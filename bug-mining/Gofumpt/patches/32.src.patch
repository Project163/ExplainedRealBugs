diff --git a/README.md b/README.md
index 7f5dcf1..2eb68e8 100644
--- a/README.md
+++ b/README.md
@@ -409,9 +409,9 @@ rely on it for your code as long as you pin a version of it.
 
 ### License
 
-Note that much of the code is copied from Go's `gofmt` and `goimports` commands.
-You can tell which files originate from the Go repository from their copyright
-headers. Their license file is `LICENSE.google`.
+Note that much of the code is copied from Go's `gofmt` command. You can tell
+which files originate from the Go repository from their copyright headers. Their
+license file is `LICENSE.google`.
 
 `gofumpt`'s original source files are also under the 3-clause BSD license, with
 the separate file `LICENSE`.
diff --git a/doc.go b/doc.go
index 2f0f4d0..0f2041a 100644
--- a/doc.go
+++ b/doc.go
@@ -3,7 +3,7 @@
 
 package main
 
-// First, sync the files with x/tools and GOROOT.
+// First, sync cmd/gofmt from GOROOT.
 //go:generate go run gen.go
 
 // Then, add the missing imports to our added code.
diff --git a/gen.go b/gen.go
index ea5244a..cadabb0 100644
--- a/gen.go
+++ b/gen.go
@@ -24,39 +24,16 @@ func main() {
 
 		// These are internal cmd dependencies. Copy them.
 		"cmd/internal/diff",
-
-		"golang.org/x/tools/cmd/goimports",
-
-		// These are internal goimports dependencies. Copy them.
-		"golang.org/x/tools/internal/event",
-		"golang.org/x/tools/internal/event/core",
-		"golang.org/x/tools/internal/event/keys",
-		"golang.org/x/tools/internal/event/label",
-		"golang.org/x/tools/internal/fastwalk",
-		"golang.org/x/tools/internal/gocommand",
-		"golang.org/x/tools/internal/gopathwalk",
-		"golang.org/x/tools/internal/imports",
-		"golang.org/x/tools/internal/module",
-		"golang.org/x/tools/internal/semver",
-		"golang.org/x/tools/internal/telemetry/event",
 	)
 	if err != nil {
 		panic(err)
 	}
 	for _, pkg := range pkgs {
-		switch pkg.ImportPath {
-		case "cmd/gofmt":
+		if pkg.ImportPath == "cmd/gofmt" {
 			copyGofmt(pkg)
-		case "golang.org/x/tools/cmd/goimports":
-			copyGoimports(pkg)
-		default:
+		} else {
 			parts := strings.Split(pkg.ImportPath, "/")
-			if parts[0] == "cmd" {
-				copyInternal(pkg, filepath.Join(parts[1:]...))
-			} else {
-				dir := filepath.Join(append([]string{"gofumports"}, parts[3:]...)...)
-				copyInternal(pkg, dir)
-			}
+			copyInternal(pkg, filepath.Join(parts[1:]...))
 		}
 	}
 }
@@ -256,8 +233,7 @@ func copyGofmt(pkg *Package) {
 		}
 		`
 	const extraFormat = `
-		// Apply gofumpt's changes before we print the code in gofmt's
-		// format.
+		// Apply gofumpt's changes before we print the code in gofmt's format.
 		` + extraSrcLangVersion + `
 		gformat.File(fileSet, file, gformat.Options{
 			LangVersion: *langVersion,
@@ -287,37 +263,6 @@ func copyGofmt(pkg *Package) {
 	}
 }
 
-func copyGoimports(pkg *Package) {
-	const extraFormat = `
-		// This is the only gofumpt change on goimports's codebase, besides changing
-		// the name in the usage text.
-		` + extraSrcLangVersion + `
-		res, err = gformat.Source(res, gformat.Options{LangVersion: *langVersion})
-		if err != nil {
-			return err
-		}
-		`
-	for _, path := range sourceFiles(pkg) {
-		body := readFile(path)
-		body = fixImports(body)
-		name := filepath.Base(path)
-		switch name {
-		case "doc.go":
-			continue // we have our own
-		case "goimports.go":
-			if i := strings.Index(body, "\t\"mvdan.cc/gofumpt"); i > 0 {
-				body = body[:i] + "\n" + extraImport + "\n" + body[i:]
-			}
-			if i := strings.Index(body, "if !bytes.Equal"); i > 0 {
-				body = body[:i] + "\n" + extraFormat + "\n" + body[i:]
-			}
-		}
-		body = strings.Replace(body, "goimports", "gofumports", -1)
-
-		writeFile(filepath.Join("gofumports", name), body)
-	}
-}
-
 func copyInternal(pkg *Package, dir string) {
 	for _, path := range sourceFiles(pkg) {
 		body := readFile(path)
@@ -328,10 +273,6 @@ func copyInternal(pkg *Package, dir string) {
 }
 
 func fixImports(body string) string {
-	body = strings.Replace(body,
-		"golang.org/x/tools/internal/",
-		"mvdan.cc/gofumpt/gofumports/internal/",
-		-1)
 	body = strings.Replace(body,
 		"cmd/internal/",
 		"mvdan.cc/gofumpt/internal/",
diff --git a/gofmt.go b/gofmt.go
index c040e77..d7a8ee4 100644
--- a/gofmt.go
+++ b/gofmt.go
@@ -122,8 +122,7 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error
 		simplify(file)
 	}
 
-	// Apply gofumpt's changes before we print the code in gofumpt's
-	// format.
+	// Apply gofumpt's changes before we print the code in gofumpt's format.
 	if *langVersion == "" {
 		out, err := exec.Command("go", "list", "-m", "-f", "{{.GoVersion}}").Output()
 		out = bytes.TrimSpace(out)
diff --git a/gofumports/flag.go b/gofumports/flag.go
deleted file mode 100644
index e4dc8ec..0000000
--- a/gofumports/flag.go
+++ /dev/null
@@ -1,8 +0,0 @@
-// Copyright (c) 2019, Daniel Mart√≠ <mvdan@mvdan.cc>
-// See LICENSE for licensing information
-
-package main
-
-import "flag"
-
-var langVersion = flag.String("lang", "", "target Go version in the form 1.X (default from go.mod)")
diff --git a/gofumports/goimports.go b/gofumports/goimports.go
deleted file mode 100644
index 0ae6ecd..0000000
--- a/gofumports/goimports.go
+++ /dev/null
@@ -1,395 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package main
-
-import (
-	"bufio"
-	"bytes"
-	"errors"
-	"flag"
-	"fmt"
-	"go/scanner"
-	"io"
-	"io/ioutil"
-	"log"
-	"os"
-	"os/exec"
-	"path/filepath"
-	"runtime"
-	"runtime/pprof"
-	"strings"
-
-	gformat "mvdan.cc/gofumpt/format"
-	"mvdan.cc/gofumpt/gofumports/internal/gocommand"
-	"mvdan.cc/gofumpt/gofumports/internal/imports"
-)
-
-var (
-	// main operation modes
-	list   = flag.Bool("l", false, "list files whose formatting differs from goimport's")
-	write  = flag.Bool("w", false, "write result to (source) file instead of stdout")
-	doDiff = flag.Bool("d", false, "display diffs instead of rewriting files")
-	srcdir = flag.String("srcdir", "", "choose imports as if source code is from `dir`. When operating on a single file, dir may instead be the complete file name.")
-
-	verbose bool // verbose logging
-
-	cpuProfile     = flag.String("cpuprofile", "", "CPU profile output")
-	memProfile     = flag.String("memprofile", "", "memory profile output")
-	memProfileRate = flag.Int("memrate", 0, "if > 0, sets runtime.MemProfileRate")
-
-	options = &imports.Options{
-		TabWidth:  8,
-		TabIndent: true,
-		Comments:  true,
-		Fragment:  true,
-		Env: &imports.ProcessEnv{
-			GocmdRunner: &gocommand.Runner{},
-		},
-	}
-	exitCode = 0
-)
-
-func init() {
-	flag.BoolVar(&options.AllErrors, "e", false, "report all errors (not just the first 10 on different lines)")
-	flag.StringVar(&options.LocalPrefix, "local", "", "put imports beginning with this string after 3rd-party packages; comma-separated list")
-	flag.BoolVar(&options.FormatOnly, "format-only", false, "if true, don't fix imports and only format. In this mode, gofumports is effectively gofmt, with the addition that imports are grouped into sections.")
-}
-
-func report(err error) {
-	scanner.PrintError(os.Stderr, err)
-	exitCode = 2
-}
-
-func usage() {
-	fmt.Fprintf(os.Stderr, "usage: gofumports [flags] [path ...]\n")
-	flag.PrintDefaults()
-	os.Exit(2)
-}
-
-func isGoFile(f os.FileInfo) bool {
-	// ignore non-Go files
-	name := f.Name()
-	return !f.IsDir() && !strings.HasPrefix(name, ".") && strings.HasSuffix(name, ".go")
-}
-
-// argumentType is which mode gofumports was invoked as.
-type argumentType int
-
-const (
-	// fromStdin means the user is piping their source into gofumports.
-	fromStdin argumentType = iota
-
-	// singleArg is the common case from editors, when gofumports is run on
-	// a single file.
-	singleArg
-
-	// multipleArg is when the user ran "gofumports file1.go file2.go"
-	// or ran gofumports on a directory tree.
-	multipleArg
-)
-
-func processFile(filename string, in io.Reader, out io.Writer, argType argumentType) error {
-	opt := options
-	if argType == fromStdin {
-		nopt := *options
-		nopt.Fragment = true
-		opt = &nopt
-	}
-
-	if in == nil {
-		f, err := os.Open(filename)
-		if err != nil {
-			return err
-		}
-		defer f.Close()
-		in = f
-	}
-
-	src, err := ioutil.ReadAll(in)
-	if err != nil {
-		return err
-	}
-
-	target := filename
-	if *srcdir != "" {
-		// Determine whether the provided -srcdirc is a directory or file
-		// and then use it to override the target.
-		//
-		// See https://github.com/dominikh/go-mode.el/issues/146
-		if isFile(*srcdir) {
-			if argType == multipleArg {
-				return errors.New("-srcdir value can't be a file when passing multiple arguments or when walking directories")
-			}
-			target = *srcdir
-		} else if argType == singleArg && strings.HasSuffix(*srcdir, ".go") && !isDir(*srcdir) {
-			// For a file which doesn't exist on disk yet, but might shortly.
-			// e.g. user in editor opens $DIR/newfile.go and newfile.go doesn't yet exist on disk.
-			// The gofumports on-save hook writes the buffer to a temp file
-			// first and runs gofumports before the actual save to newfile.go.
-			// The editor's buffer is named "newfile.go" so that is passed to gofumports as:
-			//      gofumports -srcdir=/gopath/src/pkg/newfile.go /tmp/gofmtXXXXXXXX.go
-			// and then the editor reloads the result from the tmp file and writes
-			// it to newfile.go.
-			target = *srcdir
-		} else {
-			// Pretend that file is from *srcdir in order to decide
-			// visible imports correctly.
-			target = filepath.Join(*srcdir, filepath.Base(filename))
-		}
-	}
-
-	res, err := imports.Process(target, src, opt)
-	if err != nil {
-		return err
-	}
-
-	// This is the only gofumpt change on gofumports's codebase, besides changing
-	// the name in the usage text.
-	if *langVersion == "" {
-		out, err := exec.Command("go", "list", "-m", "-f", "{{.GoVersion}}").Output()
-		out = bytes.TrimSpace(out)
-		if err == nil && len(out) > 0 {
-			*langVersion = string(out)
-		}
-	}
-	res, err = gformat.Source(res, gformat.Options{LangVersion: *langVersion})
-	if err != nil {
-		return err
-	}
-
-	if !bytes.Equal(src, res) {
-		// formatting has changed
-		if *list {
-			fmt.Fprintln(out, filename)
-		}
-		if *write {
-			if argType == fromStdin {
-				// filename is "<standard input>"
-				return errors.New("can't use -w on stdin")
-			}
-			// On Windows, we need to re-set the permissions from the file. See golang/go#38225.
-			var perms os.FileMode
-			if fi, err := os.Stat(filename); err == nil {
-				perms = fi.Mode() & os.ModePerm
-			}
-			err = ioutil.WriteFile(filename, res, perms)
-			if err != nil {
-				return err
-			}
-		}
-		if *doDiff {
-			if argType == fromStdin {
-				filename = "stdin.go" // because <standard input>.orig looks silly
-			}
-			data, err := diff(src, res, filename)
-			if err != nil {
-				return fmt.Errorf("computing diff: %s", err)
-			}
-			fmt.Printf("diff -u %s %s\n", filepath.ToSlash(filename+".orig"), filepath.ToSlash(filename))
-			out.Write(data)
-		}
-	}
-
-	if !*list && !*write && !*doDiff {
-		_, err = out.Write(res)
-	}
-
-	return err
-}
-
-func visitFile(path string, f os.FileInfo, err error) error {
-	if err == nil && isGoFile(f) {
-		err = processFile(path, nil, os.Stdout, multipleArg)
-	}
-	if err != nil {
-		report(err)
-	}
-	return nil
-}
-
-func walkDir(path string) {
-	filepath.Walk(path, visitFile)
-}
-
-func main() {
-	runtime.GOMAXPROCS(runtime.NumCPU())
-
-	// call gofmtMain in a separate function
-	// so that it can use defer and have them
-	// run before the exit.
-	gofmtMain()
-	os.Exit(exitCode)
-}
-
-// parseFlags parses command line flags and returns the paths to process.
-// It's a var so that custom implementations can replace it in other files.
-var parseFlags = func() []string {
-	flag.BoolVar(&verbose, "v", false, "verbose logging")
-
-	flag.Parse()
-	return flag.Args()
-}
-
-func bufferedFileWriter(dest string) (w io.Writer, close func()) {
-	f, err := os.Create(dest)
-	if err != nil {
-		log.Fatal(err)
-	}
-	bw := bufio.NewWriter(f)
-	return bw, func() {
-		if err := bw.Flush(); err != nil {
-			log.Fatalf("error flushing %v: %v", dest, err)
-		}
-		if err := f.Close(); err != nil {
-			log.Fatal(err)
-		}
-	}
-}
-
-func gofmtMain() {
-	flag.Usage = usage
-	paths := parseFlags()
-
-	if *cpuProfile != "" {
-		bw, flush := bufferedFileWriter(*cpuProfile)
-		pprof.StartCPUProfile(bw)
-		defer flush()
-		defer pprof.StopCPUProfile()
-	}
-	// doTrace is a conditionally compiled wrapper around runtime/trace. It is
-	// used to allow gofumports to compile under gccgo, which does not support
-	// runtime/trace. See https://golang.org/issue/15544.
-	defer doTrace()()
-	if *memProfileRate > 0 {
-		runtime.MemProfileRate = *memProfileRate
-		bw, flush := bufferedFileWriter(*memProfile)
-		defer func() {
-			runtime.GC() // materialize all statistics
-			if err := pprof.WriteHeapProfile(bw); err != nil {
-				log.Fatal(err)
-			}
-			flush()
-		}()
-	}
-
-	if verbose {
-		log.SetFlags(log.LstdFlags | log.Lmicroseconds)
-		options.Env.Logf = log.Printf
-	}
-	if options.TabWidth < 0 {
-		fmt.Fprintf(os.Stderr, "negative tabwidth %d\n", options.TabWidth)
-		exitCode = 2
-		return
-	}
-
-	if len(paths) == 0 {
-		if err := processFile("<standard input>", os.Stdin, os.Stdout, fromStdin); err != nil {
-			report(err)
-		}
-		return
-	}
-
-	argType := singleArg
-	if len(paths) > 1 {
-		argType = multipleArg
-	}
-
-	for _, path := range paths {
-		switch dir, err := os.Stat(path); {
-		case err != nil:
-			report(err)
-		case dir.IsDir():
-			walkDir(path)
-		default:
-			if err := processFile(path, nil, os.Stdout, argType); err != nil {
-				report(err)
-			}
-		}
-	}
-}
-
-func writeTempFile(dir, prefix string, data []byte) (string, error) {
-	file, err := ioutil.TempFile(dir, prefix)
-	if err != nil {
-		return "", err
-	}
-	_, err = file.Write(data)
-	if err1 := file.Close(); err == nil {
-		err = err1
-	}
-	if err != nil {
-		os.Remove(file.Name())
-		return "", err
-	}
-	return file.Name(), nil
-}
-
-func diff(b1, b2 []byte, filename string) (data []byte, err error) {
-	f1, err := writeTempFile("", "gofmt", b1)
-	if err != nil {
-		return
-	}
-	defer os.Remove(f1)
-
-	f2, err := writeTempFile("", "gofmt", b2)
-	if err != nil {
-		return
-	}
-	defer os.Remove(f2)
-
-	cmd := "diff"
-	if runtime.GOOS == "plan9" {
-		cmd = "/bin/ape/diff"
-	}
-
-	data, err = exec.Command(cmd, "-u", f1, f2).CombinedOutput()
-	if len(data) > 0 {
-		// diff exits with a non-zero status when the files don't match.
-		// Ignore that failure as long as we get output.
-		return replaceTempFilename(data, filename)
-	}
-	return
-}
-
-// replaceTempFilename replaces temporary filenames in diff with actual one.
-//
-// --- /tmp/gofmt316145376	2017-02-03 19:13:00.280468375 -0500
-// +++ /tmp/gofmt617882815	2017-02-03 19:13:00.280468375 -0500
-// ...
-// ->
-// --- path/to/file.go.orig	2017-02-03 19:13:00.280468375 -0500
-// +++ path/to/file.go	2017-02-03 19:13:00.280468375 -0500
-// ...
-func replaceTempFilename(diff []byte, filename string) ([]byte, error) {
-	bs := bytes.SplitN(diff, []byte{'\n'}, 3)
-	if len(bs) < 3 {
-		return nil, fmt.Errorf("got unexpected diff for %s", filename)
-	}
-	// Preserve timestamps.
-	var t0, t1 []byte
-	if i := bytes.LastIndexByte(bs[0], '\t'); i != -1 {
-		t0 = bs[0][i:]
-	}
-	if i := bytes.LastIndexByte(bs[1], '\t'); i != -1 {
-		t1 = bs[1][i:]
-	}
-	// Always print filepath with slash separator.
-	f := filepath.ToSlash(filename)
-	bs[0] = []byte(fmt.Sprintf("--- %s%s", f+".orig", t0))
-	bs[1] = []byte(fmt.Sprintf("+++ %s%s", f, t1))
-	return bytes.Join(bs, []byte{'\n'}), nil
-}
-
-// isFile reports whether name is a file.
-func isFile(name string) bool {
-	fi, err := os.Stat(name)
-	return err == nil && fi.Mode().IsRegular()
-}
-
-// isDir reports whether name is a directory.
-func isDir(name string) bool {
-	fi, err := os.Stat(name)
-	return err == nil && fi.IsDir()
-}
diff --git a/gofumports/goimports_gc.go b/gofumports/goimports_gc.go
deleted file mode 100644
index 21d867e..0000000
--- a/gofumports/goimports_gc.go
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build gc
-
-package main
-
-import (
-	"flag"
-	"runtime/trace"
-)
-
-var traceProfile = flag.String("trace", "", "trace profile output")
-
-func doTrace() func() {
-	if *traceProfile != "" {
-		bw, flush := bufferedFileWriter(*traceProfile)
-		trace.Start(bw)
-		return func() {
-			flush()
-			trace.Stop()
-		}
-	}
-	return func() {}
-}
diff --git a/gofumports/goimports_not_gc.go b/gofumports/goimports_not_gc.go
deleted file mode 100644
index f5531ce..0000000
--- a/gofumports/goimports_not_gc.go
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build !gc
-
-package main
-
-func doTrace() func() {
-	return func() {}
-}
diff --git a/gofumports/internal/event/core/event.go b/gofumports/internal/event/core/event.go
deleted file mode 100644
index a31fd29..0000000
--- a/gofumports/internal/event/core/event.go
+++ /dev/null
@@ -1,85 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package core provides support for event based telemetry.
-package core
-
-import (
-	"fmt"
-	"time"
-
-	"mvdan.cc/gofumpt/gofumports/internal/event/label"
-)
-
-// Event holds the information about an event of note that occurred.
-type Event struct {
-	at time.Time
-
-	// As events are often on the stack, storing the first few labels directly
-	// in the event can avoid an allocation at all for the very common cases of
-	// simple events.
-	// The length needs to be large enough to cope with the majority of events
-	// but no so large as to cause undue stack pressure.
-	// A log message with two values will use 3 labels (one for each value and
-	// one for the message itself).
-
-	static  [3]label.Label // inline storage for the first few labels
-	dynamic []label.Label  // dynamically sized storage for remaining labels
-}
-
-// eventLabelMap implements label.Map for a the labels of an Event.
-type eventLabelMap struct {
-	event Event
-}
-
-func (ev Event) At() time.Time { return ev.at }
-
-func (ev Event) Format(f fmt.State, r rune) {
-	if !ev.at.IsZero() {
-		fmt.Fprint(f, ev.at.Format("2006/01/02 15:04:05 "))
-	}
-	for index := 0; ev.Valid(index); index++ {
-		if l := ev.Label(index); l.Valid() {
-			fmt.Fprintf(f, "\n\t%v", l)
-		}
-	}
-}
-
-func (ev Event) Valid(index int) bool {
-	return index >= 0 && index < len(ev.static)+len(ev.dynamic)
-}
-
-func (ev Event) Label(index int) label.Label {
-	if index < len(ev.static) {
-		return ev.static[index]
-	}
-	return ev.dynamic[index-len(ev.static)]
-}
-
-func (ev Event) Find(key label.Key) label.Label {
-	for _, l := range ev.static {
-		if l.Key() == key {
-			return l
-		}
-	}
-	for _, l := range ev.dynamic {
-		if l.Key() == key {
-			return l
-		}
-	}
-	return label.Label{}
-}
-
-func MakeEvent(static [3]label.Label, labels []label.Label) Event {
-	return Event{
-		static:  static,
-		dynamic: labels,
-	}
-}
-
-// CloneEvent event returns a copy of the event with the time adjusted to at.
-func CloneEvent(ev Event, at time.Time) Event {
-	ev.at = at
-	return ev
-}
diff --git a/gofumports/internal/event/core/export.go b/gofumports/internal/event/core/export.go
deleted file mode 100644
index 1e69836..0000000
--- a/gofumports/internal/event/core/export.go
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package core
-
-import (
-	"context"
-	"sync/atomic"
-	"time"
-	"unsafe"
-
-	"mvdan.cc/gofumpt/gofumports/internal/event/label"
-)
-
-// Exporter is a function that handles events.
-// It may return a modified context and event.
-type Exporter func(context.Context, Event, label.Map) context.Context
-
-var exporter unsafe.Pointer
-
-// SetExporter sets the global exporter function that handles all events.
-// The exporter is called synchronously from the event call site, so it should
-// return quickly so as not to hold up user code.
-func SetExporter(e Exporter) {
-	p := unsafe.Pointer(&e)
-	if e == nil {
-		// &e is always valid, and so p is always valid, but for the early abort
-		// of ProcessEvent to be efficient it needs to make the nil check on the
-		// pointer without having to dereference it, so we make the nil function
-		// also a nil pointer
-		p = nil
-	}
-	atomic.StorePointer(&exporter, p)
-}
-
-// deliver is called to deliver an event to the supplied exporter.
-// it will fill in the time.
-func deliver(ctx context.Context, exporter Exporter, ev Event) context.Context {
-	// add the current time to the event
-	ev.at = time.Now()
-	// hand the event off to the current exporter
-	return exporter(ctx, ev, ev)
-}
-
-// Export is called to deliver an event to the global exporter if set.
-func Export(ctx context.Context, ev Event) context.Context {
-	// get the global exporter and abort early if there is not one
-	exporterPtr := (*Exporter)(atomic.LoadPointer(&exporter))
-	if exporterPtr == nil {
-		return ctx
-	}
-	return deliver(ctx, *exporterPtr, ev)
-}
-
-// ExportPair is called to deliver a start event to the supplied exporter.
-// It also returns a function that will deliver the end event to the same
-// exporter.
-// It will fill in the time.
-func ExportPair(ctx context.Context, begin, end Event) (context.Context, func()) {
-	// get the global exporter and abort early if there is not one
-	exporterPtr := (*Exporter)(atomic.LoadPointer(&exporter))
-	if exporterPtr == nil {
-		return ctx, func() {}
-	}
-	ctx = deliver(ctx, *exporterPtr, begin)
-	return ctx, func() { deliver(ctx, *exporterPtr, end) }
-}
diff --git a/gofumports/internal/event/core/fast.go b/gofumports/internal/event/core/fast.go
deleted file mode 100644
index c98c6ba..0000000
--- a/gofumports/internal/event/core/fast.go
+++ /dev/null
@@ -1,77 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package core
-
-import (
-	"context"
-
-	"mvdan.cc/gofumpt/gofumports/internal/event/keys"
-	"mvdan.cc/gofumpt/gofumports/internal/event/label"
-)
-
-// Log1 takes a message and one label delivers a log event to the exporter.
-// It is a customized version of Print that is faster and does no allocation.
-func Log1(ctx context.Context, message string, t1 label.Label) {
-	Export(ctx, MakeEvent([3]label.Label{
-		keys.Msg.Of(message),
-		t1,
-	}, nil))
-}
-
-// Log2 takes a message and two labels and delivers a log event to the exporter.
-// It is a customized version of Print that is faster and does no allocation.
-func Log2(ctx context.Context, message string, t1 label.Label, t2 label.Label) {
-	Export(ctx, MakeEvent([3]label.Label{
-		keys.Msg.Of(message),
-		t1,
-		t2,
-	}, nil))
-}
-
-// Metric1 sends a label event to the exporter with the supplied labels.
-func Metric1(ctx context.Context, t1 label.Label) context.Context {
-	return Export(ctx, MakeEvent([3]label.Label{
-		keys.Metric.New(),
-		t1,
-	}, nil))
-}
-
-// Metric2 sends a label event to the exporter with the supplied labels.
-func Metric2(ctx context.Context, t1, t2 label.Label) context.Context {
-	return Export(ctx, MakeEvent([3]label.Label{
-		keys.Metric.New(),
-		t1,
-		t2,
-	}, nil))
-}
-
-// Start1 sends a span start event with the supplied label list to the exporter.
-// It also returns a function that will end the span, which should normally be
-// deferred.
-func Start1(ctx context.Context, name string, t1 label.Label) (context.Context, func()) {
-	return ExportPair(ctx,
-		MakeEvent([3]label.Label{
-			keys.Start.Of(name),
-			t1,
-		}, nil),
-		MakeEvent([3]label.Label{
-			keys.End.New(),
-		}, nil))
-}
-
-// Start2 sends a span start event with the supplied label list to the exporter.
-// It also returns a function that will end the span, which should normally be
-// deferred.
-func Start2(ctx context.Context, name string, t1, t2 label.Label) (context.Context, func()) {
-	return ExportPair(ctx,
-		MakeEvent([3]label.Label{
-			keys.Start.Of(name),
-			t1,
-			t2,
-		}, nil),
-		MakeEvent([3]label.Label{
-			keys.End.New(),
-		}, nil))
-}
diff --git a/gofumports/internal/event/doc.go b/gofumports/internal/event/doc.go
deleted file mode 100644
index 5dc6e6b..0000000
--- a/gofumports/internal/event/doc.go
+++ /dev/null
@@ -1,7 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package event provides a set of packages that cover the main
-// concepts of telemetry in an implementation agnostic way.
-package event
diff --git a/gofumports/internal/event/event.go b/gofumports/internal/event/event.go
deleted file mode 100644
index 7083137..0000000
--- a/gofumports/internal/event/event.go
+++ /dev/null
@@ -1,127 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"context"
-
-	"mvdan.cc/gofumpt/gofumports/internal/event/core"
-	"mvdan.cc/gofumpt/gofumports/internal/event/keys"
-	"mvdan.cc/gofumpt/gofumports/internal/event/label"
-)
-
-// Exporter is a function that handles events.
-// It may return a modified context and event.
-type Exporter func(context.Context, core.Event, label.Map) context.Context
-
-// SetExporter sets the global exporter function that handles all events.
-// The exporter is called synchronously from the event call site, so it should
-// return quickly so as not to hold up user code.
-func SetExporter(e Exporter) {
-	core.SetExporter(core.Exporter(e))
-}
-
-// Log takes a message and a label list and combines them into a single event
-// before delivering them to the exporter.
-func Log(ctx context.Context, message string, labels ...label.Label) {
-	core.Export(ctx, core.MakeEvent([3]label.Label{
-		keys.Msg.Of(message),
-	}, labels))
-}
-
-// IsLog returns true if the event was built by the Log function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsLog(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.Msg
-}
-
-// Error takes a message and a label list and combines them into a single event
-// before delivering them to the exporter. It captures the error in the
-// delivered event.
-func Error(ctx context.Context, message string, err error, labels ...label.Label) {
-	core.Export(ctx, core.MakeEvent([3]label.Label{
-		keys.Msg.Of(message),
-		keys.Err.Of(err),
-	}, labels))
-}
-
-// IsError returns true if the event was built by the Error function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsError(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.Msg &&
-		ev.Label(1).Key() == keys.Err
-}
-
-// Metric sends a label event to the exporter with the supplied labels.
-func Metric(ctx context.Context, labels ...label.Label) {
-	core.Export(ctx, core.MakeEvent([3]label.Label{
-		keys.Metric.New(),
-	}, labels))
-}
-
-// IsMetric returns true if the event was built by the Metric function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsMetric(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.Metric
-}
-
-// Label sends a label event to the exporter with the supplied labels.
-func Label(ctx context.Context, labels ...label.Label) context.Context {
-	return core.Export(ctx, core.MakeEvent([3]label.Label{
-		keys.Label.New(),
-	}, labels))
-}
-
-// IsLabel returns true if the event was built by the Label function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsLabel(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.Label
-}
-
-// Start sends a span start event with the supplied label list to the exporter.
-// It also returns a function that will end the span, which should normally be
-// deferred.
-func Start(ctx context.Context, name string, labels ...label.Label) (context.Context, func()) {
-	return core.ExportPair(ctx,
-		core.MakeEvent([3]label.Label{
-			keys.Start.Of(name),
-		}, labels),
-		core.MakeEvent([3]label.Label{
-			keys.End.New(),
-		}, nil))
-}
-
-// IsStart returns true if the event was built by the Start function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsStart(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.Start
-}
-
-// IsEnd returns true if the event was built by the End function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsEnd(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.End
-}
-
-// Detach returns a context without an associated span.
-// This allows the creation of spans that are not children of the current span.
-func Detach(ctx context.Context) context.Context {
-	return core.Export(ctx, core.MakeEvent([3]label.Label{
-		keys.Detach.New(),
-	}, nil))
-}
-
-// IsDetach returns true if the event was built by the Detach function.
-// It is intended to be used in exporters to identify the semantics of the
-// event when deciding what to do with it.
-func IsDetach(ev core.Event) bool {
-	return ev.Label(0).Key() == keys.Detach
-}
diff --git a/gofumports/internal/event/keys/keys.go b/gofumports/internal/event/keys/keys.go
deleted file mode 100644
index 9025809..0000000
--- a/gofumports/internal/event/keys/keys.go
+++ /dev/null
@@ -1,564 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package keys
-
-import (
-	"fmt"
-	"io"
-	"math"
-	"strconv"
-
-	"mvdan.cc/gofumpt/gofumports/internal/event/label"
-)
-
-// Value represents a key for untyped values.
-type Value struct {
-	name        string
-	description string
-}
-
-// New creates a new Key for untyped values.
-func New(name, description string) *Value {
-	return &Value{name: name, description: description}
-}
-
-func (k *Value) Name() string        { return k.name }
-func (k *Value) Description() string { return k.description }
-
-func (k *Value) Format(w io.Writer, buf []byte, l label.Label) {
-	fmt.Fprint(w, k.From(l))
-}
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Value) Get(lm label.Map) interface{} {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return nil
-}
-
-// From can be used to get a value from a Label.
-func (k *Value) From(t label.Label) interface{} { return t.UnpackValue() }
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Value) Of(value interface{}) label.Label { return label.OfValue(k, value) }
-
-// Tag represents a key for tagging labels that have no value.
-// These are used when the existence of the label is the entire information it
-// carries, such as marking events to be of a specific kind, or from a specific
-// package.
-type Tag struct {
-	name        string
-	description string
-}
-
-// NewTag creates a new Key for tagging labels.
-func NewTag(name, description string) *Tag {
-	return &Tag{name: name, description: description}
-}
-
-func (k *Tag) Name() string        { return k.name }
-func (k *Tag) Description() string { return k.description }
-
-func (k *Tag) Format(w io.Writer, buf []byte, l label.Label) {}
-
-// New creates a new Label with this key.
-func (k *Tag) New() label.Label { return label.OfValue(k, nil) }
-
-// Int represents a key
-type Int struct {
-	name        string
-	description string
-}
-
-// NewInt creates a new Key for int values.
-func NewInt(name, description string) *Int {
-	return &Int{name: name, description: description}
-}
-
-func (k *Int) Name() string        { return k.name }
-func (k *Int) Description() string { return k.description }
-
-func (k *Int) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Int) Of(v int) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Int) Get(lm label.Map) int {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Int) From(t label.Label) int { return int(t.Unpack64()) }
-
-// Int8 represents a key
-type Int8 struct {
-	name        string
-	description string
-}
-
-// NewInt8 creates a new Key for int8 values.
-func NewInt8(name, description string) *Int8 {
-	return &Int8{name: name, description: description}
-}
-
-func (k *Int8) Name() string        { return k.name }
-func (k *Int8) Description() string { return k.description }
-
-func (k *Int8) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Int8) Of(v int8) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Int8) Get(lm label.Map) int8 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Int8) From(t label.Label) int8 { return int8(t.Unpack64()) }
-
-// Int16 represents a key
-type Int16 struct {
-	name        string
-	description string
-}
-
-// NewInt16 creates a new Key for int16 values.
-func NewInt16(name, description string) *Int16 {
-	return &Int16{name: name, description: description}
-}
-
-func (k *Int16) Name() string        { return k.name }
-func (k *Int16) Description() string { return k.description }
-
-func (k *Int16) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Int16) Of(v int16) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Int16) Get(lm label.Map) int16 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Int16) From(t label.Label) int16 { return int16(t.Unpack64()) }
-
-// Int32 represents a key
-type Int32 struct {
-	name        string
-	description string
-}
-
-// NewInt32 creates a new Key for int32 values.
-func NewInt32(name, description string) *Int32 {
-	return &Int32{name: name, description: description}
-}
-
-func (k *Int32) Name() string        { return k.name }
-func (k *Int32) Description() string { return k.description }
-
-func (k *Int32) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Int32) Of(v int32) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Int32) Get(lm label.Map) int32 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Int32) From(t label.Label) int32 { return int32(t.Unpack64()) }
-
-// Int64 represents a key
-type Int64 struct {
-	name        string
-	description string
-}
-
-// NewInt64 creates a new Key for int64 values.
-func NewInt64(name, description string) *Int64 {
-	return &Int64{name: name, description: description}
-}
-
-func (k *Int64) Name() string        { return k.name }
-func (k *Int64) Description() string { return k.description }
-
-func (k *Int64) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendInt(buf, k.From(l), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Int64) Of(v int64) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Int64) Get(lm label.Map) int64 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Int64) From(t label.Label) int64 { return int64(t.Unpack64()) }
-
-// UInt represents a key
-type UInt struct {
-	name        string
-	description string
-}
-
-// NewUInt creates a new Key for uint values.
-func NewUInt(name, description string) *UInt {
-	return &UInt{name: name, description: description}
-}
-
-func (k *UInt) Name() string        { return k.name }
-func (k *UInt) Description() string { return k.description }
-
-func (k *UInt) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *UInt) Of(v uint) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *UInt) Get(lm label.Map) uint {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *UInt) From(t label.Label) uint { return uint(t.Unpack64()) }
-
-// UInt8 represents a key
-type UInt8 struct {
-	name        string
-	description string
-}
-
-// NewUInt8 creates a new Key for uint8 values.
-func NewUInt8(name, description string) *UInt8 {
-	return &UInt8{name: name, description: description}
-}
-
-func (k *UInt8) Name() string        { return k.name }
-func (k *UInt8) Description() string { return k.description }
-
-func (k *UInt8) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *UInt8) Of(v uint8) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *UInt8) Get(lm label.Map) uint8 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *UInt8) From(t label.Label) uint8 { return uint8(t.Unpack64()) }
-
-// UInt16 represents a key
-type UInt16 struct {
-	name        string
-	description string
-}
-
-// NewUInt16 creates a new Key for uint16 values.
-func NewUInt16(name, description string) *UInt16 {
-	return &UInt16{name: name, description: description}
-}
-
-func (k *UInt16) Name() string        { return k.name }
-func (k *UInt16) Description() string { return k.description }
-
-func (k *UInt16) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *UInt16) Of(v uint16) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *UInt16) Get(lm label.Map) uint16 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *UInt16) From(t label.Label) uint16 { return uint16(t.Unpack64()) }
-
-// UInt32 represents a key
-type UInt32 struct {
-	name        string
-	description string
-}
-
-// NewUInt32 creates a new Key for uint32 values.
-func NewUInt32(name, description string) *UInt32 {
-	return &UInt32{name: name, description: description}
-}
-
-func (k *UInt32) Name() string        { return k.name }
-func (k *UInt32) Description() string { return k.description }
-
-func (k *UInt32) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(l)), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *UInt32) Of(v uint32) label.Label { return label.Of64(k, uint64(v)) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *UInt32) Get(lm label.Map) uint32 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *UInt32) From(t label.Label) uint32 { return uint32(t.Unpack64()) }
-
-// UInt64 represents a key
-type UInt64 struct {
-	name        string
-	description string
-}
-
-// NewUInt64 creates a new Key for uint64 values.
-func NewUInt64(name, description string) *UInt64 {
-	return &UInt64{name: name, description: description}
-}
-
-func (k *UInt64) Name() string        { return k.name }
-func (k *UInt64) Description() string { return k.description }
-
-func (k *UInt64) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendUint(buf, k.From(l), 10))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *UInt64) Of(v uint64) label.Label { return label.Of64(k, v) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *UInt64) Get(lm label.Map) uint64 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *UInt64) From(t label.Label) uint64 { return t.Unpack64() }
-
-// Float32 represents a key
-type Float32 struct {
-	name        string
-	description string
-}
-
-// NewFloat32 creates a new Key for float32 values.
-func NewFloat32(name, description string) *Float32 {
-	return &Float32{name: name, description: description}
-}
-
-func (k *Float32) Name() string        { return k.name }
-func (k *Float32) Description() string { return k.description }
-
-func (k *Float32) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendFloat(buf, float64(k.From(l)), 'E', -1, 32))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Float32) Of(v float32) label.Label {
-	return label.Of64(k, uint64(math.Float32bits(v)))
-}
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Float32) Get(lm label.Map) float32 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Float32) From(t label.Label) float32 {
-	return math.Float32frombits(uint32(t.Unpack64()))
-}
-
-// Float64 represents a key
-type Float64 struct {
-	name        string
-	description string
-}
-
-// NewFloat64 creates a new Key for int64 values.
-func NewFloat64(name, description string) *Float64 {
-	return &Float64{name: name, description: description}
-}
-
-func (k *Float64) Name() string        { return k.name }
-func (k *Float64) Description() string { return k.description }
-
-func (k *Float64) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendFloat(buf, k.From(l), 'E', -1, 64))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Float64) Of(v float64) label.Label {
-	return label.Of64(k, math.Float64bits(v))
-}
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Float64) Get(lm label.Map) float64 {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Label.
-func (k *Float64) From(t label.Label) float64 {
-	return math.Float64frombits(t.Unpack64())
-}
-
-// String represents a key
-type String struct {
-	name        string
-	description string
-}
-
-// NewString creates a new Key for int64 values.
-func NewString(name, description string) *String {
-	return &String{name: name, description: description}
-}
-
-func (k *String) Name() string        { return k.name }
-func (k *String) Description() string { return k.description }
-
-func (k *String) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendQuote(buf, k.From(l)))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *String) Of(v string) label.Label { return label.OfString(k, v) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *String) Get(lm label.Map) string {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return ""
-}
-
-// From can be used to get a value from a Label.
-func (k *String) From(t label.Label) string { return t.UnpackString() }
-
-// Boolean represents a key
-type Boolean struct {
-	name        string
-	description string
-}
-
-// NewBoolean creates a new Key for bool values.
-func NewBoolean(name, description string) *Boolean {
-	return &Boolean{name: name, description: description}
-}
-
-func (k *Boolean) Name() string        { return k.name }
-func (k *Boolean) Description() string { return k.description }
-
-func (k *Boolean) Format(w io.Writer, buf []byte, l label.Label) {
-	w.Write(strconv.AppendBool(buf, k.From(l)))
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Boolean) Of(v bool) label.Label {
-	if v {
-		return label.Of64(k, 1)
-	}
-	return label.Of64(k, 0)
-}
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Boolean) Get(lm label.Map) bool {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return false
-}
-
-// From can be used to get a value from a Label.
-func (k *Boolean) From(t label.Label) bool { return t.Unpack64() > 0 }
-
-// Error represents a key
-type Error struct {
-	name        string
-	description string
-}
-
-// NewError creates a new Key for int64 values.
-func NewError(name, description string) *Error {
-	return &Error{name: name, description: description}
-}
-
-func (k *Error) Name() string        { return k.name }
-func (k *Error) Description() string { return k.description }
-
-func (k *Error) Format(w io.Writer, buf []byte, l label.Label) {
-	io.WriteString(w, k.From(l).Error())
-}
-
-// Of creates a new Label with this key and the supplied value.
-func (k *Error) Of(v error) label.Label { return label.OfValue(k, v) }
-
-// Get can be used to get a label for the key from a label.Map.
-func (k *Error) Get(lm label.Map) error {
-	if t := lm.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return nil
-}
-
-// From can be used to get a value from a Label.
-func (k *Error) From(t label.Label) error {
-	err, _ := t.UnpackValue().(error)
-	return err
-}
diff --git a/gofumports/internal/event/keys/standard.go b/gofumports/internal/event/keys/standard.go
deleted file mode 100644
index 7e95866..0000000
--- a/gofumports/internal/event/keys/standard.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package keys
-
-var (
-	// Msg is a key used to add message strings to label lists.
-	Msg = NewString("message", "a readable message")
-	// Label is a key used to indicate an event adds labels to the context.
-	Label = NewTag("label", "a label context marker")
-	// Start is used for things like traces that have a name.
-	Start = NewString("start", "span start")
-	// Metric is a key used to indicate an event records metrics.
-	End = NewTag("end", "a span end marker")
-	// Metric is a key used to indicate an event records metrics.
-	Detach = NewTag("detach", "a span detach marker")
-	// Err is a key used to add error values to label lists.
-	Err = NewError("error", "an error that occurred")
-	// Metric is a key used to indicate an event records metrics.
-	Metric = NewTag("metric", "a metric event marker")
-)
diff --git a/gofumports/internal/event/label/label.go b/gofumports/internal/event/label/label.go
deleted file mode 100644
index b55c12e..0000000
--- a/gofumports/internal/event/label/label.go
+++ /dev/null
@@ -1,213 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package label
-
-import (
-	"fmt"
-	"io"
-	"reflect"
-	"unsafe"
-)
-
-// Key is used as the identity of a Label.
-// Keys are intended to be compared by pointer only, the name should be unique
-// for communicating with external systems, but it is not required or enforced.
-type Key interface {
-	// Name returns the key name.
-	Name() string
-	// Description returns a string that can be used to describe the value.
-	Description() string
-
-	// Format is used in formatting to append the value of the label to the
-	// supplied buffer.
-	// The formatter may use the supplied buf as a scratch area to avoid
-	// allocations.
-	Format(w io.Writer, buf []byte, l Label)
-}
-
-// Label holds a key and value pair.
-// It is normally used when passing around lists of labels.
-type Label struct {
-	key     Key
-	packed  uint64
-	untyped interface{}
-}
-
-// Map is the interface to a collection of Labels indexed by key.
-type Map interface {
-	// Find returns the label that matches the supplied key.
-	Find(key Key) Label
-}
-
-// List is the interface to something that provides an iterable
-// list of labels.
-// Iteration should start from 0 and continue until Valid returns false.
-type List interface {
-	// Valid returns true if the index is within range for the list.
-	// It does not imply the label at that index will itself be valid.
-	Valid(index int) bool
-	// Label returns the label at the given index.
-	Label(index int) Label
-}
-
-// list implements LabelList for a list of Labels.
-type list struct {
-	labels []Label
-}
-
-// filter wraps a LabelList filtering out specific labels.
-type filter struct {
-	keys       []Key
-	underlying List
-}
-
-// listMap implements LabelMap for a simple list of labels.
-type listMap struct {
-	labels []Label
-}
-
-// mapChain implements LabelMap for a list of underlying LabelMap.
-type mapChain struct {
-	maps []Map
-}
-
-// OfValue creates a new label from the key and value.
-// This method is for implementing new key types, label creation should
-// normally be done with the Of method of the key.
-func OfValue(k Key, value interface{}) Label { return Label{key: k, untyped: value} }
-
-// UnpackValue assumes the label was built using LabelOfValue and returns the value
-// that was passed to that constructor.
-// This method is for implementing new key types, for type safety normal
-// access should be done with the From method of the key.
-func (t Label) UnpackValue() interface{} { return t.untyped }
-
-// Of64 creates a new label from a key and a uint64. This is often
-// used for non uint64 values that can be packed into a uint64.
-// This method is for implementing new key types, label creation should
-// normally be done with the Of method of the key.
-func Of64(k Key, v uint64) Label { return Label{key: k, packed: v} }
-
-// Unpack64 assumes the label was built using LabelOf64 and returns the value that
-// was passed to that constructor.
-// This method is for implementing new key types, for type safety normal
-// access should be done with the From method of the key.
-func (t Label) Unpack64() uint64 { return t.packed }
-
-// OfString creates a new label from a key and a string.
-// This method is for implementing new key types, label creation should
-// normally be done with the Of method of the key.
-func OfString(k Key, v string) Label {
-	hdr := (*reflect.StringHeader)(unsafe.Pointer(&v))
-	return Label{
-		key:     k,
-		packed:  uint64(hdr.Len),
-		untyped: unsafe.Pointer(hdr.Data),
-	}
-}
-
-// UnpackString assumes the label was built using LabelOfString and returns the
-// value that was passed to that constructor.
-// This method is for implementing new key types, for type safety normal
-// access should be done with the From method of the key.
-func (t Label) UnpackString() string {
-	var v string
-	hdr := (*reflect.StringHeader)(unsafe.Pointer(&v))
-	hdr.Data = uintptr(t.untyped.(unsafe.Pointer))
-	hdr.Len = int(t.packed)
-	return *(*string)(unsafe.Pointer(hdr))
-}
-
-// Valid returns true if the Label is a valid one (it has a key).
-func (t Label) Valid() bool { return t.key != nil }
-
-// Key returns the key of this Label.
-func (t Label) Key() Key { return t.key }
-
-// Format is used for debug printing of labels.
-func (t Label) Format(f fmt.State, r rune) {
-	if !t.Valid() {
-		io.WriteString(f, `nil`)
-		return
-	}
-	io.WriteString(f, t.Key().Name())
-	io.WriteString(f, "=")
-	var buf [128]byte
-	t.Key().Format(f, buf[:0], t)
-}
-
-func (l *list) Valid(index int) bool {
-	return index >= 0 && index < len(l.labels)
-}
-
-func (l *list) Label(index int) Label {
-	return l.labels[index]
-}
-
-func (f *filter) Valid(index int) bool {
-	return f.underlying.Valid(index)
-}
-
-func (f *filter) Label(index int) Label {
-	l := f.underlying.Label(index)
-	for _, f := range f.keys {
-		if l.Key() == f {
-			return Label{}
-		}
-	}
-	return l
-}
-
-func (lm listMap) Find(key Key) Label {
-	for _, l := range lm.labels {
-		if l.Key() == key {
-			return l
-		}
-	}
-	return Label{}
-}
-
-func (c mapChain) Find(key Key) Label {
-	for _, src := range c.maps {
-		l := src.Find(key)
-		if l.Valid() {
-			return l
-		}
-	}
-	return Label{}
-}
-
-var emptyList = &list{}
-
-func NewList(labels ...Label) List {
-	if len(labels) == 0 {
-		return emptyList
-	}
-	return &list{labels: labels}
-}
-
-func Filter(l List, keys ...Key) List {
-	if len(keys) == 0 {
-		return l
-	}
-	return &filter{keys: keys, underlying: l}
-}
-
-func NewMap(labels ...Label) Map {
-	return listMap{labels: labels}
-}
-
-func MergeMaps(srcs ...Map) Map {
-	var nonNil []Map
-	for _, src := range srcs {
-		if src != nil {
-			nonNil = append(nonNil, src)
-		}
-	}
-	if len(nonNil) == 1 {
-		return nonNil[0]
-	}
-	return mapChain{maps: nonNil}
-}
diff --git a/gofumports/internal/fastwalk/fastwalk.go b/gofumports/internal/fastwalk/fastwalk.go
deleted file mode 100644
index 9887f7e..0000000
--- a/gofumports/internal/fastwalk/fastwalk.go
+++ /dev/null
@@ -1,196 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package fastwalk provides a faster version of filepath.Walk for file system
-// scanning tools.
-package fastwalk
-
-import (
-	"errors"
-	"os"
-	"path/filepath"
-	"runtime"
-	"sync"
-)
-
-// ErrTraverseLink is used as a return value from WalkFuncs to indicate that the
-// symlink named in the call may be traversed.
-var ErrTraverseLink = errors.New("fastwalk: traverse symlink, assuming target is a directory")
-
-// ErrSkipFiles is a used as a return value from WalkFuncs to indicate that the
-// callback should not be called for any other files in the current directory.
-// Child directories will still be traversed.
-var ErrSkipFiles = errors.New("fastwalk: skip remaining files in directory")
-
-// Walk is a faster implementation of filepath.Walk.
-//
-// filepath.Walk's design necessarily calls os.Lstat on each file,
-// even if the caller needs less info.
-// Many tools need only the type of each file.
-// On some platforms, this information is provided directly by the readdir
-// system call, avoiding the need to stat each file individually.
-// fastwalk_unix.go contains a fork of the syscall routines.
-//
-// See golang.org/issue/16399
-//
-// Walk walks the file tree rooted at root, calling walkFn for
-// each file or directory in the tree, including root.
-//
-// If fastWalk returns filepath.SkipDir, the directory is skipped.
-//
-// Unlike filepath.Walk:
-//   * file stat calls must be done by the user.
-//     The only provided metadata is the file type, which does not include
-//     any permission bits.
-//   * multiple goroutines stat the filesystem concurrently. The provided
-//     walkFn must be safe for concurrent use.
-//   * fastWalk can follow symlinks if walkFn returns the TraverseLink
-//     sentinel error. It is the walkFn's responsibility to prevent
-//     fastWalk from going into symlink cycles.
-func Walk(root string, walkFn func(path string, typ os.FileMode) error) error {
-	// TODO(bradfitz): make numWorkers configurable? We used a
-	// minimum of 4 to give the kernel more info about multiple
-	// things we want, in hopes its I/O scheduling can take
-	// advantage of that. Hopefully most are in cache. Maybe 4 is
-	// even too low of a minimum. Profile more.
-	numWorkers := 4
-	if n := runtime.NumCPU(); n > numWorkers {
-		numWorkers = n
-	}
-
-	// Make sure to wait for all workers to finish, otherwise
-	// walkFn could still be called after returning. This Wait call
-	// runs after close(e.donec) below.
-	var wg sync.WaitGroup
-	defer wg.Wait()
-
-	w := &walker{
-		fn:       walkFn,
-		enqueuec: make(chan walkItem, numWorkers), // buffered for performance
-		workc:    make(chan walkItem, numWorkers), // buffered for performance
-		donec:    make(chan struct{}),
-
-		// buffered for correctness & not leaking goroutines:
-		resc: make(chan error, numWorkers),
-	}
-	defer close(w.donec)
-
-	for i := 0; i < numWorkers; i++ {
-		wg.Add(1)
-		go w.doWork(&wg)
-	}
-	todo := []walkItem{{dir: root}}
-	out := 0
-	for {
-		workc := w.workc
-		var workItem walkItem
-		if len(todo) == 0 {
-			workc = nil
-		} else {
-			workItem = todo[len(todo)-1]
-		}
-		select {
-		case workc <- workItem:
-			todo = todo[:len(todo)-1]
-			out++
-		case it := <-w.enqueuec:
-			todo = append(todo, it)
-		case err := <-w.resc:
-			out--
-			if err != nil {
-				return err
-			}
-			if out == 0 && len(todo) == 0 {
-				// It's safe to quit here, as long as the buffered
-				// enqueue channel isn't also readable, which might
-				// happen if the worker sends both another unit of
-				// work and its result before the other select was
-				// scheduled and both w.resc and w.enqueuec were
-				// readable.
-				select {
-				case it := <-w.enqueuec:
-					todo = append(todo, it)
-				default:
-					return nil
-				}
-			}
-		}
-	}
-}
-
-// doWork reads directories as instructed (via workc) and runs the
-// user's callback function.
-func (w *walker) doWork(wg *sync.WaitGroup) {
-	defer wg.Done()
-	for {
-		select {
-		case <-w.donec:
-			return
-		case it := <-w.workc:
-			select {
-			case <-w.donec:
-				return
-			case w.resc <- w.walk(it.dir, !it.callbackDone):
-			}
-		}
-	}
-}
-
-type walker struct {
-	fn func(path string, typ os.FileMode) error
-
-	donec    chan struct{} // closed on fastWalk's return
-	workc    chan walkItem // to workers
-	enqueuec chan walkItem // from workers
-	resc     chan error    // from workers
-}
-
-type walkItem struct {
-	dir          string
-	callbackDone bool // callback already called; don't do it again
-}
-
-func (w *walker) enqueue(it walkItem) {
-	select {
-	case w.enqueuec <- it:
-	case <-w.donec:
-	}
-}
-
-func (w *walker) onDirEnt(dirName, baseName string, typ os.FileMode) error {
-	joined := dirName + string(os.PathSeparator) + baseName
-	if typ == os.ModeDir {
-		w.enqueue(walkItem{dir: joined})
-		return nil
-	}
-
-	err := w.fn(joined, typ)
-	if typ == os.ModeSymlink {
-		if err == ErrTraverseLink {
-			// Set callbackDone so we don't call it twice for both the
-			// symlink-as-symlink and the symlink-as-directory later:
-			w.enqueue(walkItem{dir: joined, callbackDone: true})
-			return nil
-		}
-		if err == filepath.SkipDir {
-			// Permit SkipDir on symlinks too.
-			return nil
-		}
-	}
-	return err
-}
-
-func (w *walker) walk(root string, runUserCallback bool) error {
-	if runUserCallback {
-		err := w.fn(root, os.ModeDir)
-		if err == filepath.SkipDir {
-			return nil
-		}
-		if err != nil {
-			return err
-		}
-	}
-
-	return readDir(root, w.onDirEnt)
-}
diff --git a/gofumports/internal/fastwalk/fastwalk_dirent_fileno.go b/gofumports/internal/fastwalk/fastwalk_dirent_fileno.go
deleted file mode 100644
index ccffec5..0000000
--- a/gofumports/internal/fastwalk/fastwalk_dirent_fileno.go
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build freebsd openbsd netbsd
-
-package fastwalk
-
-import "syscall"
-
-func direntInode(dirent *syscall.Dirent) uint64 {
-	return uint64(dirent.Fileno)
-}
diff --git a/gofumports/internal/fastwalk/fastwalk_dirent_ino.go b/gofumports/internal/fastwalk/fastwalk_dirent_ino.go
deleted file mode 100644
index ab7fbc0..0000000
--- a/gofumports/internal/fastwalk/fastwalk_dirent_ino.go
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux darwin
-// +build !appengine
-
-package fastwalk
-
-import "syscall"
-
-func direntInode(dirent *syscall.Dirent) uint64 {
-	return uint64(dirent.Ino)
-}
diff --git a/gofumports/internal/fastwalk/fastwalk_dirent_namlen_bsd.go b/gofumports/internal/fastwalk/fastwalk_dirent_namlen_bsd.go
deleted file mode 100644
index a3b26a7..0000000
--- a/gofumports/internal/fastwalk/fastwalk_dirent_namlen_bsd.go
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build darwin freebsd openbsd netbsd
-
-package fastwalk
-
-import "syscall"
-
-func direntNamlen(dirent *syscall.Dirent) uint64 {
-	return uint64(dirent.Namlen)
-}
diff --git a/gofumports/internal/fastwalk/fastwalk_dirent_namlen_linux.go b/gofumports/internal/fastwalk/fastwalk_dirent_namlen_linux.go
deleted file mode 100644
index e880d35..0000000
--- a/gofumports/internal/fastwalk/fastwalk_dirent_namlen_linux.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux
-// +build !appengine
-
-package fastwalk
-
-import (
-	"bytes"
-	"syscall"
-	"unsafe"
-)
-
-func direntNamlen(dirent *syscall.Dirent) uint64 {
-	const fixedHdr = uint16(unsafe.Offsetof(syscall.Dirent{}.Name))
-	nameBuf := (*[unsafe.Sizeof(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
-	const nameBufLen = uint16(len(nameBuf))
-	limit := dirent.Reclen - fixedHdr
-	if limit > nameBufLen {
-		limit = nameBufLen
-	}
-	nameLen := bytes.IndexByte(nameBuf[:limit], 0)
-	if nameLen < 0 {
-		panic("failed to find terminating 0 byte in dirent")
-	}
-	return uint64(nameLen)
-}
diff --git a/gofumports/internal/fastwalk/fastwalk_portable.go b/gofumports/internal/fastwalk/fastwalk_portable.go
deleted file mode 100644
index b0d6327..0000000
--- a/gofumports/internal/fastwalk/fastwalk_portable.go
+++ /dev/null
@@ -1,37 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build appengine !linux,!darwin,!freebsd,!openbsd,!netbsd
-
-package fastwalk
-
-import (
-	"io/ioutil"
-	"os"
-)
-
-// readDir calls fn for each directory entry in dirName.
-// It does not descend into directories or follow symlinks.
-// If fn returns a non-nil error, readDir returns with that error
-// immediately.
-func readDir(dirName string, fn func(dirName, entName string, typ os.FileMode) error) error {
-	fis, err := ioutil.ReadDir(dirName)
-	if err != nil {
-		return err
-	}
-	skipFiles := false
-	for _, fi := range fis {
-		if fi.Mode().IsRegular() && skipFiles {
-			continue
-		}
-		if err := fn(dirName, fi.Name(), fi.Mode()&os.ModeType); err != nil {
-			if err == ErrSkipFiles {
-				skipFiles = true
-				continue
-			}
-			return err
-		}
-	}
-	return nil
-}
diff --git a/gofumports/internal/fastwalk/fastwalk_unix.go b/gofumports/internal/fastwalk/fastwalk_unix.go
deleted file mode 100644
index 5901a8f..0000000
--- a/gofumports/internal/fastwalk/fastwalk_unix.go
+++ /dev/null
@@ -1,128 +0,0 @@
-// Copyright 2016 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// +build linux darwin freebsd openbsd netbsd
-// +build !appengine
-
-package fastwalk
-
-import (
-	"fmt"
-	"os"
-	"syscall"
-	"unsafe"
-)
-
-const blockSize = 8 << 10
-
-// unknownFileMode is a sentinel (and bogus) os.FileMode
-// value used to represent a syscall.DT_UNKNOWN Dirent.Type.
-const unknownFileMode os.FileMode = os.ModeNamedPipe | os.ModeSocket | os.ModeDevice
-
-func readDir(dirName string, fn func(dirName, entName string, typ os.FileMode) error) error {
-	fd, err := syscall.Open(dirName, 0, 0)
-	if err != nil {
-		return &os.PathError{Op: "open", Path: dirName, Err: err}
-	}
-	defer syscall.Close(fd)
-
-	// The buffer must be at least a block long.
-	buf := make([]byte, blockSize) // stack-allocated; doesn't escape
-	bufp := 0                      // starting read position in buf
-	nbuf := 0                      // end valid data in buf
-	skipFiles := false
-	for {
-		if bufp >= nbuf {
-			bufp = 0
-			nbuf, err = syscall.ReadDirent(fd, buf)
-			if err != nil {
-				return os.NewSyscallError("readdirent", err)
-			}
-			if nbuf <= 0 {
-				return nil
-			}
-		}
-		consumed, name, typ := parseDirEnt(buf[bufp:nbuf])
-		bufp += consumed
-		if name == "" || name == "." || name == ".." {
-			continue
-		}
-		// Fallback for filesystems (like old XFS) that don't
-		// support Dirent.Type and have DT_UNKNOWN (0) there
-		// instead.
-		if typ == unknownFileMode {
-			fi, err := os.Lstat(dirName + "/" + name)
-			if err != nil {
-				// It got deleted in the meantime.
-				if os.IsNotExist(err) {
-					continue
-				}
-				return err
-			}
-			typ = fi.Mode() & os.ModeType
-		}
-		if skipFiles && typ.IsRegular() {
-			continue
-		}
-		if err := fn(dirName, name, typ); err != nil {
-			if err == ErrSkipFiles {
-				skipFiles = true
-				continue
-			}
-			return err
-		}
-	}
-}
-
-func parseDirEnt(buf []byte) (consumed int, name string, typ os.FileMode) {
-	// golang.org/issue/37269
-	dirent := &syscall.Dirent{}
-	copy((*[unsafe.Sizeof(syscall.Dirent{})]byte)(unsafe.Pointer(dirent))[:], buf)
-	if v := unsafe.Offsetof(dirent.Reclen) + unsafe.Sizeof(dirent.Reclen); uintptr(len(buf)) < v {
-		panic(fmt.Sprintf("buf size of %d smaller than dirent header size %d", len(buf), v))
-	}
-	if len(buf) < int(dirent.Reclen) {
-		panic(fmt.Sprintf("buf size %d < record length %d", len(buf), dirent.Reclen))
-	}
-	consumed = int(dirent.Reclen)
-	if direntInode(dirent) == 0 { // File absent in directory.
-		return
-	}
-	switch dirent.Type {
-	case syscall.DT_REG:
-		typ = 0
-	case syscall.DT_DIR:
-		typ = os.ModeDir
-	case syscall.DT_LNK:
-		typ = os.ModeSymlink
-	case syscall.DT_BLK:
-		typ = os.ModeDevice
-	case syscall.DT_FIFO:
-		typ = os.ModeNamedPipe
-	case syscall.DT_SOCK:
-		typ = os.ModeSocket
-	case syscall.DT_UNKNOWN:
-		typ = unknownFileMode
-	default:
-		// Skip weird things.
-		// It's probably a DT_WHT (http://lwn.net/Articles/325369/)
-		// or something. Revisit if/when this package is moved outside
-		// of goimports. goimports only cares about regular files,
-		// symlinks, and directories.
-		return
-	}
-
-	nameBuf := (*[unsafe.Sizeof(dirent.Name)]byte)(unsafe.Pointer(&dirent.Name[0]))
-	nameLen := direntNamlen(dirent)
-
-	// Special cases for common things:
-	if nameLen == 1 && nameBuf[0] == '.' {
-		name = "."
-	} else if nameLen == 2 && nameBuf[0] == '.' && nameBuf[1] == '.' {
-		name = ".."
-	} else {
-		name = string(nameBuf[:nameLen])
-	}
-	return
-}
diff --git a/gofumports/internal/gocommand/invoke.go b/gofumports/internal/gocommand/invoke.go
deleted file mode 100644
index fe8c1ec..0000000
--- a/gofumports/internal/gocommand/invoke.go
+++ /dev/null
@@ -1,273 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package gocommand is a helper for calling the go command.
-package gocommand
-
-import (
-	"bytes"
-	"context"
-	"fmt"
-	"io"
-	"os"
-	"os/exec"
-	"regexp"
-	"strconv"
-	"strings"
-	"sync"
-	"time"
-
-	"mvdan.cc/gofumpt/gofumports/internal/event"
-)
-
-// An Runner will run go command invocations and serialize
-// them if it sees a concurrency error.
-type Runner struct {
-	// once guards the runner initialization.
-	once sync.Once
-
-	// inFlight tracks available workers.
-	inFlight chan struct{}
-
-	// serialized guards the ability to run a go command serially,
-	// to avoid deadlocks when claiming workers.
-	serialized chan struct{}
-}
-
-const maxInFlight = 10
-
-func (runner *Runner) initialize() {
-	runner.once.Do(func() {
-		runner.inFlight = make(chan struct{}, maxInFlight)
-		runner.serialized = make(chan struct{}, 1)
-	})
-}
-
-// 1.13: go: updates to go.mod needed, but contents have changed
-// 1.14: go: updating go.mod: existing contents have changed since last read
-var modConcurrencyError = regexp.MustCompile(`go:.*go.mod.*contents have changed`)
-
-// Run is a convenience wrapper around RunRaw.
-// It returns only stdout and a "friendly" error.
-func (runner *Runner) Run(ctx context.Context, inv Invocation) (*bytes.Buffer, error) {
-	stdout, _, friendly, _ := runner.RunRaw(ctx, inv)
-	return stdout, friendly
-}
-
-// RunPiped runs the invocation serially, always waiting for any concurrent
-// invocations to complete first.
-func (runner *Runner) RunPiped(ctx context.Context, inv Invocation, stdout, stderr io.Writer) error {
-	_, err := runner.runPiped(ctx, inv, stdout, stderr)
-	return err
-}
-
-// RunRaw runs the invocation, serializing requests only if they fight over
-// go.mod changes.
-func (runner *Runner) RunRaw(ctx context.Context, inv Invocation) (*bytes.Buffer, *bytes.Buffer, error, error) {
-	// Make sure the runner is always initialized.
-	runner.initialize()
-
-	// First, try to run the go command concurrently.
-	stdout, stderr, friendlyErr, err := runner.runConcurrent(ctx, inv)
-
-	// If we encounter a load concurrency error, we need to retry serially.
-	if friendlyErr == nil || !modConcurrencyError.MatchString(friendlyErr.Error()) {
-		return stdout, stderr, friendlyErr, err
-	}
-	event.Error(ctx, "Load concurrency error, will retry serially", err)
-
-	// Run serially by calling runPiped.
-	stdout.Reset()
-	stderr.Reset()
-	friendlyErr, err = runner.runPiped(ctx, inv, stdout, stderr)
-	return stdout, stderr, friendlyErr, err
-}
-
-func (runner *Runner) runConcurrent(ctx context.Context, inv Invocation) (*bytes.Buffer, *bytes.Buffer, error, error) {
-	// Wait for 1 worker to become available.
-	select {
-	case <-ctx.Done():
-		return nil, nil, nil, ctx.Err()
-	case runner.inFlight <- struct{}{}:
-		defer func() { <-runner.inFlight }()
-	}
-
-	stdout, stderr := &bytes.Buffer{}, &bytes.Buffer{}
-	friendlyErr, err := inv.runWithFriendlyError(ctx, stdout, stderr)
-	return stdout, stderr, friendlyErr, err
-}
-
-func (runner *Runner) runPiped(ctx context.Context, inv Invocation, stdout, stderr io.Writer) (error, error) {
-	// Make sure the runner is always initialized.
-	runner.initialize()
-
-	// Acquire the serialization lock. This avoids deadlocks between two
-	// runPiped commands.
-	select {
-	case <-ctx.Done():
-		return nil, ctx.Err()
-	case runner.serialized <- struct{}{}:
-		defer func() { <-runner.serialized }()
-	}
-
-	// Wait for all in-progress go commands to return before proceeding,
-	// to avoid load concurrency errors.
-	for i := 0; i < maxInFlight; i++ {
-		select {
-		case <-ctx.Done():
-			return nil, ctx.Err()
-		case runner.inFlight <- struct{}{}:
-			// Make sure we always "return" any workers we took.
-			defer func() { <-runner.inFlight }()
-		}
-	}
-
-	return inv.runWithFriendlyError(ctx, stdout, stderr)
-}
-
-// An Invocation represents a call to the go command.
-type Invocation struct {
-	Verb       string
-	Args       []string
-	BuildFlags []string
-	ModFlag    string
-	ModFile    string
-	Overlay    string
-	// If CleanEnv is set, the invocation will run only with the environment
-	// in Env, not starting with os.Environ.
-	CleanEnv   bool
-	Env        []string
-	WorkingDir string
-	Logf       func(format string, args ...interface{})
-}
-
-func (i *Invocation) runWithFriendlyError(ctx context.Context, stdout, stderr io.Writer) (friendlyError error, rawError error) {
-	rawError = i.run(ctx, stdout, stderr)
-	if rawError != nil {
-		friendlyError = rawError
-		// Check for 'go' executable not being found.
-		if ee, ok := rawError.(*exec.Error); ok && ee.Err == exec.ErrNotFound {
-			friendlyError = fmt.Errorf("go command required, not found: %v", ee)
-		}
-		if ctx.Err() != nil {
-			friendlyError = ctx.Err()
-		}
-		friendlyError = fmt.Errorf("err: %v: stderr: %s", friendlyError, stderr)
-	}
-	return
-}
-
-func (i *Invocation) run(ctx context.Context, stdout, stderr io.Writer) error {
-	log := i.Logf
-	if log == nil {
-		log = func(string, ...interface{}) {}
-	}
-
-	goArgs := []string{i.Verb}
-
-	appendModFile := func() {
-		if i.ModFile != "" {
-			goArgs = append(goArgs, "-modfile="+i.ModFile)
-		}
-	}
-	appendModFlag := func() {
-		if i.ModFlag != "" {
-			goArgs = append(goArgs, "-mod="+i.ModFlag)
-		}
-	}
-	appendOverlayFlag := func() {
-		if i.Overlay != "" {
-			goArgs = append(goArgs, "-overlay="+i.Overlay)
-		}
-	}
-
-	switch i.Verb {
-	case "env", "version":
-		goArgs = append(goArgs, i.Args...)
-	case "mod":
-		// mod needs the sub-verb before flags.
-		goArgs = append(goArgs, i.Args[0])
-		appendModFile()
-		goArgs = append(goArgs, i.Args[1:]...)
-	case "get":
-		goArgs = append(goArgs, i.BuildFlags...)
-		appendModFile()
-		goArgs = append(goArgs, i.Args...)
-
-	default: // notably list and build.
-		goArgs = append(goArgs, i.BuildFlags...)
-		appendModFile()
-		appendModFlag()
-		appendOverlayFlag()
-		goArgs = append(goArgs, i.Args...)
-	}
-	cmd := exec.Command("go", goArgs...)
-	cmd.Stdout = stdout
-	cmd.Stderr = stderr
-	// On darwin the cwd gets resolved to the real path, which breaks anything that
-	// expects the working directory to keep the original path, including the
-	// go command when dealing with modules.
-	// The Go stdlib has a special feature where if the cwd and the PWD are the
-	// same node then it trusts the PWD, so by setting it in the env for the child
-	// process we fix up all the paths returned by the go command.
-	if !i.CleanEnv {
-		cmd.Env = os.Environ()
-	}
-	cmd.Env = append(cmd.Env, i.Env...)
-	if i.WorkingDir != "" {
-		cmd.Env = append(cmd.Env, "PWD="+i.WorkingDir)
-		cmd.Dir = i.WorkingDir
-	}
-	defer func(start time.Time) { log("%s for %v", time.Since(start), cmdDebugStr(cmd)) }(time.Now())
-
-	return runCmdContext(ctx, cmd)
-}
-
-// runCmdContext is like exec.CommandContext except it sends os.Interrupt
-// before os.Kill.
-func runCmdContext(ctx context.Context, cmd *exec.Cmd) error {
-	if err := cmd.Start(); err != nil {
-		return err
-	}
-	resChan := make(chan error, 1)
-	go func() {
-		resChan <- cmd.Wait()
-	}()
-
-	select {
-	case err := <-resChan:
-		return err
-	case <-ctx.Done():
-	}
-	// Cancelled. Interrupt and see if it ends voluntarily.
-	cmd.Process.Signal(os.Interrupt)
-	select {
-	case err := <-resChan:
-		return err
-	case <-time.After(time.Second):
-	}
-	// Didn't shut down in response to interrupt. Kill it hard.
-	cmd.Process.Kill()
-	return <-resChan
-}
-
-func cmdDebugStr(cmd *exec.Cmd) string {
-	env := make(map[string]string)
-	for _, kv := range cmd.Env {
-		split := strings.SplitN(kv, "=", 2)
-		k, v := split[0], split[1]
-		env[k] = v
-	}
-
-	var args []string
-	for _, arg := range cmd.Args {
-		quoted := strconv.Quote(arg)
-		if quoted[1:len(quoted)-1] != arg || strings.Contains(arg, " ") {
-			args = append(args, quoted)
-		} else {
-			args = append(args, arg)
-		}
-	}
-	return fmt.Sprintf("GOROOT=%v GOPATH=%v GO111MODULE=%v GOPROXY=%v PWD=%v %v", env["GOROOT"], env["GOPATH"], env["GO111MODULE"], env["GOPROXY"], env["PWD"], strings.Join(args, " "))
-}
diff --git a/gofumports/internal/gocommand/vendor.go b/gofumports/internal/gocommand/vendor.go
deleted file mode 100644
index 1cd8d84..0000000
--- a/gofumports/internal/gocommand/vendor.go
+++ /dev/null
@@ -1,102 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package gocommand
-
-import (
-	"bytes"
-	"context"
-	"fmt"
-	"os"
-	"path/filepath"
-	"regexp"
-	"strings"
-
-	"golang.org/x/mod/semver"
-)
-
-// ModuleJSON holds information about a module.
-type ModuleJSON struct {
-	Path      string      // module path
-	Replace   *ModuleJSON // replaced by this module
-	Main      bool        // is this the main module?
-	Indirect  bool        // is this module only an indirect dependency of main module?
-	Dir       string      // directory holding files for this module, if any
-	GoMod     string      // path to go.mod file for this module, if any
-	GoVersion string      // go version used in module
-}
-
-var modFlagRegexp = regexp.MustCompile(`-mod[ =](\w+)`)
-
-// VendorEnabled reports whether vendoring is enabled. It takes a *Runner to execute Go commands
-// with the supplied context.Context and Invocation. The Invocation can contain pre-defined fields,
-// of which only Verb and Args are modified to run the appropriate Go command.
-// Inspired by setDefaultBuildMod in modload/init.go
-func VendorEnabled(ctx context.Context, inv Invocation, r *Runner) (*ModuleJSON, bool, error) {
-	mainMod, go114, err := getMainModuleAnd114(ctx, inv, r)
-	if err != nil {
-		return nil, false, err
-	}
-
-	// We check the GOFLAGS to see if there is anything overridden or not.
-	inv.Verb = "env"
-	inv.Args = []string{"GOFLAGS"}
-	stdout, err := r.Run(ctx, inv)
-	if err != nil {
-		return nil, false, err
-	}
-	goflags := string(bytes.TrimSpace(stdout.Bytes()))
-	matches := modFlagRegexp.FindStringSubmatch(goflags)
-	var modFlag string
-	if len(matches) != 0 {
-		modFlag = matches[1]
-	}
-	if modFlag != "" {
-		// Don't override an explicit '-mod=' argument.
-		return mainMod, modFlag == "vendor", nil
-	}
-	if mainMod == nil || !go114 {
-		return mainMod, false, nil
-	}
-	// Check 1.14's automatic vendor mode.
-	if fi, err := os.Stat(filepath.Join(mainMod.Dir, "vendor")); err == nil && fi.IsDir() {
-		if mainMod.GoVersion != "" && semver.Compare("v"+mainMod.GoVersion, "v1.14") >= 0 {
-			// The Go version is at least 1.14, and a vendor directory exists.
-			// Set -mod=vendor by default.
-			return mainMod, true, nil
-		}
-	}
-	return mainMod, false, nil
-}
-
-// getMainModuleAnd114 gets the main module's information and whether the
-// go command in use is 1.14+. This is the information needed to figure out
-// if vendoring should be enabled.
-func getMainModuleAnd114(ctx context.Context, inv Invocation, r *Runner) (*ModuleJSON, bool, error) {
-	const format = `{{.Path}}
-{{.Dir}}
-{{.GoMod}}
-{{.GoVersion}}
-{{range context.ReleaseTags}}{{if eq . "go1.14"}}{{.}}{{end}}{{end}}
-`
-	inv.Verb = "list"
-	inv.Args = []string{"-m", "-f", format}
-	stdout, err := r.Run(ctx, inv)
-	if err != nil {
-		return nil, false, err
-	}
-
-	lines := strings.Split(stdout.String(), "\n")
-	if len(lines) < 5 {
-		return nil, false, fmt.Errorf("unexpected stdout: %q", stdout.String())
-	}
-	mod := &ModuleJSON{
-		Path:      lines[0],
-		Dir:       lines[1],
-		GoMod:     lines[2],
-		GoVersion: lines[3],
-		Main:      true,
-	}
-	return mod, lines[4] == "go1.14", nil
-}
diff --git a/gofumports/internal/gocommand/version.go b/gofumports/internal/gocommand/version.go
deleted file mode 100644
index 60d45ac..0000000
--- a/gofumports/internal/gocommand/version.go
+++ /dev/null
@@ -1,40 +0,0 @@
-// Copyright 2020 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package gocommand
-
-import (
-	"context"
-	"fmt"
-	"strings"
-)
-
-// GoVersion checks the go version by running "go list" with modules off.
-// It returns the X in Go 1.X.
-func GoVersion(ctx context.Context, inv Invocation, r *Runner) (int, error) {
-	inv.Verb = "list"
-	inv.Args = []string{"-e", "-f", `{{context.ReleaseTags}}`}
-	inv.Env = append(append([]string{}, inv.Env...), "GO111MODULE=off")
-	// Unset any unneeded flags.
-	inv.ModFile = ""
-	inv.ModFlag = ""
-	stdoutBytes, err := r.Run(ctx, inv)
-	if err != nil {
-		return 0, err
-	}
-	stdout := stdoutBytes.String()
-	if len(stdout) < 3 {
-		return 0, fmt.Errorf("bad ReleaseTags output: %q", stdout)
-	}
-	// Split up "[go1.1 go1.15]"
-	tags := strings.Fields(stdout[1 : len(stdout)-2])
-	for i := len(tags) - 1; i >= 0; i-- {
-		var version int
-		if _, err := fmt.Sscanf(tags[i], "go1.%d", &version); err != nil {
-			continue
-		}
-		return version, nil
-	}
-	return 0, fmt.Errorf("no parseable ReleaseTags in %v", tags)
-}
diff --git a/gofumports/internal/gopathwalk/walk.go b/gofumports/internal/gopathwalk/walk.go
deleted file mode 100644
index caef8a5..0000000
--- a/gofumports/internal/gopathwalk/walk.go
+++ /dev/null
@@ -1,263 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package gopathwalk is like filepath.Walk but specialized for finding Go
-// packages, particularly in $GOPATH and $GOROOT.
-package gopathwalk
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"io/ioutil"
-	"log"
-	"os"
-	"path/filepath"
-	"strings"
-	"time"
-
-	"mvdan.cc/gofumpt/gofumports/internal/fastwalk"
-)
-
-// Options controls the behavior of a Walk call.
-type Options struct {
-	// If Logf is non-nil, debug logging is enabled through this function.
-	Logf func(format string, args ...interface{})
-	// Search module caches. Also disables legacy goimports ignore rules.
-	ModulesEnabled bool
-}
-
-// RootType indicates the type of a Root.
-type RootType int
-
-const (
-	RootUnknown RootType = iota
-	RootGOROOT
-	RootGOPATH
-	RootCurrentModule
-	RootModuleCache
-	RootOther
-)
-
-// A Root is a starting point for a Walk.
-type Root struct {
-	Path string
-	Type RootType
-}
-
-// Walk walks Go source directories ($GOROOT, $GOPATH, etc) to find packages.
-// For each package found, add will be called (concurrently) with the absolute
-// paths of the containing source directory and the package directory.
-// add will be called concurrently.
-func Walk(roots []Root, add func(root Root, dir string), opts Options) {
-	WalkSkip(roots, add, func(Root, string) bool { return false }, opts)
-}
-
-// WalkSkip walks Go source directories ($GOROOT, $GOPATH, etc) to find packages.
-// For each package found, add will be called (concurrently) with the absolute
-// paths of the containing source directory and the package directory.
-// For each directory that will be scanned, skip will be called (concurrently)
-// with the absolute paths of the containing source directory and the directory.
-// If skip returns false on a directory it will be processed.
-// add will be called concurrently.
-// skip will be called concurrently.
-func WalkSkip(roots []Root, add func(root Root, dir string), skip func(root Root, dir string) bool, opts Options) {
-	for _, root := range roots {
-		walkDir(root, add, skip, opts)
-	}
-}
-
-// walkDir creates a walker and starts fastwalk with this walker.
-func walkDir(root Root, add func(Root, string), skip func(root Root, dir string) bool, opts Options) {
-	if _, err := os.Stat(root.Path); os.IsNotExist(err) {
-		if opts.Logf != nil {
-			opts.Logf("skipping nonexistent directory: %v", root.Path)
-		}
-		return
-	}
-	start := time.Now()
-	if opts.Logf != nil {
-		opts.Logf("gopathwalk: scanning %s", root.Path)
-	}
-	w := &walker{
-		root: root,
-		add:  add,
-		skip: skip,
-		opts: opts,
-	}
-	w.init()
-	if err := fastwalk.Walk(root.Path, w.walk); err != nil {
-		log.Printf("gopathwalk: scanning directory %v: %v", root.Path, err)
-	}
-
-	if opts.Logf != nil {
-		opts.Logf("gopathwalk: scanned %s in %v", root.Path, time.Since(start))
-	}
-}
-
-// walker is the callback for fastwalk.Walk.
-type walker struct {
-	root Root                    // The source directory to scan.
-	add  func(Root, string)      // The callback that will be invoked for every possible Go package dir.
-	skip func(Root, string) bool // The callback that will be invoked for every dir. dir is skipped if it returns true.
-	opts Options                 // Options passed to Walk by the user.
-
-	ignoredDirs []os.FileInfo // The ignored directories, loaded from .goimportsignore files.
-}
-
-// init initializes the walker based on its Options
-func (w *walker) init() {
-	var ignoredPaths []string
-	if w.root.Type == RootModuleCache {
-		ignoredPaths = []string{"cache"}
-	}
-	if !w.opts.ModulesEnabled && w.root.Type == RootGOPATH {
-		ignoredPaths = w.getIgnoredDirs(w.root.Path)
-		ignoredPaths = append(ignoredPaths, "v", "mod")
-	}
-
-	for _, p := range ignoredPaths {
-		full := filepath.Join(w.root.Path, p)
-		if fi, err := os.Stat(full); err == nil {
-			w.ignoredDirs = append(w.ignoredDirs, fi)
-			if w.opts.Logf != nil {
-				w.opts.Logf("Directory added to ignore list: %s", full)
-			}
-		} else if w.opts.Logf != nil {
-			w.opts.Logf("Error statting ignored directory: %v", err)
-		}
-	}
-}
-
-// getIgnoredDirs reads an optional config file at <path>/.goimportsignore
-// of relative directories to ignore when scanning for go files.
-// The provided path is one of the $GOPATH entries with "src" appended.
-func (w *walker) getIgnoredDirs(path string) []string {
-	file := filepath.Join(path, ".goimportsignore")
-	slurp, err := ioutil.ReadFile(file)
-	if w.opts.Logf != nil {
-		if err != nil {
-			w.opts.Logf("%v", err)
-		} else {
-			w.opts.Logf("Read %s", file)
-		}
-	}
-	if err != nil {
-		return nil
-	}
-
-	var ignoredDirs []string
-	bs := bufio.NewScanner(bytes.NewReader(slurp))
-	for bs.Scan() {
-		line := strings.TrimSpace(bs.Text())
-		if line == "" || strings.HasPrefix(line, "#") {
-			continue
-		}
-		ignoredDirs = append(ignoredDirs, line)
-	}
-	return ignoredDirs
-}
-
-// shouldSkipDir reports whether the file should be skipped or not.
-func (w *walker) shouldSkipDir(fi os.FileInfo, dir string) bool {
-	for _, ignoredDir := range w.ignoredDirs {
-		if os.SameFile(fi, ignoredDir) {
-			return true
-		}
-	}
-	if w.skip != nil {
-		// Check with the user specified callback.
-		return w.skip(w.root, dir)
-	}
-	return false
-}
-
-// walk walks through the given path.
-func (w *walker) walk(path string, typ os.FileMode) error {
-	dir := filepath.Dir(path)
-	if typ.IsRegular() {
-		if dir == w.root.Path && (w.root.Type == RootGOROOT || w.root.Type == RootGOPATH) {
-			// Doesn't make sense to have regular files
-			// directly in your $GOPATH/src or $GOROOT/src.
-			return fastwalk.ErrSkipFiles
-		}
-		if !strings.HasSuffix(path, ".go") {
-			return nil
-		}
-
-		w.add(w.root, dir)
-		return fastwalk.ErrSkipFiles
-	}
-	if typ == os.ModeDir {
-		base := filepath.Base(path)
-		if base == "" || base[0] == '.' || base[0] == '_' ||
-			base == "testdata" ||
-			(w.root.Type == RootGOROOT && w.opts.ModulesEnabled && base == "vendor") ||
-			(!w.opts.ModulesEnabled && base == "node_modules") {
-			return filepath.SkipDir
-		}
-		fi, err := os.Lstat(path)
-		if err == nil && w.shouldSkipDir(fi, path) {
-			return filepath.SkipDir
-		}
-		return nil
-	}
-	if typ == os.ModeSymlink {
-		base := filepath.Base(path)
-		if strings.HasPrefix(base, ".#") {
-			// Emacs noise.
-			return nil
-		}
-		fi, err := os.Lstat(path)
-		if err != nil {
-			// Just ignore it.
-			return nil
-		}
-		if w.shouldTraverse(dir, fi) {
-			return fastwalk.ErrTraverseLink
-		}
-	}
-	return nil
-}
-
-// shouldTraverse reports whether the symlink fi, found in dir,
-// should be followed.  It makes sure symlinks were never visited
-// before to avoid symlink loops.
-func (w *walker) shouldTraverse(dir string, fi os.FileInfo) bool {
-	path := filepath.Join(dir, fi.Name())
-	target, err := filepath.EvalSymlinks(path)
-	if err != nil {
-		return false
-	}
-	ts, err := os.Stat(target)
-	if err != nil {
-		fmt.Fprintln(os.Stderr, err)
-		return false
-	}
-	if !ts.IsDir() {
-		return false
-	}
-	if w.shouldSkipDir(ts, dir) {
-		return false
-	}
-	// Check for symlink loops by statting each directory component
-	// and seeing if any are the same file as ts.
-	for {
-		parent := filepath.Dir(path)
-		if parent == path {
-			// Made it to the root without seeing a cycle.
-			// Use this symlink.
-			return true
-		}
-		parentInfo, err := os.Stat(parent)
-		if err != nil {
-			return false
-		}
-		if os.SameFile(ts, parentInfo) {
-			// Cycle. Don't traverse.
-			return false
-		}
-		path = parent
-	}
-}
diff --git a/gofumports/internal/imports/fix.go b/gofumports/internal/imports/fix.go
deleted file mode 100644
index 77826b6..0000000
--- a/gofumports/internal/imports/fix.go
+++ /dev/null
@@ -1,1729 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package imports
-
-import (
-	"bytes"
-	"context"
-	"encoding/json"
-	"fmt"
-	"go/ast"
-	"go/build"
-	"go/parser"
-	"go/token"
-	"io/ioutil"
-	"os"
-	"path"
-	"path/filepath"
-	"reflect"
-	"sort"
-	"strconv"
-	"strings"
-	"sync"
-	"unicode"
-	"unicode/utf8"
-
-	"golang.org/x/tools/go/ast/astutil"
-	"mvdan.cc/gofumpt/gofumports/internal/gocommand"
-	"mvdan.cc/gofumpt/gofumports/internal/gopathwalk"
-)
-
-// importToGroup is a list of functions which map from an import path to
-// a group number.
-var importToGroup = []func(localPrefix, importPath string) (num int, ok bool){
-	func(localPrefix, importPath string) (num int, ok bool) {
-		if localPrefix == "" {
-			return
-		}
-		for _, p := range strings.Split(localPrefix, ",") {
-			if strings.HasPrefix(importPath, p) || strings.TrimSuffix(p, "/") == importPath {
-				return 3, true
-			}
-		}
-		return
-	},
-	func(_, importPath string) (num int, ok bool) {
-		if strings.HasPrefix(importPath, "appengine") {
-			return 2, true
-		}
-		return
-	},
-	func(_, importPath string) (num int, ok bool) {
-		firstComponent := strings.Split(importPath, "/")[0]
-		if strings.Contains(firstComponent, ".") {
-			return 1, true
-		}
-		return
-	},
-}
-
-func importGroup(localPrefix, importPath string) int {
-	for _, fn := range importToGroup {
-		if n, ok := fn(localPrefix, importPath); ok {
-			return n
-		}
-	}
-	return 0
-}
-
-type ImportFixType int
-
-const (
-	AddImport ImportFixType = iota
-	DeleteImport
-	SetImportName
-)
-
-type ImportFix struct {
-	// StmtInfo represents the import statement this fix will add, remove, or change.
-	StmtInfo ImportInfo
-	// IdentName is the identifier that this fix will add or remove.
-	IdentName string
-	// FixType is the type of fix this is (AddImport, DeleteImport, SetImportName).
-	FixType   ImportFixType
-	Relevance float64 // see pkg
-}
-
-// An ImportInfo represents a single import statement.
-type ImportInfo struct {
-	ImportPath string // import path, e.g. "crypto/rand".
-	Name       string // import name, e.g. "crand", or "" if none.
-}
-
-// A packageInfo represents what's known about a package.
-type packageInfo struct {
-	name    string          // real package name, if known.
-	exports map[string]bool // known exports.
-}
-
-// parseOtherFiles parses all the Go files in srcDir except filename, including
-// test files if filename looks like a test.
-func parseOtherFiles(fset *token.FileSet, srcDir, filename string) []*ast.File {
-	// This could use go/packages but it doesn't buy much, and it fails
-	// with https://golang.org/issue/26296 in LoadFiles mode in some cases.
-	considerTests := strings.HasSuffix(filename, "_test.go")
-
-	fileBase := filepath.Base(filename)
-	packageFileInfos, err := ioutil.ReadDir(srcDir)
-	if err != nil {
-		return nil
-	}
-
-	var files []*ast.File
-	for _, fi := range packageFileInfos {
-		if fi.Name() == fileBase || !strings.HasSuffix(fi.Name(), ".go") {
-			continue
-		}
-		if !considerTests && strings.HasSuffix(fi.Name(), "_test.go") {
-			continue
-		}
-
-		f, err := parser.ParseFile(fset, filepath.Join(srcDir, fi.Name()), nil, 0)
-		if err != nil {
-			continue
-		}
-
-		files = append(files, f)
-	}
-
-	return files
-}
-
-// addGlobals puts the names of package vars into the provided map.
-func addGlobals(f *ast.File, globals map[string]bool) {
-	for _, decl := range f.Decls {
-		genDecl, ok := decl.(*ast.GenDecl)
-		if !ok {
-			continue
-		}
-
-		for _, spec := range genDecl.Specs {
-			valueSpec, ok := spec.(*ast.ValueSpec)
-			if !ok {
-				continue
-			}
-			globals[valueSpec.Names[0].Name] = true
-		}
-	}
-}
-
-// collectReferences builds a map of selector expressions, from
-// left hand side (X) to a set of right hand sides (Sel).
-func collectReferences(f *ast.File) references {
-	refs := references{}
-
-	var visitor visitFn
-	visitor = func(node ast.Node) ast.Visitor {
-		if node == nil {
-			return visitor
-		}
-		switch v := node.(type) {
-		case *ast.SelectorExpr:
-			xident, ok := v.X.(*ast.Ident)
-			if !ok {
-				break
-			}
-			if xident.Obj != nil {
-				// If the parser can resolve it, it's not a package ref.
-				break
-			}
-			if !ast.IsExported(v.Sel.Name) {
-				// Whatever this is, it's not exported from a package.
-				break
-			}
-			pkgName := xident.Name
-			r := refs[pkgName]
-			if r == nil {
-				r = make(map[string]bool)
-				refs[pkgName] = r
-			}
-			r[v.Sel.Name] = true
-		}
-		return visitor
-	}
-	ast.Walk(visitor, f)
-	return refs
-}
-
-// collectImports returns all the imports in f.
-// Unnamed imports (., _) and "C" are ignored.
-func collectImports(f *ast.File) []*ImportInfo {
-	var imports []*ImportInfo
-	for _, imp := range f.Imports {
-		var name string
-		if imp.Name != nil {
-			name = imp.Name.Name
-		}
-		if imp.Path.Value == `"C"` || name == "_" || name == "." {
-			continue
-		}
-		path := strings.Trim(imp.Path.Value, `"`)
-		imports = append(imports, &ImportInfo{
-			Name:       name,
-			ImportPath: path,
-		})
-	}
-	return imports
-}
-
-// findMissingImport searches pass's candidates for an import that provides
-// pkg, containing all of syms.
-func (p *pass) findMissingImport(pkg string, syms map[string]bool) *ImportInfo {
-	for _, candidate := range p.candidates {
-		pkgInfo, ok := p.knownPackages[candidate.ImportPath]
-		if !ok {
-			continue
-		}
-		if p.importIdentifier(candidate) != pkg {
-			continue
-		}
-
-		allFound := true
-		for right := range syms {
-			if !pkgInfo.exports[right] {
-				allFound = false
-				break
-			}
-		}
-
-		if allFound {
-			return candidate
-		}
-	}
-	return nil
-}
-
-// references is set of references found in a Go file. The first map key is the
-// left hand side of a selector expression, the second key is the right hand
-// side, and the value should always be true.
-type references map[string]map[string]bool
-
-// A pass contains all the inputs and state necessary to fix a file's imports.
-// It can be modified in some ways during use; see comments below.
-type pass struct {
-	// Inputs. These must be set before a call to load, and not modified after.
-	fset                 *token.FileSet // fset used to parse f and its siblings.
-	f                    *ast.File      // the file being fixed.
-	srcDir               string         // the directory containing f.
-	env                  *ProcessEnv    // the environment to use for go commands, etc.
-	loadRealPackageNames bool           // if true, load package names from disk rather than guessing them.
-	otherFiles           []*ast.File    // sibling files.
-
-	// Intermediate state, generated by load.
-	existingImports map[string]*ImportInfo
-	allRefs         references
-	missingRefs     references
-
-	// Inputs to fix. These can be augmented between successive fix calls.
-	lastTry       bool                    // indicates that this is the last call and fix should clean up as best it can.
-	candidates    []*ImportInfo           // candidate imports in priority order.
-	knownPackages map[string]*packageInfo // information about all known packages.
-}
-
-// loadPackageNames saves the package names for everything referenced by imports.
-func (p *pass) loadPackageNames(imports []*ImportInfo) error {
-	if p.env.Logf != nil {
-		p.env.Logf("loading package names for %v packages", len(imports))
-		defer func() {
-			p.env.Logf("done loading package names for %v packages", len(imports))
-		}()
-	}
-	var unknown []string
-	for _, imp := range imports {
-		if _, ok := p.knownPackages[imp.ImportPath]; ok {
-			continue
-		}
-		unknown = append(unknown, imp.ImportPath)
-	}
-
-	resolver, err := p.env.GetResolver()
-	if err != nil {
-		return err
-	}
-
-	names, err := resolver.loadPackageNames(unknown, p.srcDir)
-	if err != nil {
-		return err
-	}
-
-	for path, name := range names {
-		p.knownPackages[path] = &packageInfo{
-			name:    name,
-			exports: map[string]bool{},
-		}
-	}
-	return nil
-}
-
-// importIdentifier returns the identifier that imp will introduce. It will
-// guess if the package name has not been loaded, e.g. because the source
-// is not available.
-func (p *pass) importIdentifier(imp *ImportInfo) string {
-	if imp.Name != "" {
-		return imp.Name
-	}
-	known := p.knownPackages[imp.ImportPath]
-	if known != nil && known.name != "" {
-		return known.name
-	}
-	return ImportPathToAssumedName(imp.ImportPath)
-}
-
-// load reads in everything necessary to run a pass, and reports whether the
-// file already has all the imports it needs. It fills in p.missingRefs with the
-// file's missing symbols, if any, or removes unused imports if not.
-func (p *pass) load() ([]*ImportFix, bool) {
-	p.knownPackages = map[string]*packageInfo{}
-	p.missingRefs = references{}
-	p.existingImports = map[string]*ImportInfo{}
-
-	// Load basic information about the file in question.
-	p.allRefs = collectReferences(p.f)
-
-	// Load stuff from other files in the same package:
-	// global variables so we know they don't need resolving, and imports
-	// that we might want to mimic.
-	globals := map[string]bool{}
-	for _, otherFile := range p.otherFiles {
-		// Don't load globals from files that are in the same directory
-		// but a different package. Using them to suggest imports is OK.
-		if p.f.Name.Name == otherFile.Name.Name {
-			addGlobals(otherFile, globals)
-		}
-		p.candidates = append(p.candidates, collectImports(otherFile)...)
-	}
-
-	// Resolve all the import paths we've seen to package names, and store
-	// f's imports by the identifier they introduce.
-	imports := collectImports(p.f)
-	if p.loadRealPackageNames {
-		err := p.loadPackageNames(append(imports, p.candidates...))
-		if err != nil {
-			if p.env.Logf != nil {
-				p.env.Logf("loading package names: %v", err)
-			}
-			return nil, false
-		}
-	}
-	for _, imp := range imports {
-		p.existingImports[p.importIdentifier(imp)] = imp
-	}
-
-	// Find missing references.
-	for left, rights := range p.allRefs {
-		if globals[left] {
-			continue
-		}
-		_, ok := p.existingImports[left]
-		if !ok {
-			p.missingRefs[left] = rights
-			continue
-		}
-	}
-	if len(p.missingRefs) != 0 {
-		return nil, false
-	}
-
-	return p.fix()
-}
-
-// fix attempts to satisfy missing imports using p.candidates. If it finds
-// everything, or if p.lastTry is true, it updates fixes to add the imports it found,
-// delete anything unused, and update import names, and returns true.
-func (p *pass) fix() ([]*ImportFix, bool) {
-	// Find missing imports.
-	var selected []*ImportInfo
-	for left, rights := range p.missingRefs {
-		if imp := p.findMissingImport(left, rights); imp != nil {
-			selected = append(selected, imp)
-		}
-	}
-
-	if !p.lastTry && len(selected) != len(p.missingRefs) {
-		return nil, false
-	}
-
-	// Found everything, or giving up. Add the new imports and remove any unused.
-	var fixes []*ImportFix
-	for _, imp := range p.existingImports {
-		// We deliberately ignore globals here, because we can't be sure
-		// they're in the same package. People do things like put multiple
-		// main packages in the same directory, and we don't want to
-		// remove imports if they happen to have the same name as a var in
-		// a different package.
-		if _, ok := p.allRefs[p.importIdentifier(imp)]; !ok {
-			fixes = append(fixes, &ImportFix{
-				StmtInfo:  *imp,
-				IdentName: p.importIdentifier(imp),
-				FixType:   DeleteImport,
-			})
-			continue
-		}
-
-		// An existing import may need to update its import name to be correct.
-		if name := p.importSpecName(imp); name != imp.Name {
-			fixes = append(fixes, &ImportFix{
-				StmtInfo: ImportInfo{
-					Name:       name,
-					ImportPath: imp.ImportPath,
-				},
-				IdentName: p.importIdentifier(imp),
-				FixType:   SetImportName,
-			})
-		}
-	}
-
-	for _, imp := range selected {
-		fixes = append(fixes, &ImportFix{
-			StmtInfo: ImportInfo{
-				Name:       p.importSpecName(imp),
-				ImportPath: imp.ImportPath,
-			},
-			IdentName: p.importIdentifier(imp),
-			FixType:   AddImport,
-		})
-	}
-
-	return fixes, true
-}
-
-// importSpecName gets the import name of imp in the import spec.
-//
-// When the import identifier matches the assumed import name, the import name does
-// not appear in the import spec.
-func (p *pass) importSpecName(imp *ImportInfo) string {
-	// If we did not load the real package names, or the name is already set,
-	// we just return the existing name.
-	if !p.loadRealPackageNames || imp.Name != "" {
-		return imp.Name
-	}
-
-	ident := p.importIdentifier(imp)
-	if ident == ImportPathToAssumedName(imp.ImportPath) {
-		return "" // ident not needed since the assumed and real names are the same.
-	}
-	return ident
-}
-
-// apply will perform the fixes on f in order.
-func apply(fset *token.FileSet, f *ast.File, fixes []*ImportFix) {
-	for _, fix := range fixes {
-		switch fix.FixType {
-		case DeleteImport:
-			astutil.DeleteNamedImport(fset, f, fix.StmtInfo.Name, fix.StmtInfo.ImportPath)
-		case AddImport:
-			astutil.AddNamedImport(fset, f, fix.StmtInfo.Name, fix.StmtInfo.ImportPath)
-		case SetImportName:
-			// Find the matching import path and change the name.
-			for _, spec := range f.Imports {
-				path := strings.Trim(spec.Path.Value, `"`)
-				if path == fix.StmtInfo.ImportPath {
-					spec.Name = &ast.Ident{
-						Name:    fix.StmtInfo.Name,
-						NamePos: spec.Pos(),
-					}
-				}
-			}
-		}
-	}
-}
-
-// assumeSiblingImportsValid assumes that siblings' use of packages is valid,
-// adding the exports they use.
-func (p *pass) assumeSiblingImportsValid() {
-	for _, f := range p.otherFiles {
-		refs := collectReferences(f)
-		imports := collectImports(f)
-		importsByName := map[string]*ImportInfo{}
-		for _, imp := range imports {
-			importsByName[p.importIdentifier(imp)] = imp
-		}
-		for left, rights := range refs {
-			if imp, ok := importsByName[left]; ok {
-				if m, ok := stdlib[imp.ImportPath]; ok {
-					// We have the stdlib in memory; no need to guess.
-					rights = copyExports(m)
-				}
-				p.addCandidate(imp, &packageInfo{
-					// no name; we already know it.
-					exports: rights,
-				})
-			}
-		}
-	}
-}
-
-// addCandidate adds a candidate import to p, and merges in the information
-// in pkg.
-func (p *pass) addCandidate(imp *ImportInfo, pkg *packageInfo) {
-	p.candidates = append(p.candidates, imp)
-	if existing, ok := p.knownPackages[imp.ImportPath]; ok {
-		if existing.name == "" {
-			existing.name = pkg.name
-		}
-		for export := range pkg.exports {
-			existing.exports[export] = true
-		}
-	} else {
-		p.knownPackages[imp.ImportPath] = pkg
-	}
-}
-
-// fixImports adds and removes imports from f so that all its references are
-// satisfied and there are no unused imports.
-//
-// This is declared as a variable rather than a function so goimports can
-// easily be extended by adding a file with an init function.
-var fixImports = fixImportsDefault
-
-func fixImportsDefault(fset *token.FileSet, f *ast.File, filename string, env *ProcessEnv) error {
-	fixes, err := getFixes(fset, f, filename, env)
-	if err != nil {
-		return err
-	}
-	apply(fset, f, fixes)
-	return err
-}
-
-// getFixes gets the import fixes that need to be made to f in order to fix the imports.
-// It does not modify the ast.
-func getFixes(fset *token.FileSet, f *ast.File, filename string, env *ProcessEnv) ([]*ImportFix, error) {
-	abs, err := filepath.Abs(filename)
-	if err != nil {
-		return nil, err
-	}
-	srcDir := filepath.Dir(abs)
-	if env.Logf != nil {
-		env.Logf("fixImports(filename=%q), abs=%q, srcDir=%q ...", filename, abs, srcDir)
-	}
-
-	// First pass: looking only at f, and using the naive algorithm to
-	// derive package names from import paths, see if the file is already
-	// complete. We can't add any imports yet, because we don't know
-	// if missing references are actually package vars.
-	p := &pass{fset: fset, f: f, srcDir: srcDir, env: env}
-	if fixes, done := p.load(); done {
-		return fixes, nil
-	}
-
-	otherFiles := parseOtherFiles(fset, srcDir, filename)
-
-	// Second pass: add information from other files in the same package,
-	// like their package vars and imports.
-	p.otherFiles = otherFiles
-	if fixes, done := p.load(); done {
-		return fixes, nil
-	}
-
-	// Now we can try adding imports from the stdlib.
-	p.assumeSiblingImportsValid()
-	addStdlibCandidates(p, p.missingRefs)
-	if fixes, done := p.fix(); done {
-		return fixes, nil
-	}
-
-	// Third pass: get real package names where we had previously used
-	// the naive algorithm.
-	p = &pass{fset: fset, f: f, srcDir: srcDir, env: env}
-	p.loadRealPackageNames = true
-	p.otherFiles = otherFiles
-	if fixes, done := p.load(); done {
-		return fixes, nil
-	}
-
-	if err := addStdlibCandidates(p, p.missingRefs); err != nil {
-		return nil, err
-	}
-	p.assumeSiblingImportsValid()
-	if fixes, done := p.fix(); done {
-		return fixes, nil
-	}
-
-	// Go look for candidates in $GOPATH, etc. We don't necessarily load
-	// the real exports of sibling imports, so keep assuming their contents.
-	if err := addExternalCandidates(p, p.missingRefs, filename); err != nil {
-		return nil, err
-	}
-
-	p.lastTry = true
-	fixes, _ := p.fix()
-	return fixes, nil
-}
-
-// MaxRelevance is the highest relevance, used for the standard library.
-// Chosen arbitrarily to match pre-existing gopls code.
-const MaxRelevance = 7.0
-
-// getCandidatePkgs works with the passed callback to find all acceptable packages.
-// It deduplicates by import path, and uses a cached stdlib rather than reading
-// from disk.
-func getCandidatePkgs(ctx context.Context, wrappedCallback *scanCallback, filename, filePkg string, env *ProcessEnv) error {
-	notSelf := func(p *pkg) bool {
-		return p.packageName != filePkg || p.dir != filepath.Dir(filename)
-	}
-	goenv, err := env.goEnv()
-	if err != nil {
-		return err
-	}
-
-	var mu sync.Mutex // to guard asynchronous access to dupCheck
-	dupCheck := map[string]struct{}{}
-
-	// Start off with the standard library.
-	for importPath, exports := range stdlib {
-		p := &pkg{
-			dir:             filepath.Join(goenv["GOROOT"], "src", importPath),
-			importPathShort: importPath,
-			packageName:     path.Base(importPath),
-			relevance:       MaxRelevance,
-		}
-		dupCheck[importPath] = struct{}{}
-		if notSelf(p) && wrappedCallback.dirFound(p) && wrappedCallback.packageNameLoaded(p) {
-			wrappedCallback.exportsLoaded(p, exports)
-		}
-	}
-
-	scanFilter := &scanCallback{
-		rootFound: func(root gopathwalk.Root) bool {
-			// Exclude goroot results -- getting them is relatively expensive, not cached,
-			// and generally redundant with the in-memory version.
-			return root.Type != gopathwalk.RootGOROOT && wrappedCallback.rootFound(root)
-		},
-		dirFound: wrappedCallback.dirFound,
-		packageNameLoaded: func(pkg *pkg) bool {
-			mu.Lock()
-			defer mu.Unlock()
-			if _, ok := dupCheck[pkg.importPathShort]; ok {
-				return false
-			}
-			dupCheck[pkg.importPathShort] = struct{}{}
-			return notSelf(pkg) && wrappedCallback.packageNameLoaded(pkg)
-		},
-		exportsLoaded: func(pkg *pkg, exports []string) {
-			// If we're an x_test, load the package under test's test variant.
-			if strings.HasSuffix(filePkg, "_test") && pkg.dir == filepath.Dir(filename) {
-				var err error
-				_, exports, err = loadExportsFromFiles(ctx, env, pkg.dir, true)
-				if err != nil {
-					return
-				}
-			}
-			wrappedCallback.exportsLoaded(pkg, exports)
-		},
-	}
-	resolver, err := env.GetResolver()
-	if err != nil {
-		return err
-	}
-	return resolver.scan(ctx, scanFilter)
-}
-
-func ScoreImportPaths(ctx context.Context, env *ProcessEnv, paths []string) (map[string]float64, error) {
-	result := make(map[string]float64)
-	resolver, err := env.GetResolver()
-	if err != nil {
-		return nil, err
-	}
-	for _, path := range paths {
-		result[path] = resolver.scoreImportPath(ctx, path)
-	}
-	return result, nil
-}
-
-func PrimeCache(ctx context.Context, env *ProcessEnv) error {
-	// Fully scan the disk for directories, but don't actually read any Go files.
-	callback := &scanCallback{
-		rootFound: func(gopathwalk.Root) bool {
-			return true
-		},
-		dirFound: func(pkg *pkg) bool {
-			return false
-		},
-		packageNameLoaded: func(pkg *pkg) bool {
-			return false
-		},
-	}
-	return getCandidatePkgs(ctx, callback, "", "", env)
-}
-
-func candidateImportName(pkg *pkg) string {
-	if ImportPathToAssumedName(pkg.importPathShort) != pkg.packageName {
-		return pkg.packageName
-	}
-	return ""
-}
-
-// GetAllCandidates calls wrapped for each package whose name starts with
-// searchPrefix, and can be imported from filename with the package name filePkg.
-func GetAllCandidates(ctx context.Context, wrapped func(ImportFix), searchPrefix, filename, filePkg string, env *ProcessEnv) error {
-	callback := &scanCallback{
-		rootFound: func(gopathwalk.Root) bool {
-			return true
-		},
-		dirFound: func(pkg *pkg) bool {
-			if !canUse(filename, pkg.dir) {
-				return false
-			}
-			// Try the assumed package name first, then a simpler path match
-			// in case of packages named vN, which are not uncommon.
-			return strings.HasPrefix(ImportPathToAssumedName(pkg.importPathShort), searchPrefix) ||
-				strings.HasPrefix(path.Base(pkg.importPathShort), searchPrefix)
-		},
-		packageNameLoaded: func(pkg *pkg) bool {
-			if !strings.HasPrefix(pkg.packageName, searchPrefix) {
-				return false
-			}
-			wrapped(ImportFix{
-				StmtInfo: ImportInfo{
-					ImportPath: pkg.importPathShort,
-					Name:       candidateImportName(pkg),
-				},
-				IdentName: pkg.packageName,
-				FixType:   AddImport,
-				Relevance: pkg.relevance,
-			})
-			return false
-		},
-	}
-	return getCandidatePkgs(ctx, callback, filename, filePkg, env)
-}
-
-// GetImportPaths calls wrapped for each package whose import path starts with
-// searchPrefix, and can be imported from filename with the package name filePkg.
-func GetImportPaths(ctx context.Context, wrapped func(ImportFix), searchPrefix, filename, filePkg string, env *ProcessEnv) error {
-	callback := &scanCallback{
-		rootFound: func(gopathwalk.Root) bool {
-			return true
-		},
-		dirFound: func(pkg *pkg) bool {
-			if !canUse(filename, pkg.dir) {
-				return false
-			}
-			return strings.HasPrefix(pkg.importPathShort, searchPrefix)
-		},
-		packageNameLoaded: func(pkg *pkg) bool {
-			wrapped(ImportFix{
-				StmtInfo: ImportInfo{
-					ImportPath: pkg.importPathShort,
-					Name:       candidateImportName(pkg),
-				},
-				IdentName: pkg.packageName,
-				FixType:   AddImport,
-				Relevance: pkg.relevance,
-			})
-			return false
-		},
-	}
-	return getCandidatePkgs(ctx, callback, filename, filePkg, env)
-}
-
-// A PackageExport is a package and its exports.
-type PackageExport struct {
-	Fix     *ImportFix
-	Exports []string
-}
-
-// GetPackageExports returns all known packages with name pkg and their exports.
-func GetPackageExports(ctx context.Context, wrapped func(PackageExport), searchPkg, filename, filePkg string, env *ProcessEnv) error {
-	callback := &scanCallback{
-		rootFound: func(gopathwalk.Root) bool {
-			return true
-		},
-		dirFound: func(pkg *pkg) bool {
-			return pkgIsCandidate(filename, references{searchPkg: nil}, pkg)
-		},
-		packageNameLoaded: func(pkg *pkg) bool {
-			return pkg.packageName == searchPkg
-		},
-		exportsLoaded: func(pkg *pkg, exports []string) {
-			sort.Strings(exports)
-			wrapped(PackageExport{
-				Fix: &ImportFix{
-					StmtInfo: ImportInfo{
-						ImportPath: pkg.importPathShort,
-						Name:       candidateImportName(pkg),
-					},
-					IdentName: pkg.packageName,
-					FixType:   AddImport,
-					Relevance: pkg.relevance,
-				},
-				Exports: exports,
-			})
-		},
-	}
-	return getCandidatePkgs(ctx, callback, filename, filePkg, env)
-}
-
-var RequiredGoEnvVars = []string{"GO111MODULE", "GOFLAGS", "GOINSECURE", "GOMOD", "GOMODCACHE", "GONOPROXY", "GONOSUMDB", "GOPATH", "GOPROXY", "GOROOT", "GOSUMDB"}
-
-// ProcessEnv contains environment variables and settings that affect the use of
-// the go command, the go/build package, etc.
-type ProcessEnv struct {
-	GocmdRunner *gocommand.Runner
-
-	BuildFlags []string
-	ModFlag    string
-	ModFile    string
-
-	// Env overrides the OS environment, and can be used to specify
-	// GOPROXY, GO111MODULE, etc. PATH cannot be set here, because
-	// exec.Command will not honor it.
-	// Specifying all of RequiredGoEnvVars avoids a call to `go env`.
-	Env map[string]string
-
-	WorkingDir string
-
-	// If Logf is non-nil, debug logging is enabled through this function.
-	Logf func(format string, args ...interface{})
-
-	initialized bool
-
-	resolver Resolver
-}
-
-func (e *ProcessEnv) goEnv() (map[string]string, error) {
-	if err := e.init(); err != nil {
-		return nil, err
-	}
-	return e.Env, nil
-}
-
-func (e *ProcessEnv) matchFile(dir, name string) (bool, error) {
-	bctx, err := e.buildContext()
-	if err != nil {
-		return false, err
-	}
-	return bctx.MatchFile(dir, name)
-}
-
-// CopyConfig copies the env's configuration into a new env.
-func (e *ProcessEnv) CopyConfig() *ProcessEnv {
-	copy := &ProcessEnv{
-		GocmdRunner: e.GocmdRunner,
-		initialized: e.initialized,
-		BuildFlags:  e.BuildFlags,
-		Logf:        e.Logf,
-		WorkingDir:  e.WorkingDir,
-		resolver:    nil,
-		Env:         map[string]string{},
-	}
-	for k, v := range e.Env {
-		copy.Env[k] = v
-	}
-	return copy
-}
-
-func (e *ProcessEnv) init() error {
-	if e.initialized {
-		return nil
-	}
-
-	foundAllRequired := true
-	for _, k := range RequiredGoEnvVars {
-		if _, ok := e.Env[k]; !ok {
-			foundAllRequired = false
-			break
-		}
-	}
-	if foundAllRequired {
-		e.initialized = true
-		return nil
-	}
-
-	if e.Env == nil {
-		e.Env = map[string]string{}
-	}
-
-	goEnv := map[string]string{}
-	stdout, err := e.invokeGo(context.TODO(), "env", append([]string{"-json"}, RequiredGoEnvVars...)...)
-	if err != nil {
-		return err
-	}
-	if err := json.Unmarshal(stdout.Bytes(), &goEnv); err != nil {
-		return err
-	}
-	for k, v := range goEnv {
-		e.Env[k] = v
-	}
-	e.initialized = true
-	return nil
-}
-
-func (e *ProcessEnv) env() []string {
-	var env []string // the gocommand package will prepend os.Environ.
-	for k, v := range e.Env {
-		env = append(env, k+"="+v)
-	}
-	return env
-}
-
-func (e *ProcessEnv) GetResolver() (Resolver, error) {
-	if e.resolver != nil {
-		return e.resolver, nil
-	}
-	if err := e.init(); err != nil {
-		return nil, err
-	}
-	if len(e.Env["GOMOD"]) == 0 {
-		e.resolver = newGopathResolver(e)
-		return e.resolver, nil
-	}
-	e.resolver = newModuleResolver(e)
-	return e.resolver, nil
-}
-
-func (e *ProcessEnv) buildContext() (*build.Context, error) {
-	ctx := build.Default
-	goenv, err := e.goEnv()
-	if err != nil {
-		return nil, err
-	}
-	ctx.GOROOT = goenv["GOROOT"]
-	ctx.GOPATH = goenv["GOPATH"]
-
-	// As of Go 1.14, build.Context has a Dir field
-	// (see golang.org/issue/34860).
-	// Populate it only if present.
-	rc := reflect.ValueOf(&ctx).Elem()
-	dir := rc.FieldByName("Dir")
-	if dir.IsValid() && dir.Kind() == reflect.String {
-		dir.SetString(e.WorkingDir)
-	}
-
-	// Since Go 1.11, go/build.Context.Import may invoke 'go list' depending on
-	// the value in GO111MODULE in the process's environment. We always want to
-	// run in GOPATH mode when calling Import, so we need to prevent this from
-	// happening. In Go 1.16, GO111MODULE defaults to "on", so this problem comes
-	// up more frequently.
-	//
-	// HACK: setting any of the Context I/O hooks prevents Import from invoking
-	// 'go list', regardless of GO111MODULE. This is undocumented, but it's
-	// unlikely to change before GOPATH support is removed.
-	ctx.ReadDir = ioutil.ReadDir
-
-	return &ctx, nil
-}
-
-func (e *ProcessEnv) invokeGo(ctx context.Context, verb string, args ...string) (*bytes.Buffer, error) {
-	inv := gocommand.Invocation{
-		Verb:       verb,
-		Args:       args,
-		BuildFlags: e.BuildFlags,
-		Env:        e.env(),
-		Logf:       e.Logf,
-		WorkingDir: e.WorkingDir,
-	}
-	return e.GocmdRunner.Run(ctx, inv)
-}
-
-func addStdlibCandidates(pass *pass, refs references) error {
-	goenv, err := pass.env.goEnv()
-	if err != nil {
-		return err
-	}
-	add := func(pkg string) {
-		// Prevent self-imports.
-		if path.Base(pkg) == pass.f.Name.Name && filepath.Join(goenv["GOROOT"], "src", pkg) == pass.srcDir {
-			return
-		}
-		exports := copyExports(stdlib[pkg])
-		pass.addCandidate(
-			&ImportInfo{ImportPath: pkg},
-			&packageInfo{name: path.Base(pkg), exports: exports})
-	}
-	for left := range refs {
-		if left == "rand" {
-			// Make sure we try crypto/rand before math/rand.
-			add("crypto/rand")
-			add("math/rand")
-			continue
-		}
-		for importPath := range stdlib {
-			if path.Base(importPath) == left {
-				add(importPath)
-			}
-		}
-	}
-	return nil
-}
-
-// A Resolver does the build-system-specific parts of goimports.
-type Resolver interface {
-	// loadPackageNames loads the package names in importPaths.
-	loadPackageNames(importPaths []string, srcDir string) (map[string]string, error)
-	// scan works with callback to search for packages. See scanCallback for details.
-	scan(ctx context.Context, callback *scanCallback) error
-	// loadExports returns the set of exported symbols in the package at dir.
-	// loadExports may be called concurrently.
-	loadExports(ctx context.Context, pkg *pkg, includeTest bool) (string, []string, error)
-	// scoreImportPath returns the relevance for an import path.
-	scoreImportPath(ctx context.Context, path string) float64
-
-	ClearForNewScan()
-}
-
-// A scanCallback controls a call to scan and receives its results.
-// In general, minor errors will be silently discarded; a user should not
-// expect to receive a full series of calls for everything.
-type scanCallback struct {
-	// rootFound is called before scanning a new root dir. If it returns true,
-	// the root will be scanned. Returning false will not necessarily prevent
-	// directories from that root making it to dirFound.
-	rootFound func(gopathwalk.Root) bool
-	// dirFound is called when a directory is found that is possibly a Go package.
-	// pkg will be populated with everything except packageName.
-	// If it returns true, the package's name will be loaded.
-	dirFound func(pkg *pkg) bool
-	// packageNameLoaded is called when a package is found and its name is loaded.
-	// If it returns true, the package's exports will be loaded.
-	packageNameLoaded func(pkg *pkg) bool
-	// exportsLoaded is called when a package's exports have been loaded.
-	exportsLoaded func(pkg *pkg, exports []string)
-}
-
-func addExternalCandidates(pass *pass, refs references, filename string) error {
-	var mu sync.Mutex
-	found := make(map[string][]pkgDistance)
-	callback := &scanCallback{
-		rootFound: func(gopathwalk.Root) bool {
-			return true // We want everything.
-		},
-		dirFound: func(pkg *pkg) bool {
-			return pkgIsCandidate(filename, refs, pkg)
-		},
-		packageNameLoaded: func(pkg *pkg) bool {
-			if _, want := refs[pkg.packageName]; !want {
-				return false
-			}
-			if pkg.dir == pass.srcDir && pass.f.Name.Name == pkg.packageName {
-				// The candidate is in the same directory and has the
-				// same package name. Don't try to import ourselves.
-				return false
-			}
-			if !canUse(filename, pkg.dir) {
-				return false
-			}
-			mu.Lock()
-			defer mu.Unlock()
-			found[pkg.packageName] = append(found[pkg.packageName], pkgDistance{pkg, distance(pass.srcDir, pkg.dir)})
-			return false // We'll do our own loading after we sort.
-		},
-	}
-	resolver, err := pass.env.GetResolver()
-	if err != nil {
-		return err
-	}
-	if err = resolver.scan(context.Background(), callback); err != nil {
-		return err
-	}
-
-	// Search for imports matching potential package references.
-	type result struct {
-		imp *ImportInfo
-		pkg *packageInfo
-	}
-	results := make(chan result, len(refs))
-
-	ctx, cancel := context.WithCancel(context.TODO())
-	var wg sync.WaitGroup
-	defer func() {
-		cancel()
-		wg.Wait()
-	}()
-	var (
-		firstErr     error
-		firstErrOnce sync.Once
-	)
-	for pkgName, symbols := range refs {
-		wg.Add(1)
-		go func(pkgName string, symbols map[string]bool) {
-			defer wg.Done()
-
-			found, err := findImport(ctx, pass, found[pkgName], pkgName, symbols, filename)
-			if err != nil {
-				firstErrOnce.Do(func() {
-					firstErr = err
-					cancel()
-				})
-				return
-			}
-
-			if found == nil {
-				return // No matching package.
-			}
-
-			imp := &ImportInfo{
-				ImportPath: found.importPathShort,
-			}
-
-			pkg := &packageInfo{
-				name:    pkgName,
-				exports: symbols,
-			}
-			results <- result{imp, pkg}
-		}(pkgName, symbols)
-	}
-	go func() {
-		wg.Wait()
-		close(results)
-	}()
-
-	for result := range results {
-		pass.addCandidate(result.imp, result.pkg)
-	}
-	return firstErr
-}
-
-// notIdentifier reports whether ch is an invalid identifier character.
-func notIdentifier(ch rune) bool {
-	return !('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' ||
-		'0' <= ch && ch <= '9' ||
-		ch == '_' ||
-		ch >= utf8.RuneSelf && (unicode.IsLetter(ch) || unicode.IsDigit(ch)))
-}
-
-// ImportPathToAssumedName returns the assumed package name of an import path.
-// It does this using only string parsing of the import path.
-// It picks the last element of the path that does not look like a major
-// version, and then picks the valid identifier off the start of that element.
-// It is used to determine if a local rename should be added to an import for
-// clarity.
-// This function could be moved to a standard package and exported if we want
-// for use in other tools.
-func ImportPathToAssumedName(importPath string) string {
-	base := path.Base(importPath)
-	if strings.HasPrefix(base, "v") {
-		if _, err := strconv.Atoi(base[1:]); err == nil {
-			dir := path.Dir(importPath)
-			if dir != "." {
-				base = path.Base(dir)
-			}
-		}
-	}
-	base = strings.TrimPrefix(base, "go-")
-	if i := strings.IndexFunc(base, notIdentifier); i >= 0 {
-		base = base[:i]
-	}
-	return base
-}
-
-// gopathResolver implements resolver for GOPATH workspaces.
-type gopathResolver struct {
-	env      *ProcessEnv
-	walked   bool
-	cache    *dirInfoCache
-	scanSema chan struct{} // scanSema prevents concurrent scans.
-}
-
-func newGopathResolver(env *ProcessEnv) *gopathResolver {
-	r := &gopathResolver{
-		env: env,
-		cache: &dirInfoCache{
-			dirs:      map[string]*directoryPackageInfo{},
-			listeners: map[*int]cacheListener{},
-		},
-		scanSema: make(chan struct{}, 1),
-	}
-	r.scanSema <- struct{}{}
-	return r
-}
-
-func (r *gopathResolver) ClearForNewScan() {
-	<-r.scanSema
-	r.cache = &dirInfoCache{
-		dirs:      map[string]*directoryPackageInfo{},
-		listeners: map[*int]cacheListener{},
-	}
-	r.walked = false
-	r.scanSema <- struct{}{}
-}
-
-func (r *gopathResolver) loadPackageNames(importPaths []string, srcDir string) (map[string]string, error) {
-	names := map[string]string{}
-	bctx, err := r.env.buildContext()
-	if err != nil {
-		return nil, err
-	}
-	for _, path := range importPaths {
-		names[path] = importPathToName(bctx, path, srcDir)
-	}
-	return names, nil
-}
-
-// importPathToName finds out the actual package name, as declared in its .go files.
-func importPathToName(bctx *build.Context, importPath, srcDir string) string {
-	// Fast path for standard library without going to disk.
-	if _, ok := stdlib[importPath]; ok {
-		return path.Base(importPath) // stdlib packages always match their paths.
-	}
-
-	buildPkg, err := bctx.Import(importPath, srcDir, build.FindOnly)
-	if err != nil {
-		return ""
-	}
-	pkgName, err := packageDirToName(buildPkg.Dir)
-	if err != nil {
-		return ""
-	}
-	return pkgName
-}
-
-// packageDirToName is a faster version of build.Import if
-// the only thing desired is the package name. Given a directory,
-// packageDirToName then only parses one file in the package,
-// trusting that the files in the directory are consistent.
-func packageDirToName(dir string) (packageName string, err error) {
-	d, err := os.Open(dir)
-	if err != nil {
-		return "", err
-	}
-	names, err := d.Readdirnames(-1)
-	d.Close()
-	if err != nil {
-		return "", err
-	}
-	sort.Strings(names) // to have predictable behavior
-	var lastErr error
-	var nfile int
-	for _, name := range names {
-		if !strings.HasSuffix(name, ".go") {
-			continue
-		}
-		if strings.HasSuffix(name, "_test.go") {
-			continue
-		}
-		nfile++
-		fullFile := filepath.Join(dir, name)
-
-		fset := token.NewFileSet()
-		f, err := parser.ParseFile(fset, fullFile, nil, parser.PackageClauseOnly)
-		if err != nil {
-			lastErr = err
-			continue
-		}
-		pkgName := f.Name.Name
-		if pkgName == "documentation" {
-			// Special case from go/build.ImportDir, not
-			// handled by ctx.MatchFile.
-			continue
-		}
-		if pkgName == "main" {
-			// Also skip package main, assuming it's a +build ignore generator or example.
-			// Since you can't import a package main anyway, there's no harm here.
-			continue
-		}
-		return pkgName, nil
-	}
-	if lastErr != nil {
-		return "", lastErr
-	}
-	return "", fmt.Errorf("no importable package found in %d Go files", nfile)
-}
-
-type pkg struct {
-	dir             string  // absolute file path to pkg directory ("/usr/lib/go/src/net/http")
-	importPathShort string  // vendorless import path ("net/http", "a/b")
-	packageName     string  // package name loaded from source if requested
-	relevance       float64 // a weakly-defined score of how relevant a package is. 0 is most relevant.
-}
-
-type pkgDistance struct {
-	pkg      *pkg
-	distance int // relative distance to target
-}
-
-// byDistanceOrImportPathShortLength sorts by relative distance breaking ties
-// on the short import path length and then the import string itself.
-type byDistanceOrImportPathShortLength []pkgDistance
-
-func (s byDistanceOrImportPathShortLength) Len() int { return len(s) }
-func (s byDistanceOrImportPathShortLength) Less(i, j int) bool {
-	di, dj := s[i].distance, s[j].distance
-	if di == -1 {
-		return false
-	}
-	if dj == -1 {
-		return true
-	}
-	if di != dj {
-		return di < dj
-	}
-
-	vi, vj := s[i].pkg.importPathShort, s[j].pkg.importPathShort
-	if len(vi) != len(vj) {
-		return len(vi) < len(vj)
-	}
-	return vi < vj
-}
-func (s byDistanceOrImportPathShortLength) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
-
-func distance(basepath, targetpath string) int {
-	p, err := filepath.Rel(basepath, targetpath)
-	if err != nil {
-		return -1
-	}
-	if p == "." {
-		return 0
-	}
-	return strings.Count(p, string(filepath.Separator)) + 1
-}
-
-func (r *gopathResolver) scan(ctx context.Context, callback *scanCallback) error {
-	add := func(root gopathwalk.Root, dir string) {
-		// We assume cached directories have not changed. We can skip them and their
-		// children.
-		if _, ok := r.cache.Load(dir); ok {
-			return
-		}
-
-		importpath := filepath.ToSlash(dir[len(root.Path)+len("/"):])
-		info := directoryPackageInfo{
-			status:                 directoryScanned,
-			dir:                    dir,
-			rootType:               root.Type,
-			nonCanonicalImportPath: VendorlessPath(importpath),
-		}
-		r.cache.Store(dir, info)
-	}
-	processDir := func(info directoryPackageInfo) {
-		// Skip this directory if we were not able to get the package information successfully.
-		if scanned, err := info.reachedStatus(directoryScanned); !scanned || err != nil {
-			return
-		}
-
-		p := &pkg{
-			importPathShort: info.nonCanonicalImportPath,
-			dir:             info.dir,
-			relevance:       MaxRelevance - 1,
-		}
-		if info.rootType == gopathwalk.RootGOROOT {
-			p.relevance = MaxRelevance
-		}
-
-		if !callback.dirFound(p) {
-			return
-		}
-		var err error
-		p.packageName, err = r.cache.CachePackageName(info)
-		if err != nil {
-			return
-		}
-
-		if !callback.packageNameLoaded(p) {
-			return
-		}
-		if _, exports, err := r.loadExports(ctx, p, false); err == nil {
-			callback.exportsLoaded(p, exports)
-		}
-	}
-	stop := r.cache.ScanAndListen(ctx, processDir)
-	defer stop()
-
-	goenv, err := r.env.goEnv()
-	if err != nil {
-		return err
-	}
-	var roots []gopathwalk.Root
-	roots = append(roots, gopathwalk.Root{filepath.Join(goenv["GOROOT"], "src"), gopathwalk.RootGOROOT})
-	for _, p := range filepath.SplitList(goenv["GOPATH"]) {
-		roots = append(roots, gopathwalk.Root{filepath.Join(p, "src"), gopathwalk.RootGOPATH})
-	}
-	// The callback is not necessarily safe to use in the goroutine below. Process roots eagerly.
-	roots = filterRoots(roots, callback.rootFound)
-	// We can't cancel walks, because we need them to finish to have a usable
-	// cache. Instead, run them in a separate goroutine and detach.
-	scanDone := make(chan struct{})
-	go func() {
-		select {
-		case <-ctx.Done():
-			return
-		case <-r.scanSema:
-		}
-		defer func() { r.scanSema <- struct{}{} }()
-		gopathwalk.Walk(roots, add, gopathwalk.Options{Logf: r.env.Logf, ModulesEnabled: false})
-		close(scanDone)
-	}()
-	select {
-	case <-ctx.Done():
-	case <-scanDone:
-	}
-	return nil
-}
-
-func (r *gopathResolver) scoreImportPath(ctx context.Context, path string) float64 {
-	if _, ok := stdlib[path]; ok {
-		return MaxRelevance
-	}
-	return MaxRelevance - 1
-}
-
-func filterRoots(roots []gopathwalk.Root, include func(gopathwalk.Root) bool) []gopathwalk.Root {
-	var result []gopathwalk.Root
-	for _, root := range roots {
-		if !include(root) {
-			continue
-		}
-		result = append(result, root)
-	}
-	return result
-}
-
-func (r *gopathResolver) loadExports(ctx context.Context, pkg *pkg, includeTest bool) (string, []string, error) {
-	if info, ok := r.cache.Load(pkg.dir); ok && !includeTest {
-		return r.cache.CacheExports(ctx, r.env, info)
-	}
-	return loadExportsFromFiles(ctx, r.env, pkg.dir, includeTest)
-}
-
-// VendorlessPath returns the devendorized version of the import path ipath.
-// For example, VendorlessPath("foo/bar/vendor/a/b") returns "a/b".
-func VendorlessPath(ipath string) string {
-	// Devendorize for use in import statement.
-	if i := strings.LastIndex(ipath, "/vendor/"); i >= 0 {
-		return ipath[i+len("/vendor/"):]
-	}
-	if strings.HasPrefix(ipath, "vendor/") {
-		return ipath[len("vendor/"):]
-	}
-	return ipath
-}
-
-func loadExportsFromFiles(ctx context.Context, env *ProcessEnv, dir string, includeTest bool) (string, []string, error) {
-	// Look for non-test, buildable .go files which could provide exports.
-	all, err := ioutil.ReadDir(dir)
-	if err != nil {
-		return "", nil, err
-	}
-	var files []os.FileInfo
-	for _, fi := range all {
-		name := fi.Name()
-		if !strings.HasSuffix(name, ".go") || (!includeTest && strings.HasSuffix(name, "_test.go")) {
-			continue
-		}
-		match, err := env.matchFile(dir, fi.Name())
-		if err != nil || !match {
-			continue
-		}
-		files = append(files, fi)
-	}
-
-	if len(files) == 0 {
-		return "", nil, fmt.Errorf("dir %v contains no buildable, non-test .go files", dir)
-	}
-
-	var pkgName string
-	var exports []string
-	fset := token.NewFileSet()
-	for _, fi := range files {
-		select {
-		case <-ctx.Done():
-			return "", nil, ctx.Err()
-		default:
-		}
-
-		fullFile := filepath.Join(dir, fi.Name())
-		f, err := parser.ParseFile(fset, fullFile, nil, 0)
-		if err != nil {
-			if env.Logf != nil {
-				env.Logf("error parsing %v: %v", fullFile, err)
-			}
-			continue
-		}
-		if f.Name.Name == "documentation" {
-			// Special case from go/build.ImportDir, not
-			// handled by MatchFile above.
-			continue
-		}
-		if includeTest && strings.HasSuffix(f.Name.Name, "_test") {
-			// x_test package. We want internal test files only.
-			continue
-		}
-		pkgName = f.Name.Name
-		for name := range f.Scope.Objects {
-			if ast.IsExported(name) {
-				exports = append(exports, name)
-			}
-		}
-	}
-
-	if env.Logf != nil {
-		sortedExports := append([]string(nil), exports...)
-		sort.Strings(sortedExports)
-		env.Logf("loaded exports in dir %v (package %v): %v", dir, pkgName, strings.Join(sortedExports, ", "))
-	}
-	return pkgName, exports, nil
-}
-
-// findImport searches for a package with the given symbols.
-// If no package is found, findImport returns ("", false, nil)
-func findImport(ctx context.Context, pass *pass, candidates []pkgDistance, pkgName string, symbols map[string]bool, filename string) (*pkg, error) {
-	// Sort the candidates by their import package length,
-	// assuming that shorter package names are better than long
-	// ones.  Note that this sorts by the de-vendored name, so
-	// there's no "penalty" for vendoring.
-	sort.Sort(byDistanceOrImportPathShortLength(candidates))
-	if pass.env.Logf != nil {
-		for i, c := range candidates {
-			pass.env.Logf("%s candidate %d/%d: %v in %v", pkgName, i+1, len(candidates), c.pkg.importPathShort, c.pkg.dir)
-		}
-	}
-	resolver, err := pass.env.GetResolver()
-	if err != nil {
-		return nil, err
-	}
-
-	// Collect exports for packages with matching names.
-	rescv := make([]chan *pkg, len(candidates))
-	for i := range candidates {
-		rescv[i] = make(chan *pkg, 1)
-	}
-	const maxConcurrentPackageImport = 4
-	loadExportsSem := make(chan struct{}, maxConcurrentPackageImport)
-
-	ctx, cancel := context.WithCancel(ctx)
-	var wg sync.WaitGroup
-	defer func() {
-		cancel()
-		wg.Wait()
-	}()
-
-	wg.Add(1)
-	go func() {
-		defer wg.Done()
-		for i, c := range candidates {
-			select {
-			case loadExportsSem <- struct{}{}:
-			case <-ctx.Done():
-				return
-			}
-
-			wg.Add(1)
-			go func(c pkgDistance, resc chan<- *pkg) {
-				defer func() {
-					<-loadExportsSem
-					wg.Done()
-				}()
-
-				if pass.env.Logf != nil {
-					pass.env.Logf("loading exports in dir %s (seeking package %s)", c.pkg.dir, pkgName)
-				}
-				// If we're an x_test, load the package under test's test variant.
-				includeTest := strings.HasSuffix(pass.f.Name.Name, "_test") && c.pkg.dir == pass.srcDir
-				_, exports, err := resolver.loadExports(ctx, c.pkg, includeTest)
-				if err != nil {
-					if pass.env.Logf != nil {
-						pass.env.Logf("loading exports in dir %s (seeking package %s): %v", c.pkg.dir, pkgName, err)
-					}
-					resc <- nil
-					return
-				}
-
-				exportsMap := make(map[string]bool, len(exports))
-				for _, sym := range exports {
-					exportsMap[sym] = true
-				}
-
-				// If it doesn't have the right
-				// symbols, send nil to mean no match.
-				for symbol := range symbols {
-					if !exportsMap[symbol] {
-						resc <- nil
-						return
-					}
-				}
-				resc <- c.pkg
-			}(c, rescv[i])
-		}
-	}()
-
-	for _, resc := range rescv {
-		pkg := <-resc
-		if pkg == nil {
-			continue
-		}
-		return pkg, nil
-	}
-	return nil, nil
-}
-
-// pkgIsCandidate reports whether pkg is a candidate for satisfying the
-// finding which package pkgIdent in the file named by filename is trying
-// to refer to.
-//
-// This check is purely lexical and is meant to be as fast as possible
-// because it's run over all $GOPATH directories to filter out poor
-// candidates in order to limit the CPU and I/O later parsing the
-// exports in candidate packages.
-//
-// filename is the file being formatted.
-// pkgIdent is the package being searched for, like "client" (if
-// searching for "client.New")
-func pkgIsCandidate(filename string, refs references, pkg *pkg) bool {
-	// Check "internal" and "vendor" visibility:
-	if !canUse(filename, pkg.dir) {
-		return false
-	}
-
-	// Speed optimization to minimize disk I/O:
-	// the last two components on disk must contain the
-	// package name somewhere.
-	//
-	// This permits mismatch naming like directory
-	// "go-foo" being package "foo", or "pkg.v3" being "pkg",
-	// or directory "google.golang.org/api/cloudbilling/v1"
-	// being package "cloudbilling", but doesn't
-	// permit a directory "foo" to be package
-	// "bar", which is strongly discouraged
-	// anyway. There's no reason goimports needs
-	// to be slow just to accommodate that.
-	for pkgIdent := range refs {
-		lastTwo := lastTwoComponents(pkg.importPathShort)
-		if strings.Contains(lastTwo, pkgIdent) {
-			return true
-		}
-		if hasHyphenOrUpperASCII(lastTwo) && !hasHyphenOrUpperASCII(pkgIdent) {
-			lastTwo = lowerASCIIAndRemoveHyphen(lastTwo)
-			if strings.Contains(lastTwo, pkgIdent) {
-				return true
-			}
-		}
-	}
-	return false
-}
-
-func hasHyphenOrUpperASCII(s string) bool {
-	for i := 0; i < len(s); i++ {
-		b := s[i]
-		if b == '-' || ('A' <= b && b <= 'Z') {
-			return true
-		}
-	}
-	return false
-}
-
-func lowerASCIIAndRemoveHyphen(s string) (ret string) {
-	buf := make([]byte, 0, len(s))
-	for i := 0; i < len(s); i++ {
-		b := s[i]
-		switch {
-		case b == '-':
-			continue
-		case 'A' <= b && b <= 'Z':
-			buf = append(buf, b+('a'-'A'))
-		default:
-			buf = append(buf, b)
-		}
-	}
-	return string(buf)
-}
-
-// canUse reports whether the package in dir is usable from filename,
-// respecting the Go "internal" and "vendor" visibility rules.
-func canUse(filename, dir string) bool {
-	// Fast path check, before any allocations. If it doesn't contain vendor
-	// or internal, it's not tricky:
-	// Note that this can false-negative on directories like "notinternal",
-	// but we check it correctly below. This is just a fast path.
-	if !strings.Contains(dir, "vendor") && !strings.Contains(dir, "internal") {
-		return true
-	}
-
-	dirSlash := filepath.ToSlash(dir)
-	if !strings.Contains(dirSlash, "/vendor/") && !strings.Contains(dirSlash, "/internal/") && !strings.HasSuffix(dirSlash, "/internal") {
-		return true
-	}
-	// Vendor or internal directory only visible from children of parent.
-	// That means the path from the current directory to the target directory
-	// can contain ../vendor or ../internal but not ../foo/vendor or ../foo/internal
-	// or bar/vendor or bar/internal.
-	// After stripping all the leading ../, the only okay place to see vendor or internal
-	// is at the very beginning of the path.
-	absfile, err := filepath.Abs(filename)
-	if err != nil {
-		return false
-	}
-	absdir, err := filepath.Abs(dir)
-	if err != nil {
-		return false
-	}
-	rel, err := filepath.Rel(absfile, absdir)
-	if err != nil {
-		return false
-	}
-	relSlash := filepath.ToSlash(rel)
-	if i := strings.LastIndex(relSlash, "../"); i >= 0 {
-		relSlash = relSlash[i+len("../"):]
-	}
-	return !strings.Contains(relSlash, "/vendor/") && !strings.Contains(relSlash, "/internal/") && !strings.HasSuffix(relSlash, "/internal")
-}
-
-// lastTwoComponents returns at most the last two path components
-// of v, using either / or \ as the path separator.
-func lastTwoComponents(v string) string {
-	nslash := 0
-	for i := len(v) - 1; i >= 0; i-- {
-		if v[i] == '/' || v[i] == '\\' {
-			nslash++
-			if nslash == 2 {
-				return v[i:]
-			}
-		}
-	}
-	return v
-}
-
-type visitFn func(node ast.Node) ast.Visitor
-
-func (fn visitFn) Visit(node ast.Node) ast.Visitor {
-	return fn(node)
-}
-
-func copyExports(pkg []string) map[string]bool {
-	m := make(map[string]bool, len(pkg))
-	for _, v := range pkg {
-		m[v] = true
-	}
-	return m
-}
diff --git a/gofumports/internal/imports/imports.go b/gofumports/internal/imports/imports.go
deleted file mode 100644
index 2815edc..0000000
--- a/gofumports/internal/imports/imports.go
+++ /dev/null
@@ -1,346 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:generate go run mkstdlib.go
-
-// Package imports implements a Go pretty-printer (like package "go/format")
-// that also adds or removes import statements as necessary.
-package imports
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"go/ast"
-	"go/format"
-	"go/parser"
-	"go/printer"
-	"go/token"
-	"io"
-	"regexp"
-	"strconv"
-	"strings"
-
-	"golang.org/x/tools/go/ast/astutil"
-)
-
-// Options is golang.org/x/tools/imports.Options with extra internal-only options.
-type Options struct {
-	Env *ProcessEnv // The environment to use. Note: this contains the cached module and filesystem state.
-
-	// LocalPrefix is a comma-separated string of import path prefixes, which, if
-	// set, instructs Process to sort the import paths with the given prefixes
-	// into another group after 3rd-party packages.
-	LocalPrefix string
-
-	Fragment  bool // Accept fragment of a source file (no package statement)
-	AllErrors bool // Report all errors (not just the first 10 on different lines)
-
-	Comments  bool // Print comments (true if nil *Options provided)
-	TabIndent bool // Use tabs for indent (true if nil *Options provided)
-	TabWidth  int  // Tab width (8 if nil *Options provided)
-
-	FormatOnly bool // Disable the insertion and deletion of imports
-}
-
-// Process implements golang.org/x/tools/imports.Process with explicit context in opt.Env.
-func Process(filename string, src []byte, opt *Options) (formatted []byte, err error) {
-	fileSet := token.NewFileSet()
-	file, adjust, err := parse(fileSet, filename, src, opt)
-	if err != nil {
-		return nil, err
-	}
-
-	if !opt.FormatOnly {
-		if err := fixImports(fileSet, file, filename, opt.Env); err != nil {
-			return nil, err
-		}
-	}
-	return formatFile(fileSet, file, src, adjust, opt)
-}
-
-// FixImports returns a list of fixes to the imports that, when applied,
-// will leave the imports in the same state as Process. src and opt must
-// be specified.
-//
-// Note that filename's directory influences which imports can be chosen,
-// so it is important that filename be accurate.
-func FixImports(filename string, src []byte, opt *Options) (fixes []*ImportFix, err error) {
-	fileSet := token.NewFileSet()
-	file, _, err := parse(fileSet, filename, src, opt)
-	if err != nil {
-		return nil, err
-	}
-
-	return getFixes(fileSet, file, filename, opt.Env)
-}
-
-// ApplyFixes applies all of the fixes to the file and formats it. extraMode
-// is added in when parsing the file. src and opts must be specified, but no
-// env is needed.
-func ApplyFixes(fixes []*ImportFix, filename string, src []byte, opt *Options, extraMode parser.Mode) (formatted []byte, err error) {
-	// Don't use parse() -- we don't care about fragments or statement lists
-	// here, and we need to work with unparseable files.
-	fileSet := token.NewFileSet()
-	parserMode := parser.Mode(0)
-	if opt.Comments {
-		parserMode |= parser.ParseComments
-	}
-	if opt.AllErrors {
-		parserMode |= parser.AllErrors
-	}
-	parserMode |= extraMode
-
-	file, err := parser.ParseFile(fileSet, filename, src, parserMode)
-	if file == nil {
-		return nil, err
-	}
-
-	// Apply the fixes to the file.
-	apply(fileSet, file, fixes)
-
-	return formatFile(fileSet, file, src, nil, opt)
-}
-
-func formatFile(fileSet *token.FileSet, file *ast.File, src []byte, adjust func(orig []byte, src []byte) []byte, opt *Options) ([]byte, error) {
-	mergeImports(fileSet, file)
-	sortImports(opt.LocalPrefix, fileSet, file)
-	imps := astutil.Imports(fileSet, file)
-	var spacesBefore []string // import paths we need spaces before
-	for _, impSection := range imps {
-		// Within each block of contiguous imports, see if any
-		// import lines are in different group numbers. If so,
-		// we'll need to put a space between them so it's
-		// compatible with gofmt.
-		lastGroup := -1
-		for _, importSpec := range impSection {
-			importPath, _ := strconv.Unquote(importSpec.Path.Value)
-			groupNum := importGroup(opt.LocalPrefix, importPath)
-			if groupNum != lastGroup && lastGroup != -1 {
-				spacesBefore = append(spacesBefore, importPath)
-			}
-			lastGroup = groupNum
-		}
-
-	}
-
-	printerMode := printer.UseSpaces
-	if opt.TabIndent {
-		printerMode |= printer.TabIndent
-	}
-	printConfig := &printer.Config{Mode: printerMode, Tabwidth: opt.TabWidth}
-
-	var buf bytes.Buffer
-	err := printConfig.Fprint(&buf, fileSet, file)
-	if err != nil {
-		return nil, err
-	}
-	out := buf.Bytes()
-	if adjust != nil {
-		out = adjust(src, out)
-	}
-	if len(spacesBefore) > 0 {
-		out, err = addImportSpaces(bytes.NewReader(out), spacesBefore)
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	out, err = format.Source(out)
-	if err != nil {
-		return nil, err
-	}
-	return out, nil
-}
-
-// parse parses src, which was read from filename,
-// as a Go source file or statement list.
-func parse(fset *token.FileSet, filename string, src []byte, opt *Options) (*ast.File, func(orig, src []byte) []byte, error) {
-	parserMode := parser.Mode(0)
-	if opt.Comments {
-		parserMode |= parser.ParseComments
-	}
-	if opt.AllErrors {
-		parserMode |= parser.AllErrors
-	}
-
-	// Try as whole source file.
-	file, err := parser.ParseFile(fset, filename, src, parserMode)
-	if err == nil {
-		return file, nil, nil
-	}
-	// If the error is that the source file didn't begin with a
-	// package line and we accept fragmented input, fall through to
-	// try as a source fragment.  Stop and return on any other error.
-	if !opt.Fragment || !strings.Contains(err.Error(), "expected 'package'") {
-		return nil, nil, err
-	}
-
-	// If this is a declaration list, make it a source file
-	// by inserting a package clause.
-	// Insert using a ;, not a newline, so that parse errors are on
-	// the correct line.
-	const prefix = "package main;"
-	psrc := append([]byte(prefix), src...)
-	file, err = parser.ParseFile(fset, filename, psrc, parserMode)
-	if err == nil {
-		// Gofmt will turn the ; into a \n.
-		// Do that ourselves now and update the file contents,
-		// so that positions and line numbers are correct going forward.
-		psrc[len(prefix)-1] = '\n'
-		fset.File(file.Package).SetLinesForContent(psrc)
-
-		// If a main function exists, we will assume this is a main
-		// package and leave the file.
-		if containsMainFunc(file) {
-			return file, nil, nil
-		}
-
-		adjust := func(orig, src []byte) []byte {
-			// Remove the package clause.
-			src = src[len(prefix):]
-			return matchSpace(orig, src)
-		}
-		return file, adjust, nil
-	}
-	// If the error is that the source file didn't begin with a
-	// declaration, fall through to try as a statement list.
-	// Stop and return on any other error.
-	if !strings.Contains(err.Error(), "expected declaration") {
-		return nil, nil, err
-	}
-
-	// If this is a statement list, make it a source file
-	// by inserting a package clause and turning the list
-	// into a function body.  This handles expressions too.
-	// Insert using a ;, not a newline, so that the line numbers
-	// in fsrc match the ones in src.
-	fsrc := append(append([]byte("package p; func _() {"), src...), '}')
-	file, err = parser.ParseFile(fset, filename, fsrc, parserMode)
-	if err == nil {
-		adjust := func(orig, src []byte) []byte {
-			// Remove the wrapping.
-			// Gofmt has turned the ; into a \n\n.
-			src = src[len("package p\n\nfunc _() {"):]
-			src = src[:len(src)-len("}\n")]
-			// Gofmt has also indented the function body one level.
-			// Remove that indent.
-			src = bytes.Replace(src, []byte("\n\t"), []byte("\n"), -1)
-			return matchSpace(orig, src)
-		}
-		return file, adjust, nil
-	}
-
-	// Failed, and out of options.
-	return nil, nil, err
-}
-
-// containsMainFunc checks if a file contains a function declaration with the
-// function signature 'func main()'
-func containsMainFunc(file *ast.File) bool {
-	for _, decl := range file.Decls {
-		if f, ok := decl.(*ast.FuncDecl); ok {
-			if f.Name.Name != "main" {
-				continue
-			}
-
-			if len(f.Type.Params.List) != 0 {
-				continue
-			}
-
-			if f.Type.Results != nil && len(f.Type.Results.List) != 0 {
-				continue
-			}
-
-			return true
-		}
-	}
-
-	return false
-}
-
-func cutSpace(b []byte) (before, middle, after []byte) {
-	i := 0
-	for i < len(b) && (b[i] == ' ' || b[i] == '\t' || b[i] == '\n') {
-		i++
-	}
-	j := len(b)
-	for j > 0 && (b[j-1] == ' ' || b[j-1] == '\t' || b[j-1] == '\n') {
-		j--
-	}
-	if i <= j {
-		return b[:i], b[i:j], b[j:]
-	}
-	return nil, nil, b[j:]
-}
-
-// matchSpace reformats src to use the same space context as orig.
-// 1) If orig begins with blank lines, matchSpace inserts them at the beginning of src.
-// 2) matchSpace copies the indentation of the first non-blank line in orig
-//    to every non-blank line in src.
-// 3) matchSpace copies the trailing space from orig and uses it in place
-//   of src's trailing space.
-func matchSpace(orig []byte, src []byte) []byte {
-	before, _, after := cutSpace(orig)
-	i := bytes.LastIndex(before, []byte{'\n'})
-	before, indent := before[:i+1], before[i+1:]
-
-	_, src, _ = cutSpace(src)
-
-	var b bytes.Buffer
-	b.Write(before)
-	for len(src) > 0 {
-		line := src
-		if i := bytes.IndexByte(line, '\n'); i >= 0 {
-			line, src = line[:i+1], line[i+1:]
-		} else {
-			src = nil
-		}
-		if len(line) > 0 && line[0] != '\n' { // not blank
-			b.Write(indent)
-		}
-		b.Write(line)
-	}
-	b.Write(after)
-	return b.Bytes()
-}
-
-var impLine = regexp.MustCompile(`^\s+(?:[\w\.]+\s+)?"(.+)"`)
-
-func addImportSpaces(r io.Reader, breaks []string) ([]byte, error) {
-	var out bytes.Buffer
-	in := bufio.NewReader(r)
-	inImports := false
-	done := false
-	for {
-		s, err := in.ReadString('\n')
-		if err == io.EOF {
-			break
-		} else if err != nil {
-			return nil, err
-		}
-
-		if !inImports && !done && strings.HasPrefix(s, "import") {
-			inImports = true
-		}
-		if inImports && (strings.HasPrefix(s, "var") ||
-			strings.HasPrefix(s, "func") ||
-			strings.HasPrefix(s, "const") ||
-			strings.HasPrefix(s, "type")) {
-			done = true
-			inImports = false
-		}
-		if inImports && len(breaks) > 0 {
-			if m := impLine.FindStringSubmatch(s); m != nil {
-				if m[1] == breaks[0] {
-					out.WriteByte('\n')
-					breaks = breaks[1:]
-				}
-			}
-		}
-
-		fmt.Fprint(&out, s)
-	}
-	return out.Bytes(), nil
-}
diff --git a/gofumports/internal/imports/mkindex.go b/gofumports/internal/imports/mkindex.go
deleted file mode 100644
index cc3a70f..0000000
--- a/gofumports/internal/imports/mkindex.go
+++ /dev/null
@@ -1,173 +0,0 @@
-// +build ignore
-
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Command mkindex creates the file "pkgindex.go" containing an index of the Go
-// standard library. The file is intended to be built as part of the imports
-// package, so that the package may be used in environments where a GOROOT is
-// not available (such as App Engine).
-package imports
-
-import (
-	"bytes"
-	"fmt"
-	"go/ast"
-	"go/build"
-	"go/format"
-	"go/parser"
-	"go/token"
-	"io/ioutil"
-	"log"
-	"os"
-	"path"
-	"path/filepath"
-	"strings"
-)
-
-var (
-	pkgIndex = make(map[string][]pkg)
-	exports  = make(map[string]map[string]bool)
-)
-
-func main() {
-	// Don't use GOPATH.
-	ctx := build.Default
-	ctx.GOPATH = ""
-
-	// Populate pkgIndex global from GOROOT.
-	for _, path := range ctx.SrcDirs() {
-		f, err := os.Open(path)
-		if err != nil {
-			log.Print(err)
-			continue
-		}
-		children, err := f.Readdir(-1)
-		f.Close()
-		if err != nil {
-			log.Print(err)
-			continue
-		}
-		for _, child := range children {
-			if child.IsDir() {
-				loadPkg(path, child.Name())
-			}
-		}
-	}
-	// Populate exports global.
-	for _, ps := range pkgIndex {
-		for _, p := range ps {
-			e := loadExports(p.dir)
-			if e != nil {
-				exports[p.dir] = e
-			}
-		}
-	}
-
-	// Construct source file.
-	var buf bytes.Buffer
-	fmt.Fprint(&buf, pkgIndexHead)
-	fmt.Fprintf(&buf, "var pkgIndexMaster = %#v\n", pkgIndex)
-	fmt.Fprintf(&buf, "var exportsMaster = %#v\n", exports)
-	src := buf.Bytes()
-
-	// Replace main.pkg type name with pkg.
-	src = bytes.Replace(src, []byte("main.pkg"), []byte("pkg"), -1)
-	// Replace actual GOROOT with "/go".
-	src = bytes.Replace(src, []byte(ctx.GOROOT), []byte("/go"), -1)
-	// Add some line wrapping.
-	src = bytes.Replace(src, []byte("}, "), []byte("},\n"), -1)
-	src = bytes.Replace(src, []byte("true, "), []byte("true,\n"), -1)
-
-	var err error
-	src, err = format.Source(src)
-	if err != nil {
-		log.Fatal(err)
-	}
-
-	// Write out source file.
-	err = ioutil.WriteFile("pkgindex.go", src, 0o644)
-	if err != nil {
-		log.Fatal(err)
-	}
-}
-
-const pkgIndexHead = `package imports
-
-func init() {
-	pkgIndexOnce.Do(func() {
-		pkgIndex.m = pkgIndexMaster
-	})
-	loadExports = func(dir string) map[string]bool {
-		return exportsMaster[dir]
-	}
-}
-`
-
-type pkg struct {
-	importpath string // full pkg import path, e.g. "net/http"
-	dir        string // absolute file path to pkg directory e.g. "/usr/lib/go/src/fmt"
-}
-
-var fset = token.NewFileSet()
-
-func loadPkg(root, importpath string) {
-	shortName := path.Base(importpath)
-	if shortName == "testdata" {
-		return
-	}
-
-	dir := filepath.Join(root, importpath)
-	pkgIndex[shortName] = append(pkgIndex[shortName], pkg{
-		importpath: importpath,
-		dir:        dir,
-	})
-
-	pkgDir, err := os.Open(dir)
-	if err != nil {
-		return
-	}
-	children, err := pkgDir.Readdir(-1)
-	pkgDir.Close()
-	if err != nil {
-		return
-	}
-	for _, child := range children {
-		name := child.Name()
-		if name == "" {
-			continue
-		}
-		if c := name[0]; c == '.' || ('0' <= c && c <= '9') {
-			continue
-		}
-		if child.IsDir() {
-			loadPkg(root, filepath.Join(importpath, name))
-		}
-	}
-}
-
-func loadExports(dir string) map[string]bool {
-	exports := make(map[string]bool)
-	buildPkg, err := build.ImportDir(dir, 0)
-	if err != nil {
-		if strings.Contains(err.Error(), "no buildable Go source files in") {
-			return nil
-		}
-		log.Printf("could not import %q: %v", dir, err)
-		return nil
-	}
-	for _, file := range buildPkg.GoFiles {
-		f, err := parser.ParseFile(fset, filepath.Join(dir, file), nil, 0)
-		if err != nil {
-			log.Printf("could not parse %q: %v", file, err)
-			continue
-		}
-		for name := range f.Scope.Objects {
-			if ast.IsExported(name) {
-				exports[name] = true
-			}
-		}
-	}
-	return exports
-}
diff --git a/gofumports/internal/imports/mkstdlib.go b/gofumports/internal/imports/mkstdlib.go
deleted file mode 100644
index ec78c38..0000000
--- a/gofumports/internal/imports/mkstdlib.go
+++ /dev/null
@@ -1,130 +0,0 @@
-// +build ignore
-
-// mkstdlib generates the zstdlib.go file, containing the Go standard
-// library API symbols. It's baked into the binary to avoid scanning
-// GOPATH in the common case.
-package main
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"go/format"
-	"io"
-	"io/ioutil"
-	"log"
-	"os"
-	"os/exec"
-	"path/filepath"
-	"regexp"
-	"runtime"
-	"sort"
-)
-
-func mustOpen(name string) io.Reader {
-	f, err := os.Open(name)
-	if err != nil {
-		log.Fatal(err)
-	}
-	return f
-}
-
-func api(base string) string {
-	return filepath.Join(runtime.GOROOT(), "api", base)
-}
-
-var sym = regexp.MustCompile(`^pkg (\S+).*?, (?:var|func|type|const) ([A-Z]\w*)`)
-
-var unsafeSyms = map[string]bool{"Alignof": true, "ArbitraryType": true, "Offsetof": true, "Pointer": true, "Sizeof": true}
-
-func main() {
-	var buf bytes.Buffer
-	outf := func(format string, args ...interface{}) {
-		fmt.Fprintf(&buf, format, args...)
-	}
-	outf("// Code generated by mkstdlib.go. DO NOT EDIT.\n\n")
-	outf("package imports\n")
-	outf("var stdlib = map[string][]string{\n")
-	f := io.MultiReader(
-		mustOpen(api("go1.txt")),
-		mustOpen(api("go1.1.txt")),
-		mustOpen(api("go1.2.txt")),
-		mustOpen(api("go1.3.txt")),
-		mustOpen(api("go1.4.txt")),
-		mustOpen(api("go1.5.txt")),
-		mustOpen(api("go1.6.txt")),
-		mustOpen(api("go1.7.txt")),
-		mustOpen(api("go1.8.txt")),
-		mustOpen(api("go1.9.txt")),
-		mustOpen(api("go1.10.txt")),
-		mustOpen(api("go1.11.txt")),
-		mustOpen(api("go1.12.txt")),
-		mustOpen(api("go1.13.txt")),
-		mustOpen(api("go1.14.txt")),
-		mustOpen(api("go1.15.txt")),
-
-		// The API of the syscall/js package needs to be computed explicitly,
-		// because it's not included in the GOROOT/api/go1.*.txt files at this time.
-		syscallJSAPI(),
-	)
-	sc := bufio.NewScanner(f)
-
-	pkgs := map[string]map[string]bool{
-		"unsafe": unsafeSyms,
-	}
-	paths := []string{"unsafe"}
-
-	for sc.Scan() {
-		l := sc.Text()
-		if m := sym.FindStringSubmatch(l); m != nil {
-			path, sym := m[1], m[2]
-
-			if _, ok := pkgs[path]; !ok {
-				pkgs[path] = map[string]bool{}
-				paths = append(paths, path)
-			}
-			pkgs[path][sym] = true
-		}
-	}
-	if err := sc.Err(); err != nil {
-		log.Fatal(err)
-	}
-	sort.Strings(paths)
-	for _, path := range paths {
-		outf("\t%q: []string{\n", path)
-		pkg := pkgs[path]
-		var syms []string
-		for sym := range pkg {
-			syms = append(syms, sym)
-		}
-		sort.Strings(syms)
-		for _, sym := range syms {
-			outf("\t\t%q,\n", sym)
-		}
-		outf("},\n")
-	}
-	outf("}\n")
-	fmtbuf, err := format.Source(buf.Bytes())
-	if err != nil {
-		log.Fatal(err)
-	}
-	err = ioutil.WriteFile("zstdlib.go", fmtbuf, 0o666)
-	if err != nil {
-		log.Fatal(err)
-	}
-}
-
-// syscallJSAPI returns the API of the syscall/js package.
-// It's computed from the contents of $(go env GOROOT)/src/syscall/js.
-func syscallJSAPI() io.Reader {
-	var exeSuffix string
-	if runtime.GOOS == "windows" {
-		exeSuffix = ".exe"
-	}
-	cmd := exec.Command("go"+exeSuffix, "run", "cmd/api", "-contexts", "js-wasm", "syscall/js")
-	out, err := cmd.Output()
-	if err != nil {
-		log.Fatalln(err)
-	}
-	return bytes.NewReader(out)
-}
diff --git a/gofumports/internal/imports/mod.go b/gofumports/internal/imports/mod.go
deleted file mode 100644
index fa81dcf..0000000
--- a/gofumports/internal/imports/mod.go
+++ /dev/null
@@ -1,684 +0,0 @@
-package imports
-
-import (
-	"bytes"
-	"context"
-	"encoding/json"
-	"fmt"
-	"io/ioutil"
-	"os"
-	"path"
-	"path/filepath"
-	"regexp"
-	"sort"
-	"strconv"
-	"strings"
-
-	"golang.org/x/mod/module"
-	"mvdan.cc/gofumpt/gofumports/internal/gocommand"
-	"mvdan.cc/gofumpt/gofumports/internal/gopathwalk"
-)
-
-// ModuleResolver implements resolver for modules using the go command as little
-// as feasible.
-type ModuleResolver struct {
-	env            *ProcessEnv
-	moduleCacheDir string
-	dummyVendorMod *gocommand.ModuleJSON // If vendoring is enabled, the pseudo-module that represents the /vendor directory.
-	roots          []gopathwalk.Root
-	scanSema       chan struct{} // scanSema prevents concurrent scans and guards scannedRoots.
-	scannedRoots   map[gopathwalk.Root]bool
-
-	initialized   bool
-	main          *gocommand.ModuleJSON
-	modsByModPath []*gocommand.ModuleJSON // All modules, ordered by # of path components in module Path...
-	modsByDir     []*gocommand.ModuleJSON // ...or Dir.
-
-	// moduleCacheCache stores information about the module cache.
-	moduleCacheCache *dirInfoCache
-	otherCache       *dirInfoCache
-}
-
-func newModuleResolver(e *ProcessEnv) *ModuleResolver {
-	r := &ModuleResolver{
-		env:      e,
-		scanSema: make(chan struct{}, 1),
-	}
-	r.scanSema <- struct{}{}
-	return r
-}
-
-func (r *ModuleResolver) init() error {
-	if r.initialized {
-		return nil
-	}
-
-	goenv, err := r.env.goEnv()
-	if err != nil {
-		return err
-	}
-	inv := gocommand.Invocation{
-		BuildFlags: r.env.BuildFlags,
-		ModFlag:    r.env.ModFlag,
-		ModFile:    r.env.ModFile,
-		Env:        r.env.env(),
-		Logf:       r.env.Logf,
-		WorkingDir: r.env.WorkingDir,
-	}
-	mainMod, vendorEnabled, err := gocommand.VendorEnabled(context.TODO(), inv, r.env.GocmdRunner)
-	if err != nil {
-		return err
-	}
-
-	if mainMod != nil && vendorEnabled {
-		// Vendor mode is on, so all the non-Main modules are irrelevant,
-		// and we need to search /vendor for everything.
-		r.main = mainMod
-		r.dummyVendorMod = &gocommand.ModuleJSON{
-			Path: "",
-			Dir:  filepath.Join(mainMod.Dir, "vendor"),
-		}
-		r.modsByModPath = []*gocommand.ModuleJSON{mainMod, r.dummyVendorMod}
-		r.modsByDir = []*gocommand.ModuleJSON{mainMod, r.dummyVendorMod}
-	} else {
-		// Vendor mode is off, so run go list -m ... to find everything.
-		r.initAllMods()
-	}
-
-	if gmc := r.env.Env["GOMODCACHE"]; gmc != "" {
-		r.moduleCacheDir = gmc
-	} else {
-		gopaths := filepath.SplitList(goenv["GOPATH"])
-		if len(gopaths) == 0 {
-			return fmt.Errorf("empty GOPATH")
-		}
-		r.moduleCacheDir = filepath.Join(gopaths[0], "/pkg/mod")
-	}
-
-	sort.Slice(r.modsByModPath, func(i, j int) bool {
-		count := func(x int) int {
-			return strings.Count(r.modsByModPath[x].Path, "/")
-		}
-		return count(j) < count(i) // descending order
-	})
-	sort.Slice(r.modsByDir, func(i, j int) bool {
-		count := func(x int) int {
-			return strings.Count(r.modsByDir[x].Dir, "/")
-		}
-		return count(j) < count(i) // descending order
-	})
-
-	r.roots = []gopathwalk.Root{
-		{filepath.Join(goenv["GOROOT"], "/src"), gopathwalk.RootGOROOT},
-	}
-	if r.main != nil {
-		r.roots = append(r.roots, gopathwalk.Root{r.main.Dir, gopathwalk.RootCurrentModule})
-	}
-	if vendorEnabled {
-		r.roots = append(r.roots, gopathwalk.Root{r.dummyVendorMod.Dir, gopathwalk.RootOther})
-	} else {
-		addDep := func(mod *gocommand.ModuleJSON) {
-			if mod.Replace == nil {
-				// This is redundant with the cache, but we'll skip it cheaply enough.
-				r.roots = append(r.roots, gopathwalk.Root{mod.Dir, gopathwalk.RootModuleCache})
-			} else {
-				r.roots = append(r.roots, gopathwalk.Root{mod.Dir, gopathwalk.RootOther})
-			}
-		}
-		// Walk dependent modules before scanning the full mod cache, direct deps first.
-		for _, mod := range r.modsByModPath {
-			if !mod.Indirect && !mod.Main {
-				addDep(mod)
-			}
-		}
-		for _, mod := range r.modsByModPath {
-			if mod.Indirect && !mod.Main {
-				addDep(mod)
-			}
-		}
-		r.roots = append(r.roots, gopathwalk.Root{r.moduleCacheDir, gopathwalk.RootModuleCache})
-	}
-
-	r.scannedRoots = map[gopathwalk.Root]bool{}
-	if r.moduleCacheCache == nil {
-		r.moduleCacheCache = &dirInfoCache{
-			dirs:      map[string]*directoryPackageInfo{},
-			listeners: map[*int]cacheListener{},
-		}
-	}
-	if r.otherCache == nil {
-		r.otherCache = &dirInfoCache{
-			dirs:      map[string]*directoryPackageInfo{},
-			listeners: map[*int]cacheListener{},
-		}
-	}
-	r.initialized = true
-	return nil
-}
-
-func (r *ModuleResolver) initAllMods() error {
-	stdout, err := r.env.invokeGo(context.TODO(), "list", "-m", "-json", "...")
-	if err != nil {
-		return err
-	}
-	for dec := json.NewDecoder(stdout); dec.More(); {
-		mod := &gocommand.ModuleJSON{}
-		if err := dec.Decode(mod); err != nil {
-			return err
-		}
-		if mod.Dir == "" {
-			if r.env.Logf != nil {
-				r.env.Logf("module %v has not been downloaded and will be ignored", mod.Path)
-			}
-			// Can't do anything with a module that's not downloaded.
-			continue
-		}
-		// golang/go#36193: the go command doesn't always clean paths.
-		mod.Dir = filepath.Clean(mod.Dir)
-		r.modsByModPath = append(r.modsByModPath, mod)
-		r.modsByDir = append(r.modsByDir, mod)
-		if mod.Main {
-			r.main = mod
-		}
-	}
-	return nil
-}
-
-func (r *ModuleResolver) ClearForNewScan() {
-	<-r.scanSema
-	r.scannedRoots = map[gopathwalk.Root]bool{}
-	r.otherCache = &dirInfoCache{
-		dirs:      map[string]*directoryPackageInfo{},
-		listeners: map[*int]cacheListener{},
-	}
-	r.scanSema <- struct{}{}
-}
-
-func (r *ModuleResolver) ClearForNewMod() {
-	<-r.scanSema
-	*r = ModuleResolver{
-		env:              r.env,
-		moduleCacheCache: r.moduleCacheCache,
-		otherCache:       r.otherCache,
-		scanSema:         r.scanSema,
-	}
-	r.init()
-	r.scanSema <- struct{}{}
-}
-
-// findPackage returns the module and directory that contains the package at
-// the given import path, or returns nil, "" if no module is in scope.
-func (r *ModuleResolver) findPackage(importPath string) (*gocommand.ModuleJSON, string) {
-	// This can't find packages in the stdlib, but that's harmless for all
-	// the existing code paths.
-	for _, m := range r.modsByModPath {
-		if !strings.HasPrefix(importPath, m.Path) {
-			continue
-		}
-		pathInModule := importPath[len(m.Path):]
-		pkgDir := filepath.Join(m.Dir, pathInModule)
-		if r.dirIsNestedModule(pkgDir, m) {
-			continue
-		}
-
-		if info, ok := r.cacheLoad(pkgDir); ok {
-			if loaded, err := info.reachedStatus(nameLoaded); loaded {
-				if err != nil {
-					continue // No package in this dir.
-				}
-				return m, pkgDir
-			}
-			if scanned, err := info.reachedStatus(directoryScanned); scanned && err != nil {
-				continue // Dir is unreadable, etc.
-			}
-			// This is slightly wrong: a directory doesn't have to have an
-			// importable package to count as a package for package-to-module
-			// resolution. package main or _test files should count but
-			// don't.
-			// TODO(heschi): fix this.
-			if _, err := r.cachePackageName(info); err == nil {
-				return m, pkgDir
-			}
-		}
-
-		// Not cached. Read the filesystem.
-		pkgFiles, err := ioutil.ReadDir(pkgDir)
-		if err != nil {
-			continue
-		}
-		// A module only contains a package if it has buildable go
-		// files in that directory. If not, it could be provided by an
-		// outer module. See #29736.
-		for _, fi := range pkgFiles {
-			if ok, _ := r.env.matchFile(pkgDir, fi.Name()); ok {
-				return m, pkgDir
-			}
-		}
-	}
-	return nil, ""
-}
-
-func (r *ModuleResolver) cacheLoad(dir string) (directoryPackageInfo, bool) {
-	if info, ok := r.moduleCacheCache.Load(dir); ok {
-		return info, ok
-	}
-	return r.otherCache.Load(dir)
-}
-
-func (r *ModuleResolver) cacheStore(info directoryPackageInfo) {
-	if info.rootType == gopathwalk.RootModuleCache {
-		r.moduleCacheCache.Store(info.dir, info)
-	} else {
-		r.otherCache.Store(info.dir, info)
-	}
-}
-
-func (r *ModuleResolver) cacheKeys() []string {
-	return append(r.moduleCacheCache.Keys(), r.otherCache.Keys()...)
-}
-
-// cachePackageName caches the package name for a dir already in the cache.
-func (r *ModuleResolver) cachePackageName(info directoryPackageInfo) (string, error) {
-	if info.rootType == gopathwalk.RootModuleCache {
-		return r.moduleCacheCache.CachePackageName(info)
-	}
-	return r.otherCache.CachePackageName(info)
-}
-
-func (r *ModuleResolver) cacheExports(ctx context.Context, env *ProcessEnv, info directoryPackageInfo) (string, []string, error) {
-	if info.rootType == gopathwalk.RootModuleCache {
-		return r.moduleCacheCache.CacheExports(ctx, env, info)
-	}
-	return r.otherCache.CacheExports(ctx, env, info)
-}
-
-// findModuleByDir returns the module that contains dir, or nil if no such
-// module is in scope.
-func (r *ModuleResolver) findModuleByDir(dir string) *gocommand.ModuleJSON {
-	// This is quite tricky and may not be correct. dir could be:
-	// - a package in the main module.
-	// - a replace target underneath the main module's directory.
-	//    - a nested module in the above.
-	// - a replace target somewhere totally random.
-	//    - a nested module in the above.
-	// - in the mod cache.
-	// - in /vendor/ in -mod=vendor mode.
-	//    - nested module? Dunno.
-	// Rumor has it that replace targets cannot contain other replace targets.
-	for _, m := range r.modsByDir {
-		if !strings.HasPrefix(dir, m.Dir) {
-			continue
-		}
-
-		if r.dirIsNestedModule(dir, m) {
-			continue
-		}
-
-		return m
-	}
-	return nil
-}
-
-// dirIsNestedModule reports if dir is contained in a nested module underneath
-// mod, not actually in mod.
-func (r *ModuleResolver) dirIsNestedModule(dir string, mod *gocommand.ModuleJSON) bool {
-	if !strings.HasPrefix(dir, mod.Dir) {
-		return false
-	}
-	if r.dirInModuleCache(dir) {
-		// Nested modules in the module cache are pruned,
-		// so it cannot be a nested module.
-		return false
-	}
-	if mod != nil && mod == r.dummyVendorMod {
-		// The /vendor pseudomodule is flattened and doesn't actually count.
-		return false
-	}
-	modDir, _ := r.modInfo(dir)
-	if modDir == "" {
-		return false
-	}
-	return modDir != mod.Dir
-}
-
-func (r *ModuleResolver) modInfo(dir string) (modDir string, modName string) {
-	readModName := func(modFile string) string {
-		modBytes, err := ioutil.ReadFile(modFile)
-		if err != nil {
-			return ""
-		}
-		return modulePath(modBytes)
-	}
-
-	if r.dirInModuleCache(dir) {
-		if matches := modCacheRegexp.FindStringSubmatch(dir); len(matches) == 3 {
-			index := strings.Index(dir, matches[1]+"@"+matches[2])
-			modDir := filepath.Join(dir[:index], matches[1]+"@"+matches[2])
-			return modDir, readModName(filepath.Join(modDir, "go.mod"))
-		}
-	}
-	for {
-		if info, ok := r.cacheLoad(dir); ok {
-			return info.moduleDir, info.moduleName
-		}
-		f := filepath.Join(dir, "go.mod")
-		info, err := os.Stat(f)
-		if err == nil && !info.IsDir() {
-			return dir, readModName(f)
-		}
-
-		d := filepath.Dir(dir)
-		if len(d) >= len(dir) {
-			return "", "" // reached top of file system, no go.mod
-		}
-		dir = d
-	}
-}
-
-func (r *ModuleResolver) dirInModuleCache(dir string) bool {
-	if r.moduleCacheDir == "" {
-		return false
-	}
-	return strings.HasPrefix(dir, r.moduleCacheDir)
-}
-
-func (r *ModuleResolver) loadPackageNames(importPaths []string, srcDir string) (map[string]string, error) {
-	if err := r.init(); err != nil {
-		return nil, err
-	}
-	names := map[string]string{}
-	for _, path := range importPaths {
-		_, packageDir := r.findPackage(path)
-		if packageDir == "" {
-			continue
-		}
-		name, err := packageDirToName(packageDir)
-		if err != nil {
-			continue
-		}
-		names[path] = name
-	}
-	return names, nil
-}
-
-func (r *ModuleResolver) scan(ctx context.Context, callback *scanCallback) error {
-	if err := r.init(); err != nil {
-		return err
-	}
-
-	processDir := func(info directoryPackageInfo) {
-		// Skip this directory if we were not able to get the package information successfully.
-		if scanned, err := info.reachedStatus(directoryScanned); !scanned || err != nil {
-			return
-		}
-		pkg, err := r.canonicalize(info)
-		if err != nil {
-			return
-		}
-
-		if !callback.dirFound(pkg) {
-			return
-		}
-		pkg.packageName, err = r.cachePackageName(info)
-		if err != nil {
-			return
-		}
-
-		if !callback.packageNameLoaded(pkg) {
-			return
-		}
-		_, exports, err := r.loadExports(ctx, pkg, false)
-		if err != nil {
-			return
-		}
-		callback.exportsLoaded(pkg, exports)
-	}
-
-	// Start processing everything in the cache, and listen for the new stuff
-	// we discover in the walk below.
-	stop1 := r.moduleCacheCache.ScanAndListen(ctx, processDir)
-	defer stop1()
-	stop2 := r.otherCache.ScanAndListen(ctx, processDir)
-	defer stop2()
-
-	// We assume cached directories are fully cached, including all their
-	// children, and have not changed. We can skip them.
-	skip := func(root gopathwalk.Root, dir string) bool {
-		info, ok := r.cacheLoad(dir)
-		if !ok {
-			return false
-		}
-		// This directory can be skipped as long as we have already scanned it.
-		// Packages with errors will continue to have errors, so there is no need
-		// to rescan them.
-		packageScanned, _ := info.reachedStatus(directoryScanned)
-		return packageScanned
-	}
-
-	// Add anything new to the cache, and process it if we're still listening.
-	add := func(root gopathwalk.Root, dir string) {
-		r.cacheStore(r.scanDirForPackage(root, dir))
-	}
-
-	// r.roots and the callback are not necessarily safe to use in the
-	// goroutine below. Process them eagerly.
-	roots := filterRoots(r.roots, callback.rootFound)
-	// We can't cancel walks, because we need them to finish to have a usable
-	// cache. Instead, run them in a separate goroutine and detach.
-	scanDone := make(chan struct{})
-	go func() {
-		select {
-		case <-ctx.Done():
-			return
-		case <-r.scanSema:
-		}
-		defer func() { r.scanSema <- struct{}{} }()
-		// We have the lock on r.scannedRoots, and no other scans can run.
-		for _, root := range roots {
-			if ctx.Err() != nil {
-				return
-			}
-
-			if r.scannedRoots[root] {
-				continue
-			}
-			gopathwalk.WalkSkip([]gopathwalk.Root{root}, add, skip, gopathwalk.Options{Logf: r.env.Logf, ModulesEnabled: true})
-			r.scannedRoots[root] = true
-		}
-		close(scanDone)
-	}()
-	select {
-	case <-ctx.Done():
-	case <-scanDone:
-	}
-	return nil
-}
-
-func (r *ModuleResolver) scoreImportPath(ctx context.Context, path string) float64 {
-	if _, ok := stdlib[path]; ok {
-		return MaxRelevance
-	}
-	mod, _ := r.findPackage(path)
-	return modRelevance(mod)
-}
-
-func modRelevance(mod *gocommand.ModuleJSON) float64 {
-	var relevance float64
-	switch {
-	case mod == nil: // out of scope
-		return MaxRelevance - 4
-	case mod.Indirect:
-		relevance = MaxRelevance - 3
-	case !mod.Main:
-		relevance = MaxRelevance - 2
-	default:
-		relevance = MaxRelevance - 1 // main module ties with stdlib
-	}
-
-	_, versionString, ok := module.SplitPathVersion(mod.Path)
-	if ok {
-		index := strings.Index(versionString, "v")
-		if index == -1 {
-			return relevance
-		}
-		if versionNumber, err := strconv.ParseFloat(versionString[index+1:], 64); err == nil {
-			relevance += versionNumber / 1000
-		}
-	}
-
-	return relevance
-}
-
-// canonicalize gets the result of canonicalizing the packages using the results
-// of initializing the resolver from 'go list -m'.
-func (r *ModuleResolver) canonicalize(info directoryPackageInfo) (*pkg, error) {
-	// Packages in GOROOT are already canonical, regardless of the std/cmd modules.
-	if info.rootType == gopathwalk.RootGOROOT {
-		return &pkg{
-			importPathShort: info.nonCanonicalImportPath,
-			dir:             info.dir,
-			packageName:     path.Base(info.nonCanonicalImportPath),
-			relevance:       MaxRelevance,
-		}, nil
-	}
-
-	importPath := info.nonCanonicalImportPath
-	mod := r.findModuleByDir(info.dir)
-	// Check if the directory is underneath a module that's in scope.
-	if mod != nil {
-		// It is. If dir is the target of a replace directive,
-		// our guessed import path is wrong. Use the real one.
-		if mod.Dir == info.dir {
-			importPath = mod.Path
-		} else {
-			dirInMod := info.dir[len(mod.Dir)+len("/"):]
-			importPath = path.Join(mod.Path, filepath.ToSlash(dirInMod))
-		}
-	} else if !strings.HasPrefix(importPath, info.moduleName) {
-		// The module's name doesn't match the package's import path. It
-		// probably needs a replace directive we don't have.
-		return nil, fmt.Errorf("package in %q is not valid without a replace statement", info.dir)
-	}
-
-	res := &pkg{
-		importPathShort: importPath,
-		dir:             info.dir,
-		relevance:       modRelevance(mod),
-	}
-	// We may have discovered a package that has a different version
-	// in scope already. Canonicalize to that one if possible.
-	if _, canonicalDir := r.findPackage(importPath); canonicalDir != "" {
-		res.dir = canonicalDir
-	}
-	return res, nil
-}
-
-func (r *ModuleResolver) loadExports(ctx context.Context, pkg *pkg, includeTest bool) (string, []string, error) {
-	if err := r.init(); err != nil {
-		return "", nil, err
-	}
-	if info, ok := r.cacheLoad(pkg.dir); ok && !includeTest {
-		return r.cacheExports(ctx, r.env, info)
-	}
-	return loadExportsFromFiles(ctx, r.env, pkg.dir, includeTest)
-}
-
-func (r *ModuleResolver) scanDirForPackage(root gopathwalk.Root, dir string) directoryPackageInfo {
-	subdir := ""
-	if dir != root.Path {
-		subdir = dir[len(root.Path)+len("/"):]
-	}
-	importPath := filepath.ToSlash(subdir)
-	if strings.HasPrefix(importPath, "vendor/") {
-		// Only enter vendor directories if they're explicitly requested as a root.
-		return directoryPackageInfo{
-			status: directoryScanned,
-			err:    fmt.Errorf("unwanted vendor directory"),
-		}
-	}
-	switch root.Type {
-	case gopathwalk.RootCurrentModule:
-		importPath = path.Join(r.main.Path, filepath.ToSlash(subdir))
-	case gopathwalk.RootModuleCache:
-		matches := modCacheRegexp.FindStringSubmatch(subdir)
-		if len(matches) == 0 {
-			return directoryPackageInfo{
-				status: directoryScanned,
-				err:    fmt.Errorf("invalid module cache path: %v", subdir),
-			}
-		}
-		modPath, err := module.UnescapePath(filepath.ToSlash(matches[1]))
-		if err != nil {
-			if r.env.Logf != nil {
-				r.env.Logf("decoding module cache path %q: %v", subdir, err)
-			}
-			return directoryPackageInfo{
-				status: directoryScanned,
-				err:    fmt.Errorf("decoding module cache path %q: %v", subdir, err),
-			}
-		}
-		importPath = path.Join(modPath, filepath.ToSlash(matches[3]))
-	}
-
-	modDir, modName := r.modInfo(dir)
-	result := directoryPackageInfo{
-		status:                 directoryScanned,
-		dir:                    dir,
-		rootType:               root.Type,
-		nonCanonicalImportPath: importPath,
-		moduleDir:              modDir,
-		moduleName:             modName,
-	}
-	if root.Type == gopathwalk.RootGOROOT {
-		// stdlib packages are always in scope, despite the confusing go.mod
-		return result
-	}
-	return result
-}
-
-// modCacheRegexp splits a path in a module cache into module, module version, and package.
-var modCacheRegexp = regexp.MustCompile(`(.*)@([^/\\]*)(.*)`)
-
-var (
-	slashSlash = []byte("//")
-	moduleStr  = []byte("module")
-)
-
-// modulePath returns the module path from the gomod file text.
-// If it cannot find a module path, it returns an empty string.
-// It is tolerant of unrelated problems in the go.mod file.
-//
-// Copied from cmd/go/internal/modfile.
-func modulePath(mod []byte) string {
-	for len(mod) > 0 {
-		line := mod
-		mod = nil
-		if i := bytes.IndexByte(line, '\n'); i >= 0 {
-			line, mod = line[:i], line[i+1:]
-		}
-		if i := bytes.Index(line, slashSlash); i >= 0 {
-			line = line[:i]
-		}
-		line = bytes.TrimSpace(line)
-		if !bytes.HasPrefix(line, moduleStr) {
-			continue
-		}
-		line = line[len(moduleStr):]
-		n := len(line)
-		line = bytes.TrimSpace(line)
-		if len(line) == n || len(line) == 0 {
-			continue
-		}
-
-		if line[0] == '"' || line[0] == '`' {
-			p, err := strconv.Unquote(string(line))
-			if err != nil {
-				return "" // malformed quoted string or multiline module path
-			}
-			return p
-		}
-
-		return string(line)
-	}
-	return "" // missing module path
-}
diff --git a/gofumports/internal/imports/mod_cache.go b/gofumports/internal/imports/mod_cache.go
deleted file mode 100644
index bd3fb53..0000000
--- a/gofumports/internal/imports/mod_cache.go
+++ /dev/null
@@ -1,232 +0,0 @@
-package imports
-
-import (
-	"context"
-	"fmt"
-	"sync"
-
-	"mvdan.cc/gofumpt/gofumports/internal/gopathwalk"
-)
-
-// To find packages to import, the resolver needs to know about all of the
-// the packages that could be imported. This includes packages that are
-// already in modules that are in (1) the current module, (2) replace targets,
-// and (3) packages in the module cache. Packages in (1) and (2) may change over
-// time, as the client may edit the current module and locally replaced modules.
-// The module cache (which includes all of the packages in (3)) can only
-// ever be added to.
-//
-// The resolver can thus save state about packages in the module cache
-// and guarantee that this will not change over time. To obtain information
-// about new modules added to the module cache, the module cache should be
-// rescanned.
-//
-// It is OK to serve information about modules that have been deleted,
-// as they do still exist.
-// TODO(suzmue): can we share information with the caller about
-// what module needs to be downloaded to import this package?
-
-type directoryPackageStatus int
-
-const (
-	_ directoryPackageStatus = iota
-	directoryScanned
-	nameLoaded
-	exportsLoaded
-)
-
-type directoryPackageInfo struct {
-	// status indicates the extent to which this struct has been filled in.
-	status directoryPackageStatus
-	// err is non-nil when there was an error trying to reach status.
-	err error
-
-	// Set when status >= directoryScanned.
-
-	// dir is the absolute directory of this package.
-	dir      string
-	rootType gopathwalk.RootType
-	// nonCanonicalImportPath is the package's expected import path. It may
-	// not actually be importable at that path.
-	nonCanonicalImportPath string
-
-	// Module-related information.
-	moduleDir  string // The directory that is the module root of this dir.
-	moduleName string // The module name that contains this dir.
-
-	// Set when status >= nameLoaded.
-
-	packageName string // the package name, as declared in the source.
-
-	// Set when status >= exportsLoaded.
-
-	exports []string
-}
-
-// reachedStatus returns true when info has a status at least target and any error associated with
-// an attempt to reach target.
-func (info *directoryPackageInfo) reachedStatus(target directoryPackageStatus) (bool, error) {
-	if info.err == nil {
-		return info.status >= target, nil
-	}
-	if info.status == target {
-		return true, info.err
-	}
-	return true, nil
-}
-
-// dirInfoCache is a concurrency safe map for storing information about
-// directories that may contain packages.
-//
-// The information in this cache is built incrementally. Entries are initialized in scan.
-// No new keys should be added in any other functions, as all directories containing
-// packages are identified in scan.
-//
-// Other functions, including loadExports and findPackage, may update entries in this cache
-// as they discover new things about the directory.
-//
-// The information in the cache is not expected to change for the cache's
-// lifetime, so there is no protection against competing writes. Users should
-// take care not to hold the cache across changes to the underlying files.
-//
-// TODO(suzmue): consider other concurrency strategies and data structures (RWLocks, sync.Map, etc)
-type dirInfoCache struct {
-	mu sync.Mutex
-	// dirs stores information about packages in directories, keyed by absolute path.
-	dirs      map[string]*directoryPackageInfo
-	listeners map[*int]cacheListener
-}
-
-type cacheListener func(directoryPackageInfo)
-
-// ScanAndListen calls listener on all the items in the cache, and on anything
-// newly added. The returned stop function waits for all in-flight callbacks to
-// finish and blocks new ones.
-func (d *dirInfoCache) ScanAndListen(ctx context.Context, listener cacheListener) func() {
-	ctx, cancel := context.WithCancel(ctx)
-
-	// Flushing out all the callbacks is tricky without knowing how many there
-	// are going to be. Setting an arbitrary limit makes it much easier.
-	const maxInFlight = 10
-	sema := make(chan struct{}, maxInFlight)
-	for i := 0; i < maxInFlight; i++ {
-		sema <- struct{}{}
-	}
-
-	cookie := new(int) // A unique ID we can use for the listener.
-
-	// We can't hold mu while calling the listener.
-	d.mu.Lock()
-	var keys []string
-	for key := range d.dirs {
-		keys = append(keys, key)
-	}
-	d.listeners[cookie] = func(info directoryPackageInfo) {
-		select {
-		case <-ctx.Done():
-			return
-		case <-sema:
-		}
-		listener(info)
-		sema <- struct{}{}
-	}
-	d.mu.Unlock()
-
-	stop := func() {
-		cancel()
-		d.mu.Lock()
-		delete(d.listeners, cookie)
-		d.mu.Unlock()
-		for i := 0; i < maxInFlight; i++ {
-			<-sema
-		}
-	}
-
-	// Process the pre-existing keys.
-	for _, k := range keys {
-		select {
-		case <-ctx.Done():
-			return stop
-		default:
-		}
-		if v, ok := d.Load(k); ok {
-			listener(v)
-		}
-	}
-
-	return stop
-}
-
-// Store stores the package info for dir.
-func (d *dirInfoCache) Store(dir string, info directoryPackageInfo) {
-	d.mu.Lock()
-	_, old := d.dirs[dir]
-	d.dirs[dir] = &info
-	var listeners []cacheListener
-	for _, l := range d.listeners {
-		listeners = append(listeners, l)
-	}
-	d.mu.Unlock()
-
-	if !old {
-		for _, l := range listeners {
-			l(info)
-		}
-	}
-}
-
-// Load returns a copy of the directoryPackageInfo for absolute directory dir.
-func (d *dirInfoCache) Load(dir string) (directoryPackageInfo, bool) {
-	d.mu.Lock()
-	defer d.mu.Unlock()
-	info, ok := d.dirs[dir]
-	if !ok {
-		return directoryPackageInfo{}, false
-	}
-	return *info, true
-}
-
-// Keys returns the keys currently present in d.
-func (d *dirInfoCache) Keys() (keys []string) {
-	d.mu.Lock()
-	defer d.mu.Unlock()
-	for key := range d.dirs {
-		keys = append(keys, key)
-	}
-	return keys
-}
-
-func (d *dirInfoCache) CachePackageName(info directoryPackageInfo) (string, error) {
-	if loaded, err := info.reachedStatus(nameLoaded); loaded {
-		return info.packageName, err
-	}
-	if scanned, err := info.reachedStatus(directoryScanned); !scanned || err != nil {
-		return "", fmt.Errorf("cannot read package name, scan error: %v", err)
-	}
-	info.packageName, info.err = packageDirToName(info.dir)
-	info.status = nameLoaded
-	d.Store(info.dir, info)
-	return info.packageName, info.err
-}
-
-func (d *dirInfoCache) CacheExports(ctx context.Context, env *ProcessEnv, info directoryPackageInfo) (string, []string, error) {
-	if reached, _ := info.reachedStatus(exportsLoaded); reached {
-		return info.packageName, info.exports, info.err
-	}
-	if reached, err := info.reachedStatus(nameLoaded); reached && err != nil {
-		return "", nil, err
-	}
-	info.packageName, info.exports, info.err = loadExportsFromFiles(ctx, env, info.dir, false)
-	if info.err == context.Canceled || info.err == context.DeadlineExceeded {
-		return info.packageName, info.exports, info.err
-	}
-	// The cache structure wants things to proceed linearly. We can skip a
-	// step here, but only if we succeed.
-	if info.status == nameLoaded || info.err == nil {
-		info.status = exportsLoaded
-	} else {
-		info.status = nameLoaded
-	}
-	d.Store(info.dir, info)
-	return info.packageName, info.exports, info.err
-}
diff --git a/gofumports/internal/imports/sortimports.go b/gofumports/internal/imports/sortimports.go
deleted file mode 100644
index be8ffa2..0000000
--- a/gofumports/internal/imports/sortimports.go
+++ /dev/null
@@ -1,280 +0,0 @@
-// Copyright 2013 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Hacked up copy of go/ast/import.go
-
-package imports
-
-import (
-	"go/ast"
-	"go/token"
-	"sort"
-	"strconv"
-)
-
-// sortImports sorts runs of consecutive import lines in import blocks in f.
-// It also removes duplicate imports when it is possible to do so without data loss.
-func sortImports(localPrefix string, fset *token.FileSet, f *ast.File) {
-	for i, d := range f.Decls {
-		d, ok := d.(*ast.GenDecl)
-		if !ok || d.Tok != token.IMPORT {
-			// Not an import declaration, so we're done.
-			// Imports are always first.
-			break
-		}
-
-		if len(d.Specs) == 0 {
-			// Empty import block, remove it.
-			f.Decls = append(f.Decls[:i], f.Decls[i+1:]...)
-		}
-
-		if !d.Lparen.IsValid() {
-			// Not a block: sorted by default.
-			continue
-		}
-
-		// Identify and sort runs of specs on successive lines.
-		i := 0
-		specs := d.Specs[:0]
-		for j, s := range d.Specs {
-			if j > i && fset.Position(s.Pos()).Line > 1+fset.Position(d.Specs[j-1].End()).Line {
-				// j begins a new run.  End this one.
-				specs = append(specs, sortSpecs(localPrefix, fset, f, d.Specs[i:j])...)
-				i = j
-			}
-		}
-		specs = append(specs, sortSpecs(localPrefix, fset, f, d.Specs[i:])...)
-		d.Specs = specs
-
-		// Deduping can leave a blank line before the rparen; clean that up.
-		if len(d.Specs) > 0 {
-			lastSpec := d.Specs[len(d.Specs)-1]
-			lastLine := fset.Position(lastSpec.Pos()).Line
-			if rParenLine := fset.Position(d.Rparen).Line; rParenLine > lastLine+1 {
-				fset.File(d.Rparen).MergeLine(rParenLine - 1)
-			}
-		}
-	}
-}
-
-// mergeImports merges all the import declarations into the first one.
-// Taken from golang.org/x/tools/ast/astutil.
-func mergeImports(fset *token.FileSet, f *ast.File) {
-	if len(f.Decls) <= 1 {
-		return
-	}
-
-	// Merge all the import declarations into the first one.
-	var first *ast.GenDecl
-	for i := 0; i < len(f.Decls); i++ {
-		decl := f.Decls[i]
-		gen, ok := decl.(*ast.GenDecl)
-		if !ok || gen.Tok != token.IMPORT || declImports(gen, "C") {
-			continue
-		}
-		if first == nil {
-			first = gen
-			continue // Don't touch the first one.
-		}
-		// We now know there is more than one package in this import
-		// declaration. Ensure that it ends up parenthesized.
-		first.Lparen = first.Pos()
-		// Move the imports of the other import declaration to the first one.
-		for _, spec := range gen.Specs {
-			spec.(*ast.ImportSpec).Path.ValuePos = first.Pos()
-			first.Specs = append(first.Specs, spec)
-		}
-		f.Decls = append(f.Decls[:i], f.Decls[i+1:]...)
-		i--
-	}
-}
-
-// declImports reports whether gen contains an import of path.
-// Taken from golang.org/x/tools/ast/astutil.
-func declImports(gen *ast.GenDecl, path string) bool {
-	if gen.Tok != token.IMPORT {
-		return false
-	}
-	for _, spec := range gen.Specs {
-		impspec := spec.(*ast.ImportSpec)
-		if importPath(impspec) == path {
-			return true
-		}
-	}
-	return false
-}
-
-func importPath(s ast.Spec) string {
-	t, err := strconv.Unquote(s.(*ast.ImportSpec).Path.Value)
-	if err == nil {
-		return t
-	}
-	return ""
-}
-
-func importName(s ast.Spec) string {
-	n := s.(*ast.ImportSpec).Name
-	if n == nil {
-		return ""
-	}
-	return n.Name
-}
-
-func importComment(s ast.Spec) string {
-	c := s.(*ast.ImportSpec).Comment
-	if c == nil {
-		return ""
-	}
-	return c.Text()
-}
-
-// collapse indicates whether prev may be removed, leaving only next.
-func collapse(prev, next ast.Spec) bool {
-	if importPath(next) != importPath(prev) || importName(next) != importName(prev) {
-		return false
-	}
-	return prev.(*ast.ImportSpec).Comment == nil
-}
-
-type posSpan struct {
-	Start token.Pos
-	End   token.Pos
-}
-
-func sortSpecs(localPrefix string, fset *token.FileSet, f *ast.File, specs []ast.Spec) []ast.Spec {
-	// Can't short-circuit here even if specs are already sorted,
-	// since they might yet need deduplication.
-	// A lone import, however, may be safely ignored.
-	if len(specs) <= 1 {
-		return specs
-	}
-
-	// Record positions for specs.
-	pos := make([]posSpan, len(specs))
-	for i, s := range specs {
-		pos[i] = posSpan{s.Pos(), s.End()}
-	}
-
-	// Identify comments in this range.
-	// Any comment from pos[0].Start to the final line counts.
-	lastLine := fset.Position(pos[len(pos)-1].End).Line
-	cstart := len(f.Comments)
-	cend := len(f.Comments)
-	for i, g := range f.Comments {
-		if g.Pos() < pos[0].Start {
-			continue
-		}
-		if i < cstart {
-			cstart = i
-		}
-		if fset.Position(g.End()).Line > lastLine {
-			cend = i
-			break
-		}
-	}
-	comments := f.Comments[cstart:cend]
-
-	// Assign each comment to the import spec preceding it.
-	importComment := map[*ast.ImportSpec][]*ast.CommentGroup{}
-	specIndex := 0
-	for _, g := range comments {
-		for specIndex+1 < len(specs) && pos[specIndex+1].Start <= g.Pos() {
-			specIndex++
-		}
-		s := specs[specIndex].(*ast.ImportSpec)
-		importComment[s] = append(importComment[s], g)
-	}
-
-	// Sort the import specs by import path.
-	// Remove duplicates, when possible without data loss.
-	// Reassign the import paths to have the same position sequence.
-	// Reassign each comment to abut the end of its spec.
-	// Sort the comments by new position.
-	sort.Sort(byImportSpec{localPrefix, specs})
-
-	// Dedup. Thanks to our sorting, we can just consider
-	// adjacent pairs of imports.
-	deduped := specs[:0]
-	for i, s := range specs {
-		if i == len(specs)-1 || !collapse(s, specs[i+1]) {
-			deduped = append(deduped, s)
-		} else {
-			p := s.Pos()
-			fset.File(p).MergeLine(fset.Position(p).Line)
-		}
-	}
-	specs = deduped
-
-	// Fix up comment positions
-	for i, s := range specs {
-		s := s.(*ast.ImportSpec)
-		if s.Name != nil {
-			s.Name.NamePos = pos[i].Start
-		}
-		s.Path.ValuePos = pos[i].Start
-		s.EndPos = pos[i].End
-		nextSpecPos := pos[i].End
-
-		for _, g := range importComment[s] {
-			for _, c := range g.List {
-				c.Slash = pos[i].End
-				nextSpecPos = c.End()
-			}
-		}
-		if i < len(specs)-1 {
-			pos[i+1].Start = nextSpecPos
-			pos[i+1].End = nextSpecPos
-		}
-	}
-
-	sort.Sort(byCommentPos(comments))
-
-	// Fixup comments can insert blank lines, because import specs are on different lines.
-	// We remove those blank lines here by merging import spec to the first import spec line.
-	firstSpecLine := fset.Position(specs[0].Pos()).Line
-	for _, s := range specs[1:] {
-		p := s.Pos()
-		line := fset.File(p).Line(p)
-		for previousLine := line - 1; previousLine >= firstSpecLine; {
-			fset.File(p).MergeLine(previousLine)
-			previousLine--
-		}
-	}
-	return specs
-}
-
-type byImportSpec struct {
-	localPrefix string
-	specs       []ast.Spec // slice of *ast.ImportSpec
-}
-
-func (x byImportSpec) Len() int      { return len(x.specs) }
-func (x byImportSpec) Swap(i, j int) { x.specs[i], x.specs[j] = x.specs[j], x.specs[i] }
-func (x byImportSpec) Less(i, j int) bool {
-	ipath := importPath(x.specs[i])
-	jpath := importPath(x.specs[j])
-
-	igroup := importGroup(x.localPrefix, ipath)
-	jgroup := importGroup(x.localPrefix, jpath)
-	if igroup != jgroup {
-		return igroup < jgroup
-	}
-
-	if ipath != jpath {
-		return ipath < jpath
-	}
-	iname := importName(x.specs[i])
-	jname := importName(x.specs[j])
-
-	if iname != jname {
-		return iname < jname
-	}
-	return importComment(x.specs[i]) < importComment(x.specs[j])
-}
-
-type byCommentPos []*ast.CommentGroup
-
-func (x byCommentPos) Len() int           { return len(x) }
-func (x byCommentPos) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
-func (x byCommentPos) Less(i, j int) bool { return x[i].Pos() < x[j].Pos() }
diff --git a/gofumports/internal/imports/zstdlib.go b/gofumports/internal/imports/zstdlib.go
deleted file mode 100644
index f37fbdd..0000000
--- a/gofumports/internal/imports/zstdlib.go
+++ /dev/null
@@ -1,10516 +0,0 @@
-// Code generated by mkstdlib.go. DO NOT EDIT.
-
-package imports
-
-var stdlib = map[string][]string{
-	"archive/tar": {
-		"ErrFieldTooLong",
-		"ErrHeader",
-		"ErrWriteAfterClose",
-		"ErrWriteTooLong",
-		"FileInfoHeader",
-		"Format",
-		"FormatGNU",
-		"FormatPAX",
-		"FormatUSTAR",
-		"FormatUnknown",
-		"Header",
-		"NewReader",
-		"NewWriter",
-		"Reader",
-		"TypeBlock",
-		"TypeChar",
-		"TypeCont",
-		"TypeDir",
-		"TypeFifo",
-		"TypeGNULongLink",
-		"TypeGNULongName",
-		"TypeGNUSparse",
-		"TypeLink",
-		"TypeReg",
-		"TypeRegA",
-		"TypeSymlink",
-		"TypeXGlobalHeader",
-		"TypeXHeader",
-		"Writer",
-	},
-	"archive/zip": {
-		"Compressor",
-		"Decompressor",
-		"Deflate",
-		"ErrAlgorithm",
-		"ErrChecksum",
-		"ErrFormat",
-		"File",
-		"FileHeader",
-		"FileInfoHeader",
-		"NewReader",
-		"NewWriter",
-		"OpenReader",
-		"ReadCloser",
-		"Reader",
-		"RegisterCompressor",
-		"RegisterDecompressor",
-		"Store",
-		"Writer",
-	},
-	"bufio": {
-		"ErrAdvanceTooFar",
-		"ErrBadReadCount",
-		"ErrBufferFull",
-		"ErrFinalToken",
-		"ErrInvalidUnreadByte",
-		"ErrInvalidUnreadRune",
-		"ErrNegativeAdvance",
-		"ErrNegativeCount",
-		"ErrTooLong",
-		"MaxScanTokenSize",
-		"NewReadWriter",
-		"NewReader",
-		"NewReaderSize",
-		"NewScanner",
-		"NewWriter",
-		"NewWriterSize",
-		"ReadWriter",
-		"Reader",
-		"ScanBytes",
-		"ScanLines",
-		"ScanRunes",
-		"ScanWords",
-		"Scanner",
-		"SplitFunc",
-		"Writer",
-	},
-	"bytes": {
-		"Buffer",
-		"Compare",
-		"Contains",
-		"ContainsAny",
-		"ContainsRune",
-		"Count",
-		"Equal",
-		"EqualFold",
-		"ErrTooLarge",
-		"Fields",
-		"FieldsFunc",
-		"HasPrefix",
-		"HasSuffix",
-		"Index",
-		"IndexAny",
-		"IndexByte",
-		"IndexFunc",
-		"IndexRune",
-		"Join",
-		"LastIndex",
-		"LastIndexAny",
-		"LastIndexByte",
-		"LastIndexFunc",
-		"Map",
-		"MinRead",
-		"NewBuffer",
-		"NewBufferString",
-		"NewReader",
-		"Reader",
-		"Repeat",
-		"Replace",
-		"ReplaceAll",
-		"Runes",
-		"Split",
-		"SplitAfter",
-		"SplitAfterN",
-		"SplitN",
-		"Title",
-		"ToLower",
-		"ToLowerSpecial",
-		"ToTitle",
-		"ToTitleSpecial",
-		"ToUpper",
-		"ToUpperSpecial",
-		"ToValidUTF8",
-		"Trim",
-		"TrimFunc",
-		"TrimLeft",
-		"TrimLeftFunc",
-		"TrimPrefix",
-		"TrimRight",
-		"TrimRightFunc",
-		"TrimSpace",
-		"TrimSuffix",
-	},
-	"compress/bzip2": {
-		"NewReader",
-		"StructuralError",
-	},
-	"compress/flate": {
-		"BestCompression",
-		"BestSpeed",
-		"CorruptInputError",
-		"DefaultCompression",
-		"HuffmanOnly",
-		"InternalError",
-		"NewReader",
-		"NewReaderDict",
-		"NewWriter",
-		"NewWriterDict",
-		"NoCompression",
-		"ReadError",
-		"Reader",
-		"Resetter",
-		"WriteError",
-		"Writer",
-	},
-	"compress/gzip": {
-		"BestCompression",
-		"BestSpeed",
-		"DefaultCompression",
-		"ErrChecksum",
-		"ErrHeader",
-		"Header",
-		"HuffmanOnly",
-		"NewReader",
-		"NewWriter",
-		"NewWriterLevel",
-		"NoCompression",
-		"Reader",
-		"Writer",
-	},
-	"compress/lzw": {
-		"LSB",
-		"MSB",
-		"NewReader",
-		"NewWriter",
-		"Order",
-	},
-	"compress/zlib": {
-		"BestCompression",
-		"BestSpeed",
-		"DefaultCompression",
-		"ErrChecksum",
-		"ErrDictionary",
-		"ErrHeader",
-		"HuffmanOnly",
-		"NewReader",
-		"NewReaderDict",
-		"NewWriter",
-		"NewWriterLevel",
-		"NewWriterLevelDict",
-		"NoCompression",
-		"Resetter",
-		"Writer",
-	},
-	"container/heap": {
-		"Fix",
-		"Init",
-		"Interface",
-		"Pop",
-		"Push",
-		"Remove",
-	},
-	"container/list": {
-		"Element",
-		"List",
-		"New",
-	},
-	"container/ring": {
-		"New",
-		"Ring",
-	},
-	"context": {
-		"Background",
-		"CancelFunc",
-		"Canceled",
-		"Context",
-		"DeadlineExceeded",
-		"TODO",
-		"WithCancel",
-		"WithDeadline",
-		"WithTimeout",
-		"WithValue",
-	},
-	"crypto": {
-		"BLAKE2b_256",
-		"BLAKE2b_384",
-		"BLAKE2b_512",
-		"BLAKE2s_256",
-		"Decrypter",
-		"DecrypterOpts",
-		"Hash",
-		"MD4",
-		"MD5",
-		"MD5SHA1",
-		"PrivateKey",
-		"PublicKey",
-		"RIPEMD160",
-		"RegisterHash",
-		"SHA1",
-		"SHA224",
-		"SHA256",
-		"SHA384",
-		"SHA3_224",
-		"SHA3_256",
-		"SHA3_384",
-		"SHA3_512",
-		"SHA512",
-		"SHA512_224",
-		"SHA512_256",
-		"Signer",
-		"SignerOpts",
-	},
-	"crypto/aes": {
-		"BlockSize",
-		"KeySizeError",
-		"NewCipher",
-	},
-	"crypto/cipher": {
-		"AEAD",
-		"Block",
-		"BlockMode",
-		"NewCBCDecrypter",
-		"NewCBCEncrypter",
-		"NewCFBDecrypter",
-		"NewCFBEncrypter",
-		"NewCTR",
-		"NewGCM",
-		"NewGCMWithNonceSize",
-		"NewGCMWithTagSize",
-		"NewOFB",
-		"Stream",
-		"StreamReader",
-		"StreamWriter",
-	},
-	"crypto/des": {
-		"BlockSize",
-		"KeySizeError",
-		"NewCipher",
-		"NewTripleDESCipher",
-	},
-	"crypto/dsa": {
-		"ErrInvalidPublicKey",
-		"GenerateKey",
-		"GenerateParameters",
-		"L1024N160",
-		"L2048N224",
-		"L2048N256",
-		"L3072N256",
-		"ParameterSizes",
-		"Parameters",
-		"PrivateKey",
-		"PublicKey",
-		"Sign",
-		"Verify",
-	},
-	"crypto/ecdsa": {
-		"GenerateKey",
-		"PrivateKey",
-		"PublicKey",
-		"Sign",
-		"SignASN1",
-		"Verify",
-		"VerifyASN1",
-	},
-	"crypto/ed25519": {
-		"GenerateKey",
-		"NewKeyFromSeed",
-		"PrivateKey",
-		"PrivateKeySize",
-		"PublicKey",
-		"PublicKeySize",
-		"SeedSize",
-		"Sign",
-		"SignatureSize",
-		"Verify",
-	},
-	"crypto/elliptic": {
-		"Curve",
-		"CurveParams",
-		"GenerateKey",
-		"Marshal",
-		"MarshalCompressed",
-		"P224",
-		"P256",
-		"P384",
-		"P521",
-		"Unmarshal",
-		"UnmarshalCompressed",
-	},
-	"crypto/hmac": {
-		"Equal",
-		"New",
-	},
-	"crypto/md5": {
-		"BlockSize",
-		"New",
-		"Size",
-		"Sum",
-	},
-	"crypto/rand": {
-		"Int",
-		"Prime",
-		"Read",
-		"Reader",
-	},
-	"crypto/rc4": {
-		"Cipher",
-		"KeySizeError",
-		"NewCipher",
-	},
-	"crypto/rsa": {
-		"CRTValue",
-		"DecryptOAEP",
-		"DecryptPKCS1v15",
-		"DecryptPKCS1v15SessionKey",
-		"EncryptOAEP",
-		"EncryptPKCS1v15",
-		"ErrDecryption",
-		"ErrMessageTooLong",
-		"ErrVerification",
-		"GenerateKey",
-		"GenerateMultiPrimeKey",
-		"OAEPOptions",
-		"PKCS1v15DecryptOptions",
-		"PSSOptions",
-		"PSSSaltLengthAuto",
-		"PSSSaltLengthEqualsHash",
-		"PrecomputedValues",
-		"PrivateKey",
-		"PublicKey",
-		"SignPKCS1v15",
-		"SignPSS",
-		"VerifyPKCS1v15",
-		"VerifyPSS",
-	},
-	"crypto/sha1": {
-		"BlockSize",
-		"New",
-		"Size",
-		"Sum",
-	},
-	"crypto/sha256": {
-		"BlockSize",
-		"New",
-		"New224",
-		"Size",
-		"Size224",
-		"Sum224",
-		"Sum256",
-	},
-	"crypto/sha512": {
-		"BlockSize",
-		"New",
-		"New384",
-		"New512_224",
-		"New512_256",
-		"Size",
-		"Size224",
-		"Size256",
-		"Size384",
-		"Sum384",
-		"Sum512",
-		"Sum512_224",
-		"Sum512_256",
-	},
-	"crypto/subtle": {
-		"ConstantTimeByteEq",
-		"ConstantTimeCompare",
-		"ConstantTimeCopy",
-		"ConstantTimeEq",
-		"ConstantTimeLessOrEq",
-		"ConstantTimeSelect",
-	},
-	"crypto/tls": {
-		"Certificate",
-		"CertificateRequestInfo",
-		"CipherSuite",
-		"CipherSuiteName",
-		"CipherSuites",
-		"Client",
-		"ClientAuthType",
-		"ClientHelloInfo",
-		"ClientSessionCache",
-		"ClientSessionState",
-		"Config",
-		"Conn",
-		"ConnectionState",
-		"CurveID",
-		"CurveP256",
-		"CurveP384",
-		"CurveP521",
-		"Dial",
-		"DialWithDialer",
-		"Dialer",
-		"ECDSAWithP256AndSHA256",
-		"ECDSAWithP384AndSHA384",
-		"ECDSAWithP521AndSHA512",
-		"ECDSAWithSHA1",
-		"Ed25519",
-		"InsecureCipherSuites",
-		"Listen",
-		"LoadX509KeyPair",
-		"NewLRUClientSessionCache",
-		"NewListener",
-		"NoClientCert",
-		"PKCS1WithSHA1",
-		"PKCS1WithSHA256",
-		"PKCS1WithSHA384",
-		"PKCS1WithSHA512",
-		"PSSWithSHA256",
-		"PSSWithSHA384",
-		"PSSWithSHA512",
-		"RecordHeaderError",
-		"RenegotiateFreelyAsClient",
-		"RenegotiateNever",
-		"RenegotiateOnceAsClient",
-		"RenegotiationSupport",
-		"RequestClientCert",
-		"RequireAndVerifyClientCert",
-		"RequireAnyClientCert",
-		"Server",
-		"SignatureScheme",
-		"TLS_AES_128_GCM_SHA256",
-		"TLS_AES_256_GCM_SHA384",
-		"TLS_CHACHA20_POLY1305_SHA256",
-		"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
-		"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
-		"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
-		"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
-		"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
-		"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305",
-		"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
-		"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
-		"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
-		"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
-		"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
-		"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
-		"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
-		"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
-		"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305",
-		"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256",
-		"TLS_ECDHE_RSA_WITH_RC4_128_SHA",
-		"TLS_FALLBACK_SCSV",
-		"TLS_RSA_WITH_3DES_EDE_CBC_SHA",
-		"TLS_RSA_WITH_AES_128_CBC_SHA",
-		"TLS_RSA_WITH_AES_128_CBC_SHA256",
-		"TLS_RSA_WITH_AES_128_GCM_SHA256",
-		"TLS_RSA_WITH_AES_256_CBC_SHA",
-		"TLS_RSA_WITH_AES_256_GCM_SHA384",
-		"TLS_RSA_WITH_RC4_128_SHA",
-		"VerifyClientCertIfGiven",
-		"VersionSSL30",
-		"VersionTLS10",
-		"VersionTLS11",
-		"VersionTLS12",
-		"VersionTLS13",
-		"X25519",
-		"X509KeyPair",
-	},
-	"crypto/x509": {
-		"CANotAuthorizedForExtKeyUsage",
-		"CANotAuthorizedForThisName",
-		"CertPool",
-		"Certificate",
-		"CertificateInvalidError",
-		"CertificateRequest",
-		"ConstraintViolationError",
-		"CreateCertificate",
-		"CreateCertificateRequest",
-		"CreateRevocationList",
-		"DSA",
-		"DSAWithSHA1",
-		"DSAWithSHA256",
-		"DecryptPEMBlock",
-		"ECDSA",
-		"ECDSAWithSHA1",
-		"ECDSAWithSHA256",
-		"ECDSAWithSHA384",
-		"ECDSAWithSHA512",
-		"Ed25519",
-		"EncryptPEMBlock",
-		"ErrUnsupportedAlgorithm",
-		"Expired",
-		"ExtKeyUsage",
-		"ExtKeyUsageAny",
-		"ExtKeyUsageClientAuth",
-		"ExtKeyUsageCodeSigning",
-		"ExtKeyUsageEmailProtection",
-		"ExtKeyUsageIPSECEndSystem",
-		"ExtKeyUsageIPSECTunnel",
-		"ExtKeyUsageIPSECUser",
-		"ExtKeyUsageMicrosoftCommercialCodeSigning",
-		"ExtKeyUsageMicrosoftKernelCodeSigning",
-		"ExtKeyUsageMicrosoftServerGatedCrypto",
-		"ExtKeyUsageNetscapeServerGatedCrypto",
-		"ExtKeyUsageOCSPSigning",
-		"ExtKeyUsageServerAuth",
-		"ExtKeyUsageTimeStamping",
-		"HostnameError",
-		"IncompatibleUsage",
-		"IncorrectPasswordError",
-		"InsecureAlgorithmError",
-		"InvalidReason",
-		"IsEncryptedPEMBlock",
-		"KeyUsage",
-		"KeyUsageCRLSign",
-		"KeyUsageCertSign",
-		"KeyUsageContentCommitment",
-		"KeyUsageDataEncipherment",
-		"KeyUsageDecipherOnly",
-		"KeyUsageDigitalSignature",
-		"KeyUsageEncipherOnly",
-		"KeyUsageKeyAgreement",
-		"KeyUsageKeyEncipherment",
-		"MD2WithRSA",
-		"MD5WithRSA",
-		"MarshalECPrivateKey",
-		"MarshalPKCS1PrivateKey",
-		"MarshalPKCS1PublicKey",
-		"MarshalPKCS8PrivateKey",
-		"MarshalPKIXPublicKey",
-		"NameConstraintsWithoutSANs",
-		"NameMismatch",
-		"NewCertPool",
-		"NotAuthorizedToSign",
-		"PEMCipher",
-		"PEMCipher3DES",
-		"PEMCipherAES128",
-		"PEMCipherAES192",
-		"PEMCipherAES256",
-		"PEMCipherDES",
-		"ParseCRL",
-		"ParseCertificate",
-		"ParseCertificateRequest",
-		"ParseCertificates",
-		"ParseDERCRL",
-		"ParseECPrivateKey",
-		"ParsePKCS1PrivateKey",
-		"ParsePKCS1PublicKey",
-		"ParsePKCS8PrivateKey",
-		"ParsePKIXPublicKey",
-		"PublicKeyAlgorithm",
-		"PureEd25519",
-		"RSA",
-		"RevocationList",
-		"SHA1WithRSA",
-		"SHA256WithRSA",
-		"SHA256WithRSAPSS",
-		"SHA384WithRSA",
-		"SHA384WithRSAPSS",
-		"SHA512WithRSA",
-		"SHA512WithRSAPSS",
-		"SignatureAlgorithm",
-		"SystemCertPool",
-		"SystemRootsError",
-		"TooManyConstraints",
-		"TooManyIntermediates",
-		"UnconstrainedName",
-		"UnhandledCriticalExtension",
-		"UnknownAuthorityError",
-		"UnknownPublicKeyAlgorithm",
-		"UnknownSignatureAlgorithm",
-		"VerifyOptions",
-	},
-	"crypto/x509/pkix": {
-		"AlgorithmIdentifier",
-		"AttributeTypeAndValue",
-		"AttributeTypeAndValueSET",
-		"CertificateList",
-		"Extension",
-		"Name",
-		"RDNSequence",
-		"RelativeDistinguishedNameSET",
-		"RevokedCertificate",
-		"TBSCertificateList",
-	},
-	"database/sql": {
-		"ColumnType",
-		"Conn",
-		"DB",
-		"DBStats",
-		"Drivers",
-		"ErrConnDone",
-		"ErrNoRows",
-		"ErrTxDone",
-		"IsolationLevel",
-		"LevelDefault",
-		"LevelLinearizable",
-		"LevelReadCommitted",
-		"LevelReadUncommitted",
-		"LevelRepeatableRead",
-		"LevelSerializable",
-		"LevelSnapshot",
-		"LevelWriteCommitted",
-		"Named",
-		"NamedArg",
-		"NullBool",
-		"NullFloat64",
-		"NullInt32",
-		"NullInt64",
-		"NullString",
-		"NullTime",
-		"Open",
-		"OpenDB",
-		"Out",
-		"RawBytes",
-		"Register",
-		"Result",
-		"Row",
-		"Rows",
-		"Scanner",
-		"Stmt",
-		"Tx",
-		"TxOptions",
-	},
-	"database/sql/driver": {
-		"Bool",
-		"ColumnConverter",
-		"Conn",
-		"ConnBeginTx",
-		"ConnPrepareContext",
-		"Connector",
-		"DefaultParameterConverter",
-		"Driver",
-		"DriverContext",
-		"ErrBadConn",
-		"ErrRemoveArgument",
-		"ErrSkip",
-		"Execer",
-		"ExecerContext",
-		"Int32",
-		"IsScanValue",
-		"IsValue",
-		"IsolationLevel",
-		"NamedValue",
-		"NamedValueChecker",
-		"NotNull",
-		"Null",
-		"Pinger",
-		"Queryer",
-		"QueryerContext",
-		"Result",
-		"ResultNoRows",
-		"Rows",
-		"RowsAffected",
-		"RowsColumnTypeDatabaseTypeName",
-		"RowsColumnTypeLength",
-		"RowsColumnTypeNullable",
-		"RowsColumnTypePrecisionScale",
-		"RowsColumnTypeScanType",
-		"RowsNextResultSet",
-		"SessionResetter",
-		"Stmt",
-		"StmtExecContext",
-		"StmtQueryContext",
-		"String",
-		"Tx",
-		"TxOptions",
-		"Validator",
-		"Value",
-		"ValueConverter",
-		"Valuer",
-	},
-	"debug/dwarf": {
-		"AddrType",
-		"ArrayType",
-		"Attr",
-		"AttrAbstractOrigin",
-		"AttrAccessibility",
-		"AttrAddrBase",
-		"AttrAddrClass",
-		"AttrAlignment",
-		"AttrAllocated",
-		"AttrArtificial",
-		"AttrAssociated",
-		"AttrBaseTypes",
-		"AttrBinaryScale",
-		"AttrBitOffset",
-		"AttrBitSize",
-		"AttrByteSize",
-		"AttrCallAllCalls",
-		"AttrCallAllSourceCalls",
-		"AttrCallAllTailCalls",
-		"AttrCallColumn",
-		"AttrCallDataLocation",
-		"AttrCallDataValue",
-		"AttrCallFile",
-		"AttrCallLine",
-		"AttrCallOrigin",
-		"AttrCallPC",
-		"AttrCallParameter",
-		"AttrCallReturnPC",
-		"AttrCallTailCall",
-		"AttrCallTarget",
-		"AttrCallTargetClobbered",
-		"AttrCallValue",
-		"AttrCalling",
-		"AttrCommonRef",
-		"AttrCompDir",
-		"AttrConstExpr",
-		"AttrConstValue",
-		"AttrContainingType",
-		"AttrCount",
-		"AttrDataBitOffset",
-		"AttrDataLocation",
-		"AttrDataMemberLoc",
-		"AttrDecimalScale",
-		"AttrDecimalSign",
-		"AttrDeclColumn",
-		"AttrDeclFile",
-		"AttrDeclLine",
-		"AttrDeclaration",
-		"AttrDefaultValue",
-		"AttrDefaulted",
-		"AttrDeleted",
-		"AttrDescription",
-		"AttrDigitCount",
-		"AttrDiscr",
-		"AttrDiscrList",
-		"AttrDiscrValue",
-		"AttrDwoName",
-		"AttrElemental",
-		"AttrEncoding",
-		"AttrEndianity",
-		"AttrEntrypc",
-		"AttrEnumClass",
-		"AttrExplicit",
-		"AttrExportSymbols",
-		"AttrExtension",
-		"AttrExternal",
-		"AttrFrameBase",
-		"AttrFriend",
-		"AttrHighpc",
-		"AttrIdentifierCase",
-		"AttrImport",
-		"AttrInline",
-		"AttrIsOptional",
-		"AttrLanguage",
-		"AttrLinkageName",
-		"AttrLocation",
-		"AttrLoclistsBase",
-		"AttrLowerBound",
-		"AttrLowpc",
-		"AttrMacroInfo",
-		"AttrMacros",
-		"AttrMainSubprogram",
-		"AttrMutable",
-		"AttrName",
-		"AttrNamelistItem",
-		"AttrNoreturn",
-		"AttrObjectPointer",
-		"AttrOrdering",
-		"AttrPictureString",
-		"AttrPriority",
-		"AttrProducer",
-		"AttrPrototyped",
-		"AttrPure",
-		"AttrRanges",
-		"AttrRank",
-		"AttrRecursive",
-		"AttrReference",
-		"AttrReturnAddr",
-		"AttrRnglistsBase",
-		"AttrRvalueReference",
-		"AttrSegment",
-		"AttrSibling",
-		"AttrSignature",
-		"AttrSmall",
-		"AttrSpecification",
-		"AttrStartScope",
-		"AttrStaticLink",
-		"AttrStmtList",
-		"AttrStrOffsetsBase",
-		"AttrStride",
-		"AttrStrideSize",
-		"AttrStringLength",
-		"AttrStringLengthBitSize",
-		"AttrStringLengthByteSize",
-		"AttrThreadsScaled",
-		"AttrTrampoline",
-		"AttrType",
-		"AttrUpperBound",
-		"AttrUseLocation",
-		"AttrUseUTF8",
-		"AttrVarParam",
-		"AttrVirtuality",
-		"AttrVisibility",
-		"AttrVtableElemLoc",
-		"BasicType",
-		"BoolType",
-		"CharType",
-		"Class",
-		"ClassAddrPtr",
-		"ClassAddress",
-		"ClassBlock",
-		"ClassConstant",
-		"ClassExprLoc",
-		"ClassFlag",
-		"ClassLinePtr",
-		"ClassLocList",
-		"ClassLocListPtr",
-		"ClassMacPtr",
-		"ClassRangeListPtr",
-		"ClassReference",
-		"ClassReferenceAlt",
-		"ClassReferenceSig",
-		"ClassRngList",
-		"ClassRngListsPtr",
-		"ClassStrOffsetsPtr",
-		"ClassString",
-		"ClassStringAlt",
-		"ClassUnknown",
-		"CommonType",
-		"ComplexType",
-		"Data",
-		"DecodeError",
-		"DotDotDotType",
-		"Entry",
-		"EnumType",
-		"EnumValue",
-		"ErrUnknownPC",
-		"Field",
-		"FloatType",
-		"FuncType",
-		"IntType",
-		"LineEntry",
-		"LineFile",
-		"LineReader",
-		"LineReaderPos",
-		"New",
-		"Offset",
-		"PtrType",
-		"QualType",
-		"Reader",
-		"StructField",
-		"StructType",
-		"Tag",
-		"TagAccessDeclaration",
-		"TagArrayType",
-		"TagAtomicType",
-		"TagBaseType",
-		"TagCallSite",
-		"TagCallSiteParameter",
-		"TagCatchDwarfBlock",
-		"TagClassType",
-		"TagCoarrayType",
-		"TagCommonDwarfBlock",
-		"TagCommonInclusion",
-		"TagCompileUnit",
-		"TagCondition",
-		"TagConstType",
-		"TagConstant",
-		"TagDwarfProcedure",
-		"TagDynamicType",
-		"TagEntryPoint",
-		"TagEnumerationType",
-		"TagEnumerator",
-		"TagFileType",
-		"TagFormalParameter",
-		"TagFriend",
-		"TagGenericSubrange",
-		"TagImmutableType",
-		"TagImportedDeclaration",
-		"TagImportedModule",
-		"TagImportedUnit",
-		"TagInheritance",
-		"TagInlinedSubroutine",
-		"TagInterfaceType",
-		"TagLabel",
-		"TagLexDwarfBlock",
-		"TagMember",
-		"TagModule",
-		"TagMutableType",
-		"TagNamelist",
-		"TagNamelistItem",
-		"TagNamespace",
-		"TagPackedType",
-		"TagPartialUnit",
-		"TagPointerType",
-		"TagPtrToMemberType",
-		"TagReferenceType",
-		"TagRestrictType",
-		"TagRvalueReferenceType",
-		"TagSetType",
-		"TagSharedType",
-		"TagSkeletonUnit",
-		"TagStringType",
-		"TagStructType",
-		"TagSubprogram",
-		"TagSubrangeType",
-		"TagSubroutineType",
-		"TagTemplateAlias",
-		"TagTemplateTypeParameter",
-		"TagTemplateValueParameter",
-		"TagThrownType",
-		"TagTryDwarfBlock",
-		"TagTypeUnit",
-		"TagTypedef",
-		"TagUnionType",
-		"TagUnspecifiedParameters",
-		"TagUnspecifiedType",
-		"TagVariable",
-		"TagVariant",
-		"TagVariantPart",
-		"TagVolatileType",
-		"TagWithStmt",
-		"Type",
-		"TypedefType",
-		"UcharType",
-		"UintType",
-		"UnspecifiedType",
-		"UnsupportedType",
-		"VoidType",
-	},
-	"debug/elf": {
-		"ARM_MAGIC_TRAMP_NUMBER",
-		"COMPRESS_HIOS",
-		"COMPRESS_HIPROC",
-		"COMPRESS_LOOS",
-		"COMPRESS_LOPROC",
-		"COMPRESS_ZLIB",
-		"Chdr32",
-		"Chdr64",
-		"Class",
-		"CompressionType",
-		"DF_BIND_NOW",
-		"DF_ORIGIN",
-		"DF_STATIC_TLS",
-		"DF_SYMBOLIC",
-		"DF_TEXTREL",
-		"DT_BIND_NOW",
-		"DT_DEBUG",
-		"DT_ENCODING",
-		"DT_FINI",
-		"DT_FINI_ARRAY",
-		"DT_FINI_ARRAYSZ",
-		"DT_FLAGS",
-		"DT_HASH",
-		"DT_HIOS",
-		"DT_HIPROC",
-		"DT_INIT",
-		"DT_INIT_ARRAY",
-		"DT_INIT_ARRAYSZ",
-		"DT_JMPREL",
-		"DT_LOOS",
-		"DT_LOPROC",
-		"DT_NEEDED",
-		"DT_NULL",
-		"DT_PLTGOT",
-		"DT_PLTREL",
-		"DT_PLTRELSZ",
-		"DT_PREINIT_ARRAY",
-		"DT_PREINIT_ARRAYSZ",
-		"DT_REL",
-		"DT_RELA",
-		"DT_RELAENT",
-		"DT_RELASZ",
-		"DT_RELENT",
-		"DT_RELSZ",
-		"DT_RPATH",
-		"DT_RUNPATH",
-		"DT_SONAME",
-		"DT_STRSZ",
-		"DT_STRTAB",
-		"DT_SYMBOLIC",
-		"DT_SYMENT",
-		"DT_SYMTAB",
-		"DT_TEXTREL",
-		"DT_VERNEED",
-		"DT_VERNEEDNUM",
-		"DT_VERSYM",
-		"Data",
-		"Dyn32",
-		"Dyn64",
-		"DynFlag",
-		"DynTag",
-		"EI_ABIVERSION",
-		"EI_CLASS",
-		"EI_DATA",
-		"EI_NIDENT",
-		"EI_OSABI",
-		"EI_PAD",
-		"EI_VERSION",
-		"ELFCLASS32",
-		"ELFCLASS64",
-		"ELFCLASSNONE",
-		"ELFDATA2LSB",
-		"ELFDATA2MSB",
-		"ELFDATANONE",
-		"ELFMAG",
-		"ELFOSABI_86OPEN",
-		"ELFOSABI_AIX",
-		"ELFOSABI_ARM",
-		"ELFOSABI_AROS",
-		"ELFOSABI_CLOUDABI",
-		"ELFOSABI_FENIXOS",
-		"ELFOSABI_FREEBSD",
-		"ELFOSABI_HPUX",
-		"ELFOSABI_HURD",
-		"ELFOSABI_IRIX",
-		"ELFOSABI_LINUX",
-		"ELFOSABI_MODESTO",
-		"ELFOSABI_NETBSD",
-		"ELFOSABI_NONE",
-		"ELFOSABI_NSK",
-		"ELFOSABI_OPENBSD",
-		"ELFOSABI_OPENVMS",
-		"ELFOSABI_SOLARIS",
-		"ELFOSABI_STANDALONE",
-		"ELFOSABI_TRU64",
-		"EM_386",
-		"EM_486",
-		"EM_56800EX",
-		"EM_68HC05",
-		"EM_68HC08",
-		"EM_68HC11",
-		"EM_68HC12",
-		"EM_68HC16",
-		"EM_68K",
-		"EM_78KOR",
-		"EM_8051",
-		"EM_860",
-		"EM_88K",
-		"EM_960",
-		"EM_AARCH64",
-		"EM_ALPHA",
-		"EM_ALPHA_STD",
-		"EM_ALTERA_NIOS2",
-		"EM_AMDGPU",
-		"EM_ARC",
-		"EM_ARCA",
-		"EM_ARC_COMPACT",
-		"EM_ARC_COMPACT2",
-		"EM_ARM",
-		"EM_AVR",
-		"EM_AVR32",
-		"EM_BA1",
-		"EM_BA2",
-		"EM_BLACKFIN",
-		"EM_BPF",
-		"EM_C166",
-		"EM_CDP",
-		"EM_CE",
-		"EM_CLOUDSHIELD",
-		"EM_COGE",
-		"EM_COLDFIRE",
-		"EM_COOL",
-		"EM_COREA_1ST",
-		"EM_COREA_2ND",
-		"EM_CR",
-		"EM_CR16",
-		"EM_CRAYNV2",
-		"EM_CRIS",
-		"EM_CRX",
-		"EM_CSR_KALIMBA",
-		"EM_CUDA",
-		"EM_CYPRESS_M8C",
-		"EM_D10V",
-		"EM_D30V",
-		"EM_DSP24",
-		"EM_DSPIC30F",
-		"EM_DXP",
-		"EM_ECOG1",
-		"EM_ECOG16",
-		"EM_ECOG1X",
-		"EM_ECOG2",
-		"EM_ETPU",
-		"EM_EXCESS",
-		"EM_F2MC16",
-		"EM_FIREPATH",
-		"EM_FR20",
-		"EM_FR30",
-		"EM_FT32",
-		"EM_FX66",
-		"EM_H8S",
-		"EM_H8_300",
-		"EM_H8_300H",
-		"EM_H8_500",
-		"EM_HUANY",
-		"EM_IA_64",
-		"EM_INTEL205",
-		"EM_INTEL206",
-		"EM_INTEL207",
-		"EM_INTEL208",
-		"EM_INTEL209",
-		"EM_IP2K",
-		"EM_JAVELIN",
-		"EM_K10M",
-		"EM_KM32",
-		"EM_KMX16",
-		"EM_KMX32",
-		"EM_KMX8",
-		"EM_KVARC",
-		"EM_L10M",
-		"EM_LANAI",
-		"EM_LATTICEMICO32",
-		"EM_M16C",
-		"EM_M32",
-		"EM_M32C",
-		"EM_M32R",
-		"EM_MANIK",
-		"EM_MAX",
-		"EM_MAXQ30",
-		"EM_MCHP_PIC",
-		"EM_MCST_ELBRUS",
-		"EM_ME16",
-		"EM_METAG",
-		"EM_MICROBLAZE",
-		"EM_MIPS",
-		"EM_MIPS_RS3_LE",
-		"EM_MIPS_RS4_BE",
-		"EM_MIPS_X",
-		"EM_MMA",
-		"EM_MMDSP_PLUS",
-		"EM_MMIX",
-		"EM_MN10200",
-		"EM_MN10300",
-		"EM_MOXIE",
-		"EM_MSP430",
-		"EM_NCPU",
-		"EM_NDR1",
-		"EM_NDS32",
-		"EM_NONE",
-		"EM_NORC",
-		"EM_NS32K",
-		"EM_OPEN8",
-		"EM_OPENRISC",
-		"EM_PARISC",
-		"EM_PCP",
-		"EM_PDP10",
-		"EM_PDP11",
-		"EM_PDSP",
-		"EM_PJ",
-		"EM_PPC",
-		"EM_PPC64",
-		"EM_PRISM",
-		"EM_QDSP6",
-		"EM_R32C",
-		"EM_RCE",
-		"EM_RH32",
-		"EM_RISCV",
-		"EM_RL78",
-		"EM_RS08",
-		"EM_RX",
-		"EM_S370",
-		"EM_S390",
-		"EM_SCORE7",
-		"EM_SEP",
-		"EM_SE_C17",
-		"EM_SE_C33",
-		"EM_SH",
-		"EM_SHARC",
-		"EM_SLE9X",
-		"EM_SNP1K",
-		"EM_SPARC",
-		"EM_SPARC32PLUS",
-		"EM_SPARCV9",
-		"EM_ST100",
-		"EM_ST19",
-		"EM_ST200",
-		"EM_ST7",
-		"EM_ST9PLUS",
-		"EM_STARCORE",
-		"EM_STM8",
-		"EM_STXP7X",
-		"EM_SVX",
-		"EM_TILE64",
-		"EM_TILEGX",
-		"EM_TILEPRO",
-		"EM_TINYJ",
-		"EM_TI_ARP32",
-		"EM_TI_C2000",
-		"EM_TI_C5500",
-		"EM_TI_C6000",
-		"EM_TI_PRU",
-		"EM_TMM_GPP",
-		"EM_TPC",
-		"EM_TRICORE",
-		"EM_TRIMEDIA",
-		"EM_TSK3000",
-		"EM_UNICORE",
-		"EM_V800",
-		"EM_V850",
-		"EM_VAX",
-		"EM_VIDEOCORE",
-		"EM_VIDEOCORE3",
-		"EM_VIDEOCORE5",
-		"EM_VISIUM",
-		"EM_VPP500",
-		"EM_X86_64",
-		"EM_XCORE",
-		"EM_XGATE",
-		"EM_XIMO16",
-		"EM_XTENSA",
-		"EM_Z80",
-		"EM_ZSP",
-		"ET_CORE",
-		"ET_DYN",
-		"ET_EXEC",
-		"ET_HIOS",
-		"ET_HIPROC",
-		"ET_LOOS",
-		"ET_LOPROC",
-		"ET_NONE",
-		"ET_REL",
-		"EV_CURRENT",
-		"EV_NONE",
-		"ErrNoSymbols",
-		"File",
-		"FileHeader",
-		"FormatError",
-		"Header32",
-		"Header64",
-		"ImportedSymbol",
-		"Machine",
-		"NT_FPREGSET",
-		"NT_PRPSINFO",
-		"NT_PRSTATUS",
-		"NType",
-		"NewFile",
-		"OSABI",
-		"Open",
-		"PF_MASKOS",
-		"PF_MASKPROC",
-		"PF_R",
-		"PF_W",
-		"PF_X",
-		"PT_DYNAMIC",
-		"PT_HIOS",
-		"PT_HIPROC",
-		"PT_INTERP",
-		"PT_LOAD",
-		"PT_LOOS",
-		"PT_LOPROC",
-		"PT_NOTE",
-		"PT_NULL",
-		"PT_PHDR",
-		"PT_SHLIB",
-		"PT_TLS",
-		"Prog",
-		"Prog32",
-		"Prog64",
-		"ProgFlag",
-		"ProgHeader",
-		"ProgType",
-		"R_386",
-		"R_386_16",
-		"R_386_32",
-		"R_386_32PLT",
-		"R_386_8",
-		"R_386_COPY",
-		"R_386_GLOB_DAT",
-		"R_386_GOT32",
-		"R_386_GOT32X",
-		"R_386_GOTOFF",
-		"R_386_GOTPC",
-		"R_386_IRELATIVE",
-		"R_386_JMP_SLOT",
-		"R_386_NONE",
-		"R_386_PC16",
-		"R_386_PC32",
-		"R_386_PC8",
-		"R_386_PLT32",
-		"R_386_RELATIVE",
-		"R_386_SIZE32",
-		"R_386_TLS_DESC",
-		"R_386_TLS_DESC_CALL",
-		"R_386_TLS_DTPMOD32",
-		"R_386_TLS_DTPOFF32",
-		"R_386_TLS_GD",
-		"R_386_TLS_GD_32",
-		"R_386_TLS_GD_CALL",
-		"R_386_TLS_GD_POP",
-		"R_386_TLS_GD_PUSH",
-		"R_386_TLS_GOTDESC",
-		"R_386_TLS_GOTIE",
-		"R_386_TLS_IE",
-		"R_386_TLS_IE_32",
-		"R_386_TLS_LDM",
-		"R_386_TLS_LDM_32",
-		"R_386_TLS_LDM_CALL",
-		"R_386_TLS_LDM_POP",
-		"R_386_TLS_LDM_PUSH",
-		"R_386_TLS_LDO_32",
-		"R_386_TLS_LE",
-		"R_386_TLS_LE_32",
-		"R_386_TLS_TPOFF",
-		"R_386_TLS_TPOFF32",
-		"R_390",
-		"R_390_12",
-		"R_390_16",
-		"R_390_20",
-		"R_390_32",
-		"R_390_64",
-		"R_390_8",
-		"R_390_COPY",
-		"R_390_GLOB_DAT",
-		"R_390_GOT12",
-		"R_390_GOT16",
-		"R_390_GOT20",
-		"R_390_GOT32",
-		"R_390_GOT64",
-		"R_390_GOTENT",
-		"R_390_GOTOFF",
-		"R_390_GOTOFF16",
-		"R_390_GOTOFF64",
-		"R_390_GOTPC",
-		"R_390_GOTPCDBL",
-		"R_390_GOTPLT12",
-		"R_390_GOTPLT16",
-		"R_390_GOTPLT20",
-		"R_390_GOTPLT32",
-		"R_390_GOTPLT64",
-		"R_390_GOTPLTENT",
-		"R_390_GOTPLTOFF16",
-		"R_390_GOTPLTOFF32",
-		"R_390_GOTPLTOFF64",
-		"R_390_JMP_SLOT",
-		"R_390_NONE",
-		"R_390_PC16",
-		"R_390_PC16DBL",
-		"R_390_PC32",
-		"R_390_PC32DBL",
-		"R_390_PC64",
-		"R_390_PLT16DBL",
-		"R_390_PLT32",
-		"R_390_PLT32DBL",
-		"R_390_PLT64",
-		"R_390_RELATIVE",
-		"R_390_TLS_DTPMOD",
-		"R_390_TLS_DTPOFF",
-		"R_390_TLS_GD32",
-		"R_390_TLS_GD64",
-		"R_390_TLS_GDCALL",
-		"R_390_TLS_GOTIE12",
-		"R_390_TLS_GOTIE20",
-		"R_390_TLS_GOTIE32",
-		"R_390_TLS_GOTIE64",
-		"R_390_TLS_IE32",
-		"R_390_TLS_IE64",
-		"R_390_TLS_IEENT",
-		"R_390_TLS_LDCALL",
-		"R_390_TLS_LDM32",
-		"R_390_TLS_LDM64",
-		"R_390_TLS_LDO32",
-		"R_390_TLS_LDO64",
-		"R_390_TLS_LE32",
-		"R_390_TLS_LE64",
-		"R_390_TLS_LOAD",
-		"R_390_TLS_TPOFF",
-		"R_AARCH64",
-		"R_AARCH64_ABS16",
-		"R_AARCH64_ABS32",
-		"R_AARCH64_ABS64",
-		"R_AARCH64_ADD_ABS_LO12_NC",
-		"R_AARCH64_ADR_GOT_PAGE",
-		"R_AARCH64_ADR_PREL_LO21",
-		"R_AARCH64_ADR_PREL_PG_HI21",
-		"R_AARCH64_ADR_PREL_PG_HI21_NC",
-		"R_AARCH64_CALL26",
-		"R_AARCH64_CONDBR19",
-		"R_AARCH64_COPY",
-		"R_AARCH64_GLOB_DAT",
-		"R_AARCH64_GOT_LD_PREL19",
-		"R_AARCH64_IRELATIVE",
-		"R_AARCH64_JUMP26",
-		"R_AARCH64_JUMP_SLOT",
-		"R_AARCH64_LD64_GOTOFF_LO15",
-		"R_AARCH64_LD64_GOTPAGE_LO15",
-		"R_AARCH64_LD64_GOT_LO12_NC",
-		"R_AARCH64_LDST128_ABS_LO12_NC",
-		"R_AARCH64_LDST16_ABS_LO12_NC",
-		"R_AARCH64_LDST32_ABS_LO12_NC",
-		"R_AARCH64_LDST64_ABS_LO12_NC",
-		"R_AARCH64_LDST8_ABS_LO12_NC",
-		"R_AARCH64_LD_PREL_LO19",
-		"R_AARCH64_MOVW_SABS_G0",
-		"R_AARCH64_MOVW_SABS_G1",
-		"R_AARCH64_MOVW_SABS_G2",
-		"R_AARCH64_MOVW_UABS_G0",
-		"R_AARCH64_MOVW_UABS_G0_NC",
-		"R_AARCH64_MOVW_UABS_G1",
-		"R_AARCH64_MOVW_UABS_G1_NC",
-		"R_AARCH64_MOVW_UABS_G2",
-		"R_AARCH64_MOVW_UABS_G2_NC",
-		"R_AARCH64_MOVW_UABS_G3",
-		"R_AARCH64_NONE",
-		"R_AARCH64_NULL",
-		"R_AARCH64_P32_ABS16",
-		"R_AARCH64_P32_ABS32",
-		"R_AARCH64_P32_ADD_ABS_LO12_NC",
-		"R_AARCH64_P32_ADR_GOT_PAGE",
-		"R_AARCH64_P32_ADR_PREL_LO21",
-		"R_AARCH64_P32_ADR_PREL_PG_HI21",
-		"R_AARCH64_P32_CALL26",
-		"R_AARCH64_P32_CONDBR19",
-		"R_AARCH64_P32_COPY",
-		"R_AARCH64_P32_GLOB_DAT",
-		"R_AARCH64_P32_GOT_LD_PREL19",
-		"R_AARCH64_P32_IRELATIVE",
-		"R_AARCH64_P32_JUMP26",
-		"R_AARCH64_P32_JUMP_SLOT",
-		"R_AARCH64_P32_LD32_GOT_LO12_NC",
-		"R_AARCH64_P32_LDST128_ABS_LO12_NC",
-		"R_AARCH64_P32_LDST16_ABS_LO12_NC",
-		"R_AARCH64_P32_LDST32_ABS_LO12_NC",
-		"R_AARCH64_P32_LDST64_ABS_LO12_NC",
-		"R_AARCH64_P32_LDST8_ABS_LO12_NC",
-		"R_AARCH64_P32_LD_PREL_LO19",
-		"R_AARCH64_P32_MOVW_SABS_G0",
-		"R_AARCH64_P32_MOVW_UABS_G0",
-		"R_AARCH64_P32_MOVW_UABS_G0_NC",
-		"R_AARCH64_P32_MOVW_UABS_G1",
-		"R_AARCH64_P32_PREL16",
-		"R_AARCH64_P32_PREL32",
-		"R_AARCH64_P32_RELATIVE",
-		"R_AARCH64_P32_TLSDESC",
-		"R_AARCH64_P32_TLSDESC_ADD_LO12_NC",
-		"R_AARCH64_P32_TLSDESC_ADR_PAGE21",
-		"R_AARCH64_P32_TLSDESC_ADR_PREL21",
-		"R_AARCH64_P32_TLSDESC_CALL",
-		"R_AARCH64_P32_TLSDESC_LD32_LO12_NC",
-		"R_AARCH64_P32_TLSDESC_LD_PREL19",
-		"R_AARCH64_P32_TLSGD_ADD_LO12_NC",
-		"R_AARCH64_P32_TLSGD_ADR_PAGE21",
-		"R_AARCH64_P32_TLSIE_ADR_GOTTPREL_PAGE21",
-		"R_AARCH64_P32_TLSIE_LD32_GOTTPREL_LO12_NC",
-		"R_AARCH64_P32_TLSIE_LD_GOTTPREL_PREL19",
-		"R_AARCH64_P32_TLSLE_ADD_TPREL_HI12",
-		"R_AARCH64_P32_TLSLE_ADD_TPREL_LO12",
-		"R_AARCH64_P32_TLSLE_ADD_TPREL_LO12_NC",
-		"R_AARCH64_P32_TLSLE_MOVW_TPREL_G0",
-		"R_AARCH64_P32_TLSLE_MOVW_TPREL_G0_NC",
-		"R_AARCH64_P32_TLSLE_MOVW_TPREL_G1",
-		"R_AARCH64_P32_TLS_DTPMOD",
-		"R_AARCH64_P32_TLS_DTPREL",
-		"R_AARCH64_P32_TLS_TPREL",
-		"R_AARCH64_P32_TSTBR14",
-		"R_AARCH64_PREL16",
-		"R_AARCH64_PREL32",
-		"R_AARCH64_PREL64",
-		"R_AARCH64_RELATIVE",
-		"R_AARCH64_TLSDESC",
-		"R_AARCH64_TLSDESC_ADD",
-		"R_AARCH64_TLSDESC_ADD_LO12_NC",
-		"R_AARCH64_TLSDESC_ADR_PAGE21",
-		"R_AARCH64_TLSDESC_ADR_PREL21",
-		"R_AARCH64_TLSDESC_CALL",
-		"R_AARCH64_TLSDESC_LD64_LO12_NC",
-		"R_AARCH64_TLSDESC_LDR",
-		"R_AARCH64_TLSDESC_LD_PREL19",
-		"R_AARCH64_TLSDESC_OFF_G0_NC",
-		"R_AARCH64_TLSDESC_OFF_G1",
-		"R_AARCH64_TLSGD_ADD_LO12_NC",
-		"R_AARCH64_TLSGD_ADR_PAGE21",
-		"R_AARCH64_TLSGD_ADR_PREL21",
-		"R_AARCH64_TLSGD_MOVW_G0_NC",
-		"R_AARCH64_TLSGD_MOVW_G1",
-		"R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21",
-		"R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC",
-		"R_AARCH64_TLSIE_LD_GOTTPREL_PREL19",
-		"R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC",
-		"R_AARCH64_TLSIE_MOVW_GOTTPREL_G1",
-		"R_AARCH64_TLSLD_ADR_PAGE21",
-		"R_AARCH64_TLSLD_ADR_PREL21",
-		"R_AARCH64_TLSLD_LDST128_DTPREL_LO12",
-		"R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC",
-		"R_AARCH64_TLSLE_ADD_TPREL_HI12",
-		"R_AARCH64_TLSLE_ADD_TPREL_LO12",
-		"R_AARCH64_TLSLE_ADD_TPREL_LO12_NC",
-		"R_AARCH64_TLSLE_LDST128_TPREL_LO12",
-		"R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC",
-		"R_AARCH64_TLSLE_MOVW_TPREL_G0",
-		"R_AARCH64_TLSLE_MOVW_TPREL_G0_NC",
-		"R_AARCH64_TLSLE_MOVW_TPREL_G1",
-		"R_AARCH64_TLSLE_MOVW_TPREL_G1_NC",
-		"R_AARCH64_TLSLE_MOVW_TPREL_G2",
-		"R_AARCH64_TLS_DTPMOD64",
-		"R_AARCH64_TLS_DTPREL64",
-		"R_AARCH64_TLS_TPREL64",
-		"R_AARCH64_TSTBR14",
-		"R_ALPHA",
-		"R_ALPHA_BRADDR",
-		"R_ALPHA_COPY",
-		"R_ALPHA_GLOB_DAT",
-		"R_ALPHA_GPDISP",
-		"R_ALPHA_GPREL32",
-		"R_ALPHA_GPRELHIGH",
-		"R_ALPHA_GPRELLOW",
-		"R_ALPHA_GPVALUE",
-		"R_ALPHA_HINT",
-		"R_ALPHA_IMMED_BR_HI32",
-		"R_ALPHA_IMMED_GP_16",
-		"R_ALPHA_IMMED_GP_HI32",
-		"R_ALPHA_IMMED_LO32",
-		"R_ALPHA_IMMED_SCN_HI32",
-		"R_ALPHA_JMP_SLOT",
-		"R_ALPHA_LITERAL",
-		"R_ALPHA_LITUSE",
-		"R_ALPHA_NONE",
-		"R_ALPHA_OP_PRSHIFT",
-		"R_ALPHA_OP_PSUB",
-		"R_ALPHA_OP_PUSH",
-		"R_ALPHA_OP_STORE",
-		"R_ALPHA_REFLONG",
-		"R_ALPHA_REFQUAD",
-		"R_ALPHA_RELATIVE",
-		"R_ALPHA_SREL16",
-		"R_ALPHA_SREL32",
-		"R_ALPHA_SREL64",
-		"R_ARM",
-		"R_ARM_ABS12",
-		"R_ARM_ABS16",
-		"R_ARM_ABS32",
-		"R_ARM_ABS32_NOI",
-		"R_ARM_ABS8",
-		"R_ARM_ALU_PCREL_15_8",
-		"R_ARM_ALU_PCREL_23_15",
-		"R_ARM_ALU_PCREL_7_0",
-		"R_ARM_ALU_PC_G0",
-		"R_ARM_ALU_PC_G0_NC",
-		"R_ARM_ALU_PC_G1",
-		"R_ARM_ALU_PC_G1_NC",
-		"R_ARM_ALU_PC_G2",
-		"R_ARM_ALU_SBREL_19_12_NC",
-		"R_ARM_ALU_SBREL_27_20_CK",
-		"R_ARM_ALU_SB_G0",
-		"R_ARM_ALU_SB_G0_NC",
-		"R_ARM_ALU_SB_G1",
-		"R_ARM_ALU_SB_G1_NC",
-		"R_ARM_ALU_SB_G2",
-		"R_ARM_AMP_VCALL9",
-		"R_ARM_BASE_ABS",
-		"R_ARM_CALL",
-		"R_ARM_COPY",
-		"R_ARM_GLOB_DAT",
-		"R_ARM_GNU_VTENTRY",
-		"R_ARM_GNU_VTINHERIT",
-		"R_ARM_GOT32",
-		"R_ARM_GOTOFF",
-		"R_ARM_GOTOFF12",
-		"R_ARM_GOTPC",
-		"R_ARM_GOTRELAX",
-		"R_ARM_GOT_ABS",
-		"R_ARM_GOT_BREL12",
-		"R_ARM_GOT_PREL",
-		"R_ARM_IRELATIVE",
-		"R_ARM_JUMP24",
-		"R_ARM_JUMP_SLOT",
-		"R_ARM_LDC_PC_G0",
-		"R_ARM_LDC_PC_G1",
-		"R_ARM_LDC_PC_G2",
-		"R_ARM_LDC_SB_G0",
-		"R_ARM_LDC_SB_G1",
-		"R_ARM_LDC_SB_G2",
-		"R_ARM_LDRS_PC_G0",
-		"R_ARM_LDRS_PC_G1",
-		"R_ARM_LDRS_PC_G2",
-		"R_ARM_LDRS_SB_G0",
-		"R_ARM_LDRS_SB_G1",
-		"R_ARM_LDRS_SB_G2",
-		"R_ARM_LDR_PC_G1",
-		"R_ARM_LDR_PC_G2",
-		"R_ARM_LDR_SBREL_11_10_NC",
-		"R_ARM_LDR_SB_G0",
-		"R_ARM_LDR_SB_G1",
-		"R_ARM_LDR_SB_G2",
-		"R_ARM_ME_TOO",
-		"R_ARM_MOVT_ABS",
-		"R_ARM_MOVT_BREL",
-		"R_ARM_MOVT_PREL",
-		"R_ARM_MOVW_ABS_NC",
-		"R_ARM_MOVW_BREL",
-		"R_ARM_MOVW_BREL_NC",
-		"R_ARM_MOVW_PREL_NC",
-		"R_ARM_NONE",
-		"R_ARM_PC13",
-		"R_ARM_PC24",
-		"R_ARM_PLT32",
-		"R_ARM_PLT32_ABS",
-		"R_ARM_PREL31",
-		"R_ARM_PRIVATE_0",
-		"R_ARM_PRIVATE_1",
-		"R_ARM_PRIVATE_10",
-		"R_ARM_PRIVATE_11",
-		"R_ARM_PRIVATE_12",
-		"R_ARM_PRIVATE_13",
-		"R_ARM_PRIVATE_14",
-		"R_ARM_PRIVATE_15",
-		"R_ARM_PRIVATE_2",
-		"R_ARM_PRIVATE_3",
-		"R_ARM_PRIVATE_4",
-		"R_ARM_PRIVATE_5",
-		"R_ARM_PRIVATE_6",
-		"R_ARM_PRIVATE_7",
-		"R_ARM_PRIVATE_8",
-		"R_ARM_PRIVATE_9",
-		"R_ARM_RABS32",
-		"R_ARM_RBASE",
-		"R_ARM_REL32",
-		"R_ARM_REL32_NOI",
-		"R_ARM_RELATIVE",
-		"R_ARM_RPC24",
-		"R_ARM_RREL32",
-		"R_ARM_RSBREL32",
-		"R_ARM_RXPC25",
-		"R_ARM_SBREL31",
-		"R_ARM_SBREL32",
-		"R_ARM_SWI24",
-		"R_ARM_TARGET1",
-		"R_ARM_TARGET2",
-		"R_ARM_THM_ABS5",
-		"R_ARM_THM_ALU_ABS_G0_NC",
-		"R_ARM_THM_ALU_ABS_G1_NC",
-		"R_ARM_THM_ALU_ABS_G2_NC",
-		"R_ARM_THM_ALU_ABS_G3",
-		"R_ARM_THM_ALU_PREL_11_0",
-		"R_ARM_THM_GOT_BREL12",
-		"R_ARM_THM_JUMP11",
-		"R_ARM_THM_JUMP19",
-		"R_ARM_THM_JUMP24",
-		"R_ARM_THM_JUMP6",
-		"R_ARM_THM_JUMP8",
-		"R_ARM_THM_MOVT_ABS",
-		"R_ARM_THM_MOVT_BREL",
-		"R_ARM_THM_MOVT_PREL",
-		"R_ARM_THM_MOVW_ABS_NC",
-		"R_ARM_THM_MOVW_BREL",
-		"R_ARM_THM_MOVW_BREL_NC",
-		"R_ARM_THM_MOVW_PREL_NC",
-		"R_ARM_THM_PC12",
-		"R_ARM_THM_PC22",
-		"R_ARM_THM_PC8",
-		"R_ARM_THM_RPC22",
-		"R_ARM_THM_SWI8",
-		"R_ARM_THM_TLS_CALL",
-		"R_ARM_THM_TLS_DESCSEQ16",
-		"R_ARM_THM_TLS_DESCSEQ32",
-		"R_ARM_THM_XPC22",
-		"R_ARM_TLS_CALL",
-		"R_ARM_TLS_DESCSEQ",
-		"R_ARM_TLS_DTPMOD32",
-		"R_ARM_TLS_DTPOFF32",
-		"R_ARM_TLS_GD32",
-		"R_ARM_TLS_GOTDESC",
-		"R_ARM_TLS_IE12GP",
-		"R_ARM_TLS_IE32",
-		"R_ARM_TLS_LDM32",
-		"R_ARM_TLS_LDO12",
-		"R_ARM_TLS_LDO32",
-		"R_ARM_TLS_LE12",
-		"R_ARM_TLS_LE32",
-		"R_ARM_TLS_TPOFF32",
-		"R_ARM_V4BX",
-		"R_ARM_XPC25",
-		"R_INFO",
-		"R_INFO32",
-		"R_MIPS",
-		"R_MIPS_16",
-		"R_MIPS_26",
-		"R_MIPS_32",
-		"R_MIPS_64",
-		"R_MIPS_ADD_IMMEDIATE",
-		"R_MIPS_CALL16",
-		"R_MIPS_CALL_HI16",
-		"R_MIPS_CALL_LO16",
-		"R_MIPS_DELETE",
-		"R_MIPS_GOT16",
-		"R_MIPS_GOT_DISP",
-		"R_MIPS_GOT_HI16",
-		"R_MIPS_GOT_LO16",
-		"R_MIPS_GOT_OFST",
-		"R_MIPS_GOT_PAGE",
-		"R_MIPS_GPREL16",
-		"R_MIPS_GPREL32",
-		"R_MIPS_HI16",
-		"R_MIPS_HIGHER",
-		"R_MIPS_HIGHEST",
-		"R_MIPS_INSERT_A",
-		"R_MIPS_INSERT_B",
-		"R_MIPS_JALR",
-		"R_MIPS_LITERAL",
-		"R_MIPS_LO16",
-		"R_MIPS_NONE",
-		"R_MIPS_PC16",
-		"R_MIPS_PJUMP",
-		"R_MIPS_REL16",
-		"R_MIPS_REL32",
-		"R_MIPS_RELGOT",
-		"R_MIPS_SCN_DISP",
-		"R_MIPS_SHIFT5",
-		"R_MIPS_SHIFT6",
-		"R_MIPS_SUB",
-		"R_MIPS_TLS_DTPMOD32",
-		"R_MIPS_TLS_DTPMOD64",
-		"R_MIPS_TLS_DTPREL32",
-		"R_MIPS_TLS_DTPREL64",
-		"R_MIPS_TLS_DTPREL_HI16",
-		"R_MIPS_TLS_DTPREL_LO16",
-		"R_MIPS_TLS_GD",
-		"R_MIPS_TLS_GOTTPREL",
-		"R_MIPS_TLS_LDM",
-		"R_MIPS_TLS_TPREL32",
-		"R_MIPS_TLS_TPREL64",
-		"R_MIPS_TLS_TPREL_HI16",
-		"R_MIPS_TLS_TPREL_LO16",
-		"R_PPC",
-		"R_PPC64",
-		"R_PPC64_ADDR14",
-		"R_PPC64_ADDR14_BRNTAKEN",
-		"R_PPC64_ADDR14_BRTAKEN",
-		"R_PPC64_ADDR16",
-		"R_PPC64_ADDR16_DS",
-		"R_PPC64_ADDR16_HA",
-		"R_PPC64_ADDR16_HI",
-		"R_PPC64_ADDR16_HIGH",
-		"R_PPC64_ADDR16_HIGHA",
-		"R_PPC64_ADDR16_HIGHER",
-		"R_PPC64_ADDR16_HIGHERA",
-		"R_PPC64_ADDR16_HIGHEST",
-		"R_PPC64_ADDR16_HIGHESTA",
-		"R_PPC64_ADDR16_LO",
-		"R_PPC64_ADDR16_LO_DS",
-		"R_PPC64_ADDR24",
-		"R_PPC64_ADDR32",
-		"R_PPC64_ADDR64",
-		"R_PPC64_ADDR64_LOCAL",
-		"R_PPC64_DTPMOD64",
-		"R_PPC64_DTPREL16",
-		"R_PPC64_DTPREL16_DS",
-		"R_PPC64_DTPREL16_HA",
-		"R_PPC64_DTPREL16_HI",
-		"R_PPC64_DTPREL16_HIGH",
-		"R_PPC64_DTPREL16_HIGHA",
-		"R_PPC64_DTPREL16_HIGHER",
-		"R_PPC64_DTPREL16_HIGHERA",
-		"R_PPC64_DTPREL16_HIGHEST",
-		"R_PPC64_DTPREL16_HIGHESTA",
-		"R_PPC64_DTPREL16_LO",
-		"R_PPC64_DTPREL16_LO_DS",
-		"R_PPC64_DTPREL64",
-		"R_PPC64_ENTRY",
-		"R_PPC64_GOT16",
-		"R_PPC64_GOT16_DS",
-		"R_PPC64_GOT16_HA",
-		"R_PPC64_GOT16_HI",
-		"R_PPC64_GOT16_LO",
-		"R_PPC64_GOT16_LO_DS",
-		"R_PPC64_GOT_DTPREL16_DS",
-		"R_PPC64_GOT_DTPREL16_HA",
-		"R_PPC64_GOT_DTPREL16_HI",
-		"R_PPC64_GOT_DTPREL16_LO_DS",
-		"R_PPC64_GOT_TLSGD16",
-		"R_PPC64_GOT_TLSGD16_HA",
-		"R_PPC64_GOT_TLSGD16_HI",
-		"R_PPC64_GOT_TLSGD16_LO",
-		"R_PPC64_GOT_TLSLD16",
-		"R_PPC64_GOT_TLSLD16_HA",
-		"R_PPC64_GOT_TLSLD16_HI",
-		"R_PPC64_GOT_TLSLD16_LO",
-		"R_PPC64_GOT_TPREL16_DS",
-		"R_PPC64_GOT_TPREL16_HA",
-		"R_PPC64_GOT_TPREL16_HI",
-		"R_PPC64_GOT_TPREL16_LO_DS",
-		"R_PPC64_IRELATIVE",
-		"R_PPC64_JMP_IREL",
-		"R_PPC64_JMP_SLOT",
-		"R_PPC64_NONE",
-		"R_PPC64_PLT16_LO_DS",
-		"R_PPC64_PLTGOT16",
-		"R_PPC64_PLTGOT16_DS",
-		"R_PPC64_PLTGOT16_HA",
-		"R_PPC64_PLTGOT16_HI",
-		"R_PPC64_PLTGOT16_LO",
-		"R_PPC64_PLTGOT_LO_DS",
-		"R_PPC64_REL14",
-		"R_PPC64_REL14_BRNTAKEN",
-		"R_PPC64_REL14_BRTAKEN",
-		"R_PPC64_REL16",
-		"R_PPC64_REL16DX_HA",
-		"R_PPC64_REL16_HA",
-		"R_PPC64_REL16_HI",
-		"R_PPC64_REL16_LO",
-		"R_PPC64_REL24",
-		"R_PPC64_REL24_NOTOC",
-		"R_PPC64_REL32",
-		"R_PPC64_REL64",
-		"R_PPC64_SECTOFF_DS",
-		"R_PPC64_SECTOFF_LO_DS",
-		"R_PPC64_TLS",
-		"R_PPC64_TLSGD",
-		"R_PPC64_TLSLD",
-		"R_PPC64_TOC",
-		"R_PPC64_TOC16",
-		"R_PPC64_TOC16_DS",
-		"R_PPC64_TOC16_HA",
-		"R_PPC64_TOC16_HI",
-		"R_PPC64_TOC16_LO",
-		"R_PPC64_TOC16_LO_DS",
-		"R_PPC64_TOCSAVE",
-		"R_PPC64_TPREL16",
-		"R_PPC64_TPREL16_DS",
-		"R_PPC64_TPREL16_HA",
-		"R_PPC64_TPREL16_HI",
-		"R_PPC64_TPREL16_HIGH",
-		"R_PPC64_TPREL16_HIGHA",
-		"R_PPC64_TPREL16_HIGHER",
-		"R_PPC64_TPREL16_HIGHERA",
-		"R_PPC64_TPREL16_HIGHEST",
-		"R_PPC64_TPREL16_HIGHESTA",
-		"R_PPC64_TPREL16_LO",
-		"R_PPC64_TPREL16_LO_DS",
-		"R_PPC64_TPREL64",
-		"R_PPC_ADDR14",
-		"R_PPC_ADDR14_BRNTAKEN",
-		"R_PPC_ADDR14_BRTAKEN",
-		"R_PPC_ADDR16",
-		"R_PPC_ADDR16_HA",
-		"R_PPC_ADDR16_HI",
-		"R_PPC_ADDR16_LO",
-		"R_PPC_ADDR24",
-		"R_PPC_ADDR32",
-		"R_PPC_COPY",
-		"R_PPC_DTPMOD32",
-		"R_PPC_DTPREL16",
-		"R_PPC_DTPREL16_HA",
-		"R_PPC_DTPREL16_HI",
-		"R_PPC_DTPREL16_LO",
-		"R_PPC_DTPREL32",
-		"R_PPC_EMB_BIT_FLD",
-		"R_PPC_EMB_MRKREF",
-		"R_PPC_EMB_NADDR16",
-		"R_PPC_EMB_NADDR16_HA",
-		"R_PPC_EMB_NADDR16_HI",
-		"R_PPC_EMB_NADDR16_LO",
-		"R_PPC_EMB_NADDR32",
-		"R_PPC_EMB_RELSDA",
-		"R_PPC_EMB_RELSEC16",
-		"R_PPC_EMB_RELST_HA",
-		"R_PPC_EMB_RELST_HI",
-		"R_PPC_EMB_RELST_LO",
-		"R_PPC_EMB_SDA21",
-		"R_PPC_EMB_SDA2I16",
-		"R_PPC_EMB_SDA2REL",
-		"R_PPC_EMB_SDAI16",
-		"R_PPC_GLOB_DAT",
-		"R_PPC_GOT16",
-		"R_PPC_GOT16_HA",
-		"R_PPC_GOT16_HI",
-		"R_PPC_GOT16_LO",
-		"R_PPC_GOT_TLSGD16",
-		"R_PPC_GOT_TLSGD16_HA",
-		"R_PPC_GOT_TLSGD16_HI",
-		"R_PPC_GOT_TLSGD16_LO",
-		"R_PPC_GOT_TLSLD16",
-		"R_PPC_GOT_TLSLD16_HA",
-		"R_PPC_GOT_TLSLD16_HI",
-		"R_PPC_GOT_TLSLD16_LO",
-		"R_PPC_GOT_TPREL16",
-		"R_PPC_GOT_TPREL16_HA",
-		"R_PPC_GOT_TPREL16_HI",
-		"R_PPC_GOT_TPREL16_LO",
-		"R_PPC_JMP_SLOT",
-		"R_PPC_LOCAL24PC",
-		"R_PPC_NONE",
-		"R_PPC_PLT16_HA",
-		"R_PPC_PLT16_HI",
-		"R_PPC_PLT16_LO",
-		"R_PPC_PLT32",
-		"R_PPC_PLTREL24",
-		"R_PPC_PLTREL32",
-		"R_PPC_REL14",
-		"R_PPC_REL14_BRNTAKEN",
-		"R_PPC_REL14_BRTAKEN",
-		"R_PPC_REL24",
-		"R_PPC_REL32",
-		"R_PPC_RELATIVE",
-		"R_PPC_SDAREL16",
-		"R_PPC_SECTOFF",
-		"R_PPC_SECTOFF_HA",
-		"R_PPC_SECTOFF_HI",
-		"R_PPC_SECTOFF_LO",
-		"R_PPC_TLS",
-		"R_PPC_TPREL16",
-		"R_PPC_TPREL16_HA",
-		"R_PPC_TPREL16_HI",
-		"R_PPC_TPREL16_LO",
-		"R_PPC_TPREL32",
-		"R_PPC_UADDR16",
-		"R_PPC_UADDR32",
-		"R_RISCV",
-		"R_RISCV_32",
-		"R_RISCV_32_PCREL",
-		"R_RISCV_64",
-		"R_RISCV_ADD16",
-		"R_RISCV_ADD32",
-		"R_RISCV_ADD64",
-		"R_RISCV_ADD8",
-		"R_RISCV_ALIGN",
-		"R_RISCV_BRANCH",
-		"R_RISCV_CALL",
-		"R_RISCV_CALL_PLT",
-		"R_RISCV_COPY",
-		"R_RISCV_GNU_VTENTRY",
-		"R_RISCV_GNU_VTINHERIT",
-		"R_RISCV_GOT_HI20",
-		"R_RISCV_GPREL_I",
-		"R_RISCV_GPREL_S",
-		"R_RISCV_HI20",
-		"R_RISCV_JAL",
-		"R_RISCV_JUMP_SLOT",
-		"R_RISCV_LO12_I",
-		"R_RISCV_LO12_S",
-		"R_RISCV_NONE",
-		"R_RISCV_PCREL_HI20",
-		"R_RISCV_PCREL_LO12_I",
-		"R_RISCV_PCREL_LO12_S",
-		"R_RISCV_RELATIVE",
-		"R_RISCV_RELAX",
-		"R_RISCV_RVC_BRANCH",
-		"R_RISCV_RVC_JUMP",
-		"R_RISCV_RVC_LUI",
-		"R_RISCV_SET16",
-		"R_RISCV_SET32",
-		"R_RISCV_SET6",
-		"R_RISCV_SET8",
-		"R_RISCV_SUB16",
-		"R_RISCV_SUB32",
-		"R_RISCV_SUB6",
-		"R_RISCV_SUB64",
-		"R_RISCV_SUB8",
-		"R_RISCV_TLS_DTPMOD32",
-		"R_RISCV_TLS_DTPMOD64",
-		"R_RISCV_TLS_DTPREL32",
-		"R_RISCV_TLS_DTPREL64",
-		"R_RISCV_TLS_GD_HI20",
-		"R_RISCV_TLS_GOT_HI20",
-		"R_RISCV_TLS_TPREL32",
-		"R_RISCV_TLS_TPREL64",
-		"R_RISCV_TPREL_ADD",
-		"R_RISCV_TPREL_HI20",
-		"R_RISCV_TPREL_I",
-		"R_RISCV_TPREL_LO12_I",
-		"R_RISCV_TPREL_LO12_S",
-		"R_RISCV_TPREL_S",
-		"R_SPARC",
-		"R_SPARC_10",
-		"R_SPARC_11",
-		"R_SPARC_13",
-		"R_SPARC_16",
-		"R_SPARC_22",
-		"R_SPARC_32",
-		"R_SPARC_5",
-		"R_SPARC_6",
-		"R_SPARC_64",
-		"R_SPARC_7",
-		"R_SPARC_8",
-		"R_SPARC_COPY",
-		"R_SPARC_DISP16",
-		"R_SPARC_DISP32",
-		"R_SPARC_DISP64",
-		"R_SPARC_DISP8",
-		"R_SPARC_GLOB_DAT",
-		"R_SPARC_GLOB_JMP",
-		"R_SPARC_GOT10",
-		"R_SPARC_GOT13",
-		"R_SPARC_GOT22",
-		"R_SPARC_H44",
-		"R_SPARC_HH22",
-		"R_SPARC_HI22",
-		"R_SPARC_HIPLT22",
-		"R_SPARC_HIX22",
-		"R_SPARC_HM10",
-		"R_SPARC_JMP_SLOT",
-		"R_SPARC_L44",
-		"R_SPARC_LM22",
-		"R_SPARC_LO10",
-		"R_SPARC_LOPLT10",
-		"R_SPARC_LOX10",
-		"R_SPARC_M44",
-		"R_SPARC_NONE",
-		"R_SPARC_OLO10",
-		"R_SPARC_PC10",
-		"R_SPARC_PC22",
-		"R_SPARC_PCPLT10",
-		"R_SPARC_PCPLT22",
-		"R_SPARC_PCPLT32",
-		"R_SPARC_PC_HH22",
-		"R_SPARC_PC_HM10",
-		"R_SPARC_PC_LM22",
-		"R_SPARC_PLT32",
-		"R_SPARC_PLT64",
-		"R_SPARC_REGISTER",
-		"R_SPARC_RELATIVE",
-		"R_SPARC_UA16",
-		"R_SPARC_UA32",
-		"R_SPARC_UA64",
-		"R_SPARC_WDISP16",
-		"R_SPARC_WDISP19",
-		"R_SPARC_WDISP22",
-		"R_SPARC_WDISP30",
-		"R_SPARC_WPLT30",
-		"R_SYM32",
-		"R_SYM64",
-		"R_TYPE32",
-		"R_TYPE64",
-		"R_X86_64",
-		"R_X86_64_16",
-		"R_X86_64_32",
-		"R_X86_64_32S",
-		"R_X86_64_64",
-		"R_X86_64_8",
-		"R_X86_64_COPY",
-		"R_X86_64_DTPMOD64",
-		"R_X86_64_DTPOFF32",
-		"R_X86_64_DTPOFF64",
-		"R_X86_64_GLOB_DAT",
-		"R_X86_64_GOT32",
-		"R_X86_64_GOT64",
-		"R_X86_64_GOTOFF64",
-		"R_X86_64_GOTPC32",
-		"R_X86_64_GOTPC32_TLSDESC",
-		"R_X86_64_GOTPC64",
-		"R_X86_64_GOTPCREL",
-		"R_X86_64_GOTPCREL64",
-		"R_X86_64_GOTPCRELX",
-		"R_X86_64_GOTPLT64",
-		"R_X86_64_GOTTPOFF",
-		"R_X86_64_IRELATIVE",
-		"R_X86_64_JMP_SLOT",
-		"R_X86_64_NONE",
-		"R_X86_64_PC16",
-		"R_X86_64_PC32",
-		"R_X86_64_PC32_BND",
-		"R_X86_64_PC64",
-		"R_X86_64_PC8",
-		"R_X86_64_PLT32",
-		"R_X86_64_PLT32_BND",
-		"R_X86_64_PLTOFF64",
-		"R_X86_64_RELATIVE",
-		"R_X86_64_RELATIVE64",
-		"R_X86_64_REX_GOTPCRELX",
-		"R_X86_64_SIZE32",
-		"R_X86_64_SIZE64",
-		"R_X86_64_TLSDESC",
-		"R_X86_64_TLSDESC_CALL",
-		"R_X86_64_TLSGD",
-		"R_X86_64_TLSLD",
-		"R_X86_64_TPOFF32",
-		"R_X86_64_TPOFF64",
-		"Rel32",
-		"Rel64",
-		"Rela32",
-		"Rela64",
-		"SHF_ALLOC",
-		"SHF_COMPRESSED",
-		"SHF_EXECINSTR",
-		"SHF_GROUP",
-		"SHF_INFO_LINK",
-		"SHF_LINK_ORDER",
-		"SHF_MASKOS",
-		"SHF_MASKPROC",
-		"SHF_MERGE",
-		"SHF_OS_NONCONFORMING",
-		"SHF_STRINGS",
-		"SHF_TLS",
-		"SHF_WRITE",
-		"SHN_ABS",
-		"SHN_COMMON",
-		"SHN_HIOS",
-		"SHN_HIPROC",
-		"SHN_HIRESERVE",
-		"SHN_LOOS",
-		"SHN_LOPROC",
-		"SHN_LORESERVE",
-		"SHN_UNDEF",
-		"SHN_XINDEX",
-		"SHT_DYNAMIC",
-		"SHT_DYNSYM",
-		"SHT_FINI_ARRAY",
-		"SHT_GNU_ATTRIBUTES",
-		"SHT_GNU_HASH",
-		"SHT_GNU_LIBLIST",
-		"SHT_GNU_VERDEF",
-		"SHT_GNU_VERNEED",
-		"SHT_GNU_VERSYM",
-		"SHT_GROUP",
-		"SHT_HASH",
-		"SHT_HIOS",
-		"SHT_HIPROC",
-		"SHT_HIUSER",
-		"SHT_INIT_ARRAY",
-		"SHT_LOOS",
-		"SHT_LOPROC",
-		"SHT_LOUSER",
-		"SHT_NOBITS",
-		"SHT_NOTE",
-		"SHT_NULL",
-		"SHT_PREINIT_ARRAY",
-		"SHT_PROGBITS",
-		"SHT_REL",
-		"SHT_RELA",
-		"SHT_SHLIB",
-		"SHT_STRTAB",
-		"SHT_SYMTAB",
-		"SHT_SYMTAB_SHNDX",
-		"STB_GLOBAL",
-		"STB_HIOS",
-		"STB_HIPROC",
-		"STB_LOCAL",
-		"STB_LOOS",
-		"STB_LOPROC",
-		"STB_WEAK",
-		"STT_COMMON",
-		"STT_FILE",
-		"STT_FUNC",
-		"STT_HIOS",
-		"STT_HIPROC",
-		"STT_LOOS",
-		"STT_LOPROC",
-		"STT_NOTYPE",
-		"STT_OBJECT",
-		"STT_SECTION",
-		"STT_TLS",
-		"STV_DEFAULT",
-		"STV_HIDDEN",
-		"STV_INTERNAL",
-		"STV_PROTECTED",
-		"ST_BIND",
-		"ST_INFO",
-		"ST_TYPE",
-		"ST_VISIBILITY",
-		"Section",
-		"Section32",
-		"Section64",
-		"SectionFlag",
-		"SectionHeader",
-		"SectionIndex",
-		"SectionType",
-		"Sym32",
-		"Sym32Size",
-		"Sym64",
-		"Sym64Size",
-		"SymBind",
-		"SymType",
-		"SymVis",
-		"Symbol",
-		"Type",
-		"Version",
-	},
-	"debug/gosym": {
-		"DecodingError",
-		"Func",
-		"LineTable",
-		"NewLineTable",
-		"NewTable",
-		"Obj",
-		"Sym",
-		"Table",
-		"UnknownFileError",
-		"UnknownLineError",
-	},
-	"debug/macho": {
-		"ARM64_RELOC_ADDEND",
-		"ARM64_RELOC_BRANCH26",
-		"ARM64_RELOC_GOT_LOAD_PAGE21",
-		"ARM64_RELOC_GOT_LOAD_PAGEOFF12",
-		"ARM64_RELOC_PAGE21",
-		"ARM64_RELOC_PAGEOFF12",
-		"ARM64_RELOC_POINTER_TO_GOT",
-		"ARM64_RELOC_SUBTRACTOR",
-		"ARM64_RELOC_TLVP_LOAD_PAGE21",
-		"ARM64_RELOC_TLVP_LOAD_PAGEOFF12",
-		"ARM64_RELOC_UNSIGNED",
-		"ARM_RELOC_BR24",
-		"ARM_RELOC_HALF",
-		"ARM_RELOC_HALF_SECTDIFF",
-		"ARM_RELOC_LOCAL_SECTDIFF",
-		"ARM_RELOC_PAIR",
-		"ARM_RELOC_PB_LA_PTR",
-		"ARM_RELOC_SECTDIFF",
-		"ARM_RELOC_VANILLA",
-		"ARM_THUMB_32BIT_BRANCH",
-		"ARM_THUMB_RELOC_BR22",
-		"Cpu",
-		"Cpu386",
-		"CpuAmd64",
-		"CpuArm",
-		"CpuArm64",
-		"CpuPpc",
-		"CpuPpc64",
-		"Dylib",
-		"DylibCmd",
-		"Dysymtab",
-		"DysymtabCmd",
-		"ErrNotFat",
-		"FatArch",
-		"FatArchHeader",
-		"FatFile",
-		"File",
-		"FileHeader",
-		"FlagAllModsBound",
-		"FlagAllowStackExecution",
-		"FlagAppExtensionSafe",
-		"FlagBindAtLoad",
-		"FlagBindsToWeak",
-		"FlagCanonical",
-		"FlagDeadStrippableDylib",
-		"FlagDyldLink",
-		"FlagForceFlat",
-		"FlagHasTLVDescriptors",
-		"FlagIncrLink",
-		"FlagLazyInit",
-		"FlagNoFixPrebinding",
-		"FlagNoHeapExecution",
-		"FlagNoMultiDefs",
-		"FlagNoReexportedDylibs",
-		"FlagNoUndefs",
-		"FlagPIE",
-		"FlagPrebindable",
-		"FlagPrebound",
-		"FlagRootSafe",
-		"FlagSetuidSafe",
-		"FlagSplitSegs",
-		"FlagSubsectionsViaSymbols",
-		"FlagTwoLevel",
-		"FlagWeakDefines",
-		"FormatError",
-		"GENERIC_RELOC_LOCAL_SECTDIFF",
-		"GENERIC_RELOC_PAIR",
-		"GENERIC_RELOC_PB_LA_PTR",
-		"GENERIC_RELOC_SECTDIFF",
-		"GENERIC_RELOC_TLV",
-		"GENERIC_RELOC_VANILLA",
-		"Load",
-		"LoadBytes",
-		"LoadCmd",
-		"LoadCmdDylib",
-		"LoadCmdDylinker",
-		"LoadCmdDysymtab",
-		"LoadCmdRpath",
-		"LoadCmdSegment",
-		"LoadCmdSegment64",
-		"LoadCmdSymtab",
-		"LoadCmdThread",
-		"LoadCmdUnixThread",
-		"Magic32",
-		"Magic64",
-		"MagicFat",
-		"NewFatFile",
-		"NewFile",
-		"Nlist32",
-		"Nlist64",
-		"Open",
-		"OpenFat",
-		"Regs386",
-		"RegsAMD64",
-		"Reloc",
-		"RelocTypeARM",
-		"RelocTypeARM64",
-		"RelocTypeGeneric",
-		"RelocTypeX86_64",
-		"Rpath",
-		"RpathCmd",
-		"Section",
-		"Section32",
-		"Section64",
-		"SectionHeader",
-		"Segment",
-		"Segment32",
-		"Segment64",
-		"SegmentHeader",
-		"Symbol",
-		"Symtab",
-		"SymtabCmd",
-		"Thread",
-		"Type",
-		"TypeBundle",
-		"TypeDylib",
-		"TypeExec",
-		"TypeObj",
-		"X86_64_RELOC_BRANCH",
-		"X86_64_RELOC_GOT",
-		"X86_64_RELOC_GOT_LOAD",
-		"X86_64_RELOC_SIGNED",
-		"X86_64_RELOC_SIGNED_1",
-		"X86_64_RELOC_SIGNED_2",
-		"X86_64_RELOC_SIGNED_4",
-		"X86_64_RELOC_SUBTRACTOR",
-		"X86_64_RELOC_TLV",
-		"X86_64_RELOC_UNSIGNED",
-	},
-	"debug/pe": {
-		"COFFSymbol",
-		"COFFSymbolSize",
-		"DataDirectory",
-		"File",
-		"FileHeader",
-		"FormatError",
-		"IMAGE_DIRECTORY_ENTRY_ARCHITECTURE",
-		"IMAGE_DIRECTORY_ENTRY_BASERELOC",
-		"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT",
-		"IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR",
-		"IMAGE_DIRECTORY_ENTRY_DEBUG",
-		"IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT",
-		"IMAGE_DIRECTORY_ENTRY_EXCEPTION",
-		"IMAGE_DIRECTORY_ENTRY_EXPORT",
-		"IMAGE_DIRECTORY_ENTRY_GLOBALPTR",
-		"IMAGE_DIRECTORY_ENTRY_IAT",
-		"IMAGE_DIRECTORY_ENTRY_IMPORT",
-		"IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG",
-		"IMAGE_DIRECTORY_ENTRY_RESOURCE",
-		"IMAGE_DIRECTORY_ENTRY_SECURITY",
-		"IMAGE_DIRECTORY_ENTRY_TLS",
-		"IMAGE_DLLCHARACTERISTICS_APPCONTAINER",
-		"IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE",
-		"IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY",
-		"IMAGE_DLLCHARACTERISTICS_GUARD_CF",
-		"IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA",
-		"IMAGE_DLLCHARACTERISTICS_NO_BIND",
-		"IMAGE_DLLCHARACTERISTICS_NO_ISOLATION",
-		"IMAGE_DLLCHARACTERISTICS_NO_SEH",
-		"IMAGE_DLLCHARACTERISTICS_NX_COMPAT",
-		"IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE",
-		"IMAGE_DLLCHARACTERISTICS_WDM_DRIVER",
-		"IMAGE_FILE_32BIT_MACHINE",
-		"IMAGE_FILE_AGGRESIVE_WS_TRIM",
-		"IMAGE_FILE_BYTES_REVERSED_HI",
-		"IMAGE_FILE_BYTES_REVERSED_LO",
-		"IMAGE_FILE_DEBUG_STRIPPED",
-		"IMAGE_FILE_DLL",
-		"IMAGE_FILE_EXECUTABLE_IMAGE",
-		"IMAGE_FILE_LARGE_ADDRESS_AWARE",
-		"IMAGE_FILE_LINE_NUMS_STRIPPED",
-		"IMAGE_FILE_LOCAL_SYMS_STRIPPED",
-		"IMAGE_FILE_MACHINE_AM33",
-		"IMAGE_FILE_MACHINE_AMD64",
-		"IMAGE_FILE_MACHINE_ARM",
-		"IMAGE_FILE_MACHINE_ARM64",
-		"IMAGE_FILE_MACHINE_ARMNT",
-		"IMAGE_FILE_MACHINE_EBC",
-		"IMAGE_FILE_MACHINE_I386",
-		"IMAGE_FILE_MACHINE_IA64",
-		"IMAGE_FILE_MACHINE_M32R",
-		"IMAGE_FILE_MACHINE_MIPS16",
-		"IMAGE_FILE_MACHINE_MIPSFPU",
-		"IMAGE_FILE_MACHINE_MIPSFPU16",
-		"IMAGE_FILE_MACHINE_POWERPC",
-		"IMAGE_FILE_MACHINE_POWERPCFP",
-		"IMAGE_FILE_MACHINE_R4000",
-		"IMAGE_FILE_MACHINE_SH3",
-		"IMAGE_FILE_MACHINE_SH3DSP",
-		"IMAGE_FILE_MACHINE_SH4",
-		"IMAGE_FILE_MACHINE_SH5",
-		"IMAGE_FILE_MACHINE_THUMB",
-		"IMAGE_FILE_MACHINE_UNKNOWN",
-		"IMAGE_FILE_MACHINE_WCEMIPSV2",
-		"IMAGE_FILE_NET_RUN_FROM_SWAP",
-		"IMAGE_FILE_RELOCS_STRIPPED",
-		"IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP",
-		"IMAGE_FILE_SYSTEM",
-		"IMAGE_FILE_UP_SYSTEM_ONLY",
-		"IMAGE_SUBSYSTEM_EFI_APPLICATION",
-		"IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER",
-		"IMAGE_SUBSYSTEM_EFI_ROM",
-		"IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER",
-		"IMAGE_SUBSYSTEM_NATIVE",
-		"IMAGE_SUBSYSTEM_NATIVE_WINDOWS",
-		"IMAGE_SUBSYSTEM_OS2_CUI",
-		"IMAGE_SUBSYSTEM_POSIX_CUI",
-		"IMAGE_SUBSYSTEM_UNKNOWN",
-		"IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION",
-		"IMAGE_SUBSYSTEM_WINDOWS_CE_GUI",
-		"IMAGE_SUBSYSTEM_WINDOWS_CUI",
-		"IMAGE_SUBSYSTEM_WINDOWS_GUI",
-		"IMAGE_SUBSYSTEM_XBOX",
-		"ImportDirectory",
-		"NewFile",
-		"Open",
-		"OptionalHeader32",
-		"OptionalHeader64",
-		"Reloc",
-		"Section",
-		"SectionHeader",
-		"SectionHeader32",
-		"StringTable",
-		"Symbol",
-	},
-	"debug/plan9obj": {
-		"File",
-		"FileHeader",
-		"Magic386",
-		"Magic64",
-		"MagicAMD64",
-		"MagicARM",
-		"NewFile",
-		"Open",
-		"Section",
-		"SectionHeader",
-		"Sym",
-	},
-	"encoding": {
-		"BinaryMarshaler",
-		"BinaryUnmarshaler",
-		"TextMarshaler",
-		"TextUnmarshaler",
-	},
-	"encoding/ascii85": {
-		"CorruptInputError",
-		"Decode",
-		"Encode",
-		"MaxEncodedLen",
-		"NewDecoder",
-		"NewEncoder",
-	},
-	"encoding/asn1": {
-		"BitString",
-		"ClassApplication",
-		"ClassContextSpecific",
-		"ClassPrivate",
-		"ClassUniversal",
-		"Enumerated",
-		"Flag",
-		"Marshal",
-		"MarshalWithParams",
-		"NullBytes",
-		"NullRawValue",
-		"ObjectIdentifier",
-		"RawContent",
-		"RawValue",
-		"StructuralError",
-		"SyntaxError",
-		"TagBMPString",
-		"TagBitString",
-		"TagBoolean",
-		"TagEnum",
-		"TagGeneralString",
-		"TagGeneralizedTime",
-		"TagIA5String",
-		"TagInteger",
-		"TagNull",
-		"TagNumericString",
-		"TagOID",
-		"TagOctetString",
-		"TagPrintableString",
-		"TagSequence",
-		"TagSet",
-		"TagT61String",
-		"TagUTCTime",
-		"TagUTF8String",
-		"Unmarshal",
-		"UnmarshalWithParams",
-	},
-	"encoding/base32": {
-		"CorruptInputError",
-		"Encoding",
-		"HexEncoding",
-		"NewDecoder",
-		"NewEncoder",
-		"NewEncoding",
-		"NoPadding",
-		"StdEncoding",
-		"StdPadding",
-	},
-	"encoding/base64": {
-		"CorruptInputError",
-		"Encoding",
-		"NewDecoder",
-		"NewEncoder",
-		"NewEncoding",
-		"NoPadding",
-		"RawStdEncoding",
-		"RawURLEncoding",
-		"StdEncoding",
-		"StdPadding",
-		"URLEncoding",
-	},
-	"encoding/binary": {
-		"BigEndian",
-		"ByteOrder",
-		"LittleEndian",
-		"MaxVarintLen16",
-		"MaxVarintLen32",
-		"MaxVarintLen64",
-		"PutUvarint",
-		"PutVarint",
-		"Read",
-		"ReadUvarint",
-		"ReadVarint",
-		"Size",
-		"Uvarint",
-		"Varint",
-		"Write",
-	},
-	"encoding/csv": {
-		"ErrBareQuote",
-		"ErrFieldCount",
-		"ErrQuote",
-		"ErrTrailingComma",
-		"NewReader",
-		"NewWriter",
-		"ParseError",
-		"Reader",
-		"Writer",
-	},
-	"encoding/gob": {
-		"CommonType",
-		"Decoder",
-		"Encoder",
-		"GobDecoder",
-		"GobEncoder",
-		"NewDecoder",
-		"NewEncoder",
-		"Register",
-		"RegisterName",
-	},
-	"encoding/hex": {
-		"Decode",
-		"DecodeString",
-		"DecodedLen",
-		"Dump",
-		"Dumper",
-		"Encode",
-		"EncodeToString",
-		"EncodedLen",
-		"ErrLength",
-		"InvalidByteError",
-		"NewDecoder",
-		"NewEncoder",
-	},
-	"encoding/json": {
-		"Compact",
-		"Decoder",
-		"Delim",
-		"Encoder",
-		"HTMLEscape",
-		"Indent",
-		"InvalidUTF8Error",
-		"InvalidUnmarshalError",
-		"Marshal",
-		"MarshalIndent",
-		"Marshaler",
-		"MarshalerError",
-		"NewDecoder",
-		"NewEncoder",
-		"Number",
-		"RawMessage",
-		"SyntaxError",
-		"Token",
-		"Unmarshal",
-		"UnmarshalFieldError",
-		"UnmarshalTypeError",
-		"Unmarshaler",
-		"UnsupportedTypeError",
-		"UnsupportedValueError",
-		"Valid",
-	},
-	"encoding/pem": {
-		"Block",
-		"Decode",
-		"Encode",
-		"EncodeToMemory",
-	},
-	"encoding/xml": {
-		"Attr",
-		"CharData",
-		"Comment",
-		"CopyToken",
-		"Decoder",
-		"Directive",
-		"Encoder",
-		"EndElement",
-		"Escape",
-		"EscapeText",
-		"HTMLAutoClose",
-		"HTMLEntity",
-		"Header",
-		"Marshal",
-		"MarshalIndent",
-		"Marshaler",
-		"MarshalerAttr",
-		"Name",
-		"NewDecoder",
-		"NewEncoder",
-		"NewTokenDecoder",
-		"ProcInst",
-		"StartElement",
-		"SyntaxError",
-		"TagPathError",
-		"Token",
-		"TokenReader",
-		"Unmarshal",
-		"UnmarshalError",
-		"Unmarshaler",
-		"UnmarshalerAttr",
-		"UnsupportedTypeError",
-	},
-	"errors": {
-		"As",
-		"Is",
-		"New",
-		"Unwrap",
-	},
-	"expvar": {
-		"Do",
-		"Float",
-		"Func",
-		"Get",
-		"Handler",
-		"Int",
-		"KeyValue",
-		"Map",
-		"NewFloat",
-		"NewInt",
-		"NewMap",
-		"NewString",
-		"Publish",
-		"String",
-		"Var",
-	},
-	"flag": {
-		"Arg",
-		"Args",
-		"Bool",
-		"BoolVar",
-		"CommandLine",
-		"ContinueOnError",
-		"Duration",
-		"DurationVar",
-		"ErrHelp",
-		"ErrorHandling",
-		"ExitOnError",
-		"Flag",
-		"FlagSet",
-		"Float64",
-		"Float64Var",
-		"Getter",
-		"Int",
-		"Int64",
-		"Int64Var",
-		"IntVar",
-		"Lookup",
-		"NArg",
-		"NFlag",
-		"NewFlagSet",
-		"PanicOnError",
-		"Parse",
-		"Parsed",
-		"PrintDefaults",
-		"Set",
-		"String",
-		"StringVar",
-		"Uint",
-		"Uint64",
-		"Uint64Var",
-		"UintVar",
-		"UnquoteUsage",
-		"Usage",
-		"Value",
-		"Var",
-		"Visit",
-		"VisitAll",
-	},
-	"fmt": {
-		"Errorf",
-		"Formatter",
-		"Fprint",
-		"Fprintf",
-		"Fprintln",
-		"Fscan",
-		"Fscanf",
-		"Fscanln",
-		"GoStringer",
-		"Print",
-		"Printf",
-		"Println",
-		"Scan",
-		"ScanState",
-		"Scanf",
-		"Scanln",
-		"Scanner",
-		"Sprint",
-		"Sprintf",
-		"Sprintln",
-		"Sscan",
-		"Sscanf",
-		"Sscanln",
-		"State",
-		"Stringer",
-	},
-	"go/ast": {
-		"ArrayType",
-		"AssignStmt",
-		"Bad",
-		"BadDecl",
-		"BadExpr",
-		"BadStmt",
-		"BasicLit",
-		"BinaryExpr",
-		"BlockStmt",
-		"BranchStmt",
-		"CallExpr",
-		"CaseClause",
-		"ChanDir",
-		"ChanType",
-		"CommClause",
-		"Comment",
-		"CommentGroup",
-		"CommentMap",
-		"CompositeLit",
-		"Con",
-		"Decl",
-		"DeclStmt",
-		"DeferStmt",
-		"Ellipsis",
-		"EmptyStmt",
-		"Expr",
-		"ExprStmt",
-		"Field",
-		"FieldFilter",
-		"FieldList",
-		"File",
-		"FileExports",
-		"Filter",
-		"FilterDecl",
-		"FilterFile",
-		"FilterFuncDuplicates",
-		"FilterImportDuplicates",
-		"FilterPackage",
-		"FilterUnassociatedComments",
-		"ForStmt",
-		"Fprint",
-		"Fun",
-		"FuncDecl",
-		"FuncLit",
-		"FuncType",
-		"GenDecl",
-		"GoStmt",
-		"Ident",
-		"IfStmt",
-		"ImportSpec",
-		"Importer",
-		"IncDecStmt",
-		"IndexExpr",
-		"Inspect",
-		"InterfaceType",
-		"IsExported",
-		"KeyValueExpr",
-		"LabeledStmt",
-		"Lbl",
-		"MapType",
-		"MergeMode",
-		"MergePackageFiles",
-		"NewCommentMap",
-		"NewIdent",
-		"NewObj",
-		"NewPackage",
-		"NewScope",
-		"Node",
-		"NotNilFilter",
-		"ObjKind",
-		"Object",
-		"Package",
-		"PackageExports",
-		"ParenExpr",
-		"Pkg",
-		"Print",
-		"RECV",
-		"RangeStmt",
-		"ReturnStmt",
-		"SEND",
-		"Scope",
-		"SelectStmt",
-		"SelectorExpr",
-		"SendStmt",
-		"SliceExpr",
-		"SortImports",
-		"Spec",
-		"StarExpr",
-		"Stmt",
-		"StructType",
-		"SwitchStmt",
-		"Typ",
-		"TypeAssertExpr",
-		"TypeSpec",
-		"TypeSwitchStmt",
-		"UnaryExpr",
-		"ValueSpec",
-		"Var",
-		"Visitor",
-		"Walk",
-	},
-	"go/build": {
-		"AllowBinary",
-		"ArchChar",
-		"Context",
-		"Default",
-		"FindOnly",
-		"IgnoreVendor",
-		"Import",
-		"ImportComment",
-		"ImportDir",
-		"ImportMode",
-		"IsLocalImport",
-		"MultiplePackageError",
-		"NoGoError",
-		"Package",
-		"ToolDir",
-	},
-	"go/constant": {
-		"BinaryOp",
-		"BitLen",
-		"Bool",
-		"BoolVal",
-		"Bytes",
-		"Compare",
-		"Complex",
-		"Denom",
-		"Float",
-		"Float32Val",
-		"Float64Val",
-		"Imag",
-		"Int",
-		"Int64Val",
-		"Kind",
-		"Make",
-		"MakeBool",
-		"MakeFloat64",
-		"MakeFromBytes",
-		"MakeFromLiteral",
-		"MakeImag",
-		"MakeInt64",
-		"MakeString",
-		"MakeUint64",
-		"MakeUnknown",
-		"Num",
-		"Real",
-		"Shift",
-		"Sign",
-		"String",
-		"StringVal",
-		"ToComplex",
-		"ToFloat",
-		"ToInt",
-		"Uint64Val",
-		"UnaryOp",
-		"Unknown",
-		"Val",
-		"Value",
-	},
-	"go/doc": {
-		"AllDecls",
-		"AllMethods",
-		"Example",
-		"Examples",
-		"Filter",
-		"Func",
-		"IllegalPrefixes",
-		"IsPredeclared",
-		"Mode",
-		"New",
-		"NewFromFiles",
-		"Note",
-		"Package",
-		"PreserveAST",
-		"Synopsis",
-		"ToHTML",
-		"ToText",
-		"Type",
-		"Value",
-	},
-	"go/format": {
-		"Node",
-		"Source",
-	},
-	"go/importer": {
-		"Default",
-		"For",
-		"ForCompiler",
-		"Lookup",
-	},
-	"go/parser": {
-		"AllErrors",
-		"DeclarationErrors",
-		"ImportsOnly",
-		"Mode",
-		"PackageClauseOnly",
-		"ParseComments",
-		"ParseDir",
-		"ParseExpr",
-		"ParseExprFrom",
-		"ParseFile",
-		"SpuriousErrors",
-		"Trace",
-	},
-	"go/printer": {
-		"CommentedNode",
-		"Config",
-		"Fprint",
-		"Mode",
-		"RawFormat",
-		"SourcePos",
-		"TabIndent",
-		"UseSpaces",
-	},
-	"go/scanner": {
-		"Error",
-		"ErrorHandler",
-		"ErrorList",
-		"Mode",
-		"PrintError",
-		"ScanComments",
-		"Scanner",
-	},
-	"go/token": {
-		"ADD",
-		"ADD_ASSIGN",
-		"AND",
-		"AND_ASSIGN",
-		"AND_NOT",
-		"AND_NOT_ASSIGN",
-		"ARROW",
-		"ASSIGN",
-		"BREAK",
-		"CASE",
-		"CHAN",
-		"CHAR",
-		"COLON",
-		"COMMA",
-		"COMMENT",
-		"CONST",
-		"CONTINUE",
-		"DEC",
-		"DEFAULT",
-		"DEFER",
-		"DEFINE",
-		"ELLIPSIS",
-		"ELSE",
-		"EOF",
-		"EQL",
-		"FALLTHROUGH",
-		"FLOAT",
-		"FOR",
-		"FUNC",
-		"File",
-		"FileSet",
-		"GEQ",
-		"GO",
-		"GOTO",
-		"GTR",
-		"HighestPrec",
-		"IDENT",
-		"IF",
-		"ILLEGAL",
-		"IMAG",
-		"IMPORT",
-		"INC",
-		"INT",
-		"INTERFACE",
-		"IsExported",
-		"IsIdentifier",
-		"IsKeyword",
-		"LAND",
-		"LBRACE",
-		"LBRACK",
-		"LEQ",
-		"LOR",
-		"LPAREN",
-		"LSS",
-		"Lookup",
-		"LowestPrec",
-		"MAP",
-		"MUL",
-		"MUL_ASSIGN",
-		"NEQ",
-		"NOT",
-		"NewFileSet",
-		"NoPos",
-		"OR",
-		"OR_ASSIGN",
-		"PACKAGE",
-		"PERIOD",
-		"Pos",
-		"Position",
-		"QUO",
-		"QUO_ASSIGN",
-		"RANGE",
-		"RBRACE",
-		"RBRACK",
-		"REM",
-		"REM_ASSIGN",
-		"RETURN",
-		"RPAREN",
-		"SELECT",
-		"SEMICOLON",
-		"SHL",
-		"SHL_ASSIGN",
-		"SHR",
-		"SHR_ASSIGN",
-		"STRING",
-		"STRUCT",
-		"SUB",
-		"SUB_ASSIGN",
-		"SWITCH",
-		"TYPE",
-		"Token",
-		"UnaryPrec",
-		"VAR",
-		"XOR",
-		"XOR_ASSIGN",
-	},
-	"go/types": {
-		"Array",
-		"AssertableTo",
-		"AssignableTo",
-		"Basic",
-		"BasicInfo",
-		"BasicKind",
-		"Bool",
-		"Builtin",
-		"Byte",
-		"Chan",
-		"ChanDir",
-		"CheckExpr",
-		"Checker",
-		"Comparable",
-		"Complex128",
-		"Complex64",
-		"Config",
-		"Const",
-		"ConvertibleTo",
-		"DefPredeclaredTestFuncs",
-		"Default",
-		"Error",
-		"Eval",
-		"ExprString",
-		"FieldVal",
-		"Float32",
-		"Float64",
-		"Func",
-		"Id",
-		"Identical",
-		"IdenticalIgnoreTags",
-		"Implements",
-		"ImportMode",
-		"Importer",
-		"ImporterFrom",
-		"Info",
-		"Initializer",
-		"Int",
-		"Int16",
-		"Int32",
-		"Int64",
-		"Int8",
-		"Interface",
-		"Invalid",
-		"IsBoolean",
-		"IsComplex",
-		"IsConstType",
-		"IsFloat",
-		"IsInteger",
-		"IsInterface",
-		"IsNumeric",
-		"IsOrdered",
-		"IsString",
-		"IsUnsigned",
-		"IsUntyped",
-		"Label",
-		"LookupFieldOrMethod",
-		"Map",
-		"MethodExpr",
-		"MethodSet",
-		"MethodVal",
-		"MissingMethod",
-		"Named",
-		"NewArray",
-		"NewChan",
-		"NewChecker",
-		"NewConst",
-		"NewField",
-		"NewFunc",
-		"NewInterface",
-		"NewInterfaceType",
-		"NewLabel",
-		"NewMap",
-		"NewMethodSet",
-		"NewNamed",
-		"NewPackage",
-		"NewParam",
-		"NewPkgName",
-		"NewPointer",
-		"NewScope",
-		"NewSignature",
-		"NewSlice",
-		"NewStruct",
-		"NewTuple",
-		"NewTypeName",
-		"NewVar",
-		"Nil",
-		"Object",
-		"ObjectString",
-		"Package",
-		"PkgName",
-		"Pointer",
-		"Qualifier",
-		"RecvOnly",
-		"RelativeTo",
-		"Rune",
-		"Scope",
-		"Selection",
-		"SelectionKind",
-		"SelectionString",
-		"SendOnly",
-		"SendRecv",
-		"Signature",
-		"Sizes",
-		"SizesFor",
-		"Slice",
-		"StdSizes",
-		"String",
-		"Struct",
-		"Tuple",
-		"Typ",
-		"Type",
-		"TypeAndValue",
-		"TypeName",
-		"TypeString",
-		"Uint",
-		"Uint16",
-		"Uint32",
-		"Uint64",
-		"Uint8",
-		"Uintptr",
-		"Universe",
-		"Unsafe",
-		"UnsafePointer",
-		"UntypedBool",
-		"UntypedComplex",
-		"UntypedFloat",
-		"UntypedInt",
-		"UntypedNil",
-		"UntypedRune",
-		"UntypedString",
-		"Var",
-		"WriteExpr",
-		"WriteSignature",
-		"WriteType",
-	},
-	"hash": {
-		"Hash",
-		"Hash32",
-		"Hash64",
-	},
-	"hash/adler32": {
-		"Checksum",
-		"New",
-		"Size",
-	},
-	"hash/crc32": {
-		"Castagnoli",
-		"Checksum",
-		"ChecksumIEEE",
-		"IEEE",
-		"IEEETable",
-		"Koopman",
-		"MakeTable",
-		"New",
-		"NewIEEE",
-		"Size",
-		"Table",
-		"Update",
-	},
-	"hash/crc64": {
-		"Checksum",
-		"ECMA",
-		"ISO",
-		"MakeTable",
-		"New",
-		"Size",
-		"Table",
-		"Update",
-	},
-	"hash/fnv": {
-		"New128",
-		"New128a",
-		"New32",
-		"New32a",
-		"New64",
-		"New64a",
-	},
-	"hash/maphash": {
-		"Hash",
-		"MakeSeed",
-		"Seed",
-	},
-	"html": {
-		"EscapeString",
-		"UnescapeString",
-	},
-	"html/template": {
-		"CSS",
-		"ErrAmbigContext",
-		"ErrBadHTML",
-		"ErrBranchEnd",
-		"ErrEndContext",
-		"ErrNoSuchTemplate",
-		"ErrOutputContext",
-		"ErrPartialCharset",
-		"ErrPartialEscape",
-		"ErrPredefinedEscaper",
-		"ErrRangeLoopReentry",
-		"ErrSlashAmbig",
-		"Error",
-		"ErrorCode",
-		"FuncMap",
-		"HTML",
-		"HTMLAttr",
-		"HTMLEscape",
-		"HTMLEscapeString",
-		"HTMLEscaper",
-		"IsTrue",
-		"JS",
-		"JSEscape",
-		"JSEscapeString",
-		"JSEscaper",
-		"JSStr",
-		"Must",
-		"New",
-		"OK",
-		"ParseFiles",
-		"ParseGlob",
-		"Srcset",
-		"Template",
-		"URL",
-		"URLQueryEscaper",
-	},
-	"image": {
-		"Alpha",
-		"Alpha16",
-		"Black",
-		"CMYK",
-		"Config",
-		"Decode",
-		"DecodeConfig",
-		"ErrFormat",
-		"Gray",
-		"Gray16",
-		"Image",
-		"NRGBA",
-		"NRGBA64",
-		"NYCbCrA",
-		"NewAlpha",
-		"NewAlpha16",
-		"NewCMYK",
-		"NewGray",
-		"NewGray16",
-		"NewNRGBA",
-		"NewNRGBA64",
-		"NewNYCbCrA",
-		"NewPaletted",
-		"NewRGBA",
-		"NewRGBA64",
-		"NewUniform",
-		"NewYCbCr",
-		"Opaque",
-		"Paletted",
-		"PalettedImage",
-		"Point",
-		"Pt",
-		"RGBA",
-		"RGBA64",
-		"Rect",
-		"Rectangle",
-		"RegisterFormat",
-		"Transparent",
-		"Uniform",
-		"White",
-		"YCbCr",
-		"YCbCrSubsampleRatio",
-		"YCbCrSubsampleRatio410",
-		"YCbCrSubsampleRatio411",
-		"YCbCrSubsampleRatio420",
-		"YCbCrSubsampleRatio422",
-		"YCbCrSubsampleRatio440",
-		"YCbCrSubsampleRatio444",
-		"ZP",
-		"ZR",
-	},
-	"image/color": {
-		"Alpha",
-		"Alpha16",
-		"Alpha16Model",
-		"AlphaModel",
-		"Black",
-		"CMYK",
-		"CMYKModel",
-		"CMYKToRGB",
-		"Color",
-		"Gray",
-		"Gray16",
-		"Gray16Model",
-		"GrayModel",
-		"Model",
-		"ModelFunc",
-		"NRGBA",
-		"NRGBA64",
-		"NRGBA64Model",
-		"NRGBAModel",
-		"NYCbCrA",
-		"NYCbCrAModel",
-		"Opaque",
-		"Palette",
-		"RGBA",
-		"RGBA64",
-		"RGBA64Model",
-		"RGBAModel",
-		"RGBToCMYK",
-		"RGBToYCbCr",
-		"Transparent",
-		"White",
-		"YCbCr",
-		"YCbCrModel",
-		"YCbCrToRGB",
-	},
-	"image/color/palette": {
-		"Plan9",
-		"WebSafe",
-	},
-	"image/draw": {
-		"Draw",
-		"DrawMask",
-		"Drawer",
-		"FloydSteinberg",
-		"Image",
-		"Op",
-		"Over",
-		"Quantizer",
-		"Src",
-	},
-	"image/gif": {
-		"Decode",
-		"DecodeAll",
-		"DecodeConfig",
-		"DisposalBackground",
-		"DisposalNone",
-		"DisposalPrevious",
-		"Encode",
-		"EncodeAll",
-		"GIF",
-		"Options",
-	},
-	"image/jpeg": {
-		"Decode",
-		"DecodeConfig",
-		"DefaultQuality",
-		"Encode",
-		"FormatError",
-		"Options",
-		"Reader",
-		"UnsupportedError",
-	},
-	"image/png": {
-		"BestCompression",
-		"BestSpeed",
-		"CompressionLevel",
-		"Decode",
-		"DecodeConfig",
-		"DefaultCompression",
-		"Encode",
-		"Encoder",
-		"EncoderBuffer",
-		"EncoderBufferPool",
-		"FormatError",
-		"NoCompression",
-		"UnsupportedError",
-	},
-	"index/suffixarray": {
-		"Index",
-		"New",
-	},
-	"io": {
-		"ByteReader",
-		"ByteScanner",
-		"ByteWriter",
-		"Closer",
-		"Copy",
-		"CopyBuffer",
-		"CopyN",
-		"EOF",
-		"ErrClosedPipe",
-		"ErrNoProgress",
-		"ErrShortBuffer",
-		"ErrShortWrite",
-		"ErrUnexpectedEOF",
-		"LimitReader",
-		"LimitedReader",
-		"MultiReader",
-		"MultiWriter",
-		"NewSectionReader",
-		"Pipe",
-		"PipeReader",
-		"PipeWriter",
-		"ReadAtLeast",
-		"ReadCloser",
-		"ReadFull",
-		"ReadSeeker",
-		"ReadWriteCloser",
-		"ReadWriteSeeker",
-		"ReadWriter",
-		"Reader",
-		"ReaderAt",
-		"ReaderFrom",
-		"RuneReader",
-		"RuneScanner",
-		"SectionReader",
-		"SeekCurrent",
-		"SeekEnd",
-		"SeekStart",
-		"Seeker",
-		"StringWriter",
-		"TeeReader",
-		"WriteCloser",
-		"WriteSeeker",
-		"WriteString",
-		"Writer",
-		"WriterAt",
-		"WriterTo",
-	},
-	"io/ioutil": {
-		"Discard",
-		"NopCloser",
-		"ReadAll",
-		"ReadDir",
-		"ReadFile",
-		"TempDir",
-		"TempFile",
-		"WriteFile",
-	},
-	"log": {
-		"Fatal",
-		"Fatalf",
-		"Fatalln",
-		"Flags",
-		"LUTC",
-		"Ldate",
-		"Llongfile",
-		"Lmicroseconds",
-		"Lmsgprefix",
-		"Logger",
-		"Lshortfile",
-		"LstdFlags",
-		"Ltime",
-		"New",
-		"Output",
-		"Panic",
-		"Panicf",
-		"Panicln",
-		"Prefix",
-		"Print",
-		"Printf",
-		"Println",
-		"SetFlags",
-		"SetOutput",
-		"SetPrefix",
-		"Writer",
-	},
-	"log/syslog": {
-		"Dial",
-		"LOG_ALERT",
-		"LOG_AUTH",
-		"LOG_AUTHPRIV",
-		"LOG_CRIT",
-		"LOG_CRON",
-		"LOG_DAEMON",
-		"LOG_DEBUG",
-		"LOG_EMERG",
-		"LOG_ERR",
-		"LOG_FTP",
-		"LOG_INFO",
-		"LOG_KERN",
-		"LOG_LOCAL0",
-		"LOG_LOCAL1",
-		"LOG_LOCAL2",
-		"LOG_LOCAL3",
-		"LOG_LOCAL4",
-		"LOG_LOCAL5",
-		"LOG_LOCAL6",
-		"LOG_LOCAL7",
-		"LOG_LPR",
-		"LOG_MAIL",
-		"LOG_NEWS",
-		"LOG_NOTICE",
-		"LOG_SYSLOG",
-		"LOG_USER",
-		"LOG_UUCP",
-		"LOG_WARNING",
-		"New",
-		"NewLogger",
-		"Priority",
-		"Writer",
-	},
-	"math": {
-		"Abs",
-		"Acos",
-		"Acosh",
-		"Asin",
-		"Asinh",
-		"Atan",
-		"Atan2",
-		"Atanh",
-		"Cbrt",
-		"Ceil",
-		"Copysign",
-		"Cos",
-		"Cosh",
-		"Dim",
-		"E",
-		"Erf",
-		"Erfc",
-		"Erfcinv",
-		"Erfinv",
-		"Exp",
-		"Exp2",
-		"Expm1",
-		"FMA",
-		"Float32bits",
-		"Float32frombits",
-		"Float64bits",
-		"Float64frombits",
-		"Floor",
-		"Frexp",
-		"Gamma",
-		"Hypot",
-		"Ilogb",
-		"Inf",
-		"IsInf",
-		"IsNaN",
-		"J0",
-		"J1",
-		"Jn",
-		"Ldexp",
-		"Lgamma",
-		"Ln10",
-		"Ln2",
-		"Log",
-		"Log10",
-		"Log10E",
-		"Log1p",
-		"Log2",
-		"Log2E",
-		"Logb",
-		"Max",
-		"MaxFloat32",
-		"MaxFloat64",
-		"MaxInt16",
-		"MaxInt32",
-		"MaxInt64",
-		"MaxInt8",
-		"MaxUint16",
-		"MaxUint32",
-		"MaxUint64",
-		"MaxUint8",
-		"Min",
-		"MinInt16",
-		"MinInt32",
-		"MinInt64",
-		"MinInt8",
-		"Mod",
-		"Modf",
-		"NaN",
-		"Nextafter",
-		"Nextafter32",
-		"Phi",
-		"Pi",
-		"Pow",
-		"Pow10",
-		"Remainder",
-		"Round",
-		"RoundToEven",
-		"Signbit",
-		"Sin",
-		"Sincos",
-		"Sinh",
-		"SmallestNonzeroFloat32",
-		"SmallestNonzeroFloat64",
-		"Sqrt",
-		"Sqrt2",
-		"SqrtE",
-		"SqrtPhi",
-		"SqrtPi",
-		"Tan",
-		"Tanh",
-		"Trunc",
-		"Y0",
-		"Y1",
-		"Yn",
-	},
-	"math/big": {
-		"Above",
-		"Accuracy",
-		"AwayFromZero",
-		"Below",
-		"ErrNaN",
-		"Exact",
-		"Float",
-		"Int",
-		"Jacobi",
-		"MaxBase",
-		"MaxExp",
-		"MaxPrec",
-		"MinExp",
-		"NewFloat",
-		"NewInt",
-		"NewRat",
-		"ParseFloat",
-		"Rat",
-		"RoundingMode",
-		"ToNearestAway",
-		"ToNearestEven",
-		"ToNegativeInf",
-		"ToPositiveInf",
-		"ToZero",
-		"Word",
-	},
-	"math/bits": {
-		"Add",
-		"Add32",
-		"Add64",
-		"Div",
-		"Div32",
-		"Div64",
-		"LeadingZeros",
-		"LeadingZeros16",
-		"LeadingZeros32",
-		"LeadingZeros64",
-		"LeadingZeros8",
-		"Len",
-		"Len16",
-		"Len32",
-		"Len64",
-		"Len8",
-		"Mul",
-		"Mul32",
-		"Mul64",
-		"OnesCount",
-		"OnesCount16",
-		"OnesCount32",
-		"OnesCount64",
-		"OnesCount8",
-		"Rem",
-		"Rem32",
-		"Rem64",
-		"Reverse",
-		"Reverse16",
-		"Reverse32",
-		"Reverse64",
-		"Reverse8",
-		"ReverseBytes",
-		"ReverseBytes16",
-		"ReverseBytes32",
-		"ReverseBytes64",
-		"RotateLeft",
-		"RotateLeft16",
-		"RotateLeft32",
-		"RotateLeft64",
-		"RotateLeft8",
-		"Sub",
-		"Sub32",
-		"Sub64",
-		"TrailingZeros",
-		"TrailingZeros16",
-		"TrailingZeros32",
-		"TrailingZeros64",
-		"TrailingZeros8",
-		"UintSize",
-	},
-	"math/cmplx": {
-		"Abs",
-		"Acos",
-		"Acosh",
-		"Asin",
-		"Asinh",
-		"Atan",
-		"Atanh",
-		"Conj",
-		"Cos",
-		"Cosh",
-		"Cot",
-		"Exp",
-		"Inf",
-		"IsInf",
-		"IsNaN",
-		"Log",
-		"Log10",
-		"NaN",
-		"Phase",
-		"Polar",
-		"Pow",
-		"Rect",
-		"Sin",
-		"Sinh",
-		"Sqrt",
-		"Tan",
-		"Tanh",
-	},
-	"math/rand": {
-		"ExpFloat64",
-		"Float32",
-		"Float64",
-		"Int",
-		"Int31",
-		"Int31n",
-		"Int63",
-		"Int63n",
-		"Intn",
-		"New",
-		"NewSource",
-		"NewZipf",
-		"NormFloat64",
-		"Perm",
-		"Rand",
-		"Read",
-		"Seed",
-		"Shuffle",
-		"Source",
-		"Source64",
-		"Uint32",
-		"Uint64",
-		"Zipf",
-	},
-	"mime": {
-		"AddExtensionType",
-		"BEncoding",
-		"ErrInvalidMediaParameter",
-		"ExtensionsByType",
-		"FormatMediaType",
-		"ParseMediaType",
-		"QEncoding",
-		"TypeByExtension",
-		"WordDecoder",
-		"WordEncoder",
-	},
-	"mime/multipart": {
-		"ErrMessageTooLarge",
-		"File",
-		"FileHeader",
-		"Form",
-		"NewReader",
-		"NewWriter",
-		"Part",
-		"Reader",
-		"Writer",
-	},
-	"mime/quotedprintable": {
-		"NewReader",
-		"NewWriter",
-		"Reader",
-		"Writer",
-	},
-	"net": {
-		"Addr",
-		"AddrError",
-		"Buffers",
-		"CIDRMask",
-		"Conn",
-		"DNSConfigError",
-		"DNSError",
-		"DefaultResolver",
-		"Dial",
-		"DialIP",
-		"DialTCP",
-		"DialTimeout",
-		"DialUDP",
-		"DialUnix",
-		"Dialer",
-		"ErrWriteToConnected",
-		"Error",
-		"FileConn",
-		"FileListener",
-		"FilePacketConn",
-		"FlagBroadcast",
-		"FlagLoopback",
-		"FlagMulticast",
-		"FlagPointToPoint",
-		"FlagUp",
-		"Flags",
-		"HardwareAddr",
-		"IP",
-		"IPAddr",
-		"IPConn",
-		"IPMask",
-		"IPNet",
-		"IPv4",
-		"IPv4Mask",
-		"IPv4allrouter",
-		"IPv4allsys",
-		"IPv4bcast",
-		"IPv4len",
-		"IPv4zero",
-		"IPv6interfacelocalallnodes",
-		"IPv6len",
-		"IPv6linklocalallnodes",
-		"IPv6linklocalallrouters",
-		"IPv6loopback",
-		"IPv6unspecified",
-		"IPv6zero",
-		"Interface",
-		"InterfaceAddrs",
-		"InterfaceByIndex",
-		"InterfaceByName",
-		"Interfaces",
-		"InvalidAddrError",
-		"JoinHostPort",
-		"Listen",
-		"ListenConfig",
-		"ListenIP",
-		"ListenMulticastUDP",
-		"ListenPacket",
-		"ListenTCP",
-		"ListenUDP",
-		"ListenUnix",
-		"ListenUnixgram",
-		"Listener",
-		"LookupAddr",
-		"LookupCNAME",
-		"LookupHost",
-		"LookupIP",
-		"LookupMX",
-		"LookupNS",
-		"LookupPort",
-		"LookupSRV",
-		"LookupTXT",
-		"MX",
-		"NS",
-		"OpError",
-		"PacketConn",
-		"ParseCIDR",
-		"ParseError",
-		"ParseIP",
-		"ParseMAC",
-		"Pipe",
-		"ResolveIPAddr",
-		"ResolveTCPAddr",
-		"ResolveUDPAddr",
-		"ResolveUnixAddr",
-		"Resolver",
-		"SRV",
-		"SplitHostPort",
-		"TCPAddr",
-		"TCPConn",
-		"TCPListener",
-		"UDPAddr",
-		"UDPConn",
-		"UnixAddr",
-		"UnixConn",
-		"UnixListener",
-		"UnknownNetworkError",
-	},
-	"net/http": {
-		"CanonicalHeaderKey",
-		"Client",
-		"CloseNotifier",
-		"ConnState",
-		"Cookie",
-		"CookieJar",
-		"DefaultClient",
-		"DefaultMaxHeaderBytes",
-		"DefaultMaxIdleConnsPerHost",
-		"DefaultServeMux",
-		"DefaultTransport",
-		"DetectContentType",
-		"Dir",
-		"ErrAbortHandler",
-		"ErrBodyNotAllowed",
-		"ErrBodyReadAfterClose",
-		"ErrContentLength",
-		"ErrHandlerTimeout",
-		"ErrHeaderTooLong",
-		"ErrHijacked",
-		"ErrLineTooLong",
-		"ErrMissingBoundary",
-		"ErrMissingContentLength",
-		"ErrMissingFile",
-		"ErrNoCookie",
-		"ErrNoLocation",
-		"ErrNotMultipart",
-		"ErrNotSupported",
-		"ErrServerClosed",
-		"ErrShortBody",
-		"ErrSkipAltProtocol",
-		"ErrUnexpectedTrailer",
-		"ErrUseLastResponse",
-		"ErrWriteAfterFlush",
-		"Error",
-		"File",
-		"FileServer",
-		"FileSystem",
-		"Flusher",
-		"Get",
-		"Handle",
-		"HandleFunc",
-		"Handler",
-		"HandlerFunc",
-		"Head",
-		"Header",
-		"Hijacker",
-		"ListenAndServe",
-		"ListenAndServeTLS",
-		"LocalAddrContextKey",
-		"MaxBytesReader",
-		"MethodConnect",
-		"MethodDelete",
-		"MethodGet",
-		"MethodHead",
-		"MethodOptions",
-		"MethodPatch",
-		"MethodPost",
-		"MethodPut",
-		"MethodTrace",
-		"NewFileTransport",
-		"NewRequest",
-		"NewRequestWithContext",
-		"NewServeMux",
-		"NoBody",
-		"NotFound",
-		"NotFoundHandler",
-		"ParseHTTPVersion",
-		"ParseTime",
-		"Post",
-		"PostForm",
-		"ProtocolError",
-		"ProxyFromEnvironment",
-		"ProxyURL",
-		"PushOptions",
-		"Pusher",
-		"ReadRequest",
-		"ReadResponse",
-		"Redirect",
-		"RedirectHandler",
-		"Request",
-		"Response",
-		"ResponseWriter",
-		"RoundTripper",
-		"SameSite",
-		"SameSiteDefaultMode",
-		"SameSiteLaxMode",
-		"SameSiteNoneMode",
-		"SameSiteStrictMode",
-		"Serve",
-		"ServeContent",
-		"ServeFile",
-		"ServeMux",
-		"ServeTLS",
-		"Server",
-		"ServerContextKey",
-		"SetCookie",
-		"StateActive",
-		"StateClosed",
-		"StateHijacked",
-		"StateIdle",
-		"StateNew",
-		"StatusAccepted",
-		"StatusAlreadyReported",
-		"StatusBadGateway",
-		"StatusBadRequest",
-		"StatusConflict",
-		"StatusContinue",
-		"StatusCreated",
-		"StatusEarlyHints",
-		"StatusExpectationFailed",
-		"StatusFailedDependency",
-		"StatusForbidden",
-		"StatusFound",
-		"StatusGatewayTimeout",
-		"StatusGone",
-		"StatusHTTPVersionNotSupported",
-		"StatusIMUsed",
-		"StatusInsufficientStorage",
-		"StatusInternalServerError",
-		"StatusLengthRequired",
-		"StatusLocked",
-		"StatusLoopDetected",
-		"StatusMethodNotAllowed",
-		"StatusMisdirectedRequest",
-		"StatusMovedPermanently",
-		"StatusMultiStatus",
-		"StatusMultipleChoices",
-		"StatusNetworkAuthenticationRequired",
-		"StatusNoContent",
-		"StatusNonAuthoritativeInfo",
-		"StatusNotAcceptable",
-		"StatusNotExtended",
-		"StatusNotFound",
-		"StatusNotImplemented",
-		"StatusNotModified",
-		"StatusOK",
-		"StatusPartialContent",
-		"StatusPaymentRequired",
-		"StatusPermanentRedirect",
-		"StatusPreconditionFailed",
-		"StatusPreconditionRequired",
-		"StatusProcessing",
-		"StatusProxyAuthRequired",
-		"StatusRequestEntityTooLarge",
-		"StatusRequestHeaderFieldsTooLarge",
-		"StatusRequestTimeout",
-		"StatusRequestURITooLong",
-		"StatusRequestedRangeNotSatisfiable",
-		"StatusResetContent",
-		"StatusSeeOther",
-		"StatusServiceUnavailable",
-		"StatusSwitchingProtocols",
-		"StatusTeapot",
-		"StatusTemporaryRedirect",
-		"StatusText",
-		"StatusTooEarly",
-		"StatusTooManyRequests",
-		"StatusUnauthorized",
-		"StatusUnavailableForLegalReasons",
-		"StatusUnprocessableEntity",
-		"StatusUnsupportedMediaType",
-		"StatusUpgradeRequired",
-		"StatusUseProxy",
-		"StatusVariantAlsoNegotiates",
-		"StripPrefix",
-		"TimeFormat",
-		"TimeoutHandler",
-		"TrailerPrefix",
-		"Transport",
-	},
-	"net/http/cgi": {
-		"Handler",
-		"Request",
-		"RequestFromMap",
-		"Serve",
-	},
-	"net/http/cookiejar": {
-		"Jar",
-		"New",
-		"Options",
-		"PublicSuffixList",
-	},
-	"net/http/fcgi": {
-		"ErrConnClosed",
-		"ErrRequestAborted",
-		"ProcessEnv",
-		"Serve",
-	},
-	"net/http/httptest": {
-		"DefaultRemoteAddr",
-		"NewRecorder",
-		"NewRequest",
-		"NewServer",
-		"NewTLSServer",
-		"NewUnstartedServer",
-		"ResponseRecorder",
-		"Server",
-	},
-	"net/http/httptrace": {
-		"ClientTrace",
-		"ContextClientTrace",
-		"DNSDoneInfo",
-		"DNSStartInfo",
-		"GotConnInfo",
-		"WithClientTrace",
-		"WroteRequestInfo",
-	},
-	"net/http/httputil": {
-		"BufferPool",
-		"ClientConn",
-		"DumpRequest",
-		"DumpRequestOut",
-		"DumpResponse",
-		"ErrClosed",
-		"ErrLineTooLong",
-		"ErrPersistEOF",
-		"ErrPipeline",
-		"NewChunkedReader",
-		"NewChunkedWriter",
-		"NewClientConn",
-		"NewProxyClientConn",
-		"NewServerConn",
-		"NewSingleHostReverseProxy",
-		"ReverseProxy",
-		"ServerConn",
-	},
-	"net/http/pprof": {
-		"Cmdline",
-		"Handler",
-		"Index",
-		"Profile",
-		"Symbol",
-		"Trace",
-	},
-	"net/mail": {
-		"Address",
-		"AddressParser",
-		"ErrHeaderNotPresent",
-		"Header",
-		"Message",
-		"ParseAddress",
-		"ParseAddressList",
-		"ParseDate",
-		"ReadMessage",
-	},
-	"net/rpc": {
-		"Accept",
-		"Call",
-		"Client",
-		"ClientCodec",
-		"DefaultDebugPath",
-		"DefaultRPCPath",
-		"DefaultServer",
-		"Dial",
-		"DialHTTP",
-		"DialHTTPPath",
-		"ErrShutdown",
-		"HandleHTTP",
-		"NewClient",
-		"NewClientWithCodec",
-		"NewServer",
-		"Register",
-		"RegisterName",
-		"Request",
-		"Response",
-		"ServeCodec",
-		"ServeConn",
-		"ServeRequest",
-		"Server",
-		"ServerCodec",
-		"ServerError",
-	},
-	"net/rpc/jsonrpc": {
-		"Dial",
-		"NewClient",
-		"NewClientCodec",
-		"NewServerCodec",
-		"ServeConn",
-	},
-	"net/smtp": {
-		"Auth",
-		"CRAMMD5Auth",
-		"Client",
-		"Dial",
-		"NewClient",
-		"PlainAuth",
-		"SendMail",
-		"ServerInfo",
-	},
-	"net/textproto": {
-		"CanonicalMIMEHeaderKey",
-		"Conn",
-		"Dial",
-		"Error",
-		"MIMEHeader",
-		"NewConn",
-		"NewReader",
-		"NewWriter",
-		"Pipeline",
-		"ProtocolError",
-		"Reader",
-		"TrimBytes",
-		"TrimString",
-		"Writer",
-	},
-	"net/url": {
-		"Error",
-		"EscapeError",
-		"InvalidHostError",
-		"Parse",
-		"ParseQuery",
-		"ParseRequestURI",
-		"PathEscape",
-		"PathUnescape",
-		"QueryEscape",
-		"QueryUnescape",
-		"URL",
-		"User",
-		"UserPassword",
-		"Userinfo",
-		"Values",
-	},
-	"os": {
-		"Args",
-		"Chdir",
-		"Chmod",
-		"Chown",
-		"Chtimes",
-		"Clearenv",
-		"Create",
-		"DevNull",
-		"Environ",
-		"ErrClosed",
-		"ErrDeadlineExceeded",
-		"ErrExist",
-		"ErrInvalid",
-		"ErrNoDeadline",
-		"ErrNotExist",
-		"ErrPermission",
-		"Executable",
-		"Exit",
-		"Expand",
-		"ExpandEnv",
-		"File",
-		"FileInfo",
-		"FileMode",
-		"FindProcess",
-		"Getegid",
-		"Getenv",
-		"Geteuid",
-		"Getgid",
-		"Getgroups",
-		"Getpagesize",
-		"Getpid",
-		"Getppid",
-		"Getuid",
-		"Getwd",
-		"Hostname",
-		"Interrupt",
-		"IsExist",
-		"IsNotExist",
-		"IsPathSeparator",
-		"IsPermission",
-		"IsTimeout",
-		"Kill",
-		"Lchown",
-		"Link",
-		"LinkError",
-		"LookupEnv",
-		"Lstat",
-		"Mkdir",
-		"MkdirAll",
-		"ModeAppend",
-		"ModeCharDevice",
-		"ModeDevice",
-		"ModeDir",
-		"ModeExclusive",
-		"ModeIrregular",
-		"ModeNamedPipe",
-		"ModePerm",
-		"ModeSetgid",
-		"ModeSetuid",
-		"ModeSocket",
-		"ModeSticky",
-		"ModeSymlink",
-		"ModeTemporary",
-		"ModeType",
-		"NewFile",
-		"NewSyscallError",
-		"O_APPEND",
-		"O_CREATE",
-		"O_EXCL",
-		"O_RDONLY",
-		"O_RDWR",
-		"O_SYNC",
-		"O_TRUNC",
-		"O_WRONLY",
-		"Open",
-		"OpenFile",
-		"PathError",
-		"PathListSeparator",
-		"PathSeparator",
-		"Pipe",
-		"ProcAttr",
-		"Process",
-		"ProcessState",
-		"Readlink",
-		"Remove",
-		"RemoveAll",
-		"Rename",
-		"SEEK_CUR",
-		"SEEK_END",
-		"SEEK_SET",
-		"SameFile",
-		"Setenv",
-		"Signal",
-		"StartProcess",
-		"Stat",
-		"Stderr",
-		"Stdin",
-		"Stdout",
-		"Symlink",
-		"SyscallError",
-		"TempDir",
-		"Truncate",
-		"Unsetenv",
-		"UserCacheDir",
-		"UserConfigDir",
-		"UserHomeDir",
-	},
-	"os/exec": {
-		"Cmd",
-		"Command",
-		"CommandContext",
-		"ErrNotFound",
-		"Error",
-		"ExitError",
-		"LookPath",
-	},
-	"os/signal": {
-		"Ignore",
-		"Ignored",
-		"Notify",
-		"Reset",
-		"Stop",
-	},
-	"os/user": {
-		"Current",
-		"Group",
-		"Lookup",
-		"LookupGroup",
-		"LookupGroupId",
-		"LookupId",
-		"UnknownGroupError",
-		"UnknownGroupIdError",
-		"UnknownUserError",
-		"UnknownUserIdError",
-		"User",
-	},
-	"path": {
-		"Base",
-		"Clean",
-		"Dir",
-		"ErrBadPattern",
-		"Ext",
-		"IsAbs",
-		"Join",
-		"Match",
-		"Split",
-	},
-	"path/filepath": {
-		"Abs",
-		"Base",
-		"Clean",
-		"Dir",
-		"ErrBadPattern",
-		"EvalSymlinks",
-		"Ext",
-		"FromSlash",
-		"Glob",
-		"HasPrefix",
-		"IsAbs",
-		"Join",
-		"ListSeparator",
-		"Match",
-		"Rel",
-		"Separator",
-		"SkipDir",
-		"Split",
-		"SplitList",
-		"ToSlash",
-		"VolumeName",
-		"Walk",
-		"WalkFunc",
-	},
-	"plugin": {
-		"Open",
-		"Plugin",
-		"Symbol",
-	},
-	"reflect": {
-		"Append",
-		"AppendSlice",
-		"Array",
-		"ArrayOf",
-		"Bool",
-		"BothDir",
-		"Chan",
-		"ChanDir",
-		"ChanOf",
-		"Complex128",
-		"Complex64",
-		"Copy",
-		"DeepEqual",
-		"Float32",
-		"Float64",
-		"Func",
-		"FuncOf",
-		"Indirect",
-		"Int",
-		"Int16",
-		"Int32",
-		"Int64",
-		"Int8",
-		"Interface",
-		"Invalid",
-		"Kind",
-		"MakeChan",
-		"MakeFunc",
-		"MakeMap",
-		"MakeMapWithSize",
-		"MakeSlice",
-		"Map",
-		"MapIter",
-		"MapOf",
-		"Method",
-		"New",
-		"NewAt",
-		"Ptr",
-		"PtrTo",
-		"RecvDir",
-		"Select",
-		"SelectCase",
-		"SelectDefault",
-		"SelectDir",
-		"SelectRecv",
-		"SelectSend",
-		"SendDir",
-		"Slice",
-		"SliceHeader",
-		"SliceOf",
-		"String",
-		"StringHeader",
-		"Struct",
-		"StructField",
-		"StructOf",
-		"StructTag",
-		"Swapper",
-		"Type",
-		"TypeOf",
-		"Uint",
-		"Uint16",
-		"Uint32",
-		"Uint64",
-		"Uint8",
-		"Uintptr",
-		"UnsafePointer",
-		"Value",
-		"ValueError",
-		"ValueOf",
-		"Zero",
-	},
-	"regexp": {
-		"Compile",
-		"CompilePOSIX",
-		"Match",
-		"MatchReader",
-		"MatchString",
-		"MustCompile",
-		"MustCompilePOSIX",
-		"QuoteMeta",
-		"Regexp",
-	},
-	"regexp/syntax": {
-		"ClassNL",
-		"Compile",
-		"DotNL",
-		"EmptyBeginLine",
-		"EmptyBeginText",
-		"EmptyEndLine",
-		"EmptyEndText",
-		"EmptyNoWordBoundary",
-		"EmptyOp",
-		"EmptyOpContext",
-		"EmptyWordBoundary",
-		"ErrInternalError",
-		"ErrInvalidCharClass",
-		"ErrInvalidCharRange",
-		"ErrInvalidEscape",
-		"ErrInvalidNamedCapture",
-		"ErrInvalidPerlOp",
-		"ErrInvalidRepeatOp",
-		"ErrInvalidRepeatSize",
-		"ErrInvalidUTF8",
-		"ErrMissingBracket",
-		"ErrMissingParen",
-		"ErrMissingRepeatArgument",
-		"ErrTrailingBackslash",
-		"ErrUnexpectedParen",
-		"Error",
-		"ErrorCode",
-		"Flags",
-		"FoldCase",
-		"Inst",
-		"InstAlt",
-		"InstAltMatch",
-		"InstCapture",
-		"InstEmptyWidth",
-		"InstFail",
-		"InstMatch",
-		"InstNop",
-		"InstOp",
-		"InstRune",
-		"InstRune1",
-		"InstRuneAny",
-		"InstRuneAnyNotNL",
-		"IsWordChar",
-		"Literal",
-		"MatchNL",
-		"NonGreedy",
-		"OneLine",
-		"Op",
-		"OpAlternate",
-		"OpAnyChar",
-		"OpAnyCharNotNL",
-		"OpBeginLine",
-		"OpBeginText",
-		"OpCapture",
-		"OpCharClass",
-		"OpConcat",
-		"OpEmptyMatch",
-		"OpEndLine",
-		"OpEndText",
-		"OpLiteral",
-		"OpNoMatch",
-		"OpNoWordBoundary",
-		"OpPlus",
-		"OpQuest",
-		"OpRepeat",
-		"OpStar",
-		"OpWordBoundary",
-		"POSIX",
-		"Parse",
-		"Perl",
-		"PerlX",
-		"Prog",
-		"Regexp",
-		"Simple",
-		"UnicodeGroups",
-		"WasDollar",
-	},
-	"runtime": {
-		"BlockProfile",
-		"BlockProfileRecord",
-		"Breakpoint",
-		"CPUProfile",
-		"Caller",
-		"Callers",
-		"CallersFrames",
-		"Compiler",
-		"Error",
-		"Frame",
-		"Frames",
-		"Func",
-		"FuncForPC",
-		"GC",
-		"GOARCH",
-		"GOMAXPROCS",
-		"GOOS",
-		"GOROOT",
-		"Goexit",
-		"GoroutineProfile",
-		"Gosched",
-		"KeepAlive",
-		"LockOSThread",
-		"MemProfile",
-		"MemProfileRate",
-		"MemProfileRecord",
-		"MemStats",
-		"MutexProfile",
-		"NumCPU",
-		"NumCgoCall",
-		"NumGoroutine",
-		"ReadMemStats",
-		"ReadTrace",
-		"SetBlockProfileRate",
-		"SetCPUProfileRate",
-		"SetCgoTraceback",
-		"SetFinalizer",
-		"SetMutexProfileFraction",
-		"Stack",
-		"StackRecord",
-		"StartTrace",
-		"StopTrace",
-		"ThreadCreateProfile",
-		"TypeAssertionError",
-		"UnlockOSThread",
-		"Version",
-	},
-	"runtime/debug": {
-		"BuildInfo",
-		"FreeOSMemory",
-		"GCStats",
-		"Module",
-		"PrintStack",
-		"ReadBuildInfo",
-		"ReadGCStats",
-		"SetGCPercent",
-		"SetMaxStack",
-		"SetMaxThreads",
-		"SetPanicOnFault",
-		"SetTraceback",
-		"Stack",
-		"WriteHeapDump",
-	},
-	"runtime/pprof": {
-		"Do",
-		"ForLabels",
-		"Label",
-		"LabelSet",
-		"Labels",
-		"Lookup",
-		"NewProfile",
-		"Profile",
-		"Profiles",
-		"SetGoroutineLabels",
-		"StartCPUProfile",
-		"StopCPUProfile",
-		"WithLabels",
-		"WriteHeapProfile",
-	},
-	"runtime/trace": {
-		"IsEnabled",
-		"Log",
-		"Logf",
-		"NewTask",
-		"Region",
-		"Start",
-		"StartRegion",
-		"Stop",
-		"Task",
-		"WithRegion",
-	},
-	"sort": {
-		"Float64Slice",
-		"Float64s",
-		"Float64sAreSorted",
-		"IntSlice",
-		"Interface",
-		"Ints",
-		"IntsAreSorted",
-		"IsSorted",
-		"Reverse",
-		"Search",
-		"SearchFloat64s",
-		"SearchInts",
-		"SearchStrings",
-		"Slice",
-		"SliceIsSorted",
-		"SliceStable",
-		"Sort",
-		"Stable",
-		"StringSlice",
-		"Strings",
-		"StringsAreSorted",
-	},
-	"strconv": {
-		"AppendBool",
-		"AppendFloat",
-		"AppendInt",
-		"AppendQuote",
-		"AppendQuoteRune",
-		"AppendQuoteRuneToASCII",
-		"AppendQuoteRuneToGraphic",
-		"AppendQuoteToASCII",
-		"AppendQuoteToGraphic",
-		"AppendUint",
-		"Atoi",
-		"CanBackquote",
-		"ErrRange",
-		"ErrSyntax",
-		"FormatBool",
-		"FormatComplex",
-		"FormatFloat",
-		"FormatInt",
-		"FormatUint",
-		"IntSize",
-		"IsGraphic",
-		"IsPrint",
-		"Itoa",
-		"NumError",
-		"ParseBool",
-		"ParseComplex",
-		"ParseFloat",
-		"ParseInt",
-		"ParseUint",
-		"Quote",
-		"QuoteRune",
-		"QuoteRuneToASCII",
-		"QuoteRuneToGraphic",
-		"QuoteToASCII",
-		"QuoteToGraphic",
-		"Unquote",
-		"UnquoteChar",
-	},
-	"strings": {
-		"Builder",
-		"Compare",
-		"Contains",
-		"ContainsAny",
-		"ContainsRune",
-		"Count",
-		"EqualFold",
-		"Fields",
-		"FieldsFunc",
-		"HasPrefix",
-		"HasSuffix",
-		"Index",
-		"IndexAny",
-		"IndexByte",
-		"IndexFunc",
-		"IndexRune",
-		"Join",
-		"LastIndex",
-		"LastIndexAny",
-		"LastIndexByte",
-		"LastIndexFunc",
-		"Map",
-		"NewReader",
-		"NewReplacer",
-		"Reader",
-		"Repeat",
-		"Replace",
-		"ReplaceAll",
-		"Replacer",
-		"Split",
-		"SplitAfter",
-		"SplitAfterN",
-		"SplitN",
-		"Title",
-		"ToLower",
-		"ToLowerSpecial",
-		"ToTitle",
-		"ToTitleSpecial",
-		"ToUpper",
-		"ToUpperSpecial",
-		"ToValidUTF8",
-		"Trim",
-		"TrimFunc",
-		"TrimLeft",
-		"TrimLeftFunc",
-		"TrimPrefix",
-		"TrimRight",
-		"TrimRightFunc",
-		"TrimSpace",
-		"TrimSuffix",
-	},
-	"sync": {
-		"Cond",
-		"Locker",
-		"Map",
-		"Mutex",
-		"NewCond",
-		"Once",
-		"Pool",
-		"RWMutex",
-		"WaitGroup",
-	},
-	"sync/atomic": {
-		"AddInt32",
-		"AddInt64",
-		"AddUint32",
-		"AddUint64",
-		"AddUintptr",
-		"CompareAndSwapInt32",
-		"CompareAndSwapInt64",
-		"CompareAndSwapPointer",
-		"CompareAndSwapUint32",
-		"CompareAndSwapUint64",
-		"CompareAndSwapUintptr",
-		"LoadInt32",
-		"LoadInt64",
-		"LoadPointer",
-		"LoadUint32",
-		"LoadUint64",
-		"LoadUintptr",
-		"StoreInt32",
-		"StoreInt64",
-		"StorePointer",
-		"StoreUint32",
-		"StoreUint64",
-		"StoreUintptr",
-		"SwapInt32",
-		"SwapInt64",
-		"SwapPointer",
-		"SwapUint32",
-		"SwapUint64",
-		"SwapUintptr",
-		"Value",
-	},
-	"syscall": {
-		"AF_ALG",
-		"AF_APPLETALK",
-		"AF_ARP",
-		"AF_ASH",
-		"AF_ATM",
-		"AF_ATMPVC",
-		"AF_ATMSVC",
-		"AF_AX25",
-		"AF_BLUETOOTH",
-		"AF_BRIDGE",
-		"AF_CAIF",
-		"AF_CAN",
-		"AF_CCITT",
-		"AF_CHAOS",
-		"AF_CNT",
-		"AF_COIP",
-		"AF_DATAKIT",
-		"AF_DECnet",
-		"AF_DLI",
-		"AF_E164",
-		"AF_ECMA",
-		"AF_ECONET",
-		"AF_ENCAP",
-		"AF_FILE",
-		"AF_HYLINK",
-		"AF_IEEE80211",
-		"AF_IEEE802154",
-		"AF_IMPLINK",
-		"AF_INET",
-		"AF_INET6",
-		"AF_INET6_SDP",
-		"AF_INET_SDP",
-		"AF_IPX",
-		"AF_IRDA",
-		"AF_ISDN",
-		"AF_ISO",
-		"AF_IUCV",
-		"AF_KEY",
-		"AF_LAT",
-		"AF_LINK",
-		"AF_LLC",
-		"AF_LOCAL",
-		"AF_MAX",
-		"AF_MPLS",
-		"AF_NATM",
-		"AF_NDRV",
-		"AF_NETBEUI",
-		"AF_NETBIOS",
-		"AF_NETGRAPH",
-		"AF_NETLINK",
-		"AF_NETROM",
-		"AF_NS",
-		"AF_OROUTE",
-		"AF_OSI",
-		"AF_PACKET",
-		"AF_PHONET",
-		"AF_PPP",
-		"AF_PPPOX",
-		"AF_PUP",
-		"AF_RDS",
-		"AF_RESERVED_36",
-		"AF_ROSE",
-		"AF_ROUTE",
-		"AF_RXRPC",
-		"AF_SCLUSTER",
-		"AF_SECURITY",
-		"AF_SIP",
-		"AF_SLOW",
-		"AF_SNA",
-		"AF_SYSTEM",
-		"AF_TIPC",
-		"AF_UNIX",
-		"AF_UNSPEC",
-		"AF_VENDOR00",
-		"AF_VENDOR01",
-		"AF_VENDOR02",
-		"AF_VENDOR03",
-		"AF_VENDOR04",
-		"AF_VENDOR05",
-		"AF_VENDOR06",
-		"AF_VENDOR07",
-		"AF_VENDOR08",
-		"AF_VENDOR09",
-		"AF_VENDOR10",
-		"AF_VENDOR11",
-		"AF_VENDOR12",
-		"AF_VENDOR13",
-		"AF_VENDOR14",
-		"AF_VENDOR15",
-		"AF_VENDOR16",
-		"AF_VENDOR17",
-		"AF_VENDOR18",
-		"AF_VENDOR19",
-		"AF_VENDOR20",
-		"AF_VENDOR21",
-		"AF_VENDOR22",
-		"AF_VENDOR23",
-		"AF_VENDOR24",
-		"AF_VENDOR25",
-		"AF_VENDOR26",
-		"AF_VENDOR27",
-		"AF_VENDOR28",
-		"AF_VENDOR29",
-		"AF_VENDOR30",
-		"AF_VENDOR31",
-		"AF_VENDOR32",
-		"AF_VENDOR33",
-		"AF_VENDOR34",
-		"AF_VENDOR35",
-		"AF_VENDOR36",
-		"AF_VENDOR37",
-		"AF_VENDOR38",
-		"AF_VENDOR39",
-		"AF_VENDOR40",
-		"AF_VENDOR41",
-		"AF_VENDOR42",
-		"AF_VENDOR43",
-		"AF_VENDOR44",
-		"AF_VENDOR45",
-		"AF_VENDOR46",
-		"AF_VENDOR47",
-		"AF_WANPIPE",
-		"AF_X25",
-		"AI_CANONNAME",
-		"AI_NUMERICHOST",
-		"AI_PASSIVE",
-		"APPLICATION_ERROR",
-		"ARPHRD_ADAPT",
-		"ARPHRD_APPLETLK",
-		"ARPHRD_ARCNET",
-		"ARPHRD_ASH",
-		"ARPHRD_ATM",
-		"ARPHRD_AX25",
-		"ARPHRD_BIF",
-		"ARPHRD_CHAOS",
-		"ARPHRD_CISCO",
-		"ARPHRD_CSLIP",
-		"ARPHRD_CSLIP6",
-		"ARPHRD_DDCMP",
-		"ARPHRD_DLCI",
-		"ARPHRD_ECONET",
-		"ARPHRD_EETHER",
-		"ARPHRD_ETHER",
-		"ARPHRD_EUI64",
-		"ARPHRD_FCAL",
-		"ARPHRD_FCFABRIC",
-		"ARPHRD_FCPL",
-		"ARPHRD_FCPP",
-		"ARPHRD_FDDI",
-		"ARPHRD_FRAD",
-		"ARPHRD_FRELAY",
-		"ARPHRD_HDLC",
-		"ARPHRD_HIPPI",
-		"ARPHRD_HWX25",
-		"ARPHRD_IEEE1394",
-		"ARPHRD_IEEE802",
-		"ARPHRD_IEEE80211",
-		"ARPHRD_IEEE80211_PRISM",
-		"ARPHRD_IEEE80211_RADIOTAP",
-		"ARPHRD_IEEE802154",
-		"ARPHRD_IEEE802154_PHY",
-		"ARPHRD_IEEE802_TR",
-		"ARPHRD_INFINIBAND",
-		"ARPHRD_IPDDP",
-		"ARPHRD_IPGRE",
-		"ARPHRD_IRDA",
-		"ARPHRD_LAPB",
-		"ARPHRD_LOCALTLK",
-		"ARPHRD_LOOPBACK",
-		"ARPHRD_METRICOM",
-		"ARPHRD_NETROM",
-		"ARPHRD_NONE",
-		"ARPHRD_PIMREG",
-		"ARPHRD_PPP",
-		"ARPHRD_PRONET",
-		"ARPHRD_RAWHDLC",
-		"ARPHRD_ROSE",
-		"ARPHRD_RSRVD",
-		"ARPHRD_SIT",
-		"ARPHRD_SKIP",
-		"ARPHRD_SLIP",
-		"ARPHRD_SLIP6",
-		"ARPHRD_STRIP",
-		"ARPHRD_TUNNEL",
-		"ARPHRD_TUNNEL6",
-		"ARPHRD_VOID",
-		"ARPHRD_X25",
-		"AUTHTYPE_CLIENT",
-		"AUTHTYPE_SERVER",
-		"Accept",
-		"Accept4",
-		"AcceptEx",
-		"Access",
-		"Acct",
-		"AddrinfoW",
-		"Adjtime",
-		"Adjtimex",
-		"AttachLsf",
-		"B0",
-		"B1000000",
-		"B110",
-		"B115200",
-		"B1152000",
-		"B1200",
-		"B134",
-		"B14400",
-		"B150",
-		"B1500000",
-		"B1800",
-		"B19200",
-		"B200",
-		"B2000000",
-		"B230400",
-		"B2400",
-		"B2500000",
-		"B28800",
-		"B300",
-		"B3000000",
-		"B3500000",
-		"B38400",
-		"B4000000",
-		"B460800",
-		"B4800",
-		"B50",
-		"B500000",
-		"B57600",
-		"B576000",
-		"B600",
-		"B7200",
-		"B75",
-		"B76800",
-		"B921600",
-		"B9600",
-		"BASE_PROTOCOL",
-		"BIOCFEEDBACK",
-		"BIOCFLUSH",
-		"BIOCGBLEN",
-		"BIOCGDIRECTION",
-		"BIOCGDIRFILT",
-		"BIOCGDLT",
-		"BIOCGDLTLIST",
-		"BIOCGETBUFMODE",
-		"BIOCGETIF",
-		"BIOCGETZMAX",
-		"BIOCGFEEDBACK",
-		"BIOCGFILDROP",
-		"BIOCGHDRCMPLT",
-		"BIOCGRSIG",
-		"BIOCGRTIMEOUT",
-		"BIOCGSEESENT",
-		"BIOCGSTATS",
-		"BIOCGSTATSOLD",
-		"BIOCGTSTAMP",
-		"BIOCIMMEDIATE",
-		"BIOCLOCK",
-		"BIOCPROMISC",
-		"BIOCROTZBUF",
-		"BIOCSBLEN",
-		"BIOCSDIRECTION",
-		"BIOCSDIRFILT",
-		"BIOCSDLT",
-		"BIOCSETBUFMODE",
-		"BIOCSETF",
-		"BIOCSETFNR",
-		"BIOCSETIF",
-		"BIOCSETWF",
-		"BIOCSETZBUF",
-		"BIOCSFEEDBACK",
-		"BIOCSFILDROP",
-		"BIOCSHDRCMPLT",
-		"BIOCSRSIG",
-		"BIOCSRTIMEOUT",
-		"BIOCSSEESENT",
-		"BIOCSTCPF",
-		"BIOCSTSTAMP",
-		"BIOCSUDPF",
-		"BIOCVERSION",
-		"BPF_A",
-		"BPF_ABS",
-		"BPF_ADD",
-		"BPF_ALIGNMENT",
-		"BPF_ALIGNMENT32",
-		"BPF_ALU",
-		"BPF_AND",
-		"BPF_B",
-		"BPF_BUFMODE_BUFFER",
-		"BPF_BUFMODE_ZBUF",
-		"BPF_DFLTBUFSIZE",
-		"BPF_DIRECTION_IN",
-		"BPF_DIRECTION_OUT",
-		"BPF_DIV",
-		"BPF_H",
-		"BPF_IMM",
-		"BPF_IND",
-		"BPF_JA",
-		"BPF_JEQ",
-		"BPF_JGE",
-		"BPF_JGT",
-		"BPF_JMP",
-		"BPF_JSET",
-		"BPF_K",
-		"BPF_LD",
-		"BPF_LDX",
-		"BPF_LEN",
-		"BPF_LSH",
-		"BPF_MAJOR_VERSION",
-		"BPF_MAXBUFSIZE",
-		"BPF_MAXINSNS",
-		"BPF_MEM",
-		"BPF_MEMWORDS",
-		"BPF_MINBUFSIZE",
-		"BPF_MINOR_VERSION",
-		"BPF_MISC",
-		"BPF_MSH",
-		"BPF_MUL",
-		"BPF_NEG",
-		"BPF_OR",
-		"BPF_RELEASE",
-		"BPF_RET",
-		"BPF_RSH",
-		"BPF_ST",
-		"BPF_STX",
-		"BPF_SUB",
-		"BPF_TAX",
-		"BPF_TXA",
-		"BPF_T_BINTIME",
-		"BPF_T_BINTIME_FAST",
-		"BPF_T_BINTIME_MONOTONIC",
-		"BPF_T_BINTIME_MONOTONIC_FAST",
-		"BPF_T_FAST",
-		"BPF_T_FLAG_MASK",
-		"BPF_T_FORMAT_MASK",
-		"BPF_T_MICROTIME",
-		"BPF_T_MICROTIME_FAST",
-		"BPF_T_MICROTIME_MONOTONIC",
-		"BPF_T_MICROTIME_MONOTONIC_FAST",
-		"BPF_T_MONOTONIC",
-		"BPF_T_MONOTONIC_FAST",
-		"BPF_T_NANOTIME",
-		"BPF_T_NANOTIME_FAST",
-		"BPF_T_NANOTIME_MONOTONIC",
-		"BPF_T_NANOTIME_MONOTONIC_FAST",
-		"BPF_T_NONE",
-		"BPF_T_NORMAL",
-		"BPF_W",
-		"BPF_X",
-		"BRKINT",
-		"Bind",
-		"BindToDevice",
-		"BpfBuflen",
-		"BpfDatalink",
-		"BpfHdr",
-		"BpfHeadercmpl",
-		"BpfInsn",
-		"BpfInterface",
-		"BpfJump",
-		"BpfProgram",
-		"BpfStat",
-		"BpfStats",
-		"BpfStmt",
-		"BpfTimeout",
-		"BpfTimeval",
-		"BpfVersion",
-		"BpfZbuf",
-		"BpfZbufHeader",
-		"ByHandleFileInformation",
-		"BytePtrFromString",
-		"ByteSliceFromString",
-		"CCR0_FLUSH",
-		"CERT_CHAIN_POLICY_AUTHENTICODE",
-		"CERT_CHAIN_POLICY_AUTHENTICODE_TS",
-		"CERT_CHAIN_POLICY_BASE",
-		"CERT_CHAIN_POLICY_BASIC_CONSTRAINTS",
-		"CERT_CHAIN_POLICY_EV",
-		"CERT_CHAIN_POLICY_MICROSOFT_ROOT",
-		"CERT_CHAIN_POLICY_NT_AUTH",
-		"CERT_CHAIN_POLICY_SSL",
-		"CERT_E_CN_NO_MATCH",
-		"CERT_E_EXPIRED",
-		"CERT_E_PURPOSE",
-		"CERT_E_ROLE",
-		"CERT_E_UNTRUSTEDROOT",
-		"CERT_STORE_ADD_ALWAYS",
-		"CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG",
-		"CERT_STORE_PROV_MEMORY",
-		"CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT",
-		"CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT",
-		"CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT",
-		"CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT",
-		"CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT",
-		"CERT_TRUST_INVALID_BASIC_CONSTRAINTS",
-		"CERT_TRUST_INVALID_EXTENSION",
-		"CERT_TRUST_INVALID_NAME_CONSTRAINTS",
-		"CERT_TRUST_INVALID_POLICY_CONSTRAINTS",
-		"CERT_TRUST_IS_CYCLIC",
-		"CERT_TRUST_IS_EXPLICIT_DISTRUST",
-		"CERT_TRUST_IS_NOT_SIGNATURE_VALID",
-		"CERT_TRUST_IS_NOT_TIME_VALID",
-		"CERT_TRUST_IS_NOT_VALID_FOR_USAGE",
-		"CERT_TRUST_IS_OFFLINE_REVOCATION",
-		"CERT_TRUST_IS_REVOKED",
-		"CERT_TRUST_IS_UNTRUSTED_ROOT",
-		"CERT_TRUST_NO_ERROR",
-		"CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY",
-		"CERT_TRUST_REVOCATION_STATUS_UNKNOWN",
-		"CFLUSH",
-		"CLOCAL",
-		"CLONE_CHILD_CLEARTID",
-		"CLONE_CHILD_SETTID",
-		"CLONE_CSIGNAL",
-		"CLONE_DETACHED",
-		"CLONE_FILES",
-		"CLONE_FS",
-		"CLONE_IO",
-		"CLONE_NEWIPC",
-		"CLONE_NEWNET",
-		"CLONE_NEWNS",
-		"CLONE_NEWPID",
-		"CLONE_NEWUSER",
-		"CLONE_NEWUTS",
-		"CLONE_PARENT",
-		"CLONE_PARENT_SETTID",
-		"CLONE_PID",
-		"CLONE_PTRACE",
-		"CLONE_SETTLS",
-		"CLONE_SIGHAND",
-		"CLONE_SYSVSEM",
-		"CLONE_THREAD",
-		"CLONE_UNTRACED",
-		"CLONE_VFORK",
-		"CLONE_VM",
-		"CPUID_CFLUSH",
-		"CREAD",
-		"CREATE_ALWAYS",
-		"CREATE_NEW",
-		"CREATE_NEW_PROCESS_GROUP",
-		"CREATE_UNICODE_ENVIRONMENT",
-		"CRYPT_DEFAULT_CONTAINER_OPTIONAL",
-		"CRYPT_DELETEKEYSET",
-		"CRYPT_MACHINE_KEYSET",
-		"CRYPT_NEWKEYSET",
-		"CRYPT_SILENT",
-		"CRYPT_VERIFYCONTEXT",
-		"CS5",
-		"CS6",
-		"CS7",
-		"CS8",
-		"CSIZE",
-		"CSTART",
-		"CSTATUS",
-		"CSTOP",
-		"CSTOPB",
-		"CSUSP",
-		"CTL_MAXNAME",
-		"CTL_NET",
-		"CTL_QUERY",
-		"CTRL_BREAK_EVENT",
-		"CTRL_CLOSE_EVENT",
-		"CTRL_C_EVENT",
-		"CTRL_LOGOFF_EVENT",
-		"CTRL_SHUTDOWN_EVENT",
-		"CancelIo",
-		"CancelIoEx",
-		"CertAddCertificateContextToStore",
-		"CertChainContext",
-		"CertChainElement",
-		"CertChainPara",
-		"CertChainPolicyPara",
-		"CertChainPolicyStatus",
-		"CertCloseStore",
-		"CertContext",
-		"CertCreateCertificateContext",
-		"CertEnhKeyUsage",
-		"CertEnumCertificatesInStore",
-		"CertFreeCertificateChain",
-		"CertFreeCertificateContext",
-		"CertGetCertificateChain",
-		"CertInfo",
-		"CertOpenStore",
-		"CertOpenSystemStore",
-		"CertRevocationCrlInfo",
-		"CertRevocationInfo",
-		"CertSimpleChain",
-		"CertTrustListInfo",
-		"CertTrustStatus",
-		"CertUsageMatch",
-		"CertVerifyCertificateChainPolicy",
-		"Chdir",
-		"CheckBpfVersion",
-		"Chflags",
-		"Chmod",
-		"Chown",
-		"Chroot",
-		"Clearenv",
-		"Close",
-		"CloseHandle",
-		"CloseOnExec",
-		"Closesocket",
-		"CmsgLen",
-		"CmsgSpace",
-		"Cmsghdr",
-		"CommandLineToArgv",
-		"ComputerName",
-		"Conn",
-		"Connect",
-		"ConnectEx",
-		"ConvertSidToStringSid",
-		"ConvertStringSidToSid",
-		"CopySid",
-		"Creat",
-		"CreateDirectory",
-		"CreateFile",
-		"CreateFileMapping",
-		"CreateHardLink",
-		"CreateIoCompletionPort",
-		"CreatePipe",
-		"CreateProcess",
-		"CreateProcessAsUser",
-		"CreateSymbolicLink",
-		"CreateToolhelp32Snapshot",
-		"Credential",
-		"CryptAcquireContext",
-		"CryptGenRandom",
-		"CryptReleaseContext",
-		"DIOCBSFLUSH",
-		"DIOCOSFPFLUSH",
-		"DLL",
-		"DLLError",
-		"DLT_A429",
-		"DLT_A653_ICM",
-		"DLT_AIRONET_HEADER",
-		"DLT_AOS",
-		"DLT_APPLE_IP_OVER_IEEE1394",
-		"DLT_ARCNET",
-		"DLT_ARCNET_LINUX",
-		"DLT_ATM_CLIP",
-		"DLT_ATM_RFC1483",
-		"DLT_AURORA",
-		"DLT_AX25",
-		"DLT_AX25_KISS",
-		"DLT_BACNET_MS_TP",
-		"DLT_BLUETOOTH_HCI_H4",
-		"DLT_BLUETOOTH_HCI_H4_WITH_PHDR",
-		"DLT_CAN20B",
-		"DLT_CAN_SOCKETCAN",
-		"DLT_CHAOS",
-		"DLT_CHDLC",
-		"DLT_CISCO_IOS",
-		"DLT_C_HDLC",
-		"DLT_C_HDLC_WITH_DIR",
-		"DLT_DBUS",
-		"DLT_DECT",
-		"DLT_DOCSIS",
-		"DLT_DVB_CI",
-		"DLT_ECONET",
-		"DLT_EN10MB",
-		"DLT_EN3MB",
-		"DLT_ENC",
-		"DLT_ERF",
-		"DLT_ERF_ETH",
-		"DLT_ERF_POS",
-		"DLT_FC_2",
-		"DLT_FC_2_WITH_FRAME_DELIMS",
-		"DLT_FDDI",
-		"DLT_FLEXRAY",
-		"DLT_FRELAY",
-		"DLT_FRELAY_WITH_DIR",
-		"DLT_GCOM_SERIAL",
-		"DLT_GCOM_T1E1",
-		"DLT_GPF_F",
-		"DLT_GPF_T",
-		"DLT_GPRS_LLC",
-		"DLT_GSMTAP_ABIS",
-		"DLT_GSMTAP_UM",
-		"DLT_HDLC",
-		"DLT_HHDLC",
-		"DLT_HIPPI",
-		"DLT_IBM_SN",
-		"DLT_IBM_SP",
-		"DLT_IEEE802",
-		"DLT_IEEE802_11",
-		"DLT_IEEE802_11_RADIO",
-		"DLT_IEEE802_11_RADIO_AVS",
-		"DLT_IEEE802_15_4",
-		"DLT_IEEE802_15_4_LINUX",
-		"DLT_IEEE802_15_4_NOFCS",
-		"DLT_IEEE802_15_4_NONASK_PHY",
-		"DLT_IEEE802_16_MAC_CPS",
-		"DLT_IEEE802_16_MAC_CPS_RADIO",
-		"DLT_IPFILTER",
-		"DLT_IPMB",
-		"DLT_IPMB_LINUX",
-		"DLT_IPNET",
-		"DLT_IPOIB",
-		"DLT_IPV4",
-		"DLT_IPV6",
-		"DLT_IP_OVER_FC",
-		"DLT_JUNIPER_ATM1",
-		"DLT_JUNIPER_ATM2",
-		"DLT_JUNIPER_ATM_CEMIC",
-		"DLT_JUNIPER_CHDLC",
-		"DLT_JUNIPER_ES",
-		"DLT_JUNIPER_ETHER",
-		"DLT_JUNIPER_FIBRECHANNEL",
-		"DLT_JUNIPER_FRELAY",
-		"DLT_JUNIPER_GGSN",
-		"DLT_JUNIPER_ISM",
-		"DLT_JUNIPER_MFR",
-		"DLT_JUNIPER_MLFR",
-		"DLT_JUNIPER_MLPPP",
-		"DLT_JUNIPER_MONITOR",
-		"DLT_JUNIPER_PIC_PEER",
-		"DLT_JUNIPER_PPP",
-		"DLT_JUNIPER_PPPOE",
-		"DLT_JUNIPER_PPPOE_ATM",
-		"DLT_JUNIPER_SERVICES",
-		"DLT_JUNIPER_SRX_E2E",
-		"DLT_JUNIPER_ST",
-		"DLT_JUNIPER_VP",
-		"DLT_JUNIPER_VS",
-		"DLT_LAPB_WITH_DIR",
-		"DLT_LAPD",
-		"DLT_LIN",
-		"DLT_LINUX_EVDEV",
-		"DLT_LINUX_IRDA",
-		"DLT_LINUX_LAPD",
-		"DLT_LINUX_PPP_WITHDIRECTION",
-		"DLT_LINUX_SLL",
-		"DLT_LOOP",
-		"DLT_LTALK",
-		"DLT_MATCHING_MAX",
-		"DLT_MATCHING_MIN",
-		"DLT_MFR",
-		"DLT_MOST",
-		"DLT_MPEG_2_TS",
-		"DLT_MPLS",
-		"DLT_MTP2",
-		"DLT_MTP2_WITH_PHDR",
-		"DLT_MTP3",
-		"DLT_MUX27010",
-		"DLT_NETANALYZER",
-		"DLT_NETANALYZER_TRANSPARENT",
-		"DLT_NFC_LLCP",
-		"DLT_NFLOG",
-		"DLT_NG40",
-		"DLT_NULL",
-		"DLT_PCI_EXP",
-		"DLT_PFLOG",
-		"DLT_PFSYNC",
-		"DLT_PPI",
-		"DLT_PPP",
-		"DLT_PPP_BSDOS",
-		"DLT_PPP_ETHER",
-		"DLT_PPP_PPPD",
-		"DLT_PPP_SERIAL",
-		"DLT_PPP_WITH_DIR",
-		"DLT_PPP_WITH_DIRECTION",
-		"DLT_PRISM_HEADER",
-		"DLT_PRONET",
-		"DLT_RAIF1",
-		"DLT_RAW",
-		"DLT_RAWAF_MASK",
-		"DLT_RIO",
-		"DLT_SCCP",
-		"DLT_SITA",
-		"DLT_SLIP",
-		"DLT_SLIP_BSDOS",
-		"DLT_STANAG_5066_D_PDU",
-		"DLT_SUNATM",
-		"DLT_SYMANTEC_FIREWALL",
-		"DLT_TZSP",
-		"DLT_USB",
-		"DLT_USB_LINUX",
-		"DLT_USB_LINUX_MMAPPED",
-		"DLT_USER0",
-		"DLT_USER1",
-		"DLT_USER10",
-		"DLT_USER11",
-		"DLT_USER12",
-		"DLT_USER13",
-		"DLT_USER14",
-		"DLT_USER15",
-		"DLT_USER2",
-		"DLT_USER3",
-		"DLT_USER4",
-		"DLT_USER5",
-		"DLT_USER6",
-		"DLT_USER7",
-		"DLT_USER8",
-		"DLT_USER9",
-		"DLT_WIHART",
-		"DLT_X2E_SERIAL",
-		"DLT_X2E_XORAYA",
-		"DNSMXData",
-		"DNSPTRData",
-		"DNSRecord",
-		"DNSSRVData",
-		"DNSTXTData",
-		"DNS_INFO_NO_RECORDS",
-		"DNS_TYPE_A",
-		"DNS_TYPE_A6",
-		"DNS_TYPE_AAAA",
-		"DNS_TYPE_ADDRS",
-		"DNS_TYPE_AFSDB",
-		"DNS_TYPE_ALL",
-		"DNS_TYPE_ANY",
-		"DNS_TYPE_ATMA",
-		"DNS_TYPE_AXFR",
-		"DNS_TYPE_CERT",
-		"DNS_TYPE_CNAME",
-		"DNS_TYPE_DHCID",
-		"DNS_TYPE_DNAME",
-		"DNS_TYPE_DNSKEY",
-		"DNS_TYPE_DS",
-		"DNS_TYPE_EID",
-		"DNS_TYPE_GID",
-		"DNS_TYPE_GPOS",
-		"DNS_TYPE_HINFO",
-		"DNS_TYPE_ISDN",
-		"DNS_TYPE_IXFR",
-		"DNS_TYPE_KEY",
-		"DNS_TYPE_KX",
-		"DNS_TYPE_LOC",
-		"DNS_TYPE_MAILA",
-		"DNS_TYPE_MAILB",
-		"DNS_TYPE_MB",
-		"DNS_TYPE_MD",
-		"DNS_TYPE_MF",
-		"DNS_TYPE_MG",
-		"DNS_TYPE_MINFO",
-		"DNS_TYPE_MR",
-		"DNS_TYPE_MX",
-		"DNS_TYPE_NAPTR",
-		"DNS_TYPE_NBSTAT",
-		"DNS_TYPE_NIMLOC",
-		"DNS_TYPE_NS",
-		"DNS_TYPE_NSAP",
-		"DNS_TYPE_NSAPPTR",
-		"DNS_TYPE_NSEC",
-		"DNS_TYPE_NULL",
-		"DNS_TYPE_NXT",
-		"DNS_TYPE_OPT",
-		"DNS_TYPE_PTR",
-		"DNS_TYPE_PX",
-		"DNS_TYPE_RP",
-		"DNS_TYPE_RRSIG",
-		"DNS_TYPE_RT",
-		"DNS_TYPE_SIG",
-		"DNS_TYPE_SINK",
-		"DNS_TYPE_SOA",
-		"DNS_TYPE_SRV",
-		"DNS_TYPE_TEXT",
-		"DNS_TYPE_TKEY",
-		"DNS_TYPE_TSIG",
-		"DNS_TYPE_UID",
-		"DNS_TYPE_UINFO",
-		"DNS_TYPE_UNSPEC",
-		"DNS_TYPE_WINS",
-		"DNS_TYPE_WINSR",
-		"DNS_TYPE_WKS",
-		"DNS_TYPE_X25",
-		"DT_BLK",
-		"DT_CHR",
-		"DT_DIR",
-		"DT_FIFO",
-		"DT_LNK",
-		"DT_REG",
-		"DT_SOCK",
-		"DT_UNKNOWN",
-		"DT_WHT",
-		"DUPLICATE_CLOSE_SOURCE",
-		"DUPLICATE_SAME_ACCESS",
-		"DeleteFile",
-		"DetachLsf",
-		"DeviceIoControl",
-		"Dirent",
-		"DnsNameCompare",
-		"DnsQuery",
-		"DnsRecordListFree",
-		"DnsSectionAdditional",
-		"DnsSectionAnswer",
-		"DnsSectionAuthority",
-		"DnsSectionQuestion",
-		"Dup",
-		"Dup2",
-		"Dup3",
-		"DuplicateHandle",
-		"E2BIG",
-		"EACCES",
-		"EADDRINUSE",
-		"EADDRNOTAVAIL",
-		"EADV",
-		"EAFNOSUPPORT",
-		"EAGAIN",
-		"EALREADY",
-		"EAUTH",
-		"EBADARCH",
-		"EBADE",
-		"EBADEXEC",
-		"EBADF",
-		"EBADFD",
-		"EBADMACHO",
-		"EBADMSG",
-		"EBADR",
-		"EBADRPC",
-		"EBADRQC",
-		"EBADSLT",
-		"EBFONT",
-		"EBUSY",
-		"ECANCELED",
-		"ECAPMODE",
-		"ECHILD",
-		"ECHO",
-		"ECHOCTL",
-		"ECHOE",
-		"ECHOK",
-		"ECHOKE",
-		"ECHONL",
-		"ECHOPRT",
-		"ECHRNG",
-		"ECOMM",
-		"ECONNABORTED",
-		"ECONNREFUSED",
-		"ECONNRESET",
-		"EDEADLK",
-		"EDEADLOCK",
-		"EDESTADDRREQ",
-		"EDEVERR",
-		"EDOM",
-		"EDOOFUS",
-		"EDOTDOT",
-		"EDQUOT",
-		"EEXIST",
-		"EFAULT",
-		"EFBIG",
-		"EFER_LMA",
-		"EFER_LME",
-		"EFER_NXE",
-		"EFER_SCE",
-		"EFTYPE",
-		"EHOSTDOWN",
-		"EHOSTUNREACH",
-		"EHWPOISON",
-		"EIDRM",
-		"EILSEQ",
-		"EINPROGRESS",
-		"EINTR",
-		"EINVAL",
-		"EIO",
-		"EIPSEC",
-		"EISCONN",
-		"EISDIR",
-		"EISNAM",
-		"EKEYEXPIRED",
-		"EKEYREJECTED",
-		"EKEYREVOKED",
-		"EL2HLT",
-		"EL2NSYNC",
-		"EL3HLT",
-		"EL3RST",
-		"ELAST",
-		"ELF_NGREG",
-		"ELF_PRARGSZ",
-		"ELIBACC",
-		"ELIBBAD",
-		"ELIBEXEC",
-		"ELIBMAX",
-		"ELIBSCN",
-		"ELNRNG",
-		"ELOOP",
-		"EMEDIUMTYPE",
-		"EMFILE",
-		"EMLINK",
-		"EMSGSIZE",
-		"EMT_TAGOVF",
-		"EMULTIHOP",
-		"EMUL_ENABLED",
-		"EMUL_LINUX",
-		"EMUL_LINUX32",
-		"EMUL_MAXID",
-		"EMUL_NATIVE",
-		"ENAMETOOLONG",
-		"ENAVAIL",
-		"ENDRUNDISC",
-		"ENEEDAUTH",
-		"ENETDOWN",
-		"ENETRESET",
-		"ENETUNREACH",
-		"ENFILE",
-		"ENOANO",
-		"ENOATTR",
-		"ENOBUFS",
-		"ENOCSI",
-		"ENODATA",
-		"ENODEV",
-		"ENOENT",
-		"ENOEXEC",
-		"ENOKEY",
-		"ENOLCK",
-		"ENOLINK",
-		"ENOMEDIUM",
-		"ENOMEM",
-		"ENOMSG",
-		"ENONET",
-		"ENOPKG",
-		"ENOPOLICY",
-		"ENOPROTOOPT",
-		"ENOSPC",
-		"ENOSR",
-		"ENOSTR",
-		"ENOSYS",
-		"ENOTBLK",
-		"ENOTCAPABLE",
-		"ENOTCONN",
-		"ENOTDIR",
-		"ENOTEMPTY",
-		"ENOTNAM",
-		"ENOTRECOVERABLE",
-		"ENOTSOCK",
-		"ENOTSUP",
-		"ENOTTY",
-		"ENOTUNIQ",
-		"ENXIO",
-		"EN_SW_CTL_INF",
-		"EN_SW_CTL_PREC",
-		"EN_SW_CTL_ROUND",
-		"EN_SW_DATACHAIN",
-		"EN_SW_DENORM",
-		"EN_SW_INVOP",
-		"EN_SW_OVERFLOW",
-		"EN_SW_PRECLOSS",
-		"EN_SW_UNDERFLOW",
-		"EN_SW_ZERODIV",
-		"EOPNOTSUPP",
-		"EOVERFLOW",
-		"EOWNERDEAD",
-		"EPERM",
-		"EPFNOSUPPORT",
-		"EPIPE",
-		"EPOLLERR",
-		"EPOLLET",
-		"EPOLLHUP",
-		"EPOLLIN",
-		"EPOLLMSG",
-		"EPOLLONESHOT",
-		"EPOLLOUT",
-		"EPOLLPRI",
-		"EPOLLRDBAND",
-		"EPOLLRDHUP",
-		"EPOLLRDNORM",
-		"EPOLLWRBAND",
-		"EPOLLWRNORM",
-		"EPOLL_CLOEXEC",
-		"EPOLL_CTL_ADD",
-		"EPOLL_CTL_DEL",
-		"EPOLL_CTL_MOD",
-		"EPOLL_NONBLOCK",
-		"EPROCLIM",
-		"EPROCUNAVAIL",
-		"EPROGMISMATCH",
-		"EPROGUNAVAIL",
-		"EPROTO",
-		"EPROTONOSUPPORT",
-		"EPROTOTYPE",
-		"EPWROFF",
-		"ERANGE",
-		"EREMCHG",
-		"EREMOTE",
-		"EREMOTEIO",
-		"ERESTART",
-		"ERFKILL",
-		"EROFS",
-		"ERPCMISMATCH",
-		"ERROR_ACCESS_DENIED",
-		"ERROR_ALREADY_EXISTS",
-		"ERROR_BROKEN_PIPE",
-		"ERROR_BUFFER_OVERFLOW",
-		"ERROR_DIR_NOT_EMPTY",
-		"ERROR_ENVVAR_NOT_FOUND",
-		"ERROR_FILE_EXISTS",
-		"ERROR_FILE_NOT_FOUND",
-		"ERROR_HANDLE_EOF",
-		"ERROR_INSUFFICIENT_BUFFER",
-		"ERROR_IO_PENDING",
-		"ERROR_MOD_NOT_FOUND",
-		"ERROR_MORE_DATA",
-		"ERROR_NETNAME_DELETED",
-		"ERROR_NOT_FOUND",
-		"ERROR_NO_MORE_FILES",
-		"ERROR_OPERATION_ABORTED",
-		"ERROR_PATH_NOT_FOUND",
-		"ERROR_PRIVILEGE_NOT_HELD",
-		"ERROR_PROC_NOT_FOUND",
-		"ESHLIBVERS",
-		"ESHUTDOWN",
-		"ESOCKTNOSUPPORT",
-		"ESPIPE",
-		"ESRCH",
-		"ESRMNT",
-		"ESTALE",
-		"ESTRPIPE",
-		"ETHERCAP_JUMBO_MTU",
-		"ETHERCAP_VLAN_HWTAGGING",
-		"ETHERCAP_VLAN_MTU",
-		"ETHERMIN",
-		"ETHERMTU",
-		"ETHERMTU_JUMBO",
-		"ETHERTYPE_8023",
-		"ETHERTYPE_AARP",
-		"ETHERTYPE_ACCTON",
-		"ETHERTYPE_AEONIC",
-		"ETHERTYPE_ALPHA",
-		"ETHERTYPE_AMBER",
-		"ETHERTYPE_AMOEBA",
-		"ETHERTYPE_AOE",
-		"ETHERTYPE_APOLLO",
-		"ETHERTYPE_APOLLODOMAIN",
-		"ETHERTYPE_APPLETALK",
-		"ETHERTYPE_APPLITEK",
-		"ETHERTYPE_ARGONAUT",
-		"ETHERTYPE_ARP",
-		"ETHERTYPE_AT",
-		"ETHERTYPE_ATALK",
-		"ETHERTYPE_ATOMIC",
-		"ETHERTYPE_ATT",
-		"ETHERTYPE_ATTSTANFORD",
-		"ETHERTYPE_AUTOPHON",
-		"ETHERTYPE_AXIS",
-		"ETHERTYPE_BCLOOP",
-		"ETHERTYPE_BOFL",
-		"ETHERTYPE_CABLETRON",
-		"ETHERTYPE_CHAOS",
-		"ETHERTYPE_COMDESIGN",
-		"ETHERTYPE_COMPUGRAPHIC",
-		"ETHERTYPE_COUNTERPOINT",
-		"ETHERTYPE_CRONUS",
-		"ETHERTYPE_CRONUSVLN",
-		"ETHERTYPE_DCA",
-		"ETHERTYPE_DDE",
-		"ETHERTYPE_DEBNI",
-		"ETHERTYPE_DECAM",
-		"ETHERTYPE_DECCUST",
-		"ETHERTYPE_DECDIAG",
-		"ETHERTYPE_DECDNS",
-		"ETHERTYPE_DECDTS",
-		"ETHERTYPE_DECEXPER",
-		"ETHERTYPE_DECLAST",
-		"ETHERTYPE_DECLTM",
-		"ETHERTYPE_DECMUMPS",
-		"ETHERTYPE_DECNETBIOS",
-		"ETHERTYPE_DELTACON",
-		"ETHERTYPE_DIDDLE",
-		"ETHERTYPE_DLOG1",
-		"ETHERTYPE_DLOG2",
-		"ETHERTYPE_DN",
-		"ETHERTYPE_DOGFIGHT",
-		"ETHERTYPE_DSMD",
-		"ETHERTYPE_ECMA",
-		"ETHERTYPE_ENCRYPT",
-		"ETHERTYPE_ES",
-		"ETHERTYPE_EXCELAN",
-		"ETHERTYPE_EXPERDATA",
-		"ETHERTYPE_FLIP",
-		"ETHERTYPE_FLOWCONTROL",
-		"ETHERTYPE_FRARP",
-		"ETHERTYPE_GENDYN",
-		"ETHERTYPE_HAYES",
-		"ETHERTYPE_HIPPI_FP",
-		"ETHERTYPE_HITACHI",
-		"ETHERTYPE_HP",
-		"ETHERTYPE_IEEEPUP",
-		"ETHERTYPE_IEEEPUPAT",
-		"ETHERTYPE_IMLBL",
-		"ETHERTYPE_IMLBLDIAG",
-		"ETHERTYPE_IP",
-		"ETHERTYPE_IPAS",
-		"ETHERTYPE_IPV6",
-		"ETHERTYPE_IPX",
-		"ETHERTYPE_IPXNEW",
-		"ETHERTYPE_KALPANA",
-		"ETHERTYPE_LANBRIDGE",
-		"ETHERTYPE_LANPROBE",
-		"ETHERTYPE_LAT",
-		"ETHERTYPE_LBACK",
-		"ETHERTYPE_LITTLE",
-		"ETHERTYPE_LLDP",
-		"ETHERTYPE_LOGICRAFT",
-		"ETHERTYPE_LOOPBACK",
-		"ETHERTYPE_MATRA",
-		"ETHERTYPE_MAX",
-		"ETHERTYPE_MERIT",
-		"ETHERTYPE_MICP",
-		"ETHERTYPE_MOPDL",
-		"ETHERTYPE_MOPRC",
-		"ETHERTYPE_MOTOROLA",
-		"ETHERTYPE_MPLS",
-		"ETHERTYPE_MPLS_MCAST",
-		"ETHERTYPE_MUMPS",
-		"ETHERTYPE_NBPCC",
-		"ETHERTYPE_NBPCLAIM",
-		"ETHERTYPE_NBPCLREQ",
-		"ETHERTYPE_NBPCLRSP",
-		"ETHERTYPE_NBPCREQ",
-		"ETHERTYPE_NBPCRSP",
-		"ETHERTYPE_NBPDG",
-		"ETHERTYPE_NBPDGB",
-		"ETHERTYPE_NBPDLTE",
-		"ETHERTYPE_NBPRAR",
-		"ETHERTYPE_NBPRAS",
-		"ETHERTYPE_NBPRST",
-		"ETHERTYPE_NBPSCD",
-		"ETHERTYPE_NBPVCD",
-		"ETHERTYPE_NBS",
-		"ETHERTYPE_NCD",
-		"ETHERTYPE_NESTAR",
-		"ETHERTYPE_NETBEUI",
-		"ETHERTYPE_NOVELL",
-		"ETHERTYPE_NS",
-		"ETHERTYPE_NSAT",
-		"ETHERTYPE_NSCOMPAT",
-		"ETHERTYPE_NTRAILER",
-		"ETHERTYPE_OS9",
-		"ETHERTYPE_OS9NET",
-		"ETHERTYPE_PACER",
-		"ETHERTYPE_PAE",
-		"ETHERTYPE_PCS",
-		"ETHERTYPE_PLANNING",
-		"ETHERTYPE_PPP",
-		"ETHERTYPE_PPPOE",
-		"ETHERTYPE_PPPOEDISC",
-		"ETHERTYPE_PRIMENTS",
-		"ETHERTYPE_PUP",
-		"ETHERTYPE_PUPAT",
-		"ETHERTYPE_QINQ",
-		"ETHERTYPE_RACAL",
-		"ETHERTYPE_RATIONAL",
-		"ETHERTYPE_RAWFR",
-		"ETHERTYPE_RCL",
-		"ETHERTYPE_RDP",
-		"ETHERTYPE_RETIX",
-		"ETHERTYPE_REVARP",
-		"ETHERTYPE_SCA",
-		"ETHERTYPE_SECTRA",
-		"ETHERTYPE_SECUREDATA",
-		"ETHERTYPE_SGITW",
-		"ETHERTYPE_SG_BOUNCE",
-		"ETHERTYPE_SG_DIAG",
-		"ETHERTYPE_SG_NETGAMES",
-		"ETHERTYPE_SG_RESV",
-		"ETHERTYPE_SIMNET",
-		"ETHERTYPE_SLOW",
-		"ETHERTYPE_SLOWPROTOCOLS",
-		"ETHERTYPE_SNA",
-		"ETHERTYPE_SNMP",
-		"ETHERTYPE_SONIX",
-		"ETHERTYPE_SPIDER",
-		"ETHERTYPE_SPRITE",
-		"ETHERTYPE_STP",
-		"ETHERTYPE_TALARIS",
-		"ETHERTYPE_TALARISMC",
-		"ETHERTYPE_TCPCOMP",
-		"ETHERTYPE_TCPSM",
-		"ETHERTYPE_TEC",
-		"ETHERTYPE_TIGAN",
-		"ETHERTYPE_TRAIL",
-		"ETHERTYPE_TRANSETHER",
-		"ETHERTYPE_TYMSHARE",
-		"ETHERTYPE_UBBST",
-		"ETHERTYPE_UBDEBUG",
-		"ETHERTYPE_UBDIAGLOOP",
-		"ETHERTYPE_UBDL",
-		"ETHERTYPE_UBNIU",
-		"ETHERTYPE_UBNMC",
-		"ETHERTYPE_VALID",
-		"ETHERTYPE_VARIAN",
-		"ETHERTYPE_VAXELN",
-		"ETHERTYPE_VEECO",
-		"ETHERTYPE_VEXP",
-		"ETHERTYPE_VGLAB",
-		"ETHERTYPE_VINES",
-		"ETHERTYPE_VINESECHO",
-		"ETHERTYPE_VINESLOOP",
-		"ETHERTYPE_VITAL",
-		"ETHERTYPE_VLAN",
-		"ETHERTYPE_VLTLMAN",
-		"ETHERTYPE_VPROD",
-		"ETHERTYPE_VURESERVED",
-		"ETHERTYPE_WATERLOO",
-		"ETHERTYPE_WELLFLEET",
-		"ETHERTYPE_X25",
-		"ETHERTYPE_X75",
-		"ETHERTYPE_XNSSM",
-		"ETHERTYPE_XTP",
-		"ETHER_ADDR_LEN",
-		"ETHER_ALIGN",
-		"ETHER_CRC_LEN",
-		"ETHER_CRC_POLY_BE",
-		"ETHER_CRC_POLY_LE",
-		"ETHER_HDR_LEN",
-		"ETHER_MAX_DIX_LEN",
-		"ETHER_MAX_LEN",
-		"ETHER_MAX_LEN_JUMBO",
-		"ETHER_MIN_LEN",
-		"ETHER_PPPOE_ENCAP_LEN",
-		"ETHER_TYPE_LEN",
-		"ETHER_VLAN_ENCAP_LEN",
-		"ETH_P_1588",
-		"ETH_P_8021Q",
-		"ETH_P_802_2",
-		"ETH_P_802_3",
-		"ETH_P_AARP",
-		"ETH_P_ALL",
-		"ETH_P_AOE",
-		"ETH_P_ARCNET",
-		"ETH_P_ARP",
-		"ETH_P_ATALK",
-		"ETH_P_ATMFATE",
-		"ETH_P_ATMMPOA",
-		"ETH_P_AX25",
-		"ETH_P_BPQ",
-		"ETH_P_CAIF",
-		"ETH_P_CAN",
-		"ETH_P_CONTROL",
-		"ETH_P_CUST",
-		"ETH_P_DDCMP",
-		"ETH_P_DEC",
-		"ETH_P_DIAG",
-		"ETH_P_DNA_DL",
-		"ETH_P_DNA_RC",
-		"ETH_P_DNA_RT",
-		"ETH_P_DSA",
-		"ETH_P_ECONET",
-		"ETH_P_EDSA",
-		"ETH_P_FCOE",
-		"ETH_P_FIP",
-		"ETH_P_HDLC",
-		"ETH_P_IEEE802154",
-		"ETH_P_IEEEPUP",
-		"ETH_P_IEEEPUPAT",
-		"ETH_P_IP",
-		"ETH_P_IPV6",
-		"ETH_P_IPX",
-		"ETH_P_IRDA",
-		"ETH_P_LAT",
-		"ETH_P_LINK_CTL",
-		"ETH_P_LOCALTALK",
-		"ETH_P_LOOP",
-		"ETH_P_MOBITEX",
-		"ETH_P_MPLS_MC",
-		"ETH_P_MPLS_UC",
-		"ETH_P_PAE",
-		"ETH_P_PAUSE",
-		"ETH_P_PHONET",
-		"ETH_P_PPPTALK",
-		"ETH_P_PPP_DISC",
-		"ETH_P_PPP_MP",
-		"ETH_P_PPP_SES",
-		"ETH_P_PUP",
-		"ETH_P_PUPAT",
-		"ETH_P_RARP",
-		"ETH_P_SCA",
-		"ETH_P_SLOW",
-		"ETH_P_SNAP",
-		"ETH_P_TEB",
-		"ETH_P_TIPC",
-		"ETH_P_TRAILER",
-		"ETH_P_TR_802_2",
-		"ETH_P_WAN_PPP",
-		"ETH_P_WCCP",
-		"ETH_P_X25",
-		"ETIME",
-		"ETIMEDOUT",
-		"ETOOMANYREFS",
-		"ETXTBSY",
-		"EUCLEAN",
-		"EUNATCH",
-		"EUSERS",
-		"EVFILT_AIO",
-		"EVFILT_FS",
-		"EVFILT_LIO",
-		"EVFILT_MACHPORT",
-		"EVFILT_PROC",
-		"EVFILT_READ",
-		"EVFILT_SIGNAL",
-		"EVFILT_SYSCOUNT",
-		"EVFILT_THREADMARKER",
-		"EVFILT_TIMER",
-		"EVFILT_USER",
-		"EVFILT_VM",
-		"EVFILT_VNODE",
-		"EVFILT_WRITE",
-		"EV_ADD",
-		"EV_CLEAR",
-		"EV_DELETE",
-		"EV_DISABLE",
-		"EV_DISPATCH",
-		"EV_DROP",
-		"EV_ENABLE",
-		"EV_EOF",
-		"EV_ERROR",
-		"EV_FLAG0",
-		"EV_FLAG1",
-		"EV_ONESHOT",
-		"EV_OOBAND",
-		"EV_POLL",
-		"EV_RECEIPT",
-		"EV_SYSFLAGS",
-		"EWINDOWS",
-		"EWOULDBLOCK",
-		"EXDEV",
-		"EXFULL",
-		"EXTA",
-		"EXTB",
-		"EXTPROC",
-		"Environ",
-		"EpollCreate",
-		"EpollCreate1",
-		"EpollCtl",
-		"EpollEvent",
-		"EpollWait",
-		"Errno",
-		"EscapeArg",
-		"Exchangedata",
-		"Exec",
-		"Exit",
-		"ExitProcess",
-		"FD_CLOEXEC",
-		"FD_SETSIZE",
-		"FILE_ACTION_ADDED",
-		"FILE_ACTION_MODIFIED",
-		"FILE_ACTION_REMOVED",
-		"FILE_ACTION_RENAMED_NEW_NAME",
-		"FILE_ACTION_RENAMED_OLD_NAME",
-		"FILE_APPEND_DATA",
-		"FILE_ATTRIBUTE_ARCHIVE",
-		"FILE_ATTRIBUTE_DIRECTORY",
-		"FILE_ATTRIBUTE_HIDDEN",
-		"FILE_ATTRIBUTE_NORMAL",
-		"FILE_ATTRIBUTE_READONLY",
-		"FILE_ATTRIBUTE_REPARSE_POINT",
-		"FILE_ATTRIBUTE_SYSTEM",
-		"FILE_BEGIN",
-		"FILE_CURRENT",
-		"FILE_END",
-		"FILE_FLAG_BACKUP_SEMANTICS",
-		"FILE_FLAG_OPEN_REPARSE_POINT",
-		"FILE_FLAG_OVERLAPPED",
-		"FILE_LIST_DIRECTORY",
-		"FILE_MAP_COPY",
-		"FILE_MAP_EXECUTE",
-		"FILE_MAP_READ",
-		"FILE_MAP_WRITE",
-		"FILE_NOTIFY_CHANGE_ATTRIBUTES",
-		"FILE_NOTIFY_CHANGE_CREATION",
-		"FILE_NOTIFY_CHANGE_DIR_NAME",
-		"FILE_NOTIFY_CHANGE_FILE_NAME",
-		"FILE_NOTIFY_CHANGE_LAST_ACCESS",
-		"FILE_NOTIFY_CHANGE_LAST_WRITE",
-		"FILE_NOTIFY_CHANGE_SIZE",
-		"FILE_SHARE_DELETE",
-		"FILE_SHARE_READ",
-		"FILE_SHARE_WRITE",
-		"FILE_SKIP_COMPLETION_PORT_ON_SUCCESS",
-		"FILE_SKIP_SET_EVENT_ON_HANDLE",
-		"FILE_TYPE_CHAR",
-		"FILE_TYPE_DISK",
-		"FILE_TYPE_PIPE",
-		"FILE_TYPE_REMOTE",
-		"FILE_TYPE_UNKNOWN",
-		"FILE_WRITE_ATTRIBUTES",
-		"FLUSHO",
-		"FORMAT_MESSAGE_ALLOCATE_BUFFER",
-		"FORMAT_MESSAGE_ARGUMENT_ARRAY",
-		"FORMAT_MESSAGE_FROM_HMODULE",
-		"FORMAT_MESSAGE_FROM_STRING",
-		"FORMAT_MESSAGE_FROM_SYSTEM",
-		"FORMAT_MESSAGE_IGNORE_INSERTS",
-		"FORMAT_MESSAGE_MAX_WIDTH_MASK",
-		"FSCTL_GET_REPARSE_POINT",
-		"F_ADDFILESIGS",
-		"F_ADDSIGS",
-		"F_ALLOCATEALL",
-		"F_ALLOCATECONTIG",
-		"F_CANCEL",
-		"F_CHKCLEAN",
-		"F_CLOSEM",
-		"F_DUP2FD",
-		"F_DUP2FD_CLOEXEC",
-		"F_DUPFD",
-		"F_DUPFD_CLOEXEC",
-		"F_EXLCK",
-		"F_FLUSH_DATA",
-		"F_FREEZE_FS",
-		"F_FSCTL",
-		"F_FSDIRMASK",
-		"F_FSIN",
-		"F_FSINOUT",
-		"F_FSOUT",
-		"F_FSPRIV",
-		"F_FSVOID",
-		"F_FULLFSYNC",
-		"F_GETFD",
-		"F_GETFL",
-		"F_GETLEASE",
-		"F_GETLK",
-		"F_GETLK64",
-		"F_GETLKPID",
-		"F_GETNOSIGPIPE",
-		"F_GETOWN",
-		"F_GETOWN_EX",
-		"F_GETPATH",
-		"F_GETPATH_MTMINFO",
-		"F_GETPIPE_SZ",
-		"F_GETPROTECTIONCLASS",
-		"F_GETSIG",
-		"F_GLOBAL_NOCACHE",
-		"F_LOCK",
-		"F_LOG2PHYS",
-		"F_LOG2PHYS_EXT",
-		"F_MARKDEPENDENCY",
-		"F_MAXFD",
-		"F_NOCACHE",
-		"F_NODIRECT",
-		"F_NOTIFY",
-		"F_OGETLK",
-		"F_OK",
-		"F_OSETLK",
-		"F_OSETLKW",
-		"F_PARAM_MASK",
-		"F_PARAM_MAX",
-		"F_PATHPKG_CHECK",
-		"F_PEOFPOSMODE",
-		"F_PREALLOCATE",
-		"F_RDADVISE",
-		"F_RDAHEAD",
-		"F_RDLCK",
-		"F_READAHEAD",
-		"F_READBOOTSTRAP",
-		"F_SETBACKINGSTORE",
-		"F_SETFD",
-		"F_SETFL",
-		"F_SETLEASE",
-		"F_SETLK",
-		"F_SETLK64",
-		"F_SETLKW",
-		"F_SETLKW64",
-		"F_SETLK_REMOTE",
-		"F_SETNOSIGPIPE",
-		"F_SETOWN",
-		"F_SETOWN_EX",
-		"F_SETPIPE_SZ",
-		"F_SETPROTECTIONCLASS",
-		"F_SETSIG",
-		"F_SETSIZE",
-		"F_SHLCK",
-		"F_TEST",
-		"F_THAW_FS",
-		"F_TLOCK",
-		"F_ULOCK",
-		"F_UNLCK",
-		"F_UNLCKSYS",
-		"F_VOLPOSMODE",
-		"F_WRITEBOOTSTRAP",
-		"F_WRLCK",
-		"Faccessat",
-		"Fallocate",
-		"Fbootstraptransfer_t",
-		"Fchdir",
-		"Fchflags",
-		"Fchmod",
-		"Fchmodat",
-		"Fchown",
-		"Fchownat",
-		"FcntlFlock",
-		"FdSet",
-		"Fdatasync",
-		"FileNotifyInformation",
-		"Filetime",
-		"FindClose",
-		"FindFirstFile",
-		"FindNextFile",
-		"Flock",
-		"Flock_t",
-		"FlushBpf",
-		"FlushFileBuffers",
-		"FlushViewOfFile",
-		"ForkExec",
-		"ForkLock",
-		"FormatMessage",
-		"Fpathconf",
-		"FreeAddrInfoW",
-		"FreeEnvironmentStrings",
-		"FreeLibrary",
-		"Fsid",
-		"Fstat",
-		"Fstatat",
-		"Fstatfs",
-		"Fstore_t",
-		"Fsync",
-		"Ftruncate",
-		"FullPath",
-		"Futimes",
-		"Futimesat",
-		"GENERIC_ALL",
-		"GENERIC_EXECUTE",
-		"GENERIC_READ",
-		"GENERIC_WRITE",
-		"GUID",
-		"GetAcceptExSockaddrs",
-		"GetAdaptersInfo",
-		"GetAddrInfoW",
-		"GetCommandLine",
-		"GetComputerName",
-		"GetConsoleMode",
-		"GetCurrentDirectory",
-		"GetCurrentProcess",
-		"GetEnvironmentStrings",
-		"GetEnvironmentVariable",
-		"GetExitCodeProcess",
-		"GetFileAttributes",
-		"GetFileAttributesEx",
-		"GetFileExInfoStandard",
-		"GetFileExMaxInfoLevel",
-		"GetFileInformationByHandle",
-		"GetFileType",
-		"GetFullPathName",
-		"GetHostByName",
-		"GetIfEntry",
-		"GetLastError",
-		"GetLengthSid",
-		"GetLongPathName",
-		"GetProcAddress",
-		"GetProcessTimes",
-		"GetProtoByName",
-		"GetQueuedCompletionStatus",
-		"GetServByName",
-		"GetShortPathName",
-		"GetStartupInfo",
-		"GetStdHandle",
-		"GetSystemTimeAsFileTime",
-		"GetTempPath",
-		"GetTimeZoneInformation",
-		"GetTokenInformation",
-		"GetUserNameEx",
-		"GetUserProfileDirectory",
-		"GetVersion",
-		"Getcwd",
-		"Getdents",
-		"Getdirentries",
-		"Getdtablesize",
-		"Getegid",
-		"Getenv",
-		"Geteuid",
-		"Getfsstat",
-		"Getgid",
-		"Getgroups",
-		"Getpagesize",
-		"Getpeername",
-		"Getpgid",
-		"Getpgrp",
-		"Getpid",
-		"Getppid",
-		"Getpriority",
-		"Getrlimit",
-		"Getrusage",
-		"Getsid",
-		"Getsockname",
-		"Getsockopt",
-		"GetsockoptByte",
-		"GetsockoptICMPv6Filter",
-		"GetsockoptIPMreq",
-		"GetsockoptIPMreqn",
-		"GetsockoptIPv6MTUInfo",
-		"GetsockoptIPv6Mreq",
-		"GetsockoptInet4Addr",
-		"GetsockoptInt",
-		"GetsockoptUcred",
-		"Gettid",
-		"Gettimeofday",
-		"Getuid",
-		"Getwd",
-		"Getxattr",
-		"HANDLE_FLAG_INHERIT",
-		"HKEY_CLASSES_ROOT",
-		"HKEY_CURRENT_CONFIG",
-		"HKEY_CURRENT_USER",
-		"HKEY_DYN_DATA",
-		"HKEY_LOCAL_MACHINE",
-		"HKEY_PERFORMANCE_DATA",
-		"HKEY_USERS",
-		"HUPCL",
-		"Handle",
-		"Hostent",
-		"ICANON",
-		"ICMP6_FILTER",
-		"ICMPV6_FILTER",
-		"ICMPv6Filter",
-		"ICRNL",
-		"IEXTEN",
-		"IFAN_ARRIVAL",
-		"IFAN_DEPARTURE",
-		"IFA_ADDRESS",
-		"IFA_ANYCAST",
-		"IFA_BROADCAST",
-		"IFA_CACHEINFO",
-		"IFA_F_DADFAILED",
-		"IFA_F_DEPRECATED",
-		"IFA_F_HOMEADDRESS",
-		"IFA_F_NODAD",
-		"IFA_F_OPTIMISTIC",
-		"IFA_F_PERMANENT",
-		"IFA_F_SECONDARY",
-		"IFA_F_TEMPORARY",
-		"IFA_F_TENTATIVE",
-		"IFA_LABEL",
-		"IFA_LOCAL",
-		"IFA_MAX",
-		"IFA_MULTICAST",
-		"IFA_ROUTE",
-		"IFA_UNSPEC",
-		"IFF_ALLMULTI",
-		"IFF_ALTPHYS",
-		"IFF_AUTOMEDIA",
-		"IFF_BROADCAST",
-		"IFF_CANTCHANGE",
-		"IFF_CANTCONFIG",
-		"IFF_DEBUG",
-		"IFF_DRV_OACTIVE",
-		"IFF_DRV_RUNNING",
-		"IFF_DYING",
-		"IFF_DYNAMIC",
-		"IFF_LINK0",
-		"IFF_LINK1",
-		"IFF_LINK2",
-		"IFF_LOOPBACK",
-		"IFF_MASTER",
-		"IFF_MONITOR",
-		"IFF_MULTICAST",
-		"IFF_NOARP",
-		"IFF_NOTRAILERS",
-		"IFF_NO_PI",
-		"IFF_OACTIVE",
-		"IFF_ONE_QUEUE",
-		"IFF_POINTOPOINT",
-		"IFF_POINTTOPOINT",
-		"IFF_PORTSEL",
-		"IFF_PPROMISC",
-		"IFF_PROMISC",
-		"IFF_RENAMING",
-		"IFF_RUNNING",
-		"IFF_SIMPLEX",
-		"IFF_SLAVE",
-		"IFF_SMART",
-		"IFF_STATICARP",
-		"IFF_TAP",
-		"IFF_TUN",
-		"IFF_TUN_EXCL",
-		"IFF_UP",
-		"IFF_VNET_HDR",
-		"IFLA_ADDRESS",
-		"IFLA_BROADCAST",
-		"IFLA_COST",
-		"IFLA_IFALIAS",
-		"IFLA_IFNAME",
-		"IFLA_LINK",
-		"IFLA_LINKINFO",
-		"IFLA_LINKMODE",
-		"IFLA_MAP",
-		"IFLA_MASTER",
-		"IFLA_MAX",
-		"IFLA_MTU",
-		"IFLA_NET_NS_PID",
-		"IFLA_OPERSTATE",
-		"IFLA_PRIORITY",
-		"IFLA_PROTINFO",
-		"IFLA_QDISC",
-		"IFLA_STATS",
-		"IFLA_TXQLEN",
-		"IFLA_UNSPEC",
-		"IFLA_WEIGHT",
-		"IFLA_WIRELESS",
-		"IFNAMSIZ",
-		"IFT_1822",
-		"IFT_A12MPPSWITCH",
-		"IFT_AAL2",
-		"IFT_AAL5",
-		"IFT_ADSL",
-		"IFT_AFLANE8023",
-		"IFT_AFLANE8025",
-		"IFT_ARAP",
-		"IFT_ARCNET",
-		"IFT_ARCNETPLUS",
-		"IFT_ASYNC",
-		"IFT_ATM",
-		"IFT_ATMDXI",
-		"IFT_ATMFUNI",
-		"IFT_ATMIMA",
-		"IFT_ATMLOGICAL",
-		"IFT_ATMRADIO",
-		"IFT_ATMSUBINTERFACE",
-		"IFT_ATMVCIENDPT",
-		"IFT_ATMVIRTUAL",
-		"IFT_BGPPOLICYACCOUNTING",
-		"IFT_BLUETOOTH",
-		"IFT_BRIDGE",
-		"IFT_BSC",
-		"IFT_CARP",
-		"IFT_CCTEMUL",
-		"IFT_CELLULAR",
-		"IFT_CEPT",
-		"IFT_CES",
-		"IFT_CHANNEL",
-		"IFT_CNR",
-		"IFT_COFFEE",
-		"IFT_COMPOSITELINK",
-		"IFT_DCN",
-		"IFT_DIGITALPOWERLINE",
-		"IFT_DIGITALWRAPPEROVERHEADCHANNEL",
-		"IFT_DLSW",
-		"IFT_DOCSCABLEDOWNSTREAM",
-		"IFT_DOCSCABLEMACLAYER",
-		"IFT_DOCSCABLEUPSTREAM",
-		"IFT_DOCSCABLEUPSTREAMCHANNEL",
-		"IFT_DS0",
-		"IFT_DS0BUNDLE",
-		"IFT_DS1FDL",
-		"IFT_DS3",
-		"IFT_DTM",
-		"IFT_DUMMY",
-		"IFT_DVBASILN",
-		"IFT_DVBASIOUT",
-		"IFT_DVBRCCDOWNSTREAM",
-		"IFT_DVBRCCMACLAYER",
-		"IFT_DVBRCCUPSTREAM",
-		"IFT_ECONET",
-		"IFT_ENC",
-		"IFT_EON",
-		"IFT_EPLRS",
-		"IFT_ESCON",
-		"IFT_ETHER",
-		"IFT_FAITH",
-		"IFT_FAST",
-		"IFT_FASTETHER",
-		"IFT_FASTETHERFX",
-		"IFT_FDDI",
-		"IFT_FIBRECHANNEL",
-		"IFT_FRAMERELAYINTERCONNECT",
-		"IFT_FRAMERELAYMPI",
-		"IFT_FRDLCIENDPT",
-		"IFT_FRELAY",
-		"IFT_FRELAYDCE",
-		"IFT_FRF16MFRBUNDLE",
-		"IFT_FRFORWARD",
-		"IFT_G703AT2MB",
-		"IFT_G703AT64K",
-		"IFT_GIF",
-		"IFT_GIGABITETHERNET",
-		"IFT_GR303IDT",
-		"IFT_GR303RDT",
-		"IFT_H323GATEKEEPER",
-		"IFT_H323PROXY",
-		"IFT_HDH1822",
-		"IFT_HDLC",
-		"IFT_HDSL2",
-		"IFT_HIPERLAN2",
-		"IFT_HIPPI",
-		"IFT_HIPPIINTERFACE",
-		"IFT_HOSTPAD",
-		"IFT_HSSI",
-		"IFT_HY",
-		"IFT_IBM370PARCHAN",
-		"IFT_IDSL",
-		"IFT_IEEE1394",
-		"IFT_IEEE80211",
-		"IFT_IEEE80212",
-		"IFT_IEEE8023ADLAG",
-		"IFT_IFGSN",
-		"IFT_IMT",
-		"IFT_INFINIBAND",
-		"IFT_INTERLEAVE",
-		"IFT_IP",
-		"IFT_IPFORWARD",
-		"IFT_IPOVERATM",
-		"IFT_IPOVERCDLC",
-		"IFT_IPOVERCLAW",
-		"IFT_IPSWITCH",
-		"IFT_IPXIP",
-		"IFT_ISDN",
-		"IFT_ISDNBASIC",
-		"IFT_ISDNPRIMARY",
-		"IFT_ISDNS",
-		"IFT_ISDNU",
-		"IFT_ISO88022LLC",
-		"IFT_ISO88023",
-		"IFT_ISO88024",
-		"IFT_ISO88025",
-		"IFT_ISO88025CRFPINT",
-		"IFT_ISO88025DTR",
-		"IFT_ISO88025FIBER",
-		"IFT_ISO88026",
-		"IFT_ISUP",
-		"IFT_L2VLAN",
-		"IFT_L3IPVLAN",
-		"IFT_L3IPXVLAN",
-		"IFT_LAPB",
-		"IFT_LAPD",
-		"IFT_LAPF",
-		"IFT_LINEGROUP",
-		"IFT_LOCALTALK",
-		"IFT_LOOP",
-		"IFT_MEDIAMAILOVERIP",
-		"IFT_MFSIGLINK",
-		"IFT_MIOX25",
-		"IFT_MODEM",
-		"IFT_MPC",
-		"IFT_MPLS",
-		"IFT_MPLSTUNNEL",
-		"IFT_MSDSL",
-		"IFT_MVL",
-		"IFT_MYRINET",
-		"IFT_NFAS",
-		"IFT_NSIP",
-		"IFT_OPTICALCHANNEL",
-		"IFT_OPTICALTRANSPORT",
-		"IFT_OTHER",
-		"IFT_P10",
-		"IFT_P80",
-		"IFT_PARA",
-		"IFT_PDP",
-		"IFT_PFLOG",
-		"IFT_PFLOW",
-		"IFT_PFSYNC",
-		"IFT_PLC",
-		"IFT_PON155",
-		"IFT_PON622",
-		"IFT_POS",
-		"IFT_PPP",
-		"IFT_PPPMULTILINKBUNDLE",
-		"IFT_PROPATM",
-		"IFT_PROPBWAP2MP",
-		"IFT_PROPCNLS",
-		"IFT_PROPDOCSWIRELESSDOWNSTREAM",
-		"IFT_PROPDOCSWIRELESSMACLAYER",
-		"IFT_PROPDOCSWIRELESSUPSTREAM",
-		"IFT_PROPMUX",
-		"IFT_PROPVIRTUAL",
-		"IFT_PROPWIRELESSP2P",
-		"IFT_PTPSERIAL",
-		"IFT_PVC",
-		"IFT_Q2931",
-		"IFT_QLLC",
-		"IFT_RADIOMAC",
-		"IFT_RADSL",
-		"IFT_REACHDSL",
-		"IFT_RFC1483",
-		"IFT_RS232",
-		"IFT_RSRB",
-		"IFT_SDLC",
-		"IFT_SDSL",
-		"IFT_SHDSL",
-		"IFT_SIP",
-		"IFT_SIPSIG",
-		"IFT_SIPTG",
-		"IFT_SLIP",
-		"IFT_SMDSDXI",
-		"IFT_SMDSICIP",
-		"IFT_SONET",
-		"IFT_SONETOVERHEADCHANNEL",
-		"IFT_SONETPATH",
-		"IFT_SONETVT",
-		"IFT_SRP",
-		"IFT_SS7SIGLINK",
-		"IFT_STACKTOSTACK",
-		"IFT_STARLAN",
-		"IFT_STF",
-		"IFT_T1",
-		"IFT_TDLC",
-		"IFT_TELINK",
-		"IFT_TERMPAD",
-		"IFT_TR008",
-		"IFT_TRANSPHDLC",
-		"IFT_TUNNEL",
-		"IFT_ULTRA",
-		"IFT_USB",
-		"IFT_V11",
-		"IFT_V35",
-		"IFT_V36",
-		"IFT_V37",
-		"IFT_VDSL",
-		"IFT_VIRTUALIPADDRESS",
-		"IFT_VIRTUALTG",
-		"IFT_VOICEDID",
-		"IFT_VOICEEM",
-		"IFT_VOICEEMFGD",
-		"IFT_VOICEENCAP",
-		"IFT_VOICEFGDEANA",
-		"IFT_VOICEFXO",
-		"IFT_VOICEFXS",
-		"IFT_VOICEOVERATM",
-		"IFT_VOICEOVERCABLE",
-		"IFT_VOICEOVERFRAMERELAY",
-		"IFT_VOICEOVERIP",
-		"IFT_X213",
-		"IFT_X25",
-		"IFT_X25DDN",
-		"IFT_X25HUNTGROUP",
-		"IFT_X25MLP",
-		"IFT_X25PLE",
-		"IFT_XETHER",
-		"IGNBRK",
-		"IGNCR",
-		"IGNORE",
-		"IGNPAR",
-		"IMAXBEL",
-		"INFINITE",
-		"INLCR",
-		"INPCK",
-		"INVALID_FILE_ATTRIBUTES",
-		"IN_ACCESS",
-		"IN_ALL_EVENTS",
-		"IN_ATTRIB",
-		"IN_CLASSA_HOST",
-		"IN_CLASSA_MAX",
-		"IN_CLASSA_NET",
-		"IN_CLASSA_NSHIFT",
-		"IN_CLASSB_HOST",
-		"IN_CLASSB_MAX",
-		"IN_CLASSB_NET",
-		"IN_CLASSB_NSHIFT",
-		"IN_CLASSC_HOST",
-		"IN_CLASSC_NET",
-		"IN_CLASSC_NSHIFT",
-		"IN_CLASSD_HOST",
-		"IN_CLASSD_NET",
-		"IN_CLASSD_NSHIFT",
-		"IN_CLOEXEC",
-		"IN_CLOSE",
-		"IN_CLOSE_NOWRITE",
-		"IN_CLOSE_WRITE",
-		"IN_CREATE",
-		"IN_DELETE",
-		"IN_DELETE_SELF",
-		"IN_DONT_FOLLOW",
-		"IN_EXCL_UNLINK",
-		"IN_IGNORED",
-		"IN_ISDIR",
-		"IN_LINKLOCALNETNUM",
-		"IN_LOOPBACKNET",
-		"IN_MASK_ADD",
-		"IN_MODIFY",
-		"IN_MOVE",
-		"IN_MOVED_FROM",
-		"IN_MOVED_TO",
-		"IN_MOVE_SELF",
-		"IN_NONBLOCK",
-		"IN_ONESHOT",
-		"IN_ONLYDIR",
-		"IN_OPEN",
-		"IN_Q_OVERFLOW",
-		"IN_RFC3021_HOST",
-		"IN_RFC3021_MASK",
-		"IN_RFC3021_NET",
-		"IN_RFC3021_NSHIFT",
-		"IN_UNMOUNT",
-		"IOC_IN",
-		"IOC_INOUT",
-		"IOC_OUT",
-		"IOC_VENDOR",
-		"IOC_WS2",
-		"IO_REPARSE_TAG_SYMLINK",
-		"IPMreq",
-		"IPMreqn",
-		"IPPROTO_3PC",
-		"IPPROTO_ADFS",
-		"IPPROTO_AH",
-		"IPPROTO_AHIP",
-		"IPPROTO_APES",
-		"IPPROTO_ARGUS",
-		"IPPROTO_AX25",
-		"IPPROTO_BHA",
-		"IPPROTO_BLT",
-		"IPPROTO_BRSATMON",
-		"IPPROTO_CARP",
-		"IPPROTO_CFTP",
-		"IPPROTO_CHAOS",
-		"IPPROTO_CMTP",
-		"IPPROTO_COMP",
-		"IPPROTO_CPHB",
-		"IPPROTO_CPNX",
-		"IPPROTO_DCCP",
-		"IPPROTO_DDP",
-		"IPPROTO_DGP",
-		"IPPROTO_DIVERT",
-		"IPPROTO_DIVERT_INIT",
-		"IPPROTO_DIVERT_RESP",
-		"IPPROTO_DONE",
-		"IPPROTO_DSTOPTS",
-		"IPPROTO_EGP",
-		"IPPROTO_EMCON",
-		"IPPROTO_ENCAP",
-		"IPPROTO_EON",
-		"IPPROTO_ESP",
-		"IPPROTO_ETHERIP",
-		"IPPROTO_FRAGMENT",
-		"IPPROTO_GGP",
-		"IPPROTO_GMTP",
-		"IPPROTO_GRE",
-		"IPPROTO_HELLO",
-		"IPPROTO_HMP",
-		"IPPROTO_HOPOPTS",
-		"IPPROTO_ICMP",
-		"IPPROTO_ICMPV6",
-		"IPPROTO_IDP",
-		"IPPROTO_IDPR",
-		"IPPROTO_IDRP",
-		"IPPROTO_IGMP",
-		"IPPROTO_IGP",
-		"IPPROTO_IGRP",
-		"IPPROTO_IL",
-		"IPPROTO_INLSP",
-		"IPPROTO_INP",
-		"IPPROTO_IP",
-		"IPPROTO_IPCOMP",
-		"IPPROTO_IPCV",
-		"IPPROTO_IPEIP",
-		"IPPROTO_IPIP",
-		"IPPROTO_IPPC",
-		"IPPROTO_IPV4",
-		"IPPROTO_IPV6",
-		"IPPROTO_IPV6_ICMP",
-		"IPPROTO_IRTP",
-		"IPPROTO_KRYPTOLAN",
-		"IPPROTO_LARP",
-		"IPPROTO_LEAF1",
-		"IPPROTO_LEAF2",
-		"IPPROTO_MAX",
-		"IPPROTO_MAXID",
-		"IPPROTO_MEAS",
-		"IPPROTO_MH",
-		"IPPROTO_MHRP",
-		"IPPROTO_MICP",
-		"IPPROTO_MOBILE",
-		"IPPROTO_MPLS",
-		"IPPROTO_MTP",
-		"IPPROTO_MUX",
-		"IPPROTO_ND",
-		"IPPROTO_NHRP",
-		"IPPROTO_NONE",
-		"IPPROTO_NSP",
-		"IPPROTO_NVPII",
-		"IPPROTO_OLD_DIVERT",
-		"IPPROTO_OSPFIGP",
-		"IPPROTO_PFSYNC",
-		"IPPROTO_PGM",
-		"IPPROTO_PIGP",
-		"IPPROTO_PIM",
-		"IPPROTO_PRM",
-		"IPPROTO_PUP",
-		"IPPROTO_PVP",
-		"IPPROTO_RAW",
-		"IPPROTO_RCCMON",
-		"IPPROTO_RDP",
-		"IPPROTO_ROUTING",
-		"IPPROTO_RSVP",
-		"IPPROTO_RVD",
-		"IPPROTO_SATEXPAK",
-		"IPPROTO_SATMON",
-		"IPPROTO_SCCSP",
-		"IPPROTO_SCTP",
-		"IPPROTO_SDRP",
-		"IPPROTO_SEND",
-		"IPPROTO_SEP",
-		"IPPROTO_SKIP",
-		"IPPROTO_SPACER",
-		"IPPROTO_SRPC",
-		"IPPROTO_ST",
-		"IPPROTO_SVMTP",
-		"IPPROTO_SWIPE",
-		"IPPROTO_TCF",
-		"IPPROTO_TCP",
-		"IPPROTO_TLSP",
-		"IPPROTO_TP",
-		"IPPROTO_TPXX",
-		"IPPROTO_TRUNK1",
-		"IPPROTO_TRUNK2",
-		"IPPROTO_TTP",
-		"IPPROTO_UDP",
-		"IPPROTO_UDPLITE",
-		"IPPROTO_VINES",
-		"IPPROTO_VISA",
-		"IPPROTO_VMTP",
-		"IPPROTO_VRRP",
-		"IPPROTO_WBEXPAK",
-		"IPPROTO_WBMON",
-		"IPPROTO_WSN",
-		"IPPROTO_XNET",
-		"IPPROTO_XTP",
-		"IPV6_2292DSTOPTS",
-		"IPV6_2292HOPLIMIT",
-		"IPV6_2292HOPOPTS",
-		"IPV6_2292NEXTHOP",
-		"IPV6_2292PKTINFO",
-		"IPV6_2292PKTOPTIONS",
-		"IPV6_2292RTHDR",
-		"IPV6_ADDRFORM",
-		"IPV6_ADD_MEMBERSHIP",
-		"IPV6_AUTHHDR",
-		"IPV6_AUTH_LEVEL",
-		"IPV6_AUTOFLOWLABEL",
-		"IPV6_BINDANY",
-		"IPV6_BINDV6ONLY",
-		"IPV6_BOUND_IF",
-		"IPV6_CHECKSUM",
-		"IPV6_DEFAULT_MULTICAST_HOPS",
-		"IPV6_DEFAULT_MULTICAST_LOOP",
-		"IPV6_DEFHLIM",
-		"IPV6_DONTFRAG",
-		"IPV6_DROP_MEMBERSHIP",
-		"IPV6_DSTOPTS",
-		"IPV6_ESP_NETWORK_LEVEL",
-		"IPV6_ESP_TRANS_LEVEL",
-		"IPV6_FAITH",
-		"IPV6_FLOWINFO_MASK",
-		"IPV6_FLOWLABEL_MASK",
-		"IPV6_FRAGTTL",
-		"IPV6_FW_ADD",
-		"IPV6_FW_DEL",
-		"IPV6_FW_FLUSH",
-		"IPV6_FW_GET",
-		"IPV6_FW_ZERO",
-		"IPV6_HLIMDEC",
-		"IPV6_HOPLIMIT",
-		"IPV6_HOPOPTS",
-		"IPV6_IPCOMP_LEVEL",
-		"IPV6_IPSEC_POLICY",
-		"IPV6_JOIN_ANYCAST",
-		"IPV6_JOIN_GROUP",
-		"IPV6_LEAVE_ANYCAST",
-		"IPV6_LEAVE_GROUP",
-		"IPV6_MAXHLIM",
-		"IPV6_MAXOPTHDR",
-		"IPV6_MAXPACKET",
-		"IPV6_MAX_GROUP_SRC_FILTER",
-		"IPV6_MAX_MEMBERSHIPS",
-		"IPV6_MAX_SOCK_SRC_FILTER",
-		"IPV6_MIN_MEMBERSHIPS",
-		"IPV6_MMTU",
-		"IPV6_MSFILTER",
-		"IPV6_MTU",
-		"IPV6_MTU_DISCOVER",
-		"IPV6_MULTICAST_HOPS",
-		"IPV6_MULTICAST_IF",
-		"IPV6_MULTICAST_LOOP",
-		"IPV6_NEXTHOP",
-		"IPV6_OPTIONS",
-		"IPV6_PATHMTU",
-		"IPV6_PIPEX",
-		"IPV6_PKTINFO",
-		"IPV6_PMTUDISC_DO",
-		"IPV6_PMTUDISC_DONT",
-		"IPV6_PMTUDISC_PROBE",
-		"IPV6_PMTUDISC_WANT",
-		"IPV6_PORTRANGE",
-		"IPV6_PORTRANGE_DEFAULT",
-		"IPV6_PORTRANGE_HIGH",
-		"IPV6_PORTRANGE_LOW",
-		"IPV6_PREFER_TEMPADDR",
-		"IPV6_RECVDSTOPTS",
-		"IPV6_RECVDSTPORT",
-		"IPV6_RECVERR",
-		"IPV6_RECVHOPLIMIT",
-		"IPV6_RECVHOPOPTS",
-		"IPV6_RECVPATHMTU",
-		"IPV6_RECVPKTINFO",
-		"IPV6_RECVRTHDR",
-		"IPV6_RECVTCLASS",
-		"IPV6_ROUTER_ALERT",
-		"IPV6_RTABLE",
-		"IPV6_RTHDR",
-		"IPV6_RTHDRDSTOPTS",
-		"IPV6_RTHDR_LOOSE",
-		"IPV6_RTHDR_STRICT",
-		"IPV6_RTHDR_TYPE_0",
-		"IPV6_RXDSTOPTS",
-		"IPV6_RXHOPOPTS",
-		"IPV6_SOCKOPT_RESERVED1",
-		"IPV6_TCLASS",
-		"IPV6_UNICAST_HOPS",
-		"IPV6_USE_MIN_MTU",
-		"IPV6_V6ONLY",
-		"IPV6_VERSION",
-		"IPV6_VERSION_MASK",
-		"IPV6_XFRM_POLICY",
-		"IP_ADD_MEMBERSHIP",
-		"IP_ADD_SOURCE_MEMBERSHIP",
-		"IP_AUTH_LEVEL",
-		"IP_BINDANY",
-		"IP_BLOCK_SOURCE",
-		"IP_BOUND_IF",
-		"IP_DEFAULT_MULTICAST_LOOP",
-		"IP_DEFAULT_MULTICAST_TTL",
-		"IP_DF",
-		"IP_DIVERTFL",
-		"IP_DONTFRAG",
-		"IP_DROP_MEMBERSHIP",
-		"IP_DROP_SOURCE_MEMBERSHIP",
-		"IP_DUMMYNET3",
-		"IP_DUMMYNET_CONFIGURE",
-		"IP_DUMMYNET_DEL",
-		"IP_DUMMYNET_FLUSH",
-		"IP_DUMMYNET_GET",
-		"IP_EF",
-		"IP_ERRORMTU",
-		"IP_ESP_NETWORK_LEVEL",
-		"IP_ESP_TRANS_LEVEL",
-		"IP_FAITH",
-		"IP_FREEBIND",
-		"IP_FW3",
-		"IP_FW_ADD",
-		"IP_FW_DEL",
-		"IP_FW_FLUSH",
-		"IP_FW_GET",
-		"IP_FW_NAT_CFG",
-		"IP_FW_NAT_DEL",
-		"IP_FW_NAT_GET_CONFIG",
-		"IP_FW_NAT_GET_LOG",
-		"IP_FW_RESETLOG",
-		"IP_FW_TABLE_ADD",
-		"IP_FW_TABLE_DEL",
-		"IP_FW_TABLE_FLUSH",
-		"IP_FW_TABLE_GETSIZE",
-		"IP_FW_TABLE_LIST",
-		"IP_FW_ZERO",
-		"IP_HDRINCL",
-		"IP_IPCOMP_LEVEL",
-		"IP_IPSECFLOWINFO",
-		"IP_IPSEC_LOCAL_AUTH",
-		"IP_IPSEC_LOCAL_CRED",
-		"IP_IPSEC_LOCAL_ID",
-		"IP_IPSEC_POLICY",
-		"IP_IPSEC_REMOTE_AUTH",
-		"IP_IPSEC_REMOTE_CRED",
-		"IP_IPSEC_REMOTE_ID",
-		"IP_MAXPACKET",
-		"IP_MAX_GROUP_SRC_FILTER",
-		"IP_MAX_MEMBERSHIPS",
-		"IP_MAX_SOCK_MUTE_FILTER",
-		"IP_MAX_SOCK_SRC_FILTER",
-		"IP_MAX_SOURCE_FILTER",
-		"IP_MF",
-		"IP_MINFRAGSIZE",
-		"IP_MINTTL",
-		"IP_MIN_MEMBERSHIPS",
-		"IP_MSFILTER",
-		"IP_MSS",
-		"IP_MTU",
-		"IP_MTU_DISCOVER",
-		"IP_MULTICAST_IF",
-		"IP_MULTICAST_IFINDEX",
-		"IP_MULTICAST_LOOP",
-		"IP_MULTICAST_TTL",
-		"IP_MULTICAST_VIF",
-		"IP_NAT__XXX",
-		"IP_OFFMASK",
-		"IP_OLD_FW_ADD",
-		"IP_OLD_FW_DEL",
-		"IP_OLD_FW_FLUSH",
-		"IP_OLD_FW_GET",
-		"IP_OLD_FW_RESETLOG",
-		"IP_OLD_FW_ZERO",
-		"IP_ONESBCAST",
-		"IP_OPTIONS",
-		"IP_ORIGDSTADDR",
-		"IP_PASSSEC",
-		"IP_PIPEX",
-		"IP_PKTINFO",
-		"IP_PKTOPTIONS",
-		"IP_PMTUDISC",
-		"IP_PMTUDISC_DO",
-		"IP_PMTUDISC_DONT",
-		"IP_PMTUDISC_PROBE",
-		"IP_PMTUDISC_WANT",
-		"IP_PORTRANGE",
-		"IP_PORTRANGE_DEFAULT",
-		"IP_PORTRANGE_HIGH",
-		"IP_PORTRANGE_LOW",
-		"IP_RECVDSTADDR",
-		"IP_RECVDSTPORT",
-		"IP_RECVERR",
-		"IP_RECVIF",
-		"IP_RECVOPTS",
-		"IP_RECVORIGDSTADDR",
-		"IP_RECVPKTINFO",
-		"IP_RECVRETOPTS",
-		"IP_RECVRTABLE",
-		"IP_RECVTOS",
-		"IP_RECVTTL",
-		"IP_RETOPTS",
-		"IP_RF",
-		"IP_ROUTER_ALERT",
-		"IP_RSVP_OFF",
-		"IP_RSVP_ON",
-		"IP_RSVP_VIF_OFF",
-		"IP_RSVP_VIF_ON",
-		"IP_RTABLE",
-		"IP_SENDSRCADDR",
-		"IP_STRIPHDR",
-		"IP_TOS",
-		"IP_TRAFFIC_MGT_BACKGROUND",
-		"IP_TRANSPARENT",
-		"IP_TTL",
-		"IP_UNBLOCK_SOURCE",
-		"IP_XFRM_POLICY",
-		"IPv6MTUInfo",
-		"IPv6Mreq",
-		"ISIG",
-		"ISTRIP",
-		"IUCLC",
-		"IUTF8",
-		"IXANY",
-		"IXOFF",
-		"IXON",
-		"IfAddrmsg",
-		"IfAnnounceMsghdr",
-		"IfData",
-		"IfInfomsg",
-		"IfMsghdr",
-		"IfaMsghdr",
-		"IfmaMsghdr",
-		"IfmaMsghdr2",
-		"ImplementsGetwd",
-		"Inet4Pktinfo",
-		"Inet6Pktinfo",
-		"InotifyAddWatch",
-		"InotifyEvent",
-		"InotifyInit",
-		"InotifyInit1",
-		"InotifyRmWatch",
-		"InterfaceAddrMessage",
-		"InterfaceAnnounceMessage",
-		"InterfaceInfo",
-		"InterfaceMessage",
-		"InterfaceMulticastAddrMessage",
-		"InvalidHandle",
-		"Ioperm",
-		"Iopl",
-		"Iovec",
-		"IpAdapterInfo",
-		"IpAddrString",
-		"IpAddressString",
-		"IpMaskString",
-		"Issetugid",
-		"KEY_ALL_ACCESS",
-		"KEY_CREATE_LINK",
-		"KEY_CREATE_SUB_KEY",
-		"KEY_ENUMERATE_SUB_KEYS",
-		"KEY_EXECUTE",
-		"KEY_NOTIFY",
-		"KEY_QUERY_VALUE",
-		"KEY_READ",
-		"KEY_SET_VALUE",
-		"KEY_WOW64_32KEY",
-		"KEY_WOW64_64KEY",
-		"KEY_WRITE",
-		"Kevent",
-		"Kevent_t",
-		"Kill",
-		"Klogctl",
-		"Kqueue",
-		"LANG_ENGLISH",
-		"LAYERED_PROTOCOL",
-		"LCNT_OVERLOAD_FLUSH",
-		"LINUX_REBOOT_CMD_CAD_OFF",
-		"LINUX_REBOOT_CMD_CAD_ON",
-		"LINUX_REBOOT_CMD_HALT",
-		"LINUX_REBOOT_CMD_KEXEC",
-		"LINUX_REBOOT_CMD_POWER_OFF",
-		"LINUX_REBOOT_CMD_RESTART",
-		"LINUX_REBOOT_CMD_RESTART2",
-		"LINUX_REBOOT_CMD_SW_SUSPEND",
-		"LINUX_REBOOT_MAGIC1",
-		"LINUX_REBOOT_MAGIC2",
-		"LOCK_EX",
-		"LOCK_NB",
-		"LOCK_SH",
-		"LOCK_UN",
-		"LazyDLL",
-		"LazyProc",
-		"Lchown",
-		"Linger",
-		"Link",
-		"Listen",
-		"Listxattr",
-		"LoadCancelIoEx",
-		"LoadConnectEx",
-		"LoadCreateSymbolicLink",
-		"LoadDLL",
-		"LoadGetAddrInfo",
-		"LoadLibrary",
-		"LoadSetFileCompletionNotificationModes",
-		"LocalFree",
-		"Log2phys_t",
-		"LookupAccountName",
-		"LookupAccountSid",
-		"LookupSID",
-		"LsfJump",
-		"LsfSocket",
-		"LsfStmt",
-		"Lstat",
-		"MADV_AUTOSYNC",
-		"MADV_CAN_REUSE",
-		"MADV_CORE",
-		"MADV_DOFORK",
-		"MADV_DONTFORK",
-		"MADV_DONTNEED",
-		"MADV_FREE",
-		"MADV_FREE_REUSABLE",
-		"MADV_FREE_REUSE",
-		"MADV_HUGEPAGE",
-		"MADV_HWPOISON",
-		"MADV_MERGEABLE",
-		"MADV_NOCORE",
-		"MADV_NOHUGEPAGE",
-		"MADV_NORMAL",
-		"MADV_NOSYNC",
-		"MADV_PROTECT",
-		"MADV_RANDOM",
-		"MADV_REMOVE",
-		"MADV_SEQUENTIAL",
-		"MADV_SPACEAVAIL",
-		"MADV_UNMERGEABLE",
-		"MADV_WILLNEED",
-		"MADV_ZERO_WIRED_PAGES",
-		"MAP_32BIT",
-		"MAP_ALIGNED_SUPER",
-		"MAP_ALIGNMENT_16MB",
-		"MAP_ALIGNMENT_1TB",
-		"MAP_ALIGNMENT_256TB",
-		"MAP_ALIGNMENT_4GB",
-		"MAP_ALIGNMENT_64KB",
-		"MAP_ALIGNMENT_64PB",
-		"MAP_ALIGNMENT_MASK",
-		"MAP_ALIGNMENT_SHIFT",
-		"MAP_ANON",
-		"MAP_ANONYMOUS",
-		"MAP_COPY",
-		"MAP_DENYWRITE",
-		"MAP_EXECUTABLE",
-		"MAP_FILE",
-		"MAP_FIXED",
-		"MAP_FLAGMASK",
-		"MAP_GROWSDOWN",
-		"MAP_HASSEMAPHORE",
-		"MAP_HUGETLB",
-		"MAP_INHERIT",
-		"MAP_INHERIT_COPY",
-		"MAP_INHERIT_DEFAULT",
-		"MAP_INHERIT_DONATE_COPY",
-		"MAP_INHERIT_NONE",
-		"MAP_INHERIT_SHARE",
-		"MAP_JIT",
-		"MAP_LOCKED",
-		"MAP_NOCACHE",
-		"MAP_NOCORE",
-		"MAP_NOEXTEND",
-		"MAP_NONBLOCK",
-		"MAP_NORESERVE",
-		"MAP_NOSYNC",
-		"MAP_POPULATE",
-		"MAP_PREFAULT_READ",
-		"MAP_PRIVATE",
-		"MAP_RENAME",
-		"MAP_RESERVED0080",
-		"MAP_RESERVED0100",
-		"MAP_SHARED",
-		"MAP_STACK",
-		"MAP_TRYFIXED",
-		"MAP_TYPE",
-		"MAP_WIRED",
-		"MAXIMUM_REPARSE_DATA_BUFFER_SIZE",
-		"MAXLEN_IFDESCR",
-		"MAXLEN_PHYSADDR",
-		"MAX_ADAPTER_ADDRESS_LENGTH",
-		"MAX_ADAPTER_DESCRIPTION_LENGTH",
-		"MAX_ADAPTER_NAME_LENGTH",
-		"MAX_COMPUTERNAME_LENGTH",
-		"MAX_INTERFACE_NAME_LEN",
-		"MAX_LONG_PATH",
-		"MAX_PATH",
-		"MAX_PROTOCOL_CHAIN",
-		"MCL_CURRENT",
-		"MCL_FUTURE",
-		"MNT_DETACH",
-		"MNT_EXPIRE",
-		"MNT_FORCE",
-		"MSG_BCAST",
-		"MSG_CMSG_CLOEXEC",
-		"MSG_COMPAT",
-		"MSG_CONFIRM",
-		"MSG_CONTROLMBUF",
-		"MSG_CTRUNC",
-		"MSG_DONTROUTE",
-		"MSG_DONTWAIT",
-		"MSG_EOF",
-		"MSG_EOR",
-		"MSG_ERRQUEUE",
-		"MSG_FASTOPEN",
-		"MSG_FIN",
-		"MSG_FLUSH",
-		"MSG_HAVEMORE",
-		"MSG_HOLD",
-		"MSG_IOVUSRSPACE",
-		"MSG_LENUSRSPACE",
-		"MSG_MCAST",
-		"MSG_MORE",
-		"MSG_NAMEMBUF",
-		"MSG_NBIO",
-		"MSG_NEEDSA",
-		"MSG_NOSIGNAL",
-		"MSG_NOTIFICATION",
-		"MSG_OOB",
-		"MSG_PEEK",
-		"MSG_PROXY",
-		"MSG_RCVMORE",
-		"MSG_RST",
-		"MSG_SEND",
-		"MSG_SYN",
-		"MSG_TRUNC",
-		"MSG_TRYHARD",
-		"MSG_USERFLAGS",
-		"MSG_WAITALL",
-		"MSG_WAITFORONE",
-		"MSG_WAITSTREAM",
-		"MS_ACTIVE",
-		"MS_ASYNC",
-		"MS_BIND",
-		"MS_DEACTIVATE",
-		"MS_DIRSYNC",
-		"MS_INVALIDATE",
-		"MS_I_VERSION",
-		"MS_KERNMOUNT",
-		"MS_KILLPAGES",
-		"MS_MANDLOCK",
-		"MS_MGC_MSK",
-		"MS_MGC_VAL",
-		"MS_MOVE",
-		"MS_NOATIME",
-		"MS_NODEV",
-		"MS_NODIRATIME",
-		"MS_NOEXEC",
-		"MS_NOSUID",
-		"MS_NOUSER",
-		"MS_POSIXACL",
-		"MS_PRIVATE",
-		"MS_RDONLY",
-		"MS_REC",
-		"MS_RELATIME",
-		"MS_REMOUNT",
-		"MS_RMT_MASK",
-		"MS_SHARED",
-		"MS_SILENT",
-		"MS_SLAVE",
-		"MS_STRICTATIME",
-		"MS_SYNC",
-		"MS_SYNCHRONOUS",
-		"MS_UNBINDABLE",
-		"Madvise",
-		"MapViewOfFile",
-		"MaxTokenInfoClass",
-		"Mclpool",
-		"MibIfRow",
-		"Mkdir",
-		"Mkdirat",
-		"Mkfifo",
-		"Mknod",
-		"Mknodat",
-		"Mlock",
-		"Mlockall",
-		"Mmap",
-		"Mount",
-		"MoveFile",
-		"Mprotect",
-		"Msghdr",
-		"Munlock",
-		"Munlockall",
-		"Munmap",
-		"MustLoadDLL",
-		"NAME_MAX",
-		"NETLINK_ADD_MEMBERSHIP",
-		"NETLINK_AUDIT",
-		"NETLINK_BROADCAST_ERROR",
-		"NETLINK_CONNECTOR",
-		"NETLINK_DNRTMSG",
-		"NETLINK_DROP_MEMBERSHIP",
-		"NETLINK_ECRYPTFS",
-		"NETLINK_FIB_LOOKUP",
-		"NETLINK_FIREWALL",
-		"NETLINK_GENERIC",
-		"NETLINK_INET_DIAG",
-		"NETLINK_IP6_FW",
-		"NETLINK_ISCSI",
-		"NETLINK_KOBJECT_UEVENT",
-		"NETLINK_NETFILTER",
-		"NETLINK_NFLOG",
-		"NETLINK_NO_ENOBUFS",
-		"NETLINK_PKTINFO",
-		"NETLINK_RDMA",
-		"NETLINK_ROUTE",
-		"NETLINK_SCSITRANSPORT",
-		"NETLINK_SELINUX",
-		"NETLINK_UNUSED",
-		"NETLINK_USERSOCK",
-		"NETLINK_XFRM",
-		"NET_RT_DUMP",
-		"NET_RT_DUMP2",
-		"NET_RT_FLAGS",
-		"NET_RT_IFLIST",
-		"NET_RT_IFLIST2",
-		"NET_RT_IFLISTL",
-		"NET_RT_IFMALIST",
-		"NET_RT_MAXID",
-		"NET_RT_OIFLIST",
-		"NET_RT_OOIFLIST",
-		"NET_RT_STAT",
-		"NET_RT_STATS",
-		"NET_RT_TABLE",
-		"NET_RT_TRASH",
-		"NLA_ALIGNTO",
-		"NLA_F_NESTED",
-		"NLA_F_NET_BYTEORDER",
-		"NLA_HDRLEN",
-		"NLMSG_ALIGNTO",
-		"NLMSG_DONE",
-		"NLMSG_ERROR",
-		"NLMSG_HDRLEN",
-		"NLMSG_MIN_TYPE",
-		"NLMSG_NOOP",
-		"NLMSG_OVERRUN",
-		"NLM_F_ACK",
-		"NLM_F_APPEND",
-		"NLM_F_ATOMIC",
-		"NLM_F_CREATE",
-		"NLM_F_DUMP",
-		"NLM_F_ECHO",
-		"NLM_F_EXCL",
-		"NLM_F_MATCH",
-		"NLM_F_MULTI",
-		"NLM_F_REPLACE",
-		"NLM_F_REQUEST",
-		"NLM_F_ROOT",
-		"NOFLSH",
-		"NOTE_ABSOLUTE",
-		"NOTE_ATTRIB",
-		"NOTE_CHILD",
-		"NOTE_DELETE",
-		"NOTE_EOF",
-		"NOTE_EXEC",
-		"NOTE_EXIT",
-		"NOTE_EXITSTATUS",
-		"NOTE_EXTEND",
-		"NOTE_FFAND",
-		"NOTE_FFCOPY",
-		"NOTE_FFCTRLMASK",
-		"NOTE_FFLAGSMASK",
-		"NOTE_FFNOP",
-		"NOTE_FFOR",
-		"NOTE_FORK",
-		"NOTE_LINK",
-		"NOTE_LOWAT",
-		"NOTE_NONE",
-		"NOTE_NSECONDS",
-		"NOTE_PCTRLMASK",
-		"NOTE_PDATAMASK",
-		"NOTE_REAP",
-		"NOTE_RENAME",
-		"NOTE_RESOURCEEND",
-		"NOTE_REVOKE",
-		"NOTE_SECONDS",
-		"NOTE_SIGNAL",
-		"NOTE_TRACK",
-		"NOTE_TRACKERR",
-		"NOTE_TRIGGER",
-		"NOTE_TRUNCATE",
-		"NOTE_USECONDS",
-		"NOTE_VM_ERROR",
-		"NOTE_VM_PRESSURE",
-		"NOTE_VM_PRESSURE_SUDDEN_TERMINATE",
-		"NOTE_VM_PRESSURE_TERMINATE",
-		"NOTE_WRITE",
-		"NameCanonical",
-		"NameCanonicalEx",
-		"NameDisplay",
-		"NameDnsDomain",
-		"NameFullyQualifiedDN",
-		"NameSamCompatible",
-		"NameServicePrincipal",
-		"NameUniqueId",
-		"NameUnknown",
-		"NameUserPrincipal",
-		"Nanosleep",
-		"NetApiBufferFree",
-		"NetGetJoinInformation",
-		"NetSetupDomainName",
-		"NetSetupUnjoined",
-		"NetSetupUnknownStatus",
-		"NetSetupWorkgroupName",
-		"NetUserGetInfo",
-		"NetlinkMessage",
-		"NetlinkRIB",
-		"NetlinkRouteAttr",
-		"NetlinkRouteRequest",
-		"NewCallback",
-		"NewCallbackCDecl",
-		"NewLazyDLL",
-		"NlAttr",
-		"NlMsgerr",
-		"NlMsghdr",
-		"NsecToFiletime",
-		"NsecToTimespec",
-		"NsecToTimeval",
-		"Ntohs",
-		"OCRNL",
-		"OFDEL",
-		"OFILL",
-		"OFIOGETBMAP",
-		"OID_PKIX_KP_SERVER_AUTH",
-		"OID_SERVER_GATED_CRYPTO",
-		"OID_SGC_NETSCAPE",
-		"OLCUC",
-		"ONLCR",
-		"ONLRET",
-		"ONOCR",
-		"ONOEOT",
-		"OPEN_ALWAYS",
-		"OPEN_EXISTING",
-		"OPOST",
-		"O_ACCMODE",
-		"O_ALERT",
-		"O_ALT_IO",
-		"O_APPEND",
-		"O_ASYNC",
-		"O_CLOEXEC",
-		"O_CREAT",
-		"O_DIRECT",
-		"O_DIRECTORY",
-		"O_DSYNC",
-		"O_EVTONLY",
-		"O_EXCL",
-		"O_EXEC",
-		"O_EXLOCK",
-		"O_FSYNC",
-		"O_LARGEFILE",
-		"O_NDELAY",
-		"O_NOATIME",
-		"O_NOCTTY",
-		"O_NOFOLLOW",
-		"O_NONBLOCK",
-		"O_NOSIGPIPE",
-		"O_POPUP",
-		"O_RDONLY",
-		"O_RDWR",
-		"O_RSYNC",
-		"O_SHLOCK",
-		"O_SYMLINK",
-		"O_SYNC",
-		"O_TRUNC",
-		"O_TTY_INIT",
-		"O_WRONLY",
-		"Open",
-		"OpenCurrentProcessToken",
-		"OpenProcess",
-		"OpenProcessToken",
-		"Openat",
-		"Overlapped",
-		"PACKET_ADD_MEMBERSHIP",
-		"PACKET_BROADCAST",
-		"PACKET_DROP_MEMBERSHIP",
-		"PACKET_FASTROUTE",
-		"PACKET_HOST",
-		"PACKET_LOOPBACK",
-		"PACKET_MR_ALLMULTI",
-		"PACKET_MR_MULTICAST",
-		"PACKET_MR_PROMISC",
-		"PACKET_MULTICAST",
-		"PACKET_OTHERHOST",
-		"PACKET_OUTGOING",
-		"PACKET_RECV_OUTPUT",
-		"PACKET_RX_RING",
-		"PACKET_STATISTICS",
-		"PAGE_EXECUTE_READ",
-		"PAGE_EXECUTE_READWRITE",
-		"PAGE_EXECUTE_WRITECOPY",
-		"PAGE_READONLY",
-		"PAGE_READWRITE",
-		"PAGE_WRITECOPY",
-		"PARENB",
-		"PARMRK",
-		"PARODD",
-		"PENDIN",
-		"PFL_HIDDEN",
-		"PFL_MATCHES_PROTOCOL_ZERO",
-		"PFL_MULTIPLE_PROTO_ENTRIES",
-		"PFL_NETWORKDIRECT_PROVIDER",
-		"PFL_RECOMMENDED_PROTO_ENTRY",
-		"PF_FLUSH",
-		"PKCS_7_ASN_ENCODING",
-		"PMC5_PIPELINE_FLUSH",
-		"PRIO_PGRP",
-		"PRIO_PROCESS",
-		"PRIO_USER",
-		"PRI_IOFLUSH",
-		"PROCESS_QUERY_INFORMATION",
-		"PROCESS_TERMINATE",
-		"PROT_EXEC",
-		"PROT_GROWSDOWN",
-		"PROT_GROWSUP",
-		"PROT_NONE",
-		"PROT_READ",
-		"PROT_WRITE",
-		"PROV_DH_SCHANNEL",
-		"PROV_DSS",
-		"PROV_DSS_DH",
-		"PROV_EC_ECDSA_FULL",
-		"PROV_EC_ECDSA_SIG",
-		"PROV_EC_ECNRA_FULL",
-		"PROV_EC_ECNRA_SIG",
-		"PROV_FORTEZZA",
-		"PROV_INTEL_SEC",
-		"PROV_MS_EXCHANGE",
-		"PROV_REPLACE_OWF",
-		"PROV_RNG",
-		"PROV_RSA_AES",
-		"PROV_RSA_FULL",
-		"PROV_RSA_SCHANNEL",
-		"PROV_RSA_SIG",
-		"PROV_SPYRUS_LYNKS",
-		"PROV_SSL",
-		"PR_CAPBSET_DROP",
-		"PR_CAPBSET_READ",
-		"PR_CLEAR_SECCOMP_FILTER",
-		"PR_ENDIAN_BIG",
-		"PR_ENDIAN_LITTLE",
-		"PR_ENDIAN_PPC_LITTLE",
-		"PR_FPEMU_NOPRINT",
-		"PR_FPEMU_SIGFPE",
-		"PR_FP_EXC_ASYNC",
-		"PR_FP_EXC_DISABLED",
-		"PR_FP_EXC_DIV",
-		"PR_FP_EXC_INV",
-		"PR_FP_EXC_NONRECOV",
-		"PR_FP_EXC_OVF",
-		"PR_FP_EXC_PRECISE",
-		"PR_FP_EXC_RES",
-		"PR_FP_EXC_SW_ENABLE",
-		"PR_FP_EXC_UND",
-		"PR_GET_DUMPABLE",
-		"PR_GET_ENDIAN",
-		"PR_GET_FPEMU",
-		"PR_GET_FPEXC",
-		"PR_GET_KEEPCAPS",
-		"PR_GET_NAME",
-		"PR_GET_PDEATHSIG",
-		"PR_GET_SECCOMP",
-		"PR_GET_SECCOMP_FILTER",
-		"PR_GET_SECUREBITS",
-		"PR_GET_TIMERSLACK",
-		"PR_GET_TIMING",
-		"PR_GET_TSC",
-		"PR_GET_UNALIGN",
-		"PR_MCE_KILL",
-		"PR_MCE_KILL_CLEAR",
-		"PR_MCE_KILL_DEFAULT",
-		"PR_MCE_KILL_EARLY",
-		"PR_MCE_KILL_GET",
-		"PR_MCE_KILL_LATE",
-		"PR_MCE_KILL_SET",
-		"PR_SECCOMP_FILTER_EVENT",
-		"PR_SECCOMP_FILTER_SYSCALL",
-		"PR_SET_DUMPABLE",
-		"PR_SET_ENDIAN",
-		"PR_SET_FPEMU",
-		"PR_SET_FPEXC",
-		"PR_SET_KEEPCAPS",
-		"PR_SET_NAME",
-		"PR_SET_PDEATHSIG",
-		"PR_SET_PTRACER",
-		"PR_SET_SECCOMP",
-		"PR_SET_SECCOMP_FILTER",
-		"PR_SET_SECUREBITS",
-		"PR_SET_TIMERSLACK",
-		"PR_SET_TIMING",
-		"PR_SET_TSC",
-		"PR_SET_UNALIGN",
-		"PR_TASK_PERF_EVENTS_DISABLE",
-		"PR_TASK_PERF_EVENTS_ENABLE",
-		"PR_TIMING_STATISTICAL",
-		"PR_TIMING_TIMESTAMP",
-		"PR_TSC_ENABLE",
-		"PR_TSC_SIGSEGV",
-		"PR_UNALIGN_NOPRINT",
-		"PR_UNALIGN_SIGBUS",
-		"PTRACE_ARCH_PRCTL",
-		"PTRACE_ATTACH",
-		"PTRACE_CONT",
-		"PTRACE_DETACH",
-		"PTRACE_EVENT_CLONE",
-		"PTRACE_EVENT_EXEC",
-		"PTRACE_EVENT_EXIT",
-		"PTRACE_EVENT_FORK",
-		"PTRACE_EVENT_VFORK",
-		"PTRACE_EVENT_VFORK_DONE",
-		"PTRACE_GETCRUNCHREGS",
-		"PTRACE_GETEVENTMSG",
-		"PTRACE_GETFPREGS",
-		"PTRACE_GETFPXREGS",
-		"PTRACE_GETHBPREGS",
-		"PTRACE_GETREGS",
-		"PTRACE_GETREGSET",
-		"PTRACE_GETSIGINFO",
-		"PTRACE_GETVFPREGS",
-		"PTRACE_GETWMMXREGS",
-		"PTRACE_GET_THREAD_AREA",
-		"PTRACE_KILL",
-		"PTRACE_OLDSETOPTIONS",
-		"PTRACE_O_MASK",
-		"PTRACE_O_TRACECLONE",
-		"PTRACE_O_TRACEEXEC",
-		"PTRACE_O_TRACEEXIT",
-		"PTRACE_O_TRACEFORK",
-		"PTRACE_O_TRACESYSGOOD",
-		"PTRACE_O_TRACEVFORK",
-		"PTRACE_O_TRACEVFORKDONE",
-		"PTRACE_PEEKDATA",
-		"PTRACE_PEEKTEXT",
-		"PTRACE_PEEKUSR",
-		"PTRACE_POKEDATA",
-		"PTRACE_POKETEXT",
-		"PTRACE_POKEUSR",
-		"PTRACE_SETCRUNCHREGS",
-		"PTRACE_SETFPREGS",
-		"PTRACE_SETFPXREGS",
-		"PTRACE_SETHBPREGS",
-		"PTRACE_SETOPTIONS",
-		"PTRACE_SETREGS",
-		"PTRACE_SETREGSET",
-		"PTRACE_SETSIGINFO",
-		"PTRACE_SETVFPREGS",
-		"PTRACE_SETWMMXREGS",
-		"PTRACE_SET_SYSCALL",
-		"PTRACE_SET_THREAD_AREA",
-		"PTRACE_SINGLEBLOCK",
-		"PTRACE_SINGLESTEP",
-		"PTRACE_SYSCALL",
-		"PTRACE_SYSEMU",
-		"PTRACE_SYSEMU_SINGLESTEP",
-		"PTRACE_TRACEME",
-		"PT_ATTACH",
-		"PT_ATTACHEXC",
-		"PT_CONTINUE",
-		"PT_DATA_ADDR",
-		"PT_DENY_ATTACH",
-		"PT_DETACH",
-		"PT_FIRSTMACH",
-		"PT_FORCEQUOTA",
-		"PT_KILL",
-		"PT_MASK",
-		"PT_READ_D",
-		"PT_READ_I",
-		"PT_READ_U",
-		"PT_SIGEXC",
-		"PT_STEP",
-		"PT_TEXT_ADDR",
-		"PT_TEXT_END_ADDR",
-		"PT_THUPDATE",
-		"PT_TRACE_ME",
-		"PT_WRITE_D",
-		"PT_WRITE_I",
-		"PT_WRITE_U",
-		"ParseDirent",
-		"ParseNetlinkMessage",
-		"ParseNetlinkRouteAttr",
-		"ParseRoutingMessage",
-		"ParseRoutingSockaddr",
-		"ParseSocketControlMessage",
-		"ParseUnixCredentials",
-		"ParseUnixRights",
-		"PathMax",
-		"Pathconf",
-		"Pause",
-		"Pipe",
-		"Pipe2",
-		"PivotRoot",
-		"Pointer",
-		"PostQueuedCompletionStatus",
-		"Pread",
-		"Proc",
-		"ProcAttr",
-		"Process32First",
-		"Process32Next",
-		"ProcessEntry32",
-		"ProcessInformation",
-		"Protoent",
-		"PtraceAttach",
-		"PtraceCont",
-		"PtraceDetach",
-		"PtraceGetEventMsg",
-		"PtraceGetRegs",
-		"PtracePeekData",
-		"PtracePeekText",
-		"PtracePokeData",
-		"PtracePokeText",
-		"PtraceRegs",
-		"PtraceSetOptions",
-		"PtraceSetRegs",
-		"PtraceSingleStep",
-		"PtraceSyscall",
-		"Pwrite",
-		"REG_BINARY",
-		"REG_DWORD",
-		"REG_DWORD_BIG_ENDIAN",
-		"REG_DWORD_LITTLE_ENDIAN",
-		"REG_EXPAND_SZ",
-		"REG_FULL_RESOURCE_DESCRIPTOR",
-		"REG_LINK",
-		"REG_MULTI_SZ",
-		"REG_NONE",
-		"REG_QWORD",
-		"REG_QWORD_LITTLE_ENDIAN",
-		"REG_RESOURCE_LIST",
-		"REG_RESOURCE_REQUIREMENTS_LIST",
-		"REG_SZ",
-		"RLIMIT_AS",
-		"RLIMIT_CORE",
-		"RLIMIT_CPU",
-		"RLIMIT_DATA",
-		"RLIMIT_FSIZE",
-		"RLIMIT_NOFILE",
-		"RLIMIT_STACK",
-		"RLIM_INFINITY",
-		"RTAX_ADVMSS",
-		"RTAX_AUTHOR",
-		"RTAX_BRD",
-		"RTAX_CWND",
-		"RTAX_DST",
-		"RTAX_FEATURES",
-		"RTAX_FEATURE_ALLFRAG",
-		"RTAX_FEATURE_ECN",
-		"RTAX_FEATURE_SACK",
-		"RTAX_FEATURE_TIMESTAMP",
-		"RTAX_GATEWAY",
-		"RTAX_GENMASK",
-		"RTAX_HOPLIMIT",
-		"RTAX_IFA",
-		"RTAX_IFP",
-		"RTAX_INITCWND",
-		"RTAX_INITRWND",
-		"RTAX_LABEL",
-		"RTAX_LOCK",
-		"RTAX_MAX",
-		"RTAX_MTU",
-		"RTAX_NETMASK",
-		"RTAX_REORDERING",
-		"RTAX_RTO_MIN",
-		"RTAX_RTT",
-		"RTAX_RTTVAR",
-		"RTAX_SRC",
-		"RTAX_SRCMASK",
-		"RTAX_SSTHRESH",
-		"RTAX_TAG",
-		"RTAX_UNSPEC",
-		"RTAX_WINDOW",
-		"RTA_ALIGNTO",
-		"RTA_AUTHOR",
-		"RTA_BRD",
-		"RTA_CACHEINFO",
-		"RTA_DST",
-		"RTA_FLOW",
-		"RTA_GATEWAY",
-		"RTA_GENMASK",
-		"RTA_IFA",
-		"RTA_IFP",
-		"RTA_IIF",
-		"RTA_LABEL",
-		"RTA_MAX",
-		"RTA_METRICS",
-		"RTA_MULTIPATH",
-		"RTA_NETMASK",
-		"RTA_OIF",
-		"RTA_PREFSRC",
-		"RTA_PRIORITY",
-		"RTA_SRC",
-		"RTA_SRCMASK",
-		"RTA_TABLE",
-		"RTA_TAG",
-		"RTA_UNSPEC",
-		"RTCF_DIRECTSRC",
-		"RTCF_DOREDIRECT",
-		"RTCF_LOG",
-		"RTCF_MASQ",
-		"RTCF_NAT",
-		"RTCF_VALVE",
-		"RTF_ADDRCLASSMASK",
-		"RTF_ADDRCONF",
-		"RTF_ALLONLINK",
-		"RTF_ANNOUNCE",
-		"RTF_BLACKHOLE",
-		"RTF_BROADCAST",
-		"RTF_CACHE",
-		"RTF_CLONED",
-		"RTF_CLONING",
-		"RTF_CONDEMNED",
-		"RTF_DEFAULT",
-		"RTF_DELCLONE",
-		"RTF_DONE",
-		"RTF_DYNAMIC",
-		"RTF_FLOW",
-		"RTF_FMASK",
-		"RTF_GATEWAY",
-		"RTF_GWFLAG_COMPAT",
-		"RTF_HOST",
-		"RTF_IFREF",
-		"RTF_IFSCOPE",
-		"RTF_INTERFACE",
-		"RTF_IRTT",
-		"RTF_LINKRT",
-		"RTF_LLDATA",
-		"RTF_LLINFO",
-		"RTF_LOCAL",
-		"RTF_MASK",
-		"RTF_MODIFIED",
-		"RTF_MPATH",
-		"RTF_MPLS",
-		"RTF_MSS",
-		"RTF_MTU",
-		"RTF_MULTICAST",
-		"RTF_NAT",
-		"RTF_NOFORWARD",
-		"RTF_NONEXTHOP",
-		"RTF_NOPMTUDISC",
-		"RTF_PERMANENT_ARP",
-		"RTF_PINNED",
-		"RTF_POLICY",
-		"RTF_PRCLONING",
-		"RTF_PROTO1",
-		"RTF_PROTO2",
-		"RTF_PROTO3",
-		"RTF_REINSTATE",
-		"RTF_REJECT",
-		"RTF_RNH_LOCKED",
-		"RTF_SOURCE",
-		"RTF_SRC",
-		"RTF_STATIC",
-		"RTF_STICKY",
-		"RTF_THROW",
-		"RTF_TUNNEL",
-		"RTF_UP",
-		"RTF_USETRAILERS",
-		"RTF_WASCLONED",
-		"RTF_WINDOW",
-		"RTF_XRESOLVE",
-		"RTM_ADD",
-		"RTM_BASE",
-		"RTM_CHANGE",
-		"RTM_CHGADDR",
-		"RTM_DELACTION",
-		"RTM_DELADDR",
-		"RTM_DELADDRLABEL",
-		"RTM_DELETE",
-		"RTM_DELLINK",
-		"RTM_DELMADDR",
-		"RTM_DELNEIGH",
-		"RTM_DELQDISC",
-		"RTM_DELROUTE",
-		"RTM_DELRULE",
-		"RTM_DELTCLASS",
-		"RTM_DELTFILTER",
-		"RTM_DESYNC",
-		"RTM_F_CLONED",
-		"RTM_F_EQUALIZE",
-		"RTM_F_NOTIFY",
-		"RTM_F_PREFIX",
-		"RTM_GET",
-		"RTM_GET2",
-		"RTM_GETACTION",
-		"RTM_GETADDR",
-		"RTM_GETADDRLABEL",
-		"RTM_GETANYCAST",
-		"RTM_GETDCB",
-		"RTM_GETLINK",
-		"RTM_GETMULTICAST",
-		"RTM_GETNEIGH",
-		"RTM_GETNEIGHTBL",
-		"RTM_GETQDISC",
-		"RTM_GETROUTE",
-		"RTM_GETRULE",
-		"RTM_GETTCLASS",
-		"RTM_GETTFILTER",
-		"RTM_IEEE80211",
-		"RTM_IFANNOUNCE",
-		"RTM_IFINFO",
-		"RTM_IFINFO2",
-		"RTM_LLINFO_UPD",
-		"RTM_LOCK",
-		"RTM_LOSING",
-		"RTM_MAX",
-		"RTM_MAXSIZE",
-		"RTM_MISS",
-		"RTM_NEWACTION",
-		"RTM_NEWADDR",
-		"RTM_NEWADDRLABEL",
-		"RTM_NEWLINK",
-		"RTM_NEWMADDR",
-		"RTM_NEWMADDR2",
-		"RTM_NEWNDUSEROPT",
-		"RTM_NEWNEIGH",
-		"RTM_NEWNEIGHTBL",
-		"RTM_NEWPREFIX",
-		"RTM_NEWQDISC",
-		"RTM_NEWROUTE",
-		"RTM_NEWRULE",
-		"RTM_NEWTCLASS",
-		"RTM_NEWTFILTER",
-		"RTM_NR_FAMILIES",
-		"RTM_NR_MSGTYPES",
-		"RTM_OIFINFO",
-		"RTM_OLDADD",
-		"RTM_OLDDEL",
-		"RTM_OOIFINFO",
-		"RTM_REDIRECT",
-		"RTM_RESOLVE",
-		"RTM_RTTUNIT",
-		"RTM_SETDCB",
-		"RTM_SETGATE",
-		"RTM_SETLINK",
-		"RTM_SETNEIGHTBL",
-		"RTM_VERSION",
-		"RTNH_ALIGNTO",
-		"RTNH_F_DEAD",
-		"RTNH_F_ONLINK",
-		"RTNH_F_PERVASIVE",
-		"RTNLGRP_IPV4_IFADDR",
-		"RTNLGRP_IPV4_MROUTE",
-		"RTNLGRP_IPV4_ROUTE",
-		"RTNLGRP_IPV4_RULE",
-		"RTNLGRP_IPV6_IFADDR",
-		"RTNLGRP_IPV6_IFINFO",
-		"RTNLGRP_IPV6_MROUTE",
-		"RTNLGRP_IPV6_PREFIX",
-		"RTNLGRP_IPV6_ROUTE",
-		"RTNLGRP_IPV6_RULE",
-		"RTNLGRP_LINK",
-		"RTNLGRP_ND_USEROPT",
-		"RTNLGRP_NEIGH",
-		"RTNLGRP_NONE",
-		"RTNLGRP_NOTIFY",
-		"RTNLGRP_TC",
-		"RTN_ANYCAST",
-		"RTN_BLACKHOLE",
-		"RTN_BROADCAST",
-		"RTN_LOCAL",
-		"RTN_MAX",
-		"RTN_MULTICAST",
-		"RTN_NAT",
-		"RTN_PROHIBIT",
-		"RTN_THROW",
-		"RTN_UNICAST",
-		"RTN_UNREACHABLE",
-		"RTN_UNSPEC",
-		"RTN_XRESOLVE",
-		"RTPROT_BIRD",
-		"RTPROT_BOOT",
-		"RTPROT_DHCP",
-		"RTPROT_DNROUTED",
-		"RTPROT_GATED",
-		"RTPROT_KERNEL",
-		"RTPROT_MRT",
-		"RTPROT_NTK",
-		"RTPROT_RA",
-		"RTPROT_REDIRECT",
-		"RTPROT_STATIC",
-		"RTPROT_UNSPEC",
-		"RTPROT_XORP",
-		"RTPROT_ZEBRA",
-		"RTV_EXPIRE",
-		"RTV_HOPCOUNT",
-		"RTV_MTU",
-		"RTV_RPIPE",
-		"RTV_RTT",
-		"RTV_RTTVAR",
-		"RTV_SPIPE",
-		"RTV_SSTHRESH",
-		"RTV_WEIGHT",
-		"RT_CACHING_CONTEXT",
-		"RT_CLASS_DEFAULT",
-		"RT_CLASS_LOCAL",
-		"RT_CLASS_MAIN",
-		"RT_CLASS_MAX",
-		"RT_CLASS_UNSPEC",
-		"RT_DEFAULT_FIB",
-		"RT_NORTREF",
-		"RT_SCOPE_HOST",
-		"RT_SCOPE_LINK",
-		"RT_SCOPE_NOWHERE",
-		"RT_SCOPE_SITE",
-		"RT_SCOPE_UNIVERSE",
-		"RT_TABLEID_MAX",
-		"RT_TABLE_COMPAT",
-		"RT_TABLE_DEFAULT",
-		"RT_TABLE_LOCAL",
-		"RT_TABLE_MAIN",
-		"RT_TABLE_MAX",
-		"RT_TABLE_UNSPEC",
-		"RUSAGE_CHILDREN",
-		"RUSAGE_SELF",
-		"RUSAGE_THREAD",
-		"Radvisory_t",
-		"RawConn",
-		"RawSockaddr",
-		"RawSockaddrAny",
-		"RawSockaddrDatalink",
-		"RawSockaddrInet4",
-		"RawSockaddrInet6",
-		"RawSockaddrLinklayer",
-		"RawSockaddrNetlink",
-		"RawSockaddrUnix",
-		"RawSyscall",
-		"RawSyscall6",
-		"Read",
-		"ReadConsole",
-		"ReadDirectoryChanges",
-		"ReadDirent",
-		"ReadFile",
-		"Readlink",
-		"Reboot",
-		"Recvfrom",
-		"Recvmsg",
-		"RegCloseKey",
-		"RegEnumKeyEx",
-		"RegOpenKeyEx",
-		"RegQueryInfoKey",
-		"RegQueryValueEx",
-		"RemoveDirectory",
-		"Removexattr",
-		"Rename",
-		"Renameat",
-		"Revoke",
-		"Rlimit",
-		"Rmdir",
-		"RouteMessage",
-		"RouteRIB",
-		"RoutingMessage",
-		"RtAttr",
-		"RtGenmsg",
-		"RtMetrics",
-		"RtMsg",
-		"RtMsghdr",
-		"RtNexthop",
-		"Rusage",
-		"SCM_BINTIME",
-		"SCM_CREDENTIALS",
-		"SCM_CREDS",
-		"SCM_RIGHTS",
-		"SCM_TIMESTAMP",
-		"SCM_TIMESTAMPING",
-		"SCM_TIMESTAMPNS",
-		"SCM_TIMESTAMP_MONOTONIC",
-		"SHUT_RD",
-		"SHUT_RDWR",
-		"SHUT_WR",
-		"SID",
-		"SIDAndAttributes",
-		"SIGABRT",
-		"SIGALRM",
-		"SIGBUS",
-		"SIGCHLD",
-		"SIGCLD",
-		"SIGCONT",
-		"SIGEMT",
-		"SIGFPE",
-		"SIGHUP",
-		"SIGILL",
-		"SIGINFO",
-		"SIGINT",
-		"SIGIO",
-		"SIGIOT",
-		"SIGKILL",
-		"SIGLIBRT",
-		"SIGLWP",
-		"SIGPIPE",
-		"SIGPOLL",
-		"SIGPROF",
-		"SIGPWR",
-		"SIGQUIT",
-		"SIGSEGV",
-		"SIGSTKFLT",
-		"SIGSTOP",
-		"SIGSYS",
-		"SIGTERM",
-		"SIGTHR",
-		"SIGTRAP",
-		"SIGTSTP",
-		"SIGTTIN",
-		"SIGTTOU",
-		"SIGUNUSED",
-		"SIGURG",
-		"SIGUSR1",
-		"SIGUSR2",
-		"SIGVTALRM",
-		"SIGWINCH",
-		"SIGXCPU",
-		"SIGXFSZ",
-		"SIOCADDDLCI",
-		"SIOCADDMULTI",
-		"SIOCADDRT",
-		"SIOCAIFADDR",
-		"SIOCAIFGROUP",
-		"SIOCALIFADDR",
-		"SIOCARPIPLL",
-		"SIOCATMARK",
-		"SIOCAUTOADDR",
-		"SIOCAUTONETMASK",
-		"SIOCBRDGADD",
-		"SIOCBRDGADDS",
-		"SIOCBRDGARL",
-		"SIOCBRDGDADDR",
-		"SIOCBRDGDEL",
-		"SIOCBRDGDELS",
-		"SIOCBRDGFLUSH",
-		"SIOCBRDGFRL",
-		"SIOCBRDGGCACHE",
-		"SIOCBRDGGFD",
-		"SIOCBRDGGHT",
-		"SIOCBRDGGIFFLGS",
-		"SIOCBRDGGMA",
-		"SIOCBRDGGPARAM",
-		"SIOCBRDGGPRI",
-		"SIOCBRDGGRL",
-		"SIOCBRDGGSIFS",
-		"SIOCBRDGGTO",
-		"SIOCBRDGIFS",
-		"SIOCBRDGRTS",
-		"SIOCBRDGSADDR",
-		"SIOCBRDGSCACHE",
-		"SIOCBRDGSFD",
-		"SIOCBRDGSHT",
-		"SIOCBRDGSIFCOST",
-		"SIOCBRDGSIFFLGS",
-		"SIOCBRDGSIFPRIO",
-		"SIOCBRDGSMA",
-		"SIOCBRDGSPRI",
-		"SIOCBRDGSPROTO",
-		"SIOCBRDGSTO",
-		"SIOCBRDGSTXHC",
-		"SIOCDARP",
-		"SIOCDELDLCI",
-		"SIOCDELMULTI",
-		"SIOCDELRT",
-		"SIOCDEVPRIVATE",
-		"SIOCDIFADDR",
-		"SIOCDIFGROUP",
-		"SIOCDIFPHYADDR",
-		"SIOCDLIFADDR",
-		"SIOCDRARP",
-		"SIOCGARP",
-		"SIOCGDRVSPEC",
-		"SIOCGETKALIVE",
-		"SIOCGETLABEL",
-		"SIOCGETPFLOW",
-		"SIOCGETPFSYNC",
-		"SIOCGETSGCNT",
-		"SIOCGETVIFCNT",
-		"SIOCGETVLAN",
-		"SIOCGHIWAT",
-		"SIOCGIFADDR",
-		"SIOCGIFADDRPREF",
-		"SIOCGIFALIAS",
-		"SIOCGIFALTMTU",
-		"SIOCGIFASYNCMAP",
-		"SIOCGIFBOND",
-		"SIOCGIFBR",
-		"SIOCGIFBRDADDR",
-		"SIOCGIFCAP",
-		"SIOCGIFCONF",
-		"SIOCGIFCOUNT",
-		"SIOCGIFDATA",
-		"SIOCGIFDESCR",
-		"SIOCGIFDEVMTU",
-		"SIOCGIFDLT",
-		"SIOCGIFDSTADDR",
-		"SIOCGIFENCAP",
-		"SIOCGIFFIB",
-		"SIOCGIFFLAGS",
-		"SIOCGIFGATTR",
-		"SIOCGIFGENERIC",
-		"SIOCGIFGMEMB",
-		"SIOCGIFGROUP",
-		"SIOCGIFHARDMTU",
-		"SIOCGIFHWADDR",
-		"SIOCGIFINDEX",
-		"SIOCGIFKPI",
-		"SIOCGIFMAC",
-		"SIOCGIFMAP",
-		"SIOCGIFMEDIA",
-		"SIOCGIFMEM",
-		"SIOCGIFMETRIC",
-		"SIOCGIFMTU",
-		"SIOCGIFNAME",
-		"SIOCGIFNETMASK",
-		"SIOCGIFPDSTADDR",
-		"SIOCGIFPFLAGS",
-		"SIOCGIFPHYS",
-		"SIOCGIFPRIORITY",
-		"SIOCGIFPSRCADDR",
-		"SIOCGIFRDOMAIN",
-		"SIOCGIFRTLABEL",
-		"SIOCGIFSLAVE",
-		"SIOCGIFSTATUS",
-		"SIOCGIFTIMESLOT",
-		"SIOCGIFTXQLEN",
-		"SIOCGIFVLAN",
-		"SIOCGIFWAKEFLAGS",
-		"SIOCGIFXFLAGS",
-		"SIOCGLIFADDR",
-		"SIOCGLIFPHYADDR",
-		"SIOCGLIFPHYRTABLE",
-		"SIOCGLIFPHYTTL",
-		"SIOCGLINKSTR",
-		"SIOCGLOWAT",
-		"SIOCGPGRP",
-		"SIOCGPRIVATE_0",
-		"SIOCGPRIVATE_1",
-		"SIOCGRARP",
-		"SIOCGSPPPPARAMS",
-		"SIOCGSTAMP",
-		"SIOCGSTAMPNS",
-		"SIOCGVH",
-		"SIOCGVNETID",
-		"SIOCIFCREATE",
-		"SIOCIFCREATE2",
-		"SIOCIFDESTROY",
-		"SIOCIFGCLONERS",
-		"SIOCINITIFADDR",
-		"SIOCPROTOPRIVATE",
-		"SIOCRSLVMULTI",
-		"SIOCRTMSG",
-		"SIOCSARP",
-		"SIOCSDRVSPEC",
-		"SIOCSETKALIVE",
-		"SIOCSETLABEL",
-		"SIOCSETPFLOW",
-		"SIOCSETPFSYNC",
-		"SIOCSETVLAN",
-		"SIOCSHIWAT",
-		"SIOCSIFADDR",
-		"SIOCSIFADDRPREF",
-		"SIOCSIFALTMTU",
-		"SIOCSIFASYNCMAP",
-		"SIOCSIFBOND",
-		"SIOCSIFBR",
-		"SIOCSIFBRDADDR",
-		"SIOCSIFCAP",
-		"SIOCSIFDESCR",
-		"SIOCSIFDSTADDR",
-		"SIOCSIFENCAP",
-		"SIOCSIFFIB",
-		"SIOCSIFFLAGS",
-		"SIOCSIFGATTR",
-		"SIOCSIFGENERIC",
-		"SIOCSIFHWADDR",
-		"SIOCSIFHWBROADCAST",
-		"SIOCSIFKPI",
-		"SIOCSIFLINK",
-		"SIOCSIFLLADDR",
-		"SIOCSIFMAC",
-		"SIOCSIFMAP",
-		"SIOCSIFMEDIA",
-		"SIOCSIFMEM",
-		"SIOCSIFMETRIC",
-		"SIOCSIFMTU",
-		"SIOCSIFNAME",
-		"SIOCSIFNETMASK",
-		"SIOCSIFPFLAGS",
-		"SIOCSIFPHYADDR",
-		"SIOCSIFPHYS",
-		"SIOCSIFPRIORITY",
-		"SIOCSIFRDOMAIN",
-		"SIOCSIFRTLABEL",
-		"SIOCSIFRVNET",
-		"SIOCSIFSLAVE",
-		"SIOCSIFTIMESLOT",
-		"SIOCSIFTXQLEN",
-		"SIOCSIFVLAN",
-		"SIOCSIFVNET",
-		"SIOCSIFXFLAGS",
-		"SIOCSLIFPHYADDR",
-		"SIOCSLIFPHYRTABLE",
-		"SIOCSLIFPHYTTL",
-		"SIOCSLINKSTR",
-		"SIOCSLOWAT",
-		"SIOCSPGRP",
-		"SIOCSRARP",
-		"SIOCSSPPPPARAMS",
-		"SIOCSVH",
-		"SIOCSVNETID",
-		"SIOCZIFDATA",
-		"SIO_GET_EXTENSION_FUNCTION_POINTER",
-		"SIO_GET_INTERFACE_LIST",
-		"SIO_KEEPALIVE_VALS",
-		"SIO_UDP_CONNRESET",
-		"SOCK_CLOEXEC",
-		"SOCK_DCCP",
-		"SOCK_DGRAM",
-		"SOCK_FLAGS_MASK",
-		"SOCK_MAXADDRLEN",
-		"SOCK_NONBLOCK",
-		"SOCK_NOSIGPIPE",
-		"SOCK_PACKET",
-		"SOCK_RAW",
-		"SOCK_RDM",
-		"SOCK_SEQPACKET",
-		"SOCK_STREAM",
-		"SOL_AAL",
-		"SOL_ATM",
-		"SOL_DECNET",
-		"SOL_ICMPV6",
-		"SOL_IP",
-		"SOL_IPV6",
-		"SOL_IRDA",
-		"SOL_PACKET",
-		"SOL_RAW",
-		"SOL_SOCKET",
-		"SOL_TCP",
-		"SOL_X25",
-		"SOMAXCONN",
-		"SO_ACCEPTCONN",
-		"SO_ACCEPTFILTER",
-		"SO_ATTACH_FILTER",
-		"SO_BINDANY",
-		"SO_BINDTODEVICE",
-		"SO_BINTIME",
-		"SO_BROADCAST",
-		"SO_BSDCOMPAT",
-		"SO_DEBUG",
-		"SO_DETACH_FILTER",
-		"SO_DOMAIN",
-		"SO_DONTROUTE",
-		"SO_DONTTRUNC",
-		"SO_ERROR",
-		"SO_KEEPALIVE",
-		"SO_LABEL",
-		"SO_LINGER",
-		"SO_LINGER_SEC",
-		"SO_LISTENINCQLEN",
-		"SO_LISTENQLEN",
-		"SO_LISTENQLIMIT",
-		"SO_MARK",
-		"SO_NETPROC",
-		"SO_NKE",
-		"SO_NOADDRERR",
-		"SO_NOHEADER",
-		"SO_NOSIGPIPE",
-		"SO_NOTIFYCONFLICT",
-		"SO_NO_CHECK",
-		"SO_NO_DDP",
-		"SO_NO_OFFLOAD",
-		"SO_NP_EXTENSIONS",
-		"SO_NREAD",
-		"SO_NWRITE",
-		"SO_OOBINLINE",
-		"SO_OVERFLOWED",
-		"SO_PASSCRED",
-		"SO_PASSSEC",
-		"SO_PEERCRED",
-		"SO_PEERLABEL",
-		"SO_PEERNAME",
-		"SO_PEERSEC",
-		"SO_PRIORITY",
-		"SO_PROTOCOL",
-		"SO_PROTOTYPE",
-		"SO_RANDOMPORT",
-		"SO_RCVBUF",
-		"SO_RCVBUFFORCE",
-		"SO_RCVLOWAT",
-		"SO_RCVTIMEO",
-		"SO_RESTRICTIONS",
-		"SO_RESTRICT_DENYIN",
-		"SO_RESTRICT_DENYOUT",
-		"SO_RESTRICT_DENYSET",
-		"SO_REUSEADDR",
-		"SO_REUSEPORT",
-		"SO_REUSESHAREUID",
-		"SO_RTABLE",
-		"SO_RXQ_OVFL",
-		"SO_SECURITY_AUTHENTICATION",
-		"SO_SECURITY_ENCRYPTION_NETWORK",
-		"SO_SECURITY_ENCRYPTION_TRANSPORT",
-		"SO_SETFIB",
-		"SO_SNDBUF",
-		"SO_SNDBUFFORCE",
-		"SO_SNDLOWAT",
-		"SO_SNDTIMEO",
-		"SO_SPLICE",
-		"SO_TIMESTAMP",
-		"SO_TIMESTAMPING",
-		"SO_TIMESTAMPNS",
-		"SO_TIMESTAMP_MONOTONIC",
-		"SO_TYPE",
-		"SO_UPCALLCLOSEWAIT",
-		"SO_UPDATE_ACCEPT_CONTEXT",
-		"SO_UPDATE_CONNECT_CONTEXT",
-		"SO_USELOOPBACK",
-		"SO_USER_COOKIE",
-		"SO_VENDOR",
-		"SO_WANTMORE",
-		"SO_WANTOOBFLAG",
-		"SSLExtraCertChainPolicyPara",
-		"STANDARD_RIGHTS_ALL",
-		"STANDARD_RIGHTS_EXECUTE",
-		"STANDARD_RIGHTS_READ",
-		"STANDARD_RIGHTS_REQUIRED",
-		"STANDARD_RIGHTS_WRITE",
-		"STARTF_USESHOWWINDOW",
-		"STARTF_USESTDHANDLES",
-		"STD_ERROR_HANDLE",
-		"STD_INPUT_HANDLE",
-		"STD_OUTPUT_HANDLE",
-		"SUBLANG_ENGLISH_US",
-		"SW_FORCEMINIMIZE",
-		"SW_HIDE",
-		"SW_MAXIMIZE",
-		"SW_MINIMIZE",
-		"SW_NORMAL",
-		"SW_RESTORE",
-		"SW_SHOW",
-		"SW_SHOWDEFAULT",
-		"SW_SHOWMAXIMIZED",
-		"SW_SHOWMINIMIZED",
-		"SW_SHOWMINNOACTIVE",
-		"SW_SHOWNA",
-		"SW_SHOWNOACTIVATE",
-		"SW_SHOWNORMAL",
-		"SYMBOLIC_LINK_FLAG_DIRECTORY",
-		"SYNCHRONIZE",
-		"SYSCTL_VERSION",
-		"SYSCTL_VERS_0",
-		"SYSCTL_VERS_1",
-		"SYSCTL_VERS_MASK",
-		"SYS_ABORT2",
-		"SYS_ACCEPT",
-		"SYS_ACCEPT4",
-		"SYS_ACCEPT_NOCANCEL",
-		"SYS_ACCESS",
-		"SYS_ACCESS_EXTENDED",
-		"SYS_ACCT",
-		"SYS_ADD_KEY",
-		"SYS_ADD_PROFIL",
-		"SYS_ADJFREQ",
-		"SYS_ADJTIME",
-		"SYS_ADJTIMEX",
-		"SYS_AFS_SYSCALL",
-		"SYS_AIO_CANCEL",
-		"SYS_AIO_ERROR",
-		"SYS_AIO_FSYNC",
-		"SYS_AIO_READ",
-		"SYS_AIO_RETURN",
-		"SYS_AIO_SUSPEND",
-		"SYS_AIO_SUSPEND_NOCANCEL",
-		"SYS_AIO_WRITE",
-		"SYS_ALARM",
-		"SYS_ARCH_PRCTL",
-		"SYS_ARM_FADVISE64_64",
-		"SYS_ARM_SYNC_FILE_RANGE",
-		"SYS_ATGETMSG",
-		"SYS_ATPGETREQ",
-		"SYS_ATPGETRSP",
-		"SYS_ATPSNDREQ",
-		"SYS_ATPSNDRSP",
-		"SYS_ATPUTMSG",
-		"SYS_ATSOCKET",
-		"SYS_AUDIT",
-		"SYS_AUDITCTL",
-		"SYS_AUDITON",
-		"SYS_AUDIT_SESSION_JOIN",
-		"SYS_AUDIT_SESSION_PORT",
-		"SYS_AUDIT_SESSION_SELF",
-		"SYS_BDFLUSH",
-		"SYS_BIND",
-		"SYS_BINDAT",
-		"SYS_BREAK",
-		"SYS_BRK",
-		"SYS_BSDTHREAD_CREATE",
-		"SYS_BSDTHREAD_REGISTER",
-		"SYS_BSDTHREAD_TERMINATE",
-		"SYS_CAPGET",
-		"SYS_CAPSET",
-		"SYS_CAP_ENTER",
-		"SYS_CAP_FCNTLS_GET",
-		"SYS_CAP_FCNTLS_LIMIT",
-		"SYS_CAP_GETMODE",
-		"SYS_CAP_GETRIGHTS",
-		"SYS_CAP_IOCTLS_GET",
-		"SYS_CAP_IOCTLS_LIMIT",
-		"SYS_CAP_NEW",
-		"SYS_CAP_RIGHTS_GET",
-		"SYS_CAP_RIGHTS_LIMIT",
-		"SYS_CHDIR",
-		"SYS_CHFLAGS",
-		"SYS_CHFLAGSAT",
-		"SYS_CHMOD",
-		"SYS_CHMOD_EXTENDED",
-		"SYS_CHOWN",
-		"SYS_CHOWN32",
-		"SYS_CHROOT",
-		"SYS_CHUD",
-		"SYS_CLOCK_ADJTIME",
-		"SYS_CLOCK_GETCPUCLOCKID2",
-		"SYS_CLOCK_GETRES",
-		"SYS_CLOCK_GETTIME",
-		"SYS_CLOCK_NANOSLEEP",
-		"SYS_CLOCK_SETTIME",
-		"SYS_CLONE",
-		"SYS_CLOSE",
-		"SYS_CLOSEFROM",
-		"SYS_CLOSE_NOCANCEL",
-		"SYS_CONNECT",
-		"SYS_CONNECTAT",
-		"SYS_CONNECT_NOCANCEL",
-		"SYS_COPYFILE",
-		"SYS_CPUSET",
-		"SYS_CPUSET_GETAFFINITY",
-		"SYS_CPUSET_GETID",
-		"SYS_CPUSET_SETAFFINITY",
-		"SYS_CPUSET_SETID",
-		"SYS_CREAT",
-		"SYS_CREATE_MODULE",
-		"SYS_CSOPS",
-		"SYS_DELETE",
-		"SYS_DELETE_MODULE",
-		"SYS_DUP",
-		"SYS_DUP2",
-		"SYS_DUP3",
-		"SYS_EACCESS",
-		"SYS_EPOLL_CREATE",
-		"SYS_EPOLL_CREATE1",
-		"SYS_EPOLL_CTL",
-		"SYS_EPOLL_CTL_OLD",
-		"SYS_EPOLL_PWAIT",
-		"SYS_EPOLL_WAIT",
-		"SYS_EPOLL_WAIT_OLD",
-		"SYS_EVENTFD",
-		"SYS_EVENTFD2",
-		"SYS_EXCHANGEDATA",
-		"SYS_EXECVE",
-		"SYS_EXIT",
-		"SYS_EXIT_GROUP",
-		"SYS_EXTATTRCTL",
-		"SYS_EXTATTR_DELETE_FD",
-		"SYS_EXTATTR_DELETE_FILE",
-		"SYS_EXTATTR_DELETE_LINK",
-		"SYS_EXTATTR_GET_FD",
-		"SYS_EXTATTR_GET_FILE",
-		"SYS_EXTATTR_GET_LINK",
-		"SYS_EXTATTR_LIST_FD",
-		"SYS_EXTATTR_LIST_FILE",
-		"SYS_EXTATTR_LIST_LINK",
-		"SYS_EXTATTR_SET_FD",
-		"SYS_EXTATTR_SET_FILE",
-		"SYS_EXTATTR_SET_LINK",
-		"SYS_FACCESSAT",
-		"SYS_FADVISE64",
-		"SYS_FADVISE64_64",
-		"SYS_FALLOCATE",
-		"SYS_FANOTIFY_INIT",
-		"SYS_FANOTIFY_MARK",
-		"SYS_FCHDIR",
-		"SYS_FCHFLAGS",
-		"SYS_FCHMOD",
-		"SYS_FCHMODAT",
-		"SYS_FCHMOD_EXTENDED",
-		"SYS_FCHOWN",
-		"SYS_FCHOWN32",
-		"SYS_FCHOWNAT",
-		"SYS_FCHROOT",
-		"SYS_FCNTL",
-		"SYS_FCNTL64",
-		"SYS_FCNTL_NOCANCEL",
-		"SYS_FDATASYNC",
-		"SYS_FEXECVE",
-		"SYS_FFCLOCK_GETCOUNTER",
-		"SYS_FFCLOCK_GETESTIMATE",
-		"SYS_FFCLOCK_SETESTIMATE",
-		"SYS_FFSCTL",
-		"SYS_FGETATTRLIST",
-		"SYS_FGETXATTR",
-		"SYS_FHOPEN",
-		"SYS_FHSTAT",
-		"SYS_FHSTATFS",
-		"SYS_FILEPORT_MAKEFD",
-		"SYS_FILEPORT_MAKEPORT",
-		"SYS_FKTRACE",
-		"SYS_FLISTXATTR",
-		"SYS_FLOCK",
-		"SYS_FORK",
-		"SYS_FPATHCONF",
-		"SYS_FREEBSD6_FTRUNCATE",
-		"SYS_FREEBSD6_LSEEK",
-		"SYS_FREEBSD6_MMAP",
-		"SYS_FREEBSD6_PREAD",
-		"SYS_FREEBSD6_PWRITE",
-		"SYS_FREEBSD6_TRUNCATE",
-		"SYS_FREMOVEXATTR",
-		"SYS_FSCTL",
-		"SYS_FSETATTRLIST",
-		"SYS_FSETXATTR",
-		"SYS_FSGETPATH",
-		"SYS_FSTAT",
-		"SYS_FSTAT64",
-		"SYS_FSTAT64_EXTENDED",
-		"SYS_FSTATAT",
-		"SYS_FSTATAT64",
-		"SYS_FSTATFS",
-		"SYS_FSTATFS64",
-		"SYS_FSTATV",
-		"SYS_FSTATVFS1",
-		"SYS_FSTAT_EXTENDED",
-		"SYS_FSYNC",
-		"SYS_FSYNC_NOCANCEL",
-		"SYS_FSYNC_RANGE",
-		"SYS_FTIME",
-		"SYS_FTRUNCATE",
-		"SYS_FTRUNCATE64",
-		"SYS_FUTEX",
-		"SYS_FUTIMENS",
-		"SYS_FUTIMES",
-		"SYS_FUTIMESAT",
-		"SYS_GETATTRLIST",
-		"SYS_GETAUDIT",
-		"SYS_GETAUDIT_ADDR",
-		"SYS_GETAUID",
-		"SYS_GETCONTEXT",
-		"SYS_GETCPU",
-		"SYS_GETCWD",
-		"SYS_GETDENTS",
-		"SYS_GETDENTS64",
-		"SYS_GETDIRENTRIES",
-		"SYS_GETDIRENTRIES64",
-		"SYS_GETDIRENTRIESATTR",
-		"SYS_GETDTABLECOUNT",
-		"SYS_GETDTABLESIZE",
-		"SYS_GETEGID",
-		"SYS_GETEGID32",
-		"SYS_GETEUID",
-		"SYS_GETEUID32",
-		"SYS_GETFH",
-		"SYS_GETFSSTAT",
-		"SYS_GETFSSTAT64",
-		"SYS_GETGID",
-		"SYS_GETGID32",
-		"SYS_GETGROUPS",
-		"SYS_GETGROUPS32",
-		"SYS_GETHOSTUUID",
-		"SYS_GETITIMER",
-		"SYS_GETLCID",
-		"SYS_GETLOGIN",
-		"SYS_GETLOGINCLASS",
-		"SYS_GETPEERNAME",
-		"SYS_GETPGID",
-		"SYS_GETPGRP",
-		"SYS_GETPID",
-		"SYS_GETPMSG",
-		"SYS_GETPPID",
-		"SYS_GETPRIORITY",
-		"SYS_GETRESGID",
-		"SYS_GETRESGID32",
-		"SYS_GETRESUID",
-		"SYS_GETRESUID32",
-		"SYS_GETRLIMIT",
-		"SYS_GETRTABLE",
-		"SYS_GETRUSAGE",
-		"SYS_GETSGROUPS",
-		"SYS_GETSID",
-		"SYS_GETSOCKNAME",
-		"SYS_GETSOCKOPT",
-		"SYS_GETTHRID",
-		"SYS_GETTID",
-		"SYS_GETTIMEOFDAY",
-		"SYS_GETUID",
-		"SYS_GETUID32",
-		"SYS_GETVFSSTAT",
-		"SYS_GETWGROUPS",
-		"SYS_GETXATTR",
-		"SYS_GET_KERNEL_SYMS",
-		"SYS_GET_MEMPOLICY",
-		"SYS_GET_ROBUST_LIST",
-		"SYS_GET_THREAD_AREA",
-		"SYS_GTTY",
-		"SYS_IDENTITYSVC",
-		"SYS_IDLE",
-		"SYS_INITGROUPS",
-		"SYS_INIT_MODULE",
-		"SYS_INOTIFY_ADD_WATCH",
-		"SYS_INOTIFY_INIT",
-		"SYS_INOTIFY_INIT1",
-		"SYS_INOTIFY_RM_WATCH",
-		"SYS_IOCTL",
-		"SYS_IOPERM",
-		"SYS_IOPL",
-		"SYS_IOPOLICYSYS",
-		"SYS_IOPRIO_GET",
-		"SYS_IOPRIO_SET",
-		"SYS_IO_CANCEL",
-		"SYS_IO_DESTROY",
-		"SYS_IO_GETEVENTS",
-		"SYS_IO_SETUP",
-		"SYS_IO_SUBMIT",
-		"SYS_IPC",
-		"SYS_ISSETUGID",
-		"SYS_JAIL",
-		"SYS_JAIL_ATTACH",
-		"SYS_JAIL_GET",
-		"SYS_JAIL_REMOVE",
-		"SYS_JAIL_SET",
-		"SYS_KDEBUG_TRACE",
-		"SYS_KENV",
-		"SYS_KEVENT",
-		"SYS_KEVENT64",
-		"SYS_KEXEC_LOAD",
-		"SYS_KEYCTL",
-		"SYS_KILL",
-		"SYS_KLDFIND",
-		"SYS_KLDFIRSTMOD",
-		"SYS_KLDLOAD",
-		"SYS_KLDNEXT",
-		"SYS_KLDSTAT",
-		"SYS_KLDSYM",
-		"SYS_KLDUNLOAD",
-		"SYS_KLDUNLOADF",
-		"SYS_KQUEUE",
-		"SYS_KQUEUE1",
-		"SYS_KTIMER_CREATE",
-		"SYS_KTIMER_DELETE",
-		"SYS_KTIMER_GETOVERRUN",
-		"SYS_KTIMER_GETTIME",
-		"SYS_KTIMER_SETTIME",
-		"SYS_KTRACE",
-		"SYS_LCHFLAGS",
-		"SYS_LCHMOD",
-		"SYS_LCHOWN",
-		"SYS_LCHOWN32",
-		"SYS_LGETFH",
-		"SYS_LGETXATTR",
-		"SYS_LINK",
-		"SYS_LINKAT",
-		"SYS_LIO_LISTIO",
-		"SYS_LISTEN",
-		"SYS_LISTXATTR",
-		"SYS_LLISTXATTR",
-		"SYS_LOCK",
-		"SYS_LOOKUP_DCOOKIE",
-		"SYS_LPATHCONF",
-		"SYS_LREMOVEXATTR",
-		"SYS_LSEEK",
-		"SYS_LSETXATTR",
-		"SYS_LSTAT",
-		"SYS_LSTAT64",
-		"SYS_LSTAT64_EXTENDED",
-		"SYS_LSTATV",
-		"SYS_LSTAT_EXTENDED",
-		"SYS_LUTIMES",
-		"SYS_MAC_SYSCALL",
-		"SYS_MADVISE",
-		"SYS_MADVISE1",
-		"SYS_MAXSYSCALL",
-		"SYS_MBIND",
-		"SYS_MIGRATE_PAGES",
-		"SYS_MINCORE",
-		"SYS_MINHERIT",
-		"SYS_MKCOMPLEX",
-		"SYS_MKDIR",
-		"SYS_MKDIRAT",
-		"SYS_MKDIR_EXTENDED",
-		"SYS_MKFIFO",
-		"SYS_MKFIFOAT",
-		"SYS_MKFIFO_EXTENDED",
-		"SYS_MKNOD",
-		"SYS_MKNODAT",
-		"SYS_MLOCK",
-		"SYS_MLOCKALL",
-		"SYS_MMAP",
-		"SYS_MMAP2",
-		"SYS_MODCTL",
-		"SYS_MODFIND",
-		"SYS_MODFNEXT",
-		"SYS_MODIFY_LDT",
-		"SYS_MODNEXT",
-		"SYS_MODSTAT",
-		"SYS_MODWATCH",
-		"SYS_MOUNT",
-		"SYS_MOVE_PAGES",
-		"SYS_MPROTECT",
-		"SYS_MPX",
-		"SYS_MQUERY",
-		"SYS_MQ_GETSETATTR",
-		"SYS_MQ_NOTIFY",
-		"SYS_MQ_OPEN",
-		"SYS_MQ_TIMEDRECEIVE",
-		"SYS_MQ_TIMEDSEND",
-		"SYS_MQ_UNLINK",
-		"SYS_MREMAP",
-		"SYS_MSGCTL",
-		"SYS_MSGGET",
-		"SYS_MSGRCV",
-		"SYS_MSGRCV_NOCANCEL",
-		"SYS_MSGSND",
-		"SYS_MSGSND_NOCANCEL",
-		"SYS_MSGSYS",
-		"SYS_MSYNC",
-		"SYS_MSYNC_NOCANCEL",
-		"SYS_MUNLOCK",
-		"SYS_MUNLOCKALL",
-		"SYS_MUNMAP",
-		"SYS_NAME_TO_HANDLE_AT",
-		"SYS_NANOSLEEP",
-		"SYS_NEWFSTATAT",
-		"SYS_NFSCLNT",
-		"SYS_NFSSERVCTL",
-		"SYS_NFSSVC",
-		"SYS_NFSTAT",
-		"SYS_NICE",
-		"SYS_NLSTAT",
-		"SYS_NMOUNT",
-		"SYS_NSTAT",
-		"SYS_NTP_ADJTIME",
-		"SYS_NTP_GETTIME",
-		"SYS_OABI_SYSCALL_BASE",
-		"SYS_OBREAK",
-		"SYS_OLDFSTAT",
-		"SYS_OLDLSTAT",
-		"SYS_OLDOLDUNAME",
-		"SYS_OLDSTAT",
-		"SYS_OLDUNAME",
-		"SYS_OPEN",
-		"SYS_OPENAT",
-		"SYS_OPENBSD_POLL",
-		"SYS_OPEN_BY_HANDLE_AT",
-		"SYS_OPEN_EXTENDED",
-		"SYS_OPEN_NOCANCEL",
-		"SYS_OVADVISE",
-		"SYS_PACCEPT",
-		"SYS_PATHCONF",
-		"SYS_PAUSE",
-		"SYS_PCICONFIG_IOBASE",
-		"SYS_PCICONFIG_READ",
-		"SYS_PCICONFIG_WRITE",
-		"SYS_PDFORK",
-		"SYS_PDGETPID",
-		"SYS_PDKILL",
-		"SYS_PERF_EVENT_OPEN",
-		"SYS_PERSONALITY",
-		"SYS_PID_HIBERNATE",
-		"SYS_PID_RESUME",
-		"SYS_PID_SHUTDOWN_SOCKETS",
-		"SYS_PID_SUSPEND",
-		"SYS_PIPE",
-		"SYS_PIPE2",
-		"SYS_PIVOT_ROOT",
-		"SYS_PMC_CONTROL",
-		"SYS_PMC_GET_INFO",
-		"SYS_POLL",
-		"SYS_POLLTS",
-		"SYS_POLL_NOCANCEL",
-		"SYS_POSIX_FADVISE",
-		"SYS_POSIX_FALLOCATE",
-		"SYS_POSIX_OPENPT",
-		"SYS_POSIX_SPAWN",
-		"SYS_PPOLL",
-		"SYS_PRCTL",
-		"SYS_PREAD",
-		"SYS_PREAD64",
-		"SYS_PREADV",
-		"SYS_PREAD_NOCANCEL",
-		"SYS_PRLIMIT64",
-		"SYS_PROCCTL",
-		"SYS_PROCESS_POLICY",
-		"SYS_PROCESS_VM_READV",
-		"SYS_PROCESS_VM_WRITEV",
-		"SYS_PROC_INFO",
-		"SYS_PROF",
-		"SYS_PROFIL",
-		"SYS_PSELECT",
-		"SYS_PSELECT6",
-		"SYS_PSET_ASSIGN",
-		"SYS_PSET_CREATE",
-		"SYS_PSET_DESTROY",
-		"SYS_PSYNCH_CVBROAD",
-		"SYS_PSYNCH_CVCLRPREPOST",
-		"SYS_PSYNCH_CVSIGNAL",
-		"SYS_PSYNCH_CVWAIT",
-		"SYS_PSYNCH_MUTEXDROP",
-		"SYS_PSYNCH_MUTEXWAIT",
-		"SYS_PSYNCH_RW_DOWNGRADE",
-		"SYS_PSYNCH_RW_LONGRDLOCK",
-		"SYS_PSYNCH_RW_RDLOCK",
-		"SYS_PSYNCH_RW_UNLOCK",
-		"SYS_PSYNCH_RW_UNLOCK2",
-		"SYS_PSYNCH_RW_UPGRADE",
-		"SYS_PSYNCH_RW_WRLOCK",
-		"SYS_PSYNCH_RW_YIELDWRLOCK",
-		"SYS_PTRACE",
-		"SYS_PUTPMSG",
-		"SYS_PWRITE",
-		"SYS_PWRITE64",
-		"SYS_PWRITEV",
-		"SYS_PWRITE_NOCANCEL",
-		"SYS_QUERY_MODULE",
-		"SYS_QUOTACTL",
-		"SYS_RASCTL",
-		"SYS_RCTL_ADD_RULE",
-		"SYS_RCTL_GET_LIMITS",
-		"SYS_RCTL_GET_RACCT",
-		"SYS_RCTL_GET_RULES",
-		"SYS_RCTL_REMOVE_RULE",
-		"SYS_READ",
-		"SYS_READAHEAD",
-		"SYS_READDIR",
-		"SYS_READLINK",
-		"SYS_READLINKAT",
-		"SYS_READV",
-		"SYS_READV_NOCANCEL",
-		"SYS_READ_NOCANCEL",
-		"SYS_REBOOT",
-		"SYS_RECV",
-		"SYS_RECVFROM",
-		"SYS_RECVFROM_NOCANCEL",
-		"SYS_RECVMMSG",
-		"SYS_RECVMSG",
-		"SYS_RECVMSG_NOCANCEL",
-		"SYS_REMAP_FILE_PAGES",
-		"SYS_REMOVEXATTR",
-		"SYS_RENAME",
-		"SYS_RENAMEAT",
-		"SYS_REQUEST_KEY",
-		"SYS_RESTART_SYSCALL",
-		"SYS_REVOKE",
-		"SYS_RFORK",
-		"SYS_RMDIR",
-		"SYS_RTPRIO",
-		"SYS_RTPRIO_THREAD",
-		"SYS_RT_SIGACTION",
-		"SYS_RT_SIGPENDING",
-		"SYS_RT_SIGPROCMASK",
-		"SYS_RT_SIGQUEUEINFO",
-		"SYS_RT_SIGRETURN",
-		"SYS_RT_SIGSUSPEND",
-		"SYS_RT_SIGTIMEDWAIT",
-		"SYS_RT_TGSIGQUEUEINFO",
-		"SYS_SBRK",
-		"SYS_SCHED_GETAFFINITY",
-		"SYS_SCHED_GETPARAM",
-		"SYS_SCHED_GETSCHEDULER",
-		"SYS_SCHED_GET_PRIORITY_MAX",
-		"SYS_SCHED_GET_PRIORITY_MIN",
-		"SYS_SCHED_RR_GET_INTERVAL",
-		"SYS_SCHED_SETAFFINITY",
-		"SYS_SCHED_SETPARAM",
-		"SYS_SCHED_SETSCHEDULER",
-		"SYS_SCHED_YIELD",
-		"SYS_SCTP_GENERIC_RECVMSG",
-		"SYS_SCTP_GENERIC_SENDMSG",
-		"SYS_SCTP_GENERIC_SENDMSG_IOV",
-		"SYS_SCTP_PEELOFF",
-		"SYS_SEARCHFS",
-		"SYS_SECURITY",
-		"SYS_SELECT",
-		"SYS_SELECT_NOCANCEL",
-		"SYS_SEMCONFIG",
-		"SYS_SEMCTL",
-		"SYS_SEMGET",
-		"SYS_SEMOP",
-		"SYS_SEMSYS",
-		"SYS_SEMTIMEDOP",
-		"SYS_SEM_CLOSE",
-		"SYS_SEM_DESTROY",
-		"SYS_SEM_GETVALUE",
-		"SYS_SEM_INIT",
-		"SYS_SEM_OPEN",
-		"SYS_SEM_POST",
-		"SYS_SEM_TRYWAIT",
-		"SYS_SEM_UNLINK",
-		"SYS_SEM_WAIT",
-		"SYS_SEM_WAIT_NOCANCEL",
-		"SYS_SEND",
-		"SYS_SENDFILE",
-		"SYS_SENDFILE64",
-		"SYS_SENDMMSG",
-		"SYS_SENDMSG",
-		"SYS_SENDMSG_NOCANCEL",
-		"SYS_SENDTO",
-		"SYS_SENDTO_NOCANCEL",
-		"SYS_SETATTRLIST",
-		"SYS_SETAUDIT",
-		"SYS_SETAUDIT_ADDR",
-		"SYS_SETAUID",
-		"SYS_SETCONTEXT",
-		"SYS_SETDOMAINNAME",
-		"SYS_SETEGID",
-		"SYS_SETEUID",
-		"SYS_SETFIB",
-		"SYS_SETFSGID",
-		"SYS_SETFSGID32",
-		"SYS_SETFSUID",
-		"SYS_SETFSUID32",
-		"SYS_SETGID",
-		"SYS_SETGID32",
-		"SYS_SETGROUPS",
-		"SYS_SETGROUPS32",
-		"SYS_SETHOSTNAME",
-		"SYS_SETITIMER",
-		"SYS_SETLCID",
-		"SYS_SETLOGIN",
-		"SYS_SETLOGINCLASS",
-		"SYS_SETNS",
-		"SYS_SETPGID",
-		"SYS_SETPRIORITY",
-		"SYS_SETPRIVEXEC",
-		"SYS_SETREGID",
-		"SYS_SETREGID32",
-		"SYS_SETRESGID",
-		"SYS_SETRESGID32",
-		"SYS_SETRESUID",
-		"SYS_SETRESUID32",
-		"SYS_SETREUID",
-		"SYS_SETREUID32",
-		"SYS_SETRLIMIT",
-		"SYS_SETRTABLE",
-		"SYS_SETSGROUPS",
-		"SYS_SETSID",
-		"SYS_SETSOCKOPT",
-		"SYS_SETTID",
-		"SYS_SETTID_WITH_PID",
-		"SYS_SETTIMEOFDAY",
-		"SYS_SETUID",
-		"SYS_SETUID32",
-		"SYS_SETWGROUPS",
-		"SYS_SETXATTR",
-		"SYS_SET_MEMPOLICY",
-		"SYS_SET_ROBUST_LIST",
-		"SYS_SET_THREAD_AREA",
-		"SYS_SET_TID_ADDRESS",
-		"SYS_SGETMASK",
-		"SYS_SHARED_REGION_CHECK_NP",
-		"SYS_SHARED_REGION_MAP_AND_SLIDE_NP",
-		"SYS_SHMAT",
-		"SYS_SHMCTL",
-		"SYS_SHMDT",
-		"SYS_SHMGET",
-		"SYS_SHMSYS",
-		"SYS_SHM_OPEN",
-		"SYS_SHM_UNLINK",
-		"SYS_SHUTDOWN",
-		"SYS_SIGACTION",
-		"SYS_SIGALTSTACK",
-		"SYS_SIGNAL",
-		"SYS_SIGNALFD",
-		"SYS_SIGNALFD4",
-		"SYS_SIGPENDING",
-		"SYS_SIGPROCMASK",
-		"SYS_SIGQUEUE",
-		"SYS_SIGQUEUEINFO",
-		"SYS_SIGRETURN",
-		"SYS_SIGSUSPEND",
-		"SYS_SIGSUSPEND_NOCANCEL",
-		"SYS_SIGTIMEDWAIT",
-		"SYS_SIGWAIT",
-		"SYS_SIGWAITINFO",
-		"SYS_SOCKET",
-		"SYS_SOCKETCALL",
-		"SYS_SOCKETPAIR",
-		"SYS_SPLICE",
-		"SYS_SSETMASK",
-		"SYS_SSTK",
-		"SYS_STACK_SNAPSHOT",
-		"SYS_STAT",
-		"SYS_STAT64",
-		"SYS_STAT64_EXTENDED",
-		"SYS_STATFS",
-		"SYS_STATFS64",
-		"SYS_STATV",
-		"SYS_STATVFS1",
-		"SYS_STAT_EXTENDED",
-		"SYS_STIME",
-		"SYS_STTY",
-		"SYS_SWAPCONTEXT",
-		"SYS_SWAPCTL",
-		"SYS_SWAPOFF",
-		"SYS_SWAPON",
-		"SYS_SYMLINK",
-		"SYS_SYMLINKAT",
-		"SYS_SYNC",
-		"SYS_SYNCFS",
-		"SYS_SYNC_FILE_RANGE",
-		"SYS_SYSARCH",
-		"SYS_SYSCALL",
-		"SYS_SYSCALL_BASE",
-		"SYS_SYSFS",
-		"SYS_SYSINFO",
-		"SYS_SYSLOG",
-		"SYS_TEE",
-		"SYS_TGKILL",
-		"SYS_THREAD_SELFID",
-		"SYS_THR_CREATE",
-		"SYS_THR_EXIT",
-		"SYS_THR_KILL",
-		"SYS_THR_KILL2",
-		"SYS_THR_NEW",
-		"SYS_THR_SELF",
-		"SYS_THR_SET_NAME",
-		"SYS_THR_SUSPEND",
-		"SYS_THR_WAKE",
-		"SYS_TIME",
-		"SYS_TIMERFD_CREATE",
-		"SYS_TIMERFD_GETTIME",
-		"SYS_TIMERFD_SETTIME",
-		"SYS_TIMER_CREATE",
-		"SYS_TIMER_DELETE",
-		"SYS_TIMER_GETOVERRUN",
-		"SYS_TIMER_GETTIME",
-		"SYS_TIMER_SETTIME",
-		"SYS_TIMES",
-		"SYS_TKILL",
-		"SYS_TRUNCATE",
-		"SYS_TRUNCATE64",
-		"SYS_TUXCALL",
-		"SYS_UGETRLIMIT",
-		"SYS_ULIMIT",
-		"SYS_UMASK",
-		"SYS_UMASK_EXTENDED",
-		"SYS_UMOUNT",
-		"SYS_UMOUNT2",
-		"SYS_UNAME",
-		"SYS_UNDELETE",
-		"SYS_UNLINK",
-		"SYS_UNLINKAT",
-		"SYS_UNMOUNT",
-		"SYS_UNSHARE",
-		"SYS_USELIB",
-		"SYS_USTAT",
-		"SYS_UTIME",
-		"SYS_UTIMENSAT",
-		"SYS_UTIMES",
-		"SYS_UTRACE",
-		"SYS_UUIDGEN",
-		"SYS_VADVISE",
-		"SYS_VFORK",
-		"SYS_VHANGUP",
-		"SYS_VM86",
-		"SYS_VM86OLD",
-		"SYS_VMSPLICE",
-		"SYS_VM_PRESSURE_MONITOR",
-		"SYS_VSERVER",
-		"SYS_WAIT4",
-		"SYS_WAIT4_NOCANCEL",
-		"SYS_WAIT6",
-		"SYS_WAITEVENT",
-		"SYS_WAITID",
-		"SYS_WAITID_NOCANCEL",
-		"SYS_WAITPID",
-		"SYS_WATCHEVENT",
-		"SYS_WORKQ_KERNRETURN",
-		"SYS_WORKQ_OPEN",
-		"SYS_WRITE",
-		"SYS_WRITEV",
-		"SYS_WRITEV_NOCANCEL",
-		"SYS_WRITE_NOCANCEL",
-		"SYS_YIELD",
-		"SYS__LLSEEK",
-		"SYS__LWP_CONTINUE",
-		"SYS__LWP_CREATE",
-		"SYS__LWP_CTL",
-		"SYS__LWP_DETACH",
-		"SYS__LWP_EXIT",
-		"SYS__LWP_GETNAME",
-		"SYS__LWP_GETPRIVATE",
-		"SYS__LWP_KILL",
-		"SYS__LWP_PARK",
-		"SYS__LWP_SELF",
-		"SYS__LWP_SETNAME",
-		"SYS__LWP_SETPRIVATE",
-		"SYS__LWP_SUSPEND",
-		"SYS__LWP_UNPARK",
-		"SYS__LWP_UNPARK_ALL",
-		"SYS__LWP_WAIT",
-		"SYS__LWP_WAKEUP",
-		"SYS__NEWSELECT",
-		"SYS__PSET_BIND",
-		"SYS__SCHED_GETAFFINITY",
-		"SYS__SCHED_GETPARAM",
-		"SYS__SCHED_SETAFFINITY",
-		"SYS__SCHED_SETPARAM",
-		"SYS__SYSCTL",
-		"SYS__UMTX_LOCK",
-		"SYS__UMTX_OP",
-		"SYS__UMTX_UNLOCK",
-		"SYS___ACL_ACLCHECK_FD",
-		"SYS___ACL_ACLCHECK_FILE",
-		"SYS___ACL_ACLCHECK_LINK",
-		"SYS___ACL_DELETE_FD",
-		"SYS___ACL_DELETE_FILE",
-		"SYS___ACL_DELETE_LINK",
-		"SYS___ACL_GET_FD",
-		"SYS___ACL_GET_FILE",
-		"SYS___ACL_GET_LINK",
-		"SYS___ACL_SET_FD",
-		"SYS___ACL_SET_FILE",
-		"SYS___ACL_SET_LINK",
-		"SYS___CLONE",
-		"SYS___DISABLE_THREADSIGNAL",
-		"SYS___GETCWD",
-		"SYS___GETLOGIN",
-		"SYS___GET_TCB",
-		"SYS___MAC_EXECVE",
-		"SYS___MAC_GETFSSTAT",
-		"SYS___MAC_GET_FD",
-		"SYS___MAC_GET_FILE",
-		"SYS___MAC_GET_LCID",
-		"SYS___MAC_GET_LCTX",
-		"SYS___MAC_GET_LINK",
-		"SYS___MAC_GET_MOUNT",
-		"SYS___MAC_GET_PID",
-		"SYS___MAC_GET_PROC",
-		"SYS___MAC_MOUNT",
-		"SYS___MAC_SET_FD",
-		"SYS___MAC_SET_FILE",
-		"SYS___MAC_SET_LCTX",
-		"SYS___MAC_SET_LINK",
-		"SYS___MAC_SET_PROC",
-		"SYS___MAC_SYSCALL",
-		"SYS___OLD_SEMWAIT_SIGNAL",
-		"SYS___OLD_SEMWAIT_SIGNAL_NOCANCEL",
-		"SYS___POSIX_CHOWN",
-		"SYS___POSIX_FCHOWN",
-		"SYS___POSIX_LCHOWN",
-		"SYS___POSIX_RENAME",
-		"SYS___PTHREAD_CANCELED",
-		"SYS___PTHREAD_CHDIR",
-		"SYS___PTHREAD_FCHDIR",
-		"SYS___PTHREAD_KILL",
-		"SYS___PTHREAD_MARKCANCEL",
-		"SYS___PTHREAD_SIGMASK",
-		"SYS___QUOTACTL",
-		"SYS___SEMCTL",
-		"SYS___SEMWAIT_SIGNAL",
-		"SYS___SEMWAIT_SIGNAL_NOCANCEL",
-		"SYS___SETLOGIN",
-		"SYS___SETUGID",
-		"SYS___SET_TCB",
-		"SYS___SIGACTION_SIGTRAMP",
-		"SYS___SIGTIMEDWAIT",
-		"SYS___SIGWAIT",
-		"SYS___SIGWAIT_NOCANCEL",
-		"SYS___SYSCTL",
-		"SYS___TFORK",
-		"SYS___THREXIT",
-		"SYS___THRSIGDIVERT",
-		"SYS___THRSLEEP",
-		"SYS___THRWAKEUP",
-		"S_ARCH1",
-		"S_ARCH2",
-		"S_BLKSIZE",
-		"S_IEXEC",
-		"S_IFBLK",
-		"S_IFCHR",
-		"S_IFDIR",
-		"S_IFIFO",
-		"S_IFLNK",
-		"S_IFMT",
-		"S_IFREG",
-		"S_IFSOCK",
-		"S_IFWHT",
-		"S_IREAD",
-		"S_IRGRP",
-		"S_IROTH",
-		"S_IRUSR",
-		"S_IRWXG",
-		"S_IRWXO",
-		"S_IRWXU",
-		"S_ISGID",
-		"S_ISTXT",
-		"S_ISUID",
-		"S_ISVTX",
-		"S_IWGRP",
-		"S_IWOTH",
-		"S_IWRITE",
-		"S_IWUSR",
-		"S_IXGRP",
-		"S_IXOTH",
-		"S_IXUSR",
-		"S_LOGIN_SET",
-		"SecurityAttributes",
-		"Seek",
-		"Select",
-		"Sendfile",
-		"Sendmsg",
-		"SendmsgN",
-		"Sendto",
-		"Servent",
-		"SetBpf",
-		"SetBpfBuflen",
-		"SetBpfDatalink",
-		"SetBpfHeadercmpl",
-		"SetBpfImmediate",
-		"SetBpfInterface",
-		"SetBpfPromisc",
-		"SetBpfTimeout",
-		"SetCurrentDirectory",
-		"SetEndOfFile",
-		"SetEnvironmentVariable",
-		"SetFileAttributes",
-		"SetFileCompletionNotificationModes",
-		"SetFilePointer",
-		"SetFileTime",
-		"SetHandleInformation",
-		"SetKevent",
-		"SetLsfPromisc",
-		"SetNonblock",
-		"Setdomainname",
-		"Setegid",
-		"Setenv",
-		"Seteuid",
-		"Setfsgid",
-		"Setfsuid",
-		"Setgid",
-		"Setgroups",
-		"Sethostname",
-		"Setlogin",
-		"Setpgid",
-		"Setpriority",
-		"Setprivexec",
-		"Setregid",
-		"Setresgid",
-		"Setresuid",
-		"Setreuid",
-		"Setrlimit",
-		"Setsid",
-		"Setsockopt",
-		"SetsockoptByte",
-		"SetsockoptICMPv6Filter",
-		"SetsockoptIPMreq",
-		"SetsockoptIPMreqn",
-		"SetsockoptIPv6Mreq",
-		"SetsockoptInet4Addr",
-		"SetsockoptInt",
-		"SetsockoptLinger",
-		"SetsockoptString",
-		"SetsockoptTimeval",
-		"Settimeofday",
-		"Setuid",
-		"Setxattr",
-		"Shutdown",
-		"SidTypeAlias",
-		"SidTypeComputer",
-		"SidTypeDeletedAccount",
-		"SidTypeDomain",
-		"SidTypeGroup",
-		"SidTypeInvalid",
-		"SidTypeLabel",
-		"SidTypeUnknown",
-		"SidTypeUser",
-		"SidTypeWellKnownGroup",
-		"Signal",
-		"SizeofBpfHdr",
-		"SizeofBpfInsn",
-		"SizeofBpfProgram",
-		"SizeofBpfStat",
-		"SizeofBpfVersion",
-		"SizeofBpfZbuf",
-		"SizeofBpfZbufHeader",
-		"SizeofCmsghdr",
-		"SizeofICMPv6Filter",
-		"SizeofIPMreq",
-		"SizeofIPMreqn",
-		"SizeofIPv6MTUInfo",
-		"SizeofIPv6Mreq",
-		"SizeofIfAddrmsg",
-		"SizeofIfAnnounceMsghdr",
-		"SizeofIfData",
-		"SizeofIfInfomsg",
-		"SizeofIfMsghdr",
-		"SizeofIfaMsghdr",
-		"SizeofIfmaMsghdr",
-		"SizeofIfmaMsghdr2",
-		"SizeofInet4Pktinfo",
-		"SizeofInet6Pktinfo",
-		"SizeofInotifyEvent",
-		"SizeofLinger",
-		"SizeofMsghdr",
-		"SizeofNlAttr",
-		"SizeofNlMsgerr",
-		"SizeofNlMsghdr",
-		"SizeofRtAttr",
-		"SizeofRtGenmsg",
-		"SizeofRtMetrics",
-		"SizeofRtMsg",
-		"SizeofRtMsghdr",
-		"SizeofRtNexthop",
-		"SizeofSockFilter",
-		"SizeofSockFprog",
-		"SizeofSockaddrAny",
-		"SizeofSockaddrDatalink",
-		"SizeofSockaddrInet4",
-		"SizeofSockaddrInet6",
-		"SizeofSockaddrLinklayer",
-		"SizeofSockaddrNetlink",
-		"SizeofSockaddrUnix",
-		"SizeofTCPInfo",
-		"SizeofUcred",
-		"SlicePtrFromStrings",
-		"SockFilter",
-		"SockFprog",
-		"Sockaddr",
-		"SockaddrDatalink",
-		"SockaddrGen",
-		"SockaddrInet4",
-		"SockaddrInet6",
-		"SockaddrLinklayer",
-		"SockaddrNetlink",
-		"SockaddrUnix",
-		"Socket",
-		"SocketControlMessage",
-		"SocketDisableIPv6",
-		"Socketpair",
-		"Splice",
-		"StartProcess",
-		"StartupInfo",
-		"Stat",
-		"Stat_t",
-		"Statfs",
-		"Statfs_t",
-		"Stderr",
-		"Stdin",
-		"Stdout",
-		"StringBytePtr",
-		"StringByteSlice",
-		"StringSlicePtr",
-		"StringToSid",
-		"StringToUTF16",
-		"StringToUTF16Ptr",
-		"Symlink",
-		"Sync",
-		"SyncFileRange",
-		"SysProcAttr",
-		"SysProcIDMap",
-		"Syscall",
-		"Syscall12",
-		"Syscall15",
-		"Syscall18",
-		"Syscall6",
-		"Syscall9",
-		"Sysctl",
-		"SysctlUint32",
-		"Sysctlnode",
-		"Sysinfo",
-		"Sysinfo_t",
-		"Systemtime",
-		"TCGETS",
-		"TCIFLUSH",
-		"TCIOFLUSH",
-		"TCOFLUSH",
-		"TCPInfo",
-		"TCPKeepalive",
-		"TCP_CA_NAME_MAX",
-		"TCP_CONGCTL",
-		"TCP_CONGESTION",
-		"TCP_CONNECTIONTIMEOUT",
-		"TCP_CORK",
-		"TCP_DEFER_ACCEPT",
-		"TCP_INFO",
-		"TCP_KEEPALIVE",
-		"TCP_KEEPCNT",
-		"TCP_KEEPIDLE",
-		"TCP_KEEPINIT",
-		"TCP_KEEPINTVL",
-		"TCP_LINGER2",
-		"TCP_MAXBURST",
-		"TCP_MAXHLEN",
-		"TCP_MAXOLEN",
-		"TCP_MAXSEG",
-		"TCP_MAXWIN",
-		"TCP_MAX_SACK",
-		"TCP_MAX_WINSHIFT",
-		"TCP_MD5SIG",
-		"TCP_MD5SIG_MAXKEYLEN",
-		"TCP_MINMSS",
-		"TCP_MINMSSOVERLOAD",
-		"TCP_MSS",
-		"TCP_NODELAY",
-		"TCP_NOOPT",
-		"TCP_NOPUSH",
-		"TCP_NSTATES",
-		"TCP_QUICKACK",
-		"TCP_RXT_CONNDROPTIME",
-		"TCP_RXT_FINDROP",
-		"TCP_SACK_ENABLE",
-		"TCP_SYNCNT",
-		"TCP_VENDOR",
-		"TCP_WINDOW_CLAMP",
-		"TCSAFLUSH",
-		"TCSETS",
-		"TF_DISCONNECT",
-		"TF_REUSE_SOCKET",
-		"TF_USE_DEFAULT_WORKER",
-		"TF_USE_KERNEL_APC",
-		"TF_USE_SYSTEM_THREAD",
-		"TF_WRITE_BEHIND",
-		"TH32CS_INHERIT",
-		"TH32CS_SNAPALL",
-		"TH32CS_SNAPHEAPLIST",
-		"TH32CS_SNAPMODULE",
-		"TH32CS_SNAPMODULE32",
-		"TH32CS_SNAPPROCESS",
-		"TH32CS_SNAPTHREAD",
-		"TIME_ZONE_ID_DAYLIGHT",
-		"TIME_ZONE_ID_STANDARD",
-		"TIME_ZONE_ID_UNKNOWN",
-		"TIOCCBRK",
-		"TIOCCDTR",
-		"TIOCCONS",
-		"TIOCDCDTIMESTAMP",
-		"TIOCDRAIN",
-		"TIOCDSIMICROCODE",
-		"TIOCEXCL",
-		"TIOCEXT",
-		"TIOCFLAG_CDTRCTS",
-		"TIOCFLAG_CLOCAL",
-		"TIOCFLAG_CRTSCTS",
-		"TIOCFLAG_MDMBUF",
-		"TIOCFLAG_PPS",
-		"TIOCFLAG_SOFTCAR",
-		"TIOCFLUSH",
-		"TIOCGDEV",
-		"TIOCGDRAINWAIT",
-		"TIOCGETA",
-		"TIOCGETD",
-		"TIOCGFLAGS",
-		"TIOCGICOUNT",
-		"TIOCGLCKTRMIOS",
-		"TIOCGLINED",
-		"TIOCGPGRP",
-		"TIOCGPTN",
-		"TIOCGQSIZE",
-		"TIOCGRANTPT",
-		"TIOCGRS485",
-		"TIOCGSERIAL",
-		"TIOCGSID",
-		"TIOCGSIZE",
-		"TIOCGSOFTCAR",
-		"TIOCGTSTAMP",
-		"TIOCGWINSZ",
-		"TIOCINQ",
-		"TIOCIXOFF",
-		"TIOCIXON",
-		"TIOCLINUX",
-		"TIOCMBIC",
-		"TIOCMBIS",
-		"TIOCMGDTRWAIT",
-		"TIOCMGET",
-		"TIOCMIWAIT",
-		"TIOCMODG",
-		"TIOCMODS",
-		"TIOCMSDTRWAIT",
-		"TIOCMSET",
-		"TIOCM_CAR",
-		"TIOCM_CD",
-		"TIOCM_CTS",
-		"TIOCM_DCD",
-		"TIOCM_DSR",
-		"TIOCM_DTR",
-		"TIOCM_LE",
-		"TIOCM_RI",
-		"TIOCM_RNG",
-		"TIOCM_RTS",
-		"TIOCM_SR",
-		"TIOCM_ST",
-		"TIOCNOTTY",
-		"TIOCNXCL",
-		"TIOCOUTQ",
-		"TIOCPKT",
-		"TIOCPKT_DATA",
-		"TIOCPKT_DOSTOP",
-		"TIOCPKT_FLUSHREAD",
-		"TIOCPKT_FLUSHWRITE",
-		"TIOCPKT_IOCTL",
-		"TIOCPKT_NOSTOP",
-		"TIOCPKT_START",
-		"TIOCPKT_STOP",
-		"TIOCPTMASTER",
-		"TIOCPTMGET",
-		"TIOCPTSNAME",
-		"TIOCPTYGNAME",
-		"TIOCPTYGRANT",
-		"TIOCPTYUNLK",
-		"TIOCRCVFRAME",
-		"TIOCREMOTE",
-		"TIOCSBRK",
-		"TIOCSCONS",
-		"TIOCSCTTY",
-		"TIOCSDRAINWAIT",
-		"TIOCSDTR",
-		"TIOCSERCONFIG",
-		"TIOCSERGETLSR",
-		"TIOCSERGETMULTI",
-		"TIOCSERGSTRUCT",
-		"TIOCSERGWILD",
-		"TIOCSERSETMULTI",
-		"TIOCSERSWILD",
-		"TIOCSER_TEMT",
-		"TIOCSETA",
-		"TIOCSETAF",
-		"TIOCSETAW",
-		"TIOCSETD",
-		"TIOCSFLAGS",
-		"TIOCSIG",
-		"TIOCSLCKTRMIOS",
-		"TIOCSLINED",
-		"TIOCSPGRP",
-		"TIOCSPTLCK",
-		"TIOCSQSIZE",
-		"TIOCSRS485",
-		"TIOCSSERIAL",
-		"TIOCSSIZE",
-		"TIOCSSOFTCAR",
-		"TIOCSTART",
-		"TIOCSTAT",
-		"TIOCSTI",
-		"TIOCSTOP",
-		"TIOCSTSTAMP",
-		"TIOCSWINSZ",
-		"TIOCTIMESTAMP",
-		"TIOCUCNTL",
-		"TIOCVHANGUP",
-		"TIOCXMTFRAME",
-		"TOKEN_ADJUST_DEFAULT",
-		"TOKEN_ADJUST_GROUPS",
-		"TOKEN_ADJUST_PRIVILEGES",
-		"TOKEN_ADJUST_SESSIONID",
-		"TOKEN_ALL_ACCESS",
-		"TOKEN_ASSIGN_PRIMARY",
-		"TOKEN_DUPLICATE",
-		"TOKEN_EXECUTE",
-		"TOKEN_IMPERSONATE",
-		"TOKEN_QUERY",
-		"TOKEN_QUERY_SOURCE",
-		"TOKEN_READ",
-		"TOKEN_WRITE",
-		"TOSTOP",
-		"TRUNCATE_EXISTING",
-		"TUNATTACHFILTER",
-		"TUNDETACHFILTER",
-		"TUNGETFEATURES",
-		"TUNGETIFF",
-		"TUNGETSNDBUF",
-		"TUNGETVNETHDRSZ",
-		"TUNSETDEBUG",
-		"TUNSETGROUP",
-		"TUNSETIFF",
-		"TUNSETLINK",
-		"TUNSETNOCSUM",
-		"TUNSETOFFLOAD",
-		"TUNSETOWNER",
-		"TUNSETPERSIST",
-		"TUNSETSNDBUF",
-		"TUNSETTXFILTER",
-		"TUNSETVNETHDRSZ",
-		"Tee",
-		"TerminateProcess",
-		"Termios",
-		"Tgkill",
-		"Time",
-		"Time_t",
-		"Times",
-		"Timespec",
-		"TimespecToNsec",
-		"Timeval",
-		"Timeval32",
-		"TimevalToNsec",
-		"Timex",
-		"Timezoneinformation",
-		"Tms",
-		"Token",
-		"TokenAccessInformation",
-		"TokenAuditPolicy",
-		"TokenDefaultDacl",
-		"TokenElevation",
-		"TokenElevationType",
-		"TokenGroups",
-		"TokenGroupsAndPrivileges",
-		"TokenHasRestrictions",
-		"TokenImpersonationLevel",
-		"TokenIntegrityLevel",
-		"TokenLinkedToken",
-		"TokenLogonSid",
-		"TokenMandatoryPolicy",
-		"TokenOrigin",
-		"TokenOwner",
-		"TokenPrimaryGroup",
-		"TokenPrivileges",
-		"TokenRestrictedSids",
-		"TokenSandBoxInert",
-		"TokenSessionId",
-		"TokenSessionReference",
-		"TokenSource",
-		"TokenStatistics",
-		"TokenType",
-		"TokenUIAccess",
-		"TokenUser",
-		"TokenVirtualizationAllowed",
-		"TokenVirtualizationEnabled",
-		"Tokenprimarygroup",
-		"Tokenuser",
-		"TranslateAccountName",
-		"TranslateName",
-		"TransmitFile",
-		"TransmitFileBuffers",
-		"Truncate",
-		"UNIX_PATH_MAX",
-		"USAGE_MATCH_TYPE_AND",
-		"USAGE_MATCH_TYPE_OR",
-		"UTF16FromString",
-		"UTF16PtrFromString",
-		"UTF16ToString",
-		"Ucred",
-		"Umask",
-		"Uname",
-		"Undelete",
-		"UnixCredentials",
-		"UnixRights",
-		"Unlink",
-		"Unlinkat",
-		"UnmapViewOfFile",
-		"Unmount",
-		"Unsetenv",
-		"Unshare",
-		"UserInfo10",
-		"Ustat",
-		"Ustat_t",
-		"Utimbuf",
-		"Utime",
-		"Utimes",
-		"UtimesNano",
-		"Utsname",
-		"VDISCARD",
-		"VDSUSP",
-		"VEOF",
-		"VEOL",
-		"VEOL2",
-		"VERASE",
-		"VERASE2",
-		"VINTR",
-		"VKILL",
-		"VLNEXT",
-		"VMIN",
-		"VQUIT",
-		"VREPRINT",
-		"VSTART",
-		"VSTATUS",
-		"VSTOP",
-		"VSUSP",
-		"VSWTC",
-		"VT0",
-		"VT1",
-		"VTDLY",
-		"VTIME",
-		"VWERASE",
-		"VirtualLock",
-		"VirtualUnlock",
-		"WAIT_ABANDONED",
-		"WAIT_FAILED",
-		"WAIT_OBJECT_0",
-		"WAIT_TIMEOUT",
-		"WALL",
-		"WALLSIG",
-		"WALTSIG",
-		"WCLONE",
-		"WCONTINUED",
-		"WCOREFLAG",
-		"WEXITED",
-		"WLINUXCLONE",
-		"WNOHANG",
-		"WNOTHREAD",
-		"WNOWAIT",
-		"WNOZOMBIE",
-		"WOPTSCHECKED",
-		"WORDSIZE",
-		"WSABuf",
-		"WSACleanup",
-		"WSADESCRIPTION_LEN",
-		"WSAData",
-		"WSAEACCES",
-		"WSAECONNABORTED",
-		"WSAECONNRESET",
-		"WSAEnumProtocols",
-		"WSAID_CONNECTEX",
-		"WSAIoctl",
-		"WSAPROTOCOL_LEN",
-		"WSAProtocolChain",
-		"WSAProtocolInfo",
-		"WSARecv",
-		"WSARecvFrom",
-		"WSASYS_STATUS_LEN",
-		"WSASend",
-		"WSASendTo",
-		"WSASendto",
-		"WSAStartup",
-		"WSTOPPED",
-		"WTRAPPED",
-		"WUNTRACED",
-		"Wait4",
-		"WaitForSingleObject",
-		"WaitStatus",
-		"Win32FileAttributeData",
-		"Win32finddata",
-		"Write",
-		"WriteConsole",
-		"WriteFile",
-		"X509_ASN_ENCODING",
-		"XCASE",
-		"XP1_CONNECTIONLESS",
-		"XP1_CONNECT_DATA",
-		"XP1_DISCONNECT_DATA",
-		"XP1_EXPEDITED_DATA",
-		"XP1_GRACEFUL_CLOSE",
-		"XP1_GUARANTEED_DELIVERY",
-		"XP1_GUARANTEED_ORDER",
-		"XP1_IFS_HANDLES",
-		"XP1_MESSAGE_ORIENTED",
-		"XP1_MULTIPOINT_CONTROL_PLANE",
-		"XP1_MULTIPOINT_DATA_PLANE",
-		"XP1_PARTIAL_MESSAGE",
-		"XP1_PSEUDO_STREAM",
-		"XP1_QOS_SUPPORTED",
-		"XP1_SAN_SUPPORT_SDP",
-		"XP1_SUPPORT_BROADCAST",
-		"XP1_SUPPORT_MULTIPOINT",
-		"XP1_UNI_RECV",
-		"XP1_UNI_SEND",
-	},
-	"syscall/js": {
-		"CopyBytesToGo",
-		"CopyBytesToJS",
-		"Error",
-		"Func",
-		"FuncOf",
-		"Global",
-		"Null",
-		"Type",
-		"TypeBoolean",
-		"TypeFunction",
-		"TypeNull",
-		"TypeNumber",
-		"TypeObject",
-		"TypeString",
-		"TypeSymbol",
-		"TypeUndefined",
-		"Undefined",
-		"Value",
-		"ValueError",
-		"ValueOf",
-		"Wrapper",
-	},
-	"testing": {
-		"AllocsPerRun",
-		"B",
-		"Benchmark",
-		"BenchmarkResult",
-		"Cover",
-		"CoverBlock",
-		"CoverMode",
-		"Coverage",
-		"Init",
-		"InternalBenchmark",
-		"InternalExample",
-		"InternalTest",
-		"M",
-		"Main",
-		"MainStart",
-		"PB",
-		"RegisterCover",
-		"RunBenchmarks",
-		"RunExamples",
-		"RunTests",
-		"Short",
-		"T",
-		"TB",
-		"Verbose",
-	},
-	"testing/iotest": {
-		"DataErrReader",
-		"ErrTimeout",
-		"HalfReader",
-		"NewReadLogger",
-		"NewWriteLogger",
-		"OneByteReader",
-		"TimeoutReader",
-		"TruncateWriter",
-	},
-	"testing/quick": {
-		"Check",
-		"CheckEqual",
-		"CheckEqualError",
-		"CheckError",
-		"Config",
-		"Generator",
-		"SetupError",
-		"Value",
-	},
-	"text/scanner": {
-		"Char",
-		"Comment",
-		"EOF",
-		"Float",
-		"GoTokens",
-		"GoWhitespace",
-		"Ident",
-		"Int",
-		"Position",
-		"RawString",
-		"ScanChars",
-		"ScanComments",
-		"ScanFloats",
-		"ScanIdents",
-		"ScanInts",
-		"ScanRawStrings",
-		"ScanStrings",
-		"Scanner",
-		"SkipComments",
-		"String",
-		"TokenString",
-	},
-	"text/tabwriter": {
-		"AlignRight",
-		"Debug",
-		"DiscardEmptyColumns",
-		"Escape",
-		"FilterHTML",
-		"NewWriter",
-		"StripEscape",
-		"TabIndent",
-		"Writer",
-	},
-	"text/template": {
-		"ExecError",
-		"FuncMap",
-		"HTMLEscape",
-		"HTMLEscapeString",
-		"HTMLEscaper",
-		"IsTrue",
-		"JSEscape",
-		"JSEscapeString",
-		"JSEscaper",
-		"Must",
-		"New",
-		"ParseFiles",
-		"ParseGlob",
-		"Template",
-		"URLQueryEscaper",
-	},
-	"text/template/parse": {
-		"ActionNode",
-		"BoolNode",
-		"BranchNode",
-		"ChainNode",
-		"CommandNode",
-		"DotNode",
-		"FieldNode",
-		"IdentifierNode",
-		"IfNode",
-		"IsEmptyTree",
-		"ListNode",
-		"New",
-		"NewIdentifier",
-		"NilNode",
-		"Node",
-		"NodeAction",
-		"NodeBool",
-		"NodeChain",
-		"NodeCommand",
-		"NodeDot",
-		"NodeField",
-		"NodeIdentifier",
-		"NodeIf",
-		"NodeList",
-		"NodeNil",
-		"NodeNumber",
-		"NodePipe",
-		"NodeRange",
-		"NodeString",
-		"NodeTemplate",
-		"NodeText",
-		"NodeType",
-		"NodeVariable",
-		"NodeWith",
-		"NumberNode",
-		"Parse",
-		"PipeNode",
-		"Pos",
-		"RangeNode",
-		"StringNode",
-		"TemplateNode",
-		"TextNode",
-		"Tree",
-		"VariableNode",
-		"WithNode",
-	},
-	"time": {
-		"ANSIC",
-		"After",
-		"AfterFunc",
-		"April",
-		"August",
-		"Date",
-		"December",
-		"Duration",
-		"February",
-		"FixedZone",
-		"Friday",
-		"Hour",
-		"January",
-		"July",
-		"June",
-		"Kitchen",
-		"LoadLocation",
-		"LoadLocationFromTZData",
-		"Local",
-		"Location",
-		"March",
-		"May",
-		"Microsecond",
-		"Millisecond",
-		"Minute",
-		"Monday",
-		"Month",
-		"Nanosecond",
-		"NewTicker",
-		"NewTimer",
-		"November",
-		"Now",
-		"October",
-		"Parse",
-		"ParseDuration",
-		"ParseError",
-		"ParseInLocation",
-		"RFC1123",
-		"RFC1123Z",
-		"RFC3339",
-		"RFC3339Nano",
-		"RFC822",
-		"RFC822Z",
-		"RFC850",
-		"RubyDate",
-		"Saturday",
-		"Second",
-		"September",
-		"Since",
-		"Sleep",
-		"Stamp",
-		"StampMicro",
-		"StampMilli",
-		"StampNano",
-		"Sunday",
-		"Thursday",
-		"Tick",
-		"Ticker",
-		"Time",
-		"Timer",
-		"Tuesday",
-		"UTC",
-		"Unix",
-		"UnixDate",
-		"Until",
-		"Wednesday",
-		"Weekday",
-	},
-	"unicode": {
-		"ASCII_Hex_Digit",
-		"Adlam",
-		"Ahom",
-		"Anatolian_Hieroglyphs",
-		"Arabic",
-		"Armenian",
-		"Avestan",
-		"AzeriCase",
-		"Balinese",
-		"Bamum",
-		"Bassa_Vah",
-		"Batak",
-		"Bengali",
-		"Bhaiksuki",
-		"Bidi_Control",
-		"Bopomofo",
-		"Brahmi",
-		"Braille",
-		"Buginese",
-		"Buhid",
-		"C",
-		"Canadian_Aboriginal",
-		"Carian",
-		"CaseRange",
-		"CaseRanges",
-		"Categories",
-		"Caucasian_Albanian",
-		"Cc",
-		"Cf",
-		"Chakma",
-		"Cham",
-		"Cherokee",
-		"Co",
-		"Common",
-		"Coptic",
-		"Cs",
-		"Cuneiform",
-		"Cypriot",
-		"Cyrillic",
-		"Dash",
-		"Deprecated",
-		"Deseret",
-		"Devanagari",
-		"Diacritic",
-		"Digit",
-		"Dogra",
-		"Duployan",
-		"Egyptian_Hieroglyphs",
-		"Elbasan",
-		"Elymaic",
-		"Ethiopic",
-		"Extender",
-		"FoldCategory",
-		"FoldScript",
-		"Georgian",
-		"Glagolitic",
-		"Gothic",
-		"Grantha",
-		"GraphicRanges",
-		"Greek",
-		"Gujarati",
-		"Gunjala_Gondi",
-		"Gurmukhi",
-		"Han",
-		"Hangul",
-		"Hanifi_Rohingya",
-		"Hanunoo",
-		"Hatran",
-		"Hebrew",
-		"Hex_Digit",
-		"Hiragana",
-		"Hyphen",
-		"IDS_Binary_Operator",
-		"IDS_Trinary_Operator",
-		"Ideographic",
-		"Imperial_Aramaic",
-		"In",
-		"Inherited",
-		"Inscriptional_Pahlavi",
-		"Inscriptional_Parthian",
-		"Is",
-		"IsControl",
-		"IsDigit",
-		"IsGraphic",
-		"IsLetter",
-		"IsLower",
-		"IsMark",
-		"IsNumber",
-		"IsOneOf",
-		"IsPrint",
-		"IsPunct",
-		"IsSpace",
-		"IsSymbol",
-		"IsTitle",
-		"IsUpper",
-		"Javanese",
-		"Join_Control",
-		"Kaithi",
-		"Kannada",
-		"Katakana",
-		"Kayah_Li",
-		"Kharoshthi",
-		"Khmer",
-		"Khojki",
-		"Khudawadi",
-		"L",
-		"Lao",
-		"Latin",
-		"Lepcha",
-		"Letter",
-		"Limbu",
-		"Linear_A",
-		"Linear_B",
-		"Lisu",
-		"Ll",
-		"Lm",
-		"Lo",
-		"Logical_Order_Exception",
-		"Lower",
-		"LowerCase",
-		"Lt",
-		"Lu",
-		"Lycian",
-		"Lydian",
-		"M",
-		"Mahajani",
-		"Makasar",
-		"Malayalam",
-		"Mandaic",
-		"Manichaean",
-		"Marchen",
-		"Mark",
-		"Masaram_Gondi",
-		"MaxASCII",
-		"MaxCase",
-		"MaxLatin1",
-		"MaxRune",
-		"Mc",
-		"Me",
-		"Medefaidrin",
-		"Meetei_Mayek",
-		"Mende_Kikakui",
-		"Meroitic_Cursive",
-		"Meroitic_Hieroglyphs",
-		"Miao",
-		"Mn",
-		"Modi",
-		"Mongolian",
-		"Mro",
-		"Multani",
-		"Myanmar",
-		"N",
-		"Nabataean",
-		"Nandinagari",
-		"Nd",
-		"New_Tai_Lue",
-		"Newa",
-		"Nko",
-		"Nl",
-		"No",
-		"Noncharacter_Code_Point",
-		"Number",
-		"Nushu",
-		"Nyiakeng_Puachue_Hmong",
-		"Ogham",
-		"Ol_Chiki",
-		"Old_Hungarian",
-		"Old_Italic",
-		"Old_North_Arabian",
-		"Old_Permic",
-		"Old_Persian",
-		"Old_Sogdian",
-		"Old_South_Arabian",
-		"Old_Turkic",
-		"Oriya",
-		"Osage",
-		"Osmanya",
-		"Other",
-		"Other_Alphabetic",
-		"Other_Default_Ignorable_Code_Point",
-		"Other_Grapheme_Extend",
-		"Other_ID_Continue",
-		"Other_ID_Start",
-		"Other_Lowercase",
-		"Other_Math",
-		"Other_Uppercase",
-		"P",
-		"Pahawh_Hmong",
-		"Palmyrene",
-		"Pattern_Syntax",
-		"Pattern_White_Space",
-		"Pau_Cin_Hau",
-		"Pc",
-		"Pd",
-		"Pe",
-		"Pf",
-		"Phags_Pa",
-		"Phoenician",
-		"Pi",
-		"Po",
-		"Prepended_Concatenation_Mark",
-		"PrintRanges",
-		"Properties",
-		"Ps",
-		"Psalter_Pahlavi",
-		"Punct",
-		"Quotation_Mark",
-		"Radical",
-		"Range16",
-		"Range32",
-		"RangeTable",
-		"Regional_Indicator",
-		"Rejang",
-		"ReplacementChar",
-		"Runic",
-		"S",
-		"STerm",
-		"Samaritan",
-		"Saurashtra",
-		"Sc",
-		"Scripts",
-		"Sentence_Terminal",
-		"Sharada",
-		"Shavian",
-		"Siddham",
-		"SignWriting",
-		"SimpleFold",
-		"Sinhala",
-		"Sk",
-		"Sm",
-		"So",
-		"Soft_Dotted",
-		"Sogdian",
-		"Sora_Sompeng",
-		"Soyombo",
-		"Space",
-		"SpecialCase",
-		"Sundanese",
-		"Syloti_Nagri",
-		"Symbol",
-		"Syriac",
-		"Tagalog",
-		"Tagbanwa",
-		"Tai_Le",
-		"Tai_Tham",
-		"Tai_Viet",
-		"Takri",
-		"Tamil",
-		"Tangut",
-		"Telugu",
-		"Terminal_Punctuation",
-		"Thaana",
-		"Thai",
-		"Tibetan",
-		"Tifinagh",
-		"Tirhuta",
-		"Title",
-		"TitleCase",
-		"To",
-		"ToLower",
-		"ToTitle",
-		"ToUpper",
-		"TurkishCase",
-		"Ugaritic",
-		"Unified_Ideograph",
-		"Upper",
-		"UpperCase",
-		"UpperLower",
-		"Vai",
-		"Variation_Selector",
-		"Version",
-		"Wancho",
-		"Warang_Citi",
-		"White_Space",
-		"Yi",
-		"Z",
-		"Zanabazar_Square",
-		"Zl",
-		"Zp",
-		"Zs",
-	},
-	"unicode/utf16": {
-		"Decode",
-		"DecodeRune",
-		"Encode",
-		"EncodeRune",
-		"IsSurrogate",
-	},
-	"unicode/utf8": {
-		"DecodeLastRune",
-		"DecodeLastRuneInString",
-		"DecodeRune",
-		"DecodeRuneInString",
-		"EncodeRune",
-		"FullRune",
-		"FullRuneInString",
-		"MaxRune",
-		"RuneCount",
-		"RuneCountInString",
-		"RuneError",
-		"RuneLen",
-		"RuneSelf",
-		"RuneStart",
-		"UTFMax",
-		"Valid",
-		"ValidRune",
-		"ValidString",
-	},
-	"unsafe": {
-		"Alignof",
-		"ArbitraryType",
-		"Offsetof",
-		"Pointer",
-		"Sizeof",
-	},
-}
diff --git a/gofumports/internal/module/module.go b/gofumports/internal/module/module.go
deleted file mode 100644
index 376cffa..0000000
--- a/gofumports/internal/module/module.go
+++ /dev/null
@@ -1,540 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package module defines the module.Version type
-// along with support code.
-package module
-
-// IMPORTANT NOTE
-//
-// This file essentially defines the set of valid import paths for the go command.
-// There are many subtle considerations, including Unicode ambiguity,
-// security, network, and file system representations.
-//
-// This file also defines the set of valid module path and version combinations,
-// another topic with many subtle considerations.
-//
-// Changes to the semantics in this file require approval from rsc.
-
-import (
-	"fmt"
-	"sort"
-	"strings"
-	"unicode"
-	"unicode/utf8"
-
-	"mvdan.cc/gofumpt/gofumports/internal/semver"
-)
-
-// A Version is defined by a module path and version pair.
-type Version struct {
-	Path string
-
-	// Version is usually a semantic version in canonical form.
-	// There are two exceptions to this general rule.
-	// First, the top-level target of a build has no specific version
-	// and uses Version = "".
-	// Second, during MVS calculations the version "none" is used
-	// to represent the decision to take no version of a given module.
-	Version string `json:",omitempty"`
-}
-
-// Check checks that a given module path, version pair is valid.
-// In addition to the path being a valid module path
-// and the version being a valid semantic version,
-// the two must correspond.
-// For example, the path "yaml/v2" only corresponds to
-// semantic versions beginning with "v2.".
-func Check(path, version string) error {
-	if err := CheckPath(path); err != nil {
-		return err
-	}
-	if !semver.IsValid(version) {
-		return fmt.Errorf("malformed semantic version %v", version)
-	}
-	_, pathMajor, _ := SplitPathVersion(path)
-	if !MatchPathMajor(version, pathMajor) {
-		if pathMajor == "" {
-			pathMajor = "v0 or v1"
-		}
-		if pathMajor[0] == '.' { // .v1
-			pathMajor = pathMajor[1:]
-		}
-		return fmt.Errorf("mismatched module path %v and version %v (want %v)", path, version, pathMajor)
-	}
-	return nil
-}
-
-// firstPathOK reports whether r can appear in the first element of a module path.
-// The first element of the path must be an LDH domain name, at least for now.
-// To avoid case ambiguity, the domain name must be entirely lower case.
-func firstPathOK(r rune) bool {
-	return r == '-' || r == '.' ||
-		'0' <= r && r <= '9' ||
-		'a' <= r && r <= 'z'
-}
-
-// pathOK reports whether r can appear in an import path element.
-// Paths can be ASCII letters, ASCII digits, and limited ASCII punctuation: + - . _ and ~.
-// This matches what "go get" has historically recognized in import paths.
-// TODO(rsc): We would like to allow Unicode letters, but that requires additional
-// care in the safe encoding (see note below).
-func pathOK(r rune) bool {
-	if r < utf8.RuneSelf {
-		return r == '+' || r == '-' || r == '.' || r == '_' || r == '~' ||
-			'0' <= r && r <= '9' ||
-			'A' <= r && r <= 'Z' ||
-			'a' <= r && r <= 'z'
-	}
-	return false
-}
-
-// fileNameOK reports whether r can appear in a file name.
-// For now we allow all Unicode letters but otherwise limit to pathOK plus a few more punctuation characters.
-// If we expand the set of allowed characters here, we have to
-// work harder at detecting potential case-folding and normalization collisions.
-// See note about "safe encoding" below.
-func fileNameOK(r rune) bool {
-	if r < utf8.RuneSelf {
-		// Entire set of ASCII punctuation, from which we remove characters:
-		//     ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
-		// We disallow some shell special characters: " ' * < > ? ` |
-		// (Note that some of those are disallowed by the Windows file system as well.)
-		// We also disallow path separators / : and \ (fileNameOK is only called on path element characters).
-		// We allow spaces (U+0020) in file names.
-		const allowed = "!#$%&()+,-.=@[]^_{}~ "
-		if '0' <= r && r <= '9' || 'A' <= r && r <= 'Z' || 'a' <= r && r <= 'z' {
-			return true
-		}
-		for i := 0; i < len(allowed); i++ {
-			if rune(allowed[i]) == r {
-				return true
-			}
-		}
-		return false
-	}
-	// It may be OK to add more ASCII punctuation here, but only carefully.
-	// For example Windows disallows < > \, and macOS disallows :, so we must not allow those.
-	return unicode.IsLetter(r)
-}
-
-// CheckPath checks that a module path is valid.
-func CheckPath(path string) error {
-	if err := checkPath(path, false); err != nil {
-		return fmt.Errorf("malformed module path %q: %v", path, err)
-	}
-	i := strings.Index(path, "/")
-	if i < 0 {
-		i = len(path)
-	}
-	if i == 0 {
-		return fmt.Errorf("malformed module path %q: leading slash", path)
-	}
-	if !strings.Contains(path[:i], ".") {
-		return fmt.Errorf("malformed module path %q: missing dot in first path element", path)
-	}
-	if path[0] == '-' {
-		return fmt.Errorf("malformed module path %q: leading dash in first path element", path)
-	}
-	for _, r := range path[:i] {
-		if !firstPathOK(r) {
-			return fmt.Errorf("malformed module path %q: invalid char %q in first path element", path, r)
-		}
-	}
-	if _, _, ok := SplitPathVersion(path); !ok {
-		return fmt.Errorf("malformed module path %q: invalid version", path)
-	}
-	return nil
-}
-
-// CheckImportPath checks that an import path is valid.
-func CheckImportPath(path string) error {
-	if err := checkPath(path, false); err != nil {
-		return fmt.Errorf("malformed import path %q: %v", path, err)
-	}
-	return nil
-}
-
-// checkPath checks that a general path is valid.
-// It returns an error describing why but not mentioning path.
-// Because these checks apply to both module paths and import paths,
-// the caller is expected to add the "malformed ___ path %q: " prefix.
-// fileName indicates whether the final element of the path is a file name
-// (as opposed to a directory name).
-func checkPath(path string, fileName bool) error {
-	if !utf8.ValidString(path) {
-		return fmt.Errorf("invalid UTF-8")
-	}
-	if path == "" {
-		return fmt.Errorf("empty string")
-	}
-	if strings.Contains(path, "..") {
-		return fmt.Errorf("double dot")
-	}
-	if strings.Contains(path, "//") {
-		return fmt.Errorf("double slash")
-	}
-	if path[len(path)-1] == '/' {
-		return fmt.Errorf("trailing slash")
-	}
-	elemStart := 0
-	for i, r := range path {
-		if r == '/' {
-			if err := checkElem(path[elemStart:i], fileName); err != nil {
-				return err
-			}
-			elemStart = i + 1
-		}
-	}
-	if err := checkElem(path[elemStart:], fileName); err != nil {
-		return err
-	}
-	return nil
-}
-
-// checkElem checks whether an individual path element is valid.
-// fileName indicates whether the element is a file name (not a directory name).
-func checkElem(elem string, fileName bool) error {
-	if elem == "" {
-		return fmt.Errorf("empty path element")
-	}
-	if strings.Count(elem, ".") == len(elem) {
-		return fmt.Errorf("invalid path element %q", elem)
-	}
-	if elem[0] == '.' && !fileName {
-		return fmt.Errorf("leading dot in path element")
-	}
-	if elem[len(elem)-1] == '.' {
-		return fmt.Errorf("trailing dot in path element")
-	}
-	charOK := pathOK
-	if fileName {
-		charOK = fileNameOK
-	}
-	for _, r := range elem {
-		if !charOK(r) {
-			return fmt.Errorf("invalid char %q", r)
-		}
-	}
-
-	// Windows disallows a bunch of path elements, sadly.
-	// See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file
-	short := elem
-	if i := strings.Index(short, "."); i >= 0 {
-		short = short[:i]
-	}
-	for _, bad := range badWindowsNames {
-		if strings.EqualFold(bad, short) {
-			return fmt.Errorf("disallowed path element %q", elem)
-		}
-	}
-	return nil
-}
-
-// CheckFilePath checks whether a slash-separated file path is valid.
-func CheckFilePath(path string) error {
-	if err := checkPath(path, true); err != nil {
-		return fmt.Errorf("malformed file path %q: %v", path, err)
-	}
-	return nil
-}
-
-// badWindowsNames are the reserved file path elements on Windows.
-// See https://docs.microsoft.com/en-us/windows/desktop/fileio/naming-a-file
-var badWindowsNames = []string{
-	"CON",
-	"PRN",
-	"AUX",
-	"NUL",
-	"COM1",
-	"COM2",
-	"COM3",
-	"COM4",
-	"COM5",
-	"COM6",
-	"COM7",
-	"COM8",
-	"COM9",
-	"LPT1",
-	"LPT2",
-	"LPT3",
-	"LPT4",
-	"LPT5",
-	"LPT6",
-	"LPT7",
-	"LPT8",
-	"LPT9",
-}
-
-// SplitPathVersion returns prefix and major version such that prefix+pathMajor == path
-// and version is either empty or "/vN" for N >= 2.
-// As a special case, gopkg.in paths are recognized directly;
-// they require ".vN" instead of "/vN", and for all N, not just N >= 2.
-func SplitPathVersion(path string) (prefix, pathMajor string, ok bool) {
-	if strings.HasPrefix(path, "gopkg.in/") {
-		return splitGopkgIn(path)
-	}
-
-	i := len(path)
-	dot := false
-	for i > 0 && ('0' <= path[i-1] && path[i-1] <= '9' || path[i-1] == '.') {
-		if path[i-1] == '.' {
-			dot = true
-		}
-		i--
-	}
-	if i <= 1 || i == len(path) || path[i-1] != 'v' || path[i-2] != '/' {
-		return path, "", true
-	}
-	prefix, pathMajor = path[:i-2], path[i-2:]
-	if dot || len(pathMajor) <= 2 || pathMajor[2] == '0' || pathMajor == "/v1" {
-		return path, "", false
-	}
-	return prefix, pathMajor, true
-}
-
-// splitGopkgIn is like SplitPathVersion but only for gopkg.in paths.
-func splitGopkgIn(path string) (prefix, pathMajor string, ok bool) {
-	if !strings.HasPrefix(path, "gopkg.in/") {
-		return path, "", false
-	}
-	i := len(path)
-	if strings.HasSuffix(path, "-unstable") {
-		i -= len("-unstable")
-	}
-	for i > 0 && ('0' <= path[i-1] && path[i-1] <= '9') {
-		i--
-	}
-	if i <= 1 || path[i-1] != 'v' || path[i-2] != '.' {
-		// All gopkg.in paths must end in vN for some N.
-		return path, "", false
-	}
-	prefix, pathMajor = path[:i-2], path[i-2:]
-	if len(pathMajor) <= 2 || pathMajor[2] == '0' && pathMajor != ".v0" {
-		return path, "", false
-	}
-	return prefix, pathMajor, true
-}
-
-// MatchPathMajor reports whether the semantic version v
-// matches the path major version pathMajor.
-func MatchPathMajor(v, pathMajor string) bool {
-	if strings.HasPrefix(pathMajor, ".v") && strings.HasSuffix(pathMajor, "-unstable") {
-		pathMajor = strings.TrimSuffix(pathMajor, "-unstable")
-	}
-	if strings.HasPrefix(v, "v0.0.0-") && pathMajor == ".v1" {
-		// Allow old bug in pseudo-versions that generated v0.0.0- pseudoversion for gopkg .v1.
-		// For example, gopkg.in/yaml.v2@v2.2.1's go.mod requires gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405.
-		return true
-	}
-	m := semver.Major(v)
-	if pathMajor == "" {
-		return m == "v0" || m == "v1" || semver.Build(v) == "+incompatible"
-	}
-	return (pathMajor[0] == '/' || pathMajor[0] == '.') && m == pathMajor[1:]
-}
-
-// CanonicalVersion returns the canonical form of the version string v.
-// It is the same as semver.Canonical(v) except that it preserves the special build suffix "+incompatible".
-func CanonicalVersion(v string) string {
-	cv := semver.Canonical(v)
-	if semver.Build(v) == "+incompatible" {
-		cv += "+incompatible"
-	}
-	return cv
-}
-
-// Sort sorts the list by Path, breaking ties by comparing Versions.
-func Sort(list []Version) {
-	sort.Slice(list, func(i, j int) bool {
-		mi := list[i]
-		mj := list[j]
-		if mi.Path != mj.Path {
-			return mi.Path < mj.Path
-		}
-		// To help go.sum formatting, allow version/file.
-		// Compare semver prefix by semver rules,
-		// file by string order.
-		vi := mi.Version
-		vj := mj.Version
-		var fi, fj string
-		if k := strings.Index(vi, "/"); k >= 0 {
-			vi, fi = vi[:k], vi[k:]
-		}
-		if k := strings.Index(vj, "/"); k >= 0 {
-			vj, fj = vj[:k], vj[k:]
-		}
-		if vi != vj {
-			return semver.Compare(vi, vj) < 0
-		}
-		return fi < fj
-	})
-}
-
-// Safe encodings
-//
-// Module paths appear as substrings of file system paths
-// (in the download cache) and of web server URLs in the proxy protocol.
-// In general we cannot rely on file systems to be case-sensitive,
-// nor can we rely on web servers, since they read from file systems.
-// That is, we cannot rely on the file system to keep rsc.io/QUOTE
-// and rsc.io/quote separate. Windows and macOS don't.
-// Instead, we must never require two different casings of a file path.
-// Because we want the download cache to match the proxy protocol,
-// and because we want the proxy protocol to be possible to serve
-// from a tree of static files (which might be stored on a case-insensitive
-// file system), the proxy protocol must never require two different casings
-// of a URL path either.
-//
-// One possibility would be to make the safe encoding be the lowercase
-// hexadecimal encoding of the actual path bytes. This would avoid ever
-// needing different casings of a file path, but it would be fairly illegible
-// to most programmers when those paths appeared in the file system
-// (including in file paths in compiler errors and stack traces)
-// in web server logs, and so on. Instead, we want a safe encoding that
-// leaves most paths unaltered.
-//
-// The safe encoding is this:
-// replace every uppercase letter with an exclamation mark
-// followed by the letter's lowercase equivalent.
-//
-// For example,
-// github.com/Azure/azure-sdk-for-go ->  github.com/!azure/azure-sdk-for-go.
-// github.com/GoogleCloudPlatform/cloudsql-proxy -> github.com/!google!cloud!platform/cloudsql-proxy
-// github.com/Sirupsen/logrus -> github.com/!sirupsen/logrus.
-//
-// Import paths that avoid upper-case letters are left unchanged.
-// Note that because import paths are ASCII-only and avoid various
-// problematic punctuation (like : < and >), the safe encoding is also ASCII-only
-// and avoids the same problematic punctuation.
-//
-// Import paths have never allowed exclamation marks, so there is no
-// need to define how to encode a literal !.
-//
-// Although paths are disallowed from using Unicode (see pathOK above),
-// the eventual plan is to allow Unicode letters as well, to assume that
-// file systems and URLs are Unicode-safe (storing UTF-8), and apply
-// the !-for-uppercase convention. Note however that not all runes that
-// are different but case-fold equivalent are an upper/lower pair.
-// For example, U+004B ('K'), U+006B ('k'), and U+212A ('‚Ñ™' for Kelvin)
-// are considered to case-fold to each other. When we do add Unicode
-// letters, we must not assume that upper/lower are the only case-equivalent pairs.
-// Perhaps the Kelvin symbol would be disallowed entirely, for example.
-// Or perhaps it would encode as "!!k", or perhaps as "(212A)".
-//
-// Also, it would be nice to allow Unicode marks as well as letters,
-// but marks include combining marks, and then we must deal not
-// only with case folding but also normalization: both U+00E9 ('√©')
-// and U+0065 U+0301 ('e' followed by combining acute accent)
-// look the same on the page and are treated by some file systems
-// as the same path. If we do allow Unicode marks in paths, there
-// must be some kind of normalization to allow only one canonical
-// encoding of any character used in an import path.
-
-// EncodePath returns the safe encoding of the given module path.
-// It fails if the module path is invalid.
-func EncodePath(path string) (encoding string, err error) {
-	if err := CheckPath(path); err != nil {
-		return "", err
-	}
-
-	return encodeString(path)
-}
-
-// EncodeVersion returns the safe encoding of the given module version.
-// Versions are allowed to be in non-semver form but must be valid file names
-// and not contain exclamation marks.
-func EncodeVersion(v string) (encoding string, err error) {
-	if err := checkElem(v, true); err != nil || strings.Contains(v, "!") {
-		return "", fmt.Errorf("disallowed version string %q", v)
-	}
-	return encodeString(v)
-}
-
-func encodeString(s string) (encoding string, err error) {
-	haveUpper := false
-	for _, r := range s {
-		if r == '!' || r >= utf8.RuneSelf {
-			// This should be disallowed by CheckPath, but diagnose anyway.
-			// The correctness of the encoding loop below depends on it.
-			return "", fmt.Errorf("internal error: inconsistency in EncodePath")
-		}
-		if 'A' <= r && r <= 'Z' {
-			haveUpper = true
-		}
-	}
-
-	if !haveUpper {
-		return s, nil
-	}
-
-	var buf []byte
-	for _, r := range s {
-		if 'A' <= r && r <= 'Z' {
-			buf = append(buf, '!', byte(r+'a'-'A'))
-		} else {
-			buf = append(buf, byte(r))
-		}
-	}
-	return string(buf), nil
-}
-
-// DecodePath returns the module path of the given safe encoding.
-// It fails if the encoding is invalid or encodes an invalid path.
-func DecodePath(encoding string) (path string, err error) {
-	path, ok := decodeString(encoding)
-	if !ok {
-		return "", fmt.Errorf("invalid module path encoding %q", encoding)
-	}
-	if err := CheckPath(path); err != nil {
-		return "", fmt.Errorf("invalid module path encoding %q: %v", encoding, err)
-	}
-	return path, nil
-}
-
-// DecodeVersion returns the version string for the given safe encoding.
-// It fails if the encoding is invalid or encodes an invalid version.
-// Versions are allowed to be in non-semver form but must be valid file names
-// and not contain exclamation marks.
-func DecodeVersion(encoding string) (v string, err error) {
-	v, ok := decodeString(encoding)
-	if !ok {
-		return "", fmt.Errorf("invalid version encoding %q", encoding)
-	}
-	if err := checkElem(v, true); err != nil {
-		return "", fmt.Errorf("disallowed version string %q", v)
-	}
-	return v, nil
-}
-
-func decodeString(encoding string) (string, bool) {
-	var buf []byte
-
-	bang := false
-	for _, r := range encoding {
-		if r >= utf8.RuneSelf {
-			return "", false
-		}
-		if bang {
-			bang = false
-			if r < 'a' || 'z' < r {
-				return "", false
-			}
-			buf = append(buf, byte(r+'A'-'a'))
-			continue
-		}
-		if r == '!' {
-			bang = true
-			continue
-		}
-		if 'A' <= r && r <= 'Z' {
-			return "", false
-		}
-		buf = append(buf, byte(r))
-	}
-	if bang {
-		return "", false
-	}
-	return string(buf), true
-}
diff --git a/gofumports/internal/semver/semver.go b/gofumports/internal/semver/semver.go
deleted file mode 100644
index 4af7118..0000000
--- a/gofumports/internal/semver/semver.go
+++ /dev/null
@@ -1,388 +0,0 @@
-// Copyright 2018 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package semver implements comparison of semantic version strings.
-// In this package, semantic version strings must begin with a leading "v",
-// as in "v1.0.0".
-//
-// The general form of a semantic version string accepted by this package is
-//
-//	vMAJOR[.MINOR[.PATCH[-PRERELEASE][+BUILD]]]
-//
-// where square brackets indicate optional parts of the syntax;
-// MAJOR, MINOR, and PATCH are decimal integers without extra leading zeros;
-// PRERELEASE and BUILD are each a series of non-empty dot-separated identifiers
-// using only alphanumeric characters and hyphens; and
-// all-numeric PRERELEASE identifiers must not have leading zeros.
-//
-// This package follows Semantic Versioning 2.0.0 (see semver.org)
-// with two exceptions. First, it requires the "v" prefix. Second, it recognizes
-// vMAJOR and vMAJOR.MINOR (with no prerelease or build suffixes)
-// as shorthands for vMAJOR.0.0 and vMAJOR.MINOR.0.
-package semver
-
-// parsed returns the parsed form of a semantic version string.
-type parsed struct {
-	major      string
-	minor      string
-	patch      string
-	short      string
-	prerelease string
-	build      string
-	err        string
-}
-
-// IsValid reports whether v is a valid semantic version string.
-func IsValid(v string) bool {
-	_, ok := parse(v)
-	return ok
-}
-
-// Canonical returns the canonical formatting of the semantic version v.
-// It fills in any missing .MINOR or .PATCH and discards build metadata.
-// Two semantic versions compare equal only if their canonical formattings
-// are identical strings.
-// The canonical invalid semantic version is the empty string.
-func Canonical(v string) string {
-	p, ok := parse(v)
-	if !ok {
-		return ""
-	}
-	if p.build != "" {
-		return v[:len(v)-len(p.build)]
-	}
-	if p.short != "" {
-		return v + p.short
-	}
-	return v
-}
-
-// Major returns the major version prefix of the semantic version v.
-// For example, Major("v2.1.0") == "v2".
-// If v is an invalid semantic version string, Major returns the empty string.
-func Major(v string) string {
-	pv, ok := parse(v)
-	if !ok {
-		return ""
-	}
-	return v[:1+len(pv.major)]
-}
-
-// MajorMinor returns the major.minor version prefix of the semantic version v.
-// For example, MajorMinor("v2.1.0") == "v2.1".
-// If v is an invalid semantic version string, MajorMinor returns the empty string.
-func MajorMinor(v string) string {
-	pv, ok := parse(v)
-	if !ok {
-		return ""
-	}
-	i := 1 + len(pv.major)
-	if j := i + 1 + len(pv.minor); j <= len(v) && v[i] == '.' && v[i+1:j] == pv.minor {
-		return v[:j]
-	}
-	return v[:i] + "." + pv.minor
-}
-
-// Prerelease returns the prerelease suffix of the semantic version v.
-// For example, Prerelease("v2.1.0-pre+meta") == "-pre".
-// If v is an invalid semantic version string, Prerelease returns the empty string.
-func Prerelease(v string) string {
-	pv, ok := parse(v)
-	if !ok {
-		return ""
-	}
-	return pv.prerelease
-}
-
-// Build returns the build suffix of the semantic version v.
-// For example, Build("v2.1.0+meta") == "+meta".
-// If v is an invalid semantic version string, Build returns the empty string.
-func Build(v string) string {
-	pv, ok := parse(v)
-	if !ok {
-		return ""
-	}
-	return pv.build
-}
-
-// Compare returns an integer comparing two versions according to
-// according to semantic version precedence.
-// The result will be 0 if v == w, -1 if v < w, or +1 if v > w.
-//
-// An invalid semantic version string is considered less than a valid one.
-// All invalid semantic version strings compare equal to each other.
-func Compare(v, w string) int {
-	pv, ok1 := parse(v)
-	pw, ok2 := parse(w)
-	if !ok1 && !ok2 {
-		return 0
-	}
-	if !ok1 {
-		return -1
-	}
-	if !ok2 {
-		return +1
-	}
-	if c := compareInt(pv.major, pw.major); c != 0 {
-		return c
-	}
-	if c := compareInt(pv.minor, pw.minor); c != 0 {
-		return c
-	}
-	if c := compareInt(pv.patch, pw.patch); c != 0 {
-		return c
-	}
-	return comparePrerelease(pv.prerelease, pw.prerelease)
-}
-
-// Max canonicalizes its arguments and then returns the version string
-// that compares greater.
-func Max(v, w string) string {
-	v = Canonical(v)
-	w = Canonical(w)
-	if Compare(v, w) > 0 {
-		return v
-	}
-	return w
-}
-
-func parse(v string) (p parsed, ok bool) {
-	if v == "" || v[0] != 'v' {
-		p.err = "missing v prefix"
-		return
-	}
-	p.major, v, ok = parseInt(v[1:])
-	if !ok {
-		p.err = "bad major version"
-		return
-	}
-	if v == "" {
-		p.minor = "0"
-		p.patch = "0"
-		p.short = ".0.0"
-		return
-	}
-	if v[0] != '.' {
-		p.err = "bad minor prefix"
-		ok = false
-		return
-	}
-	p.minor, v, ok = parseInt(v[1:])
-	if !ok {
-		p.err = "bad minor version"
-		return
-	}
-	if v == "" {
-		p.patch = "0"
-		p.short = ".0"
-		return
-	}
-	if v[0] != '.' {
-		p.err = "bad patch prefix"
-		ok = false
-		return
-	}
-	p.patch, v, ok = parseInt(v[1:])
-	if !ok {
-		p.err = "bad patch version"
-		return
-	}
-	if len(v) > 0 && v[0] == '-' {
-		p.prerelease, v, ok = parsePrerelease(v)
-		if !ok {
-			p.err = "bad prerelease"
-			return
-		}
-	}
-	if len(v) > 0 && v[0] == '+' {
-		p.build, v, ok = parseBuild(v)
-		if !ok {
-			p.err = "bad build"
-			return
-		}
-	}
-	if v != "" {
-		p.err = "junk on end"
-		ok = false
-		return
-	}
-	ok = true
-	return
-}
-
-func parseInt(v string) (t, rest string, ok bool) {
-	if v == "" {
-		return
-	}
-	if v[0] < '0' || '9' < v[0] {
-		return
-	}
-	i := 1
-	for i < len(v) && '0' <= v[i] && v[i] <= '9' {
-		i++
-	}
-	if v[0] == '0' && i != 1 {
-		return
-	}
-	return v[:i], v[i:], true
-}
-
-func parsePrerelease(v string) (t, rest string, ok bool) {
-	// "A pre-release version MAY be denoted by appending a hyphen and
-	// a series of dot separated identifiers immediately following the patch version.
-	// Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
-	// Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes."
-	if v == "" || v[0] != '-' {
-		return
-	}
-	i := 1
-	start := 1
-	for i < len(v) && v[i] != '+' {
-		if !isIdentChar(v[i]) && v[i] != '.' {
-			return
-		}
-		if v[i] == '.' {
-			if start == i || isBadNum(v[start:i]) {
-				return
-			}
-			start = i + 1
-		}
-		i++
-	}
-	if start == i || isBadNum(v[start:i]) {
-		return
-	}
-	return v[:i], v[i:], true
-}
-
-func parseBuild(v string) (t, rest string, ok bool) {
-	if v == "" || v[0] != '+' {
-		return
-	}
-	i := 1
-	start := 1
-	for i < len(v) {
-		if !isIdentChar(v[i]) {
-			return
-		}
-		if v[i] == '.' {
-			if start == i {
-				return
-			}
-			start = i + 1
-		}
-		i++
-	}
-	if start == i {
-		return
-	}
-	return v[:i], v[i:], true
-}
-
-func isIdentChar(c byte) bool {
-	return 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' || c == '-'
-}
-
-func isBadNum(v string) bool {
-	i := 0
-	for i < len(v) && '0' <= v[i] && v[i] <= '9' {
-		i++
-	}
-	return i == len(v) && i > 1 && v[0] == '0'
-}
-
-func isNum(v string) bool {
-	i := 0
-	for i < len(v) && '0' <= v[i] && v[i] <= '9' {
-		i++
-	}
-	return i == len(v)
-}
-
-func compareInt(x, y string) int {
-	if x == y {
-		return 0
-	}
-	if len(x) < len(y) {
-		return -1
-	}
-	if len(x) > len(y) {
-		return +1
-	}
-	if x < y {
-		return -1
-	} else {
-		return +1
-	}
-}
-
-func comparePrerelease(x, y string) int {
-	// "When major, minor, and patch are equal, a pre-release version has
-	// lower precedence than a normal version.
-	// Example: 1.0.0-alpha < 1.0.0.
-	// Precedence for two pre-release versions with the same major, minor,
-	// and patch version MUST be determined by comparing each dot separated
-	// identifier from left to right until a difference is found as follows:
-	// identifiers consisting of only digits are compared numerically and
-	// identifiers with letters or hyphens are compared lexically in ASCII
-	// sort order. Numeric identifiers always have lower precedence than
-	// non-numeric identifiers. A larger set of pre-release fields has a
-	// higher precedence than a smaller set, if all of the preceding
-	// identifiers are equal.
-	// Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
-	// 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0."
-	if x == y {
-		return 0
-	}
-	if x == "" {
-		return +1
-	}
-	if y == "" {
-		return -1
-	}
-	for x != "" && y != "" {
-		x = x[1:] // skip - or .
-		y = y[1:] // skip - or .
-		var dx, dy string
-		dx, x = nextIdent(x)
-		dy, y = nextIdent(y)
-		if dx != dy {
-			ix := isNum(dx)
-			iy := isNum(dy)
-			if ix != iy {
-				if ix {
-					return -1
-				} else {
-					return +1
-				}
-			}
-			if ix {
-				if len(dx) < len(dy) {
-					return -1
-				}
-				if len(dx) > len(dy) {
-					return +1
-				}
-			}
-			if dx < dy {
-				return -1
-			} else {
-				return +1
-			}
-		}
-	}
-	if x == "" {
-		return -1
-	} else {
-		return +1
-	}
-}
-
-func nextIdent(x string) (dx, rest string) {
-	i := 0
-	for i < len(x) && x[i] != '.' {
-		i++
-	}
-	return x[:i], x[i:]
-}
diff --git a/gofumports/internal/telemetry/event/event.go b/gofumports/internal/telemetry/event/event.go
deleted file mode 100644
index 2b990c5..0000000
--- a/gofumports/internal/telemetry/event/event.go
+++ /dev/null
@@ -1,113 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package event provides support for event based telemetry.
-package event
-
-import (
-	"fmt"
-	"time"
-)
-
-type eventType uint8
-
-const (
-	invalidType   = eventType(iota)
-	LogType       // an event that should be recorded in a log
-	StartSpanType // the start of a span of time
-	EndSpanType   // the end of a span of time
-	LabelType     // some values that should be noted for later events
-	DetachType    // an event that causes a context to detach
-	RecordType    // a value that should be tracked
-)
-
-// sTags is used to hold a small number of tags inside an event whichout
-// requiring a separate allocation.
-// As tags are often on the stack, this avoids an allocation at all for
-// the very common cases of simple events.
-// The length needs to be large enough to cope with the majority of events
-// but no so large as to cause undue stack pressure.
-// A log message with two values will use 3 tags (one for each value and
-// one for the message itself).
-type sTags [3]Tag
-
-// Event holds the information about an event of note that ocurred.
-type Event struct {
-	At time.Time
-
-	typ     eventType
-	static  sTags // inline storage for the first few tags
-	dynamic []Tag // dynamically sized storage for remaining tags
-}
-
-// eventTagMap implements TagMap for a the tags of an Event.
-type eventTagMap struct {
-	event Event
-}
-
-func (ev Event) IsLog() bool       { return ev.typ == LogType }
-func (ev Event) IsEndSpan() bool   { return ev.typ == EndSpanType }
-func (ev Event) IsStartSpan() bool { return ev.typ == StartSpanType }
-func (ev Event) IsLabel() bool     { return ev.typ == LabelType }
-func (ev Event) IsDetach() bool    { return ev.typ == DetachType }
-func (ev Event) IsRecord() bool    { return ev.typ == RecordType }
-
-func (ev Event) Format(f fmt.State, r rune) {
-	tagMap := TagMap(ev)
-	if !ev.At.IsZero() {
-		fmt.Fprint(f, ev.At.Format("2006/01/02 15:04:05 "))
-	}
-	msg := Msg.Get(tagMap)
-	err := Err.Get(tagMap)
-	fmt.Fprint(f, msg)
-	if err != nil {
-		if f.Flag('+') {
-			fmt.Fprintf(f, ": %+v", err)
-		} else {
-			fmt.Fprintf(f, ": %v", err)
-		}
-	}
-	for index := 0; ev.Valid(index); index++ {
-		tag := ev.Tag(index)
-		// msg and err were both already printed above, so we skip them to avoid
-		// double printing
-		if !tag.Valid() || tag.Key() == Msg || tag.Key() == Err {
-			continue
-		}
-		fmt.Fprintf(f, "\n\t%v", tag)
-	}
-}
-
-func (ev Event) Valid(index int) bool {
-	return index >= 0 && index < len(ev.static)+len(ev.dynamic)
-}
-
-func (ev Event) Tag(index int) Tag {
-	if index < len(ev.static) {
-		return ev.static[index]
-	}
-	return ev.dynamic[index-len(ev.static)]
-}
-
-func (ev Event) Find(key Key) Tag {
-	for _, tag := range ev.static {
-		if tag.Key() == key {
-			return tag
-		}
-	}
-	for _, tag := range ev.dynamic {
-		if tag.Key() == key {
-			return tag
-		}
-	}
-	return Tag{}
-}
-
-func makeEvent(typ eventType, static sTags, tags []Tag) Event {
-	return Event{
-		typ:     typ,
-		static:  static,
-		dynamic: tags,
-	}
-}
diff --git a/gofumports/internal/telemetry/event/export.go b/gofumports/internal/telemetry/event/export.go
deleted file mode 100644
index beb6e8b..0000000
--- a/gofumports/internal/telemetry/event/export.go
+++ /dev/null
@@ -1,66 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"context"
-	"sync/atomic"
-	"time"
-	"unsafe"
-)
-
-// Exporter is a function that handles events.
-// It may return a modified context and event.
-type Exporter func(context.Context, Event, TagMap) context.Context
-
-var exporter unsafe.Pointer
-
-// SetExporter sets the global exporter function that handles all events.
-// The exporter is called synchronously from the event call site, so it should
-// return quickly so as not to hold up user code.
-func SetExporter(e Exporter) {
-	p := unsafe.Pointer(&e)
-	if e == nil {
-		// &e is always valid, and so p is always valid, but for the early abort
-		// of ProcessEvent to be efficient it needs to make the nil check on the
-		// pointer without having to dereference it, so we make the nil function
-		// also a nil pointer
-		p = nil
-	}
-	atomic.StorePointer(&exporter, p)
-}
-
-// deliver is called to deliver an event to the supplied exporter.
-// it will fill in the time and generate the basic tag source.
-func deliver(ctx context.Context, exporter Exporter, ev Event) context.Context {
-	// add the current time to the event
-	ev.At = time.Now()
-	// hand the event off to the current exporter
-	return exporter(ctx, ev, ev)
-}
-
-// dispatch is called to deliver an event to the global exporter if set.
-func dispatch(ctx context.Context, ev Event) context.Context {
-	// get the global exporter and abort early if there is not one
-	exporterPtr := (*Exporter)(atomic.LoadPointer(&exporter))
-	if exporterPtr == nil {
-		return ctx
-	}
-	return deliver(ctx, *exporterPtr, ev)
-}
-
-// dispatchPair is called to deliver a start event to the supplied exporter.
-// It also returns a function that will deliver the end event to the same
-// exporter.
-// it will fill in the time and generate the basic tag source.
-func dispatchPair(ctx context.Context, begin, end Event) (context.Context, func()) {
-	// get the global exporter and abort early if there is not one
-	exporterPtr := (*Exporter)(atomic.LoadPointer(&exporter))
-	if exporterPtr == nil {
-		return ctx, func() {}
-	}
-	ctx = deliver(ctx, *exporterPtr, begin)
-	return ctx, func() { deliver(ctx, *exporterPtr, end) }
-}
diff --git a/gofumports/internal/telemetry/event/key.go b/gofumports/internal/telemetry/event/key.go
deleted file mode 100644
index acde751..0000000
--- a/gofumports/internal/telemetry/event/key.go
+++ /dev/null
@@ -1,565 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"fmt"
-	"io"
-	"math"
-	"strconv"
-)
-
-var (
-	// Msg is a key used to add message strings to tag lists.
-	Msg = NewStringKey("message", "a readable message")
-	// Name is used for things like traces that have a name.
-	Name = NewStringKey("name", "an entity name")
-	// Err is a key used to add error values to tag lists.
-	Err = NewErrorKey("error", "an error that occurred")
-)
-
-// Key is used as the identity of a Tag.
-// Keys are intended to be compared by pointer only, the name should be unique
-// for communicating with external systems, but it is not required or enforced.
-type Key interface {
-	// Name returns the key name.
-	Name() string
-	// Description returns a string that can be used to describe the value.
-	Description() string
-
-	// Format is used in formatting to append the value of the tag to the
-	// supplied buffer.
-	// The formatter may use the supplied buf as a scratch area to avoid
-	// allocations.
-	Format(w io.Writer, buf []byte, tag Tag)
-}
-
-// ValueKey represents a key for untyped values.
-type ValueKey struct {
-	name        string
-	description string
-}
-
-// NewKey creates a new Key for untyped values.
-func NewKey(name, description string) *ValueKey {
-	return &ValueKey{name: name, description: description}
-}
-
-func (k *ValueKey) Name() string        { return k.name }
-func (k *ValueKey) Description() string { return k.description }
-
-func (k *ValueKey) Format(w io.Writer, buf []byte, tag Tag) {
-	fmt.Fprint(w, k.From(tag))
-}
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *ValueKey) Get(tags TagMap) interface{} {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return nil
-}
-
-// From can be used to get a value from a Tag.
-func (k *ValueKey) From(t Tag) interface{} { return t.UnpackValue() }
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *ValueKey) Of(value interface{}) Tag { return TagOfValue(k, value) }
-
-// IntKey represents a key
-type IntKey struct {
-	name        string
-	description string
-}
-
-// NewIntKey creates a new Key for int values.
-func NewIntKey(name, description string) *IntKey {
-	return &IntKey{name: name, description: description}
-}
-
-func (k *IntKey) Name() string        { return k.name }
-func (k *IntKey) Description() string { return k.description }
-
-func (k *IntKey) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *IntKey) Of(v int) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *IntKey) Get(tags TagMap) int {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *IntKey) From(t Tag) int { return int(t.Unpack64()) }
-
-// Int8Key represents a key
-type Int8Key struct {
-	name        string
-	description string
-}
-
-// NewInt8Key creates a new Key for int8 values.
-func NewInt8Key(name, description string) *Int8Key {
-	return &Int8Key{name: name, description: description}
-}
-
-func (k *Int8Key) Name() string        { return k.name }
-func (k *Int8Key) Description() string { return k.description }
-
-func (k *Int8Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *Int8Key) Of(v int8) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *Int8Key) Get(tags TagMap) int8 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *Int8Key) From(t Tag) int8 { return int8(t.Unpack64()) }
-
-// Int16Key represents a key
-type Int16Key struct {
-	name        string
-	description string
-}
-
-// NewInt16Key creates a new Key for int16 values.
-func NewInt16Key(name, description string) *Int16Key {
-	return &Int16Key{name: name, description: description}
-}
-
-func (k *Int16Key) Name() string        { return k.name }
-func (k *Int16Key) Description() string { return k.description }
-
-func (k *Int16Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *Int16Key) Of(v int16) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *Int16Key) Get(tags TagMap) int16 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *Int16Key) From(t Tag) int16 { return int16(t.Unpack64()) }
-
-// Int32Key represents a key
-type Int32Key struct {
-	name        string
-	description string
-}
-
-// NewInt32Key creates a new Key for int32 values.
-func NewInt32Key(name, description string) *Int32Key {
-	return &Int32Key{name: name, description: description}
-}
-
-func (k *Int32Key) Name() string        { return k.name }
-func (k *Int32Key) Description() string { return k.description }
-
-func (k *Int32Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendInt(buf, int64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *Int32Key) Of(v int32) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *Int32Key) Get(tags TagMap) int32 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *Int32Key) From(t Tag) int32 { return int32(t.Unpack64()) }
-
-// Int64Key represents a key
-type Int64Key struct {
-	name        string
-	description string
-}
-
-// NewInt64Key creates a new Key for int64 values.
-func NewInt64Key(name, description string) *Int64Key {
-	return &Int64Key{name: name, description: description}
-}
-
-func (k *Int64Key) Name() string        { return k.name }
-func (k *Int64Key) Description() string { return k.description }
-
-func (k *Int64Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendInt(buf, k.From(tag), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *Int64Key) Of(v int64) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *Int64Key) Get(tags TagMap) int64 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *Int64Key) From(t Tag) int64 { return int64(t.Unpack64()) }
-
-// UIntKey represents a key
-type UIntKey struct {
-	name        string
-	description string
-}
-
-// NewUIntKey creates a new Key for uint values.
-func NewUIntKey(name, description string) *UIntKey {
-	return &UIntKey{name: name, description: description}
-}
-
-func (k *UIntKey) Name() string        { return k.name }
-func (k *UIntKey) Description() string { return k.description }
-
-func (k *UIntKey) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *UIntKey) Of(v uint) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *UIntKey) Get(tags TagMap) uint {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *UIntKey) From(t Tag) uint { return uint(t.Unpack64()) }
-
-// UInt8Key represents a key
-type UInt8Key struct {
-	name        string
-	description string
-}
-
-// NewUInt8Key creates a new Key for uint8 values.
-func NewUInt8Key(name, description string) *UInt8Key {
-	return &UInt8Key{name: name, description: description}
-}
-
-func (k *UInt8Key) Name() string        { return k.name }
-func (k *UInt8Key) Description() string { return k.description }
-
-func (k *UInt8Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *UInt8Key) Of(v uint8) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *UInt8Key) Get(tags TagMap) uint8 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *UInt8Key) From(t Tag) uint8 { return uint8(t.Unpack64()) }
-
-// UInt16Key represents a key
-type UInt16Key struct {
-	name        string
-	description string
-}
-
-// NewUInt16Key creates a new Key for uint16 values.
-func NewUInt16Key(name, description string) *UInt16Key {
-	return &UInt16Key{name: name, description: description}
-}
-
-func (k *UInt16Key) Name() string        { return k.name }
-func (k *UInt16Key) Description() string { return k.description }
-
-func (k *UInt16Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *UInt16Key) Of(v uint16) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *UInt16Key) Get(tags TagMap) uint16 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *UInt16Key) From(t Tag) uint16 { return uint16(t.Unpack64()) }
-
-// UInt32Key represents a key
-type UInt32Key struct {
-	name        string
-	description string
-}
-
-// NewUInt32Key creates a new Key for uint32 values.
-func NewUInt32Key(name, description string) *UInt32Key {
-	return &UInt32Key{name: name, description: description}
-}
-
-func (k *UInt32Key) Name() string        { return k.name }
-func (k *UInt32Key) Description() string { return k.description }
-
-func (k *UInt32Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendUint(buf, uint64(k.From(tag)), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *UInt32Key) Of(v uint32) Tag { return TagOf64(k, uint64(v)) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *UInt32Key) Get(tags TagMap) uint32 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *UInt32Key) From(t Tag) uint32 { return uint32(t.Unpack64()) }
-
-// UInt64Key represents a key
-type UInt64Key struct {
-	name        string
-	description string
-}
-
-// NewUInt64Key creates a new Key for uint64 values.
-func NewUInt64Key(name, description string) *UInt64Key {
-	return &UInt64Key{name: name, description: description}
-}
-
-func (k *UInt64Key) Name() string        { return k.name }
-func (k *UInt64Key) Description() string { return k.description }
-
-func (k *UInt64Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendUint(buf, k.From(tag), 10))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *UInt64Key) Of(v uint64) Tag { return TagOf64(k, v) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *UInt64Key) Get(tags TagMap) uint64 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *UInt64Key) From(t Tag) uint64 { return t.Unpack64() }
-
-// Float32Key represents a key
-type Float32Key struct {
-	name        string
-	description string
-}
-
-// NewFloat32Key creates a new Key for float32 values.
-func NewFloat32Key(name, description string) *Float32Key {
-	return &Float32Key{name: name, description: description}
-}
-
-func (k *Float32Key) Name() string        { return k.name }
-func (k *Float32Key) Description() string { return k.description }
-
-func (k *Float32Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendFloat(buf, float64(k.From(tag)), 'E', -1, 32))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *Float32Key) Of(v float32) Tag {
-	return TagOf64(k, uint64(math.Float32bits(v)))
-}
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *Float32Key) Get(tags TagMap) float32 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *Float32Key) From(t Tag) float32 {
-	return math.Float32frombits(uint32(t.Unpack64()))
-}
-
-// Float64Key represents a key
-type Float64Key struct {
-	name        string
-	description string
-}
-
-// NewFloat64Key creates a new Key for int64 values.
-func NewFloat64Key(name, description string) *Float64Key {
-	return &Float64Key{name: name, description: description}
-}
-
-func (k *Float64Key) Name() string        { return k.name }
-func (k *Float64Key) Description() string { return k.description }
-
-func (k *Float64Key) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendFloat(buf, k.From(tag), 'E', -1, 64))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *Float64Key) Of(v float64) Tag {
-	return TagOf64(k, math.Float64bits(v))
-}
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *Float64Key) Get(tags TagMap) float64 {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return 0
-}
-
-// From can be used to get a value from a Tag.
-func (k *Float64Key) From(t Tag) float64 {
-	return math.Float64frombits(t.Unpack64())
-}
-
-// StringKey represents a key
-type StringKey struct {
-	name        string
-	description string
-}
-
-// NewStringKey creates a new Key for int64 values.
-func NewStringKey(name, description string) *StringKey {
-	return &StringKey{name: name, description: description}
-}
-
-func (k *StringKey) Name() string        { return k.name }
-func (k *StringKey) Description() string { return k.description }
-
-func (k *StringKey) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendQuote(buf, k.From(tag)))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *StringKey) Of(v string) Tag { return TagOfString(k, v) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *StringKey) Get(tags TagMap) string {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return ""
-}
-
-// From can be used to get a value from a Tag.
-func (k *StringKey) From(t Tag) string { return t.UnpackString() }
-
-// BooleanKey represents a key
-type BooleanKey struct {
-	name        string
-	description string
-}
-
-// NewBooleanKey creates a new Key for bool values.
-func NewBooleanKey(name, description string) *BooleanKey {
-	return &BooleanKey{name: name, description: description}
-}
-
-func (k *BooleanKey) Name() string        { return k.name }
-func (k *BooleanKey) Description() string { return k.description }
-
-func (k *BooleanKey) Format(w io.Writer, buf []byte, tag Tag) {
-	w.Write(strconv.AppendBool(buf, k.From(tag)))
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *BooleanKey) Of(v bool) Tag {
-	if v {
-		return TagOf64(k, 1)
-	}
-	return TagOf64(k, 0)
-}
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *BooleanKey) Get(tags TagMap) bool {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return false
-}
-
-// From can be used to get a value from a Tag.
-func (k *BooleanKey) From(t Tag) bool { return t.Unpack64() > 0 }
-
-// ErrorKey represents a key
-type ErrorKey struct {
-	name        string
-	description string
-}
-
-// NewErrorKey creates a new Key for int64 values.
-func NewErrorKey(name, description string) *ErrorKey {
-	return &ErrorKey{name: name, description: description}
-}
-
-func (k *ErrorKey) Name() string        { return k.name }
-func (k *ErrorKey) Description() string { return k.description }
-
-func (k *ErrorKey) Format(w io.Writer, buf []byte, tag Tag) {
-	io.WriteString(w, k.From(tag).Error())
-}
-
-// Of creates a new Tag with this key and the supplied value.
-func (k *ErrorKey) Of(v error) Tag { return TagOfValue(k, v) }
-
-// Get can be used to get a tag for the key from a TagMap.
-func (k *ErrorKey) Get(tags TagMap) error {
-	if t := tags.Find(k); t.Valid() {
-		return k.From(t)
-	}
-	return nil
-}
-
-// From can be used to get a value from a Tag.
-func (k *ErrorKey) From(t Tag) error {
-	err, _ := t.UnpackValue().(error)
-	return err
-}
diff --git a/gofumports/internal/telemetry/event/label.go b/gofumports/internal/telemetry/event/label.go
deleted file mode 100644
index edd34bb..0000000
--- a/gofumports/internal/telemetry/event/label.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"context"
-)
-
-// Label sends a label event to the exporter with the supplied tags.
-func Label(ctx context.Context, tags ...Tag) context.Context {
-	return dispatch(ctx, makeEvent(LabelType, sTags{}, tags))
-}
-
-// Label1 sends a label event to the exporter with the supplied tags.
-func Label1(ctx context.Context, t1 Tag) context.Context {
-	return dispatch(ctx, makeEvent(LabelType, sTags{t1}, nil))
-}
-
-// Label2 sends a label event to the exporter with the supplied tags.
-func Label2(ctx context.Context, t1, t2 Tag) context.Context {
-	return dispatch(ctx, makeEvent(LabelType, sTags{t1, t2}, nil))
-}
-
-// Label3 sends a label event to the exporter with the supplied tags.
-func Label3(ctx context.Context, t1, t2, t3 Tag) context.Context {
-	return dispatch(ctx, makeEvent(LabelType, sTags{t1, t2, t3}, nil))
-}
diff --git a/gofumports/internal/telemetry/event/log.go b/gofumports/internal/telemetry/event/log.go
deleted file mode 100644
index c3e163c..0000000
--- a/gofumports/internal/telemetry/event/log.go
+++ /dev/null
@@ -1,68 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"context"
-	"errors"
-	"fmt"
-)
-
-// Log sends a log event with the supplied tag list to the exporter.
-func Log(ctx context.Context, tags ...Tag) {
-	dispatch(ctx, makeEvent(LogType, sTags{}, tags))
-}
-
-// Log1 sends a label event to the exporter with the supplied tags.
-func Log1(ctx context.Context, t1 Tag) context.Context {
-	return dispatch(ctx, makeEvent(LogType, sTags{t1}, nil))
-}
-
-// Log2 sends a label event to the exporter with the supplied tags.
-func Log2(ctx context.Context, t1, t2 Tag) context.Context {
-	return dispatch(ctx, makeEvent(LogType, sTags{t1, t2}, nil))
-}
-
-// Log3 sends a label event to the exporter with the supplied tags.
-func Log3(ctx context.Context, t1, t2, t3 Tag) context.Context {
-	return dispatch(ctx, makeEvent(LogType, sTags{t1, t2, t3}, nil))
-}
-
-// Print takes a message and a tag list and combines them into a single event
-// before delivering them to the exporter.
-func Print(ctx context.Context, message string, tags ...Tag) {
-	dispatch(ctx, makeEvent(LogType, sTags{Msg.Of(message)}, tags))
-}
-
-// Print1 takes a message and one tag delivers a log event to the exporter.
-// It is a customized version of Print that is faster and does no allocation.
-func Print1(ctx context.Context, message string, t1 Tag) {
-	dispatch(ctx, makeEvent(LogType, sTags{Msg.Of(message), t1}, nil))
-}
-
-// Print2 takes a message and two tags and delivers a log event to the exporter.
-// It is a customized version of Print that is faster and does no allocation.
-func Print2(ctx context.Context, message string, t1, t2 Tag) {
-	dispatch(ctx, makeEvent(LogType, sTags{Msg.Of(message), t1, t2}, nil))
-}
-
-// Error takes a message and a tag list and combines them into a single event
-// before delivering them to the exporter. It captures the error in the
-// delivered event.
-func Error(ctx context.Context, message string, err error, tags ...Tag) {
-	if err == nil {
-		err = errors.New(message)
-		message = ""
-	}
-	dispatch(ctx, makeEvent(LogType, sTags{Msg.Of(message), Err.Of(err)}, tags))
-}
-
-// Debugf sends a log event with the supplied message to the exporter.
-// This is intended only for temporary debugging lines, and usage should not
-// normally be checked in, preffering structured log events for things
-// that have to be used in production.
-func Debugf(ctx context.Context, message string, args ...interface{}) {
-	dispatch(ctx, makeEvent(LogType, sTags{Msg.Of(fmt.Sprintf(message, args...))}, nil))
-}
diff --git a/gofumports/internal/telemetry/event/metric.go b/gofumports/internal/telemetry/event/metric.go
deleted file mode 100644
index e4092bb..0000000
--- a/gofumports/internal/telemetry/event/metric.go
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"context"
-)
-
-// Record sends a label event to the exporter with the supplied tags.
-func Record(ctx context.Context, tags ...Tag) context.Context {
-	return dispatch(ctx, makeEvent(RecordType, sTags{}, tags))
-}
-
-// Record1 sends a label event to the exporter with the supplied tags.
-func Record1(ctx context.Context, t1 Tag) context.Context {
-	return dispatch(ctx, makeEvent(RecordType, sTags{t1}, nil))
-}
-
-// Record2 sends a label event to the exporter with the supplied tags.
-func Record2(ctx context.Context, t1, t2 Tag) context.Context {
-	return dispatch(ctx, makeEvent(RecordType, sTags{t1, t2}, nil))
-}
-
-// Record3 sends a label event to the exporter with the supplied tags.
-func Record3(ctx context.Context, t1, t2, t3 Tag) context.Context {
-	return dispatch(ctx, makeEvent(RecordType, sTags{t1, t2, t3}, nil))
-}
diff --git a/gofumports/internal/telemetry/event/tag.go b/gofumports/internal/telemetry/event/tag.go
deleted file mode 100644
index 5230736..0000000
--- a/gofumports/internal/telemetry/event/tag.go
+++ /dev/null
@@ -1,197 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"fmt"
-	"io"
-	"reflect"
-	"unsafe"
-)
-
-// Tag holds a key and value pair.
-// It is normally used when passing around lists of tags.
-type Tag struct {
-	key     Key
-	packed  uint64
-	untyped interface{}
-}
-
-// TagMap is the interface to a collection of Tags indexed by key.
-type TagMap interface {
-	// Find returns the tag that matches the supplied key.
-	Find(key Key) Tag
-}
-
-// TagList is the interface to something that provides an iterable
-// list of tags.
-// Iteration should start from 0 and continue until Valid returns false.
-type TagList interface {
-	// Valid returns true if the index is within range for the list.
-	// It does not imply the tag at that index will itself be valid.
-	Valid(index int) bool
-	// Tag returns the tag at the given index.
-	Tag(index int) Tag
-}
-
-// tagList implements TagList for a list of Tags.
-type tagList struct {
-	tags []Tag
-}
-
-// tagFilter wraps a TagList filtering out specific tags.
-type tagFilter struct {
-	keys       []Key
-	underlying TagList
-}
-
-// tagMap implements TagMap for a simple list of tags.
-type tagMap struct {
-	tags []Tag
-}
-
-// tagMapChain implements TagMap for a list of underlying TagMap.
-type tagMapChain struct {
-	maps []TagMap
-}
-
-// TagOfValue creates a new tag from the key and value.
-// This method is for implementing new key types, tag creation should
-// normally be done with the Of method of the key.
-func TagOfValue(k Key, value interface{}) Tag { return Tag{key: k, untyped: value} }
-
-// UnpackValue assumes the tag was built using TagOfValue and returns the value
-// that was passed to that constructor.
-// This method is for implementing new key types, for type safety normal
-// access should be done with the From method of the key.
-func (t Tag) UnpackValue() interface{} { return t.untyped }
-
-// TagOf64 creates a new tag from a key and a uint64. This is often
-// used for non uint64 values that can be packed into a uint64.
-// This method is for implementing new key types, tag creation should
-// normally be done with the Of method of the key.
-func TagOf64(k Key, v uint64) Tag { return Tag{key: k, packed: v} }
-
-// Unpack64 assumes the tag was built using TagOf64 and returns the value that
-// was passed to that constructor.
-// This method is for implementing new key types, for type safety normal
-// access should be done with the From method of the key.
-func (t Tag) Unpack64() uint64 { return t.packed }
-
-// TagOfString creates a new tag from a key and a string.
-// This method is for implementing new key types, tag creation should
-// normally be done with the Of method of the key.
-func TagOfString(k Key, v string) Tag {
-	hdr := (*reflect.StringHeader)(unsafe.Pointer(&v))
-	return Tag{
-		key:     k,
-		packed:  uint64(hdr.Len),
-		untyped: unsafe.Pointer(hdr.Data),
-	}
-}
-
-// UnpackString assumes the tag was built using TagOfString and returns the
-// value that was passed to that constructor.
-// This method is for implementing new key types, for type safety normal
-// access should be done with the From method of the key.
-func (t Tag) UnpackString() string {
-	var v string
-	hdr := (*reflect.StringHeader)(unsafe.Pointer(&v))
-	hdr.Data = uintptr(t.untyped.(unsafe.Pointer))
-	hdr.Len = int(t.packed)
-	return *(*string)(unsafe.Pointer(hdr))
-}
-
-// Valid returns true if the Tag is a valid one (it has a key).
-func (t Tag) Valid() bool { return t.key != nil }
-
-// Key returns the key of this Tag.
-func (t Tag) Key() Key { return t.key }
-
-// Format is used for debug printing of tags.
-func (t Tag) Format(f fmt.State, r rune) {
-	if !t.Valid() {
-		io.WriteString(f, `nil`)
-		return
-	}
-	io.WriteString(f, t.Key().Name())
-	io.WriteString(f, "=")
-	var buf [128]byte
-	t.Key().Format(f, buf[:0], t)
-}
-
-func (l *tagList) Valid(index int) bool {
-	return index >= 0 && index < len(l.tags)
-}
-
-func (l *tagList) Tag(index int) Tag {
-	return l.tags[index]
-}
-
-func (f *tagFilter) Valid(index int) bool {
-	return f.underlying.Valid(index)
-}
-
-func (f *tagFilter) Tag(index int) Tag {
-	tag := f.underlying.Tag(index)
-	for _, f := range f.keys {
-		if tag.Key() == f {
-			return Tag{}
-		}
-	}
-	return tag
-}
-
-func (l tagMap) Find(key Key) Tag {
-	for _, tag := range l.tags {
-		if tag.Key() == key {
-			return tag
-		}
-	}
-	return Tag{}
-}
-
-func (c tagMapChain) Find(key Key) Tag {
-	for _, src := range c.maps {
-		tag := src.Find(key)
-		if tag.Valid() {
-			return tag
-		}
-	}
-	return Tag{}
-}
-
-var emptyList = &tagList{}
-
-func NewTagList(tags ...Tag) TagList {
-	if len(tags) == 0 {
-		return emptyList
-	}
-	return &tagList{tags: tags}
-}
-
-func Filter(l TagList, keys ...Key) TagList {
-	if len(keys) == 0 {
-		return l
-	}
-	return &tagFilter{keys: keys, underlying: l}
-}
-
-func NewTagMap(tags ...Tag) TagMap {
-	return tagMap{tags: tags}
-}
-
-func MergeTagMaps(srcs ...TagMap) TagMap {
-	var nonNil []TagMap
-	for _, src := range srcs {
-		if src != nil {
-			nonNil = append(nonNil, src)
-		}
-	}
-	if len(nonNil) == 1 {
-		return nonNil[0]
-	}
-	return tagMapChain{maps: nonNil}
-}
diff --git a/gofumports/internal/telemetry/event/trace.go b/gofumports/internal/telemetry/event/trace.go
deleted file mode 100644
index 2c40341..0000000
--- a/gofumports/internal/telemetry/event/trace.go
+++ /dev/null
@@ -1,42 +0,0 @@
-// Copyright 2019 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package event
-
-import (
-	"context"
-)
-
-// StartSpan sends a span start event with the supplied tag list to the exporter.
-// It also returns a function that will end the span, which should normally be
-// deferred.
-func StartSpan(ctx context.Context, name string, tags ...Tag) (context.Context, func()) {
-	return dispatchPair(ctx,
-		makeEvent(StartSpanType, sTags{Name.Of(name)}, tags),
-		makeEvent(EndSpanType, sTags{}, nil))
-}
-
-// StartSpan1 sends a span start event with the supplied tag list to the exporter.
-// It also returns a function that will end the span, which should normally be
-// deferred.
-func StartSpan1(ctx context.Context, name string, t1 Tag) (context.Context, func()) {
-	return dispatchPair(ctx,
-		makeEvent(StartSpanType, sTags{Name.Of(name), t1}, nil),
-		makeEvent(EndSpanType, sTags{}, nil))
-}
-
-// StartSpan2 sends a span start event with the supplied tag list to the exporter.
-// It also returns a function that will end the span, which should normally be
-// deferred.
-func StartSpan2(ctx context.Context, name string, t1, t2 Tag) (context.Context, func()) {
-	return dispatchPair(ctx,
-		makeEvent(StartSpanType, sTags{Name.Of(name), t1, t2}, nil),
-		makeEvent(EndSpanType, sTags{}, nil))
-}
-
-// Detach returns a context without an associated span.
-// This allows the creation of spans that are not children of the current span.
-func Detach(ctx context.Context) context.Context {
-	return dispatch(ctx, makeEvent(DetachType, sTags{}, nil))
-}
diff --git a/gofumports/main_test.go b/gofumports/main_test.go
deleted file mode 100644
index d205d34..0000000
--- a/gofumports/main_test.go
+++ /dev/null
@@ -1,38 +0,0 @@
-// Copyright (c) 2019, Daniel Mart√≠ <mvdan@mvdan.cc>
-// See LICENSE for licensing information
-
-package main
-
-import (
-	"os"
-	"path/filepath"
-	"testing"
-
-	"github.com/rogpeppe/go-internal/gotooltest"
-	"github.com/rogpeppe/go-internal/testscript"
-)
-
-func TestMain(m *testing.M) {
-	os.Exit(testscript.RunMain(m, map[string]func() int{
-		"gofumpt": func() int {
-			// Don't change gofmtMain, to keep changes to the gofmt
-			// codebase to a minimum.
-			gofmtMain()
-			return exitCode
-		},
-	}))
-}
-
-func TestScripts(t *testing.T) {
-	t.Parallel()
-	p := testscript.Params{
-		Dir: filepath.Join("..", "testdata", "scripts"),
-		Condition: func(cond string) (bool, error) {
-			return false, nil
-		},
-	}
-	if err := gotooltest.Setup(&p); err != nil {
-		t.Fatal(err)
-	}
-	testscript.Run(t, p)
-}
diff --git a/main_test.go b/main_test.go
index e3a0058..06e6b03 100644
--- a/main_test.go
+++ b/main_test.go
@@ -25,13 +25,6 @@ func TestScripts(t *testing.T) {
 	t.Parallel()
 	p := testscript.Params{
 		Dir: filepath.Join("testdata", "scripts"),
-		Condition: func(cond string) (bool, error) {
-			switch cond {
-			case "gofumpt":
-				return true, nil
-			}
-			return false, nil
-		},
 	}
 	if err := gotooltest.Setup(&p); err != nil {
 		t.Fatal(err)
diff --git a/testdata/scripts/cgo.txt b/testdata/scripts/cgo.txt
index 71f345f..672c5f7 100644
--- a/testdata/scripts/cgo.txt
+++ b/testdata/scripts/cgo.txt
@@ -1,5 +1,3 @@
-[!gofumpt] skip 'don''t add or remove imports'
-
 gofumpt -w foo.go
 cmp foo.go foo.go.golden
 
diff --git a/testdata/scripts/decl-group-many.txt b/testdata/scripts/decl-group-many.txt
index 104c66d..5f07aa4 100644
--- a/testdata/scripts/decl-group-many.txt
+++ b/testdata/scripts/decl-group-many.txt
@@ -1,5 +1,3 @@
-[!gofumpt] skip 'would remove the unused imports'
-
 gofumpt -w foo.go
 cmp foo.go foo.go.golden
 
diff --git a/testdata/scripts/decl-group-single.txt b/testdata/scripts/decl-group-single.txt
index 257be5a..8cdbf6e 100644
--- a/testdata/scripts/decl-group-single.txt
+++ b/testdata/scripts/decl-group-single.txt
@@ -1,5 +1,3 @@
-[!gofumpt] skip 'would remove the unused imports'
-
 gofumpt -w f1.go f2.go
 cmp f1.go f1.go.golden
 cmp f2.go f2.go.golden
diff --git a/testdata/scripts/func-merge-parameters.txt b/testdata/scripts/func-merge-parameters.txt
index 408e293..0c0548f 100644
--- a/testdata/scripts/func-merge-parameters.txt
+++ b/testdata/scripts/func-merge-parameters.txt
@@ -2,9 +2,7 @@
 gofumpt foo.go
 cmp stdout foo.go
 
-# It's run with -extra. Note that the flag isn't available in gofumports,
-# following the lack of -s.
-[!gofumpt] skip
+# It's run with -extra.
 gofumpt -extra foo.go
 cmp stdout foo.go.golden
 
diff --git a/testdata/scripts/missing-import.txt b/testdata/scripts/missing-import.txt
index e9fa2eb..4bd4926 100644
--- a/testdata/scripts/missing-import.txt
+++ b/testdata/scripts/missing-import.txt
@@ -1,18 +1,8 @@
-gofumpt -w foo.go
-[gofumpt] cmp foo.go foo.go.gofumpt
-[!gofumpt] cmp foo.go foo.go.gofumports
+# A missing import shouldn't matter nor be fixed by gofumpt.
+gofumpt foo.go
+cmp stdout foo.go
 
 -- foo.go --
 package p
 
 var _ bytes.Buffer
--- foo.go.gofumpt --
-package p
-
-var _ bytes.Buffer
--- foo.go.gofumports --
-package p
-
-import "bytes"
-
-var _ bytes.Buffer
diff --git a/testdata/scripts/simplify.txt b/testdata/scripts/simplify.txt
index 7cc582e..d1c53d5 100644
--- a/testdata/scripts/simplify.txt
+++ b/testdata/scripts/simplify.txt
@@ -1,8 +1,6 @@
-# gofumpt changes -s to default to true. Note that goimports, and thus
-# gofumports, has no such flag.
+# gofumpt changes -s to default to true.
 gofumpt foo.go
-[gofumpt] cmp stdout foo.go.golden
-[!gofumpt] cmp stdout foo.go
+cmp stdout foo.go.golden
 
 -- foo.go --
 package p
diff --git a/testdata/scripts/std-imports.txt b/testdata/scripts/std-imports.txt
index 1d9e0f2..3a68c6a 100644
--- a/testdata/scripts/std-imports.txt
+++ b/testdata/scripts/std-imports.txt
@@ -1,5 +1,3 @@
-[!gofumpt] skip 'don''t add or remove imports'
-
 gofumpt -w foo.go
 cmp foo.go foo.go.golden
 
