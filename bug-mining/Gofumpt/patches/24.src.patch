diff --git a/README.md b/README.md
index 63e6e84..7428657 100644
--- a/README.md
+++ b/README.md
@@ -75,13 +75,24 @@ if err != nil {
 
 </details>
 
-Composite literals with elements in separate lines must also separate both braces
+Composite literals should use newlines consistently
 
 <details><summary>example</summary>
 
 ```
+// A newline before or after an element requires newlines for the opening and
+// closing braces.
 var ints = []int{1, 2,
 	3, 4}
+
+// A newline between consecutive elements requires a newline between all
+// elements.
+var matrix = [][]int{
+	{1},
+	{2}, {
+		3,
+	},
+}
 ```
 
 ```
@@ -89,6 +100,14 @@ var ints = []int{
 	1, 2,
 	3, 4,
 }
+
+var matrix = [][]int{
+	{1},
+	{2},
+	{
+		3,
+	},
+}
 ```
 
 </details>
diff --git a/internal/gofumpt.go b/internal/gofumpt.go
index c34bc05..aa52572 100644
--- a/internal/gofumpt.go
+++ b/internal/gofumpt.go
@@ -367,28 +367,41 @@ func (f *fumpter) applyPre(c *astutil.Cursor) {
 			break
 		}
 
+		newlineAroundElems := false
 		newlineBetweenElems := false
 		lastLine := openLine
-		for _, elem := range node.Elts {
+		for i, elem := range node.Elts {
 			if f.Line(elem.Pos()) > lastLine {
-				newlineBetweenElems = true
+				if i == 0 {
+					newlineAroundElems = true
+				} else {
+					newlineBetweenElems = true
+				}
 			}
 			lastLine = f.Line(elem.End())
 		}
 		if closeLine > lastLine {
-			newlineBetweenElems = true
+			newlineAroundElems = true
 		}
 
-		if !newlineBetweenElems {
-			// no newlines between elements (and braces)
-			break
+		if newlineBetweenElems || newlineAroundElems {
+			first := node.Elts[0]
+			if openLine == f.Line(first.Pos()) {
+				// We want the newline right after the brace.
+				f.addNewline(node.Lbrace + 1)
+				closeLine = f.Line(node.Rbrace)
+			}
+			last := node.Elts[len(node.Elts)-1]
+			if closeLine == f.Line(last.End()) {
+				// We want the newline right before the brace.
+				f.addNewline(node.Rbrace)
+			}
 		}
 
-		first := node.Elts[0]
-		if openLine == f.Line(first.Pos()) {
-			// We want the newline right after the brace.
-			f.addNewline(node.Lbrace + 1)
-			closeLine = f.Line(node.Rbrace)
+		// If there's a newline between any consecutive elements, there
+		// must be a newline between all composite literal elements.
+		if !newlineBetweenElems {
+			break
 		}
 		for i1, elem1 := range node.Elts {
 			i2 := i1 + 1
@@ -402,17 +415,10 @@ func (f *fumpter) applyPre(c *astutil.Cursor) {
 			if !ok1 && !ok2 {
 				continue
 			}
-			// If there's a newline between any consecutive
-			// elements, there must be a newline between all
-			// composite literal elements.
 			if f.Line(elem1.End()) == f.Line(elem2.Pos()) {
 				f.addNewline(elem1.End())
 			}
 		}
-		last := node.Elts[len(node.Elts)-1]
-		if closeLine == f.Line(last.End()) {
-			f.addNewline(last.End())
-		}
 
 	case *ast.CaseClause:
 		f.stmts(node.Body)
diff --git a/testdata/scripts/composite-multiline.txt b/testdata/scripts/composite-multiline.txt
index 688dac9..e5d1651 100644
--- a/testdata/scripts/composite-multiline.txt
+++ b/testdata/scripts/composite-multiline.txt
@@ -12,6 +12,9 @@ var _ = []int{
 var _ = []int{1, 2,
 	3, 4}
 
+var _ = []int{
+	1, 2, 3, 4}
+
 var _ = [][]string{{
 	"no need for more newlines",
 	"if wrapping a single expression",
@@ -34,6 +37,14 @@ var _ = []struct{ a int }{
 	},
 }
 
+var _ = []struct{ a int }{{
+	a: 1,
+}, {
+	a: 2,
+}, {
+	a: 3,
+}}
+
 -- foo.go.golden --
 package p
 
@@ -46,6 +57,10 @@ var _ = []int{
 	3, 4,
 }
 
+var _ = []int{
+	1, 2, 3, 4,
+}
+
 var _ = [][]string{{
 	"no need for more newlines",
 	"if wrapping a single expression",
@@ -68,3 +83,11 @@ var _ = []struct{ a int }{
 		a: 3,
 	},
 }
+
+var _ = []struct{ a int }{{
+	a: 1,
+}, {
+	a: 2,
+}, {
+	a: 3,
+}}
