diff --git a/httpclient5/src/main/java/org/apache/hc/client5/http/config/RequestConfig.java b/httpclient5/src/main/java/org/apache/hc/client5/http/config/RequestConfig.java
index 54ce77634..b18a7b122 100644
--- a/httpclient5/src/main/java/org/apache/hc/client5/http/config/RequestConfig.java
+++ b/httpclient5/src/main/java/org/apache/hc/client5/http/config/RequestConfig.java
@@ -531,6 +531,12 @@ public Builder setConnectTimeout(final long connectTimeout, final TimeUnit timeU
          * HTTP transports with message multiplexing.
          * </p>
          * <p>
+         * Please note that response timeout is not a deadline. Its absolute value
+         * can be exceeded, for example, in case of automatic request re-execution.
+         * Please make sure the automatic request re-execution policy has been
+         * configured appropriately.
+         * </p>
+         * <p>
          * Default: {@code null}
          * </p>
          *
diff --git a/httpclient5/src/main/java/org/apache/hc/client5/http/impl/DefaultHttpRequestRetryStrategy.java b/httpclient5/src/main/java/org/apache/hc/client5/http/impl/DefaultHttpRequestRetryStrategy.java
index b8dfcb535..47c9bab56 100644
--- a/httpclient5/src/main/java/org/apache/hc/client5/http/impl/DefaultHttpRequestRetryStrategy.java
+++ b/httpclient5/src/main/java/org/apache/hc/client5/http/impl/DefaultHttpRequestRetryStrategy.java
@@ -41,6 +41,8 @@
 import javax.net.ssl.SSLException;
 
 import org.apache.hc.client5.http.HttpRequestRetryStrategy;
+import org.apache.hc.client5.http.config.RequestConfig;
+import org.apache.hc.client5.http.protocol.HttpClientContext;
 import org.apache.hc.client5.http.utils.DateUtils;
 import org.apache.hc.core5.annotation.Contract;
 import org.apache.hc.core5.annotation.ThreadingBehavior;
@@ -55,6 +57,7 @@
 import org.apache.hc.core5.http.protocol.HttpContext;
 import org.apache.hc.core5.util.Args;
 import org.apache.hc.core5.util.TimeValue;
+import org.apache.hc.core5.util.Timeout;
 
 /**
  * Default implementation of the {@link HttpRequestRetryStrategy} interface.
@@ -95,7 +98,8 @@ protected DefaultHttpRequestRetryStrategy(
             final Collection<Class<? extends IOException>> clazzes,
             final Collection<Integer> codes) {
         Args.notNegative(maxRetries, "maxRetries");
-        Args.notNegative(defaultRetryInterval.getDuration(), "defaultRetryInterval");
+        Args.notNull(defaultRetryInterval, "defaultRetryInterval");
+        Args.check(TimeValue.isNonNegative(defaultRetryInterval), "Default retry interval is negative");
         this.maxRetries = maxRetries;
         this.defaultRetryInterval = defaultRetryInterval;
         this.nonRetriableIOExceptionClasses = new HashSet<>(clazzes);
@@ -199,6 +203,14 @@ public boolean retryRequest(
             final HttpContext context) {
         Args.notNull(response, "response");
 
+        if (context != null) {
+            final HttpClientContext clientContext = HttpClientContext.cast(context);
+            final RequestConfig requestConfig = clientContext.getRequestConfigOrDefault();
+            final Timeout responseTimeout = requestConfig.getResponseTimeout();
+            if (responseTimeout != null && defaultRetryInterval.compareTo(responseTimeout) > 0) {
+                return false;
+            }
+        }
         return execCount <= this.maxRetries && retriableCodes.contains(response.getCode());
     }
 
diff --git a/httpclient5/src/main/java/org/apache/hc/client5/http/impl/async/AsyncHttpRequestRetryExec.java b/httpclient5/src/main/java/org/apache/hc/client5/http/impl/async/AsyncHttpRequestRetryExec.java
index 292b6ed07..90beadff7 100644
--- a/httpclient5/src/main/java/org/apache/hc/client5/http/impl/async/AsyncHttpRequestRetryExec.java
+++ b/httpclient5/src/main/java/org/apache/hc/client5/http/impl/async/AsyncHttpRequestRetryExec.java
@@ -126,9 +126,6 @@ public AsyncDataConsumer handleResponse(
                 state.retrying = retryStrategy.retryRequest(response, scope.execCount.get(), clientContext);
                 if (state.retrying) {
                     state.delay = retryStrategy.getRetryInterval(response, scope.execCount.get(), clientContext);
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug("{} retrying request in {}", exchangeId, state.delay);
-                    }
                     return new DiscardingEntityConsumer<>();
                 }
                 return asyncExecCallback.handleResponse(response, entityDetails);
@@ -146,13 +143,17 @@ public void completed() {
                     if (entityProducer != null) {
                        entityProducer.releaseResources();
                     }
+                    final TimeValue delay = TimeValue.isPositive(state.delay) ? state.delay : TimeValue.ZERO_MILLISECONDS;
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("{} wait for {}", exchangeId, delay);
+                    }
                     scope.scheduler.scheduleExecution(
                             request,
                             entityProducer,
                             scope,
                             (r, e, s, c) -> execute(r, e, s, chain, c),
                             asyncExecCallback,
-                            state.delay);
+                            delay);
                 } else {
                     asyncExecCallback.completed();
                 }
@@ -182,13 +183,17 @@ public void failed(final Exception cause) {
                         state.retrying = true;
                         final int execCount = scope.execCount.incrementAndGet();
                         state.delay = retryStrategy.getRetryInterval(request, (IOException) cause, execCount - 1, clientContext);
+                        final TimeValue delay = TimeValue.isPositive(state.delay) ? state.delay : TimeValue.ZERO_MILLISECONDS;
+                        if (LOG.isDebugEnabled()) {
+                            LOG.debug("{} wait for {}", exchangeId, delay);
+                        }
                         scope.scheduler.scheduleExecution(
                                 request,
                                 entityProducer,
                                 scope,
                                 (r, e, s, c) -> execute(r, e, s, chain, c),
                                 asyncExecCallback,
-                                state.delay);
+                                delay);
                         return;
                     }
                 }
diff --git a/httpclient5/src/main/java/org/apache/hc/client5/http/impl/classic/HttpRequestRetryExec.java b/httpclient5/src/main/java/org/apache/hc/client5/http/impl/classic/HttpRequestRetryExec.java
index 2ab32b664..2e0021085 100644
--- a/httpclient5/src/main/java/org/apache/hc/client5/http/impl/classic/HttpRequestRetryExec.java
+++ b/httpclient5/src/main/java/org/apache/hc/client5/http/impl/classic/HttpRequestRetryExec.java
@@ -34,7 +34,6 @@
 import org.apache.hc.client5.http.classic.ExecChain;
 import org.apache.hc.client5.http.classic.ExecChain.Scope;
 import org.apache.hc.client5.http.classic.ExecChainHandler;
-import org.apache.hc.client5.http.config.RequestConfig;
 import org.apache.hc.client5.http.impl.ChainElement;
 import org.apache.hc.client5.http.protocol.HttpClientContext;
 import org.apache.hc.core5.annotation.Contract;
@@ -48,7 +47,6 @@
 import org.apache.hc.core5.http.io.support.ClassicRequestBuilder;
 import org.apache.hc.core5.util.Args;
 import org.apache.hc.core5.util.TimeValue;
-import org.apache.hc.core5.util.Timeout;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -108,9 +106,28 @@ public ClassicHttpResponse execute(
         ClassicHttpRequest currentRequest = request;
 
         for (int execCount = 1;; execCount++) {
-            final ClassicHttpResponse response;
             try {
-                 response = chain.proceed(currentRequest, scope);
+                final ClassicHttpResponse response = chain.proceed(currentRequest, scope);
+                try {
+                    final HttpEntity entity = request.getEntity();
+                    if (entity != null && !entity.isRepeatable()) {
+                        if (LOG.isDebugEnabled()) {
+                            LOG.debug("{} cannot retry non-repeatable request", exchangeId);
+                        }
+                        return response;
+                    }
+                    if (retryStrategy.retryRequest(response, execCount, context)) {
+                        response.close();
+                        final TimeValue delay = retryStrategy.getRetryInterval(response, execCount, context);
+                        pause(exchangeId, delay);
+                        currentRequest = ClassicRequestBuilder.copy(scope.originalRequest).build();
+                    } else {
+                        return response;
+                    }
+                } catch (final RuntimeException ex) {
+                    response.close();
+                    throw ex;
+                }
             } catch (final IOException ex) {
                 if (scope.execRuntime.isExecutionAborted()) {
                     throw new RequestFailedException("Request aborted");
@@ -130,18 +147,8 @@ public ClassicHttpResponse execute(
                         LOG.info("Recoverable I/O exception ({}) caught when processing request to {}",
                                 ex.getClass().getName(), route);
                     }
-                    final TimeValue nextInterval = retryStrategy.getRetryInterval(request, ex, execCount, context);
-                    if (TimeValue.isPositive(nextInterval)) {
-                        try {
-                            if (LOG.isDebugEnabled()) {
-                                LOG.debug("{} wait for {}", exchangeId, nextInterval);
-                            }
-                            nextInterval.sleep();
-                        } catch (final InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                            throw new InterruptedIOException();
-                        }
-                    }
+                    final TimeValue delay = retryStrategy.getRetryInterval(request, ex, execCount, context);
+                    pause(exchangeId, delay);
                     currentRequest = ClassicRequestBuilder.copy(scope.originalRequest).build();
                     continue;
                 }
@@ -153,44 +160,19 @@ public ClassicHttpResponse execute(
                 }
                 throw ex;
             }
+        }
+    }
 
+    private static void pause(final String exchangeId, final TimeValue delay) throws InterruptedIOException {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("{} wait for {}", exchangeId, delay);
+        }
+        if (TimeValue.isPositive(delay)) {
             try {
-                final HttpEntity entity = request.getEntity();
-                if (entity != null && !entity.isRepeatable()) {
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug("{} cannot retry non-repeatable request", exchangeId);
-                    }
-                    return response;
-                }
-                if (retryStrategy.retryRequest(response, execCount, context)) {
-                    final TimeValue nextInterval = retryStrategy.getRetryInterval(response, execCount, context);
-                    // Make sure the retry interval does not exceed the response timeout
-                    if (TimeValue.isPositive(nextInterval)) {
-                        final RequestConfig requestConfig = context.getRequestConfigOrDefault();
-                        final Timeout responseTimeout = requestConfig.getResponseTimeout();
-                        if (responseTimeout != null && nextInterval.compareTo(responseTimeout) > 0) {
-                            return response;
-                        }
-                    }
-                    response.close();
-                    if (TimeValue.isPositive(nextInterval)) {
-                        try {
-                            if (LOG.isDebugEnabled()) {
-                                LOG.debug("{} wait for {}", exchangeId, nextInterval);
-                            }
-                            nextInterval.sleep();
-                        } catch (final InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                            throw new InterruptedIOException();
-                        }
-                    }
-                    currentRequest = ClassicRequestBuilder.copy(scope.originalRequest).build();
-                } else {
-                    return response;
-                }
-            } catch (final RuntimeException ex) {
-                response.close();
-                throw ex;
+                delay.sleep();
+            } catch (final InterruptedException e) {
+                Thread.currentThread().interrupt();
+                throw new InterruptedIOException();
             }
         }
     }
diff --git a/httpclient5/src/test/java/org/apache/hc/client5/http/impl/TestDefaultHttpRequestRetryStrategy.java b/httpclient5/src/test/java/org/apache/hc/client5/http/impl/TestDefaultHttpRequestRetryStrategy.java
index 2440f5c98..4c2649b52 100644
--- a/httpclient5/src/test/java/org/apache/hc/client5/http/impl/TestDefaultHttpRequestRetryStrategy.java
+++ b/httpclient5/src/test/java/org/apache/hc/client5/http/impl/TestDefaultHttpRequestRetryStrategy.java
@@ -33,16 +33,17 @@
 import java.net.UnknownHostException;
 import java.time.Instant;
 import java.time.temporal.ChronoUnit;
-
 import javax.net.ssl.SSLException;
-
 import org.apache.hc.client5.http.classic.methods.HttpGet;
+import org.apache.hc.client5.http.config.RequestConfig;
+import org.apache.hc.client5.http.protocol.HttpClientContext;
 import org.apache.hc.client5.http.utils.DateUtils;
 import org.apache.hc.core5.http.ConnectionClosedException;
 import org.apache.hc.core5.http.HttpHeaders;
 import org.apache.hc.core5.http.HttpResponse;
 import org.apache.hc.core5.http.message.BasicHttpResponse;
 import org.apache.hc.core5.util.TimeValue;
+import org.apache.hc.core5.util.Timeout;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -74,6 +75,29 @@ void testBasics() {
         Assertions.assertEquals(TimeValue.ofMilliseconds(1234L), this.retryStrategy.getRetryInterval(response1, 1, null));
     }
 
+    @Test
+    void testRetryRequestWithResponseTimeout() {
+        final HttpResponse response = new BasicHttpResponse(503, "Oopsie");
+
+        final HttpClientContext context = HttpClientContext.create();
+        context.setRequestConfig(RequestConfig.custom()
+                .build());
+
+        Assertions.assertTrue(retryStrategy.retryRequest(response, 1, context));
+
+        context.setRequestConfig(RequestConfig.custom()
+            .setResponseTimeout(Timeout.ofMilliseconds(1234L))
+            .build());
+
+        Assertions.assertTrue(retryStrategy.retryRequest(response, 1, context));
+
+        context.setRequestConfig(RequestConfig.custom()
+                .setResponseTimeout(Timeout.ofMilliseconds(1233L))
+                .build());
+
+        Assertions.assertFalse(retryStrategy.retryRequest(response, 1, context));
+    }
+
     @Test
     void testRetryAfterHeaderAsLong() {
         final HttpResponse response = new BasicHttpResponse(503, "Oopsie");
diff --git a/httpclient5/src/test/java/org/apache/hc/client5/http/impl/classic/TestHttpRequestRetryExec.java b/httpclient5/src/test/java/org/apache/hc/client5/http/impl/classic/TestHttpRequestRetryExec.java
index 5672587c5..006ef9a50 100644
--- a/httpclient5/src/test/java/org/apache/hc/client5/http/impl/classic/TestHttpRequestRetryExec.java
+++ b/httpclient5/src/test/java/org/apache/hc/client5/http/impl/classic/TestHttpRequestRetryExec.java
@@ -45,7 +45,6 @@
 import org.apache.hc.core5.http.HttpHost;
 import org.apache.hc.core5.http.io.support.ClassicRequestBuilder;
 import org.apache.hc.core5.util.TimeValue;
-import org.apache.hc.core5.util.Timeout;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -138,38 +137,6 @@ void testRetrySleepOnIOException() throws Exception {
         Mockito.verify(nextInterval, Mockito.times(1)).sleep();
     }
 
-    @Test
-    void testRetryIntervalGreaterResponseTimeout() throws Exception {
-        final HttpRoute route = new HttpRoute(target);
-        final HttpGet request = new HttpGet("/test");
-        final HttpClientContext context = HttpClientContext.create();
-        context.setRequestConfig(RequestConfig.custom()
-                .setResponseTimeout(Timeout.ofSeconds(3))
-                .build());
-
-        final ClassicHttpResponse response = Mockito.mock(ClassicHttpResponse.class);
-
-        Mockito.when(chain.proceed(
-                Mockito.same(request),
-                Mockito.any())).thenReturn(response);
-        Mockito.when(retryStrategy.retryRequest(
-                Mockito.any(),
-                Mockito.anyInt(),
-                Mockito.any())).thenReturn(Boolean.TRUE, Boolean.FALSE);
-        Mockito.when(retryStrategy.getRetryInterval(
-                Mockito.any(),
-                Mockito.anyInt(),
-                Mockito.any())).thenReturn(TimeValue.ofSeconds(5));
-
-        final ExecChain.Scope scope = new ExecChain.Scope("test", route, request, endpoint, context);
-        retryExec.execute(request, scope, chain);
-
-        Mockito.verify(chain, Mockito.times(1)).proceed(
-                Mockito.any(),
-                Mockito.same(scope));
-        Mockito.verify(response, Mockito.times(0)).close();
-    }
-
     @Test
     void testRetryIntervalResponseTimeoutNull() throws Exception {
         final HttpRoute route = new HttpRoute(target);
