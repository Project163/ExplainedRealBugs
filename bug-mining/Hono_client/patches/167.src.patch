diff --git a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
index 038ccb1f4..b5be28896 100644
--- a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
@@ -135,53 +135,46 @@ public interface ApplicationClientFactory extends ConnectionLifecycle<HonoConnec
             BiConsumer<ProtonDelivery, Message> consumer, Handler<Void> closeHandler);
 
     /**
-     * Gets a client for sending commands to a device.
+     * Gets a client for sending commands to devices of the given tenant.
      * <p>
      * The client returned may be either newly created or it may be an existing
-     * client for the given device.
+     * client for the given tenant.
      * <p>
      * This method will use an implementation specific mechanism (e.g. a UUID) to create
-     * a unique reply-to address to be included in commands sent to the device. The protocol
-     * adapters need to convey an encoding of the reply-to address to the device when delivering
-     * the command. Consequently, the number of bytes transferred to the device depends on the
-     * length of the reply-to address being used. In situations where this is a major concern it
-     * might be advisable to use {@link #getOrCreateCommandClient(String, String, String)} for
-     * creating a command client and provide custom (and shorter) <em>reply-to identifier</em>
+     * a unique reply-to address to be included in commands sent to devices of the tenant.
+     * The protocol adapters need to convey an encoding of the reply-to address to the device
+     * when delivering the command. Consequently, the number of bytes transferred to the device
+     * depends on the length of the reply-to address being used. In situations where this is a
+     * major concern it might be advisable to use {@link #getOrCreateCommandClient(String, String)}
+     * for creating a command client and provide custom (and shorter) <em>reply-to identifier</em>
      * to be used in the reply-to address.
      *
-     * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to send the commands to.
+     * @param tenantId The tenant of the devices to which commands shall be sent.
      * @return A future that will complete with the command and control client (if successful) or
      *         fail if the client cannot be created, e.g. because the underlying connection
      *         is not established or if a concurrent request to create a client for the same
-     *         tenant and device is already being executed.
+     *         tenant is already being executed.
      * @throws NullPointerException if the tenantId is {@code null}.
      */
-    Future<CommandClient> getOrCreateCommandClient(String tenantId, String deviceId);
+    Future<CommandClient> getOrCreateCommandClient(String tenantId);
 
     /**
-     * Gets a client for sending commands to a device.
+     * Gets a client for sending commands to devices of the given tenant.
      * <p>
      * The client returned may be either newly created or it may be an existing
-     * client for the given device.
+     * client for the given tenant and replyId.
      *
-     * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to send the commands to.
-     * @param replyId An arbitrary string which (in conjunction with the tenant and device ID) uniquely
-     *                identifies this command client.
-     *                This identifier will only be used for creating a <em>new</em> client for the device.
-     *                If this method returns an existing client for the device then the client will use
-     *                the reply-to address determined during its initial creation. In particular, this
-     *                means that if the (existing) client has originally been created using the
-     *                {@link #getOrCreateCommandClient(String, String)} method, then the reply-to address
-     *                used by the client will most likely not contain the given identifier.
+     * @param tenantId The tenant of the devices to which commands shall be sent.
+     * @param replyId An arbitrary string which will be used to create the reply-to address to be included in
+     *                commands sent to devices of the tenant. The combination of tenant and replyId has to be
+     *                unique among all CommandClient instances to make sure command response messages can be received.
      * @return A future that will complete with the command and control client (if successful) or
      *         fail if the client cannot be created, e.g. because the underlying connection
      *         is not established or if a concurrent request to create a client for the same
-     *         tenant and device is already being executed.
+     *         tenant and replyId is already being executed.
      * @throws NullPointerException if the tenantId is {@code null}.
      */
-    Future<CommandClient> getOrCreateCommandClient(String tenantId, String deviceId, String replyId);
+    Future<CommandClient> getOrCreateCommandClient(String tenantId, String replyId);
 
     /**
      * Gets a client for sending commands to a device asynchronously, i.e. command responses get received by a
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandClient.java b/client/src/main/java/org/eclipse/hono/client/CommandClient.java
index 97e4b65e2..967a7a65d 100644
--- a/client/src/main/java/org/eclipse/hono/client/CommandClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/CommandClient.java
@@ -34,6 +34,7 @@ public interface CommandClient extends RequestResponseClient {
      * A device needs to be (successfully) registered before a client can upload
      * any data for it. The device also needs to be connected for a successful delivery.
      *
+     * @param deviceId The device to send the command to.
      * @param command The command name.
      * @param data The command data to send to the device or {@code null} if the command has no input data.
      * @return A future indicating the result of the operation.
@@ -46,7 +47,7 @@ public interface CommandClient extends RequestResponseClient {
      * @throws NullPointerException if command is {@code null}.
      * @see RequestResponseClient#setRequestTimeout(long)
      */
-    Future<BufferResult> sendCommand(String command, Buffer data);
+    Future<BufferResult> sendCommand(String deviceId, String command, Buffer data);
 
     /**
      * Sends a command to a device and expects a response.
@@ -54,6 +55,7 @@ public interface CommandClient extends RequestResponseClient {
      * A device needs to be (successfully) registered before a client can upload
      * any data for it. The device also needs to be connected for a successful delivery.
      *
+     * @param deviceId The device to send the command to.
      * @param command The command name.
      * @param contentType The type of the data submitted as part of the command or {@code null} if unknown.
      * @param data The command data to send to the device or {@code null} if the command has no input data.
@@ -67,7 +69,7 @@ public interface CommandClient extends RequestResponseClient {
      * @throws NullPointerException if command is {@code null}.
      * @see RequestResponseClient#setRequestTimeout(long)
      */
-    Future<BufferResult> sendCommand(String command, String contentType, Buffer data, Map<String, Object> properties);
+    Future<BufferResult> sendCommand(String deviceId, String command, String contentType, Buffer data, Map<String, Object> properties);
 
     /**
      * Sends a <em>one-way command</em> to a device, i.e. there is no response expected from the device.
@@ -75,6 +77,7 @@ public interface CommandClient extends RequestResponseClient {
      * A device needs to be (successfully) registered before a client can upload
      * any data for it. The device also needs to be connected for a successful delivery.
      *
+     * @param deviceId The device to send the command to.
      * @param command The one-way command name.
      * @param data The command data to send to the device or {@code null} if the one-way command has no input data.
      * @return A future indicating the result of the operation.
@@ -85,7 +88,7 @@ public interface CommandClient extends RequestResponseClient {
      * @throws NullPointerException if command is {@code null}.
      * @see RequestResponseClient#setRequestTimeout(long)
      */
-    Future<Void> sendOneWayCommand(String command, Buffer data);
+    Future<Void> sendOneWayCommand(String deviceId, String command, Buffer data);
 
     /**
      * Sends a <em>one-way command</em> to a device, i.e. there is no response from the device expected.
@@ -93,6 +96,7 @@ public interface CommandClient extends RequestResponseClient {
      * A device needs to be (successfully) registered before a client can upload
      * any data for it. The device also needs to be connected for a successful delivery.
      *
+     * @param deviceId The device to send the command to.
      * @param command The one-way command name.
      * @param contentType The type of the data submitted as part of the one-way command or {@code null} if unknown.
      * @param data The command data to send to the device or {@code null} if the command has no input data.
@@ -105,5 +109,5 @@ public interface CommandClient extends RequestResponseClient {
      * @throws NullPointerException if command is {@code null}.
      * @see RequestResponseClient#setRequestTimeout(long)
      */
-    Future<Void> sendOneWayCommand(String command, String contentType, Buffer data, Map<String, Object> properties);
+    Future<Void> sendOneWayCommand(String deviceId, String command, String contentType, Buffer data, Map<String, Object> properties);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 51d0c33d8..cfb920f69 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -80,11 +80,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                             HttpURLConnection.HTTP_GONE
     };
 
-    /**
-     * Target address of the request message.
-     * Note that the target address of the sender link may be different, see {@link #getLinkTargetAddress()}.
-     */
-    protected final String targetAddress;
+    protected final String linkTargetAddress;
 
     private final Map<Object, TriTuple<Handler<AsyncResult<R>>, Object, Span>> replyMap = new HashMap<>();
     private Handler<Void> drainHandler;
@@ -122,14 +118,42 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             final HonoConnection connection,
             final String tenantId) {
 
+        this(connection, tenantId, UUID.randomUUID().toString());
+    }
+
+    /**
+     * Creates a request-response client.
+     * <p>
+     * The created instance's sender link's target address is set to
+     * <em>${name}[/${tenantId}]</em> and the receiver link's source
+     * address is set to <em>${name}[/${tenantId}]/${replyId}</em>
+     * (where ${name} is the value returned by {@link #getName()}).
+     * <p>
+     * The latter address is also used as the value of the <em>reply-to</em>
+     * property of all request messages sent by this client.
+     * <p>
+     * The client will be ready to use after invoking {@link #createLinks()} or
+     * {@link #createLinks(Handler, Handler)} only.
+     *
+     * @param connection The connection to the service.
+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the
+     *                 client should not be scoped to a tenant.
+     * @param replyId The replyId to use in the reply-to address.
+     * @throws NullPointerException if any of context or configuration are {@code null}.
+     */
+    protected AbstractRequestResponseClient(
+            final HonoConnection connection,
+            final String tenantId,
+            final String replyId) {
+
         super(connection);
         this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();
         if (tenantId == null) {
-            this.targetAddress = getName();
-            this.replyToAddress = String.format("%s/%s", getReplyToEndpointName(), UUID.randomUUID());
+            this.linkTargetAddress = getName();
+            this.replyToAddress = String.format("%s/%s", getReplyToEndpointName(), replyId);
         } else {
-            this.targetAddress = String.format("%s/%s", getName(), tenantId);
-            this.replyToAddress = String.format("%s/%s/%s", getReplyToEndpointName(), tenantId, UUID.randomUUID());
+            this.linkTargetAddress = String.format("%s/%s", getName(), tenantId);
+            this.replyToAddress = String.format("%s/%s/%s", getReplyToEndpointName(), tenantId, replyId);
         }
         this.tenantId = tenantId;
     }
@@ -167,7 +191,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         Objects.requireNonNull(replyId);
 
         this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();
-        this.targetAddress = String.format("%s/%s/%s", getName(), tenantId, deviceId);
+        this.linkTargetAddress = String.format("%s/%s/%s", getName(), tenantId, deviceId);
         this.replyToAddress = String.format("%s/%s/%s/%s", getReplyToEndpointName(), tenantId, deviceId, replyId);
         this.tenantId = tenantId;
     }
@@ -200,7 +224,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      */
     public final void setResponseCache(final ExpiringValueCache<Object, R> cache) {
         this.responseCache = cache;
-        LOG.info("enabling caching of responses from {}", targetAddress);
+        LOG.info("enabling caching of responses from {}", getName());
     }
 
     /**
@@ -323,17 +347,16 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             ApplicationProperties applicationProperties);
 
     /**
-     * The target address of the sender link on which the request message is sent.
+     * The default target address for request messages sent with this client.
      * <p>
-     * This default implementation returns the target address of the request message.
+     * This default implementation returns the link target address.
      * <p>
-     * Subclasses may override this method in order to use a different address for creating the sender link.
-     * For example, an empty address could be returned here to create an anonymous relay link.
+     * Subclasses may override this method in order to use a different address as default for sending messages.
      *
-     * @return The link target address.
+     * @return The message target address.
      */
-    protected String getLinkTargetAddress() {
-        return targetAddress;
+    protected String getDefaultMessageTargetAddress() {
+        return linkTargetAddress;
     }
 
     /**
@@ -364,7 +387,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         return createReceiver(replyToAddress, receiverCloseHook)
                 .compose(recv -> {
                     this.receiver = recv;
-                    return createSender(getLinkTargetAddress(), senderCloseHook);
+                    return createSender(linkTargetAddress, senderCloseHook);
                 }).compose(sender -> {
                     LOG.debug("request-response client for peer [{}] created", connection.getConfig().getHost());
                     this.sender = sender;
@@ -467,7 +490,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                 // response has already been processed
             } else {
                 LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
-                        targetAddress, correlationId, result.cause().getMessage());
+                        linkTargetAddress, correlationId, result.cause().getMessage());
                 final Span span = handler.three();
                 if (span != null) {
                     Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(result.cause()));
@@ -498,8 +521,6 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Build a Proton message with a provided subject (serving as the operation that shall be invoked).
      * The message can be extended by arbitrary application properties passed in.
-     * <p>
-     * To enable specific message properties that are not considered here, the method can be overridden by subclasses.
      *
      * @param subject The subject system property of the message.
      * @param appProperties The map containing arbitrary application properties.
@@ -510,14 +531,30 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      *                  (see {@link AbstractHonoClient#setApplicationProperties(Message, Map)}
      */
     private Message createMessage(final String subject, final Map<String, Object> appProperties) {
+        return createMessage(subject, getDefaultMessageTargetAddress(), appProperties);
+    }
+
+    /**
+     * Build a Proton message with a provided subject (serving as the operation that shall be invoked).
+     * The message can be extended by arbitrary application properties passed in.
+     *
+     * @param subject The subject system property of the message.
+     * @param address The address of the message, put in the <em>to</em> property.
+     * @param appProperties The map containing arbitrary application properties.
+     *                      Maybe null if no application properties are needed.
+     * @return The Proton message constructed from the provided parameters.
+     * @throws NullPointerException if the subject is {@code null}.
+     * @throws IllegalArgumentException if the application properties contain not AMQP 1.0 compatible values
+     *                  (see {@link AbstractHonoClient#setApplicationProperties(Message, Map)}
+     */
+    private Message createMessage(final String subject, final String address,
+            final Map<String, Object> appProperties) {
 
         Objects.requireNonNull(subject);
         final Message msg = ProtonHelper.message();
         final String messageId = createMessageId();
         AbstractHonoClient.setApplicationProperties(msg, appProperties);
-        if (!targetAddress.equals(getLinkTargetAddress())) {
-            msg.setAddress(targetAddress);
-        }
+        msg.setAddress(address);
         msg.setReplyTo(replyToAddress);
         msg.setMessageId(messageId);
         msg.setSubject(subject);
@@ -527,6 +564,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Creates a request message for a payload and sends it to the peer.
      * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
+     * <p>
      * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, Handler)} with {@code null} for the
      * properties parameter.
      * 
@@ -546,6 +586,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Creates a request message for a payload and sends it to the peer.
      * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
+     * <p>
      * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, String, Handler, Object, Span)} with
      * {@code null} for the properties, content type and cache key parameters.
      * 
@@ -567,6 +610,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Creates a request message for a payload and sends it to the peer.
      * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
+     * <p>
      * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, Handler)}
      * with {@code null} for the properties parameter.
      * 
@@ -587,6 +633,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
 
     /**
      * Creates a request message for a payload and headers and sends it to the peer.
+     * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
      * 
      * @param action The operation that the request is supposed to trigger/invoke.
      * @param properties The headers to include in the request message as AMQP application properties.
@@ -611,6 +660,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Creates a request message for a payload with content-type JSON and headers and sends it to the peer.
      * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
+     * <p>
      * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
      * Otherwise, the request message is sent and a timer is started which fails the result handler,
      * if no response is received within <em>requestTimeout</em> milliseconds.
@@ -643,6 +695,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Creates a request message for a payload and headers and sends it to the peer.
      * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
+     * <p>
      * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
      * Otherwise, the request message is sent and a timer is started which fails the result handler,
      * if no response is received within <em>requestTimeout</em> milliseconds.
@@ -682,6 +737,46 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         }, cacheKey, currentSpan);
     }
 
+    /**
+     * Creates a request message for a payload and headers and sends it to the peer.
+     * <p>
+     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
+     * <em>to</em> property.
+     * <p>
+     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
+     * Otherwise, the request message is sent and a timer is started which fails the result handler,
+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.
+     * <p>
+     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.
+     * However, the span is never finished by this method.
+     *
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param properties The headers to include in the request message as AMQP application properties.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param contentType The content type of the payload.
+     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
+     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
+     *                      e.g. because there is no connection to the service or there are no credits available
+     *                      for sending the request or the request timed out.
+     * @param cacheKey The key to use for caching the response (if the service allows caching).
+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
+     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.
+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
+     */
+    protected final void createAndSendRequest(
+            final String action,
+            final Map<String, Object> properties,
+            final Buffer payload,
+            final String contentType,
+            final Handler<AsyncResult<R>> resultHandler,
+            final Object cacheKey,
+            final Span currentSpan) {
+
+        createAndSendRequest(action, getDefaultMessageTargetAddress(), properties, payload, contentType, resultHandler,
+                cacheKey, currentSpan);
+    }
+
     /**
      * Creates a request message for a payload and headers and sends it to the peer.
      * <p>
@@ -693,6 +788,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * However, the span is never finished by this method.
      * 
      * @param action The operation that the request is supposed to trigger/invoke.
+     * @param address The address to send the message to.
      * @param properties The headers to include in the request message as AMQP application properties.
      * @param payload The payload to include in the request message as a an AMQP Value section.
      * @param contentType The content type of the payload.
@@ -708,6 +804,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      */
     protected final void createAndSendRequest(
             final String action,
+            final String address,
             final Map<String, Object> properties,
             final Buffer payload,
             final String contentType,
@@ -720,7 +817,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         Objects.requireNonNull(currentSpan);
 
         if (isOpen()) {
-            final Message request = createMessage(action, properties);
+            final Message request = createMessage(action, address, properties);
             MessageHelper.setPayload(request, contentType, payload);
             sendRequest(request, resultHandler, cacheKey, currentSpan);
         } else {
@@ -751,7 +848,8 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             final Object cacheKey,
             final Span currentSpan) {
 
-        Tags.MESSAGE_BUS_DESTINATION.set(currentSpan, targetAddress);
+        final String requestTargetAddress = request.getAddress() != null ? request.getAddress() : getDefaultMessageTargetAddress();
+        Tags.MESSAGE_BUS_DESTINATION.set(currentSpan, requestTargetAddress);
         Tags.SPAN_KIND.set(currentSpan, Tags.SPAN_KIND_CLIENT);
         Tags.HTTP_METHOD.set(currentSpan, request.getSubject());
         if (tenantId != null) {
@@ -761,7 +859,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         connection.executeOrRunOnContext(res -> {
 
             if (sender.sendQueueFull()) {
-                LOG.debug("cannot send request to peer, no credit left for link [target: {}]", targetAddress);
+                LOG.debug("cannot send request to peer, no credit left for link [link target: {}]", linkTargetAddress);
                 Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
                 resultHandler.handle(Future.failedFuture(new ServerErrorException(
                         HttpURLConnection.HTTP_UNAVAILABLE, "no credit available for sending request")));
@@ -787,18 +885,18 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                         final Rejected rejected = (Rejected) remoteState;
                         if (rejected.getError() != null) {
                             LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}",
-                                    targetAddress, request.getSubject(), correlationId, rejected.getError());
+                                    requestTargetAddress, request.getSubject(), correlationId, rejected.getError());
                             failedResult.fail(StatusCodeMapper.from(rejected.getError()));
                             cancelRequest(correlationId, failedResult);
                         } else {
                             LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]",
-                                    targetAddress, request.getSubject(), correlationId);
+                                    requestTargetAddress, request.getSubject(), correlationId);
                             failedResult.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
                             cancelRequest(correlationId, failedResult);
                         }
                     } else if (Accepted.class.isInstance(remoteState)) {
                         LOG.trace("service has accepted request [target address: {}, subject: {}, correlation ID: {}]",
-                                targetAddress, request.getSubject(), correlationId);
+                                requestTargetAddress, request.getSubject(), correlationId);
                         currentSpan.log("request accepted by peer");
                         // if no reply-to is set, the request is assumed to be one-way (no response is expected)
                         if (request.getReplyTo() == null) {
@@ -808,12 +906,12 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                         }
                     } else if (Released.class.isInstance(remoteState)) {
                         LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}], remote state: {}",
-                                targetAddress, request.getSubject(), correlationId, remoteState);
+                                requestTargetAddress, request.getSubject(), correlationId, remoteState);
                         failedResult.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
                         cancelRequest(correlationId, failedResult);
                     } else if (Modified.class.isInstance(remoteState)) {
                         LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}], remote state: {}",
-                                targetAddress, request.getSubject(), correlationId, remoteState);
+                                requestTargetAddress, request.getSubject(), correlationId, remoteState);
                         final Modified modified = (Modified) deliveryUpdated.getRemoteState();
                         failedResult.fail(modified.getUndeliverableHere() ? new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)
                                 : new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
@@ -830,10 +928,10 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                     final String deviceId = MessageHelper.getDeviceId(request);
                     if (deviceId == null) {
                         LOG.debug("sent request [target address: {}, subject: {}, correlation ID: {}] to service",
-                                targetAddress, request.getSubject(), correlationId);
+                                requestTargetAddress, request.getSubject(), correlationId);
                     } else {
                         LOG.debug("sent request [target address: {}, subject: {}, correlation ID: {}, device ID: {}] to service",
-                                targetAddress, request.getSubject(), correlationId, deviceId);
+                                requestTargetAddress, request.getSubject(), correlationId, deviceId);
                     }
                 }
             }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
index a96900587..361cefc3e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
@@ -25,6 +25,7 @@ import org.eclipse.hono.client.AsyncCommandClient;
 import org.eclipse.hono.client.CommandClient;
 import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.util.CommandConstants;
 
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -109,36 +110,37 @@ public class ApplicationClientFactoryImpl extends AbstractHonoClientFactory impl
      * {@inheritDoc}
      */
     @Override
-    public Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String deviceId) {
-        return getOrCreateCommandClient(tenantId, deviceId, UUID.randomUUID().toString());
+    public Future<CommandClient> getOrCreateCommandClient(final String tenantId) {
+        Objects.requireNonNull(tenantId);
+
+        final String cacheKey = String.format("%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId);
+        return getOrCreateCommandClient(tenantId, UUID.randomUUID().toString(), cacheKey);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public Future<CommandClient> getOrCreateCommandClient(
-            final String tenantId,
-            final String deviceId,
-            final String replyId) {
-
+    public Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String replyId) {
         Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
         Objects.requireNonNull(replyId);
 
-        log.debug("get or create command client for [tenantId: {}, deviceId: {}, replyId: {}]", tenantId, deviceId,
-                replyId);
+        final String cacheKey = String.format("%s/%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, replyId);
+        return getOrCreateCommandClient(tenantId, replyId, cacheKey);
+    }
+
+    private Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String replyId,
+            final String cacheKey) {
+        log.debug("get or create command client for [tenantId: {}, replyId: {}]", tenantId, replyId);
         return connection.executeOrRunOnContext(result -> {
-            final String targetAddress = CommandClientImpl.getTargetAddress(tenantId, deviceId);
             commandClientFactory.getOrCreateClient(
-                    targetAddress,
+                    cacheKey,
                     () -> CommandClientImpl.create(
                             connection,
                             tenantId,
-                            deviceId,
                             replyId,
-                            s -> removeCommandClient(targetAddress),
-                            s -> removeCommandClient(targetAddress)),
+                            s -> removeCommandClient(cacheKey),
+                            s -> removeCommandClient(cacheKey)),
                     result);
         });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
index 3e80bda02..6766e6c1e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
@@ -49,7 +49,6 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
     private static final Logger LOG = LoggerFactory.getLogger(CommandClientImpl.class);
 
     private long messageCounter;
-    private final String linkTargetAddress;
 
     /**
      * Creates a client for sending commands to devices.
@@ -59,18 +58,15 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
      *
      * @param connection The connection to Hono.
      * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to create the client for.
      * @param replyId The replyId to use in the reply-to address.
      * @throws NullPointerException if any of the parameters are {@code null}.
      */
     CommandClientImpl(
             final HonoConnection connection,
             final String tenantId,
-            final String deviceId,
             final String replyId) {
 
-        super(connection, tenantId, deviceId, replyId);
-        this.linkTargetAddress = String.format("%s/%s", getName(), tenantId);
+        super(connection, tenantId, replyId);
     }
 
     /**
@@ -78,7 +74,6 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
      *
      * @param connection The connection to Hono.
      * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to create the client for.
      * @param replyId The replyId to use in the reply-to address.
      * @param sender The link to use for sending command requests.
      * @param receiver The link to use for receiving command responses.
@@ -87,12 +82,11 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
     CommandClientImpl(
             final HonoConnection connection,
             final String tenantId,
-            final String deviceId,
             final String replyId,
             final ProtonSender sender,
             final ProtonReceiver receiver) {
 
-        this(connection, tenantId, deviceId, replyId);
+        this(connection, tenantId, replyId);
         this.sender = Objects.requireNonNull(sender);
         this.receiver = Objects.requireNonNull(receiver);
     }
@@ -122,11 +116,6 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
         return CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT;
     }
 
-    @Override
-    protected String getLinkTargetAddress() {
-        return linkTargetAddress;
-    }
-
     /**
      * The command's message ID is transferred to the device in order to be able to correlate the
      * response received from the device with the request message. It is therefore
@@ -155,12 +144,12 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
     /**
      * {@inheritDoc}
      * <p>
-     * This method simply invokes {@link #sendCommand(String, String, Buffer, Map)} with
+     * This method simply invokes {@link #sendCommand(String, String, String, Buffer, Map)} with
      * {@code null} as the *content-type* and {@code null} as *application properties*.
      */
     @Override
-    public Future<BufferResult> sendCommand(final String command, final Buffer data) {
-        return sendCommand(command, null, data, null);
+    public Future<BufferResult> sendCommand(final String deviceId, final String command, final Buffer data) {
+        return sendCommand(deviceId, command, null, data, null);
     }
 
     /**
@@ -170,14 +159,18 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
      * from a device with the request.
      */
     @Override
-    public Future<BufferResult> sendCommand(final String command, final String contentType, final Buffer data, final Map<String, Object> properties) {
+    public Future<BufferResult> sendCommand(final String deviceId, final String command, final String contentType,
+            final Buffer data, final Map<String, Object> properties) {
 
         Objects.requireNonNull(command);
 
         final Span currentSpan = newChildSpan(null, command);
 
         final Future<BufferResult> responseTracker = Future.future();
-        createAndSendRequest(command, properties, data, contentType, responseTracker, null, currentSpan);
+
+        final String messageTargetAddress = getTargetAddress(getTenantId(), deviceId);
+        createAndSendRequest(command, messageTargetAddress, properties, data, contentType, responseTracker,
+                null, currentSpan);
 
         return responseTracker
                 .recover(t -> {
@@ -198,15 +191,16 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
     }
 
     @Override
-    public Future<Void> sendOneWayCommand(final String command, final Buffer data) {
-        return sendOneWayCommand(command, null, data, null);
+    public Future<Void> sendOneWayCommand(final String deviceId, final String command, final Buffer data) {
+        return sendOneWayCommand(deviceId, command, null, data, null);
     }
 
     /**
      * {@inheritDoc}
      */
     @Override
-    public Future<Void> sendOneWayCommand(final String command, final String contentType, final Buffer data, final Map<String, Object> properties) {
+    public Future<Void> sendOneWayCommand(final String deviceId, final String command, final String contentType,
+            final Buffer data, final Map<String, Object> properties) {
         Objects.requireNonNull(command);
 
         final Span currentSpan = newChildSpan(null, command);
@@ -218,7 +212,7 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
             AbstractHonoClient.setApplicationProperties(request, properties);
 
             final String messageId = createMessageId();
-            request.setAddress(targetAddress);
+            request.setAddress(getTargetAddress(getTenantId(), deviceId));
             request.setMessageId(messageId);
             request.setSubject(command);
 
@@ -255,7 +249,6 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
      *
      * @param con The connection to Hono.
      * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to create the client for.
      * @param replyId The replyId to use in the reply-to address.
      * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
      * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
@@ -265,12 +258,11 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
     public static final Future<CommandClient> create(
             final HonoConnection con,
             final String tenantId,
-            final String deviceId,
             final String replyId,
             final Handler<String> senderCloseHook,
             final Handler<String> receiverCloseHook) {
 
-        final CommandClientImpl client = new CommandClientImpl(con, tenantId, deviceId, replyId);
+        final CommandClientImpl client = new CommandClientImpl(con, tenantId, replyId);
         return client.createLinks(senderCloseHook, receiverCloseHook)
                 .map(ok -> {
                     LOG.debug("successfully created command client for [{}]", tenantId);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java
index 200236759..9e723aeab 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java
@@ -69,7 +69,6 @@ public class CommandClientImplTest {
         client = new CommandClientImpl(
                 connection,
                 Constants.DEFAULT_TENANT,
-                DEVICE_ID,
                 REPLY_ID,
                 sender,
                 receiver);
@@ -90,14 +89,14 @@ public class CommandClientImplTest {
         final Map<String, Object> applicationProperties = new HashMap<>();
         applicationProperties.put("appKey", "appValue");
 
-        client.sendCommand("doSomething", "text/plain", Buffer.buffer("payload"), applicationProperties);
+        client.sendCommand(DEVICE_ID, "doSomething", "text/plain", Buffer.buffer("payload"), applicationProperties);
         final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
         verify(sender).send(messageCaptor.capture(), anyHandler());
         assertThat(messageCaptor.getValue().getSubject(), is("doSomething"));
         assertNotNull(messageCaptor.getValue().getMessageId());
         assertThat(messageCaptor.getValue().getContentType(), is("text/plain"));
         assertThat(messageCaptor.getValue().getReplyTo(),
-                is(String.format("%s/%s/%s/%s", client.getReplyToEndpointName(), Constants.DEFAULT_TENANT, DEVICE_ID, REPLY_ID)));
+                is(String.format("%s/%s/%s", client.getReplyToEndpointName(), Constants.DEFAULT_TENANT, REPLY_ID)));
         assertNotNull(messageCaptor.getValue().getApplicationProperties());
         assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("appKey"), is("appValue"));
     }
@@ -118,7 +117,7 @@ public class CommandClientImplTest {
         final Map<String, Object> applicationProperties = new HashMap<>();
         applicationProperties.put("appKey", "appValue");
 
-        client.sendOneWayCommand("doSomething", "text/plain", Buffer.buffer("payload"), applicationProperties);
+        client.sendOneWayCommand(DEVICE_ID, "doSomething", "text/plain", Buffer.buffer("payload"), applicationProperties);
         final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
         verify(sender).send(messageCaptor.capture(), anyHandler());
         assertThat(messageCaptor.getValue().getSubject(), is("doSomething"));
