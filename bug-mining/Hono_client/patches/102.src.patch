diff --git a/client/src/main/java/org/eclipse/hono/client/TenantClient.java b/client/src/main/java/org/eclipse/hono/client/TenantClient.java
index 2146acb82..bce345d55 100644
--- a/client/src/main/java/org/eclipse/hono/client/TenantClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/TenantClient.java
@@ -13,12 +13,13 @@
 
 package org.eclipse.hono.client;
 
-import io.vertx.core.Future;
-
 import javax.security.auth.x500.X500Principal;
 
 import org.eclipse.hono.util.TenantObject;
 
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+
 /**
  * A client for accessing Hono's Tenant API.
  * <p>
@@ -41,9 +42,35 @@ public interface TenantClient extends RequestResponseClient {
      *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
      *         the (error) status code returned by the service.</li>
      *         </ul>
+     * @throws NullPointerException if tenant ID is {@code null}.
      */
     Future<TenantObject> get(String tenantId);
 
+    /**
+     * Gets configuration information for a tenant.
+     * <p>
+     * This default implementation simply returns the result of
+     * {@link #get(String)}.
+     * 
+     * @param tenantId The id of the tenant to retrieve details for.
+     * @param context The currently active OpenTracing span. An implementation
+     *         should use this as the parent for any span it creates for tracing
+     *         the execution of this operation.
+     * @return A future indicating the result of the operation.
+     *         <ul>
+     *         <li>The future will succeed if a response with status 200 has been received from the
+     *         tenant service. The JSON object will then contain values as defined in
+     *         <a href="https://www.eclipse.org/hono/api/tenant-api/#get-tenant-information">
+     *         Get Tenant Information</a>.</li>
+     *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
+     *         the (error) status code returned by the service.</li>
+     *         </ul>
+     * @throws NullPointerException if tenant ID is {@code null}.
+     */
+    default Future<TenantObject> get(final String tenantId, final SpanContext context) {
+        return get(tenantId);
+    }
+
     /**
      * Gets tenant configuration information for the <em>subject DN</em>
      * of a trusted certificate authority.
@@ -63,6 +90,38 @@ public interface TenantClient extends RequestResponseClient {
      *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
      *         the (error) status code returned by the service.</li>
      *         </ul>
+     * @throws NullPointerException if subject DN is {@code null}.
      */
     Future<TenantObject> get(X500Principal subjectDn);
+
+    /**
+     * Gets tenant configuration information for the <em>subject DN</em>
+     * of a trusted certificate authority.
+     * <p>
+     * This method can e.g. be used when trying to authenticate a device based on
+     * an X.509 client certificate. Using this method, the <em>issuer DN</em> from the
+     * client's certificate can be used to determine the tenant that the device belongs to.
+     * <p>
+     * This default implementation simply returns the result of
+     * {@link #get(X500Principal)}.
+     * 
+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate
+     *                  that has been configured for the tenant.
+     * @param context The currently active OpenTracing span. An implementation
+     *         should use this as the parent for any span it creates for tracing
+     *         the execution of this operation.
+     * @return A future indicating the result of the operation.
+     *         <ul>
+     *         <li>The future will succeed if a response with status 200 has been received from the
+     *         tenant service. The JSON object will then contain values as defined in
+     *         <a href="https://www.eclipse.org/hono/api/tenant-api/#get-tenant-information">
+     *         Get Tenant Information</a>.</li>
+     *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
+     *         the (error) status code returned by the service.</li>
+     *         </ul>
+     * @throws NullPointerException if subject DN is {@code null}.
+     */
+    default Future<TenantObject> get(final X500Principal subjectDn, final SpanContext context) {
+        return get(subjectDn);
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index a75c88fe8..e343f3ebe 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -9,6 +9,7 @@
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
  *    Red Hat Inc
+ *   Bosch Software Innovations GmbH - add Open Tracing support
  */
 package org.eclipse.hono.client.impl;
 
@@ -21,10 +22,10 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.UUID;
 
-import io.vertx.core.buffer.Buffer;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.cache.ExpiringValueCache;
 import org.eclipse.hono.client.ClientErrorException;
@@ -33,6 +34,8 @@ import org.eclipse.hono.client.RequestResponseClientConfigProperties;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.tracing.MessageAnnotationsInjectAdapter;
+import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RequestResponseApiConstants;
@@ -41,10 +44,15 @@ import org.eclipse.hono.util.TriTuple;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.opentracing.Span;
+import io.opentracing.Tracer;
+import io.opentracing.propagation.Format;
+import io.opentracing.tag.Tags;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.buffer.Buffer;
 import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonHelper;
@@ -74,7 +82,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                             HttpURLConnection.HTTP_GONE
     };
 
-    private final Map<Object, TriTuple<Handler<AsyncResult<R>>, Object, Object>> replyMap = new HashMap<>();
+    private final Map<Object, TriTuple<Handler<AsyncResult<R>>, Object, Span>> replyMap = new HashMap<>();
     private final String replyToAddress;
     private final String targetAddress;
     private final String tenantId;
@@ -98,7 +106,28 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @throws NullPointerException if any of context or configuration are {@code null}.
      */
     AbstractRequestResponseClient(final Context context, final ClientConfigProperties config, final String tenantId) {
-        super(context, config);
+        this(context, config, (Tracer) null, tenantId);
+    }
+
+    /**
+     * Creates a request-response client.
+     * <p>
+     * The client will be ready to use after invoking {@link #createLinks(ProtonConnection, ClientConfigProperties)} only.
+     * 
+     * @param context The vert.x context to run message exchanges with the peer on.
+     * @param config The configuration properties to use.
+     * @param tracer The tracer to use for tracking request processing
+     *               across process boundaries.
+     * @param tenantId The identifier of the tenant that the client is scoped to.
+     * @throws NullPointerException if any of the parameters other than tracer is {@code null}.
+     */
+    AbstractRequestResponseClient(
+            final Context context,
+            final ClientConfigProperties config,
+            final Tracer tracer,
+            final String tenantId) {
+
+        super(context, config, tracer);
         this.requestTimeoutMillis = config.getRequestTimeout();
         if (tenantId == null) {
             this.targetAddress = getName();
@@ -141,14 +170,43 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @param sender The AMQP 1.0 link to use for sending requests to the peer.
      * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
      * @throws NullPointerException if any of the parameters except tenant ID is {@code null}.
+     * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    AbstractRequestResponseClient(final Context context, final ClientConfigProperties config, final String tenantId,
-            final ProtonSender sender, final ProtonReceiver receiver) {
+    AbstractRequestResponseClient(
+            final Context context,
+            final ClientConfigProperties config,
+            final String tenantId,
+            final ProtonSender sender,
+            final ProtonReceiver receiver) {
+
         this(context, config, tenantId);
         this.sender = Objects.requireNonNull(sender);
         this.receiver = Objects.requireNonNull(receiver);
     }
 
+    /**
+     * Creates a request-response client for a sender and receiver link.
+     * 
+     * @param context The vert.x context to run message exchanges with the peer on.
+     * @param config The configuration properties to use.
+     * @param tenantId The identifier of the tenant that the client is scoped to.
+     * @param sender The AMQP 1.0 link to use for sending requests to the peer.
+     * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
+     * @throws NullPointerException if any of the parameters other than tracer is {@code null}.
+     */
+    AbstractRequestResponseClient(
+            final Context context,
+            final ClientConfigProperties config,
+            final Tracer tracer,
+            final String tenantId,
+            final ProtonSender sender,
+            final ProtonReceiver receiver) {
+
+        this(context, config, tracer, tenantId);
+        this.sender = Objects.requireNonNull(sender);
+        this.receiver = Objects.requireNonNull(receiver);
+    }
+
     /**
      * Sets a cache for responses received from the service.
      * 
@@ -302,7 +360,8 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         // the tuple from the reply map contains
         // 1. the handler for processing the response and
         // 2. the key to use for caching the response
-        final TriTuple<Handler<AsyncResult<R>>, Object, Object> handler = replyMap.remove(message.getCorrelationId());
+        // 3. the Opentracing span covering the execution
+        final TriTuple<Handler<AsyncResult<R>>, Object, Span> handler = replyMap.remove(message.getCorrelationId());
 
         if (handler == null) {
             LOG.debug("discarding unexpected response [reply-to: {}, correlation ID: {}]",
@@ -310,14 +369,19 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             ProtonHelper.released(delivery, true);
         } else {
             final R response = getRequestResponseResult(message);
+            final Span span = handler.three();
             if (response == null) {
                 LOG.debug("discarding malformed response lacking status code [reply-to: {}, correlation ID: {}]",
                         replyToAddress, message.getCorrelationId());
+                TracingHelper.logError(span, "response lacks status code");
                 ProtonHelper.released(delivery, true);
             } else {
                 LOG.debug("received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}]",
                         replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus());
                 addToCache(handler.two(), response);
+                if (span != null) {
+                    Tags.HTTP_STATUS.set(span, response.getStatus());
+                }
                 handler.one().handle(Future.succeededFuture(response));
                 ProtonHelper.accepted(delivery, true);
             }
@@ -337,13 +401,17 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
 
         Objects.requireNonNull(correlationId);
         Objects.requireNonNull(result);
-        if (!result.failed()) {
+
+        if (result.succeeded()) {
             throw new IllegalArgumentException("result must be failed");
         } else {
-            final TriTuple<Handler<AsyncResult<R>>, Object, Object> handler = replyMap.remove(correlationId);
-            if (handler != null) {
+            final TriTuple<Handler<AsyncResult<R>>, Object, Span> handler = replyMap.remove(correlationId);
+            if (handler == null) {
+                // response has already been processed
+            } else {
                 LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
                         targetAddress, correlationId, result.cause().getMessage());
+                TracingHelper.logError(handler.three(), result.cause());
                 handler.one().handle(result);
             }
         }
@@ -404,9 +472,32 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             final String action,
             final Buffer payload,
             final Handler<AsyncResult<R>> resultHandler) {
+
         createAndSendRequest(action, null, payload, resultHandler);
     }
 
+    /**
+     * Creates a request message for a payload and sends it to the peer.
+     * <p>
+     * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, String, Handler, Object, Span)}
+     * with {@code null} for the properties, content type and cache key parameters.
+     * 
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param resultHandler The handler to notify about the outcome of the request.
+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
+     * @throws NullPointerException if any of action, result handler or current span is {@code null}.
+     */
+    protected final void createAndSendRequest(
+            final String action,
+            final Buffer payload,
+            final Handler<AsyncResult<R>> resultHandler,
+            final Span currentSpan) {
+
+        Objects.requireNonNull(currentSpan);
+        createAndSendRequest(action, null, payload, null, resultHandler, null, currentSpan);
+    }
+
     /**
      * Creates a request message for a payload and sends it to the peer.
      * <p>
@@ -424,6 +515,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             final Buffer payload,
             final Handler<AsyncResult<R>> resultHandler,
             final Object cacheKey) {
+
         createAndSendRequest(action, null, payload, resultHandler, cacheKey);
     }
 
@@ -441,11 +533,45 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
      * @see AbstractHonoClient#setApplicationProperties(Message, Map)
      */
-    protected final void createAndSendRequest(final String action, final Map<String, Object> properties, final Buffer payload,
-                                      final Handler<AsyncResult<R>> resultHandler) {
+    protected final void createAndSendRequest(
+            final String action,
+            final Map<String, Object> properties,
+            final Buffer payload,
+            final Handler<AsyncResult<R>> resultHandler) {
+
         createAndSendRequest(action, properties, payload, resultHandler, null);
     }
 
+    /**
+     * Creates a request message for a payload with content-type JSON and headers and sends it to the peer.
+     * <p>
+     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
+     * Otherwise, the request message is sent and a timer is started which fails the result handler,
+     * if no response is received within <em>requestTimeout</em> milliseconds.
+     *
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param properties The headers to include in the request message as AMQP application properties.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
+     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
+     *                      e.g. because there is no connection to the service or there are no credits available
+     *                      for sending the request or the request timed out.
+     * @param cacheKey The key to use for caching the response (if the service allows caching).
+     * @throws NullPointerException if action or result handler are {@code null}.
+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
+     */
+    protected final void createAndSendRequest(
+            final String action,
+            final Map<String, Object> properties,
+            final Buffer payload,
+            final Handler<AsyncResult<R>> resultHandler,
+            final Object cacheKey) {
+
+        createAndSendRequest(action, properties, payload, RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
+                resultHandler, cacheKey);
+    }
+
     /**
      * Creates a request message for a payload and headers and sends it to the peer.
      * <p>
@@ -474,40 +600,27 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             final Handler<AsyncResult<R>> resultHandler,
             final Object cacheKey) {
 
-        Objects.requireNonNull(action);
-        Objects.requireNonNull(resultHandler);
-
-        if (isOpen()) {
-            final Message request = createMessage(action, properties);
-            if (payload != null) {
-                if(contentType != null) {
-                    request.setContentType(contentType);
-                }
-                request.setBody(new AmqpValue(payload.getBytes()));
-            }
-            sendRequest(request, resultHandler, cacheKey);
-        } else {
-            resultHandler.handle(Future.failedFuture(new ServerErrorException(
-                    HttpURLConnection.HTTP_UNAVAILABLE, "sender and/or receiver link is not open")));
-        }
+        createAndSendRequest(action, properties, payload, contentType, resultHandler, cacheKey, newChildSpan(null, action));
     }
 
     /**
-     * Creates a request message for a payload with content-type JSON and headers and sends it to the peer.
+     * Creates a request message for a payload and headers and sends it to the peer.
      * <p>
      * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
      * Otherwise, the request message is sent and a timer is started which fails the result handler,
-     * if no response is received within <em>requestTimeout</em> milliseconds.
-     *
+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.
+     * 
      * @param action The operation that the request is supposed to trigger/invoke.
      * @param properties The headers to include in the request message as AMQP application properties.
      * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param contentType The content type of the payload.
      * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
      *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
      *                      e.g. because there is no connection to the service or there are no credits available
      *                      for sending the request or the request timed out.
      * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @throws NullPointerException if action or result handler are {@code null}.
+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
+     * @throws NullPointerException if any of action or result handler is {@code null}.
      * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
      * @see AbstractHonoClient#setApplicationProperties(Message, Map)
      */
@@ -515,11 +628,29 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             final String action,
             final Map<String, Object> properties,
             final Buffer payload,
+            final String contentType,
             final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey) {
+            final Object cacheKey,
+            final Span currentSpan) {
 
-        createAndSendRequest(action, properties, payload, RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
-                resultHandler, cacheKey);
+        Objects.requireNonNull(action);
+        Objects.requireNonNull(resultHandler);
+        Objects.requireNonNull(currentSpan);
+
+        if (isOpen()) {
+            final Message request = createMessage(action, properties);
+            if (payload != null) {
+                if (contentType != null) {
+                    request.setContentType(contentType);
+                }
+                request.setBody(new AmqpValue(payload.getBytes()));
+            }
+            sendRequest(request, resultHandler, cacheKey, currentSpan);
+        } else {
+            TracingHelper.logError(currentSpan, "sender and/or receiver link is not open");
+            resultHandler.handle(Future.failedFuture(new ServerErrorException(
+                    HttpURLConnection.HTTP_UNAVAILABLE, "sender and/or receiver link is not open")));
+        }
     }
 
     /**
@@ -532,38 +663,63 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @param request The message to send.
      * @param resultHandler The handler to notify about the outcome of the request.
      * @param cacheKey The key to use for caching the response (if the service allows caching).
+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
      */
-    private void sendRequest(final Message request, final Handler<AsyncResult<R>> resultHandler, final Object cacheKey) {
+    private void sendRequest(
+            final Message request,
+            final Handler<AsyncResult<R>> resultHandler,
+            final Object cacheKey,
+            final Span currentSpan) {
+
+        Tags.MESSAGE_BUS_DESTINATION.set(currentSpan, targetAddress);
+        Tags.SPAN_KIND.set(currentSpan, Tags.SPAN_KIND_CLIENT);
+        Tags.HTTP_METHOD.set(currentSpan, request.getSubject());
+        TracingHelper.TAG_QOS.set(currentSpan, ProtonQoS.AT_LEAST_ONCE.toString());
+        if (tenantId != null) {
+            currentSpan.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
+        }
 
         context.runOnContext(req -> {
             if (sender.sendQueueFull()) {
                 LOG.debug("cannot send request to peer, no credit left for link [target: {}]", targetAddress);
                 resultHandler.handle(Future.failedFuture(new ServerErrorException(
                         HttpURLConnection.HTTP_UNAVAILABLE, "no credit available for sending request")));
+                TracingHelper.logError(currentSpan, "no credit left for request link");
             } else {
                 final Object correlationId = Optional.ofNullable(request.getCorrelationId()).orElse(request.getMessageId());
-                final TriTuple<Handler<AsyncResult<R>>, Object, Object> handler = TriTuple.of(resultHandler, cacheKey, null);
+                if (correlationId instanceof String) {
+                    TracingHelper.TAG_CORRELATION_ID.set(currentSpan, (String) correlationId);
+                }
+                TracingHelper.TAG_CREDIT.set(currentSpan, sender.getCredit());
+                final TriTuple<Handler<AsyncResult<R>>, Object, Span> handler = TriTuple.of(resultHandler, cacheKey, currentSpan);
+                tracer.inject(currentSpan.context(), Format.Builtin.TEXT_MAP, new MessageAnnotationsInjectAdapter(request));
                 replyMap.put(correlationId, handler);
+
                 sender.send(request, deliveryUpdated -> {
-                    if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
-                        final Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
+                    final Future<R> failedResult = Future.future();
+                    final DeliveryState remoteState = deliveryUpdated.getRemoteState();
+                    TracingHelper.TAG_REMOTE_STATE.set(currentSpan, remoteState.getClass().getSimpleName());
+                    if (Rejected.class.isInstance(remoteState)) {
+                        final Rejected rejected = (Rejected) remoteState;
                         if (rejected.getError() != null) {
                             LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}",
                                     targetAddress, request.getSubject(), correlationId, rejected.getError());
-
-                            cancelRequest(correlationId, Future.failedFuture(StatusCodeMapper.from(rejected.getError())));
+                            failedResult.fail(StatusCodeMapper.from(rejected.getError()));
+                            cancelRequest(correlationId, failedResult);
                         } else {
                             LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]",
                                     targetAddress, request.getSubject(), correlationId);
-                            cancelRequest(correlationId, Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST)));
+                            failedResult.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                            cancelRequest(correlationId, failedResult);
                         }
-                    } else if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    } else if (Accepted.class.isInstance(remoteState)) {
                         LOG.trace("service has accepted request [target address: {}, subject: {}, correlation ID: {}]",
                                 targetAddress, request.getSubject(), correlationId);
                     } else {
                         LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}",
-                                targetAddress, request.getSubject(), correlationId, deliveryUpdated.getRemoteState());
-                        cancelRequest(correlationId, Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)));
+                                targetAddress, request.getSubject(), correlationId, remoteState);
+                        failedResult.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
+                        cancelRequest(correlationId, failedResult);
                     }
                 });
                 if (requestTimeoutMillis > 0) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 53a3a0c6f..3216609ae 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -857,6 +857,7 @@ public class HonoClientImpl implements HonoClient {
                     context,
                     clientConfigProperties,
                     cacheProvider,
+                    tracer,
                     connection,
                     this::removeTenantClient,
                     this::removeTenantClient,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
index 54e29c546..bb72bcb3b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
@@ -16,9 +16,10 @@ package org.eclipse.hono.client.impl;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.util.Map;
+import java.util.Objects;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
 
-import io.vertx.core.buffer.Buffer;
 import javax.security.auth.x500.X500Principal;
 
 import org.eclipse.hono.cache.CacheProvider;
@@ -26,7 +27,10 @@ import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.client.TenantClient;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.CacheDirective;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RegistrationConstants;
 import org.eclipse.hono.util.TenantConstants;
 import org.eclipse.hono.util.TenantConstants.TenantAction;
 import org.eclipse.hono.util.TenantObject;
@@ -37,10 +41,16 @@ import org.slf4j.LoggerFactory;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
 
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.noop.NoopTracerFactory;
+import io.opentracing.tag.StringTag;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.buffer.Buffer;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonReceiver;
@@ -55,6 +65,7 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
 
     private static final Logger LOG = LoggerFactory.getLogger(TenantClientImpl.class);
     private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
+    private static final StringTag TAG_SUBJECT_DN = new StringTag("subject_dn");
 
     /**
      * Creates a tenant API client.
@@ -64,7 +75,20 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
     protected TenantClientImpl(final Context context, final ClientConfigProperties config) {
-        super(context, config, null);
+        this(context, config, NoopTracerFactory.create());
+    }
+
+    /**
+     * Creates a tenant API client.
+     *
+     * @param context The Vert.x context to run message exchanges with the peer on.
+     * @param config The configuration properties to use.
+     * @param tracer The tracer to use for tracking request processing
+     *               across process boundaries.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    protected TenantClientImpl(final Context context, final ClientConfigProperties config, final Tracer tracer) {
+        super(context, config, tracer, null);
     }
 
     /**
@@ -79,7 +103,23 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
     protected TenantClientImpl(final Context context, final ClientConfigProperties config,
                            final ProtonSender sender, final ProtonReceiver receiver) {
 
-        super(context, config, null, sender, receiver);
+        this(context, config, null, sender, receiver);
+    }
+
+    /**
+     * Creates a tenant API client.
+     *
+     * @param context The Vert.x context to run message exchanges with the peer on.
+     * @param config The configuration properties to use.
+     * @param tracer The tracer to use for tracking request processing
+     *               across process boundaries.
+     * @param sender The AMQP 1.0 link to use for sending requests to the peer.
+     * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    protected TenantClientImpl(final Context context, final ClientConfigProperties config,
+                           final Tracer tracer, final ProtonSender sender, final ProtonReceiver receiver) {
+        super(context, config, tracer, null, sender, receiver);
     }
 
     @Override
@@ -126,6 +166,8 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
      * @param clientConfig The configuration properties to use.
      * @param cacheProvider A factory for cache instances for tenant configuration results. If {@code null}
      *                     the client will not cache any results from the Tenant service.
+     * @param tracer The tracer to use for tracking request processing
+     *               across process boundaries.
      * @param con The AMQP connection to the server.
      * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
      * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
@@ -136,13 +178,14 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
             final Context context,
             final ClientConfigProperties clientConfig,
             final CacheProvider cacheProvider,
+            final Tracer tracer,
             final ProtonConnection con,
             final Handler<String> senderCloseHook,
             final Handler<String> receiverCloseHook,
             final Handler<AsyncResult<TenantClient>> creationHandler) {
 
         LOG.debug("creating new tenant client");
-        final TenantClientImpl client = new TenantClientImpl(context, clientConfig);
+        final TenantClientImpl client = new TenantClientImpl(context, clientConfig, tracer);
         if (cacheProvider != null) {
             client.setResponseCache(cacheProvider.getCache(TenantClientImpl.getTargetAddress()));
         }
@@ -162,16 +205,38 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
      */
     @Override
     public final Future<TenantObject> get(final String tenantId) {
+        return get(tenantId, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<TenantObject> get(final String tenantId, final SpanContext parent) {
+
+        Objects.requireNonNull(tenantId);
 
         final TriTuple<TenantAction, String, Object> key = TriTuple.of(TenantAction.get, tenantId, null);
+        final Span span = newChildSpan(parent, "get Tenant configuration");
+        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
+        final AtomicBoolean cacheHit = new AtomicBoolean(true);
 
         return getResponseFromCache(key).recover(t -> {
+            cacheHit.set(false);
             final Future<TenantResult<TenantObject>> tenantResult = Future.future();
             final JsonObject payload = new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, tenantId);
-            createAndSendRequest(TenantConstants.TenantAction.get.toString(), customizeRequestApplicationProperties(), payload.toBuffer(),
-                    tenantResult.completer(), key);
+            createAndSendRequest(
+                    TenantConstants.TenantAction.get.toString(),
+                    customizeRequestApplicationProperties(),
+                    payload.toBuffer(),
+                    RegistrationConstants.CONTENT_TYPE_APPLICATION_JSON,
+                    tenantResult.completer(),
+                    key,
+                    span);
             return tenantResult;
         }).map(tenantResult -> {
+            TracingHelper.TAG_CACHE_HIT.set(span, cacheHit.get());
+            span.finish();
             switch(tenantResult.getStatus()) {
                 case HttpURLConnection.HTTP_OK:
                     return tenantResult.getPayload();
@@ -183,20 +248,38 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
         });
     }
 
+
     /**
      * {@inheritDoc}
      */
     @Override
     public final Future<TenantObject> get(final X500Principal subjectDn) {
+        return get(subjectDn, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<TenantObject> get(final X500Principal subjectDn, final SpanContext parent) {
+
+        Objects.requireNonNull(subjectDn);
 
+        final String subjectDnRfc2253 = subjectDn.getName(X500Principal.RFC2253);
         final TriTuple<TenantAction, X500Principal, Object> key = TriTuple.of(TenantAction.get, subjectDn, null);
+        final Span span = newChildSpan(parent, "get Tenant configuration");
+        TAG_SUBJECT_DN.set(span, subjectDnRfc2253);
+        final AtomicBoolean cacheHit = new AtomicBoolean(true);
 
         return getResponseFromCache(key).recover(t -> {
+            cacheHit.set(false);
             final Future<TenantResult<TenantObject>> tenantResult = Future.future();
-            final JsonObject payload = new JsonObject().put(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN, subjectDn.getName(X500Principal.RFC2253));
+            final JsonObject payload = new JsonObject().put(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN, subjectDnRfc2253);
             createAndSendRequest(TenantConstants.TenantAction.get.toString(), customizeRequestApplicationProperties(), payload.toBuffer(), tenantResult.completer(), key);
             return tenantResult;
         }).map(tenantResult -> {
+            TracingHelper.TAG_CACHE_HIT.set(span, cacheHit.get());
+            span.finish();
             switch(tenantResult.getStatus()) {
                 case HttpURLConnection.HTTP_OK:
                     return tenantResult.getPayload();
