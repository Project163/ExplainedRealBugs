diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 9c89900cf..e69ade170 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -313,11 +313,13 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      *         The future will be succeeded if the message has been sent to the endpoint.
      *         The delivery contained in the future represents the delivery state at the time
      *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events and commands it will be locally
      *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent.
+     *         message could not be sent or, in the case of events or commands, if no delivery update
+     *         was received from the peer within the configured timeout period
+     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
      * @throws NullPointerException if any of the parameters are {@code null}.
      */
     protected abstract Future<ProtonDelivery> sendMessage(Message message, Span currentSpan);
@@ -389,7 +391,9 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      *         by the peer.
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or has not been accepted by the peer.
+     *         message could not be sent or has not been accepted by the peer or if no delivery update
+     *         was received from the peer within the configured timeout period
+     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
      * @throws NullPointerException if the message is {@code null}.
      */
     protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message, final Span currentSpan) {
@@ -405,9 +409,27 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
         details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());
         currentSpan.log(details);
 
+        final Long timerId = config.getSendMessageTimeout() > 0
+                ? context.owner().setTimer(config.getSendMessageTimeout(), id -> {
+                    if (!result.isComplete()) {
+                        final ServerErrorException exception = new ServerErrorException(
+                                HttpURLConnection.HTTP_UNAVAILABLE,
+                                "waiting for delivery update timed out after " + config.getSendMessageTimeout() + "ms");
+                        LOG.debug("waiting for delivery update timed out for message [message ID: {}] after {}ms",
+                                messageId, config.getSendMessageTimeout());
+                        result.fail(exception);
+                    }
+                })
+                : null;
+
         sender.send(message, deliveryUpdated -> {
+            if (timerId != null) {
+                context.owner().cancelTimer(timerId);
+            }
             final DeliveryState remoteState = deliveryUpdated.getRemoteState();
-            if (deliveryUpdated.remotelySettled()) {
+            if (result.isComplete()) {
+                LOG.debug("ignoring received delivery update for message [message ID: {}]: waiting for the update has already timed out", messageId);
+            } else if (deliveryUpdated.remotelySettled()) {
                 if (Accepted.class.isInstance(remoteState)) {
                     currentSpan.log("message accepted by peer");
                     result.complete(deliveryUpdated);
@@ -447,6 +469,7 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
             return delivery;
         }).recover(t -> {
             TracingHelper.logError(currentSpan, t);
+            Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(result.cause()));
             currentSpan.finish();
             return Future.failedFuture(t);
         });
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index d2e20c6c1..c43335d78 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -156,7 +156,9 @@ public final class EventSenderImpl extends AbstractSender {
      *         by the peer.
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or has not been accepted by the peer.
+     *         message could not be sent or has not been accepted by the peer or if no delivery update
+     *         was received from the peer within the configured timeout period
+     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
      * @throws NullPointerException if any of the parameters are {@code null}.
      */
     @Override
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index f05514689..52389fb0a 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -17,6 +17,7 @@ import java.net.HttpURLConnection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
@@ -200,9 +201,30 @@ public final class TelemetrySenderImpl extends AbstractSender {
         details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());
         currentSpan.log(details);
 
+        final AtomicBoolean timeoutReached = new AtomicBoolean(false);
+        final Long timerId = config.getSendMessageTimeout() > 0
+                ? context.owner().setTimer(config.getSendMessageTimeout(), id -> {
+                    if (timeoutReached.compareAndSet(false, true)) {
+                        final ServerErrorException exception = new ServerErrorException(
+                                HttpURLConnection.HTTP_UNAVAILABLE,
+                                "waiting for delivery update timed out after " + config.getSendMessageTimeout() + "ms");
+                        LOG.debug("waiting for delivery update timed out for message [message ID: {}] after {}ms",
+                                messageId, config.getSendMessageTimeout());
+                        TracingHelper.logError(currentSpan, exception.getMessage());
+                        Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
+                        currentSpan.finish();
+                    }
+                })
+                : null;
+
         final ProtonDelivery result = sender.send(message, deliveryUpdated -> {
+            if (timerId != null) {
+                context.owner().cancelTimer(timerId);
+            }
             final DeliveryState remoteState = deliveryUpdated.getRemoteState();
-            if (deliveryUpdated.remotelySettled()) {
+            if (timeoutReached.get()) {
+                LOG.debug("ignoring received delivery update for message [message ID: {}]: waiting for the update has already timed out", messageId);
+            } else if (deliveryUpdated.remotelySettled()) {
                 if (Accepted.class.isInstance(remoteState)) {
                     LOG.trace("message [message ID: {}] accepted by peer", messageId);
                     currentSpan.log("message accepted by peer");
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
index ad9c27fd8..821bffa56 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
@@ -18,8 +18,11 @@ import static org.junit.Assert.*;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
+import java.net.HttpURLConnection;
+
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.MessageHelper;
@@ -46,6 +49,7 @@ public class AbstractSenderTest {
     private ProtonSender protonSender;
     private ClientConfigProperties config;
     private Context context;
+    private Vertx vertx;
 
     /**
      * Sets up the fixture.
@@ -54,7 +58,8 @@ public class AbstractSenderTest {
     public void setUp() {
         protonSender = HonoClientUnitTestHelper.mockProtonSender();
         config = new ClientConfigProperties();
-        context = HonoClientUnitTestHelper.mockContext(mock(Vertx.class));
+        vertx = mock(Vertx.class);
+        context = HonoClientUnitTestHelper.mockContext(vertx);
     }
 
     /**
@@ -124,6 +129,35 @@ public class AbstractSenderTest {
         verify(protonSender, never()).send(any(Message.class));
     }
 
+    /**
+     * Verifies that the sender fails if a timeout occurs.
+     */
+    @Test
+    public void testSendMessageFailsOnTimeout() {
+
+        // GIVEN a sender that won't receive a delivery update on sending a message 
+        // and directly triggers the timeout handler
+        when(protonSender.send(any(Message.class), any(Handler.class))).thenReturn(mock(ProtonDelivery.class));
+        when(vertx.setTimer(anyLong(), any(Handler.class))).thenAnswer(invocation -> {
+            final Handler<Long> handler = invocation.getArgument(1);
+            final long timerId = 1;
+            handler.handle(timerId);
+            return timerId;
+        });
+        final AbstractSender sender = newSender("tenant", "endpoint");
+
+        // WHEN sending a message
+        final Message message = mock(Message.class);
+        final Span span = mock(Span.class);
+        final Future<ProtonDelivery> result = sender.sendMessageAndWaitForOutcome(message, span);
+
+        // THEN the returned result future will fail with a 503 status code.
+        assertFalse(result.succeeded());
+        assertTrue(result.cause() instanceof ServerErrorException);
+        assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) result.cause()).getErrorCode());
+        verify(span).finish();
+    }
+
     /**
      * Verifies credits available.
      *
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
index 7e6d789a3..3719327a9 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
@@ -26,6 +26,7 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import io.opentracing.Span;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -114,4 +115,31 @@ public class TelemetrySenderImplTest {
         assertFalse(result.succeeded());
         verify(sender, never()).send(any(Message.class), any(Handler.class));
     }
+
+    /**
+     * Verifies that a timeout occurring while a message is sent doesn't cause the corresponding 
+     * OpenTracing span to stay unfinished.
+     */
+    @Test
+    public void testSendMessageFailsOnTimeout() {
+
+        // GIVEN a sender that won't receive a delivery update on sending a message 
+        // and directly triggers the timeout handler
+        when(sender.send(any(Message.class), any(Handler.class))).thenReturn(mock(ProtonDelivery.class));
+        when(vertx.setTimer(anyLong(), any(Handler.class))).thenAnswer(invocation -> {
+            final Handler<Long> handler = invocation.getArgument(1);
+            final long timerId = 1;
+            handler.handle(timerId);
+            return timerId;
+        });
+        final MessageSender messageSender = new TelemetrySenderImpl(config, sender, "tenant", "telemetry/tenant", context);
+
+        // WHEN sending a message
+        final Message message = mock(Message.class);
+        final Span span = mock(Span.class);
+        ((TelemetrySenderImpl) messageSender).sendMessage(message, span);
+
+        // THEN the given Span will nonetheless be finished.
+        verify(span).finish();
+    }
 }
