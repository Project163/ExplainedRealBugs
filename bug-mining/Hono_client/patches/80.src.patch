diff --git a/client/src/main/java/org/eclipse/hono/client/RequestResponseClientConfigProperties.java b/client/src/main/java/org/eclipse/hono/client/RequestResponseClientConfigProperties.java
index 1c6ac44bf..fa736f0c9 100644
--- a/client/src/main/java/org/eclipse/hono/client/RequestResponseClientConfigProperties.java
+++ b/client/src/main/java/org/eclipse/hono/client/RequestResponseClientConfigProperties.java
@@ -31,9 +31,14 @@ public class RequestResponseClientConfigProperties extends ClientConfigPropertie
      * The default maximum size of response caches.
      */
     public static final long DEFAULT_RESPONSE_CACHE_MAX_SIZE = 1000L;
+    /**
+     * The default timeout for cached responses in seconds until they are considered invalid.
+     */
+    public static final int DEFAULT_RESPONSE_CACHE_TIMEOUT = 600;
 
     private int responseCacheMinSize = DEFAULT_RESPONSE_CACHE_MIN_SIZE;
     private long responseCacheMaxSize = DEFAULT_RESPONSE_CACHE_MAX_SIZE;
+    private int responseCacheDefaultTimeout = DEFAULT_RESPONSE_CACHE_TIMEOUT;
 
     /**
      * Gets the minimum size of the response cache.
@@ -58,7 +63,7 @@ public class RequestResponseClientConfigProperties extends ClientConfigPropertie
      * @param size The maximum number of results to keep in the cache.
      * @throws IllegalArgumentException if size is &lt; 0.
      */
-    public final void setResponseCacheMinSize(int size) {
+    public final void setResponseCacheMinSize(final int size) {
         if (size < 0) {
             throw new IllegalArgumentException("minimum cache size must not be negative");
         }
@@ -94,10 +99,38 @@ public class RequestResponseClientConfigProperties extends ClientConfigPropertie
      * @param size The maximum number of results to keep in the cache.
      * @throws IllegalArgumentException if size is &lt; 0.
      */
-    public final void setResponseCacheMaxSize(long size) {
+    public final void setResponseCacheMaxSize(final long size) {
         if (size < 0) {
             throw new IllegalArgumentException("maximum cache size must not be negative");
         }
         this.responseCacheMaxSize = size;
     }
+
+    /**
+     * Gets the configured default timeout {@link #DEFAULT_RESPONSE_CACHE_TIMEOUT} for cached responses in seconds.
+     * <p>
+     * When a response is put to the cache, this value is taken as the default timeout before the cached response is
+     * considered invalid.
+     *
+     * @return The default timeout for cached responses.
+     */
+    public final int getResponseCacheDefaultTimeout() {
+        return responseCacheDefaultTimeout;
+    }
+
+    /**
+     * Set the configured default timeout {@link #DEFAULT_RESPONSE_CACHE_TIMEOUT} for cached responses in seconds.
+     * <p>
+     * When a response is put to the cache, this value is taken as the default timeout before the cached response is
+     * considered invalid.
+     *
+     * @param timeoutInSeconds The timeout in seconds.
+     * @throws IllegalArgumentException if size is &lt;= 0.
+     */
+    public final void setResponseCacheDefaultTimeout(final int timeoutInSeconds) {
+        if (timeoutInSeconds <= 0) {
+            throw new IllegalArgumentException("default cache timeout must be greater than zero");
+        }
+        this.responseCacheDefaultTimeout = timeoutInSeconds;
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 8e933c76f..664814ecb 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -73,6 +73,11 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      */
     private ExpiringValueCache<Object, R> responseCache;
 
+    /**
+     * The default timeout for the response cache that may be used when putting new entries to the cache.
+     */
+    private int responseCacheTimeoutSeconds;
+
     private long requestTimeoutMillis = DEFAULT_TIMEOUT_MILLIS;
 
     /**
@@ -121,6 +126,24 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         LOG.info("enabling caching of responses from {}", targetAddress);
     }
 
+    /**
+     * Gets the timeout in seconds that may be used when putting new entries to the response cache.
+     *
+     * @return The timeout for new entries.
+     */
+    public int getResponseCacheTimeoutSeconds() {
+        return responseCacheTimeoutSeconds;
+    }
+
+    /**
+     * Sets the timeout in seconds that may be used when putting new entries to the response cache.
+     *
+     * @param responseCacheTimeoutSeconds The timeout for new entries.
+     */
+    public void setResponseCacheTimeoutSeconds(final int responseCacheTimeoutSeconds) {
+        this.responseCacheTimeoutSeconds = responseCacheTimeoutSeconds;
+    }
+
     /**
      * Sets the period of time after which any requests are considered to have timed out.
      * <p>
@@ -235,7 +258,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
 
         final Handler<AsyncResult<R>> handler = replyMap.remove(message.getCorrelationId());
         if (handler != null) {
-            R response = getRequestResponseResult(message);
+            final R response = getRequestResponseResult(message);
             LOG.debug("received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}]",
                     replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus());
             handler.handle(Future.succeededFuture(response));
@@ -262,7 +285,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         if (!result.failed()) {
             throw new IllegalArgumentException("result must be failed");
         } else {
-            Handler<AsyncResult<R>> responseHandler = replyMap.remove(correlationId);
+            final Handler<AsyncResult<R>> responseHandler = replyMap.remove(correlationId);
             if (responseHandler != null) {
                 LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
                         targetAddress, correlationId, result.cause().getMessage());
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index db3fbd9cb..27ba34fec 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -76,6 +76,7 @@ public class HonoClientImpl implements HonoClient {
     private ProtonClientOptions clientOptions;
     private ProtonConnection connection;
     private CacheManager cacheManager;
+    private int responseCacheDefaultTimeoutSeconds;
     private AtomicInteger reconnectAttempts = new AtomicInteger(0);
 
     /**
@@ -127,7 +128,19 @@ public class HonoClientImpl implements HonoClient {
      * @throws NullPointerException if manager is {@code null}.
      */
     public final void setCacheManager(final CacheManager manager) {
+        this.setCacheManager(manager, 0);
+    }
+
+    /**
+     * Sets a manager for creating cache instances to be used in Hono clients and set a default timeout for entries.
+     *
+     * @param manager The cache manager.
+     * @param defaultTimeoutInSeconds The timeout in seconds that may be used for new entries.
+     * @throws NullPointerException if manager is {@code null}.
+     */
+    public final void setCacheManager(final CacheManager manager, final int defaultTimeoutInSeconds) {
         this.cacheManager = Objects.requireNonNull(manager);
+        this.responseCacheDefaultTimeoutSeconds = defaultTimeoutInSeconds;
     }
 
     /**
@@ -730,6 +743,8 @@ public class HonoClientImpl implements HonoClient {
             TenantClientImpl.create(
                     context,
                     clientConfigProperties,
+                    cacheManager,
+                    responseCacheDefaultTimeoutSeconds,
                     connection,
                     this::removeTenantClient,
                     this::removeTenantClient,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
index 85dbc24a0..d8afb22c2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
@@ -15,6 +15,7 @@ package org.eclipse.hono.client.impl;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
+import java.time.Instant;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.UUID;
@@ -24,8 +25,9 @@ import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.client.TenantClient;
-import org.eclipse.hono.config.ClientConfigProperties;
 
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.SpringBasedExpiringValueCache;
 import org.eclipse.hono.util.TenantConstants;
 import org.eclipse.hono.util.TenantObject;
 import org.eclipse.hono.util.TenantResult;
@@ -39,6 +41,8 @@ import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonConnection;
+import org.springframework.cache.Cache;
+import org.springframework.cache.CacheManager;
 
 /**
  * A Vertx-Proton based client for Hono's Tenant API.
@@ -50,7 +54,6 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
     private static final Logger LOG = LoggerFactory.getLogger(TenantClientImpl.class);
     private static final ObjectMapper objectMapper = new ObjectMapper();
 
-
     /**
      * Creates a tenant API client.
      *
@@ -126,6 +129,8 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
     public final static void create(
             final Context context,
             final ClientConfigProperties clientConfig,
+            final CacheManager cacheManager,
+            final int responseCacheTimeoutInSeconds,
             final ProtonConnection con,
             final Handler<String> senderCloseHook,
             final Handler<String> receiverCloseHook,
@@ -133,6 +138,11 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
 
         LOG.debug("creating new tenant API client.");
         final TenantClientImpl client = new TenantClientImpl(context, clientConfig);
+        if (cacheManager != null) {
+            final Cache cache = cacheManager.getCache(TenantClientImpl.getTargetAddress());
+            client.setResponseCache(new SpringBasedExpiringValueCache<>(cache));
+            client.setResponseCacheTimeoutSeconds(responseCacheTimeoutInSeconds);
+        }
         client.createLinks(con, senderCloseHook, receiverCloseHook).setHandler(s -> {
             if (s.succeeded()) {
                 LOG.debug("successfully created tenant API client");
@@ -150,15 +160,26 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
     @Override
     public final Future<TenantObject> get(final String tenantId) {
 
-        final Future<TenantResult<TenantObject>> responseTracker = Future.future();
-        createAndSendRequest(TenantConstants.TenantAction.get.toString(), createTenantProperties(tenantId), null,
-                responseTracker.completer());
-        return responseTracker.map(response -> {
-            switch (response.getStatus()) {
-            case HttpURLConnection.HTTP_OK:
-                return response.getPayload();
-            default:
-                throw StatusCodeMapper.from(response);
+        return getCachedTenantResult(tenantId).recover(t -> {
+            final Future<TenantResult<TenantObject>> tenantResult = Future.future();
+            createAndSendRequest(TenantConstants.TenantAction.get.toString(), createTenantProperties(tenantId), null,
+                    tenantResult.completer());
+            return tenantResult.map(result -> {
+                switch(result.getStatus()) {
+                    case HttpURLConnection.HTTP_OK:
+                        if (isCachingEnabled()) {
+                            putResponseToCache(tenantId, result, Instant.now().plusSeconds(getResponseCacheTimeoutSeconds()));
+                        }
+                    default:
+                        return result;
+                }
+            });
+        }).map(result -> {
+            switch(result.getStatus()) {
+                case HttpURLConnection.HTTP_OK:
+                    return result.getPayload();
+                default:
+                    throw StatusCodeMapper.from(result);
             }
         });
     }
@@ -168,4 +189,14 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
         properties.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
         return properties;
     }
+
+    private Future<TenantResult<TenantObject>> getCachedTenantResult(final String key) {
+
+        final TenantResult<TenantObject> result = getResponseFromCache(key);
+        if (result == null) {
+            return Future.failedFuture("tenant cache miss");
+        } else {
+            return Future.succeededFuture(result);
+        }
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
index 8cfb53329..31fe99d98 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
@@ -21,12 +21,18 @@ import static org.mockito.Mockito.*;
 
 import io.vertx.core.Context;
 import io.vertx.core.Vertx;
+import io.vertx.core.json.JsonObject;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.RequestResponseClientConfigProperties;
+import org.eclipse.hono.util.ExpiringValueCache;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.TenantConstants;
+import org.eclipse.hono.util.TenantObject;
+import org.eclipse.hono.util.TenantResult;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -38,6 +44,9 @@ import io.vertx.core.Handler;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
 
+import java.net.HttpURLConnection;
+import java.time.Instant;
+
 
 /**
  * Tests verifying behavior of {@link TenantClientImpl}.
@@ -56,6 +65,7 @@ public class TenantClientImplTest {
     private Context context;
     private ProtonSender sender;
     private TenantClientImpl client;
+    private ExpiringValueCache<Object, TenantResult<TenantObject>> cache;
 
     /**
      * Sets up the fixture.
@@ -69,6 +79,7 @@ public class TenantClientImplTest {
         final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
         sender = HonoClientUnitTestHelper.mockProtonSender();
 
+        cache = mock(ExpiringValueCache.class);
         final RequestResponseClientConfigProperties config = new RequestResponseClientConfigProperties();
         client = new TenantClientImpl(context, config, sender, receiver);
     }
@@ -81,7 +92,7 @@ public class TenantClientImplTest {
      */
     @SuppressWarnings("unchecked")
     @Test
-    public void testGetTenant(final TestContext ctx) {
+    public void testGetTenantInvokesServiceIfNoCacheConfigured(final TestContext ctx) {
 
         // GIVEN an adapter
 
@@ -97,6 +108,63 @@ public class TenantClientImplTest {
         assertThat(sentMessage.getSubject(), is(TenantConstants.TenantAction.get.toString()));
     }
 
+    /**
+     * Verifies that on a cache miss the adapter retrieves tenant information
+     * from the Tenant service and puts it to the cache.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testGetTenantAddsInfoToCacheOnCacheMiss(final TestContext ctx) {
+
+        // GIVEN an adapter with an empty cache
+        client.setResponseCache(cache);
+        client.setResponseCacheTimeoutSeconds(600);
+        final JsonObject tenantResult = newTenantResult("tenant");
+        final Message response = ProtonHelper.message(tenantResult.encode());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+
+        // WHEN getting tenant information
+        client.get("tenant").setHandler(ctx.asyncAssertSuccess(result -> {
+            // THEN the tenant result has been added to the cache
+            verify(cache).put(eq("tenant"), any(TenantResult.class), any(Instant.class));
+        }));
+
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+    }
+
+    /**
+     * Verifies that tenant information is taken from cache if cache is configured and the cache has this tenant
+     * information cached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetTenantReturnsValueFromCache(final TestContext ctx) {
+
+        // GIVEN an adapter with a cache containing a tenant
+        client.setResponseCache(cache);
+        client.setResponseCacheTimeoutSeconds(600);
+
+        final JsonObject tenantJsonObject = newTenantResult("tenant");
+        final TenantResult<TenantObject> tenantResult = client.getResult(HttpURLConnection.HTTP_OK, tenantJsonObject.toString());
+
+        when(cache.get(eq("tenant"))).thenReturn(tenantResult);
+
+        // WHEN getting tenant information
+        client.get("tenant").setHandler(ctx.asyncAssertSuccess(result -> {
+            // THEN the tenant information is read from the cache
+            ctx.assertEquals(tenantResult.getPayload(), result);
+            verify(sender, never()).send(any(Message.class));
+        }));
+
+    }
+
     /**
      * Verifies that the client uses the correct message id prefix defined for the tenant client.
      *
@@ -118,4 +186,11 @@ public class TenantClientImplTest {
         assertThat(sentMessage.getMessageId().toString(), startsWith(TenantConstants.MESSAGE_ID_PREFIX));
     }
 
+    private JsonObject newTenantResult(final String tenantId) {
+
+        final JsonObject returnObject = new JsonObject().
+                put(TenantConstants.FIELD_TENANT_ID, tenantId).
+                put(TenantConstants.FIELD_ENABLED, true);
+        return returnObject;
+    }
 }
