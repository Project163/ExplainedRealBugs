diff --git a/client/src/main/java/org/eclipse/hono/client/BasicDeviceConnectionClientFactory.java b/client/src/main/java/org/eclipse/hono/client/BasicDeviceConnectionClientFactory.java
deleted file mode 100644
index dbfc0d0eb..000000000
--- a/client/src/main/java/org/eclipse/hono/client/BasicDeviceConnectionClientFactory.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import io.vertx.core.Future;
-
-/**
- * A factory for creating clients for Hono's Device Connection API.
- *
- * @deprecated Use the {@code org.eclipse.hono.client.command.DeviceConnectionClient} instead.
- */
-@Deprecated
-public interface BasicDeviceConnectionClientFactory {
-
-    /**
-     * Gets a client for invoking operations on a service implementing Hono's <em>Device Connection</em> API.
-     *
-     * @param tenantId The tenant to manage device connection data for.
-     * @return A future that will complete with the device connection client (if successful) or fail if the client
-     *         cannot be created, e.g. because the underlying connection is not established or if a concurrent
-     *         request to create a client for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<DeviceConnectionClient> getOrCreateDeviceConnectionClient(String tenantId);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandContext.java b/client/src/main/java/org/eclipse/hono/client/CommandContext.java
deleted file mode 100644
index 6dd00a908..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandContext.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/**
- * Copyright (c) 2018, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import java.util.Objects;
-
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Modified;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.MapBasedExecutionContext;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * A context for passing around parameters relevant for processing a {@code Command}.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.CommandContext} instead.
- */
-@Deprecated
-public class CommandContext extends MapBasedExecutionContext {
-
-    /**
-     * The key under which the current CommandContext is stored.
-     */
-    public static final String KEY_COMMAND_CONTEXT = "command-context";
-
-    private static final Logger LOG = LoggerFactory.getLogger(CommandContext.class);
-
-    private final Command command;
-    private final ProtonDelivery delivery;
-
-    private CommandContext(
-            final Command command,
-            final ProtonDelivery delivery,
-            final Span span) {
-        super(span);
-        this.command = command;
-        this.delivery = delivery;
-    }
-
-    /**
-     * Creates a context for a command.
-     *
-     * @param command The command to be processed.
-     * @param delivery The delivery corresponding to the message.
-     * @param span The OpenTracing span to use for tracking the processing of the command.
-     * @return The context.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public static CommandContext from(
-            final Command command,
-            final ProtonDelivery delivery,
-            final Span span) {
-
-        Objects.requireNonNull(command);
-        Objects.requireNonNull(delivery);
-        Objects.requireNonNull(span);
-        return new CommandContext(command, delivery, span);
-    }
-
-    /**
-     * Gets the command to process.
-     *
-     * @return The command.
-     */
-    public Command getCommand() {
-        return command;
-    }
-
-    /**
-     * Gets the delivery corresponding to the command message.
-     *
-     * @return The delivery.
-     */
-    public ProtonDelivery getDelivery() {
-        return delivery;
-    }
-
-    /**
-     * Settles the command message with the <em>accepted</em> outcome.
-     * <p>
-     * This method also finishes the OpenTracing span returned by
-     * {@link #getTracingSpan()}.
-     */
-    public void accept() {
-        disposition(Accepted.getInstance());
-    }
-
-    /**
-     * Settles the command message with the <em>released</em> outcome.
-     * <p>
-     * This method also finishes the OpenTracing span returned by
-     * {@link #getTracingSpan()}.
-     */
-    public void release() {
-        disposition(Released.getInstance());
-    }
-
-    /**
-     * Settles the command message with the <em>modified</em> outcome.
-     * <p>
-     * This method also finishes the OpenTracing span returned by
-     * {@link #getTracingSpan()}.
-     *
-     * @param deliveryFailed Whether the delivery should be treated as failed.
-     * @param undeliverableHere Whether the delivery is considered undeliverable.
-     */
-    public void modify(final boolean deliveryFailed, final boolean undeliverableHere) {
-        final Modified modified = new Modified();
-        modified.setDeliveryFailed(deliveryFailed);
-        modified.setUndeliverableHere(undeliverableHere);
-        disposition(modified);
-    }
-
-    /**
-     * Settles the command message with the <em>rejected</em> outcome.
-     * <p>
-     * This method also finishes the OpenTracing span returned by
-     * {@link #getTracingSpan()}.
-     *
-     * @param errorCondition The error condition to send in the disposition frame (may be {@code null}).
-     */
-    public void reject(final ErrorCondition errorCondition) {
-        final Rejected rejected = new Rejected();
-        if (errorCondition != null) {
-            rejected.setError(errorCondition);
-        }
-        disposition(rejected);
-    }
-
-    /**
-     * Settles the command message with the given {@code DeliveryState} outcome.
-     * <p>
-     * This method also finishes the OpenTracing span returned by
-     * {@link #getTracingSpan()}.
-     *
-     * @param deliveryState The deliveryState to set in the disposition frame.
-     * @throws NullPointerException if deliveryState is {@code null}.
-     */
-    public void disposition(final DeliveryState deliveryState) {
-
-        Objects.requireNonNull(deliveryState);
-        final Span span = getTracingSpan();
-        if (delivery.isSettled()) {
-            final String msg = String.format("cannot complete incoming delivery of command message with outcome '%s' - delivery already settled locally; local state: %s",
-                    deliveryState, delivery.getLocalState());
-            TracingHelper.logError(getTracingSpan(), msg);
-            LOG.info("{} [{}]", msg, getCommand());
-        } else {
-            final boolean wasAlreadyRemotelySettled = delivery.remotelySettled();
-            // if delivery is already settled remotely call "disposition" anyway to update local state and settle locally
-            delivery.disposition(deliveryState, true);
-            if (wasAlreadyRemotelySettled) {
-                final String msg = String.format("cannot complete incoming delivery of command message with outcome '%s' - delivery already settled remotely; remote state: %s",
-                        deliveryState, delivery.getRemoteState());
-                TracingHelper.logError(getTracingSpan(), msg);
-                LOG.info("{} [{}]", msg, getCommand());
-            } else if (Accepted.class.isInstance(deliveryState)) {
-                LOG.trace("accepted command message [{}]", getCommand());
-                span.log("accepted command for device");
-
-            } else if (Released.class.isInstance(deliveryState)) {
-                LOG.debug("released command message [{}]", getCommand());
-                TracingHelper.logError(span, "released command for device");
-
-            } else if (Modified.class.isInstance(deliveryState)) {
-                final Modified modified = (Modified) deliveryState;
-                LOG.debug("modified command message [{}]", getCommand());
-                TracingHelper.logError(span, "modified command for device"
-                        + (Boolean.TRUE.equals(modified.getDeliveryFailed()) ? "; delivery failed" : "")
-                        + (Boolean.TRUE.equals(modified.getUndeliverableHere()) ? "; undeliverable here" : ""));
-
-            } else if (Rejected.class.isInstance(deliveryState)) {
-                final ErrorCondition errorCondition = ((Rejected) deliveryState).getError();
-                LOG.debug("rejected command message [error: {}, command: {}]", errorCondition, getCommand());
-                TracingHelper.logError(span, "rejected command for device"
-                        + ((errorCondition != null && errorCondition.getDescription() != null)
-                                ? "; error: " + errorCondition.getDescription()
-                                : ""));
-            } else {
-                LOG.warn("unexpected delivery state [{}] when settling command message [{}]", deliveryState, getCommand());
-                TracingHelper.logError(span, "unexpected delivery state: " + deliveryState);
-            }
-        }
-        span.finish();
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java b/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
deleted file mode 100644
index 63428b4ca..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
+++ /dev/null
@@ -1,214 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import java.util.Collections;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.stream.Collectors;
-
-import org.eclipse.hono.client.impl.CommandTargetMapperImpl;
-import org.eclipse.hono.util.RegistrationConstants;
-
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonObject;
-
-/**
- * A component for determining where a incoming command message should be targeted at when processing the message in a
- * protocol adapter.
- * <p>
- * This refers to finding the <em>protocol adapter instance</em> that a device or gateway has connected to in order to
- * receive a command message. Furthermore, it is determined to which <em>gateway</em> a command is to be mapped to or
- * whether it will be sent to the target device directly.
- * <p>
- * For obtaining both information, the <em>getCommandHandlingAdapterInstances</em> operation of the Device Connection
- * service is used. See the <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
- * specification</a> for details on that operation. Note that a possible result of multiple entries of that operation
- * will be reduced to just one finding here.
- * <p>
- * The <em>CommandTargetMapper</em> will return a gateway id as target, if there is no command consumer registered
- * specifically for the device id of the command, but instead there is a consumer registered for a gateway that may act
- * on behalf of the device.
- * <p>
- * Note that this also means that if a <em>gateway</em> has registered itself as a command consumer for a <em>specific
- * device</em> (instead of as a consumer for commands to <em>any</em> device that the gateway may handle), that gateway
- * won't be returned here for that device. That kind of gateway mapping will occur when processing the command at the
- * target protocol adapter instance.
- */
-@Deprecated
-public interface CommandTargetMapper {
-
-    /**
-     * Access to collaborators that the mapper needs for doing its work.
-     *
-     */
-    interface CommandTargetMapperContext {
-
-        /**
-         * Gets the device identifiers of the gateways that an edge device may connect via.
-         *
-         * @param tenant The tenant that the device belongs to.
-         * @param deviceId The device id.
-         * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-         *            Implementing classes should use this as the parent for any span they create for tracing the execution
-         *            of this operation.
-         * @return The gateway identifiers.
-         * @throws NullPointerException if any of the parameters except context is {@code null}.
-         */
-        Future<List<String>> getViaGateways(String tenant, String deviceId, SpanContext context);
-
-        /**
-         * Gets information about the adapter instances that can handle a command for the given device.
-         * <p>
-         * See Hono's <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
-         * specification</a> for a detailed description of the method's behaviour and the returned JSON object.
-         * <p>
-         * If no adapter instances are found, the returned future is failed.
-         *
-         * @param tenant The tenant that the device belongs to.
-         * @param deviceId The device id.
-         * @param viaGateways The list of gateways that may act on behalf of the given device.
-         * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-         *            Implementing classes should use this as the parent for any span they create for tracing the execution
-         *            of this operation.
-         * @return A future indicating the outcome of the operation.
-         *         <p>
-         *         If instances were found, the future will be succeeded with a JSON object containing one or more mappings
-         *         from device id to adapter instance id. Otherwise the future will be failed with a
-         *         {@link org.eclipse.hono.client.ServiceInvocationException}.
-         * @throws NullPointerException if any of the parameters except context is {@code null}.
-         */
-        Future<JsonObject> getCommandHandlingAdapterInstances(
-                String tenant,
-                String deviceId,
-                List<String> viaGateways,
-                SpanContext context);
-    }
-
-    /**
-     * Creates a new {@link CommandTargetMapper} using the default implementation.
-     *
-     * @param tracer The tracer instance.
-     * @return The CommandTargetMapper instance.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    static CommandTargetMapper create(final Tracer tracer) {
-        return new CommandTargetMapperImpl(tracer);
-    }
-
-    /**
-     * Creates a mapper context for client factories.
-     *
-     * @param registrationClientFactory The factory for creating Device Registration service clients.
-     * @param deviceConnectionClientFactory The factory for creating Device Connection service clients.
-     * @return The mapper context.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    static CommandTargetMapperContext createContext(
-            final RegistrationClientFactory registrationClientFactory,
-            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {
-
-        Objects.requireNonNull(registrationClientFactory);
-        Objects.requireNonNull(deviceConnectionClientFactory);
-
-        return new CommandTargetMapperContext() {
-
-            @Override
-            public Future<List<String>> getViaGateways(
-                    final String tenant,
-                    final String deviceId,
-                    final SpanContext context) {
-
-                Objects.requireNonNull(tenant);
-                Objects.requireNonNull(deviceId);
-
-                return registrationClientFactory.getOrCreateRegistrationClient(tenant)
-                        .compose(client -> client.assertRegistration(deviceId, null, context))
-                        .map(json -> Optional.ofNullable(json.getJsonArray(RegistrationConstants.FIELD_VIA))
-                                .map(array -> array.stream()
-                                        .filter(String.class::isInstance)
-                                        .map(String.class::cast)
-                                        .collect(Collectors.toList()))
-                                .orElse(Collections.emptyList()));
-            }
-
-            @Override
-            public Future<JsonObject> getCommandHandlingAdapterInstances(
-                    final String tenant, 
-                    final String deviceId,
-                    final List<String> viaGateways,
-                    final SpanContext context) {
-
-                Objects.requireNonNull(tenant);
-                Objects.requireNonNull(deviceId);
-                Objects.requireNonNull(viaGateways);
-
-                return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenant)
-                        .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, context));
-            }
-        };
-    }
-
-    /**
-     * Initializes the mapper with the given context.
-     *
-     * @param context The context that the mapper needs for doing its work.
-     * @throws NullPointerException if context is {@code null}.
-     */
-    void initialize(CommandTargetMapperContext context);
-
-    /**
-     * Determines the target protocol adapter instance for a command directed at the given device. Also determines
-     * whether the command should be mapped to a gateway.
-     * <p>
-     * The mapping to a gateway will be done if there is no command consumer registered specifically for the given
-     * device id, but instead there is a consumer registered for a gateway that may act on behalf of the device.
-     * <p>
-     * Note that this also means that if a <em>gateway</em> has registered itself as a command consumer specifically for
-     * the given device (instead of as a consumer for commands to <em>any</em> device that the gateway may handle), that
-     * gateway won't be returned here. That kind of gateway mapping will have to occur when processing the command at
-     * the target protocol adapter instance.
-     * <p>
-     * If there are multiple command subscriptions from gateways that may act on behalf of the device and if the device
-     * hasn't communicated via any of these gateways yet, this method chooses one of the possible combinations of
-     * gateway and adapter instance where that gateway has subscribed for commands.
-     * <p>
-     * The value of the returned future is a JSON object with the fields
-     * {@link org.eclipse.hono.util.DeviceConnectionConstants#FIELD_PAYLOAD_DEVICE_ID} and
-     * {@link org.eclipse.hono.util.DeviceConnectionConstants#FIELD_ADAPTER_INSTANCE_ID} set to the determined values.
-     * If the command is not mapped to a gateway here, the
-     * {@link org.eclipse.hono.util.DeviceConnectionConstants#FIELD_PAYLOAD_DEVICE_ID} contains the given device
-     * id itself.
-     * <p>
-     * Note that {@link #initialize(CommandTargetMapperContext)} has to have been called already,
-     * otherwise a failed future is returned.
-     *
-     * @param tenantId The tenant identifier.
-     * @param deviceId The device identifier.
-     * @param context The currently active OpenTracing span context or {@code null}.
-     * @return A succeeded Future containing the JSON object with target device/gateway and adapter instance; or a
-     *         failed Future with:
-     *         <ul>
-     *         <li>a {@link ClientErrorException} with status <em>Not Found</em> if no matching adapter instance was
-     *         found</li>
-     *         <li>or a {@link ServiceInvocationException} with an error code indicating the cause of the failure</li>
-     *         </ul>
-     * @throws NullPointerException if tenantId or deviceId is {@code null}.
-     */
-    Future<JsonObject> getTargetGatewayAndAdapterInstance(String tenantId, String deviceId, SpanContext context);
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/DelegatedCommandSender.java b/client/src/main/java/org/eclipse/hono/client/DelegatedCommandSender.java
deleted file mode 100644
index 23f716d7a..000000000
--- a/client/src/main/java/org/eclipse/hono/client/DelegatedCommandSender.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * A sender to send command messages that are delegated to be processed by another command consumer.
- * <p>
- * This usually involves command messages first retrieved via a tenant-scoped consumer and then delegated back to the
- * downstream peer so that they can be consumed by the device-specific consumer.
- */
-@Deprecated
-public interface DelegatedCommandSender extends MessageSender {
-
-    /**
-     * Sends a command message to the downstream peer to be consumed by a device-specific consumer.
-     *
-     * @param command The command to send.
-     * @param context The currently active OpenTracing span or {@code null} if no
-     *         span is currently active. An implementation should use this as the
-     *         parent for any new span(s) it creates for tracing the execution of
-     *         this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been accepted (and settled)
-     *         by the consumer.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or if no delivery update
-     *         was received from the peer within the configured timeout period
-     *         (see {@link org.eclipse.hono.config.ClientConfigProperties#getSendMessageTimeout()}).
-     * @throws NullPointerException if command is {@code null}.
-     */
-    Future<ProtonDelivery> sendCommandMessage(Command command, SpanContext context);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
deleted file mode 100644
index cf0828c3a..000000000
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
+++ /dev/null
@@ -1,130 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import java.time.Duration;
-import java.util.List;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonObject;
-
-/**
- * A client for accessing Hono's Device Connection API.
- * <p>
- * An instance of this interface is always scoped to a specific tenant.
- * <p>
- * See Hono's <a href="https://www.eclipse.org/hono/docs/api/device-connection/">
- * Device Connection API specification</a> for a description of the result codes returned.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.DeviceConnectionClient} instead.
- */
-@Deprecated
-public interface DeviceConnectionClient extends RequestResponseClient {
-
-    /**
-     * Sets the given gateway as the last gateway that acted on behalf of the given device.
-     * <p>
-     * If a device connects directly instead of through a gateway, the device identifier itself is to be used as value
-     * for the <em>gatewayId</em> parameter.
-     *
-     * @param deviceId The device id.
-     * @param gatewayId The gateway id (or the device id if the last message came from the device directly).
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *            An implementation should use this as the parent for any span it creates for tracing
-     *            the execution of this operation.
-     * @return A future indicating whether the operation succeeded or not.
-     * @throws NullPointerException if device id or gateway id is {@code null}.
-     */
-    Future<Void> setLastKnownGatewayForDevice(String deviceId, String gatewayId, SpanContext context);
-
-    /**
-     * Gets the gateway that last acted on behalf of the given device.
-     * <p>
-     * If no last known gateway has been set for the given device yet, a failed future with status <em>Not Found</em>
-     * is returned.
-     *
-     * @param deviceId The device id.
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *            An implementation should use this as the parent for any span it creates for tracing
-     *            the execution of this operation.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 200 has been received from the device connection service.
-     *         In that case the value of the future will contain a <em>gateway-id</em> property with the
-     *         gateway id.
-     *         <p>
-     *         In case a status other then 200 is received, the future will fail with a
-     *         {@link ServiceInvocationException} containing the (error) status code returned by the service.
-     * @throws NullPointerException if device id is {@code null}.
-     */
-    Future<JsonObject> getLastKnownGatewayForDevice(String deviceId, SpanContext context);
-
-    /**
-     * Sets the protocol adapter instance that handles commands for the given device.
-     *
-     * @param deviceId The device id.
-     * @param adapterInstanceId The protocol adapter instance id.
-     * @param lifespan The lifespan of the mapping entry. Using a negative duration or {@code null} here is
-     *                 interpreted as an unlimited lifespan. Only the number of seconds in the given duration
-     *                 will be taken into account.
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *            An implementation should use this as the parent for any span it creates for tracing
-     *            the execution of this operation.
-     * @return A future indicating whether the operation succeeded or not.
-     * @throws NullPointerException if device id or adapter instance id is {@code null}.
-     */
-    Future<Void> setCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, Duration lifespan,
-            SpanContext context);
-
-    /**
-     * Removes the mapping information that associates the given device with the given protocol adapter instance
-     * that handles commands for the given device. The mapping entry is only deleted if its value
-     * contains the given protocol adapter instance id.
-     *
-     * @param deviceId The device id.
-     * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *            An implementation should use this as the parent for any span it creates for tracing
-     *            the execution of this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the entry was successfully removed.
-     *         Otherwise the future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException}.
-     * @throws NullPointerException if device id or adapter instance id is {@code null}.
-     */
-    Future<Void> removeCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);
-
-    /**
-     * Gets information about the adapter instances that can handle a command for the given device.
-     * <p>
-     * See Hono's <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
-     * specification</a> for a detailed description of the method's behaviour and the returned JSON object.
-     * <p>
-     * If no adapter instances are found, the returned future is failed.
-     *
-     * @param deviceId The device id.
-     * @param viaGateways The list of gateways that may act on behalf of the given device.
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *            Implementing classes should use this as the parent for any span they create for tracing the execution
-     *            of this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         If instances were found, the future will be succeeded with a JSON object containing one or more mappings
-     *         from device id to adapter instance id. Otherwise the future will be failed with a
-     *         {@link org.eclipse.hono.client.ServiceInvocationException}.
-     * @throws NullPointerException if any of the parameters except context is {@code null}.
-     */
-    Future<JsonObject> getCommandHandlingAdapterInstances(String deviceId, List<String> viaGateways, SpanContext context);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java
deleted file mode 100644
index c4f779340..000000000
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.client.impl.DeviceConnectionClientFactoryImpl;
-
-/**
- * A factory for creating clients for Hono's Device Connection API.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.DeviceConnectionClient} instead.
- */
-@Deprecated
-public interface DeviceConnectionClientFactory extends BasicDeviceConnectionClientFactory, ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param samplerFactory The sampler factory to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static DeviceConnectionClientFactory create(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        return new DeviceConnectionClientFactoryImpl(connection, samplerFactory);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java
deleted file mode 100644
index 4a0bdb63d..000000000
--- a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-
-/**
- * Represents the device specific command consumer used in protocol adapters.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.CommandConsumer} instead.
- */
-@Deprecated
-public interface ProtocolAdapterCommandConsumer {
-
-    /**
-     * Closes the consumer.
-     *
-     * @param spanContext The span context (may be {@code null}).
-     * @return A future indicating the outcome of the operation. The future will be failed with a
-     *         {@link ServiceInvocationException} if there was an error closing the consumer and with a
-     *         {@link ClientErrorException} with {@link java.net.HttpURLConnection#HTTP_PRECON_FAILED} if the consumer
-     *         was found to have been closed/overwritten already.
-     */
-    Future<Void> close(SpanContext spanContext);
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
deleted file mode 100644
index 800c185fd..000000000
--- a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import java.time.Duration;
-import java.util.Objects;
-
-import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-
-/**
- * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to
- * receive commands and send responses.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.amqp.ProtonBasedDelegatingCommandConsumerFactory} instead.
- */
-@Deprecated
-public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * A service for setting and clearing information mapping protocol adapter instances to devices.
-     */
-    interface CommandHandlingAdapterInfoAccess {
-
-        /**
-         * Sets the protocol adapter instance that handles commands for the given device.
-         *
-         * @param tenant The tenant that the device belongs to.
-         * @param deviceId The device id.
-         * @param adapterInstanceId The protocol adapter instance id.
-         * @param lifespan The lifespan of the mapping entry. Using a negative duration or {@code null} here is
-         *                 interpreted as an unlimited lifespan. Only the number of seconds in the given duration
-         *                 will be taken into account.
-         * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-         *            An implementation should use this as the parent for any span it creates for tracing
-         *            the execution of this operation.
-         * @return A future indicating whether the operation succeeded or not.
-         * @throws NullPointerException if tenant, device id or adapter instance id are {@code null}.
-         */
-        Future<Void> setCommandHandlingAdapterInstance(
-                String tenant,
-                String deviceId,
-                String adapterInstanceId,
-                Duration lifespan,
-                SpanContext context);
-
-        /**
-         * Removes the mapping information that associates the given device with the given protocol adapter instance
-         * that handles commands for the given device. The mapping entry is only deleted if its value
-         * contains the given protocol adapter instance id.
-         *
-         * @param tenant The tenant that the device belongs to.
-         * @param deviceId The device id.
-         * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.
-         * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-         *            An implementation should use this as the parent for any span it creates for tracing
-         *            the execution of this operation.
-         * @return A future indicating the outcome of the operation.
-         *         <p>
-         *         The future will be succeeded if the entry was successfully removed.
-         *         Otherwise the future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException}.
-         * @throws NullPointerException if tenant, device id or adapter instance id are {@code null}.
-         */
-        Future<Void> removeCommandHandlingAdapterInstance(
-                String tenant,
-                String deviceId,
-                String adapterInstanceId,
-                SpanContext context);
-    }
-
-    /**
-     * Creates an accessor for a Device Connection service client factory.
-     *
-     * @param factory The factory.
-     * @return The accessor.
-     * @throws NullPointerException if the factory is {@code null}.
-     */
-    static CommandHandlingAdapterInfoAccess createCommandHandlingAdapterInfoAccess(
-            final BasicDeviceConnectionClientFactory factory) {
-
-        Objects.requireNonNull(factory);
-
-        return new CommandHandlingAdapterInfoAccess() {
-
-            @Override
-            public Future<Void> setCommandHandlingAdapterInstance(
-                    final String tenant,
-                    final String deviceId,
-                    final String adapterInstanceId,
-                    final Duration lifespan,
-                    final SpanContext context) {
-                return factory.getOrCreateDeviceConnectionClient(tenant)
-                        .compose(client -> client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, lifespan, context));
-            }
-
-            @Override
-            public Future<Void> removeCommandHandlingAdapterInstance(
-                    final String tenant,
-                    final String deviceId,
-                    final String adapterInstanceId,
-                    final SpanContext context) {
-                return factory.getOrCreateDeviceConnectionClient(tenant)
-                        .compose(client -> client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, context));
-            }
-        };
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to the AMQP network.
-     * @return The factory.
-     * @throws NullPointerException if connection or gatewayMapper is {@code null}.
-     */
-    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection) {
-        return create(connection, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to the AMQP network.
-     * @param samplerFactory The sampler factory to use.
-     * @return The factory.
-     * @throws NullPointerException if connection or gatewayMapper is {@code null}.
-     */
-    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, samplerFactory);
-    }
-
-    /**
-     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.
-     *
-     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and
-     *            protocol adapter instance that can handle it. Note that no initialization of this component will be done
-     *            here, that is supposed to be done by the calling method.
-     * @param commandHandlingAdapterInfoAccess The component for setting and clearing information mapping protocol
-     *                                         adapter instances to devices.
-     */
-    void initialize(
-            CommandTargetMapper commandTargetMapper,
-            CommandHandlingAdapterInfoAccess commandHandlingAdapterInfoAccess);
-
-    /**
-     * Creates a command consumer for a device.
-     * <p>
-     * For each device only one command consumer may be active at any given time. Invoking this method multiple times
-     * with the same parameters will each time overwrite the previous entry.
-     * <p>
-     * It is the responsibility of the calling code to properly close a consumer
-     * once it is no longer needed by invoking its {@link ProtocolAdapterCommandConsumer#close(SpanContext)}
-     * method.
-     * <p>
-     * Note that {@link #initialize(CommandTargetMapper, CommandHandlingAdapterInfoAccess)} has to have been called
-     * already, otherwise a failed future is returned.
-     *
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
-     *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
-     *                       message transfer and finish the trace span associated with the {@link CommandContext}.
-     * @param lifespan The time period in which the command consumer shall be active. Using a negative duration or
-     *                 {@code null} here is interpreted as an unlimited lifespan. The guaranteed granularity
-     *                 taken into account here is seconds.
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *                An implementation should use this as the parent for any span it creates for tracing
-     *                the execution of this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be completed with the newly created consumer once the link
-     *         has been established.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating
-     *         the cause of the failure.
-     * @throws NullPointerException if any of tenant, device ID or command handler is {@code null}.
-     */
-    Future<ProtocolAdapterCommandConsumer> createCommandConsumer(
-            String tenantId,
-            String deviceId,
-            Handler<CommandContext> commandHandler,
-            Duration lifespan,
-            SpanContext context);
-
-    /**
-     * Creates a command consumer for a device that is connected via a gateway.
-     * <p>
-     * For each device only one command consumer may be active at any given time. Invoking this method multiple times
-     * with the same parameters will each time overwrite the previous entry.
-     * <p>
-     * It is the responsibility of the calling code to properly close a consumer
-     * once it is no longer needed by invoking its {@link ProtocolAdapterCommandConsumer#close(SpanContext)}
-     * method.
-     * <p>
-     * Note that {@link #initialize(CommandTargetMapper, CommandHandlingAdapterInfoAccess)} has to have been called
-     * already, otherwise a failed future is returned.
-     *
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @param gatewayId The gateway that wants to act on behalf of the device.
-     * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
-     *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
-     *                       message transfer and finish the trace span associated with the {@link CommandContext}.
-     * @param lifespan The time period in which the command consumer shall be active. Using a negative duration or
-     *                 {@code null} here is interpreted as an unlimited lifespan. The guaranteed granularity
-     *                 taken into account here is seconds.
-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
-     *                An implementation should use this as the parent for any span it creates for tracing
-     *                the execution of this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be completed with the newly created consumer once the link
-     *         has been established.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating
-     *         the cause of the failure.
-     * @throws NullPointerException if any of tenant, device ID, gateway ID or command handler is {@code null}.
-     */
-    Future<ProtocolAdapterCommandConsumer> createCommandConsumer(
-            String tenantId,
-            String deviceId,
-            String gatewayId,
-            Handler<CommandContext> commandHandler,
-            Duration lifespan,
-            SpanContext context);
-
-    /**
-     * Gets a sender for sending command responses to a business application.
-     * <p>
-     * It is the responsibility of the calling code to properly close the
-     * link by invoking {@link CommandResponseSender#close(Handler)}
-     * once the sender is no longer needed anymore.
-     *
-     * @param tenantId The ID of the tenant to send the command responses for.
-     * @param replyId The ID used to build the reply address as {@code command_response/tenantId/replyId}.
-     * @return A future that will complete with the sender once the link has been established.
-     *         The future will be failed with a {@link ServiceInvocationException} if
-     *         the link cannot be established, e.g. because this client is not connected.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    Future<CommandResponseSender> getCommandResponseSender(String tenantId, String replyId);
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
deleted file mode 100644
index 006740068..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.auth.Device;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.HonoProtonHelper;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-
-/**
- * Handler for commands received at the protocol adapter instance specific address.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.amqp.ProtonBasedInternalCommandConsumer} instead.
- */
-@Deprecated
-public final class AdapterInstanceCommandHandler {
-
-    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);
-
-    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();
-    private final Tracer tracer;
-    private final String adapterInstanceId;
-
-    /**
-     * Creates a new AdapterInstanceCommandHandler instance.
-     *
-     * @param tracer The tracer instance.
-     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public AdapterInstanceCommandHandler(final Tracer tracer, final String adapterInstanceId) {
-        this.tracer = Objects.requireNonNull(tracer);
-        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);
-    }
-
-    /**
-     * Handles a received command message.
-     *
-     * @param msg The command message.
-     * @param delivery The delivery.
-     * @throws NullPointerException If msg or delivery is {@code null}.
-     */
-    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {
-        Objects.requireNonNull(msg);
-        Objects.requireNonNull(delivery);
-        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case
-        final ResourceIdentifier resourceIdentifier = ResourceIdentifier.isValid(msg.getAddress())
-                ? ResourceIdentifier.fromString(msg.getAddress())
-                : null;
-        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {
-            LOG.debug("address of command message is invalid: {}", msg.getAddress());
-            final Rejected rejected = new Rejected();
-            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "invalid command target address"));
-            delivery.disposition(rejected, true);
-            return;
-        }
-        final String tenantId = resourceIdentifier.getTenantId();
-        final String originalDeviceId = resourceIdentifier.getResourceId();
-        // fetch "via" property (if set)
-        final String gatewayIdFromMessage = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);
-        final String targetDeviceId = gatewayIdFromMessage != null ? gatewayIdFromMessage : originalDeviceId;
-        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, targetDeviceId);
-
-        // Adopt gateway id from command handler if set;
-        // for that kind of command handler (gateway subscribing for specific device commands), the
-        // gateway information is not stored in the device connection service ("deviceConnectionService.setCommandHandlingAdapterInstance()" doesn't have an extra gateway id parameter);
-        // and therefore not set in the delegated command message
-        final String gatewayId = commandHandler != null && commandHandler.getGatewayId() != null
-                ? commandHandler.getGatewayId()
-                : gatewayIdFromMessage;
-
-        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);
-
-        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);
-        final Span currentSpan = CommandConsumer.createSpan("handle command", tenantId, originalDeviceId,
-                gatewayId, tracer, spanContext);
-        currentSpan.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
-        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);
-
-        if (commandHandler != null) {
-            HonoProtonHelper.onReceivedMessageDeliveryUpdatedFromRemote(delivery, d -> {
-                LOG.debug("got unexpected disposition update for received command message [remote state: {}, {}]", delivery.getRemoteState(), command);
-                currentSpan.log("got unexpected disposition update for received command message [remote state: " + delivery.getRemoteState() + "]");
-            });
-            LOG.trace("using [{}] for received command [{}]", commandHandler, command);
-            // command.isValid() check not done here - it is to be done in the command handler
-            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));
-        } else {
-            LOG.info("no command handler found for command with device id {}, gateway id {} [tenant-id: {}]",
-                    originalDeviceId, gatewayId, tenantId);
-            TracingHelper.logError(currentSpan, "no command handler found for command");
-            currentSpan.finish();
-            ProtonHelper.released(delivery, true);
-        }
-    }
-
-    /**
-     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
-     *
-     * @param tenantId The tenant id.
-     * @param deviceId The identifier of the device or gateway that is the target of the commands being handled.
-     * @param gatewayId The identifier of the gateway in case the handler gets added as part of the gateway
-     *                  subscribing specifically for commands of the given device, or {@code null} otherwise.
-     *                  (A gateway subscribing for commands of all devices, that it may act on behalf of, would mean
-     *                  using a {@code null} value here and providing the gateway id in the <em>deviceId</em>
-     *                  parameter.)
-     * @param commandHandler The command handler. The handler must invoke one of the terminal methods of the passed
-     *                       in {@link CommandContext} in order to settle the command message transfer and finish
-     *                       the trace span associated with the {@link CommandContext}.
-     * @return The replaced handler entry or {@code null} if there was none.
-     * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.
-     */
-    public CommandHandlerWrapper putDeviceSpecificCommandHandler(final String tenantId, final String deviceId,
-            final String gatewayId, final Handler<CommandContext> commandHandler) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(commandHandler);
-
-        return putDeviceSpecificCommandHandler(new CommandHandlerWrapper(tenantId, deviceId, gatewayId, commandHandler));
-    }
-
-    /**
-     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
-     *
-     * @param commandHandlerWrapper The wrapper containing the command handler and device/gateway identifier.
-     * @return The replaced entry or {@code null} if there was none.
-     * @throws NullPointerException If commandHandlerWrapper is {@code null}.
-     */
-    public CommandHandlerWrapper putDeviceSpecificCommandHandler(final CommandHandlerWrapper commandHandlerWrapper) {
-        Objects.requireNonNull(commandHandlerWrapper);
-
-        final String key = getDeviceKey(commandHandlerWrapper);
-        if (commandHandlers.containsKey(key)) {
-            LOG.debug("replacing existing command handler [tenant-id: {}, device-id: {}]",
-                    commandHandlerWrapper.getTenantId(), commandHandlerWrapper.getDeviceId());
-        }
-        return commandHandlers.put(key, commandHandlerWrapper);
-    }
-
-    /**
-     * Gets a handler for the given device id.
-     * <p>
-     * When providing a gateway id as <em>deviceId</em> here, the handler is returned that handles
-     * commands for all devices that the gateway may act on behalf of, if such a handler was set before.
-     *
-     * @param tenantId The tenant id.
-     * @param deviceId The device id to get the handler for.
-     * @return The handler or {@code null}.
-     * @throws NullPointerException If tenantId or deviceId is {@code null}.
-     */
-    public CommandHandlerWrapper getDeviceSpecificCommandHandler(final String tenantId, final String deviceId) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        return commandHandlers.get(getDeviceKey(tenantId, deviceId));
-    }
-
-    /**
-     * Gets the contained command handlers.
-     *
-     * @return The command handlers.
-     */
-    public Collection<CommandHandlerWrapper> getDeviceSpecificCommandHandlers() {
-        return commandHandlers.values();
-    }
-
-    /**
-     * Removes the handler for the given device id.
-     *
-     * @param tenantId The tenant id of the handler to remove.
-     * @param deviceId The device id of the handler to remove.
-     * @return {@code true} if the handler was removed.
-     * @throws NullPointerException If tenantId or deviceId is {@code null}.
-     */
-    public boolean removeDeviceSpecificCommandHandler(final String tenantId, final String deviceId) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        final CommandHandlerWrapper removedHandler = commandHandlers.remove(getDeviceKey(tenantId, deviceId));
-        LOG.trace("Removed handler for tenant {}, device {}: {}", tenantId, deviceId, removedHandler != null);
-        return removedHandler != null;
-    }
-
-    /**
-     * Removes the given handler.
-     *
-     * @param commandHandlerWrapper The handler to remove.
-     * @return {@code true} if the handler was removed.
-     * @throws NullPointerException If commandHandlerWrapper is {@code null}.
-     */
-    public boolean removeDeviceSpecificCommandHandler(final CommandHandlerWrapper commandHandlerWrapper) {
-        Objects.requireNonNull(commandHandlerWrapper);
-        final boolean removed = commandHandlers.remove(getDeviceKey(commandHandlerWrapper), commandHandlerWrapper);
-        LOG.trace("Removed {}: {}", commandHandlerWrapper, removed);
-        return removed;
-    }
-
-    private String getDeviceKey(final CommandHandlerWrapper commandHandlerWrapper) {
-        return getDeviceKey(commandHandlerWrapper.getTenantId(), commandHandlerWrapper.getDeviceId());
-    }
-
-    private String getDeviceKey(final String tenantId, final String deviceId) {
-        return Device.asAddress(tenantId, deviceId);
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
deleted file mode 100644
index 4485ce964..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.client.CommandContext;
-
-import io.vertx.core.Handler;
-
-/**
- * Wraps a command handler to be used in a command consumer.
- */
-public final class CommandHandlerWrapper {
-
-    private final String tenantId;
-    private final String deviceId;
-    private final String gatewayId;
-    private final Handler<CommandContext> commandHandler;
-
-    /**
-     * Creates a new CommandHandlerWrapper.
-     *
-     * @param tenantId The tenant id.
-     * @param deviceId The identifier of the device or gateway that is the target of the commands being handled.
-     * @param gatewayId The identifier of the gateway in case the handler is used as part of the gateway
-     *                  subscribing specifically for commands for the given device, or {@code null} otherwise.
-     *                  (A gateway subscribing for commands for all devices, that it may act on behalf of, would mean
-     *                  using a {@code null} value here and providing the gateway id in the <em>deviceId</em>
-     *                  parameter.)
-     * @param commandHandler The command handler.
-     * @throws NullPointerException If tenantId, deviceId or commandHandler is {@code null}.
-     */
-    public CommandHandlerWrapper(final String tenantId, final String deviceId, final String gatewayId,
-                                 final Handler<CommandContext> commandHandler) {
-        this.tenantId = Objects.requireNonNull(tenantId);
-        this.deviceId = Objects.requireNonNull(deviceId);
-        this.gatewayId = gatewayId;
-        this.commandHandler = Objects.requireNonNull(commandHandler);
-    }
-
-    /**
-     * Gets the tenant identifier.
-     *
-     * @return The identifier.
-     */
-    public String getTenantId() {
-        return tenantId;
-    }
-
-    /**
-     * Gets the identifier of the device or gateway to handle commands for.
-     *
-     * @return The identifier.
-     */
-    public String getDeviceId() {
-        return deviceId;
-    }
-
-    /**
-     * Gets the identifier of the gateway in case the handler is used by a gateway having specifically subscribed for
-     * commands for the device returned by {@link #getDeviceId()}.
-     *
-     * @return The identifier or {@code null}.
-     */
-    public String getGatewayId() {
-        return gatewayId;
-    }
-
-    /**
-     * Invokes the command handler with the given command context.
-     *
-     * @param commandContext The command context to pass on to the command handler.
-     */
-    public void handleCommand(final CommandContext commandContext) {
-        commandHandler.handle(commandContext);
-    }
-
-    @Override
-    public String toString() {
-        return "CommandHandlerWrapper{" +
-                "tenantId='" + tenantId + '\'' +
-                ", deviceId='" + deviceId + '\'' +
-                (gatewayId != null ? (", gatewayId='" + gatewayId + '\'') : "") +
-                '}';
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
deleted file mode 100644
index a1708324f..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.List;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import org.eclipse.hono.client.CommandTargetMapper;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-
-/**
- * A component for mapping an incoming command to the gateway (if applicable)
- * and protocol adapter instance that can handle it.
- */
-public class CommandTargetMapperImpl implements CommandTargetMapper {
-
-    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);
-
-    private final Tracer tracer;
-    private final AtomicBoolean initialized = new AtomicBoolean(false);
-    private CommandTargetMapperContext mapperContext;
-
-    /**
-     * Creates a new GatewayMapperImpl instance.
-     *
-     * @param tracer The tracer instance.
-     * @throws NullPointerException if tracer is {@code null}.
-     */
-    public CommandTargetMapperImpl(final Tracer tracer) {
-        this.tracer = Objects.requireNonNull(tracer);
-    }
-
-    @Override
-    public void initialize(final CommandTargetMapperContext context) {
-        this.mapperContext = Objects.requireNonNull(context);
-        initialized.set(true);
-    }
-
-    @Override
-    public final Future<JsonObject> getTargetGatewayAndAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {
-        if (!initialized.get()) {
-            LOG.error("not initialized");
-            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
-        }
-        final Span span = TracingHelper
-                .buildChildSpan(tracer, context, "get target gateway and adapter instance",
-                        CommandTargetMapper.class.getSimpleName())
-                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)
-                .withTag(TracingHelper.TAG_TENANT_ID, tenantId)
-                .withTag(TracingHelper.TAG_DEVICE_ID, deviceId)
-                .start();
-
-        return mapperContext.getViaGateways(tenantId, deviceId, span.context())
-                .recover(t -> {
-                    LOG.debug("Error retrieving gateways authorized to act on behalf of device [tenant-id: {}, device-id: {}]",
-                            tenantId, deviceId, t);
-                    return Future.failedFuture(t);
-                }).compose(viaGateways -> {
-                    return mapperContext.getCommandHandlingAdapterInstances(tenantId, deviceId, viaGateways, span.context())
-                            .compose(resultJson -> determineTargetInstanceJson(resultJson, deviceId, viaGateways, span));
-                }).map(result -> {
-                    span.finish();
-                    return result;
-                }).recover(t -> {
-                    LOG.debug("Error getting target gateway and adapter instance", t);
-                    TracingHelper.logError(span, t);
-                    Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(t));
-                    span.finish();
-                    return Future.failedFuture(t);
-                });
-    }
-
-    private Future<JsonObject> determineTargetInstanceJson(final JsonObject adapterInstancesJson, final String deviceId,
-            final List<String> viaGateways, final Span span) {
-        final JsonArray instancesArray = adapterInstancesJson.getJsonArray(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);
-        if (instancesArray == null || instancesArray.isEmpty()) {
-            return createAndLogInternalServerErrorFuture(span, "Invalid result JSON; field '"
-                    + DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES + "' is null or empty");
-        }
-
-        final JsonObject targetInstanceObject;
-        try {
-            if (instancesArray.size() == 1) {
-                targetInstanceObject = instancesArray.getJsonObject(0);
-            } else {
-                targetInstanceObject = chooseTargetGatewayAndAdapterInstance(instancesArray);
-            }
-        } catch (final ClassCastException e) {
-            return createAndLogInternalServerErrorFuture(span, "Invalid result JSON: " + e);
-        }
-        final String targetDevice = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);
-        final String targetAdapterInstance = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);
-        if (targetDevice == null || targetAdapterInstance == null) {
-            return createAndLogInternalServerErrorFuture(span, "Invalid result JSON, missing target device and/or adapter instance");
-        }
-        if (!targetDevice.equals(deviceId)) {
-            // target device is a gateway
-            if (!viaGateways.contains(targetDevice)) {
-                return createAndLogInternalServerErrorFuture(span,
-                        "Invalid result JSON, target gateway " + targetDevice + " is not in via gateways list");
-            }
-            span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, targetDevice);
-        }
-
-        final String choiceInfo = instancesArray.size() > 1 ? " chosen from " + instancesArray.size() + " entries" : "";
-        final String gatewayInfo = !targetDevice.equals(deviceId) ? " gateway '" + targetDevice + "' and" : "";
-        final String infoMsg = String.format("command target%s:%s adapter instance '%s'", choiceInfo, gatewayInfo, targetAdapterInstance);
-        LOG.debug(infoMsg);
-        span.log(infoMsg);
-
-        span.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, targetAdapterInstance);
-        return Future.succeededFuture(targetInstanceObject);
-    }
-
-    private Future<JsonObject> createAndLogInternalServerErrorFuture(final Span span, final String errorMessage) {
-        LOG.error(errorMessage);
-        TracingHelper.logError(span, errorMessage);
-        return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
-    }
-
-    /**
-     * Chooses the target gateway and adapter instance from the given list of entries.
-     * <p>
-     * This method returns first entry from the given list.
-     * <p>
-     * Subclasses may override this method in order to apply a different algorithm.
-     *
-     * @param instancesArray The JSON array containing the target gateway and adapter instance entries to choose from.
-     * @return The chosen JSON object.
-     */
-    protected JsonObject chooseTargetGatewayAndAdapterInstance(final JsonArray instancesArray) {
-        return instancesArray.getJsonObject(0);
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
deleted file mode 100644
index 5579b87a9..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
+++ /dev/null
@@ -1,256 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.DelegatedCommandSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.MessageHelper;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based sender to send command messages to the downstream peer as part of delegating them to be
- * processed by another command consumer.
- */
-public class DelegatedCommandSenderImpl extends AbstractSender implements DelegatedCommandSender {
-
-    DelegatedCommandSenderImpl(
-            final HonoConnection connection,
-            final ProtonSender sender,
-            final SendMessageSampler sampler) {
-
-        super(connection, sender, "", "", sampler);
-    }
-
-    @Override
-    protected String getTo(final String deviceId) {
-        return null;
-    }
-
-    @Override
-    public String getEndpoint() {
-        return CommandConstants.INTERNAL_COMMAND_ENDPOINT;
-    }
-
-    @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
-        return runSendAndWaitForOutcomeOnContext(message, currentSpan);
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
-        return sendAndWaitForOutcome(message, null);
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message rawMessage, final SpanContext parent) {
-        Objects.requireNonNull(rawMessage);
-
-        final Span span = startSpan(parent, rawMessage);
-        TracingHelper.injectSpanContext(connection.getTracer(), span.context(), rawMessage);
-
-        return runSendAndWaitForOutcomeOnContext(rawMessage, span);
-    }
-
-    private Future<ProtonDelivery> runSendAndWaitForOutcomeOnContext(final Message rawMessage, final Span span) {
-        return connection.executeOnContext(result -> {
-            if (sender.sendQueueFull()) {
-                final ServiceInvocationException e = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available");
-                logMessageSendingError("error sending message [ID: {}, address: {}], no credit available (drain={})",
-                        rawMessage.getMessageId(), getMessageAddress(rawMessage), sender.getDrain());
-                TracingHelper.TAG_CREDIT.set(span, 0);
-                logError(span, e);
-                span.finish();
-                result.fail(e);
-            } else {
-                sendMessageAndWaitForOutcome(rawMessage, span).onComplete(result);
-            }
-        });
-    }
-
-    /**
-     * Sends an AMQP 1.0 message to the peer this client is configured for and waits for the outcome of the transfer.
-     * <p>
-     * This method overrides the base implementation to also return a succeeded Future if a delivery update other than
-     * <em>Accepted</em> was received. And in contrast to the base implementation it doesn't set a new message id on
-     * the given message.
-     *
-     * @param message The message to send.
-     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
-     *              The span will be finished by this method and will contain an error log if
-     *              the message has not been accepted by the peer.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been accepted (and settled)
-     *         by the consumer.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or if no delivery update
-     *         was received from the peer within the configured timeout period
-     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
-     * @throws NullPointerException if either of the parameters is {@code null}.
-     */
-    @Override
-    protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message, final Span currentSpan) {
-
-        Objects.requireNonNull(message);
-        Objects.requireNonNull(currentSpan);
-
-        final AtomicReference<ProtonDelivery> deliveryRef = new AtomicReference<>();
-        final Promise<ProtonDelivery> result = Promise.promise();
-        final String messageId = message.getMessageId() != null ? message.getMessageId().toString() : "";
-        logMessageIdAndSenderInfo(currentSpan, messageId);
-
-        final SendMessageSampler.Sample sample = this.sampler.start(this.tenantId);
-
-        final ClientConfigProperties config = connection.getConfig();
-        final Long timerId = config.getSendMessageTimeout() > 0
-                ? connection.getVertx().setTimer(config.getSendMessageTimeout(), id -> {
-                    if (!result.future().isComplete()) {
-                        handleSendMessageTimeout(message, config.getSendMessageTimeout(), deliveryRef.get(), sample,
-                                result, null);
-                    }
-                })
-                : null;
-
-        deliveryRef.set(sender.send(message, deliveryUpdated -> {
-            if (timerId != null) {
-                connection.getVertx().cancelTimer(timerId);
-            }
-            final DeliveryState remoteState = deliveryUpdated.getRemoteState();
-            sample.completed(remoteState);
-            if (result.future().isComplete()) {
-                log.debug("ignoring received delivery update for message [ID: {}, address: {}]: waiting for the update has already timed out",
-                        messageId, getMessageAddress(message));
-            } else if (deliveryUpdated.remotelySettled()) {
-                logUpdatedDeliveryState(currentSpan, message, deliveryUpdated);
-                result.complete(deliveryUpdated);
-            } else {
-                logMessageSendingError("peer did not settle message [ID: {}, address: {}, remote state: {}], failing delivery",
-                        messageId, getMessageAddress(message), remoteState.getClass().getSimpleName());
-                final ServiceInvocationException e = new ServerErrorException(
-                        HttpURLConnection.HTTP_INTERNAL_ERROR,
-                        "peer did not settle message, failing delivery");
-                result.fail(e);
-            }
-        }));
-        log.trace("sent message [ID: {}, address: {}], remaining credit: {}, queued messages: {}", messageId,
-                getMessageAddress(message), sender.getCredit(), sender.getQueued());
-
-        return result.future()
-                .map(delivery -> {
-                    Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-                    currentSpan.finish();
-                    return delivery;
-                }).recover(t -> {
-                    TracingHelper.logError(currentSpan, t);
-                    Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(t));
-                    currentSpan.finish();
-                    return Future.failedFuture(t);
-                });
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendCommandMessage(final Command command, final SpanContext spanContext) {
-        Objects.requireNonNull(command);
-        final String replyToAddress = command.isOneWay() ? null
-                : String.format("%s/%s/%s", command.getReplyToEndpoint(), command.getTenant(), command.getReplyToId());
-        final Message delegatedCommandMessage = createDelegatedCommandMessage(command.getCommandMessage(), replyToAddress);
-        final Span span = startSpan(spanContext, delegatedCommandMessage);
-        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, command.getTenant());
-        if (command.isTargetedAtGateway()) {
-            MessageHelper.addProperty(delegatedCommandMessage, MessageHelper.APP_PROPERTY_CMD_VIA, command.getDeviceId());
-            TracingHelper.TAG_DEVICE_ID.set(span, command.getOriginalDeviceId());
-            TracingHelper.TAG_GATEWAY_ID.set(span, command.getDeviceId());
-        } else {
-            TracingHelper.TAG_DEVICE_ID.set(span, command.getDeviceId());
-        }
-        TracingHelper.injectSpanContext(connection.getTracer(), span.context(), delegatedCommandMessage);
-
-        return runSendAndWaitForOutcomeOnContext(delegatedCommandMessage, span);
-    }
-
-    /**
-     * Gets the AMQP <em>target</em> address to use for sending the delegated command messages to.
-     *
-     * @param adapterInstanceId The protocol adapter instance id.
-     * @return The target address.
-     * @throws NullPointerException if adapterInstanceId is {@code null}.
-     */
-    static String getTargetAddress(final String adapterInstanceId) {
-        return CommandConstants.INTERNAL_COMMAND_ENDPOINT + "/" + Objects.requireNonNull(adapterInstanceId);
-    }
-
-    private static Message createDelegatedCommandMessage(final Message originalMessage, final String replyToAddress) {
-        Objects.requireNonNull(originalMessage);
-        // copy original message
-        final Message msg = MessageHelper.getShallowCopy(originalMessage);
-        msg.setReplyTo(replyToAddress);
-        return msg;
-    }
-
-    /**
-     * Creates a new sender for sending the delegated command messages to the AMQP network.
-     *
-     * @param con The connection to the AMQP network.
-     * @param adapterInstanceId The protocol adapter instance id.
-     * @param sampler The sampler to use.
-     * @param remoteCloseHook A handler to invoke if the peer closes the link unexpectedly (may be {@code null}).
-     * @return A future indicating the result of the creation attempt.
-     * @throws NullPointerException if any of the parameters except remoteCloseHook is {@code null}.
-     */
-    public static Future<DelegatedCommandSender> create(
-            final HonoConnection con,
-            final String adapterInstanceId,
-            final SendMessageSampler sampler,
-            final Handler<String> remoteCloseHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(adapterInstanceId);
-        Objects.requireNonNull(sampler);
-
-        final String targetAddress = getTargetAddress(adapterInstanceId);
-        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
-                .map(sender -> new DelegatedCommandSenderImpl(con, sender, sampler));
-    }
-
-    @Override
-    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
-
-        final Span span = newChildSpan(parent, "delegate Command request");
-        Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_CLIENT);
-        return span;
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java
deleted file mode 100644
index ac944d7f3..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.DeviceConnectionClientFactory;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.eventbus.Message;
-
-
-/**
- * A factory for creating clients for the Hono APIs required
- * by protocol adapters.
- *
- */
-public class DeviceConnectionClientFactoryImpl extends AbstractHonoClientFactory implements DeviceConnectionClientFactory {
-
-    private final CachingClientFactory<DeviceConnectionClient> deviceConnectionClientFactory;
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param samplerFactory The sampler factory to use.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    public DeviceConnectionClientFactoryImpl(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-        this.deviceConnectionClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());
-        connection.getVertx().eventBus().consumer(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT,
-                this::handleTenantTimeout);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onDisconnect() {
-        deviceConnectionClientFactory.clearState();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<DeviceConnectionClient> getOrCreateDeviceConnectionClient(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-        return connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    deviceConnectionClientFactory.getOrCreateClient(
-                            DeviceConnectionClientImpl.getTargetAddress(tenantId),
-                            () -> DeviceConnectionClientImpl.create(
-                                    connection,
-                                    tenantId,
-                                    samplerFactory.create(DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT),
-                                    this::removeDeviceConnectionClient,
-                                    this::removeDeviceConnectionClient),
-                            result);
-                }));
-    }
-
-    private void removeDeviceConnectionClient(final String tenantId) {
-        deviceConnectionClientFactory.removeClient(DeviceConnectionClientImpl.getTargetAddress(tenantId));
-    }
-
-    private void handleTenantTimeout(final Message<String> msg) {
-        final String address = DeviceConnectionClientImpl.getTargetAddress(msg.body());
-        final DeviceConnectionClient client = deviceConnectionClientFactory.getClient(address);
-        if (client != null) {
-            client.close(v -> deviceConnectionClientFactory.removeClient(address));
-        }
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
deleted file mode 100644
index 2b34d6b85..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
+++ /dev/null
@@ -1,353 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.UUID;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.DeviceConnectionResult;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RequestResponseApiConstants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.core.json.DecodeException;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for Hono's Device Connection API.
- *
- */
-public class DeviceConnectionClientImpl extends AbstractRequestResponseClient<DeviceConnectionResult> implements DeviceConnectionClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(DeviceConnectionClientImpl.class);
-
-    /**
-     * Creates a new client for accessing the Device Connection service.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to the Device Connection service.
-     * @param tenantId The identifier of the tenant for which the client should be created.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected DeviceConnectionClientImpl(final HonoConnection connection, final String tenantId, final SendMessageSampler sampler) {
-        super(connection, Objects.requireNonNull(tenantId), sampler);
-    }
-
-    /**
-     * Creates a new client for accessing the Device Connection service.
-     *
-     * @param connection The connection to the Device Connection service.
-     * @param tenantId The identifier of the tenant for which the client should be created.
-     * @param sender The AMQP link to use for sending requests to the service.
-     * @param receiver The AMQP link to use for receiving responses from the service.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected DeviceConnectionClientImpl(
-            final HonoConnection connection,
-            final String tenantId,
-            final ProtonSender sender,
-            final ProtonReceiver receiver,
-            final SendMessageSampler sampler) {
-
-        super(connection, Objects.requireNonNull(tenantId), sender, receiver, sampler);
-    }
-
-    /**
-     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Device Connection API endpoint.
-     *
-     * @param tenantId The tenant to upload data for.
-     * @return The target address.
-     * @throws NullPointerException if tenant is {@code null}.
-     */
-    public static final String getTargetAddress(final String tenantId) {
-        return String.format("%s/%s", DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT, Objects.requireNonNull(tenantId));
-    }
-
-    @Override
-    protected final String getName() {
-
-        return DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT;
-    }
-
-    @Override
-    protected final String createMessageId() {
-
-        return String.format("devcon-client-%s", UUID.randomUUID());
-    }
-
-    @Override
-    protected final DeviceConnectionResult getResult(
-            final int status,
-            final String contentType,
-            final Buffer payload,
-            final CacheDirective cacheDirective,
-            final ApplicationProperties applicationProperties) {
-
-        if (payload == null) {
-            return DeviceConnectionResult.from(status, null, null, applicationProperties);
-        } else {
-            try {
-                // ignoring given cacheDirective param here - device connection results shall not be cached
-                return DeviceConnectionResult.from(status, new JsonObject(payload), CacheDirective.noCacheDirective(), applicationProperties);
-            } catch (final DecodeException e) {
-                LOG.warn("received malformed payload from Device Connection service", e);
-                return DeviceConnectionResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR, null, null, applicationProperties);
-            }
-        }
-    }
-
-    /**
-     * Creates a new device connection client for a tenant.
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consumer events for.
-     * @param sampler The sampler to use.
-     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters except for the close hooks is {@code null}.
-     */
-    public static final Future<DeviceConnectionClient> create(
-            final HonoConnection con,
-            final String tenantId,
-            final SendMessageSampler sampler,
-            final Handler<String> senderCloseHook,
-            final Handler<String> receiverCloseHook) {
-
-        LOG.debug("creating new device connection client for [{}]", tenantId);
-        final DeviceConnectionClientImpl client = new DeviceConnectionClientImpl(con, tenantId, sampler);
-        // no response cache being set on client here - device connection results shall not be cached
-        return client.createLinks(senderCloseHook, receiverCloseHook)
-                .map(ok -> {
-                    LOG.debug("successfully created device connection client for [{}]", tenantId);
-                    return (DeviceConnectionClient) client;
-                }).recover(t -> {
-                    LOG.debug("failed to create device connection client for [{}]", tenantId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-
-    private Map<String, Object> createDeviceIdProperties(final String deviceId) {
-        final Map<String, Object> properties = new HashMap<>();
-        properties.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);
-        return properties;
-    }
-
-    /**
-     * Invokes the <em>Set Last Known Gateway for Device</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/device-connection">Device Connection API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     */
-    @Override
-    public Future<Void> setLastKnownGatewayForDevice(final String deviceId, final String gatewayId, final SpanContext context) {
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(gatewayId);
-
-        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
-        properties.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);
-
-        // using FollowsFrom instead of ChildOf reference here as invoking methods usually don't depend and wait on the result of this method
-        final Span currentSpan = newFollowingSpan(context, "set last known gateway for device");
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-        currentSpan.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);
-        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
-        createAndSendRequest(
-                DeviceConnectionConstants.DeviceConnectionAction.SET_LAST_GATEWAY.getSubject(),
-                properties,
-                null,
-                null,
-                resultTracker,
-                null,
-                currentSpan);
-        return mapResultAndFinishSpan(
-                resultTracker.future(),
-                result -> {
-                    switch (result.getStatus()) {
-                    case HttpURLConnection.HTTP_NO_CONTENT:
-                        return null;
-                    default:
-                        throw StatusCodeMapper.from(result);
-                    }
-                },
-                currentSpan);
-    }
-
-    /**
-     * Invokes the <em>Get Last Known Gateway for Device</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/device-connection">Device Connection API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     */
-    @Override
-    public Future<JsonObject> getLastKnownGatewayForDevice(final String deviceId, final SpanContext context) {
-        Objects.requireNonNull(deviceId);
-        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
-
-        final Span currentSpan = newChildSpan(context, "get last known gateway for device");
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-        createAndSendRequest(
-                DeviceConnectionConstants.DeviceConnectionAction.GET_LAST_GATEWAY.getSubject(),
-                createDeviceIdProperties(deviceId),
-                null,
-                null,
-                resultTracker,
-                null,
-                currentSpan);
-        return mapResultAndFinishSpan(
-                resultTracker.future(),
-                result -> {
-                    switch (result.getStatus()) {
-                    case HttpURLConnection.HTTP_OK:
-                        return result.getPayload();
-                    default:
-                        throw StatusCodeMapper.from(result);
-                    }
-                },
-                currentSpan);
-    }
-
-    @Override
-    public Future<Void> removeCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId, final SpanContext context) {
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(adapterInstanceId);
-
-        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
-        properties.put(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
-
-        final Span currentSpan = newChildSpan(context, "remove command handling adapter instance");
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-        currentSpan.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
-        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
-        createAndSendRequest(
-                DeviceConnectionConstants.DeviceConnectionAction.REMOVE_CMD_HANDLING_ADAPTER_INSTANCE.getSubject(),
-                properties,
-                null,
-                null,
-                resultTracker,
-                null,
-                currentSpan);
-        // not using mapResultAndFinishSpan() in order to skip logging PRECON_FAILED result as error (may have been trying to remove an expired entry)
-        return resultTracker.future().recover(t -> {
-            Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(t));
-            TracingHelper.logError(currentSpan, t);
-            currentSpan.finish();
-            return Future.failedFuture(t);
-        }).map(resultValue -> {
-            Tags.HTTP_STATUS.set(currentSpan, resultValue.getStatus());
-            if (resultValue.isError() && resultValue.getStatus() != HttpURLConnection.HTTP_PRECON_FAILED) {
-                Tags.ERROR.set(currentSpan, Boolean.TRUE);
-            }
-            currentSpan.finish();
-
-            switch (resultValue.getStatus()) {
-            case HttpURLConnection.HTTP_NO_CONTENT:
-                return null;
-            default:
-                throw StatusCodeMapper.from(resultValue);
-            }
-        });
-    }
-
-    @Override
-    public Future<Void> setCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId,
-            final Duration lifespan, final SpanContext context) {
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(adapterInstanceId);
-
-        final int lifespanSeconds = lifespan != null && lifespan.getSeconds() <= Integer.MAX_VALUE ? (int) lifespan.getSeconds() : -1;
-        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
-        properties.put(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
-        properties.put(MessageHelper.APP_PROPERTY_LIFESPAN, lifespanSeconds);
-
-        final Span currentSpan = newChildSpan(context, "set command handling adapter instance");
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-        currentSpan.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
-        currentSpan.setTag(MessageHelper.APP_PROPERTY_LIFESPAN, lifespanSeconds);
-        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
-        createAndSendRequest(
-                DeviceConnectionConstants.DeviceConnectionAction.SET_CMD_HANDLING_ADAPTER_INSTANCE.getSubject(),
-                properties,
-                null,
-                null,
-                resultTracker,
-                null,
-                currentSpan);
-        return mapResultAndFinishSpan(resultTracker.future(), result -> {
-            switch (result.getStatus()) {
-                case HttpURLConnection.HTTP_NO_CONTENT:
-                    return null;
-                default:
-                    throw StatusCodeMapper.from(result);
-            }
-        }, currentSpan);
-    }
-
-    @Override
-    public Future<JsonObject> getCommandHandlingAdapterInstances(final String deviceId, final List<String> viaGateways, final SpanContext context) {
-        Objects.requireNonNull(deviceId);
-        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
-
-        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
-        final JsonObject payload = new JsonObject();
-        payload.put(DeviceConnectionConstants.FIELD_GATEWAY_IDS, new JsonArray(viaGateways));
-
-        final Span currentSpan = newChildSpan(context, "get command handling adapter instances");
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-        createAndSendRequest(
-                DeviceConnectionConstants.DeviceConnectionAction.GET_CMD_HANDLING_ADAPTER_INSTANCES.getSubject(),
-                properties,
-                payload.toBuffer(),
-                RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
-                resultTracker,
-                null,
-                currentSpan);
-        return mapResultAndFinishSpan(resultTracker.future(), result -> {
-            switch (result.getStatus()) {
-                case HttpURLConnection.HTTP_OK:
-                    return result.getPayload();
-                default:
-                    throw StatusCodeMapper.from(result);
-            }
-        }, currentSpan);
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
deleted file mode 100644
index 8c38bf540..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
+++ /dev/null
@@ -1,318 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2020, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.Objects;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.CommandTargetMapper;
-import org.eclipse.hono.client.DelegatedCommandSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * Handler for commands received at the tenant-specific address.
- */
-public class MappingAndDelegatingCommandHandler {
-
-    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandHandler.class);
-
-    /**
-     * Used for integration tests (with only a single instance of each protocol adapter):
-     * <p>
-     * System property value defining whether incoming command messages on the tenant
-     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific
-     * consumer even if there is a local handler for the command.<p>
-     * The second condition for the rerouting to take place is that the command message
-     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application
-     * property with a {@code true} value.
-     */
-    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean
-            .valueOf(System.getProperty("enableForcedCommandRerouting", "false"));
-    /**
-     * Name of the boolean command message application property with which commands are
-     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.
-     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property
-     * is set to {@code true}.
-     */
-    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = "force-command-rerouting";
-
-    private final HonoConnection connection;
-    private final CommandTargetMapper commandTargetMapper;
-    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;
-    private final String adapterInstanceId;
-    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;
-    private final SendMessageSampler sampler;
-
-    /**
-     * Creates a new MappingAndDelegatingCommandHandler instance.
-     *
-     * @param connection The connection to the AMQP network.
-     * @param commandTargetMapper The mapper component to determine the command target.
-     * @param adapterInstanceCommandHandler The handler to delegate command handling to if the command is to be
-     *                                      handled by the local adapter instance.
-     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public MappingAndDelegatingCommandHandler(
-            final HonoConnection connection,
-            final CommandTargetMapper commandTargetMapper,
-            final AdapterInstanceCommandHandler adapterInstanceCommandHandler,
-            final String adapterInstanceId,
-            final SendMessageSampler sampler) {
-        this.connection = Objects.requireNonNull(connection);
-        this.commandTargetMapper = Objects.requireNonNull(commandTargetMapper);
-        this.adapterInstanceCommandHandler = Objects.requireNonNull(adapterInstanceCommandHandler);
-        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);
-        this.sampler = sampler;
-
-        this.delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());
-        this.connection.addDisconnectListener(con -> delegatedCommandSenderFactory.clearState());
-    }
-
-    /**
-     * Delegates an incoming command to the protocol adapter instance that the target
-     * device is connected to.
-     * <p>
-     * Determines the target gateway (if applicable) and protocol adapter instance for an incoming command
-     * and delegates the command either to the local AdapterInstanceCommandHandler or to the resulting
-     * protocol adapter instance.
-     *
-     * @param tenantId The tenant that the command target must belong to.
-     * @param originalMessageDelivery The delivery of the command message.
-     * @param message The command message.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public void mapAndDelegateIncomingCommandMessage(
-            final String tenantId,
-            final ProtonDelivery originalMessageDelivery,
-            final Message message) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(originalMessageDelivery);
-        Objects.requireNonNull(message);
-
-        // this is the place where a command message on the "command/${tenant}" address arrives *first*
-        if (!ResourceIdentifier.isValid(message.getAddress())) {
-            LOG.debug("command message has no valid address");
-            final Rejected rejected = new Rejected();
-            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "missing or invalid command target address"));
-            originalMessageDelivery.disposition(rejected, true);
-            return;
-        }
-        final ResourceIdentifier targetAddress = ResourceIdentifier.fromString(message.getAddress());
-        final String deviceId = targetAddress.getResourceId();
-        if (!tenantId.equals(targetAddress.getTenantId())) {
-            LOG.debug("command message address contains invalid tenant [expected: {}, found: {}]", tenantId, targetAddress.getTenantId());
-            final Rejected rejected = new Rejected();
-            rejected.setError(new ErrorCondition(AmqpError.UNAUTHORIZED_ACCESS, "unauthorized to send command to tenant"));
-            originalMessageDelivery.disposition(rejected, true);
-            return;
-        } else if (deviceId == null) {
-            LOG.debug("invalid command message address: {}", message.getAddress());
-            final Rejected rejected = new Rejected();
-            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "invalid command target address"));
-            originalMessageDelivery.disposition(rejected, true);
-            return;
-        }
-
-        final Command command = Command.from(message, tenantId, deviceId);
-        if (command.isValid()) {
-            LOG.trace("received valid command message: [{}]", command);
-        } else {
-            LOG.debug("received invalid command message: {}", command);
-        }
-        final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);
-        final Span currentSpan = CommandConsumer.createSpan("map and delegate command", tenantId, deviceId, null,
-                connection.getTracer(), spanContext);
-        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);
-        final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);
-        mapAndDelegateIncomingCommand(tenantId, deviceId, commandContext);
-    }
-
-    private void mapAndDelegateIncomingCommand(final String tenantId, final String originalDeviceId,
-            final CommandContext originalCommandContext) {
-        // note that the command might be invalid here - a matching local handler to reject it (and report metrics) shall be found in that case
-        final Command originalCommand = originalCommandContext.getCommand();
-
-        LOG.trace("determine command target gateway/adapter for [{}]", originalCommand);
-        final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId,
-                originalDeviceId, originalCommandContext.getTracingContext());
-
-        commandTargetFuture.onComplete(commandTargetResult -> {
-            if (commandTargetResult.succeeded()) {
-                final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);
-                final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);
-
-                delegateIncomingCommand(tenantId, originalDeviceId, originalCommandContext, targetDeviceId, targetAdapterInstance);
-
-            } else {
-                if (commandTargetResult.cause() instanceof ServiceInvocationException
-                        && ((ServiceInvocationException) commandTargetResult.cause()).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-                    LOG.debug("no target adapter instance found for command for device {}", originalDeviceId);
-                    TracingHelper.logError(originalCommandContext.getTracingSpan(),
-                            "no target adapter instance found for command with device id " + originalDeviceId);
-                } else {
-                    LOG.debug("error getting target gateway and adapter instance for command with device id {}",
-                            originalDeviceId, commandTargetResult.cause());
-                    TracingHelper.logError(originalCommandContext.getTracingSpan(),
-                            "error getting target gateway and adapter instance for command with device id " + originalDeviceId,
-                            commandTargetResult.cause());
-                }
-                originalCommandContext.release();
-            }
-        });
-    }
-
-    private void delegateIncomingCommand(final String tenantId, final String originalDeviceId,
-            final CommandContext originalCommandContext, final String targetDeviceId,
-            final String targetAdapterInstance) {
-
-        // note that the command might be invalid here - a matching local handler to reject it (and report metrics) shall be found in that case
-        final Command originalCommand = originalCommandContext.getCommand();
-        final String targetGatewayId = targetDeviceId.equals(originalDeviceId) ? null : targetDeviceId;
-
-        // if command is targeted at this adapter instance, determine the command handler
-        final CommandHandlerWrapper commandHandler = adapterInstanceId.equals(targetAdapterInstance)
-                ? adapterInstanceCommandHandler.getDeviceSpecificCommandHandler(tenantId, targetDeviceId)
-                : null;
-
-        if (adapterInstanceId.equals(targetAdapterInstance) && commandHandler == null) {
-            LOG.info("local command handler not found for target {} {} [{}]",
-                    targetDeviceId.equals(originalDeviceId) ? "device" : "gateway", targetDeviceId, originalCommand);
-            TracingHelper.logError(originalCommandContext.getTracingSpan(),
-                    "local command handler not found for command; target device: " + targetDeviceId);
-            if (originalCommand.isValid()) {
-                originalCommandContext.release();
-            } else {
-                originalCommandContext.reject(getMalformedMessageError());
-            }
-        } else {
-            final boolean forcedCommandReroutingSet = isForcedCommandReroutingSet(originalCommandContext);
-            if (commandHandler != null && forcedCommandReroutingSet) { // used for integration tests
-                LOG.debug("forced command rerouting is set, skip usage of local {} for {}", commandHandler, originalCommand);
-            }
-            if (commandHandler != null && !forcedCommandReroutingSet) {
-                // Adopt gateway id from command handler if set;
-                // for that kind of command handler (gateway subscribing for specific device commands), the
-                // gateway information is not stored in the device connection service ("deviceConnectionService.setCommandHandlingAdapterInstance()" doesn't have an extra gateway id parameter);
-                // and therefore not set in the commandTargetMapper result
-                final String actualGatewayId = commandHandler.getGatewayId() != null
-                        ? commandHandler.getGatewayId()
-                        : targetGatewayId;
-                final CommandContext commandContext = originalCommand.isValid()
-                        ? adaptCommandContextToGatewayIfNeeded(originalCommandContext, actualGatewayId)
-                        : originalCommandContext;
-                LOG.trace("use local {} for {}", commandHandler, commandContext.getCommand());
-                commandHandler.handleCommand(commandContext);
-            } else if (originalCommand.isValid()) {
-                // delegate to matching consumer via downstream peer
-                final CommandContext commandContext = adaptCommandContextToGatewayIfNeeded(originalCommandContext, targetGatewayId);
-                delegateCommandMessageToAdapterInstance(targetAdapterInstance, commandContext);
-            } else {
-                // command message is invalid
-                originalCommandContext.reject(getMalformedMessageError());
-            }
-        }
-    }
-
-    private ErrorCondition getMalformedMessageError() {
-        return new ErrorCondition(Constants.AMQP_BAD_REQUEST, "malformed command message");
-    }
-
-    private CommandContext adaptCommandContextToGatewayIfNeeded(final CommandContext originalCommandContext, final String gatewayId) {
-        final Command originalCommand = originalCommandContext.getCommand();
-        final String tenantId = originalCommand.getTenant();
-        final String originalDeviceId = originalCommand.getDeviceId();
-
-        final CommandContext commandContext;
-        if (gatewayId == null) {
-            LOG.trace("command not mapped to gateway, use original device id {}", originalDeviceId);
-            commandContext = originalCommandContext;
-        } else {
-            LOG.trace("determined target gateway {} for device {}", gatewayId, originalDeviceId);
-            originalCommandContext.getTracingSpan().log("determined target gateway " + gatewayId);
-            if (!originalCommand.isOneWay()) {
-                originalCommand.getCommandMessage().setReplyTo(String.format("%s/%s/%s",
-                        CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, originalCommand.getReplyToId()));
-            }
-            final Command command = Command.from(originalCommand.getCommandMessage(), tenantId, gatewayId);
-            commandContext = CommandContext.from(command, originalCommandContext.getDelivery(),
-                    originalCommandContext.getTracingSpan());
-        }
-        return commandContext;
-    }
-
-    private void delegateCommandMessageToAdapterInstance(final String targetAdapterInstance, final CommandContext commandContext) {
-        LOG.trace("delegate command to target adapter instance '{}' [command: {}]", targetAdapterInstance, commandContext.getCommand());
-        getOrCreateDelegatedCommandSender(targetAdapterInstance)
-                .compose(sender -> sender.sendCommandMessage(commandContext.getCommand(), commandContext.getTracingContext()))
-                .onComplete(ar -> {
-                    if (ar.succeeded()) {
-                        final ProtonDelivery delegatedMsgDelivery = ar.result();
-                        LOG.trace("command [{}] sent to downstream peer; remote state of delivery: {}",
-                                commandContext.getCommand(), delegatedMsgDelivery.getRemoteState());
-                        commandContext.disposition(delegatedMsgDelivery.getRemoteState());
-                    } else {
-                        LOG.debug("failed to send command [{}] to downstream peer", commandContext.getCommand(), ar.cause());
-                        TracingHelper.logError(commandContext.getTracingSpan(),
-                                "failed to send command message to downstream peer: " + ar.cause());
-                        commandContext.release();
-                    }
-                });
-    }
-
-    private boolean isForcedCommandReroutingSet(final CommandContext commandContext) {
-        if (!FORCED_COMMAND_REROUTING_ENABLED || !commandContext.getCommand().isValid()) {
-            return false;
-        }
-        final ApplicationProperties applicationProperties = commandContext.getCommand().getCommandMessage()
-                .getApplicationProperties();
-        return Boolean.TRUE.equals(MessageHelper.getApplicationProperty(applicationProperties,
-                FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY, Boolean.class));
-    }
-
-    private Future<DelegatedCommandSender> getOrCreateDelegatedCommandSender(final String protocolAdapterInstanceId) {
-        return connection.executeOnContext(result -> {
-            delegatedCommandSenderFactory.getOrCreateClient(protocolAdapterInstanceId,
-                    () -> DelegatedCommandSenderImpl.create(connection, protocolAdapterInstanceId, sampler,
-                            onSenderClosed -> delegatedCommandSenderFactory.removeClient(protocolAdapterInstanceId)),
-                    result);
-        });
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
deleted file mode 100644
index 4aa042e91..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
+++ /dev/null
@@ -1,412 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.CommandResponseSender;
-import org.eclipse.hono.client.CommandTargetMapper;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.client.ProtocolAdapterCommandConsumer;
-import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.util.AddressHelper;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.HonoProtonHelper;
-import org.eclipse.hono.util.Strings;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.CompositeFuture;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.eventbus.Message;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to receive commands and send responses.
- * <p>
- * The factory uses two kinds of consumer links to receive commands:
- * <ul>
- * <li>A single consumer link on an address containing the protocol adapter instance id.</li>
- * <li>A tenant-scoped link, created (if not already existing for that tenant) when
- * {@link #createCommandConsumer(String, String, Handler, Duration, SpanContext)} is invoked.</li>
- * </ul>
- * <p>
- * Command messages are first received on the tenant-scoped consumer address. It is then determined whether there is
- * a consumer and corresponding command handler for the command message's target device or one of the device's
- * possible gateways. If found, that handler is either invoked directly, or, if it is on another protocol adapter
- * instance, the command message is sent to that protocol adapter instance to be handled there.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.amqp.ProtonBasedDelegatingCommandConsumerFactory} instead.
- */
-@Deprecated
-public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClientFactory implements ProtocolAdapterCommandConsumerFactory {
-
-    private static final int RECREATE_CONSUMERS_DELAY = 20;
-
-    /**
-     * Cache key used here is the tenant id.
-     */
-    private CachingClientFactory<MessageConsumer> mappingAndDelegatingCommandConsumerFactory;
-
-    /**
-     * Identifier that has to be unique to this factory instance.
-     * Will be used to represent the protocol adapter instance that this factory instance is used in,
-     * when registering command handlers with the CommandHandlingAdapterInfoAccess service.
-     */
-    private final String adapterInstanceId;
-    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;
-    private final AtomicBoolean recreatingConsumers = new AtomicBoolean(false);
-    private final AtomicBoolean tryAgainRecreatingConsumers = new AtomicBoolean(false);
-
-    private CommandHandlingAdapterInfoAccess commandHandlingAdapterInfoAccessor;
-    private MappingAndDelegatingCommandHandler mappingAndDelegatingCommandHandler;
-    private ProtonReceiver adapterSpecificConsumer;
-    private final AtomicBoolean initialized = new AtomicBoolean(false);
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to the AMQP network.
-     * @param samplerFactory The sampler factory to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public ProtocolAdapterCommandConsumerFactoryImpl(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-
-        adapterInstanceId = getAdapterInstanceId(connection.getConfig().getName());
-
-        adapterInstanceCommandHandler = new AdapterInstanceCommandHandler(connection.getTracer(), adapterInstanceId);
-    }
-
-    private static String getAdapterInstanceId(final String adapterName) {
-        // replace special characters so that the id can be used in a Kafka topic name
-        final String prefix = Strings.isNullOrEmpty(adapterName) ? ""
-                : adapterName.replaceAll("[^a-zA-Z0-9._-]", "") + "-";
-        return prefix + UUID.randomUUID();
-    }
-
-    @Override
-    public void initialize(
-            final CommandTargetMapper commandTargetMapper,
-            final CommandHandlingAdapterInfoAccess accessor) {
-
-        Objects.requireNonNull(commandTargetMapper);
-        this.commandHandlingAdapterInfoAccessor = Objects.requireNonNull(accessor);
-
-        mappingAndDelegatingCommandHandler = new MappingAndDelegatingCommandHandler(connection,
-                commandTargetMapper, adapterInstanceCommandHandler, adapterInstanceId, samplerFactory.create(CommandConstants.COMMAND_ENDPOINT));
-        mappingAndDelegatingCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> true);
-
-        connection.getVertx().eventBus().consumer(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT,
-                this::handleTenantTimeout);
-        connection.addReconnectListener(c -> recreateConsumers());
-        // trigger creation of adapter specific consumer link (with retry if failed)
-        recreateConsumers();
-        initialized.set(true);
-    }
-
-    @Override
-    protected void onDisconnect() {
-        adapterSpecificConsumer = null;
-        mappingAndDelegatingCommandConsumerFactory.clearState();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<ProtocolAdapterCommandConsumer> createCommandConsumer(final String tenantId, final String deviceId,
-            final Handler<CommandContext> commandHandler, final Duration lifespan, final SpanContext context) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(commandHandler);
-        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, lifespan, context);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<ProtocolAdapterCommandConsumer> createCommandConsumer(final String tenantId,
-            final String deviceId, final String gatewayId, final Handler<CommandContext> commandHandler,
-            final Duration lifespan, final SpanContext context) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(gatewayId);
-        Objects.requireNonNull(commandHandler);
-        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, lifespan, context);
-    }
-
-    private Future<ProtocolAdapterCommandConsumer> doCreateCommandConsumer(final String tenantId, final String deviceId,
-            final String gatewayId, final Handler<CommandContext> commandHandler, final Duration lifespan,
-            final SpanContext context) {
-        if (!initialized.get()) {
-            log.error("not initialized");
-            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
-        }
-        // lifespan greater than what can be expressed in nanoseconds (i.e. 292 years) is considered unlimited, preventing ArithmeticExceptions down the road
-        final Duration sanitizedLifespan = lifespan == null || lifespan.isNegative()
-                || lifespan.getSeconds() > (Long.MAX_VALUE / 1000_000_000L) ? Duration.ofSeconds(-1) : lifespan;
-        log.trace("create command consumer [tenant-id: {}, device-id: {}, gateway-id: {}]", tenantId, deviceId, gatewayId);
-        return connection.executeOnContext(result -> {
-            // create the tenant-scoped consumer ("command/<tenantId>") that maps/delegates incoming commands to the right handler/adapter-instance
-            getOrCreateMappingAndDelegatingCommandConsumer(tenantId)
-                    .compose(res -> {
-                        // register the command handler
-                        final CommandHandlerWrapper commandHandlerWrapper = new CommandHandlerWrapper(tenantId,
-                                deviceId, gatewayId, commandHandler);
-                        final CommandHandlerWrapper replacedHandler = adapterInstanceCommandHandler
-                                .putDeviceSpecificCommandHandler(commandHandlerWrapper);
-                        if (replacedHandler != null) {
-                            // TODO find a way to provide a notification here so that potential resources associated with the replaced consumer can be freed (maybe add a commandHandlerOverwritten Handler param to createCommandConsumer())
-                        }
-                        // associate handler with this adapter instance
-                        final Instant lifespanStart = Instant.now();
-                        return setCommandHandlingAdapterInstance(tenantId, deviceId, sanitizedLifespan, context)
-                                .map(v -> {
-                                    final Function<SpanContext, Future<Void>> onCloseAction = onCloseSpanContext -> {
-                                        return removeCommandConsumer(commandHandlerWrapper, sanitizedLifespan,
-                                                lifespanStart, onCloseSpanContext);
-                                    };
-                                    return (ProtocolAdapterCommandConsumer) new ProtocolAdapterCommandConsumerImpl(onCloseAction);
-                                });
-                    })
-                    .onComplete(result);
-        });
-    }
-
-    private Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId,
-            final Duration lifespan, final SpanContext context) {
-        return commandHandlingAdapterInfoAccessor.setCommandHandlingAdapterInstance(tenantId, deviceId, adapterInstanceId, lifespan, context)
-                .recover(thr -> {
-                    log.info("error setting command handling adapter instance [tenant: {}, device: {}]", tenantId,
-                            deviceId, thr);
-                    // handler association failed - unregister the handler
-                    adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
-                    return Future.failedFuture(thr);
-                });
-    }
-
-    private Future<Void> removeCommandConsumer(final CommandHandlerWrapper commandHandlerWrapper, final Duration lifespan,
-            final Instant lifespanStart, final SpanContext onCloseSpanContext) {
-
-        final String tenantId = commandHandlerWrapper.getTenantId();
-        final String deviceId = commandHandlerWrapper.getDeviceId();
-
-        log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
-        if (!adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(commandHandlerWrapper)) {
-            // This case happens when trying to remove a command consumer which has been overwritten since its creation
-            // via a 2nd invocation of 'createCommandConsumer' with the same device/tenant id. Since the 2nd 'createCommandConsumer'
-            // invocation has registered a different 'commandHandlerWrapper' instance (and possibly already removed it),
-            // trying to remove the original object will return false here.
-            // On a more abstract level, this case happens when 2 consecutive command subscription requests from the
-            // same device (with no intermittent disconnect/unsubscribe - possibly because of a broken connection in between) have
-            // reached the *same* adapter instance and verticle, using this CommandConsumerFactory. Invoking 'removeCommandConsumer'
-            // on the 1st (obsolete and overwritten) command subscription shall have no impact. Throwing an explicit exception
-            // here will enable the protocol adapter to detect this case and skip an (incorrect) "disconnectedTtd" event message.
-            log.debug("command consumer not removed - handler already replaced or removed [tenant: {}, device: {}]",
-                    tenantId, deviceId);
-            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,
-                    "local command handler already replaced or removed"));
-        }
-        return commandHandlingAdapterInfoAccessor.removeCommandHandlingAdapterInstance(
-                    tenantId,
-                    deviceId,
-                    adapterInstanceId,
-                    onCloseSpanContext)
-                .recover(thr -> {
-                    if (ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_PRECON_FAILED) {
-                        final boolean entryMayHaveExpired = !lifespan.isNegative() && Instant.now().isAfter(lifespanStart.plus(lifespan));
-                        if (entryMayHaveExpired) {
-                            log.trace("ignoring 412 error when removing command handling adapter instance; entry may have already expired [tenant: {}, device: {}]",
-                                    tenantId, deviceId);
-                            return Future.succeededFuture();
-                        } else {
-                            // entry wasn't actually removed and entry hasn't expired (yet);
-                            // This case happens when 2 consecutive command subscription requests from the same device
-                            // (with no intermittent disconnect/unsubscribe - possibly because of a broken connection in between)
-                            // have reached *different* protocol adapter instances/verticles. Now calling 'removeCommandHandlingAdapterInstance'
-                            // on the 1st subscription fails because of the non-matching adapterInstanceId parameter.
-                            // Throwing an explicit exception here will enable the protocol adapter to detect this case
-                            // and skip sending an (incorrect) "disconnectedTtd" event message.
-                            log.debug("command handling adapter instance not removed - not matched or already removed [tenant: {}, device: {}]",
-                                    tenantId, deviceId);
-                            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,
-                                    "no matching command consumer mapping found to be removed"));
-                        }
-                    } else {
-                        log.info("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
-                                deviceId, thr);
-                        return Future.failedFuture(thr);
-                    }
-                });
-    }
-
-    private Future<MessageConsumer> getOrCreateMappingAndDelegatingCommandConsumer(final String tenantId) {
-        final Future<MessageConsumer> messageConsumerFuture = connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    mappingAndDelegatingCommandConsumerFactory.getOrCreateClient(tenantId,
-                            () -> newMappingAndDelegatingCommandConsumer(tenantId),
-                            result);
-                }));
-        return messageConsumerFuture.recover(thr -> {
-            log.debug("failed to create mappingAndDelegatingCommandConsumer for tenant {}", tenantId, thr);
-            return Future.failedFuture(thr);
-        });
-    }
-
-    private Future<MessageConsumer> newMappingAndDelegatingCommandConsumer(final String tenantId) {
-        log.trace("creating new MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId);
-        final String address = AddressHelper.getTargetAddress(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null, connection.getConfig());
-        return connection.createReceiver(
-                address,
-                ProtonQoS.AT_LEAST_ONCE,
-                (delivery, message) -> {
-                    mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(tenantId, delivery, message);
-                },
-                connection.getConfig().getInitialCredits(),
-                false, // no auto-accept
-                sourceAddress -> { // remote close hook
-                    log.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed remotely", tenantId);
-                    mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
-                    invokeRecreateConsumersWithDelay();
-                }).map(receiver -> {
-                    log.debug("successfully created MappingAndDelegatingCommandConsumer [{}]", address);
-                    final CommandConsumer consumer = new CommandConsumer(connection, receiver);
-                    consumer.setLocalCloseHandler(sourceAddress -> {
-                        log.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed locally", tenantId);
-                        mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
-                    });
-                    return (MessageConsumer) consumer;
-                }).recover(t -> {
-                    log.debug("failed to create MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-
-    private Future<ProtonReceiver> createAdapterSpecificConsumer() {
-        log.trace("creating new adapter instance command consumer");
-        final String adapterInstanceConsumerAddress = CommandConstants.INTERNAL_COMMAND_ENDPOINT + "/"
-                + adapterInstanceId;
-        return connection.createReceiver(
-                adapterInstanceConsumerAddress,
-                ProtonQoS.AT_LEAST_ONCE,
-                (delivery, msg) -> adapterInstanceCommandHandler.handleCommandMessage(msg, delivery),
-                connection.getConfig().getInitialCredits(),
-                false, // no auto-accept
-                sourceAddress -> { // remote close hook
-                    log.debug("command receiver link closed remotely");
-                    invokeRecreateConsumersWithDelay();
-                }).map(receiver -> {
-                    log.debug("successfully created adapter specific command consumer");
-                    adapterSpecificConsumer = receiver;
-                    return receiver;
-                }).recover(t -> {
-                    log.error("failed to create adapter specific command consumer", t);
-                    return Future.failedFuture(t);
-                });
-    }
-
-    private void recreateConsumers() {
-        if (recreatingConsumers.compareAndSet(false, true)) {
-            log.debug("recreate command consumer links");
-            connection.isConnected(getDefaultConnectionCheckTimeout())
-                    .compose(res -> {
-                        @SuppressWarnings("rawtypes")
-                        final List<Future> consumerCreationFutures = new ArrayList<>();
-                        // recreate adapter specific consumer
-                        if (!HonoProtonHelper.isLinkOpenAndConnected(adapterSpecificConsumer)) {
-                            log.debug("recreate adapter specific command consumer link");
-                            consumerCreationFutures.add(createAdapterSpecificConsumer());
-                        }
-                        // recreate mappingAndDelegatingCommandConsumers
-                        adapterInstanceCommandHandler.getDeviceSpecificCommandHandlers().stream()
-                                .map(CommandHandlerWrapper::getTenantId).distinct().forEach(tenantId -> {
-                                    log.debug("recreate command consumer link for tenant {}", tenantId);
-                                    consumerCreationFutures.add(
-                                            getOrCreateMappingAndDelegatingCommandConsumer(tenantId));
-                                });
-                        return CompositeFuture.join(consumerCreationFutures);
-                    }).onComplete(ar -> {
-                        recreatingConsumers.set(false);
-                        if (tryAgainRecreatingConsumers.compareAndSet(true, false) || ar.failed()) {
-                            if (ar.succeeded()) {
-                                // tryAgainRecreatingConsumers was set - try again immediately
-                                recreateConsumers();
-                            } else {
-                                invokeRecreateConsumersWithDelay();
-                            }
-                        }
-                    });
-        } else {
-            // if recreateConsumers() was triggered by a remote link closing, that might have occurred after that link was dealt with above;
-            // therefore be sure recreateConsumers() gets called again once the current invocation has finished.
-            log.debug("already recreating consumers");
-            tryAgainRecreatingConsumers.set(true);
-        }
-    }
-
-    private void invokeRecreateConsumersWithDelay() {
-        connection.getVertx().setTimer(RECREATE_CONSUMERS_DELAY, tid -> recreateConsumers());
-    }
-
-    private void handleTenantTimeout(final Message<String> msg) {
-        final String tenantId = msg.body();
-        final List<CommandHandlerWrapper> tenantRelatedHandlers = adapterInstanceCommandHandler
-                .getDeviceSpecificCommandHandlers().stream().filter(handler -> handler.getTenantId().equals(tenantId))
-                .collect(Collectors.toList());
-        if (tenantRelatedHandlers.isEmpty()) {
-            final MessageConsumer consumer = mappingAndDelegatingCommandConsumerFactory.getClient(tenantId);
-            if (consumer != null) {
-                log.info("tenant timeout: closing and removing command consumer [tenant {}]", tenantId);
-                consumer.close(v -> mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId));
-            }
-        } else {
-            log.debug("ignoring tenant timeout; there are still {} command handlers for tenant devices [tenant {}]",
-                    tenantRelatedHandlers.size(), tenantId);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * This implementation always creates a new sender link.
-     */
-    @Override
-    public Future<CommandResponseSender> getCommandResponseSender(final String tenantId, final String replyId) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(replyId);
-        return connection.executeOnContext(result -> {
-            CommandResponseSenderImpl.create(connection, tenantId, replyId, samplerFactory.create(CommandConstants.COMMAND_RESPONSE_ENDPOINT), onRemoteClose -> {}).onComplete(result);
-        });
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerImpl.java
deleted file mode 100644
index 0fe7330e0..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerImpl.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Function;
-
-import org.eclipse.hono.client.ProtocolAdapterCommandConsumer;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-
-/**
- * Represents the device specific command consumer used in protocol adapters.
- * <p>
- * Delegates an invocation of the {@link #close(SpanContext)} to the action supplied in the constructor.
- */
-public final class ProtocolAdapterCommandConsumerImpl implements ProtocolAdapterCommandConsumer {
-
-    private final Function<SpanContext, Future<Void>> onCloseAction;
-    private final AtomicBoolean closeCalled = new AtomicBoolean(false);
-
-    /**
-     * Creates a new DeviceSpecificCommandConsumer.
-     *
-     * @param onCloseAction The action to invoke when {@link #close(SpanContext)} is called.
-     * @throws NullPointerException If onCloseAction is {@code null}.
-     */
-    public ProtocolAdapterCommandConsumerImpl(final Function<SpanContext, Future<Void>> onCloseAction) {
-        this.onCloseAction = Objects.requireNonNull(onCloseAction);
-    }
-
-    @Override
-    public Future<Void> close(final SpanContext spanContext) {
-        if (closeCalled.compareAndSet(false, true)) {
-            return onCloseAction.apply(spanContext);
-        } else {
-            return Future.succeededFuture();
-        }
-    }
-
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandlerTest.java
deleted file mode 100644
index 955ebb5ef..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandlerTest.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.Collections;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.MessageHelper;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-
-/**
- * Verifies behavior of {@link AdapterInstanceCommandHandler}.
- */
-public class AdapterInstanceCommandHandlerTest {
-
-    private AdapterInstanceCommandHandler adapterInstanceCommandHandler;
-
-    /**
-     * Sets up fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-        final Span span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        final String adapterInstanceId = "adapterInstanceId";
-        adapterInstanceCommandHandler = new AdapterInstanceCommandHandler(tracer, adapterInstanceId);
-    }
-
-    @Test
-    void testHandleCommandMessageWithInvalidMessage() {
-        final Message msg = mock(Message.class);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        adapterInstanceCommandHandler.handleCommandMessage(msg, delivery);
-
-        final ArgumentCaptor<DeliveryState> deliveryStateCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(delivery).disposition(deliveryStateCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateCaptor.getValue()).isNotNull();
-        assertThat(deliveryStateCaptor.getValue()).isInstanceOf(Rejected.class);
-    }
-
-    @Test
-    void testHandleCommandMessageWithNoHandlerFound() {
-        final Message msg = mock(Message.class);
-        final String deviceId = "4711";
-        when(msg.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        adapterInstanceCommandHandler.handleCommandMessage(msg, delivery);
-
-        final ArgumentCaptor<DeliveryState> deliveryStateCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(delivery).disposition(deliveryStateCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateCaptor.getValue()).isNotNull();
-        assertThat(deliveryStateCaptor.getValue()).isInstanceOf(Released.class);
-    }
-
-    @Test
-    void testHandleCommandMessageWithHandlerForDevice() {
-        final String deviceId = "4711";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, commandHandler);
-
-        adapterInstanceCommandHandler.handleCommandMessage(message, mock(ProtonDelivery.class));
-
-        final ArgumentCaptor<CommandContext> commandContextCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(commandHandler).handle(commandContextCaptor.capture());
-        assertThat(commandContextCaptor.getValue()).isNotNull();
-        assertThat(commandContextCaptor.getValue().getCommand().getDeviceId()).isEqualTo(deviceId);
-    }
-
-    @Test
-    void testHandleCommandMessageWithHandlerForGateway() {
-        final String deviceId = "4711";
-        final String gatewayId = "gw-1";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-        message.setApplicationProperties(
-                new ApplicationProperties(Collections.singletonMap(MessageHelper.APP_PROPERTY_CMD_VIA, gatewayId)));
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, gatewayId, null, commandHandler);
-
-        adapterInstanceCommandHandler.handleCommandMessage(message, mock(ProtonDelivery.class));
-
-        final ArgumentCaptor<CommandContext> commandContextCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(commandHandler).handle(commandContextCaptor.capture());
-        assertThat(commandContextCaptor.getValue()).isNotNull();
-        // assert that command is directed at the gateway
-        assertThat(commandContextCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
-        assertThat(commandContextCaptor.getValue().getCommand().getOriginalDeviceId()).isEqualTo(deviceId);
-    }
-
-    @Test
-    void testHandleCommandMessageWithHandlerForGatewayAndSpecificDevice() {
-        final String deviceId = "4711";
-        final String gatewayId = "gw-1";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, gatewayId, commandHandler);
-
-        adapterInstanceCommandHandler.handleCommandMessage(message, mock(ProtonDelivery.class));
-
-        final ArgumentCaptor<CommandContext> commandContextCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(commandHandler).handle(commandContextCaptor.capture());
-        assertThat(commandContextCaptor.getValue()).isNotNull();
-        // assert that command is directed at the gateway
-        assertThat(commandContextCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
-        assertThat(commandContextCaptor.getValue().getCommand().getOriginalDeviceId()).isEqualTo(deviceId);
-    }
-
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
deleted file mode 100644
index 0dbc6c811..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
+++ /dev/null
@@ -1,166 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import org.eclipse.hono.client.CommandTargetMapper.CommandTargetMapperContext;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-
-/**
- * Verifies behavior of {@link CommandTargetMapperImpl}.
- */
-public class CommandTargetMapperImplTest {
-
-    private CommandTargetMapperImpl commandTargetMapper;
-    private CommandTargetMapperContext mapperContext;
-    private String tenantId;
-    private String deviceId;
-    private Span span;
-
-    /**
-     * Sets up common fixture.
-     */
-    @BeforeEach
-    public void setup() {
-        span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        tenantId = "testTenant";
-        deviceId = "testDevice";
-        mapperContext = mock(CommandTargetMapperContext.class);
-        commandTargetMapper = new CommandTargetMapperImpl(tracer);
-        commandTargetMapper.initialize(mapperContext);
-    }
-
-    /**
-     * Verifies that the <em>getTargetGatewayAndAdapterInstance</em> method returns a Future with the expected result
-     * for a device for which no 'via' entry is set.
-     */
-    @Test
-    public void testGetTargetGatewayAndAdapterInstanceUsingDeviceWithNoVia() {
-        // GIVEN assertRegistration result with no 'via'
-        when(mapperContext.getViaGateways(anyString(), anyString(), any()))
-            .thenReturn(Future.succeededFuture(Collections.emptyList()));
-
-        // and a getCommandHandlingAdapterInstances result with one object for the device
-        final String adapterInstanceId = "adapter1";
-        final JsonObject adapterInstancesResult = new JsonObject();
-        final JsonObject adapterInstanceEntry = new JsonObject();
-        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId);
-        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
-        adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, new JsonArray(Collections.singletonList(adapterInstanceEntry)));
-        when(mapperContext.getCommandHandlingAdapterInstances(eq(tenantId), eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
-
-        // WHEN getTargetGatewayAndAdapterInstance() is invoked
-        final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
-
-        // THEN the returned Future is complete and contains the adapter instance entry
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(adapterInstanceEntry);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that the <em>getTargetGatewayAndAdapterInstance</em> method returns a result with a gateway
-     * if that gateway is one of the device's 'via' gateways and is associated with a command handling adapter
-     * instance.
-     */
-    @Test
-    public void testGetTargetGatewayAndAdapterInstanceUsingDeviceWithMappedGateway() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistration result with non-empty 'via'
-        when(mapperContext.getViaGateways(anyString(), anyString(), any()))
-            .thenReturn(Future.succeededFuture(Collections.singletonList(gatewayId)));
-
-        // and a getCommandHandlingAdapterInstances result with one object for the gateway
-        final String adapterInstanceId = "adapter1";
-        final JsonObject adapterInstancesResult = new JsonObject();
-        final JsonObject adapterInstanceEntry = new JsonObject();
-        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, gatewayId);
-        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
-        adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, new JsonArray(Collections.singletonList(adapterInstanceEntry)));
-        when(mapperContext.getCommandHandlingAdapterInstances(eq(tenantId), eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
-
-        // THEN the returned Future is complete and contains the adapter instance entry
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(adapterInstanceEntry);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that <em>getTargetGatewayAndAdapterInstance</em> method result for multiple command handling
-     * adapter instances associated with gateways in the via list of the device.
-     */
-    @Test
-    public void tesGetTargetGatewayAndAdapterInstanceUsingDeviceWithMappedGateway() {
-        final String gatewayId = "testDeviceVia";
-        final String otherGatewayId = "otherGatewayId";
-        final List<String> viaList = new ArrayList<>();
-        viaList.add(gatewayId);
-        viaList.add(otherGatewayId);
-        // GIVEN assertRegistration result with non-empty 'via'
-        when(mapperContext.getViaGateways(anyString(), anyString(), any())).thenReturn(Future.succeededFuture(viaList));
-
-        // and a getCommandHandlingAdapterInstances result with 2 objects with the one with 'gatewayId' being first
-        final String adapterInstanceId = "adapter1";
-        final JsonObject adapterInstancesResult = new JsonObject();
-        final JsonObject adapterInstanceEntry = new JsonObject();
-        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, gatewayId);
-        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
-
-        final JsonObject adapterInstanceOtherEntry = new JsonObject();
-        adapterInstanceOtherEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, otherGatewayId);
-        adapterInstanceOtherEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
-
-        final JsonArray adapterInstances = new JsonArray();
-        adapterInstances.add(adapterInstanceEntry);
-        adapterInstances.add(adapterInstanceOtherEntry);
-        adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, adapterInstances);
-        when(mapperContext.getCommandHandlingAdapterInstances(eq(tenantId), eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
-
-        // THEN the returned Future is complete and contains the first adapter instance entry
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(adapterInstanceEntry);
-        verify(span).finish();
-    }
-
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImplTest.java
deleted file mode 100644
index 9e07723fd..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImplTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-
-import io.vertx.core.Future;
-
-/**
- * Tests verifying the behavior of {@link DeviceConnectionClientFactoryImpl}.
- */
-public class DeviceConnectionClientFactoryImplTest
-        extends AbstractTenantTimeoutRelatedClientFactoryTest<DeviceConnectionClient> {
-
-    @Override
-    protected Future<DeviceConnectionClient> getClientFuture(final HonoConnection connection, final String tenantId) {
-        return new DeviceConnectionClientFactoryImpl(connection, SendMessageSampler.Factory.noop())
-                .getOrCreateDeviceConnectionClient(tenantId);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
deleted file mode 100644
index 3c59047e9..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
+++ /dev/null
@@ -1,714 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-import java.util.Collections;
-
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-
-/**
- * Tests verifying behavior of {@link DeviceConnectionClientImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class DeviceConnectionClientImplTest {
-
-    private ProtonSender sender;
-    private DeviceConnectionClientImpl client;
-    private Span span;
-
-    /**
-     * Sets up the fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-
-        span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        final Vertx vertx = mock(Vertx.class);
-        final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-
-        final RequestResponseClientConfigProperties config = new RequestResponseClientConfigProperties();
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config, tracer);
-
-        client = new DeviceConnectionClientImpl(connection, Constants.DEFAULT_TENANT, sender, receiver, SendMessageSampler.noop());
-    }
-
-    /**
-     * Verifies that the client retrieves the result of the <em>get-last-known-gateway</em> operation from the
-     * Device Connection service.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetLastKnownGatewayForDeviceSuccess(final VertxTestContext ctx) {
-
-        final String gatewayId = "gatewayId";
-        final JsonObject getLastGatewayResult = new JsonObject().
-                put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
-
-        // WHEN getting the last known gateway
-        client.getLastKnownGatewayForDevice("deviceId", span.context())
-                .onComplete(ctx.succeeding(resultJson -> {
-                    ctx.verify(() -> {
-                        // THEN the last known gateway has been retrieved from the service and the span is finished
-                        assertThat(resultJson).isNotNull();
-                        assertThat(resultJson.getString(DeviceConnectionConstants.FIELD_GATEWAY_ID)).isEqualTo(gatewayId);
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-
-        final Message sentMessage = verifySenderSend();
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(sentMessage.getMessageId());
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, getLastGatewayResult.toBuffer());
-        client.handleResponse(mock(ProtonDelivery.class), response);
-    }
-
-    /**
-     * Verifies that the client handles the response of the <em>set-last-known-gateway</em> operation from the
-     * Device Connection service.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSetLastKnownGatewayForDeviceSuccess(final VertxTestContext ctx) {
-
-        // WHEN setting the last known gateway
-        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
-                .onComplete(ctx.succeeding(r -> {
-                    ctx.verify(() -> {
-                        // THEN the response has been handled and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-
-        final Message sentMessage = verifySenderSend();
-        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
-        client.handleResponse(mock(ProtonDelivery.class), response);
-    }
-
-    /**
-     * Verifies that the client handles the response of the <em>set-cmd-handling-adapter-instance</em> operation from the
-     * Device Connection service.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSetCommandHandlingAdapterInstance(final VertxTestContext ctx) {
-
-        // WHEN setting the command handling adapter instance
-        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, span.context())
-                .onComplete(ctx.succeeding(r -> {
-                    ctx.verify(() -> {
-                        // THEN the response has been handled and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-
-        final Message sentMessage = verifySenderSend();
-        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
-        client.handleResponse(mock(ProtonDelivery.class), response);
-    }
-
-    /**
-     * Verifies that the client handles the response of the <em>remove-cmd-handling-adapter-instance</em> operation from the
-     * Device Connection service.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testRemoveCommandHandlingAdapterInstance(final VertxTestContext ctx) {
-
-        // WHEN removing the command handling adapter instance
-        client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
-                .onComplete(ctx.succeeding(r -> {
-                    ctx.verify(() -> {
-                        // THEN the response has been handled and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-
-        final Message sentMessage = verifySenderSend();
-        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
-        client.handleResponse(mock(ProtonDelivery.class), response);
-    }
-
-    /**
-     * Verifies that the client handles the response of the <em>get-cmd-handling-adapter-instances</em> operation from the
-     * Device Connection service.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetCommandHandlingAdapterInstances(final VertxTestContext ctx) {
-
-        final String adapterInstanceId = "adapterInstanceId";
-        final String deviceId = "4711";
-
-        final JsonArray adapterInstancesArray = new JsonArray();
-        adapterInstancesArray
-                .add(new JsonObject().put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId)
-                        .put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId));
-        final JsonObject adapterInstancesResult = new JsonObject().
-                put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, adapterInstancesArray);
-
-        // WHEN getting the command handling adapter instances
-        client.getCommandHandlingAdapterInstances(deviceId, Collections.emptyList(), span.context())
-                .onComplete(ctx.succeeding(resultJson -> {
-                    ctx.verify(() -> {
-                        // THEN the response has been handled and the span is finished
-                        assertThat(resultJson).isEqualTo(adapterInstancesResult);
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-
-        final Message sentMessage = verifySenderSend();
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(sentMessage.getMessageId());
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, adapterInstancesResult.toBuffer());
-        client.handleResponse(mock(ProtonDelivery.class), response);
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>get-last-known-gateway</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetLastKnownGatewayForDeviceFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left 
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN getting last known gateway information
-        client.getLastKnownGatewayForDevice("deviceId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>set-last-known-gateway</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSetLastKnownGatewayForDeviceFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left 
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN setting last known gateway information
-        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>set-cmd-handling-adapter-instance</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSetCommandHandlingAdapterInstanceFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN setting the command handling adapter instance
-        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>remove-cmd-handling-adapter-instance</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testRemoveCommandHandlingAdapterInstanceFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN removing the command handling adapter instance
-        client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>remove-cmd-handling-adapter-instance</em> operation
-     * fails if a <em>PRECON_FAILED</em> response was returned from the device connection service.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testRemoveCommandHandlingAdapterInstanceForNotFoundEntry(final VertxTestContext ctx) {
-
-        // WHEN removing the command handling adapter instance
-        client.removeCommandHandlingAdapterInstance("deviceId", "gatewayId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the response has been handled and the span is finished
-                        assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_PRECON_FAILED);
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-
-        final Message sentMessage = verifySenderSend();
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_PRECON_FAILED);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(sentMessage.getMessageId());
-        client.handleResponse(mock(ProtonDelivery.class), response);
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>get-cmd-handling-adapter-instances</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetCommandHandlingAdapterInstancesFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN getting the command handling adapter instances
-        client.getCommandHandlingAdapterInstances("deviceId", Collections.emptyList(), span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>get-last-known-gateway</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetLastKnownGatewayForDeviceFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN getting last known gateway information
-        client.getLastKnownGatewayForDevice("deviceId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>set-last-known-gateway</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSetLastKnownGatewayForDeviceFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN setting last known gateway information
-        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>set-cmd-handling-adapter-instance</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSetCommandHandlingAdapterInstanceFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN setting the command handling adapter instance
-        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>remove-cmd-handling-adapter-instance</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testRemoveCommandHandlingAdapterInstanceFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN removing the command handling adapter instance
-        client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that a client invocation of the <em>get-cmd-handling-adapter-instances</em> operation fails
-     * if the device connection service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetCommandHandlingAdapterInstancesFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN getting the command handling adapter instances
-        client.getCommandHandlingAdapterInstances("deviceId", Collections.emptyList(), span.context())
-                .onComplete(ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                        // THEN the invocation fails and the span is marked as erroneous
-                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that the client includes the required information in the <em>get-last-known-gateway</em> operation
-     * request message sent to the device connection service.
-     */
-    @Test
-    public void testGetLastKnownGatewayForDeviceIncludesRequiredInformationInRequest() {
-
-        final String deviceId = "deviceId";
-
-        // WHEN getting last known gateway information
-        client.getLastKnownGatewayForDevice(deviceId, span.context());
-
-        // THEN the message being sent contains the device ID in its properties
-        final Message sentMessage = verifySenderSend();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo(deviceId);
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.GET_LAST_GATEWAY.getSubject());
-        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
-    }
-
-    /**
-     * Verifies that the client includes the required information in the <em>set-last-known-gateway</em> operation
-     * request message sent to the device connection service.
-     */
-    @Test
-    public void testSetLastKnownGatewayForDeviceIncludesRequiredInformationInRequest() {
-
-        final String deviceId = "deviceId";
-        final String gatewayId = "gatewayId";
-
-        // WHEN setting last known gateway information
-        client.setLastKnownGatewayForDevice(deviceId, gatewayId, span.context());
-
-        // THEN the message being sent contains the device ID in its properties
-        final Message sentMessage = verifySenderSend();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo(deviceId);
-        assertThat(MessageHelper.getApplicationProperty(sentMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_GATEWAY_ID, String.class))
-                        .isEqualTo(gatewayId);
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.SET_LAST_GATEWAY.getSubject());
-        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
-    }
-
-    /**
-     * Verifies that the client includes the required information in the <em>set-cmd-handling-adapter-instance</em> operation
-     * request message sent to the device connection service.
-     */
-    @Test
-    public void testSetCommandHandlingAdapterInstanceIncludesRequiredInformationInRequest() {
-
-        final String deviceId = "deviceId";
-
-        // WHEN setting the command handling adapter instance
-        client.setCommandHandlingAdapterInstance(deviceId, "adapterInstanceId", null, span.context());
-
-        // THEN the message being sent contains the device ID in its properties
-        final Message sentMessage = verifySenderSend();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo(deviceId);
-        assertThat(MessageHelper.getApplicationProperty(sentMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, String.class))
-                        .isEqualTo("adapterInstanceId");
-        assertThat(MessageHelper.getApplicationProperty(sentMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_LIFESPAN, Integer.class))
-                        .isEqualTo(Integer.valueOf(-1));
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.SET_CMD_HANDLING_ADAPTER_INSTANCE.getSubject());
-        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
-    }
-
-    /**
-     * Verifies that the client includes the required information in the <em>set-cmd-handling-adapter-instance</em> operation
-     * request message sent to the device connection service, including the lifespan parameter.
-     */
-    @Test
-    public void testSetCommandHandlingAdapterInstanceWithLifespanIncludesRequiredInformationInRequest() {
-
-        final String deviceId = "deviceId";
-        final int lifespanSeconds = 20;
-
-        // WHEN setting the command handling adapter instance
-        client.setCommandHandlingAdapterInstance(deviceId, "adapterInstanceId",
-                Duration.ofSeconds(lifespanSeconds), span.context());
-
-        // THEN the message being sent contains the device ID in its properties
-        final Message sentMessage = verifySenderSend();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo(deviceId);
-        assertThat(MessageHelper.getApplicationProperty(sentMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, String.class))
-                .isEqualTo("adapterInstanceId");
-        assertThat(MessageHelper.getApplicationProperty(sentMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_LIFESPAN, Integer.class))
-                .isEqualTo(lifespanSeconds);
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.SET_CMD_HANDLING_ADAPTER_INSTANCE.getSubject());
-        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
-    }
-
-    /**
-     * Verifies that the client includes the required information in the <em>remove-cmd-handling-adapter-instance</em> operation
-     * request message sent to the device connection service.
-     */
-    @Test
-    public void testRemoveCommandHandlingAdapterInstanceIncludesRequiredInformationInRequest() {
-
-        final String deviceId = "deviceId";
-        final String adapterInstanceId = "adapterInstanceId";
-
-        // WHEN removing the command handling adapter instance
-        client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, span.context());
-
-        // THEN the message being sent contains the device ID in its properties
-        final Message sentMessage = verifySenderSend();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo(deviceId);
-        assertThat(MessageHelper.getApplicationProperty(sentMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, String.class))
-                        .isEqualTo(adapterInstanceId);
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.REMOVE_CMD_HANDLING_ADAPTER_INSTANCE.getSubject());
-        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
-    }
-
-    /**
-     * Verifies that the client includes the required information in the <em>get-cmd-handling-adapter-instances</em> operation
-     * request message sent to the device connection service.
-     */
-    @Test
-    public void testGetCommandHandlingAdapterInstancesIncludesRequiredInformationInRequest() {
-
-        final String deviceId = "deviceId";
-        final String gatewayId = "gw-1";
-
-        // WHEN getting last known gateway information
-        client.getCommandHandlingAdapterInstances(deviceId, Collections.singletonList(gatewayId), span.context());
-
-        // THEN the message being sent contains the device ID in its properties
-        final Message sentMessage = verifySenderSend();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo(deviceId);
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.GET_CMD_HANDLING_ADAPTER_INSTANCES.getSubject());
-        // and the 'via' gateway ID in the payload
-        final JsonObject msgJsonPayload = MessageHelper.getJsonPayload(sentMessage);
-        assertThat(msgJsonPayload).isNotNull();
-        final JsonArray gatewaysJsonArray = msgJsonPayload.getJsonArray(DeviceConnectionConstants.FIELD_GATEWAY_IDS);
-        assertThat(gatewaysJsonArray.getList().iterator().next()).isEqualTo(gatewayId);
-    }
-
-    private Message createNoContentResponseMessage(final Object correlationId) {
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NO_CONTENT);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(correlationId);
-        return response;
-    }
-
-    private Message verifySenderSend() {
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        return messageCaptor.getValue();
-    }
-
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandlerTest.java
deleted file mode 100644
index ccdb83143..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandlerTest.java
+++ /dev/null
@@ -1,523 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.argThat;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.util.UUID;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.CommandTargetMapper;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.vertx.core.Context;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.core.eventbus.EventBus;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-/**
- * Verifies behavior of {@link MappingAndDelegatingCommandHandler}.
- */
-public class MappingAndDelegatingCommandHandlerTest {
-
-    private CommandTargetMapper commandTargetMapper;
-    private AdapterInstanceCommandHandler adapterInstanceCommandHandler;
-    private String adapterInstanceId;
-    private MappingAndDelegatingCommandHandler mappingAndDelegatingCommandHandler;
-    // sender used in the DelegatedCommandSender
-    private ProtonSender sender;
-
-    /**
-     * Sets up fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-        final Span span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        final Vertx vertx = mock(Vertx.class);
-        final Context context = VertxMockSupport.mockContext(vertx);
-        when(vertx.getOrCreateContext()).thenReturn(context);
-        doAnswer(invocation -> {
-            final Handler<Void> handler = invocation.getArgument(1);
-            handler.handle(null);
-            return null;
-        }).when(vertx).setTimer(anyLong(), VertxMockSupport.anyHandler());
-        final EventBus eventBus = mock(EventBus.class);
-        when(vertx.eventBus()).thenReturn(eventBus);
-
-        adapterInstanceId = UUID.randomUUID().toString();
-
-        final ClientConfigProperties props = new ClientConfigProperties();
-        props.setSendMessageTimeout(0);
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, props);
-        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-        when(connection.createSender(anyString(), any(), any())).thenReturn(Future.succeededFuture(sender));
-
-        adapterInstanceCommandHandler = new AdapterInstanceCommandHandler(tracer, adapterInstanceId);
-        commandTargetMapper = mock(CommandTargetMapper.class);
-
-        mappingAndDelegatingCommandHandler = new MappingAndDelegatingCommandHandler(
-                connection, commandTargetMapper, adapterInstanceCommandHandler, adapterInstanceId, SendMessageSampler.noop());
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the given command message shall get mapped to a local command handler.
-     */
-    @Test
-    public void testMapWithLocalCommandHandler() {
-        final String deviceId = "4711";
-
-        // GIVEN a registered commandHandler for the deviceId
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
-
-        // AND the deviceId commandHandler registered for the local adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
-
-        // WHEN mapping and delegating the command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the local command handler is invoked with the unchanged command message
-        assertThat(localHandlerCmdContextRef.get()).isNotNull();
-        assertThat(localHandlerCmdContextRef.get().getCommand()).isNotNull();
-        assertThat(localHandlerCmdContextRef.get().getCommand().getCommandMessage()).isEqualTo(message);
-        assertThat(localHandlerCmdContextRef.get().getCommand().isValid()).isTrue();
-        // AND the command message delivery is unchanged (that would be done by the commandHandler)
-        verify(delivery, never()).disposition(any(), anyBoolean());
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the given <em>invalid</em> command message shall get mapped to a local command handler.
-     */
-    @Test
-    public void testMapWithLocalCommandHandlerAndInvalidMessage() {
-        final String deviceId = "4711";
-
-        // GIVEN a registered commandHandler for the deviceId
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
-
-        // AND the deviceId commandHandler registered for the local adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
-
-        // WHEN mapping and delegating an invalid command message
-        final Message message = getValidCommandMessage(deviceId);
-        message.setSubject(null); // make the message invalid
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the local command handler is invoked with the unchanged command message
-        assertThat(localHandlerCmdContextRef.get()).isNotNull();
-        assertThat(localHandlerCmdContextRef.get().getCommand()).isNotNull();
-        assertThat(localHandlerCmdContextRef.get().getCommand().getCommandMessage()).isEqualTo(message);
-        assertThat(localHandlerCmdContextRef.get().getCommand().isValid()).isFalse();
-        // AND the command message delivery is unchanged (that would be done by the commandHandler)
-        verify(delivery, never()).disposition(any(), anyBoolean());
-    }
-
-    /**
-     * Verifies that a command message with an address that doesn't contain a device ID
-     * gets rejected.
-     */
-    @Test
-    public void testMapForMessageHavingAddressWithoutDeviceId() {
-
-        // GIVEN a command message with an address that does not
-        // contain a device ID
-        final String deviceId = "4711";
-        final Message message = getValidCommandMessage(deviceId);
-        message.setAddress(String.format("%s/%s", CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT));
-
-        // WHEN mapping and delegating the command
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the disposition is REJECTED
-        verify(delivery).disposition(
-                argThat(state -> Constants.AMQP_BAD_REQUEST.equals(((Rejected) state).getError().getCondition())),
-                eq(true));
-        // and the message is not being delegated
-        verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-    }
-
-    /**
-     * Verifies that a command message with an address that contains a tenant which doesn't
-     * match the scope of the command receiver link gets rejected.
-     */
-    @Test
-    public void testMapForMessageHavingAddressWithInvalidTenant() {
-
-        // GIVEN a command message with an address that contains an
-        // invalid tenant
-        final String deviceId = "4711";
-        final Message message = getValidCommandMessage(deviceId);
-        message.setAddress(String.format("%s/%s/%s", CommandConstants.COMMAND_ENDPOINT, "wrong-tenant", deviceId));
-
-        // WHEN mapping and delegating the command
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the disposition is REJECTED
-        verify(delivery).disposition(
-                argThat(state -> AmqpError.UNAUTHORIZED_ACCESS.equals(((Rejected) state).getError().getCondition())),
-                eq(true));
-        // and the message is not being delegated
-        verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * no command handling adapter instance is found for the command message device.
-     */
-    @Test
-    public void testMapWithNoAdapterInstanceFound() {
-        final String deviceId = "4711";
-
-        // GIVEN no registered commandHandler for the deviceId
-        // but a deviceId commandHandler registered for the local adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
-
-        // WHEN mapping and delegating a command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the disposition is RELEASED
-        verify(delivery).disposition(any(Released.class), eq(true));
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * no command handling adapter instance is found for the command message device and the command message
-     * is invalid.
-     */
-    @Test
-    public void testMapWithNoAdapterInstanceFoundAndMessageInvalid() {
-        final String deviceId = "4711";
-
-        // GIVEN no registered commandHandler for the deviceId
-        // but a deviceId commandHandler registered for the local adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
-
-        // WHEN mapping and delegating an invalid command message
-        final Message message = getValidCommandMessage(deviceId);
-        message.setSubject(null); // make the message invalid
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the disposition is REJECTED
-        verify(delivery).disposition(any(Rejected.class), eq(true));
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the command handler is not found.
-     */
-    @Test
-    public void testMapWithCommandHandlerNotFound() {
-        final String deviceId = "4711";
-
-        // GIVEN a 'NOT_FOUND' error when looking up the adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)));
-
-        // WHEN mapping and delegating a command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the disposition is RELEASED
-        verify(delivery).disposition(any(Released.class), eq(true));
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the given command message shall get mapped to a local command handler, handling commands for a gateway.
-     */
-    @Test
-    public void testMapWithLocalCommandHandlerForGateway() {
-        final String deviceId = "4711";
-        final String gatewayId = "gw-1";
-
-        // GIVEN a registered commandHandler for the gateway
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, gatewayId, null, localHandlerCmdContextRef::set);
-
-        // AND the gatewayId commandHandler registered for the local adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(gatewayId, adapterInstanceId)));
-
-        // WHEN mapping and delegating the command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the local command handler is invoked with the command message, its device id set to the gateway
-        assertThat(localHandlerCmdContextRef.get()).isNotNull();
-        final Command command = localHandlerCmdContextRef.get().getCommand();
-        assertThat(command).isNotNull();
-        assertThat(command.isValid()).isTrue();
-        assertThat(command.getDeviceId()).isEqualTo(gatewayId);
-        assertThat(command.getOriginalDeviceId()).isEqualTo(deviceId);
-        // AND the command message delivery is unchanged (that would be done by the commandHandler)
-        verify(delivery, never()).disposition(any(), anyBoolean());
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the given command message shall get mapped to a local command handler, handling commands for the specific
-     * device for a gateway.
-     */
-    @Test
-    public void testMapWithLocalCommandHandlerForGatewayAndSpecificDevice() {
-        final String deviceId = "4711";
-        final String gatewayId = "gw-1";
-
-        // GIVEN a registered commandHandler for the deviceId and gatewayId
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, gatewayId, localHandlerCmdContextRef::set);
-
-        // AND the deviceId commandHandler registered for the local adapter instance
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
-
-        // WHEN mapping and delegating the command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the local command handler is invoked with the command message, its device id set to the gateway
-        assertThat(localHandlerCmdContextRef.get()).isNotNull();
-        final Command command = localHandlerCmdContextRef.get().getCommand();
-        assertThat(command).isNotNull();
-        assertThat(command.isValid()).isTrue();
-        assertThat(command.getDeviceId()).isEqualTo(gatewayId);
-        assertThat(command.getOriginalDeviceId()).isEqualTo(deviceId);
-        // AND the command message delivery is unchanged (that would be done by the commandHandler)
-        verify(delivery, never()).disposition(any(), anyBoolean());
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the command shall get handled by another adapter instance.
-     */
-    @Test
-    public void testMapWithCommandHandlerOnAnotherInstance() {
-        final String deviceId = "4711";
-
-        // GIVEN a deviceId commandHandler registered for another adapter instance (not the local one)
-        final String otherAdapterInstance = "otherAdapterInstance";
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, otherAdapterInstance)));
-
-        // AND an ACCEPTED result when sending the command message to another adapter instance
-        final ProtonDelivery sendMsgDeliveryUpdate = mock(ProtonDelivery.class);
-        when(sendMsgDeliveryUpdate.getRemoteState()).thenReturn(new Accepted());
-        when(sendMsgDeliveryUpdate.remotelySettled()).thenReturn(true);
-        final AtomicReference<Message> delegatedMessageRef = new AtomicReference<>();
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            delegatedMessageRef.set(invocation.getArgument(0));
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(sendMsgDeliveryUpdate);
-            return mock(ProtonDelivery.class);
-        });
-
-        // register local command handler - that shall not get used
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
-
-        // WHEN mapping and delegating the command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the delivery gets ACCEPTED as well
-        verify(delivery).disposition(any(Accepted.class), eq(true));
-        assertThat(localHandlerCmdContextRef.get()).isNull();
-        final Message delegatedMessage = delegatedMessageRef.get();
-        assertThat(delegatedMessage).isNotNull();
-        assertThat(delegatedMessage.getAddress()).isEqualTo(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the command shall get handled by another adapter instance, and the command message is invalid.
-     */
-    @Test
-    public void testMapWithCommandHandlerOnAnotherInstanceWithInvalidMessage() {
-        final String deviceId = "4711";
-
-        // GIVEN a deviceId commandHandler registered for another adapter instance (not the local one)
-        final String otherAdapterInstance = "otherAdapterInstance";
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, otherAdapterInstance)));
-
-        // register local command handler - that shall not get used
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
-
-        // WHEN mapping and delegating the invalid command message
-        final Message message = getValidCommandMessage(deviceId);
-        message.setSubject(null); // make the message invalid
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the delivery gets REJECTED
-        verify(delivery).disposition(any(Rejected.class), eq(true));
-        assertThat(localHandlerCmdContextRef.get()).isNull();
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the command shall get handled by another adapter instance and where sending the command message to
-     * the adapter instance fails.
-     */
-    @Test
-    public void testMapWithCommandHandlerOnAnotherInstanceWithMessageSendingFailed() {
-        final String deviceId = "4711";
-
-        // GIVEN a deviceId commandHandler registered for another adapter instance (not the local one)
-        final String otherAdapterInstance = "otherAdapterInstance";
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, otherAdapterInstance)));
-
-        // AND an error when sending the command message to another adapter instance (no credit)
-        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
-
-        // register local command handler - that shall not get used
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
-
-        // WHEN mapping and delegating the command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the delivery gets RELEASED
-        verify(delivery).disposition(any(Released.class), eq(true));
-        assertThat(localHandlerCmdContextRef.get()).isNull();
-    }
-
-    /**
-     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
-     * the command shall get handled by another adapter instance, the command handler being set for a gateway.
-     */
-    @Test
-    public void testMapWithCommandHandlerForGatewayOnAnotherInstance() {
-        final String deviceId = "4711";
-        final String gatewayId = "gw-1";
-
-        // GIVEN a gateway commandHandler registered for another adapter instance (not the local one)
-        final String otherAdapterInstance = "otherAdapterInstance";
-        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(gatewayId, otherAdapterInstance)));
-
-        // AND an ACCEPTED result when sending the command message to another adapter instance
-        final ProtonDelivery sendMsgDeliveryUpdate = mock(ProtonDelivery.class);
-        when(sendMsgDeliveryUpdate.getRemoteState()).thenReturn(new Accepted());
-        when(sendMsgDeliveryUpdate.remotelySettled()).thenReturn(true);
-        final AtomicReference<Message> delegatedMessageRef = new AtomicReference<>();
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            delegatedMessageRef.set(invocation.getArgument(0));
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(sendMsgDeliveryUpdate);
-            return mock(ProtonDelivery.class);
-        });
-
-        // register local command handler - that shall not get used
-        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
-        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, gatewayId, null, localHandlerCmdContextRef::set);
-
-        // WHEN mapping and delegating the command message
-        final Message message = getValidCommandMessage(deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
-
-        // THEN the delivery gets ACCEPTED as well
-        verify(delivery).disposition(any(Accepted.class), eq(true));
-        assertThat(localHandlerCmdContextRef.get()).isNull();
-        final Message delegatedMessage = delegatedMessageRef.get();
-        assertThat(delegatedMessage).isNotNull();
-        assertThat(delegatedMessage.getAddress()).isEqualTo(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-        final String viaProperty = MessageHelper.getApplicationProperty(delegatedMessage.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_CMD_VIA, String.class);
-        assertThat(viaProperty).isEqualTo(gatewayId);
-    }
-
-    private JsonObject createTargetAdapterInstanceJson(final String deviceId, final String otherAdapterInstance) {
-        final JsonObject targetAdapterInstanceJson = new JsonObject();
-        targetAdapterInstanceJson.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId);
-        targetAdapterInstanceJson.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, otherAdapterInstance);
-        return targetAdapterInstanceJson;
-    }
-
-    private Message getValidCommandMessage(final String deviceId) {
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
-        message.setSubject("doThis");
-        message.setCorrelationId("the-correlation-id");
-        return message;
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
deleted file mode 100644
index 3c0868c30..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
+++ /dev/null
@@ -1,320 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.ArgumentMatchers.startsWith;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
-
-import org.apache.qpid.proton.amqp.transport.Source;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.CommandTargetMapper;
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.DeviceConnectionClientFactory;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ProtocolAdapterCommandConsumer;
-import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.core.Context;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.core.eventbus.EventBus;
-import io.vertx.core.eventbus.Message;
-import io.vertx.junit5.Timeout;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * Verifies behavior of {@link ProtocolAdapterCommandConsumerFactoryImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)
-public class ProtocolAdapterCommandConsumerFactoryImplTest {
-
-    private Vertx vertx;
-    private HonoConnection connection;
-    private DeviceConnectionClientFactory deviceConnectionClientFactory;
-    private CommandTargetMapper commandTargetMapper;
-    private DeviceConnectionClient devConClient;
-    private ProtonReceiver mappingAndDelegatingCommandReceiver;
-    private String tenantCommandAddress;
-    private String tenantId;
-    private String deviceId;
-
-    /**
-     * Sets up fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-
-        vertx = mock(Vertx.class);
-        final Context context = VertxMockSupport.mockContext(vertx);
-        when(vertx.getOrCreateContext()).thenReturn(context);
-        VertxMockSupport.runTimersImmediately(vertx);
-        final EventBus eventBus = mock(EventBus.class);
-        when(vertx.eventBus()).thenReturn(eventBus);
-
-        deviceId = "theDevice";
-        tenantId = "theTenant";
-        final String adapterInstanceId = UUID.randomUUID().toString();
-
-        final ClientConfigProperties props = new ClientConfigProperties();
-
-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, props);
-        when(connection.getContainerId()).thenReturn(adapterInstanceId);
-
-        final ProtonReceiver adapterInstanceCommandReceiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        when(adapterInstanceCommandReceiver.getSource()).thenReturn(mock(Source.class));
-
-        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
-        when(connection.createReceiver(
-                startsWith(CommandConstants.INTERNAL_COMMAND_ENDPOINT),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(adapterInstanceCommandReceiver));
-        mappingAndDelegatingCommandReceiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        when(mappingAndDelegatingCommandReceiver.getSource()).thenReturn(mock(Source.class));
-        tenantCommandAddress = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
-        when(connection.createReceiver(
-                eq(tenantCommandAddress),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(mappingAndDelegatingCommandReceiver));
-        commandTargetMapper = mock(CommandTargetMapper.class);
-        devConClient = mock(DeviceConnectionClient.class);
-        deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);
-        when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));
-        when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
-                .thenReturn(Future.succeededFuture(devConClient));
-        when(devConClient.setCommandHandlingAdapterInstance(anyString(), anyString(), any(), any()))
-                .thenReturn(Future.succeededFuture());
-        when(devConClient.removeCommandHandlingAdapterInstance(anyString(), anyString(), any()))
-                .thenReturn(Future.succeededFuture());
-    }
-
-    private ProtocolAdapterCommandConsumerFactoryImpl createCommandConsumerFactory() {
-        final ProtocolAdapterCommandConsumerFactoryImpl factory = new ProtocolAdapterCommandConsumerFactoryImpl(
-                connection, SendMessageSampler.Factory.noop());
-        factory.initialize(
-                commandTargetMapper,
-                ProtocolAdapterCommandConsumerFactory.createCommandHandlingAdapterInfoAccess(deviceConnectionClientFactory));
-        return factory;
-    }
-
-    /**
-     * Verifies that an attempt to open a command consumer fails if the peer
-     * rejects to open a receiver link.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateCommandConsumerFailsIfPeerRejectsLink(final VertxTestContext ctx) {
-
-        final ProtocolAdapterCommandConsumerFactoryImpl commandConsumerFactory = createCommandConsumerFactory();
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final ServerErrorException ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE);
-        when(connection.createReceiver(
-                anyString(),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler()))
-        .thenReturn(Future.failedFuture(ex));
-
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> {
-                    assertThat(ServiceInvocationException.extractStatusCode(t)).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that creating a command consumer successfully creates a tenant-scoped
-     * receiver link and registers the command handling adapter instance.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateCommandConsumerSucceeds(final VertxTestContext ctx) {
-
-        final ProtocolAdapterCommandConsumerFactoryImpl commandConsumerFactory = createCommandConsumerFactory();
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
-            .onComplete(ctx.succeeding(c -> {
-                ctx.verify(() -> {
-                    verify(connection).createReceiver(eq(tenantCommandAddress), eq(ProtonQoS.AT_LEAST_ONCE), any(), anyInt(),
-                            eq(false), any());
-                    verify(devConClient).setCommandHandlingAdapterInstance(eq(deviceId), anyString(), any(), any());
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that creating a command consumer with a positive lifespan and
-     * closing the consumer afterwards succeeds.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateTimeLimitedCommandConsumerSucceeds(final VertxTestContext ctx) {
-
-        final ProtocolAdapterCommandConsumerFactoryImpl commandConsumerFactory = createCommandConsumerFactory();
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-
-        final Duration lifespan = Duration.ofSeconds(10);
-        final Future<ProtocolAdapterCommandConsumer> commandConsumerFuture = commandConsumerFactory.createCommandConsumer(tenantId,
-                deviceId, commandHandler, lifespan, null);
-        commandConsumerFuture.onComplete(ctx.succeeding(consumer -> {
-            ctx.verify(() -> {
-                verify(connection).createReceiver(eq(tenantCommandAddress), eq(ProtonQoS.AT_LEAST_ONCE), any(), anyInt(),
-                        eq(false), any());
-                verify(devConClient).setCommandHandlingAdapterInstance(eq(deviceId), anyString(), any(), any());
-                // verify closing the consumer is successful
-                consumer.close(any()).onComplete(ctx.succeeding(v -> {
-                    ctx.verify(() -> {
-                        // verify command handling adapter instance has been explicitly removed (since lifespan hasn't elapsed yet)
-                        verify(devConClient).removeCommandHandlingAdapterInstance(eq(deviceId), anyString(), any());
-                    });
-                    ctx.completeNow();
-                }));
-            });
-        }));
-    }
-
-    /**
-     * Verifies that upon getting a tenant timeout notification, the tenant-scoped
-     * consumer link is closed if there are no consumers for that tenant registered
-     * anymore.
-     *
-     * @param ctx The test context.
-     * @throws InterruptedException If the test execution gets interrupted.
-     */
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testTenantTimeoutClosesTenantLink(final VertxTestContext ctx) throws InterruptedException {
-
-        final ArgumentCaptor<Handler<Message<Object>>> eventBusMsgHandler = ArgumentCaptor.forClass(Handler.class);
-        when(vertx.eventBus().consumer(eq(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT), eventBusMsgHandler.capture()))
-                .thenReturn(mock(io.vertx.core.eventbus.MessageConsumer.class));
-
-        final ProtocolAdapterCommandConsumerFactoryImpl commandConsumerFactory = createCommandConsumerFactory();
-
-        // GIVEN a scenario where a command consumer is created and then closed again
-        final VertxTestContext consumerCreationAndRemoval = new VertxTestContext();
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
-                .onComplete(consumerCreationAndRemoval.succeeding(consumer -> {
-                    // close the consumer again
-                    consumer.close(null)
-                            .onComplete(consumerCreationAndRemoval.succeedingThenComplete());
-                }));
-        assertThat(consumerCreationAndRemoval.awaitCompletion(2, TimeUnit.SECONDS)).isTrue();
-        if (consumerCreationAndRemoval.failed()) {
-            ctx.failNow(consumerCreationAndRemoval.causeOfFailure());
-            return;
-        }
-
-        // WHEN the tenant timeout is triggered
-        final Message<Object> eventBusMsg = mock(Message.class);
-        when(eventBusMsg.body()).thenReturn(tenantId);
-        eventBusMsgHandler.getValue().handle(eventBusMsg);
-
-        // THEN the tenant-scoped receiver link is closed
-        verify(connection).closeAndFree(eq(mappingAndDelegatingCommandReceiver), any());
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that upon getting a tenant timeout notification, the tenant-scoped
-     * consumer link isn't closed if there are still consumers for that tenant registered.
-     *
-     * @param ctx The test context.
-     * @throws InterruptedException If the test execution gets interrupted.
-     */
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testTenantTimeoutSkipsClosingTenantLink(final VertxTestContext ctx) throws InterruptedException {
-
-        final ArgumentCaptor<Handler<Message<Object>>> eventBusMsgHandler = ArgumentCaptor.forClass(Handler.class);
-        when(vertx.eventBus().consumer(eq(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT), eventBusMsgHandler.capture()))
-                .thenReturn(mock(io.vertx.core.eventbus.MessageConsumer.class));
-
-        final ProtocolAdapterCommandConsumerFactoryImpl commandConsumerFactory = createCommandConsumerFactory();
-
-        // GIVEN a scenario where a command consumer is created
-        final VertxTestContext consumerCreation = new VertxTestContext();
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
-                .onComplete(consumerCreation.succeedingThenComplete());
-        assertThat(consumerCreation.awaitCompletion(2, TimeUnit.SECONDS)).isTrue();
-        if (consumerCreation.failed()) {
-            consumerCreation.failNow(consumerCreation.causeOfFailure());
-            return;
-        }
-
-        // WHEN the tenant timeout is triggered
-        final Message<Object> eventBusMsg = mock(Message.class);
-        when(eventBusMsg.body()).thenReturn(tenantId);
-        eventBusMsgHandler.getValue().handle(eventBusMsg);
-
-        // THEN the tenant-scoped receiver link isn't closed because the command consumer is still alive
-        verify(connection, never()).closeAndFree(eq(mappingAndDelegatingCommandReceiver), any());
-        ctx.completeNow();
-    }
-
-}
