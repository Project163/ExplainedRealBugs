diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index bcba3ff73..ea6bdc106 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -42,7 +42,7 @@ import io.vertx.proton.ProtonConnection;
 /**
  * A helper class for creating Vert.x based clients for Hono's arbitrary APIs.
  */
-public class HonoClient {
+public final class HonoClient {
 
     private static final Logger LOG = LoggerFactory.getLogger(HonoClient.class);
     private final String name;
@@ -98,10 +98,27 @@ public class HonoClient {
         return connection != null && !connection.isDisconnected();
     }
 
+    /**
+     * Connects to the Hono server using given options.
+     * 
+     * @param options The options to use (may be {@code null}).
+     * @param connectionHandler The handler to notify about the outcome of the connection attempt.
+     * @return This client for command chaining.
+     * @throws NullPointerException if the connection handler is {@code null}.
+     */
     public HonoClient connect(final ProtonClientOptions options, final Handler<AsyncResult<HonoClient>> connectionHandler) {
         return connect(options, connectionHandler, null);
     }
 
+    /**
+     * Connects to the Hono server using given options.
+     * 
+     * @param options The options to use (may be {@code null}).
+     * @param connectionHandler The handler to notify about the outcome of the connection attempt.
+     * @param disconnectHandler A  handler to notify about connection loss (may be {@code null}).
+     * @return This client for command chaining.
+     * @throws NullPointerException if the connection handler is {@code null}.
+     */
     public HonoClient connect(
             final ProtonClientOptions options,
             final Handler<AsyncResult<HonoClient>> connectionHandler,
@@ -177,15 +194,68 @@ public class HonoClient {
         }
     }
 
-    public HonoClient getOrCreateTelemetrySender( final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+    /**
+     * Gets a client for sending telemetry messages to a Hono server.
+     * 
+     * @param tenantId The ID of the tenant to send messages for.
+     * @param resultHandler The handler to notify about the client.
+     * @return This for command chaining.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    public HonoClient getOrCreateTelemetrySender(final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+        return getOrCreateTelemetrySender(tenantId, null, resultHandler);
+    }
+
+    /**
+     * Gets a client for sending telemetry messages to a Hono server.
+     * 
+     * @param tenantId The ID of the tenant to send messages for.
+     * @param deviceId The ID of the device to send events for (may be {@code null}).
+     * @param resultHandler The handler to notify about the client.
+     * @return This for command chaining.
+     * @throws NullPointerException if any of the tenantId or resultHandler is {@code null}.
+     */
+    public HonoClient getOrCreateTelemetrySender(final String tenantId, final String deviceId, final Handler<AsyncResult<MessageSender>> resultHandler) {
         Objects.requireNonNull(tenantId);
-        getOrCreateSender( "telemetry/" + tenantId,  (creationResult) -> createTelemetrySender(tenantId, creationResult), resultHandler);
+        getOrCreateSender(
+                TelemetrySenderImpl.getTargetAddress(tenantId, deviceId),
+                (creationResult) -> createTelemetrySender(tenantId, deviceId, creationResult),
+                resultHandler);
         return this;
     }
 
-    public HonoClient getOrCreateEventSender( final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+    /**
+     * Gets a client for sending events to a Hono server.
+     * 
+     * @param tenantId The ID of the tenant to send events for.
+     * @param resultHandler The handler to notify about the client.
+     * @return This for command chaining.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    public HonoClient getOrCreateEventSender(final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+        return getOrCreateEventSender(tenantId, null, resultHandler);
+    }
+
+    /**
+     * Gets a client for sending events to a Hono server.
+     * 
+     * @param tenantId The ID of the tenant to send events for.
+     * @param deviceId The ID of the device to send events for (may be {@code null}).
+     * @param resultHandler The handler to notify about the client.
+     * @return This for command chaining.
+     * @throws NullPointerException if any of the tenantId or resultHandler is {@code null}.
+     */
+    public HonoClient getOrCreateEventSender(
+            final String tenantId,
+            final String deviceId,
+            final Handler<AsyncResult<MessageSender>> resultHandler) {
+
         Objects.requireNonNull(tenantId);
-        getOrCreateSender("event/" + tenantId, (creationResult) -> createEventSender(tenantId, creationResult), resultHandler);
+        Objects.requireNonNull(resultHandler);
+        getOrCreateSender(
+                EventSenderImpl.getTargetAddress(tenantId, deviceId),
+                (creationResult) -> createEventSender(tenantId, deviceId, creationResult),
+                resultHandler);
         return this;
     }
 
@@ -209,10 +279,11 @@ public class HonoClient {
 
     private HonoClient createTelemetrySender(
             final String tenantId,
+            final String deviceId,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         checkConnection().compose(
-                connected -> TelemetrySenderImpl.create(context, connection, tenantId, creationHandler),
+                connected -> TelemetrySenderImpl.create(context, connection, tenantId, deviceId, creationHandler),
                 Future.<MessageSender> future().setHandler(creationHandler));
         return this;
     }
@@ -241,10 +312,11 @@ public class HonoClient {
 
     private HonoClient createEventSender(
             final String tenantId,
+            final String deviceId,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         checkConnection().compose(
-                connected -> EventSenderImpl.create(context, connection, tenantId, creationHandler),
+                connected -> EventSenderImpl.create(context, connection, tenantId, deviceId, creationHandler),
                 Future.<MessageSender> future().setHandler(creationHandler));
         return this;
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 1b3807321..d4c5f06a8 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -45,15 +45,18 @@ import io.vertx.proton.ProtonHelper;
  */
 abstract class AbstractSender extends AbstractHonoClient implements MessageSender {
 
-    private static final Logger     LOG = LoggerFactory.getLogger(AbstractSender.class);
-    private static final AtomicLong messageCounter = new AtomicLong();
-    private static final Pattern    CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
+    private static final Logger                LOG = LoggerFactory.getLogger(AbstractSender.class);
+    private static final AtomicLong            MESSAGE_COUNTER = new AtomicLong();
+    private static final Pattern               CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
 
-    private Handler<Void> drainHandler;
-    private BiConsumer<String, ProtonDelivery> dispositionHandler = (id, delivery) -> LOG.info("Disposition updated for {}: {}", id, delivery.getRemoteState());
+    protected final String                     tenantId;
 
-    AbstractSender(final Context context) {
+    private Handler<Void>                      drainHandler;
+    private BiConsumer<String, ProtonDelivery> dispositionHandler = (messageId, delivery) -> LOG.trace("disposition updated [message ID: {}, remote delivery state: {}]", messageId, delivery.getRemoteState());
+
+    AbstractSender(final String tenantId, final Context context) {
         super(context);
+        this.tenantId = Objects.requireNonNull(tenantId);
     }
 
     @Override
@@ -144,8 +147,13 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     }
 
     private void sendMessage(final Message rawMessage) {
-        sender.send(rawMessage, deliveryUpdated ->
-                dispositionHandler.accept(rawMessage.getMessageId().toString(), deliveryUpdated));
+        sender.send(rawMessage, deliveryUpdated -> {
+            if (rawMessage.getMessageId() != null) {
+                dispositionHandler.accept(rawMessage.getMessageId().toString(), deliveryUpdated);
+            } else {
+                dispositionHandler.accept("n/a", deliveryUpdated);
+            }
+        });
     }
 
     @Override
@@ -200,18 +208,43 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         Objects.requireNonNull(payload);
         Objects.requireNonNull(contentType);
         final Message msg = ProtonHelper.message();
+        msg.setAddress(getTo(deviceId));
         msg.setBody(new Data(new Binary(payload)));
         setApplicationProperties(msg, properties);
         addProperties(msg, deviceId, contentType);
+        addEndpointSpecificProperties(msg, deviceId);
         send(msg, capacityAvailableHandler);
     }
 
-    protected void addProperties(final Message msg, final String deviceId, final String contentType) {
-        msg.setMessageId(String.format("%s-%d", getClass().getSimpleName(), messageCounter.getAndIncrement()));
+    /**
+     * Gets the value of the <em>to</em> property to be used for messages produced by this sender.
+     * 
+     * @param deviceId The identifier of the device that the message's content originates from.
+     * @return The address.
+     */
+    protected abstract String getTo(final String deviceId);
+
+    private void addProperties(final Message msg, final String deviceId, final String contentType) {
+        msg.setMessageId(String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement()));
         msg.setContentType(contentType);
         addDeviceId(msg, deviceId);
     }
 
+    /**
+     * Sets additional properties on the message to be sent.
+     * <p>
+     * Subclasses should override this method to set any properties on messages
+     * that are specific to the particular endpoint the message is to be sent to.
+     * <p>
+     * This method does nothing by default.
+     * 
+     * @param msg The message to be sent.
+     * @param deviceId The ID of the device that the message's content originates from.
+     */
+    protected void addEndpointSpecificProperties(final Message msg, final String deviceId) {
+        // empty
+    }
+
     private void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
         if (properties != null) {
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index 163c98ad3..330e2dced 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -33,27 +33,50 @@ import io.vertx.proton.ProtonSender;
  */
 public class EventSenderImpl extends AbstractSender {
 
-    private static final String EVENT_ADDRESS_TEMPLATE = "event/%s";
+    private static final String EVENT_ENDPOINT_NAME = "event/";
     private static final Logger LOG = LoggerFactory.getLogger(EventSenderImpl.class);
 
-    private EventSenderImpl(final Context context, final ProtonSender sender) {
-        super(context);
+    private EventSenderImpl(final String tenantId, final Context context, final ProtonSender sender) {
+        super(tenantId, context);
         this.sender = sender;
     }
 
+    /**
+     * Gets the AMQP <em>target</em> address to use for sending messages to Hono's event endpoint.
+     * 
+     * @param tenantId The tenant to send events for.
+     * @param deviceId The device to send events for. If {@code null}, the target address can be used
+     *                 to send events for arbitrary devices belonging to the tenant.
+     * @return The target address.
+     * @throws NullPointerException if tenant is {@code null}.
+     */
+    public static String getTargetAddress(final String tenantId, final String deviceId) {
+        StringBuilder address = new StringBuilder(EVENT_ENDPOINT_NAME).append(tenantId);
+        if (deviceId != null && deviceId.length() > 0) {
+            address.append("/").append(deviceId);
+        }
+        return address.toString();
+    }
+
+    @Override
+    protected String getTo(final String deviceId) {
+        return getTargetAddress(tenantId, deviceId);
+    }
+
     public static void create(
             final Context context,
             final ProtonConnection con,
             final String tenantId,
+            final String deviceId,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(con);
         Objects.requireNonNull(tenantId);
-        createSender(con, tenantId).setHandler(created -> {
+        createSender(con, tenantId, deviceId).setHandler(created -> {
             if (created.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(
-                        new EventSenderImpl(context, created.result())));
+                        new EventSenderImpl(tenantId, context, created.result())));
             } else {
                 creationHandler.handle(Future.failedFuture(created.cause()));
             }
@@ -62,10 +85,11 @@ public class EventSenderImpl extends AbstractSender {
 
     private static Future<ProtonSender> createSender(
             final ProtonConnection con,
-            final String tenantId) {
+            final String tenantId,
+            final String deviceId) {
 
         final Future<ProtonSender> result = Future.future();
-        final String targetAddress = String.format(EVENT_ADDRESS_TEMPLATE, tenantId);
+        final String targetAddress = getTargetAddress(tenantId, deviceId);
 
         final ProtonSender sender = con.createSender(targetAddress);
         sender.setQoS(ProtonQoS.AT_LEAST_ONCE);
@@ -89,8 +113,7 @@ public class EventSenderImpl extends AbstractSender {
     }
 
     @Override
-    protected void addProperties(final Message msg, final String deviceId, final String contentType) {
-        super.addProperties(msg, deviceId, contentType);
+    protected void addEndpointSpecificProperties(final Message msg, final String deviceId) {
         msg.setDurable(true);
     }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index 24c80d76d..ea880fbe1 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -31,27 +31,50 @@ import io.vertx.proton.ProtonSender;
  */
 public class TelemetrySenderImpl extends AbstractSender {
 
-    private static final String     TELEMETRY_ADDRESS_TEMPLATE  = "telemetry/%s";
+    private static final String     TELEMETRY_ENDPOINT_NAME  = "telemetry/";
     private static final Logger     LOG = LoggerFactory.getLogger(TelemetrySenderImpl.class);
 
-    private TelemetrySenderImpl(final Context context, final ProtonSender sender) {
-        super(context);
+    private TelemetrySenderImpl(final String tenantId, final Context context, final ProtonSender sender) {
+        super(tenantId, context);
         this.sender = sender;
     }
 
+    /**
+     * Gets the AMQP <em>target</em> address to use for uploading data to Hono's telemetry endpoint.
+     * 
+     * @param tenantId The tenant to upload data for.
+     * @param deviceId The device to upload data for. If {@code null}, the target address can be used
+     *                 to upload data for arbitrary devices belonging to the tenant.
+     * @return The target address.
+     * @throws NullPointerException if tenant is {@code null}.
+     */
+    public static String getTargetAddress(final String tenantId, final String deviceId) {
+        StringBuilder targetAddress = new StringBuilder(TELEMETRY_ENDPOINT_NAME).append(Objects.requireNonNull(tenantId));
+        if (deviceId != null && deviceId.length() > 0) {
+            targetAddress.append("/").append(deviceId);
+        }
+        return targetAddress.toString();
+    }
+
+    @Override
+    protected String getTo(final String deviceId) {
+        return getTargetAddress(tenantId, deviceId);
+    }
+
     public static void create(
             final Context context,
             final ProtonConnection con,
             final String tenantId,
+            final String deviceId,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(con);
         Objects.requireNonNull(tenantId);
-        createSender(context, con, tenantId).setHandler(created -> {
+        createSender(context, con, tenantId, deviceId).setHandler(created -> {
             if (created.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(
-                        new TelemetrySenderImpl(context, created.result())));
+                        new TelemetrySenderImpl(tenantId, context, created.result())));
             } else {
                 creationHandler.handle(Future.failedFuture(created.cause()));
             }
@@ -61,10 +84,11 @@ public class TelemetrySenderImpl extends AbstractSender {
     private static Future<ProtonSender> createSender(
             final Context ctx,
             final ProtonConnection con,
-            final String tenantId) {
+            final String tenantId,
+            final String deviceId) {
 
         final Future<ProtonSender> result = Future.future();
-        final String targetAddress = String.format(TELEMETRY_ADDRESS_TEMPLATE, tenantId);
+        final String targetAddress = getTargetAddress(tenantId, deviceId);
 
         ctx.runOnContext(create -> {
             final ProtonSender sender = con.createSender(targetAddress);
