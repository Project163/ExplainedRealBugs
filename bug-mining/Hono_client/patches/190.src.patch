diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index b8d405889..5bb2fc8d2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -39,6 +39,7 @@ import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.connection.ConnectionFactory;
+import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.HonoProtonHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -617,6 +618,15 @@ public class HonoConnectionImpl implements HonoConnection {
 
         return executeOrRunOnContext(result -> {
             checkConnected().compose(v -> {
+
+                if (targetAddress == null && !supportsCapability(Constants.CAP_ANONYMOUS_RELAY)) {
+                    // AnonTerm spec requires peer to offer ANONYMOUS-RELAY capability
+                    // before a client can use anonymous terminus
+                    return Future.failedFuture(new ServerErrorException(
+                            HttpURLConnection.HTTP_NOT_IMPLEMENTED,
+                            "server does not support anonymous terminus"));
+                }
+
                 final Future<ProtonSender> senderFuture = Future.future();
                 final ProtonSender sender = connection.createSender(targetAddress);
                 sender.setQoS(qos);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index d5a06b7e0..cdf5e4270 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -33,6 +33,7 @@ import java.util.function.BiConsumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
+import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Target;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
@@ -632,6 +633,37 @@ public class HonoConnectionImplTest {
         verify(remoteCloseHook, never()).handle(anyString());
     }
 
+    /**
+     * Verifies that the attempt to create a sender for a {@code null} target address
+     * fails with a {@code ServerErrorException} if the remote peer doesn't
+     * support the anonymous terminus.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateSenderFailsForUnsupportedAnonTerminus(final TestContext ctx) {
+
+        when(con.getRemoteOfferedCapabilities()).thenReturn(new Symbol[] {Symbol.valueOf("some-feature")});
+        final Handler<String> remoteCloseHook = mock(Handler.class);
+
+        // GIVEN an established connection
+        final Async connectAttempt = ctx.async();
+        honoConnection.connect().setHandler(ctx.asyncAssertSuccess(ok -> connectAttempt.complete()));
+        connectAttempt.await();
+
+        // WHEN a client tries to open a sender for the anonymous terminus
+        final Future<ProtonSender> result = honoConnection.createSender(
+                null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook);
+
+        // THEN the attempt fails
+        assertTrue(result.failed());
+        assertThat(((ServerErrorException) result.cause()).getErrorCode(), is(HttpURLConnection.HTTP_NOT_IMPLEMENTED));
+        // and the remote close hook is not invoked
+        verify(remoteCloseHook, never()).handle(anyString());
+    }
+
+
     /**
      * Verifies that the attempt to create a sender fails with a
      * {@code ServerErrorException} if the remote peer sends a
