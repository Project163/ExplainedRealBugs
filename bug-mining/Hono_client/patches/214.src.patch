diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
index ab5e4a91e..65ac1df05 100644
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
@@ -95,13 +95,14 @@ public interface DeviceConnectionClient extends RequestResponseClient {
      * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
      *            An implementation should use this as the parent for any span it creates for tracing
      *            the execution of this operation.
-     * @return A future indicating the outcome of the operation.
+     * @return A future indicating the outcome of the operation, with its value indicating whether the protocol
+     *         adapter instance value was removed or not.
      *         <p>
-     *         The future will be succeeded if the entry was successfully removed.
-     *         Otherwise the future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException}.
+     *         The future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException} if there
+     *         was an error removing the value.
      * @throws NullPointerException if device id or adapter instance id is {@code null}.
      */
-    Future<Void> removeCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);
+    Future<Boolean> removeCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);
 
     /**
      * Gets information about the adapter instances that can handle a command for the given device.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
index 42a77ade8..09f8f963b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
@@ -232,7 +232,7 @@ public class DeviceConnectionClientImpl extends AbstractRequestResponseClient<De
     }
 
     @Override
-    public Future<Void> removeCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId, final SpanContext context) {
+    public Future<Boolean> removeCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId, final SpanContext context) {
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(adapterInstanceId);
 
@@ -252,7 +252,9 @@ public class DeviceConnectionClientImpl extends AbstractRequestResponseClient<De
         return mapResultAndFinishSpan(resultTracker.future(), result -> {
             switch (result.getStatus()) {
                 case HttpURLConnection.HTTP_NO_CONTENT:
-                    return null;
+                    return Boolean.TRUE;
+                case HttpURLConnection.HTTP_NOT_FOUND:
+                    return Boolean.FALSE;
                 default:
                     throw StatusCodeMapper.from(result);
             }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
index eda0cd53b..60628e3e3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
@@ -15,7 +15,6 @@ package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
 import java.time.Duration;
-import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
@@ -30,7 +29,6 @@ import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;
 import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.ResourceIdentifier;
@@ -173,9 +171,8 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                         return setCommandHandlingAdapterInstance(tenantId, deviceId, sanitizedLifespan, context);
                     })
                     .map(res -> {
-                        final Instant lifespanStart = Instant.now();
                         final Supplier<Future<Void>> onCloseAction = () -> removeCommandConsumer(tenantId, deviceId,
-                                sanitizedLifespan, lifespanStart, context);
+                                sanitizedLifespan, context);
                         return (MessageConsumer) new DeviceSpecificCommandConsumer(onCloseAction);
                     })
                     .setHandler(result);
@@ -197,34 +194,23 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
     }
 
     private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId, final Duration lifespan,
-            final Instant lifespanStart, final SpanContext createCommandConsumerSpanContext) {
+            final SpanContext createCommandConsumerSpanContext) {
         log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
         adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
 
-        final boolean lifespanReached = !lifespan.isNegative() && Instant.now().isAfter(lifespanStart.plus(lifespan));
-        // TODO when making handling of the lifespan property mandatory for implementors of the Device Connection API,
-        //  removing the adapter instance can be skipped here if 'lifespanReached' is true
         return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
                 .compose(client -> {
                     // The given span context from the createCommandConsumer invocation is only used here if a non-unlimited lifespan is set
                     // meaning creating and removing the consumer will probably happen in a timespan short enough for one overall trace.
-                    // The span context isn't used however if lifespanReached is true since the below 'remove' operation will usually (but not necessarily)
-                    // result in a "not found" error in that case, which is expected and should not cause the overall trace to be marked with an error.
-                    final SpanContext context = !lifespan.isNegative() && !lifespanReached ? createCommandConsumerSpanContext : null;
+                    final SpanContext context = !lifespan.isNegative() ? createCommandConsumerSpanContext : null;
                     return client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, context);
-                }).recover(thr -> {
-                    if (lifespanReached && thr instanceof ServiceInvocationException
-                            && ((ServiceInvocationException) thr).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-                        // entry was not found, meaning it has expired
-                        log.trace("ignoring 404 error when removing command handling adapter instance; entry has already expired [tenant: {}, device: {}]",
-                                tenantId, deviceId);
-                        return Future.succeededFuture();
-                    } else {
-                        log.info("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
-                                deviceId, thr);
-                        return Future.failedFuture(thr);
-                    }
-                });
+                })
+                .recover(thr -> {
+                    log.warn("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
+                            deviceId, thr);
+                    return Future.failedFuture(thr);
+                })
+                .mapEmpty();
     }
 
     private Future<MessageConsumer> getOrCreateMappingAndDelegatingCommandConsumer(final String tenantId) {
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
index f74d4ee5a..ea01e4c86 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
@@ -183,9 +183,10 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN removing the command handling adapter instance
         client.removeCommandHandlingAdapterInstance("deviceId", "gatewayId", span.context())
-                .setHandler(ctx.succeeding(r -> {
+                .setHandler(ctx.succeeding(result -> {
                     ctx.verify(() -> {
                         // THEN the response has been handled and the span is finished
+                        assertThat(result).isTrue();
                         verify(span).finish();
                     });
                     ctx.completeNow();
@@ -334,6 +335,34 @@ public class DeviceConnectionClientImplTest {
                 }));
     }
 
+    /**
+     * Verifies that a client invocation of the <em>remove-cmd-handling-adapter-instance</em> operation
+     * returns a <em>Boolean.FALSE</em> value if a <em>NOT_FOUND</em> response was returned.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testRemoveCommandHandlingAdapterInstanceForNotFoundEntry(final VertxTestContext ctx) {
+
+        // WHEN removing the command handling adapter instance
+        client.removeCommandHandlingAdapterInstance("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.succeeding(result -> {
+                    ctx.verify(() -> {
+                        // THEN the response has been handled and the span is finished
+                        assertThat(result).isFalse();
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+
+        final Message sentMessage = verifySenderSend();
+        final Message response = ProtonHelper.message();
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NOT_FOUND);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
+        response.setCorrelationId(sentMessage.getMessageId());
+        client.handleResponse(mock(ProtonDelivery.class), response);
+    }
+
     /**
      * Verifies that a client invocation of the <em>get-cmd-handling-adapter-instances</em> operation fails
      * if the device connection service cannot be reached.
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
index f1adb6787..9b93615fe 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
@@ -135,8 +135,10 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
         when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));
         when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
                 .thenReturn(Future.succeededFuture(devConClient));
-        when(devConClient.setCommandHandlingAdapterInstance(anyString(), anyString(), any(), any())).thenReturn(Future.succeededFuture());
-        when(devConClient.removeCommandHandlingAdapterInstance(anyString(), anyString(), any())).thenReturn(Future.succeededFuture());
+        when(devConClient.setCommandHandlingAdapterInstance(anyString(), anyString(), any(), any()))
+                .thenReturn(Future.succeededFuture());
+        when(devConClient.removeCommandHandlingAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(Boolean.TRUE));
 
         commandConsumerFactory = new ProtocolAdapterCommandConsumerFactoryImpl(connection);
         commandConsumerFactory.initialize(commandTargetMapper, deviceConnectionClientFactory);
