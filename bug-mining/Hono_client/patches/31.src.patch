diff --git a/client/src/main/java/org/eclipse/hono/client/MessageSender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
index ef8b2adf3..50598397f 100644
--- a/client/src/main/java/org/eclipse/hono/client/MessageSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
@@ -69,6 +69,33 @@ public interface MessageSender {
      */
     void sendQueueDrainHandler(Handler<Void> handler);
 
+    /**
+     * Sends an AMQP 1.0 message to the endpoint configured for this client.
+     * <p>
+     * The message will be sent immediately if this client has enough credit available on its
+     * link to the Hono server or it will be sent later after this client has been replenished
+     * with more credit. In both cases the handler will be notified <em>once only</em> when this
+     * sender has capacity available for accepting and sending the next message.
+     *
+     * @param message The message to send.
+     * @param capacityAvailableHandler The handler to notify when this sender can accept and send
+     *                                 another message.
+     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @throws NullPointerException if the message is {@code null}.
+     */
+    void send(Message message, Handler<Void> capacityAvailableHandler, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+
+    /**
+     * Sends an AMQP 1.0 message to the endpoint configured for this client.
+     *
+     * @param message The message to send.
+     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
+     *         the message is discarded and {@code false} is returned.
+     * @throws NullPointerException if the message is {@code null}.
+     */
+    boolean send(Message message, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+
     /**
      * Sends an AMQP 1.0 message to the endpoint configured for this client.
      * <p>
@@ -117,6 +144,30 @@ public interface MessageSender {
      */
     boolean send(String deviceId, String payload, String contentType, String registrationAssertion);
 
+    /**
+     * Sends a message for a given device to the endpoint configured for this client.
+     *
+     * @param deviceId The id of the device.
+     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
+     * @param payload The data to send.
+     *                The payload's byte representation will be contained in the message as an AMQP 1.0
+     *                <em>Data</em> section.
+     * @param contentType The content type of the payload.
+     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
+     *                    If the content type specifies a particular character set, this character set will be used to
+     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
+     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
+     *                              this sender has been created for.
+     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
+     *                              client} can be used to obtain such an assertion.
+     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
+     *         the message is discarded and {@code false} is returned.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
+     */
+    boolean send(String deviceId, String payload, String contentType, String registrationAssertion, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      * <p>
@@ -164,6 +215,26 @@ public interface MessageSender {
      */
     boolean send(String deviceId, byte[] payload, String contentType, String registrationAssertion);
 
+    /**
+     * Sends a message for a given device to the endpoint configured for this client.
+     *
+     * @param deviceId The id of the device.
+     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
+     * @param payload The data to send.
+     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload.
+     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
+     *                              this sender has been created for.
+     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
+     *                              client} can be used to obtain such an assertion.
+     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
+     *         the message is discarded and {@code false} is returned.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    boolean send(String deviceId, byte[] payload, String contentType, String registrationAssertion, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      * <p>
@@ -213,6 +284,32 @@ public interface MessageSender {
      */
     boolean send(String deviceId, Map<String, ?> properties, String payload, String contentType, String registrationAssertion);
 
+    /**
+     * Sends a message for a given device to the endpoint configured for this client.
+     *
+     * @param deviceId The id of the device.
+     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
+     * @param properties The application properties.
+     *                   AMQP application properties that can be used for carrying data in the message other than the payload
+     * @param payload The data to send.
+     *                The payload's byte representation will be contained in the message as an AMQP 1.0
+     *                <em>Data</em> section.
+     * @param contentType The content type of the payload.
+     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
+     *                    If the content type specifies a particular character set, this character set will be used to
+     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
+     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
+     *                              this sender has been created for.
+     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
+     *                              client} can be used to obtain such an assertion.
+     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
+     *         the message is discarded and {@code false} is returned.
+     * @throws NullPointerException if any of device id, payload or content type is {@code null}.
+     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
+     */
+    boolean send(String deviceId, Map<String, ?> properties, String payload, String contentType, String registrationAssertion, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      *
@@ -234,6 +331,28 @@ public interface MessageSender {
      */
     boolean send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType, String registrationAssertion);
 
+    /**
+     * Sends a message for a given device to the endpoint configured for this client.
+     *
+     * @param deviceId The id of the device.
+     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
+     * @param properties The application properties.
+     *                   AMQP application properties that can be used for carrying data in the message other than the payload
+     * @param payload The data to send.
+     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload.
+     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
+     *                              this sender has been created for.
+     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
+     *                              client} can be used to obtain such an assertion.
+     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
+     *         the message is discarded and {@code false} is returned.
+     * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
+     */
+    boolean send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType, String registrationAssertion, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      * <p>
@@ -310,11 +429,11 @@ public interface MessageSender {
     void setErrorHandler(Handler<AsyncResult<Void>> errorHandler);
 
     /**
-     * Sets a callback for disposition updates for messages sent with this {@link MessageSender}.
+     * Sets the default callback for disposition updates for messages sent with this {@link MessageSender}.
      *
      * @param dispositionHandler consumer that accepts a message id and updated disposition
      */
-    void setDispositionHandler(BiConsumer<Object, ProtonDelivery> dispositionHandler);
+    void setDefaultDispositionHandler(BiConsumer<Object, ProtonDelivery> dispositionHandler);
 
     /**
      * Closes the AMQP link with the Hono server this sender is using.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 615b7c5d2..8839cd7a7 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -51,13 +51,14 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     private static final Logger                LOG = LoggerFactory.getLogger(AbstractSender.class);
     private static final AtomicLong            MESSAGE_COUNTER = new AtomicLong();
     private static final Pattern               CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
+    private static final BiConsumer<Object, ProtonDelivery> DEFAULT_DISPOSITION_HANDLER = (messageId, delivery) -> LOG.trace("delivery state updated [message ID: {}, new remote state: {}]", messageId, delivery.getRemoteState());
 
     protected final String                     tenantId;
     protected final String                     targetAddress;
 
     private final Handler<String>              closeHook;
     private Handler<Void>                      drainHandler;
-    private BiConsumer<Object, ProtonDelivery> dispositionHandler = (messageId, delivery) -> LOG.trace("delivery state updated [message ID: {}, new remote state: {}]", messageId, delivery.getRemoteState());
+    private BiConsumer<Object, ProtonDelivery> defaultDispositionHandler = DEFAULT_DISPOSITION_HANDLER;
 
     AbstractSender(final ProtonSender sender, final String tenantId, final String targetAddress,
             final Context context, final Handler<String> closeHook) {
@@ -133,22 +134,23 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     }
 
     @Override
-    public final void setDispositionHandler(final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        this.dispositionHandler = dispositionHandler;
+    public final void setDefaultDispositionHandler(final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+        this.defaultDispositionHandler = dispositionHandler;
     }
 
     @Override
-    public final void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler) {
+    public final void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
         Objects.requireNonNull(rawMessage);
+        Objects.requireNonNull(dispositionHandler);
         if (capacityAvailableHandler == null) {
             context.runOnContext(send -> {
-                sendMessage(rawMessage);
+                sendMessage(rawMessage, dispositionHandler);
             });
         } else if (this.drainHandler != null) {
             throw new IllegalStateException("cannot send message while waiting for replenishment with credit");
         } else if (sender.isOpen()) {
             context.runOnContext(send -> {
-                sendMessage(rawMessage);
+                sendMessage(rawMessage, dispositionHandler);
                 if (sender.sendQueueFull()) {
                     sendQueueDrainHandler(capacityAvailableHandler);
                 } else {
@@ -161,28 +163,45 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     }
 
     @Override
-    public final boolean send(final Message rawMessage) {
+    public final boolean send(final Message rawMessage, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
         Objects.requireNonNull(rawMessage);
+        Objects.requireNonNull(dispositionHandler);
         if (sender.sendQueueFull()) {
             return false;
         } else {
             context.runOnContext(send -> {
-                sendMessage(rawMessage);
+                sendMessage(rawMessage, dispositionHandler);
             });
             return true;
         }
     }
 
-    private void sendMessage(final Message rawMessage) {
+    private void sendMessage(final Message rawMessage, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
         sender.send(rawMessage, deliveryUpdated -> dispositionHandler.accept(rawMessage.getMessageId(), deliveryUpdated));
         LOG.trace("sent message, remaining credit: {}, queued messages: {}", sender.getCredit(), sender.getQueued());
     }
 
+    @Override
+    public final void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler) {
+        send(rawMessage, capacityAvailableHandler, this.defaultDispositionHandler);
+    }
+
+    @Override
+    public final boolean send(final Message rawMessage) {
+        return send(rawMessage, this.defaultDispositionHandler);
+    }
+
     @Override
     public final boolean send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion) {
         return send(deviceId, null, payload, contentType, registrationAssertion);
     }
 
+    @Override
+    public final boolean send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion,
+            final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+        return send(deviceId, null, payload, contentType, registrationAssertion, dispositionHandler);
+    }
+
     @Override
     public final void send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion,
             final Handler<Void> capacityAvailableHandler) {
@@ -194,6 +213,12 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         return send(deviceId, null, payload, contentType, registrationAssertion);
     }
 
+    @Override
+    public final boolean send(final String deviceId, final String payload, final String contentType, final String registrationAssertion,
+            final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+        return send(deviceId, null, payload, contentType, registrationAssertion, dispositionHandler);
+    }
+
     @Override
     public final void send(final String deviceId, final String payload, final String contentType, final String registrationAssertion,
             final Handler<Void> capacityAvailableHandler) {
@@ -208,18 +233,33 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         return send(deviceId, properties, payload.getBytes(charset), contentType, registrationAssertion);
     }
 
+    @Override
+    public final boolean send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType,
+                              final String registrationAssertion, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+        Objects.requireNonNull(payload);
+        final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
+        return send(deviceId, properties, payload.getBytes(charset), contentType, registrationAssertion, dispositionHandler);
+    }
+
     @Override
     public final boolean send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType,
             final String registrationAssertion) {
+        return send(deviceId, properties, payload, contentType, registrationAssertion, this.defaultDispositionHandler);
+    }
+
+    @Override
+    public final boolean send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType,
+                              final String registrationAssertion, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(payload);
         Objects.requireNonNull(contentType);
         Objects.requireNonNull(registrationAssertion);
+        Objects.requireNonNull(dispositionHandler);
         final Message msg = ProtonHelper.message();
         msg.setBody(new Data(new Binary(payload)));
         setApplicationProperties(msg, properties);
         addProperties(msg, deviceId, contentType, registrationAssertion);
-        return send(msg);
+        return send(msg, dispositionHandler);
     }
 
     @Override
