diff --git a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
index 6e5376631..473e6fe2a 100644
--- a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
+++ b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
@@ -37,7 +37,7 @@ public interface ConnectionLifecycle {
      *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
      *         </ul>
      */
-    Future<HonoClient> connect();
+    Future<HonoConnection> connect();
 
     /**
      * Adds a listener to be notified when the connection is lost unexpectedly.
diff --git a/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java b/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
index 218019d82..475a3a1b7 100644
--- a/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
+++ b/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
@@ -27,5 +27,5 @@ public interface DisconnectListener {
      * 
      * @param client The client representing the connection to the service.
      */
-    void onDisconnect(HonoClient client);
+    void onDisconnect(HonoConnection client);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
similarity index 93%
rename from client/src/main/java/org/eclipse/hono/client/HonoClient.java
rename to client/src/main/java/org/eclipse/hono/client/HonoConnection.java
index 3d3b7ebd6..137adcbe0 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
@@ -14,7 +14,7 @@
 package org.eclipse.hono.client;
 
 import org.apache.qpid.proton.amqp.Symbol;
-import org.eclipse.hono.client.impl.HonoClientImpl;
+import org.eclipse.hono.client.impl.HonoConnectionImpl;
 import org.eclipse.hono.config.ClientConfigProperties;
 
 import io.vertx.core.AsyncResult;
@@ -63,7 +63,7 @@ import io.vertx.proton.ProtonConnection;
  * from the same Context or to make sure that the handlers are running on the correct Context, e.g. by using
  * the {@code Context}'s <em>runOnContext</em> method.
  */
-public interface HonoClient extends ConnectionLifecycle,
+public interface HonoConnection extends ConnectionLifecycle,
                                     DownstreamSenderFactory,
                                     ApplicationClientFactory,
                                     CredentialsClientFactory,
@@ -71,18 +71,19 @@ public interface HonoClient extends ConnectionLifecycle,
                                     TenantClientFactory {
 
     /**
-     * Creates a new client using the default implementation.
+     * Creates a new connection using the default implementation.
      * <p>
-     * <strong>Note:</strong> Instances of {@link ClientConfigProperties} are not thread safe and not immutable. They
-     * must not be modified after calling this method.
+     * <strong>Note:</strong> Instances of {@link ClientConfigProperties} are not thread safe and not immutable.
+     * They must therefore not be modified after calling this method.
      *
      * @param vertx The vert.x instance to use or {@code null}, if a new vert.x instance should be created.
      * @param clientConfigProperties The client properties to use.
-     * @return The created client.
+     * @return The newly created connection. Note that the underlying AMQP connection will not be established
+     *         until one of its <em>connect</em> methods is invoked.
      * @throws NullPointerException if properties are {@code null}.
      */
-    static HonoClient newClient(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
-        return new HonoClientImpl(vertx, clientConfigProperties);
+    static HonoConnection newConnection(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
+        return new HonoConnectionImpl(vertx, clientConfigProperties);
     }
 
     /**
@@ -100,7 +101,7 @@ public interface HonoClient extends ConnectionLifecycle,
      * <p>
      * The number of times that the client should try to establish the AMQP connection with the peer
      * can be configured by means of the <em>connectAttempts</em> property of the 
-     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * {@code ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)}
      * method.
      * <p>
      * When an established connection to the peer fails, the client will automatically try to re-connect
@@ -117,7 +118,7 @@ public interface HonoClient extends ConnectionLifecycle,
      *         </ul>
      */
     @Override
-    Future<HonoClient> connect();
+    Future<HonoConnection> connect();
 
     /**
      * Connects to the Hono server using given TCP client options.
@@ -133,7 +134,7 @@ public interface HonoClient extends ConnectionLifecycle,
      * <p>
      * The number of times that the client should try to establish the AMQP connection with the peer
      * can be configured by means of the <em>connectAttempts</em> property of the 
-     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * {@code ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)}
      * method.
      * <p>
      * When an established connection to the peer fails, the client will automatically try to re-connect
@@ -150,7 +151,7 @@ public interface HonoClient extends ConnectionLifecycle,
      *         </ul>
      * @throws NullPointerException if the options are {@code null}.
      */
-    Future<HonoClient> connect(ProtonClientOptions options);
+    Future<HonoConnection> connect(ProtonClientOptions options);
 
     /**
      * Connects to the Hono server using default options.
@@ -166,7 +167,7 @@ public interface HonoClient extends ConnectionLifecycle,
      * <p>
      * The number of times that the client should try to establish the AMQP connection with the peer
      * can be configured by means of the <em>connectAttempts</em> property of the 
-     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * {@code ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)}
      * method.
      * <p>
      * When an established connection to the peer fails, the given disconnect handler will be invoked.
@@ -182,7 +183,7 @@ public interface HonoClient extends ConnectionLifecycle,
      *         </ul>
      * @throws NullPointerException if the disconnect handler is {@code null}.
      */
-    Future<HonoClient> connect(Handler<ProtonConnection> disconnectHandler);
+    Future<HonoConnection> connect(Handler<ProtonConnection> disconnectHandler);
 
     /**
      * Connects to the Hono server using given options.
@@ -198,7 +199,7 @@ public interface HonoClient extends ConnectionLifecycle,
      * <p>
      * The number of times that the client should try to establish the AMQP connection with the peer
      * can be configured by means of the <em>connectAttempts</em> property of the 
-     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * {@code ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)}
      * method.
      * <p>
      * When an established connection to the peer fails, the given disconnect handler will be invoked.
@@ -217,7 +218,7 @@ public interface HonoClient extends ConnectionLifecycle,
      *         <li>the maximum number of (unsuccessful) (re-)connection attempts have been made.</li>
      *         </ul>
      */
-    Future<HonoClient> connect(
+    Future<HonoConnection> connect(
             ProtonClientOptions options,
             Handler<ProtonConnection> disconnectHandler);
 
diff --git a/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java b/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
index e5269dbf1..27fec7991 100644
--- a/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
+++ b/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
@@ -29,5 +29,5 @@ public interface ReconnectListener {
      * 
      * @param client The client representing the (re-established) connection to the service.
      */
-    void onReconnect(HonoClient client);
+    void onReconnect(HonoConnection client);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
index bbb754e3f..46526c13f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
@@ -36,7 +36,7 @@ import io.vertx.core.Vertx;
 /**
  * Implements a connection between an Adapter and the AMQP 1.0 network to receive commands and send a response.
  */
-public class CommandConsumerFactoryImpl extends HonoClientImpl implements CommandConsumerFactory {
+public class CommandConsumerFactoryImpl extends HonoConnectionImpl implements CommandConsumerFactory {
 
     /**
      * The minimum number of milliseconds to wait between checking a
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
similarity index 97%
rename from client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
rename to client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index ceec549f6..9a9eb861a 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -41,7 +41,7 @@ import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.CommandClient;
 import org.eclipse.hono.client.CredentialsClient;
 import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.HonoClient;
+import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.ReconnectListener;
@@ -85,12 +85,12 @@ import io.vertx.proton.sasl.SaslSystemException;
  * invocation of any of the connect methods will then use the same approach as
  * described above to determine the Context to use.
  */
-public class HonoClientImpl implements HonoClient {
+public class HonoConnectionImpl implements HonoConnection {
 
     /**
      * A logger to be shared with subclasses.
      */
-    protected final Logger log = LoggerFactory.getLogger(HonoClientImpl.class);
+    protected final Logger log = LoggerFactory.getLogger(HonoConnectionImpl.class);
     /**
      * The configuration properties for this client.
      */
@@ -141,7 +141,7 @@ public class HonoClientImpl implements HonoClient {
      * @param clientConfigProperties The configuration properties to use.
      * @throws NullPointerException if clientConfigProperties is {@code null}
      */
-    public HonoClientImpl(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
+    public HonoConnectionImpl(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
         this(vertx, null, clientConfigProperties);
     }
 
@@ -156,7 +156,7 @@ public class HonoClientImpl implements HonoClient {
      * @param clientConfigProperties The configuration properties to use.
      * @throws NullPointerException if clientConfigProperties is {@code null}
      */
-    public HonoClientImpl(final Vertx vertx, final ConnectionFactory connectionFactory,
+    public HonoConnectionImpl(final Vertx vertx, final ConnectionFactory connectionFactory,
             final ClientConfigProperties clientConfigProperties) {
 
         Objects.requireNonNull(clientConfigProperties);
@@ -340,7 +340,7 @@ public class HonoClientImpl implements HonoClient {
      * {@inheritDoc}
      */
     @Override
-    public final Future<HonoClient> connect() {
+    public final Future<HonoConnection> connect() {
         return connect(null, null);
     }
 
@@ -348,7 +348,7 @@ public class HonoClientImpl implements HonoClient {
      * {@inheritDoc}
      */
     @Override
-    public final Future<HonoClient> connect(final ProtonClientOptions options) {
+    public final Future<HonoConnection> connect(final ProtonClientOptions options) {
         return connect(Objects.requireNonNull(options), null);
     }
 
@@ -356,7 +356,7 @@ public class HonoClientImpl implements HonoClient {
      * {@inheritDoc}
      */
     @Override
-    public final Future<HonoClient> connect(final Handler<ProtonConnection> disconnectHandler) {
+    public final Future<HonoConnection> connect(final Handler<ProtonConnection> disconnectHandler) {
         return connect(null, Objects.requireNonNull(disconnectHandler));
     }
 
@@ -364,11 +364,11 @@ public class HonoClientImpl implements HonoClient {
      * {@inheritDoc}
      */
     @Override
-    public final Future<HonoClient> connect(
+    public final Future<HonoConnection> connect(
             final ProtonClientOptions options,
             final Handler<ProtonConnection> disconnectHandler) {
 
-        final Future<HonoClient> result = Future.future();
+        final Future<HonoConnection> result = Future.future();
         if (shuttingDown.get()) {
             result.fail(new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "client is already shut down"));
         } else {
@@ -379,7 +379,7 @@ public class HonoClientImpl implements HonoClient {
 
     private void connect(
             final ProtonClientOptions options,
-            final Handler<AsyncResult<HonoClient>> connectionHandler,
+            final Handler<AsyncResult<HonoConnection>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
 
         context = vertx.getOrCreateContext();
@@ -479,7 +479,7 @@ public class HonoClientImpl implements HonoClient {
         }
     }
 
-    private void notifyReconnectHandlers(final AsyncResult<HonoClient> reconnectAttempt) {
+    private void notifyReconnectHandlers(final AsyncResult<HonoConnection> reconnectAttempt) {
         if (reconnectAttempt.succeeded()) {
             for (ReconnectListener listener : reconnectListeners) {
                 listener.onReconnect(this);
@@ -517,14 +517,14 @@ public class HonoClientImpl implements HonoClient {
         }
     }
 
-    private void reconnect(final Handler<AsyncResult<HonoClient>> connectionHandler,
+    private void reconnect(final Handler<AsyncResult<HonoConnection>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
         reconnect(null, connectionHandler, disconnectHandler);
     }
 
     private void reconnect(
             final Throwable connectionFailureCause,
-            final Handler<AsyncResult<HonoClient>> connectionHandler,
+            final Handler<AsyncResult<HonoConnection>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
 
         if (shuttingDown.get()) {
@@ -558,7 +558,7 @@ public class HonoClientImpl implements HonoClient {
                 (connectionFailureCause instanceof SaslSystemException && ((SaslSystemException) connectionFailureCause).isPermanent());
     }
 
-    private void failConnectionAttempt(final Throwable connectionFailureCause, final Handler<AsyncResult<HonoClient>> connectionHandler) {
+    private void failConnectionAttempt(final Throwable connectionFailureCause, final Handler<AsyncResult<HonoConnection>> connectionHandler) {
 
         log.info("stopping connection attempt to server [host: {}, port: {}] due to terminal error",
                 connectionFactory.getHost(), connectionFactory.getPort(), connectionFailureCause);
@@ -881,7 +881,7 @@ public class HonoClientImpl implements HonoClient {
      * Creates a new instance of {@link CredentialsClient} scoped for the given tenant identifier.
      * <p>
      * Custom implementation of {@link CredentialsClient} can be instantiated by overriding this method. Any such
-     * instance should be scoped to the given tenantId. Custom extension of {@link HonoClientImpl} must invoke
+     * instance should be scoped to the given tenantId. Custom extension of {@link HonoConnectionImpl} must invoke
      * {@link #removeCredentialsClient(String)} to cleanup when finished with the client.
      *
      * @param tenantId tenant scope for which the client is instantiated
@@ -948,7 +948,7 @@ public class HonoClientImpl implements HonoClient {
      * Creates a new instance of {@link RegistrationClient} scoped for the given tenantId.
      * <p>
      * Custom implementation of {@link RegistrationClient} can be instantiated by overriding this method. Any such
-     * instance should be scoped to the given tenantId. Custom extension of {@link HonoClientImpl} must invoke
+     * instance should be scoped to the given tenantId. Custom extension of {@link HonoConnectionImpl} must invoke
      * {@link #removeRegistrationClient(String)} to cleanup when finished with the client.
      *
      * @param tenantId tenant scope for which the client is instantiated
@@ -1005,7 +1005,7 @@ public class HonoClientImpl implements HonoClient {
      * Creates a new instance of {@link TenantClient}.
      * <p>
      * Custom implementation of {@link TenantClient} can be instantiated by overriding this method.
-     * Custom extension of {@link HonoClientImpl} must invoke
+     * Custom extension of {@link HonoConnectionImpl} must invoke
      * {@link #removeTenantClient()} to cleanup when finished with the client.
      *
      * @return a future containing an instance of {@link TenantClient}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
similarity index 86%
rename from client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
rename to client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index 6ae9a8486..11ec0873b 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -27,6 +27,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 import javax.security.sasl.AuthenticationException;
 
 import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.client.RequestResponseClient;
@@ -54,11 +55,11 @@ import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.sasl.SaslSystemException;
 
 /**
- * Test cases verifying the behavior of {@code HonoClient}.
+ * Test cases verifying the behavior of {@link HonoConnection}.
  *
  */
 @RunWith(VertxUnitRunner.class)
-public class HonoClientImplTest {
+public class HonoConnectionImplTest {
 
     /**
      * Global timeout for each test case.
@@ -70,7 +71,7 @@ public class HonoClientImplTest {
     private ProtonConnection con;
     private DisconnectHandlerProvidingConnectionFactory connectionFactory;
     private ClientConfigProperties props;
-    private HonoClientImpl client;
+    private HonoConnectionImpl honoConnection;
 
     /**
      * Sets up fixture.
@@ -90,7 +91,7 @@ public class HonoClientImplTest {
         when(con.getRemoteContainer()).thenReturn("server");
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
         props = new ClientConfigProperties();
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
     }
 
     /**
@@ -109,10 +110,10 @@ public class HonoClientImplTest {
         // expect three unsuccessful connection attempts
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
                 .setExpectedFailingConnectionAttempts(3);
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        client.connect().setHandler(ctx.asyncAssertFailure(t -> {
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
             // THEN the connection attempt fails
             ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) t).getErrorCode());
         }));
@@ -136,10 +137,10 @@ public class HonoClientImplTest {
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
                 .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
                 .failWith(new AuthenticationException("Failed to authenticate"));
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        client.connect().setHandler(ctx.asyncAssertFailure(t -> {
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
             // THEN the connection attempt fails due do lack of authorization
             ctx.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, ((ServiceInvocationException) t).getErrorCode());
         }));
@@ -154,7 +155,7 @@ public class HonoClientImplTest {
      * @param ctx The vert.x test client.
      */
     @Test
-    public void testConnectFailsWithClientErrorForNoSASLMechanismException(final TestContext ctx) {
+    public void testConnectFailsWithClientErrorForNoSaslMechanismException(final TestContext ctx) {
 
         // GIVEN a client that is configured to connect
         // to a peer that always throws a SaslSystemException (as if no credentials were given)
@@ -162,11 +163,12 @@ public class HonoClientImplTest {
         props.setConnectTimeout(10);
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
                 .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
-                .failWith(new SaslSystemException(true, "Could not find a suitable SASL mechanism for the remote peer using the available credentials."));
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+                .failWith(new SaslSystemException(
+                        true, "Could not find a suitable SASL mechanism for the remote peer using the available credentials."));
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        client.connect().setHandler(ctx.asyncAssertFailure(t -> {
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
             // THEN the connection attempt fails due do lack of authorization
             ctx.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, ((ServiceInvocationException) t).getErrorCode());
             ctx.assertEquals("no suitable SASL mechanism found for authentication with server", t.getMessage());
@@ -191,10 +193,10 @@ public class HonoClientImplTest {
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
                 .setExpectedFailingConnectionAttempts(3)
                 .failWith(new SaslSystemException(false, "SASL handshake failed due to a transient error"));
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        client.connect().setHandler(ctx.asyncAssertFailure(t -> {
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
             // THEN the connection attempt fails
             ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServiceInvocationException) t).getErrorCode());
         }));
@@ -218,10 +220,10 @@ public class HonoClientImplTest {
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
                 .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
                 .failWith(new SaslSystemException(true, "SASL handshake failed due to an unrecoverable error"));
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        client.connect().setHandler(ctx.asyncAssertFailure(t -> {
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
             // THEN the connection attempt fails
             ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServiceInvocationException) t).getErrorCode());
         }));
@@ -238,7 +240,7 @@ public class HonoClientImplTest {
     @Test
     public void testGetOrCreateRequestResponseClientFailsWhenNotConnected(final TestContext ctx) {
 
-        client.getOrCreateRequestResponseClient("the-key", () -> Future.succeededFuture(mock(RequestResponseClient.class)))
+        honoConnection.getOrCreateRequestResponseClient("the-key", () -> Future.succeededFuture(mock(RequestResponseClient.class)))
         .setHandler(ctx.asyncAssertFailure(t -> {
             ctx.assertTrue(t instanceof ServerErrorException);
         }));
@@ -255,15 +257,15 @@ public class HonoClientImplTest {
 
         // GIVEN a client that already tries to create a registration client for "tenant"
         final Async connected = ctx.async();
-        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
+        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
-        client.getOrCreateRequestResponseClient(
+        honoConnection.getOrCreateRequestResponseClient(
                 "registration/tenant",
                 () -> Future.future());
 
         // WHEN an additional, concurrent attempt is made to create a client for "tenant"
-        client.getOrCreateRequestResponseClient(
+        honoConnection.getOrCreateRequestResponseClient(
                 "registration/tenant",
                 () -> {
                     ctx.fail("should not create concurrent client");
@@ -285,13 +287,13 @@ public class HonoClientImplTest {
 
         // GIVEN a client that tries to create a registration client for "tenant"
         final Async connected = ctx.async();
-        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
+        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async creationFailure = ctx.async();
         final Async supplierInvocation = ctx.async();
 
-        client.getOrCreateRequestResponseClient(
+        honoConnection.getOrCreateRequestResponseClient(
                 "registration/tenant",
                 () -> {
                     ctx.assertFalse(creationFailure.isCompleted());
@@ -317,13 +319,13 @@ public class HonoClientImplTest {
 
         // GIVEN a client that already tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
-        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
+        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
-        client.getOrCreateSender("telemetry/tenant", () -> Future.future());
+        honoConnection.getOrCreateSender("telemetry/tenant", () -> Future.future());
 
         // WHEN an additional, concurrent attempt is made to create a telemetry sender for "tenant"
-        client.getOrCreateSender(
+        honoConnection.getOrCreateSender(
                 "telemetry/tenant",
                 () -> {
                     ctx.fail("should not create concurrent client");
@@ -345,13 +347,13 @@ public class HonoClientImplTest {
 
         // GIVEN a client that tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
-        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
+        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async disconnected = ctx.async();
         final Async supplierInvocation = ctx.async();
 
-        client.getOrCreateSender(
+        honoConnection.getOrCreateSender(
                 "telemetry/tenant",
                 () -> {
                     ctx.assertFalse(disconnected.isCompleted());
@@ -380,12 +382,12 @@ public class HonoClientImplTest {
 
         // GIVEN a connected client that already tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
-        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
+        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async creationFailure = ctx.async();
         final Async supplierInvocation = ctx.async();
-        client.createConsumer("tenant", () -> {
+        honoConnection.createConsumer("tenant", () -> {
             supplierInvocation.complete();
             return Future.future();
         }).setHandler(ctx.asyncAssertFailure(cause -> {
@@ -416,14 +418,14 @@ public class HonoClientImplTest {
         final ProtonClientOptions options = new ProtonClientOptions()
                 .setReconnectInterval(50)
                 .setReconnectAttempts(0);
-        client = new HonoClientImpl(vertx, connectionFactory, props);
-        client.connect(options).setHandler(ctx.asyncAssertSuccess());
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+        honoConnection.connect(options).setHandler(ctx.asyncAssertSuccess());
         assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // WHEN the downstream connection fails just when the client wants to open a sender link
         final Async senderCreationFailure = ctx.async();
-        client.getOrCreateSender("telemetry/tenant", () -> {
+        honoConnection.getOrCreateSender("telemetry/tenant", () -> {
             connectionFactory.getDisconnectHandler().handle(con);
             return Future.future();
         }).setHandler(ctx.asyncAssertFailure(cause -> senderCreationFailure.complete()));
@@ -433,7 +435,7 @@ public class HonoClientImplTest {
         // the connection is re-established
         assertTrue(connectionFactory.await());
         // and the next attempt to create a sender succeeds
-        client.getOrCreateSender(
+        honoConnection.getOrCreateSender(
                 "telemetry/tenant",
                 () -> Future.succeededFuture(mock(MessageSender.class))).setHandler(ctx.asyncAssertSuccess());
     }
@@ -453,8 +455,8 @@ public class HonoClientImplTest {
         final ProtonClientOptions options = new ProtonClientOptions()
                 .setReconnectInterval(50)
                 .setReconnectAttempts(0);
-        client = new HonoClientImpl(vertx, connectionFactory, props);
-        client.connect(options).setHandler(ctx.asyncAssertSuccess());
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+        honoConnection.connect(options).setHandler(ctx.asyncAssertSuccess());
         assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
@@ -486,11 +488,11 @@ public class HonoClientImplTest {
                 .setExpectedFailingConnectionAttempts(2);
         props.setReconnectAttempts(2);
         props.setConnectTimeout(10);
-        client = new HonoClientImpl(vertx, connectionFactory, props);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN trying to connect
         final Async disconnectHandlerInvocation = ctx.async();
-        client.connect(null, failedCon -> disconnectHandlerInvocation.complete()).setHandler(ctx.asyncAssertSuccess());
+        honoConnection.connect(null, failedCon -> disconnectHandlerInvocation.complete()).setHandler(ctx.asyncAssertSuccess());
 
         // THEN the client fails twice to connect
         assertTrue(connectionFactory.awaitFailure());
@@ -514,7 +516,7 @@ public class HonoClientImplTest {
         // GIVEN a client that is connected to a server
         final Async connected = ctx.async();
         final Async disconnectHandlerInvocation = ctx.async();
-        client.connect(
+        honoConnection.connect(
                 new ProtonClientOptions().setReconnectAttempts(1),
                 failedCon -> disconnectHandlerInvocation.complete())
             .setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
@@ -539,11 +541,11 @@ public class HonoClientImplTest {
     @Test
     public void testConnectFailsAfterShutdown(final TestContext ctx) {
 
-        client.connect().compose(ok -> {
+        honoConnection.connect().compose(ok -> {
             // GIVEN a client that is in the process of shutting down
-            client.shutdown(Future.future());
+            honoConnection.shutdown(Future.future());
             // WHEN the client tries to reconnect before shut down is complete
-            return client.connect();
+            return honoConnection.connect();
         }).setHandler(ctx.asyncAssertFailure(cause -> {
             // THEN the connection attempt fails
             ctx.assertEquals(HttpURLConnection.HTTP_CONFLICT, ((ClientErrorException) cause).getErrorCode());
@@ -559,18 +561,18 @@ public class HonoClientImplTest {
     @Test
     public void testConnectSucceedsAfterDisconnect(final TestContext ctx) {
 
-        client.connect().compose(ok -> {
+        honoConnection.connect().compose(ok -> {
             // GIVEN a client that is connected to a server
             final Future<Void> disconnected = Future.future();
             // WHEN the client disconnects
-            client.disconnect(disconnected);
+            honoConnection.disconnect(disconnected);
             final ArgumentCaptor<Handler<AsyncResult<ProtonConnection>>> closeHandler = ArgumentCaptor.forClass(Handler.class);
             verify(con).closeHandler(closeHandler.capture());
             closeHandler.getValue().handle(Future.succeededFuture(con));
             return disconnected;
         }).compose(d -> {
             // AND tries to reconnect again
-            return client.connect(new ProtonClientOptions());
+            return honoConnection.connect(new ProtonClientOptions());
         }).setHandler(ctx.asyncAssertSuccess(success -> {
             // THEN the connection succeeds
         }));
@@ -595,13 +597,13 @@ public class HonoClientImplTest {
             final Handler<AsyncResult<ProtonConnection>> resultHandler = invocation.getArgument(3);
             if (connectAttempts.incrementAndGet() == 3) {
                 // WHEN client gets shutdown
-                client.shutdown();
+                honoConnection.shutdown();
             }
             resultHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)));
             return null;
         }).when(factory).connect(any(), any(Handler.class), any(Handler.class), any(Handler.class));
-        client = new HonoClientImpl(vertx, factory, props);
-        client.connect().setHandler(
+        honoConnection = new HonoConnectionImpl(vertx, factory, props);
+        honoConnection.connect().setHandler(
                 ctx.asyncAssertFailure(cause -> {
                     // THEN three attempts have been made to connect
                     ctx.assertTrue(connectAttempts.get() == 3);
