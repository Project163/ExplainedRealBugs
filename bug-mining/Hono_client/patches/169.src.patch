diff --git a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
index 19463e823..a5b87be55 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
@@ -142,10 +142,11 @@ public interface HonoConnection extends ConnectionLifecycle<HonoConnection> {
     /**
      * Connects to the Hono server using given TCP client options.
      * <p>
-     * The client will try to establish a TCP connection to the peer based on the values of the
-     * <em>connectTimeout</em>, <em>reconnectAttempts</em> and <em>reconnectInterval</em> properties
-     * of the given options. Note that each connection attempt is made using the same IP
-     * address that has been resolved when the method was initially invoked.
+     * The client will try to establish a TCP connection to the peer based on the given options.
+     * If no options are given, the used default properties will have the <em>connectTimeout</em> and
+     * <em>heartBeat</em> values from the {@link ClientConfigProperties}. Note that each connection
+     * attempt is made using the same IP address that has been resolved when the method was initially
+     * invoked.
      * <p>
      * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
      * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index 8541a73a8..ff19077c2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -20,6 +20,7 @@ import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -37,7 +38,6 @@ import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.HonoProtonHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -482,7 +482,10 @@ public class HonoConnectionImpl implements HonoConnection {
             // no need to try to re-connect
             log.info("client is shutting down, giving up attempt to connect");
             connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
-        } else if (clientConfigProperties.getReconnectAttempts() - connectAttempts.getAndIncrement() == 0) {
+            return;
+        }
+        final int reconnectAttempt = connectAttempts.getAndIncrement();
+        if (clientConfigProperties.getReconnectAttempts() - reconnectAttempt == 0) {
             log.info("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
                     clientConfigProperties.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
             clearState();
@@ -492,14 +495,27 @@ public class HonoConnectionImpl implements HonoConnection {
             if (connectionFailureCause != null) {
                 log.debug("connection attempt failed", connectionFailureCause);
             }
-            final long reconnectInterval = Optional.ofNullable(clientOptions)
-                    .map(o -> o.getReconnectInterval())
-                    .orElse(Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS);
-            log.trace("scheduling new connection attempt in {}ms ...", reconnectInterval);
-            // give Vert.x some time to clean up NetClient
-            vertx.setTimer(reconnectInterval, tid -> {
+            // apply exponential backoff with jitter
+            // determine the max delay for this reconnect attempt as 2^attempt * delayIncrement
+            final long currentMaxDelay = (long) Math.pow(2, reconnectAttempt - 1)
+                    * clientConfigProperties.getReconnectDelayIncrement();
+            final long reconnectInterval;
+            if (currentMaxDelay > clientConfigProperties.getReconnectMinDelay()) {
+                // let the actual reconnect delay be a random between the minDelay and the currentMaxDelay,
+                // capped by the overall maxDelay
+                reconnectInterval = ThreadLocalRandom.current().nextLong(clientConfigProperties.getReconnectMinDelay(),
+                        Math.min(clientConfigProperties.getReconnectMaxDelay(), currentMaxDelay));
+            } else {
+                reconnectInterval = clientConfigProperties.getReconnectMinDelay();
+            }
+            if (reconnectInterval > 0) {
+                log.trace("scheduling new connection attempt in {}ms ...", reconnectInterval);
+                vertx.setTimer(reconnectInterval, tid -> {
+                    connect(clientOptions, connectionHandler, disconnectHandler);
+                });
+            } else {
                 connect(clientOptions, connectionHandler, disconnectHandler);
-            });
+            }
         }
     }
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index 9389e92d0..4f5f85e63 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -26,6 +26,7 @@ import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -140,6 +141,40 @@ public class HonoConnectionImplTest {
         assertTrue(connectionFactory.awaitFailure());
     }
 
+    /**
+     * Verifies that the delay between reconnect attempts conforms
+     * to how it is configured in the ClientConfigProperties.
+     *
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testReconnectDelay(final TestContext ctx) {
+
+        // GIVEN a client that is configured to reconnect 5 times with custom delay times.
+        final int reconnectAttempts = 5;
+        props.setReconnectAttempts(reconnectAttempts);
+        props.setReconnectMinDelay(10);
+        props.setReconnectMaxDelay(1000);
+        props.setReconnectDelayIncrement(100);
+        props.setConnectTimeout(10);
+        // expect 6 unsuccessful connection attempts
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(reconnectAttempts + 1);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+
+        // WHEN the client tries to connect
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
+            // THEN the connection attempt fails
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) t).getErrorCode());
+        }));
+        // and the client has indeed tried 6 times in total before giving up
+        assertTrue(connectionFactory.awaitFailure());
+        final ArgumentCaptor<Long> delayValueCaptor = ArgumentCaptor.forClass(Long.class);
+        verify(vertx, times(reconnectAttempts)).setTimer(delayValueCaptor.capture(), anyHandler());
+        // and the first delay period is the minDelay value
+        ctx.assertEquals(10L, delayValueCaptor.getAllValues().get(0));
+    }
+
     /**
      * Verifies that the client fails with a ClientErrorException with status code 401
      * if it cannot authenticate to the server due to wrong credentials.
@@ -262,7 +297,6 @@ public class HonoConnectionImplTest {
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
         props.setReconnectAttempts(1);
         final ProtonClientOptions options = new ProtonClientOptions()
-                .setReconnectInterval(50)
                 .setReconnectAttempts(0);
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
         honoConnection.connect(options).setHandler(ctx.asyncAssertSuccess());
