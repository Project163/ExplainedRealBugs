diff --git a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
deleted file mode 100644
index 545331651..000000000
--- a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/**
- * Copyright (c) 2019, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-package org.eclipse.hono.client;
-
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.impl.ApplicationClientFactoryImpl;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * A factory for creating clients for Hono's north bound APIs.
- *
- * @deprecated Use {@code org.eclipse.hono.application.client.ApplicationClient} instead.
- */
-@Deprecated
-public interface ApplicationClientFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static ApplicationClientFactory create(final HonoConnection connection) {
-        return create(connection, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param samplerFactory The sampler to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static ApplicationClientFactory create(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        return new ApplicationClientFactoryImpl(connection, samplerFactory);
-    }
-
-    /**
-     * Creates a client for consuming data from Hono's north bound <em>Telemetry API</em>.
-     *
-     * @param tenantId The tenant to consume data for.
-     * @param telemetryConsumer The handler to invoke with every message received.
-     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)
-     *                   after the message handler runs for them, if no other disposition has been applied
-     *                   during handling. NOTE: When using {@code false} here, make sure that deliveries are
-     *                   quickly updated and settled, so that the messages don't remain <em>in flight</em>
-     *                   for long.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this factory
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createTelemetryConsumer(
-            String tenantId,
-            BiConsumer<ProtonDelivery, Message> telemetryConsumer,
-            boolean autoAccept,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming data from Hono's north bound <em>Telemetry API</em>.
-     * <p>
-     * The messages passed in to the consumer will be accepted and settled automatically if the consumer
-     * does not throw an exception.
-     *
-     * @param tenantId The tenant to consume data for.
-     * @param telemetryConsumer The handler to invoke with every message received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this factory
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createTelemetryConsumer(
-            String tenantId,
-            Consumer<Message> telemetryConsumer,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
-     *
-     * @param tenantId The tenant to consume events for.
-     * @param eventConsumer The handler to invoke with every event received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)
-     *                   after the message handler runs for them, if no other disposition has been applied
-     *                   during handling. NOTE: When using {@code false} here, make sure that deliveries are
-     *                   quickly updated and settled, so that the messages don't remain <em>in flight</em>
-     *                   for long.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this factory
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createEventConsumer(
-            String tenantId,
-            BiConsumer<ProtonDelivery, Message> eventConsumer,
-            boolean autoAccept,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
-     * <p>
-     * The events passed in to the event consumer will be accepted and settled automatically if
-     * the consumer does not throw an exception and does not manually handle the message disposition
-     * using the passed in delivery.
-     *
-     * @param tenantId The tenant to consume events for.
-     * @param eventConsumer The handler to invoke with every event received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this factory
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createEventConsumer(
-            String tenantId,
-            BiConsumer<ProtonDelivery, Message> eventConsumer,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
-     * <p>
-     * The events passed in to the event consumer will be accepted and settled automatically if
-     * the consumer does not throw an exception.
-     *
-     * @param tenantId The tenant to consume events for.
-     * @param eventConsumer The handler to invoke with every event received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this factory
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createEventConsumer(
-            String tenantId,
-            Consumer<Message> eventConsumer,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming responses to commands that have been sent asynchronously
-     * using Hono's north bound <em>Command &amp; Control API</em>.
-     * <p>
-     * The command responses passed in to the consumer will be accepted and settled automatically
-     * if the consumer does not throw an exception.
-     *
-     * @param tenantId The tenant to consume command responses for.
-     * @param replyId The replyId of commands to consume command responses for.
-     * @param consumer The handler to invoke with every command response received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this factory
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @see org.eclipse.hono.client.AsyncCommandClient
-     */
-    Future<MessageConsumer> createAsyncCommandResponseConsumer(String tenantId, String replyId,
-            Consumer<Message> consumer, Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming async command responses from Hono's north bound <em>Command API</em>.
-     * <p>
-     * The command responses passed in to the responses consumer will be accepted and settled automatically
-     * if the consumer does not throw an exception and does not manually handle the message disposition using
-     * the passed in delivery.
-     *
-     * @param tenantId The tenant to consume command responses for.
-     * @param replyId The replyId of commands to consume command responses for.
-     * @param consumer The handler to invoke with every command response received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established.
-     *         The future will fail if the link cannot be established, e.g. because this client
-     *         is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @see org.eclipse.hono.client.AsyncCommandClient
-     */
-    Future<MessageConsumer> createAsyncCommandResponseConsumer(String tenantId, String replyId,
-            BiConsumer<ProtonDelivery, Message> consumer, Handler<Void> closeHandler);
-
-    /**
-     * Gets a client for sending commands to devices of the given tenant.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     * <p>
-     * This method will use an implementation specific mechanism (e.g. a UUID) to create
-     * a unique reply-to address to be included in commands sent to devices of the tenant.
-     * The protocol adapters need to convey an encoding of the reply-to address to the device
-     * when delivering the command. Consequently, the number of bytes transferred to the device
-     * depends on the length of the reply-to address being used. In situations where this is a
-     * major concern it might be advisable to use {@link #getOrCreateCommandClient(String, String)}
-     * for creating a command client and provide custom (and shorter) <em>reply-to identifier</em>
-     * to be used in the reply-to address.
-     *
-     * @param tenantId The tenant of the devices to which commands shall be sent.
-     * @return A future that will complete with the command and control client (if successful) or
-     *         fail if the client cannot be created, e.g. because the underlying connection
-     *         is not established or if a concurrent request to create a client for the same
-     *         tenant is already being executed.
-     * @throws NullPointerException if the tenantId is {@code null}.
-     */
-    Future<CommandClient> getOrCreateCommandClient(String tenantId);
-
-    /**
-     * Gets a client for sending commands to devices of the given tenant.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant and replyId.
-     *
-     * @param tenantId The tenant of the devices to which commands shall be sent.
-     * @param replyId An arbitrary string which will be used to create the reply-to address to be included in
-     *                commands sent to devices of the tenant. The combination of tenant and replyId has to be
-     *                unique among all CommandClient instances to make sure command response messages can be received.
-     * @return A future that will complete with the command and control client (if successful) or
-     *         fail if the client cannot be created, e.g. because the underlying connection
-     *         is not established or if a concurrent request to create a client for the same
-     *         tenant and replyId is already being executed.
-     * @throws NullPointerException if tenantId or replyId is {@code null}.
-     */
-    Future<CommandClient> getOrCreateCommandClient(String tenantId, String replyId);
-
-    /**
-     * Gets a client for sending commands to devices of the given tenant asynchronously, i.e. command responses
-     * get received by a separate receiver.
-     * <p>
-     * The client returned may be either newly created or it may be an existing client for the given tenant.
-     *
-     * @param tenantId The tenant of the devices to which commands shall be sent.
-     * @return A future that will complete with the command client (if successful) or
-     *         fail if the client cannot be created, e.g. because the underlying connection
-     *         is not established or if a concurrent request to create a client for the same
-     *         tenant is already being executed.
-     * @throws NullPointerException if tenantId is {@code null}.
-     */
-    Future<AsyncCommandClient> getOrCreateAsyncCommandClient(String tenantId);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/AsyncCommandClient.java b/client/src/main/java/org/eclipse/hono/client/AsyncCommandClient.java
deleted file mode 100644
index 4713bcd84..000000000
--- a/client/src/main/java/org/eclipse/hono/client/AsyncCommandClient.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-package org.eclipse.hono.client;
-
-import java.util.Map;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.buffer.Buffer;
-
-/**
- * A client for sending asynchronous request response commands.
- * <p>
- * An instance of this interface is always scoped to a specific tenant and device.
- *
- * @deprecated Use {@code org.eclipse.hono.application.client.ApplicationClient} instead.
- */
-@Deprecated
-public interface AsyncCommandClient extends MessageSender {
-
-    /**
-     * Sends an async command to a device, i.e. there is no immediate response expected from the device, but
-     * asynchronously via a separate consumer.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload any data for it. The device also needs
-     * to be connected for a successful delivery.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The command name.
-     * @param data The command data to send to the device or {@code null} if the command has no input data.
-     * @param correlationId The identifier to use for correlating the response with the request. Note: This parameter is
-     *            security sensitive. To ensure secure request response mapping choose correlationId carefully, e.g.
-     *            {@link java.util.UUID#randomUUID()}.
-     * @param replyId An arbitrary string which gets used for the response link address in the form of
-     *            <em>command_response/${tenantId}/${replyId}</em>. Must match the {@code replyId} passed to the
-     *            command response receiver, see also below.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         If the command was accepted, the future will succeed.
-     *         <p>
-     *         The future will fail with a {@link ServiceInvocationException} if the command could not be forwarded to
-     *         the device.
-     * @throws NullPointerException if command, correlationId or replyId is {@code null}.
-     * @see ApplicationClientFactory#createAsyncCommandResponseConsumer(String, String,
-     *      java.util.function.Consumer, io.vertx.core.Handler)
-     * @see ApplicationClientFactory#createAsyncCommandResponseConsumer(String, String,
-     *      java.util.function.BiConsumer, io.vertx.core.Handler)
-     */
-    Future<Void> sendAsyncCommand(String deviceId, String command, Buffer data, String correlationId, String replyId);
-
-    /**
-     * Sends an async command to a device, i.e. there is no immediate response expected from the device, but
-     * asynchronously via a separate consumer.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload any data for it. The device also needs
-     * to be connected for a successful delivery.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The command name.
-     * @param contentType The type of the data submitted as part of the command or {@code null} if unknown.
-     * @param data The command data to send to the device or {@code null} if the command has no input data.
-     * @param correlationId The identifier to use for correlating the response with the request. Note: This parameter is
-     *            security sensitive. To ensure secure request response mapping choose correlationId carefully, e.g.
-     *            {@link java.util.UUID#randomUUID()}.
-     * @param replyId An arbitrary string which gets used for response link address in the form of
-     *            <em>command_response/${tenantId}/${replyId}</em>. Must match the {@code replyId} passed to the command
-     *            response receiver, see also below.
-     * @param properties The headers to include in the command message as AMQP application properties.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         If the command was accepted, the future will succeed.
-     *         <p>
-     *         The future will fail with a {@link ServiceInvocationException} if the command could not be forwarded to
-     *         the device.
-     * @throws NullPointerException if command, correlationId or replyId is {@code null}.
-     * @see ApplicationClientFactory#createAsyncCommandResponseConsumer(String, String,
-     *      java.util.function.Consumer, io.vertx.core.Handler)
-     * @see ApplicationClientFactory#createAsyncCommandResponseConsumer(String, String,
-     *      java.util.function.BiConsumer, io.vertx.core.Handler)
-     */
-    Future<Void> sendAsyncCommand(String deviceId, String command, String contentType, Buffer data, String correlationId, String replyId,
-            Map<String, Object> properties);
-
-    /**
-     * Sends an async command to a device, i.e. there is no immediate response expected from the device, but
-     * asynchronously via a separate consumer.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload any data for it. The device also needs
-     * to be connected for a successful delivery.
-     * <p>
-     * This default implementation simply returns the result of {@link #sendAsyncCommand(String, String, String, Buffer, String, String, Map)}.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The command name.
-     * @param contentType The type of the data submitted as part of the command or {@code null} if unknown.
-     * @param data The command data to send to the device or {@code null} if the command has no input data.
-     * @param correlationId The identifier to use for correlating the response with the request. Note: This parameter is
-     *            security sensitive. To ensure secure request response mapping choose correlationId carefully, e.g.
-     *            {@link java.util.UUID#randomUUID()}.
-     * @param replyId An arbitrary string which gets used for response link address in the form of
-     *            <em>command_response/${tenantId}/${replyId}</em>. Must match the {@code replyId} passed to the command
-     *            response receiver, see also below.
-     * @param properties The headers to include in the command message as AMQP application properties.
-     * @param context The currently active OpenTracing span. An implementation should use this as the parent for any
-     *            span it creates for tracing the execution of this operation.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         If the command was accepted, the future will succeed.
-     *         <p>
-     *         The future will fail with a {@link ServiceInvocationException} if the command could not be forwarded to
-     *         the device.
-     * @throws NullPointerException if command, correlationId or replyId is {@code null}.
-     * @see ApplicationClientFactory#createAsyncCommandResponseConsumer(String, String, java.util.function.Consumer,
-     *      io.vertx.core.Handler)
-     * @see ApplicationClientFactory#createAsyncCommandResponseConsumer(String, String, java.util.function.BiConsumer,
-     *      io.vertx.core.Handler)
-     */
-    default Future<Void> sendAsyncCommand(final String deviceId, final String command, final String contentType,
-            final Buffer data, final String correlationId, final String replyId, final Map<String, Object> properties,
-            final SpanContext context) {
-        return sendAsyncCommand(deviceId, command, contentType, data, correlationId, replyId, properties);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/Command.java b/client/src/main/java/org/eclipse/hono/client/Command.java
deleted file mode 100644
index a67f1dc4b..000000000
--- a/client/src/main/java/org/eclipse/hono/client/Command.java
+++ /dev/null
@@ -1,546 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.StringJoiner;
-
-import org.apache.qpid.proton.amqp.messaging.AmqpValue;
-import org.apache.qpid.proton.amqp.messaging.Data;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
-
-import io.vertx.core.buffer.Buffer;
-
-/**
- * A wrapper around an AMQP 1.0 message representing a command.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.Command} instead.
- */
-@Deprecated
-public final class Command {
-
-    /**
-     * Bit flag value for the boolean option that defines whether the original reply-to address of the command message
-     * contained the device id.
-     */
-    private static final byte FLAG_REPLY_TO_CONTAINED_DEVICE_ID = 1;
-
-    /**
-     * If present, the command is invalid.
-     */
-    private final Optional<String> validationError;
-    private final Message message;
-    private final String tenantId;
-    private final String correlationId;
-    private final String replyToId;
-    private final String requestId;
-    private String deviceId;
-
-    private Command(
-            final Optional<String> validationError,
-            final Message message,
-            final String tenantId,
-            final String deviceId,
-            final String correlationId,
-            final String replyToId,
-            final String requestId) {
-
-        this.validationError = validationError;
-        this.message = message;
-        this.tenantId = tenantId;
-        this.deviceId = deviceId;
-        this.correlationId = correlationId;
-        this.replyToId = replyToId;
-        this.requestId = requestId;
-    }
-
-    /**
-     * Creates a command from an AMQP 1.0 message.
-     * <p>
-     * The message is expected to contain
-     * <ul>
-     * <li>a non-null <em>address</em>, containing a matching tenant part and a non-empty device-id part</li>
-     * <li>a non-null <em>subject</em></li>
-     * <li>either a null <em>reply-to</em> address (for a one-way command)
-     * or a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists
-     * of four segments</li>
-     * <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li>
-     * </ul>
-     * <p>
-     * If any of the requirements above are not met, then the returned command's {@link Command#isValid()}
-     * method will return {@code false}.
-     * <p>
-     * Note that, if set, the <em>reply-to</em> address of the given message will be adapted, making sure it contains
-     * the device id.
-     *
-     * @param message The message containing the command.
-     * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The identifier of the device that the command will be sent to. If the command has been mapped
-     *                 to a gateway, this id is the gateway id and the original command target device is given in
-     *                 the message address.
-     * @return The command.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public static Command from(
-            final Message message,
-            final String tenantId,
-            final String deviceId) {
-
-        Objects.requireNonNull(message);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-
-        final StringJoiner validationErrorJoiner = new StringJoiner(", ");
-        String originalDeviceId = deviceId;
-        if (!ResourceIdentifier.isValid(message.getAddress())) {
-            validationErrorJoiner.add("address is empty or invalid");
-        } else {
-            final ResourceIdentifier addressIdentifier = ResourceIdentifier.fromString(message.getAddress());
-            if (!tenantId.equals(addressIdentifier.getTenantId())) {
-                validationErrorJoiner.add("address contains wrong tenant '" + addressIdentifier.getTenantId() + "'");
-            }
-            if (addressIdentifier.getResourceId() == null) {
-                validationErrorJoiner.add("address is missing device-id part");
-            }
-            originalDeviceId = addressIdentifier.getResourceId();
-        }
-
-        if (message.getSubject() == null) {
-            validationErrorJoiner.add("subject not set");
-        }
-
-        if (message.getBody() != null) {
-            // check for unsupported message body
-            getUnsupportedPayloadReason(message).ifPresent(validationErrorJoiner::add);
-        }
-
-        String correlationId = null;
-        final Object correlationIdObj = MessageHelper.getCorrelationId(message);
-        if (correlationIdObj != null) {
-            if (correlationIdObj instanceof String) {
-                correlationId = (String) correlationIdObj;
-            } else {
-                validationErrorJoiner.add("message/correlation-id is not of type string, actual type: " + correlationIdObj.getClass().getName());
-            }
-        } else if (message.getReplyTo() != null) {
-            // correlation id is required if a command response is expected
-            validationErrorJoiner.add("neither message-id nor correlation-id is set");
-        }
-
-        String originalReplyToId = null;
-        if (message.getReplyTo() != null) {
-            try {
-                final ResourceIdentifier replyTo = ResourceIdentifier.fromString(message.getReplyTo());
-                if (!CommandConstants.isNorthboundCommandResponseEndpoint(replyTo.getEndpoint())) {
-                    // not a command message
-                    validationErrorJoiner.add("reply-to not a command address: " + message.getReplyTo());
-                } else if (!tenantId.equals(replyTo.getTenantId())) {
-                    // command response is targeted at wrong tenant
-                    validationErrorJoiner.add("reply-to not targeted at tenant " + tenantId + ": " + message.getReplyTo());
-                } else {
-                    originalReplyToId = replyTo.getPathWithoutBase();
-                    if (originalReplyToId.isEmpty()) {
-                        validationErrorJoiner.add("reply-to part after tenant not set: " + message.getReplyTo());
-                    } else {
-                        message.setReplyTo(
-                                String.format("%s/%s/%s", CommandConstants.COMMAND_RESPONSE_ENDPOINT, tenantId,
-                                        getDeviceFacingReplyToId(originalReplyToId, originalDeviceId)));
-                    }
-                }
-            } catch (final IllegalArgumentException e) {
-                // reply-to could not be parsed
-                validationErrorJoiner.add("reply-to cannot be parsed: " + message.getReplyTo());
-            }
-        }
-
-        return new Command(
-                validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),
-                message,
-                tenantId,
-                deviceId,
-                correlationId,
-                originalReplyToId,
-                getRequestId(correlationId, originalReplyToId, originalDeviceId));
-    }
-
-    /**
-     * Gets the AMQP 1.0 message representing this command.
-     *
-     * @return The command message.
-     */
-    public Message getCommandMessage() {
-        return message;
-    }
-
-    /**
-     * Checks if this command is a <em>one-way</em> command (meaning there is no response expected).
-     *
-     * @return {@code true} if the message's <em>reply-to</em> property is empty or invalid.
-     */
-    public boolean isOneWay() {
-        return replyToId == null;
-    }
-
-    /**
-     * Checks if this command contains all required information.
-     *
-     * @return {@code true} if this is a valid command.
-     */
-    public boolean isValid() {
-        return !validationError.isPresent();
-    }
-
-    /**
-     * Gets info about why the command is invalid.
-     *
-     * @return Info string.
-     * @throws IllegalStateException if this command is valid.
-     */
-    public String getInvalidCommandReason() {
-        if (isValid()) {
-            throw new IllegalStateException("command is valid");
-        }
-        return validationError.get();
-    }
-
-    /**
-     * Gets the tenant that the device belongs to.
-     *
-     * @return The tenant identifier or {@code null} if the command is invalid and no tenant id is set.
-     */
-    public String getTenant() {
-        return tenantId;
-    }
-
-    /**
-     * Gets the identifier of the gateway or edge device that this command
-     * needs to be forwarded to for delivery.
-     * <p>
-     * In the case that the command got redirected to a gateway,
-     * the id returned here is a gateway id. See {@link #getOriginalDeviceId()}
-     * for the original device id in that case.
-     *
-     * @return The identifier or {@code null} if the command is invalid and no device id is set.
-     */
-    public String getDeviceId() {
-        return deviceId;
-    }
-
-    /**
-     * Sets the identifier of the gateway this command is to be sent to.
-     * <p>
-     * Using {@code null} as parameter means that the command is to be forwarded directly
-     * to the device given in the original command message, without using a gateway.
-     *
-     * @param gatewayId The gateway identifier.
-     */
-    public void setGatewayId(final String gatewayId) {
-        this.deviceId = Optional.ofNullable(gatewayId).orElseGet(this::getOriginalDeviceId);
-    }
-
-    /**
-     * Checks whether the command is targeted at a gateway.
-     * <p>
-     * This is the case when the commands got redirected and hence
-     * the device id (ie. the gateway id in that case) is different
-     * from the original device id.
-     *
-     * @return {@code true} if the device id is a gateway id.
-     */
-    public boolean isTargetedAtGateway() {
-        final String originalDeviceId = getOriginalDeviceId();
-        return originalDeviceId != null && !originalDeviceId.equals(getDeviceId());
-    }
-
-    /**
-     * Gets the device identifier used in the original command. It is extracted from the
-     * <em>to</em> property of the command AMQP message.
-     * <p>
-     * This id differs from {@link #getDeviceId()} if the command got redirected to a gateway
-     * ({@link #getDeviceId()} returns the gateway id in that case).
-     *
-     * @return The identifier or {@code null} if the command is invalid and no device id is set.
-     */
-    public String getOriginalDeviceId() {
-        if (!ResourceIdentifier.isValid(message.getAddress())) {
-            return null;
-        }
-        return ResourceIdentifier.fromString(message.getAddress()).getResourceId();
-    }
-
-    /**
-     * Gets the name of this command.
-     *
-     * @return The name.
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public String getName() {
-        if (isValid()) {
-            return message.getSubject();
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets the request identifier of this command.
-     * <p>
-     * May be {@code null} for a one-way command.
-     *
-     * @return The identifier or {@code null} if not set.
-     * @throws IllegalStateException if this command is invalid.
-     * @see #getRequestId(String, String, String)
-     */
-    public String getRequestId() {
-        if (isValid()) {
-            return requestId;
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets the payload of this command.
-     *
-     * @return The message payload or {@code null} if the command message contains no payload.
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public Buffer getPayload() {
-        if (isValid()) {
-            return MessageHelper.getPayload(message);
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets the size of this command's payload.
-     *
-     * @return The payload size in bytes, 0 if the command has no (valid) payload.
-     */
-    public int getPayloadSize() {
-        return MessageHelper.getPayloadSize(message);
-    }
-
-    /**
-     * Gets the type of this command's payload.
-     *
-     * @return The content type or {@code null} if not set.
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public String getContentType() {
-        if (isValid()) {
-            return message.getContentType();
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets this command's reply-to-id. It is the last part of the command message's <em>reply-to</em> property
-     * value {@code command_response/${tenant_id}/${reply_id}}.
-     * <p>
-     * Note that an outgoing command message targeted at the device will contain an
-     * adapted reply-to address containing the device id.
-     *
-     * @return The identifier or {@code null} if not set (meaning the command is a one-way command).
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public String getReplyToId() {
-        if (isValid()) {
-            return replyToId;
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets the name of the endpoint used in the <em>reply-to</em> address of the incoming command message.
-     * <p>
-     * If the command message didn't contain a <em>reply-to</em> address, the default
-     * {@link CommandConstants#NORTHBOUND_COMMAND_RESPONSE_ENDPOINT} is returned here.
-     *
-     * @return The name of the endpoint.
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public String getReplyToEndpoint() {
-        if (isValid()) {
-            return CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT;
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets the ID to use for correlating a response to this command.
-     *
-     * @return The identifier or {@code null} if not set.
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public String getCorrelationId() {
-        if (isValid()) {
-            return correlationId;
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Gets the application properties of a message if any.
-     *
-     * @return The application properties.
-     * @throws IllegalStateException if this command is invalid.
-     */
-    public Map<String, Object> getApplicationProperties() {
-        if (isValid()) {
-            if (message.getApplicationProperties() == null) {
-                return null;
-            }
-            return message.getApplicationProperties().getValue();
-        } else {
-            throw new IllegalStateException("command is invalid");
-        }
-    }
-
-    /**
-     * Creates a request ID for a command.
-     * <p>
-     * Incorporates the given correlationId and replyToId (minus deviceId if contained in the replyToId).
-     *
-     * @param correlationId The identifier to use for correlating the response with the request.
-     * @param replyToId An arbitrary identifier to encode into the request ID.
-     * @param deviceId The target of the command.
-     * @return The request identifier or {@code null} if correlationId or deviceId is {@code null}.
-     * @deprecated Use {@code org.eclipse.hono.client.command.Commands#getRequestId(String, String, String)} instead.
-     */
-    public static String getRequestId(final String correlationId, final String replyToId, final String deviceId) {
-
-        if (correlationId == null || deviceId == null) {
-            return null;
-        }
-
-        String replyToIdWithoutDeviceOrEmpty = Optional.ofNullable(replyToId).orElse("");
-        final boolean replyToContainedDeviceId = replyToIdWithoutDeviceOrEmpty.startsWith(deviceId + "/");
-        if (replyToContainedDeviceId) {
-            replyToIdWithoutDeviceOrEmpty = replyToIdWithoutDeviceOrEmpty.substring(deviceId.length() + 1);
-        }
-        return String.format("%s%02x%s%s", encodeReplyToOptions(replyToContainedDeviceId),
-                correlationId.length(), correlationId, replyToIdWithoutDeviceOrEmpty);
-    }
-
-    /**
-     * Encodes the given boolean parameters related to the original reply-to address of the command message as a single
-     * digit string.
-     *
-     * @param replyToContainedDeviceId Whether the original reply-to address of the command message contained the device
-     *            id.
-     * @return The encoded options as a single digit string.
-     */
-    static String encodeReplyToOptions(final boolean replyToContainedDeviceId) {
-        int bitFlag = 0;
-        if (replyToContainedDeviceId) {
-            bitFlag |= FLAG_REPLY_TO_CONTAINED_DEVICE_ID;
-        }
-        return String.valueOf(bitFlag);
-    }
-
-    /**
-     * Checks if the original reply-to address of the command message contained the device id.
-     *
-     * @param replyToOptionsBitFlag The bit flag returned by {@link #encodeReplyToOptions(boolean)}.
-     * @return {@code true} if the original reply-to address of the command message contained the device id.
-     * @throws NumberFormatException If the given replyToOptionsBitFlag can't be parsed as an integer.
-     */
-    static boolean isReplyToContainedDeviceIdOptionSet(final String replyToOptionsBitFlag) {
-        return decodeReplyToOption(replyToOptionsBitFlag, FLAG_REPLY_TO_CONTAINED_DEVICE_ID);
-    }
-
-    private static boolean decodeReplyToOption(final String replyToOptionsBitFlag, final byte optionBitConstant) {
-        return (Integer.parseInt(replyToOptionsBitFlag) & optionBitConstant) == optionBitConstant;
-    }
-
-    @Override
-    public String toString() {
-        if (isValid()) {
-            final String originalDeviceId = getOriginalDeviceId();
-            if (!getDeviceId().equals(originalDeviceId)) {
-                return String.format("Command [name: %s, tenant-id: %s, gateway-id: %s, device-id: %s, request-id: %s]",
-                        getName(), getTenant(), getDeviceId(), originalDeviceId, getRequestId());
-            } else {
-                return String.format("Command [name: %s, tenant-id: %s, device-id: %s, request-id: %s]",
-                        getName(), getTenant(), getDeviceId(), getRequestId());
-            }
-        } else {
-            return String.format("Invalid Command [tenant-id: %s, device-id: %s. error: %s]", tenantId, deviceId, validationError.get());
-        }
-    }
-
-    /**
-     * Gets the reply-to-id that will be set when forwarding the command to the device.
-     * <p>
-     * It is ensured that this id starts with {@code ${deviceId}/}.
-     *
-     * @param replyToId The reply-to-id as extracted from the 'reply-to' of the command AMQP message.
-     * @param deviceId The device id.
-     * @return The reply-to-id, starting with the device id.
-     */
-    public static String getDeviceFacingReplyToId(final String replyToId, final String deviceId) {
-        final boolean replyToContainedDeviceId = replyToId.startsWith(deviceId + "/");
-        final String replyToIdWithoutDeviceId = replyToContainedDeviceId ? replyToId.substring(deviceId.length() + 1)
-                : replyToId;
-        final String bitFlagString = encodeReplyToOptions(replyToContainedDeviceId);
-        return String.format("%s/%s%s", deviceId, bitFlagString, replyToIdWithoutDeviceId);
-    }
-
-    /**
-     * Validates the type of the message body containing the payload data and returns an error string if it is
-     * unsupported.
-     * <p>
-     * The message body is considered unsupported if there is a body section and it is neither
-     * <ul>
-     * <li>a Data section,</li>
-     * <li>nor an AmqpValue section containing a byte array or a String.</li>
-     * </ul>
-     *
-     * @param msg The AMQP 1.0 message to parse.
-     * @return An Optional with the error string or an empty Optional if the payload is supported or the
-     *         message has no body section.
-     * @throws NullPointerException if the message is {@code null}.
-     * @see MessageHelper#getPayload(Message)
-     */
-    private static Optional<String> getUnsupportedPayloadReason(final Message msg) {
-        Objects.requireNonNull(msg);
-
-        String reason = null;
-        if (msg.getBody() instanceof AmqpValue) {
-            final Object value = ((AmqpValue) msg.getBody()).getValue();
-            if (value == null) {
-                reason = "message has body with empty amqp-value section";
-            } else if (!(value instanceof byte[] || value instanceof String)) {
-                reason = String.format("message has amqp-value section body with unsupported value type [%s], supported is byte[] or String",
-                        value.getClass().getName());
-            }
-
-        } else if (msg.getBody() != null && !(msg.getBody() instanceof Data)) {
-            reason = String.format("message has unsupported body section [%s], supported section types are 'data' and 'amqp-value'",
-                    msg.getBody().getClass().getName());
-        }
-        return Optional.ofNullable(reason);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandClient.java b/client/src/main/java/org/eclipse/hono/client/CommandClient.java
deleted file mode 100644
index 977d73088..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandClient.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import java.util.Map;
-
-import org.eclipse.hono.util.BufferResult;
-
-import io.vertx.core.Future;
-import io.vertx.core.buffer.Buffer;
-
-/**
- * A client for accessing Hono's Command and Control API.
- * <p>
- * An instance of this interface is always scoped to a specific tenant.
- * </p>
- *
- * @deprecated Use {@code org.eclipse.hono.application.client.ApplicationClient} instead.
- */
-@Deprecated
-public interface CommandClient extends RequestResponseClient {
-
-    /**
-     * Sends a command to a device and expects a response.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload
-     * any data for it. The device also needs to be connected to a protocol adapter
-     * and needs to have indicated its intent to receive commands.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The name of the command.
-     * @param data The input data to the command or {@code null} if the command has no input data.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 2xx has been received from the device.
-     *         If the response has no payload, the future will complete with a BufferResult that has a {@code null} payload.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code. Status codes are defined at
-     *         <a href="https://www.eclipse.org/hono/docs/api/command-and-control">Command and Control API</a>.
-     * @throws NullPointerException if any of device ID or command are {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<BufferResult> sendCommand(String deviceId, String command, Buffer data);
-
-    /**
-     * Sends a command to a device and expects a response.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload
-     * any data for it. The device also needs to be connected to a protocol adapter
-     * and needs to have indicated its intent to receive commands.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The name of the command.
-     * @param contentType The type of the data submitted as part of the command or {@code null} if unknown.
-     * @param data The input data to the command or {@code null} if the command has no input data.
-     * @param properties The headers to include in the command message as AMQP application properties.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 2xx has been received from the device.
-     *         If the response has no payload, the future will complete with a BufferResult that has a {@code null} payload.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code. Status codes are defined at <a href="https://www.eclipse.org/hono/docs/api/command-and-control">Command and Control API</a>.
-     * @throws NullPointerException if any of device ID or command are {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<BufferResult> sendCommand(String deviceId, String command, String contentType, Buffer data, Map<String, Object> properties);
-
-    /**
-     * Sends a <em>one-way command</em> to a device, i.e. there is no response expected from the device.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload
-     * any data for it. The device also needs to be connected to a protocol adapter
-     * and needs to have indicated its intent to receive commands.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The name of the command.
-     * @param data The input data to the command or {@code null} if the command has no input data.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         If the one-way command was accepted, the future will succeed.
-     *         <p>
-     *         The future will fail with a {@link ServiceInvocationException} if the one-way command could not be forwarded to the device.
-     * @throws NullPointerException if any of device ID or command are {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<Void> sendOneWayCommand(String deviceId, String command, Buffer data);
-
-    /**
-     * Sends a <em>one-way command</em> to a device, i.e. there is no response from the device expected.
-     * <p>
-     * A device needs to be (successfully) registered before a client can upload
-     * any data for it. The device also needs to be connected to a protocol adapter
-     * and needs to have indicated its intent to receive commands.
-     *
-     * @param deviceId The device to send the command to.
-     * @param command The name of the command.
-     * @param contentType The type of the data submitted as part of the one-way command or {@code null} if unknown.
-     * @param data The input data to the command or {@code null} if the command has no input data.
-     * @param properties The headers to include in the one-way command message as AMQP application properties.
-     * @return A future indicating the result of the operation:
-     *         <p>
-     *         If the one-way command was accepted, the future will succeed.
-     *         <p>
-     *         The future will fail with a {@link ServiceInvocationException} if the one-way command could not be forwarded to the device.
-     * @throws NullPointerException if any of device ID or command are {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<Void> sendOneWayCommand(String deviceId, String command, String contentType, Buffer data, Map<String, Object> properties);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandResponse.java b/client/src/main/java/org/eclipse/hono/client/CommandResponse.java
deleted file mode 100644
index 780844d82..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandResponse.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import java.util.Objects;
-import java.util.function.Predicate;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.vertx.core.buffer.Buffer;
-import io.vertx.proton.ProtonHelper;
-
-/**
- * A wrapper around payload that has been sent by a device in
- * response to a command.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.CommandResponse} instead.
- */
-@Deprecated
-public final class CommandResponse {
-
-    private static final Logger LOG = LoggerFactory.getLogger(CommandResponse.class);
-
-    private static final Predicate<Integer> INVALID_STATUS_CODE = code ->
-        code == null || code < 200 || (code >= 300 && code < 400) || code >= 600;
-
-    private final Message message;
-    private final String replyToId;
-
-    private CommandResponse(final String tenantId, final String deviceId, final Buffer payload,
-            final String contentType, final int status, final String correlationId, final String replyToId) {
-        message = ProtonHelper.message();
-        message.setCorrelationId(correlationId);
-        MessageHelper.setCreationTime(message);
-        MessageHelper.addTenantId(message, tenantId);
-        MessageHelper.addDeviceId(message, deviceId);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, status);
-        MessageHelper.setPayload(message, contentType, payload);
-        this.replyToId = replyToId;
-    }
-
-    private CommandResponse(final Message message, final String replyToId) {
-        this.message = message;
-        this.replyToId = replyToId;
-    }
-
-    /**
-     * Creates a response for a request ID.
-     *
-     * @param requestId The request ID of the command that this is the response for.
-     * @param tenantId The tenant ID of the device sending the response.
-     * @param deviceId The device ID of the device sending the response.
-     * @param payload The payload of the response.
-     * @param contentType The contentType of the response. May be {@code null} since it is not required.
-     * @param status The HTTP status code indicating the outcome of the command.
-     * @return The response or {@code null} if the request ID could not be parsed, the status is {@code null} or if the
-     *         status code is &lt; 200 or &gt;= 600.
-     * @throws NullPointerException if tenantId or deviceId is {@code null}.
-     */
-    public static CommandResponse from(
-            final String requestId,
-            final String tenantId,
-            final String deviceId,
-            final Buffer payload,
-            final String contentType,
-            final Integer status) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-
-        if (requestId == null) {
-            LOG.debug("cannot create CommandResponse: request id is null");
-            return null;
-        } else if (INVALID_STATUS_CODE.test(status)) {
-            LOG.debug("cannot create CommandResponse: status is invalid: {}", status);
-            return null;
-        } else if (requestId.length() < 3) {
-            LOG.debug("cannot create CommandResponse: request id invalid: {}", requestId);
-            return null;
-        } else {
-            try {
-                final String replyToOptionsBitFlag = requestId.substring(0, 1);
-                final boolean addDeviceIdToReply = Command.isReplyToContainedDeviceIdOptionSet(replyToOptionsBitFlag);
-                final int lengthStringOne = Integer.parseInt(requestId.substring(1, 3), 16);
-                final String replyId = requestId.substring(3 + lengthStringOne);
-                return new CommandResponse(
-                        tenantId, deviceId, payload,
-                        contentType,
-                        status,
-                        requestId.substring(3, 3 + lengthStringOne), // correlation ID
-                        addDeviceIdToReply ? deviceId + "/" + replyId : replyId);
-            } catch (NumberFormatException | StringIndexOutOfBoundsException se) {
-                LOG.debug("error creating CommandResponse", se);
-                return null;
-            }
-        }
-    }
-
-    /**
-     * Creates a command response from a given message.
-     *
-     * @param message The command response message.
-     *
-     * @return The command response or {@code null} if message or any of correlationId, address and status is
-     *         {@code null} or if the status code is &lt; 200 or &gt;= 600.
-     * @throws NullPointerException if message is {@code null}.
-     */
-    public static CommandResponse from(final Message message) {
-        Objects.requireNonNull(message);
-
-        final String correlationId = message.getCorrelationId() instanceof String ? (String) message.getCorrelationId() : null;
-        final Integer status = MessageHelper.getStatus(message);
-
-        if (correlationId == null || !ResourceIdentifier.isValid(message.getAddress()) || status == null) {
-            LOG.debug("cannot create CommandResponse: invalid message (correlationId: {}, address: {}, status: {})",
-                    correlationId, message.getAddress(), status);
-            return null;
-        } else if (INVALID_STATUS_CODE.test(status)) {
-            LOG.debug("cannot create CommandResponse: status is invalid: {}", status);
-            return null;
-        }
-
-        final ResourceIdentifier resource = ResourceIdentifier.fromString(message.getAddress());
-        final String tenantId = resource.getTenantId();
-        final String deviceId = resource.getResourceId();
-        if (tenantId == null || deviceId == null) {
-            LOG.debug("cannot create CommandResponse: invalid address, missing tenant and/or device identifier");
-            return null;
-        }
-        final String pathWithoutBase = resource.getPathWithoutBase();
-        if (pathWithoutBase.length() < deviceId.length() + 3) {
-            LOG.debug("cannot create CommandResponse: invalid address resource length");
-            return null;
-        }
-        MessageHelper.addTenantId(message, tenantId);
-        MessageHelper.addDeviceId(message, deviceId);
-        try {
-            // pathWithoutBase starts with deviceId/[bit flag]
-            final String replyToOptionsBitFlag = pathWithoutBase.substring(deviceId.length() + 1, deviceId.length() + 2);
-            final boolean replyToContainedDeviceId = Command.isReplyToContainedDeviceIdOptionSet(replyToOptionsBitFlag);
-            final String replyToId = pathWithoutBase.replaceFirst(deviceId + "/" + replyToOptionsBitFlag,
-                    replyToContainedDeviceId ? deviceId + "/" : "");
-            return new CommandResponse(message, replyToId);
-        } catch (final NumberFormatException e) {
-            LOG.debug("error creating CommandResponse, invalid bit flag value", e);
-            return null;
-        }
-    }
-
-    /**
-     * Gets the reply-to identifier that is either part of the request ID or the response address.
-     *
-     * @return The identifier.
-     */
-    public String getReplyToId() {
-        return replyToId;
-    }
-
-    /**
-     * Gets the correlation identifier.
-     *
-     * @return The identifier or {@code null} if no correlation id is set.
-     */
-    public String getCorrelationId() {
-        return (String) message.getCorrelationId();
-    }
-
-    /**
-     * Gets the HTTP status code that indicates the outcome of
-     * executing the command.
-     *
-     * @return The status code.
-     */
-    public int getStatus() {
-        return MessageHelper.getStatus(message);
-    }
-
-    /**
-     * Gets the AMQP 1.0 message representing this command response.
-     *
-     * @return The command response message.
-     */
-    public Message toMessage() {
-        return message;
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandResponseSender.java b/client/src/main/java/org/eclipse/hono/client/CommandResponseSender.java
deleted file mode 100644
index e0361ef11..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandResponseSender.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * A sender to send back the response message of a command.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.CommandResponseSender} instead.
- */
-@Deprecated
-public interface CommandResponseSender extends MessageSender {
-
-    /**
-     * Sends a response message to a command back to the business application.
-     *
-     * @param response The response.
-     * @param context The currently active OpenTracing span or {@code null} if no
-     *         span is currently active. An implementation should use this as the
-     *         parent for any new span(s) it creates for tracing the execution of
-     *         this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been accepted (and settled)
-     *         by the application.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or has not been accepted by the application.
-     * @throws NullPointerException if response is {@code null}.
-     */
-    Future<ProtonDelivery> sendCommandResponse(CommandResponse response, SpanContext context);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java b/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java
deleted file mode 100644
index 7c549f663..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.util.CredentialsObject;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonObject;
-
-/**
- * A client for accessing Hono's Credentials API.
- * <p>
- * An instance of this interface is always scoped to a specific tenant.
- * </p>
- * <p>
- * See Hono's <a href="https://www.eclipse.org/hono/docs/api/credentials/">
- * Credentials API specification</a> for a description of the result codes returned.
- * </p>
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.CredentialsClient} instead.
- */
-@Deprecated
-public interface CredentialsClient extends RequestResponseClient {
-
-    /**
-     * Gets credentials for a device by type and authentication identifier.
-     *
-     * @param type The type of credentials to retrieve.
-     * @param authId The authentication identifier used in the credentials to retrieve.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 2xx has been received from the
-     *         credentials service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/credentials/#get-credentials">
-     *         Get Credentials</a>.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<CredentialsObject> get(String type, String authId);
-
-    /**
-     * Gets credentials for a device by type and authentication identifier.
-     *
-     * @param type The type of credentials to retrieve.
-     * @param authId The authentication identifier used in the credentials to retrieve.
-     * @param clientContext Optional bag of properties that can be used to identify the device
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 2xx has been received from the
-     *         credentials service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/credentials/#get-credentials">
-     *         Get Credentials</a>.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<CredentialsObject> get(String type, String authId, JsonObject clientContext);
-
-    /**
-     * Gets credentials for a device by type and authentication identifier.
-     * <p>
-     * This default implementation simply returns the result of {@link #get(String, String, JsonObject)}.
-     *
-     * @param type The type of credentials to retrieve.
-     * @param authId The authentication identifier used in the credentials to retrieve.
-     * @param clientContext Optional bag of properties that can be used to identify the device
-     * @param spanContext The currently active OpenTracing span (may be {@code null}). An implementation
-     *                    should use this as the parent for any span it creates for tracing
-     *                    the execution of this operation.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 2xx has been received from the
-     *         credentials service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/credentials/#get-credentials">
-     *         Get Credentials</a>.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.
-     * @throws NullPointerException if any of the parameters (except spanContext) is {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    default Future<CredentialsObject> get(final String type, final String authId, final JsonObject clientContext,
-            final SpanContext spanContext) {
-        return get(type, authId, clientContext);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java b/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
deleted file mode 100644
index fa75d0829..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.impl.CredentialsClientFactoryImpl;
-
-import io.vertx.core.Future;
-
-/**
- * A factory for creating clients for Hono's Credentials API.
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.CredentialsClient} instead.
- */
-@Deprecated
-public interface CredentialsClientFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static CredentialsClientFactory create(final HonoConnection connection) {
-        return new CredentialsClientFactoryImpl(connection, null, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param cacheProvider The cache provider to use for creating caches for credential objects
-     *                      or {@code null} if credential objects should not be cached.
-     * @param samplerFactory The sampler factory to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static CredentialsClientFactory create(final HonoConnection connection, final CacheProvider cacheProvider, final SendMessageSampler.Factory samplerFactory) {
-        return new CredentialsClientFactoryImpl(connection, cacheProvider, samplerFactory);
-    }
-
-    /**
-     * Gets a client for interacting with Hono's <em>Credentials</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @param tenantId The tenant to manage device credentials data for.
-     * @return A future that will complete with the credentials client (if successful) or fail if the client cannot be
-     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
-     *         client for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<CredentialsClient> getOrCreateCredentialsClient(String tenantId);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CreditBasedSender.java b/client/src/main/java/org/eclipse/hono/client/CreditBasedSender.java
deleted file mode 100644
index 8e705bd86..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CreditBasedSender.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client;
-
-import io.vertx.core.Handler;
-
-/**
- *  A client with methods to retrieve flow credits and also to set queueDrainHandler.
- *
- */
-@Deprecated
-public interface CreditBasedSender {
-    /**
-     * Gets the number of messages this sender can send based on its current number of credits.
-     * <p>
-     * Note that the value returned is valid during execution of the current vert.x handler only.
-     *
-     * @return The number of messages.
-     */
-    int getCredit();
-
-    /**
-     * Sets a handler to be notified once this sender has capacity available to send a message.
-     * <p>
-     * The handler registered using this method will be invoked <em>exactly once</em> when this sender is replenished
-     * with more credit from the peer. For subsequent notifications to be received, a new handler must be registered.
-     * <p>
-     * Client code can use this method to register a handler after it has checked this sender's capacity to send
-     * messages using {@link #getCredit()}, e.g.
-     *
-     * <pre>
-     * MessageSender sender;
-     * ...
-     *
-     * if (sender.getCredit() &lt;= 0) {
-     *     sender.sendQueueDrainHandler(replenished -&gt; {
-     *         sender.send(msg);
-     *     });
-     * } else {
-     *     sender.send(msg);
-     * }
-     * </pre>
-     * <p>
-     * Note that all the <em>send</em> methods fail if no credit is available.
-     *
-     * @param handler The handler to invoke when this sender has been replenished with credit.
-     * @throws IllegalStateException if there already is a handler registered. Note that this means that this sender is
-     *             already waiting for credit.
-     */
-    void sendQueueDrainHandler(Handler<Void> handler);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/DownstreamSender.java b/client/src/main/java/org/eclipse/hono/client/DownstreamSender.java
deleted file mode 100644
index 73622dc17..000000000
--- a/client/src/main/java/org/eclipse/hono/client/DownstreamSender.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/**
- * Copyright (c) 2019, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import java.util.Map;
-
-import io.vertx.core.Future;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * A client for sending messages to Hono's
- * south bound Telemetry and Event APIs.
- *
- * @deprecated Use {@code org.eclipse.hono.client.telemetry.TelemetrySender} and/or
- * {@code org.eclipse.hono.client.telemetry.EventSender} instead.
- */
-@Deprecated
-public interface DownstreamSender extends MessageSender {
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 <p>
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param payload The data to send.
-     *                <p>
-     *                The payload's byte representation will be contained in the message as an AMQP 1.0
-     *                <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    <p>
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     *                    If the content type specifies a particular character set, this character set will be used to
-     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
-     */
-    Future<ProtonDelivery> send(String deviceId, String payload, String contentType);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 <p>
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param payload The data to send.
-     *                <p>
-     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    <p>
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
-     */
-    Future<ProtonDelivery> send(String deviceId, byte[] payload, String contentType);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 <p>
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param properties The application properties.
-     *                   <p>
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
-     * @param payload The data to send.
-     *                <p>
-     *                The payload's byte representation will be contained in the message as an AMQP 1.0
-     *                <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    <p>
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     *                    If the content type specifies a particular character set, this character set will be used to
-     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if any of device id, payload, content type or registration assertion
-     *                              is {@code null}.
-     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
-     */
-    Future<ProtonDelivery> send(
-            String deviceId,
-            Map<String, ?> properties,
-            String payload,
-            String contentType);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 <p>
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param properties The application properties.
-     *                   <p>
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
-     * @param payload The data to send.
-     *                <p>
-     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    <p>
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
-     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
-     */
-    Future<ProtonDelivery> send(
-            String deviceId,
-            Map<String, ?> properties,
-            byte[] payload,
-            String contentType);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/DownstreamSenderFactory.java b/client/src/main/java/org/eclipse/hono/client/DownstreamSenderFactory.java
deleted file mode 100644
index f4d9490f0..000000000
--- a/client/src/main/java/org/eclipse/hono/client/DownstreamSenderFactory.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/**
- * Copyright (c) 2019, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.client.impl.DownstreamSenderFactoryImpl;
-
-import io.vertx.core.Future;
-
-/**
- * A factory for creating clients for Hono's south bound Telemetry and Event APIs.
- *
- * @deprecated Use {@code org.eclipse.hono.client.telemetry.TelemetrySender} and/or
- * {@code org.eclipse.hono.client.telemetry.EventSender} instead.
- */
-@Deprecated
-public interface DownstreamSenderFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static DownstreamSenderFactory create(final HonoConnection connection) {
-        return new DownstreamSenderFactoryImpl(connection, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param samplerFactory The sampler factory to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static DownstreamSenderFactory create(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        return new DownstreamSenderFactoryImpl(connection, samplerFactory);
-    }
-
-    /**
-     * Gets a client for sending data to Hono's south bound <em>Telemetry</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @param tenantId The ID of the tenant to send messages for.
-     * @return A future that will complete with the sender once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
-     *         create a sender for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<DownstreamSender> getOrCreateTelemetrySender(String tenantId);
-
-    /**
-     * Gets a client for sending data to Hono's south bound <em>Event</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @param tenantId The ID of the tenant to send messages for.
-     * @return A future that will complete with the sender once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
-     *         create a sender for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<DownstreamSender> getOrCreateEventSender(String tenantId);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/MessageConsumer.java b/client/src/main/java/org/eclipse/hono/client/MessageConsumer.java
deleted file mode 100644
index 6f10a2b4c..000000000
--- a/client/src/main/java/org/eclipse/hono/client/MessageConsumer.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Handler;
-
-/**
- * A client for consuming messages from a Hono server.
- *
- * @deprecated Use {@code org.eclipse.hono.client.command.CommandConsumer} instead.
- */
-@Deprecated
-public interface MessageConsumer {
-
-    /**
-     * Closes the AMQP link with the Hono server this client is configured to use.
-     * <p>
-     * The underlying AMQP connection to the server is not affected by this operation.
-     * </p>
-     *
-     * @param closeHandler A handler that is called back with the result of the attempt to close the link.
-     */
-    void close(Handler<AsyncResult<Void>> closeHandler);
-
-    /**
-     * Grants the given number of message credits to the sender.
-     *
-     * For use when created with 0 prefetch in consumer creation
-     *
-     * @param credits the credits to flow
-     * @throws IllegalStateException if prefetch is non-zero, or an existing drain operation is not yet complete
-     */
-    void flow(int credits) throws IllegalStateException;
-
-    /**
-     * Gets the number of additional messages this consumer can receive.
-     * <p>
-     * Note that the value returned is valid during execution of the current vert.x handler only.
-     *
-     * @return The number of messages.
-     */
-    int getRemainingCredit();
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/MessageSender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
deleted file mode 100644
index 7d25e35e7..000000000
--- a/client/src/main/java/org/eclipse/hono/client/MessageSender.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import org.apache.qpid.proton.message.Message;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * A client for publishing messages to Hono.
- *
- */
-@Deprecated
-public interface MessageSender extends CreditBasedSender {
-
-    /**
-     * Gets the name of the endpoint this sender sends messages to.
-     * <p>
-     * The name returned is implementation specific, e.g. an implementation
-     * that can be used to upload telemetry data to Hono will return
-     * the value <em>telemetry</em>.
-     *
-     * @return The endpoint name.
-     */
-    String getEndpoint();
-
-    /**
-     * Closes the AMQP link with the Hono server this sender is using.
-     * <p>
-     * The underlying AMQP connection to the server is not affected by this operation.
-     *
-     * @param closeHandler A handler that is called back with the outcome of the attempt to close the link.
-     * @throws NullPointerException if the handler is {@code null}.
-     */
-    void close(Handler<AsyncResult<Void>> closeHandler);
-
-    /**
-     * Checks if this sender is (locally) open.
-     * <p>
-     * Note that the value returned is valid during execution of the current vert.x handler only.
-     *
-     * @return {@code true} if this sender can be used to send messages to the peer.
-     */
-    boolean isOpen();
-
-    /**
-     * Sends an AMQP 1.0 message to the endpoint configured for this client.
-     *
-     * @param message The message to send.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery will be locally settled only, if the implementing class
-     *         uses <em>at most once</em> delivery semantics. Otherwise, the delivery
-     *         will be settled locally and remotely (<em>at least once</em> semantics).
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit. It will be failed with either a
-     *         {@code ServerErrorException} or a {@link ClientErrorException}
-     *         if the message could not be processed and the implementing class uses
-     *         <em>at least once</em> delivery semantics.
-     * @throws NullPointerException if the message is {@code null}.
-     */
-    Future<ProtonDelivery> send(Message message);
-
-    /**
-     * Sends an AMQP 1.0 message to the endpoint configured for this client.
-     * <p>
-     * This default implementation simply returns the result of {@link #send(Message)}.
-     *
-     * @param message The message to send.
-     * @param context The currently active OpenTracing span. An implementation
-     *         should use this as the parent for any span it creates for tracing
-     *         the execution of this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if message is {@code null}.
-     */
-    default Future<ProtonDelivery> send(Message message, SpanContext context) {
-        return send(message);
-    }
-
-    /**
-     * Sends an AMQP 1.0 message to the peer and waits for the disposition indicating
-     * the outcome of the transfer.
-     *
-     * @param message The message to send.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been accepted (and settled)
-     *         by the peer.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if the message is {@code null}.
-     */
-    Future<ProtonDelivery> sendAndWaitForOutcome(Message message);
-
-    /**
-     * Sends an AMQP 1.0 message to the peer and waits for the disposition indicating
-     * the outcome of the transfer.
-     * <p>
-     * This default implementation simply returns the result of {@link #sendAndWaitForOutcome(Message)}.
-     *
-     * @param message The message to send.
-     * @param context The currently active OpenTracing span. An implementation
-     *         should use this as the parent for any span it creates for tracing
-     *         the execution of this operation.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been accepted (and settled)
-     *         by the peer.
-     *         <p>
-     *         The future will be failed with a {@link ServerErrorException} if the message
-     *         could not be sent due to a lack of credit.
-     *         If an event is sent which cannot be processed by the peer the future will
-     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
-     *         depending on the reason for the failure to process the message.
-     * @throws NullPointerException if message is {@code null}.
-     */
-    default Future<ProtonDelivery> sendAndWaitForOutcome(Message message, SpanContext context) {
-        return sendAndWaitForOutcome(message);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java b/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java
deleted file mode 100644
index 2353e700b..000000000
--- a/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonObject;
-
-/**
- * A client for accessing Hono's Registration API.
- * <p>
- * An instance of this interface is always scoped to a specific tenant.
- * <p>
- * See Hono's <a href="https://www.eclipse.org/hono/docs/api/device-registration/">
- * Registration API specification</a> for a description of the result codes returned.
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.DeviceRegistrationClient} instead.
- */
-@Deprecated
-public interface RegistrationClient extends RequestResponseClient {
-
-    /**
-     * Asserts that a device is registered and <em>enabled</em>.
-     *
-     * @param deviceId The ID of the device to get the assertion for.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 200 has been received from the
-     *         registration service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/device-registration/#assert-device-registration">
-     *         Assert Device Registration</a>.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.
-     * @throws NullPointerException if device ID is {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<JsonObject> assertRegistration(String deviceId);
-
-    /**
-     * Asserts that a device is registered and <em>enabled</em>.
-     *
-     * @param deviceId The ID of the device to get the assertion for.
-     * @param gatewayId The gateway that wants to act on behalf of the device.
-     *                  <p>
-     *                  If not {@code null}, the service will verify that the gateway
-     *                  is enabled and authorized to <em>act on behalf of</em> the
-     *                  given device before asserting the device's registration status.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 200 has been received from the
-     *         registration service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/device-registration/#assert-device-registration">
-     *         Assert Device Registration</a>.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.
-     * @throws NullPointerException if device ID is {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    Future<JsonObject> assertRegistration(String deviceId, String gatewayId);
-
-    /**
-     * Asserts that a device is registered and <em>enabled</em>.
-     * <p>
-     * This default implementation simply returns the result of {@link #assertRegistration(String, String)}.
-     *
-     * @param deviceId The ID of the device to get the assertion for.
-     * @param gatewayId The gateway that wants to act on behalf of the device.
-     *                  <p>
-     *                  If not {@code null}, the service will verify that the gateway
-     *                  is enabled and authorized to <em>act on behalf of</em> the
-     *                  given device before asserting the device's registration status.
-     * @param context The currently active OpenTracing span. An implementation
-     *         should use this as the parent for any span it creates for tracing
-     *         the execution of this operation.
-     * @return A future indicating the result of the operation.
-     *         <p>
-     *         The future will succeed if a response with status 200 has been received from the
-     *         registration service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/device-registration/#assert-device-registration">
-     *         Assert Device Registration</a>.
-     *         <p>
-     *         Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.
-     * @throws NullPointerException if device ID is {@code null}.
-     * @see RequestResponseClient#setRequestTimeout(long)
-     */
-    default Future<JsonObject> assertRegistration(
-            final String deviceId,
-            final String gatewayId,
-            final SpanContext context) {
-
-        return assertRegistration(deviceId, gatewayId);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
deleted file mode 100644
index d3991e599..000000000
--- a/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.impl.RegistrationClientFactoryImpl;
-
-import io.vertx.core.Future;
-
-/**
- * A factory for creating clients for Hono's Device Registration API.
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.DeviceRegistrationClient} instead.
- */
-@Deprecated
-public interface RegistrationClientFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static RegistrationClientFactory create(final HonoConnection connection) {
-        return new RegistrationClientFactoryImpl(connection, null, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param cacheProvider The cache provider to use for creating caches for tenant objects
-     *                      or {@code null} if tenant objects should not be cached.
-     * @param samplerFactory The sampler factory to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static RegistrationClientFactory create(final HonoConnection connection, final CacheProvider cacheProvider, final SendMessageSampler.Factory samplerFactory) {
-        return new RegistrationClientFactoryImpl(connection, cacheProvider, samplerFactory);
-    }
-
-    /**
-     * Gets a client for invoking operations on a service implementing Hono's <em>Device Registration</em> API.
-     *
-     * @param tenantId The tenant to manage device registration data for.
-     * @return A future that will complete with the registration client (if successful) or fail if the client cannot be
-     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
-     *         client for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<RegistrationClient> getOrCreateRegistrationClient(String tenantId);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
deleted file mode 100644
index ed8e04094..000000000
--- a/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Handler;
-
-/**
- * Interface for common methods that all clients that follow the request response pattern need to implement.
- */
-@Deprecated
-public interface RequestResponseClient extends CreditBasedSender {
-    /**
-     * Closes the AMQP link(s) with the Hono server this client is configured to use.
-     * <p>
-     * The underlying AMQP connection to the server is not affected by this operation.
-     * </p>
-     *
-     * @param closeHandler A handler that is called back with the result of the attempt to close the links.
-     */
-    void close(Handler<AsyncResult<Void>> closeHandler);
-
-    /**
-     * Checks if this client's sender and receiver are (locally) open.
-     *
-     * @return {@code true} if this client can be used to exchange messages with the peer.
-     */
-    boolean isOpen();
-
-    /**
-     * Sets the period of time after which any requests are considered to have timed out.
-     * <p>
-     * The client will fail the result handler passed in to any of the operations if no response
-     * has been received from the peer after the given amount of time.
-     * <p>
-     * When setting this property to 0, requests do not time out at all. Note that this will
-     * allow for unanswered requests piling up in the client, which eventually may cause the
-     * client to run out of memory.
-     *
-     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.
-     * @throws IllegalArgumentException if the value is &lt; 0
-     */
-    void setRequestTimeout(long timoutMillis);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/TenantClient.java b/client/src/main/java/org/eclipse/hono/client/TenantClient.java
deleted file mode 100644
index da89c71b9..000000000
--- a/client/src/main/java/org/eclipse/hono/client/TenantClient.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import javax.security.auth.x500.X500Principal;
-
-import org.eclipse.hono.util.TenantObject;
-
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-
-/**
- * A client for accessing Hono's Tenant API.
- * <p>
- * See Hono's <a href="https://www.eclipse.org/hono/docs/api/tenant">
- * Tenant API specification</a> for a description of the result codes returned.
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.TenantClient} instead.
- */
-@Deprecated
-public interface TenantClient extends RequestResponseClient {
-
-    /**
-     * Gets configuration information for a tenant.
-     *
-     * @param tenantId The id of the tenant to retrieve details for.
-     * @return A future indicating the result of the operation.
-     *         <ul>
-     *         <li>The future will succeed if a response with status 200 has been received from the
-     *         tenant service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/tenant/#get-tenant-information">
-     *         Get Tenant Information</a>.</li>
-     *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.</li>
-     *         </ul>
-     * @throws NullPointerException if tenant ID is {@code null}.
-     */
-    Future<TenantObject> get(String tenantId);
-
-    /**
-     * Gets configuration information for a tenant.
-     * <p>
-     * This default implementation simply returns the result of
-     * {@link #get(String)}.
-     *
-     * @param tenantId The id of the tenant to retrieve details for.
-     * @param context The currently active OpenTracing span. An implementation
-     *         should use this as the parent for any span it creates for tracing
-     *         the execution of this operation.
-     * @return A future indicating the result of the operation.
-     *         <ul>
-     *         <li>The future will succeed if a response with status 200 has been received from the
-     *         tenant service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/tenant/#get-tenant-information">
-     *         Get Tenant Information</a>.</li>
-     *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.</li>
-     *         </ul>
-     * @throws NullPointerException if tenant ID is {@code null}.
-     */
-    default Future<TenantObject> get(final String tenantId, final SpanContext context) {
-        return get(tenantId);
-    }
-
-    /**
-     * Gets tenant configuration information for the <em>subject DN</em>
-     * of a trusted certificate authority.
-     * <p>
-     * This method can e.g. be used when trying to authenticate a device based on
-     * an X.509 client certificate. Using this method, the <em>issuer DN</em> from the
-     * client's certificate can be used to determine the tenant that the device belongs to.
-     *
-     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate
-     *                  that has been configured for the tenant.
-     * @return A future indicating the result of the operation.
-     *         <ul>
-     *         <li>The future will succeed if a response with status 200 has been received from the
-     *         tenant service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/tenant/#get-tenant-information">
-     *         Get Tenant Information</a>.</li>
-     *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.</li>
-     *         </ul>
-     * @throws NullPointerException if subject DN is {@code null}.
-     */
-    Future<TenantObject> get(X500Principal subjectDn);
-
-    /**
-     * Gets tenant configuration information for the <em>subject DN</em>
-     * of a trusted certificate authority.
-     * <p>
-     * This method can e.g. be used when trying to authenticate a device based on
-     * an X.509 client certificate. Using this method, the <em>issuer DN</em> from the
-     * client's certificate can be used to determine the tenant that the device belongs to.
-     * <p>
-     * This default implementation simply returns the result of
-     * {@link #get(X500Principal)}.
-     *
-     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate
-     *                  that has been configured for the tenant.
-     * @param context The currently active OpenTracing span. An implementation
-     *         should use this as the parent for any span it creates for tracing
-     *         the execution of this operation.
-     * @return A future indicating the result of the operation.
-     *         <ul>
-     *         <li>The future will succeed if a response with status 200 has been received from the
-     *         tenant service. The JSON object will then contain values as defined in
-     *         <a href="https://www.eclipse.org/hono/docs/api/tenant/#get-tenant-information">
-     *         Get Tenant Information</a>.</li>
-     *         <li>Otherwise, the future will fail with a {@link ServiceInvocationException} containing
-     *         the (error) status code returned by the service.</li>
-     *         </ul>
-     * @throws NullPointerException if subject DN is {@code null}.
-     */
-    default Future<TenantObject> get(final X500Principal subjectDn, final SpanContext context) {
-        return get(subjectDn);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/TenantClientFactory.java b/client/src/main/java/org/eclipse/hono/client/TenantClientFactory.java
deleted file mode 100644
index 3db3bba6b..000000000
--- a/client/src/main/java/org/eclipse/hono/client/TenantClientFactory.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.impl.TenantClientFactoryImpl;
-
-import io.vertx.core.Future;
-
-/**
- * A factory for creating clients for Hono's Tenant API.
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.amqp.ProtonBasedTenantClient} instead.
- */
-@Deprecated
-public interface TenantClientFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static TenantClientFactory create(final HonoConnection connection) {
-        return new TenantClientFactoryImpl(connection, null, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param cacheProvider The provider to use for creating caches for tenant objects
-     *                      or {@code null} if tenant objects should not be cached.
-     * @param samplerFactory The sampler factory to use.
-     * @return The factory.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    static TenantClientFactory create(final HonoConnection connection, final CacheProvider cacheProvider, final SendMessageSampler.Factory samplerFactory) {
-        return new TenantClientFactoryImpl(connection, cacheProvider, samplerFactory);
-    }
-
-    /**
-     * Gets a client for interacting with Hono's <em>Tenant</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @return A future that will complete with the tenant client (if successful) or fail if the client cannot be
-     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
-     *         client for the same tenant is already being executed.
-     */
-    Future<TenantClient> getOrCreateTenantClient();
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java
deleted file mode 100644
index 25bc56a9e..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * Abstract client for consuming messages from a Hono server.
- */
-public abstract class AbstractConsumer extends AbstractHonoClient implements MessageConsumer {
-
-    private Handler<String> localCloseHandler;
-
-    /**
-     * Creates an abstract message consumer.
-     *
-     * @param connection The connection to use.
-     * @param receiver The proton receiver link.
-     */
-    protected AbstractConsumer(final HonoConnection connection, final ProtonReceiver receiver) {
-
-        super(connection);
-        this.receiver = receiver;
-    }
-
-    /**
-     * Sets a handler which will be invoked after this consumer has been
-     * locally closed.
-     *
-     * @param handler The handler.
-     */
-    public void setLocalCloseHandler(final Handler<String> handler) {
-        this.localCloseHandler = handler;
-    }
-
-    @Override
-    public int getRemainingCredit() {
-        return receiver.getCredit() - receiver.getQueued();
-    }
-
-    @Override
-    public void flow(final int credits) throws IllegalStateException {
-        receiver.flow(credits);
-    }
-
-    @Override
-    public void close(final Handler<AsyncResult<Void>> closeHandler) {
-
-        closeLinks(ok -> {
-            if (localCloseHandler != null) {
-                localCloseHandler.handle(receiver.getSource().getAddress());
-            }
-            if (closeHandler != null) {
-                closeHandler.handle(Future.succeededFuture());
-            }
-        });
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractDownstreamSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractDownstreamSender.java
deleted file mode 100644
index d41bcc579..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractDownstreamSender.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-import java.util.Map;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.MessageHelper;
-
-import io.vertx.core.Future;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for publishing messages to Hono.
- */
-public abstract class AbstractDownstreamSender extends AbstractSender implements DownstreamSender {
-
-    /**
-     * A counter to be used for creating message IDs.
-     */
-    protected static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
-
-    private static final Pattern CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
-
-    /**
-     * Creates a new sender.
-     *
-     * @param connection The connection to use for interacting with the server.
-     * @param sender The sender link to send messages over.
-     * @param tenantId The identifier of the tenant that the
-     *           devices belong to which have published the messages
-     *           that this sender is used to send downstream.
-     * @param sampler The sampler for sending messages.
-     * @param targetAddress The target address to send the messages to.
-     * @throws NullPointerException if any of the parameters except targetAddress is {@code null}.
-     */
-    protected AbstractDownstreamSender(
-            final HonoConnection connection,
-            final ProtonSender sender,
-            final String tenantId,
-            final String targetAddress,
-            final SendMessageSampler sampler) {
-
-        super(connection, sender, tenantId, targetAddress, sampler);
-    }
-
-    @Override
-    public final Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType) {
-        return send(deviceId, null, payload, contentType);
-    }
-
-    @Override
-    public final Future<ProtonDelivery> send(final String deviceId, final String payload, final String contentType) {
-        return send(deviceId, null, payload, contentType);
-    }
-
-    @Override
-    public final Future<ProtonDelivery> send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType) {
-        Objects.requireNonNull(payload);
-        final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
-        return send(deviceId, properties, payload.getBytes(charset), contentType);
-    }
-
-    @Override
-    public final Future<ProtonDelivery> send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType) {
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(payload);
-        Objects.requireNonNull(contentType);
-
-        final Message msg = ProtonHelper.message();
-        msg.setAddress(getTo(deviceId));
-        MessageHelper.setPayload(msg, contentType, payload);
-        setApplicationProperties(msg, properties);
-        MessageHelper.addDeviceId(msg, deviceId);
-        return send(msg);
-    }
-
-    private Charset getCharsetForContentType(final String contentType) {
-
-        final Matcher m = CHARSET_PATTERN.matcher(contentType);
-        if (m.matches()) {
-            return Charset.forName(m.group(1));
-        } else {
-            return StandardCharsets.UTF_8;
-        }
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
deleted file mode 100644
index ae43db9c9..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.References;
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A base class for implementing Hono API clients.
- * <p>
- * Holds a sender and a receiver to an AMQP 1.0 server and provides
- * support for closing these links gracefully.
- */
-public abstract class AbstractHonoClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(AbstractHonoClient.class);
-
-    /**
-     * The connection to the server.
-     */
-    protected final HonoConnection connection;
-
-    /**
-     * The vertx-proton object used for sending messages to the server.
-     */
-    protected ProtonSender sender;
-    /**
-     * The vertx-proton object used for receiving messages from the server.
-     */
-    protected ProtonReceiver receiver;
-    /**
-     * The capabilities offered by the peer.
-     */
-    protected List<Symbol> offeredCapabilities = Collections.emptyList();
-
-    /**
-     * Creates a client for a connection.
-     *
-     * @param connection The connection to use.
-     * @throws NullPointerException if connection is {@code null}.
-     */
-    protected AbstractHonoClient(final HonoConnection connection) {
-        this.connection = Objects.requireNonNull(connection);
-    }
-
-    /**
-     * Marks an <em>OpenTracing</em> span as erroneous and logs an exception.
-     * <p>
-     * This method does <em>not</em> finish the span.
-     *
-     * @param span The span to mark.
-     * @param error The exception that has occurred. If the exception is a
-     *              {@link ServiceInvocationException} then a {@link Tags#HTTP_STATUS}
-     *              tag is added containing the exception's error code property value.
-     * @throws NullPointerException if error is {@code null}.
-     */
-    protected final void logError(final Span span, final Throwable error) {
-        if (span != null) {
-            if (ServiceInvocationException.class.isInstance(error)) {
-                final ServiceInvocationException e = (ServiceInvocationException) error;
-                Tags.HTTP_STATUS.set(span, e.getErrorCode());
-            }
-            TracingHelper.logError(span, error);
-        }
-    }
-
-    /**
-     * Creates a new <em>OpenTracing</em> span for tracing the execution of a service invocation.
-     * <p>
-     * The returned span will already contain the following tags:
-     * <ul>
-     * <li>{@link Tags#COMPONENT} - set to <em>hono-client</em></li>
-     * <li>{@link Tags#PEER_HOSTNAME} - set to {@link org.eclipse.hono.config.ClientConfigProperties#getHost()}</li>
-     * <li>{@link Tags#PEER_PORT} - set to {@link org.eclipse.hono.config.ClientConfigProperties#getPort()}</li>
-     * <li>{@link TracingHelper#TAG_PEER_CONTAINER} - set to {@link HonoConnection#getRemoteContainerId()}</li>
-     * </ul>
-     *
-     * @param parent The existing span. If not {@code null} then the new span will have a
-     *                     {@link References#CHILD_OF} reference to the existing span.
-     * @param operationName The operation name that the span should be created for.
-     * @return The new span.
-     */
-    protected final Span newChildSpan(final SpanContext parent, final String operationName) {
-
-        return newSpan(parent, References.CHILD_OF, operationName);
-    }
-
-    /**
-     * Creates a new <em>OpenTracing</em> span for tracing the execution of a service invocation.
-     * <p>
-     * The returned span will already contain the following tags:
-     * <ul>
-     * <li>{@link Tags#COMPONENT} - set to <em>hono-client</em></li>
-     * <li>{@link Tags#PEER_HOSTNAME} - set to {@link org.eclipse.hono.config.ClientConfigProperties#getHost()}</li>
-     * <li>{@link Tags#PEER_PORT} - set to {@link org.eclipse.hono.config.ClientConfigProperties#getPort()}</li>
-     * <li>{@link TracingHelper#TAG_PEER_CONTAINER} - set to {@link HonoConnection#getRemoteContainerId()}</li>
-     * </ul>
-     *
-     * @param parent The existing span. If not {@code null} then the new span will have a
-     *                     {@link References#FOLLOWS_FROM} reference to the existing span.
-     * @param operationName The operation name that the span should be created for.
-     * @return The new span.
-     */
-    protected final Span newFollowingSpan(final SpanContext parent, final String operationName) {
-
-        return newSpan(parent, References.FOLLOWS_FROM, operationName);
-    }
-
-    private Span newSpan(final SpanContext parent, final String referenceType, final String operationName) {
-
-        return TracingHelper.buildSpan(connection.getTracer(), parent, operationName, referenceType)
-                .ignoreActiveSpan()
-                .withTag(Tags.COMPONENT.getKey(), "hono-client")
-                .withTag(Tags.PEER_HOSTNAME.getKey(), connection.getConfig().getHost())
-                .withTag(Tags.PEER_PORT.getKey(), connection.getConfig().getPort())
-                .withTag(TracingHelper.TAG_PEER_CONTAINER.getKey(), connection.getRemoteContainerId())
-                .start();
-    }
-
-    /**
-     * Checks if this client supports a certain capability.
-     * <p>
-     * The result of this method should only be considered reliable
-     * if this client is open.
-     *
-     * @param capability The capability to check support for.
-     * @return {@code true} if the capability is included in the list of
-     *         capabilities that the peer has offered during link
-     *         establishment, {@code false} otherwise.
-     */
-    public final boolean supportsCapability(final Symbol capability) {
-        if (capability == null) {
-            return false;
-        } else {
-            return offeredCapabilities.contains(capability);
-        }
-    }
-
-    /**
-     * Closes this client's sender and receiver links to Hono.
-     * Link resources will be freed after the links are closed.
-     *
-     * @param closeHandler The handler to notify once the link has been closed.
-     * @throws NullPointerException if the given handler is {@code null}.
-     */
-    protected final void closeLinks(final Handler<Void> closeHandler) {
-
-        Objects.requireNonNull(closeHandler);
-
-        final Handler<Void> closeReceiver = s -> {
-            if (receiver != null) {
-                LOG.debug("locally closing receiver link [{}]", receiver.getSource().getAddress());
-            }
-            connection.closeAndFree(receiver, receiverClosed -> closeHandler.handle(null));
-        };
-
-        if (sender != null) {
-            LOG.debug("locally closing sender link [{}]", sender.getTarget().getAddress());
-            connection.closeAndFree(sender, senderClosed -> closeReceiver.handle(null));
-        } else if (receiver != null) {
-            closeReceiver.handle(null);
-        }
-    }
-
-    /**
-     * Set the application properties for a Proton Message but do a check for all properties first if they only contain
-     * values that the AMQP 1.0 spec allows.
-     *
-     * @param msg The Proton message. Must not be null.
-     * @param properties The map containing application properties.
-     * @throws NullPointerException if the message passed in is null.
-     * @throws IllegalArgumentException if the properties contain any value that AMQP 1.0 disallows.
-     */
-    protected static final void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
-        if (properties != null) {
-            final Map<String, Object> propsToAdd = new HashMap<>();
-            // check the three types not allowed by AMQP 1.0 spec for application properties (list, map and array)
-            for (final Map.Entry<String, ?> entry: properties.entrySet()) {
-                if (entry.getValue() != null) {
-                    if (entry.getValue() instanceof List) {
-                        throw new IllegalArgumentException(String.format("Application property %s can't be a List", entry.getKey()));
-                    } else if (entry.getValue() instanceof Map) {
-                        throw new IllegalArgumentException(String.format("Application property %s can't be a Map", entry.getKey()));
-                    } else if (entry.getValue().getClass().isArray()) {
-                        throw new IllegalArgumentException(String.format("Application property %s can't be an Array", entry.getKey()));
-                    }
-                }
-                propsToAdd.put(entry.getKey(), entry.getValue());
-            }
-
-            final ApplicationProperties applicationProperties = new ApplicationProperties(propsToAdd);
-            msg.setApplicationProperties(applicationProperties);
-        }
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
deleted file mode 100644
index ce323d6f3..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ /dev/null
@@ -1,1158 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.UUID;
-import java.util.function.Function;
-import java.util.function.Supplier;
-
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Modified;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.cache.ExpiringValueCache;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClient;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.HonoProtonHelper;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RequestResponseApiConstants;
-import org.eclipse.hono.util.RequestResponseResult;
-import org.eclipse.hono.util.TriTuple;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based parent class for the implementation of API clients that follow the request response pattern.
- * <p>
- * Subclasses only need to implement some abstract helper methods (see the method descriptions) and their own
- * API specific methods. This allows for implementation classes that focus on the API specific code.
- *
- * @param <R> The type of result this client expects the peer to return.
- *
- */
-public abstract class AbstractRequestResponseClient<R extends RequestResponseResult<?>>
-        extends AbstractHonoClient implements RequestResponseClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestResponseClient.class);
-    private static final int[] CACHEABLE_STATUS_CODES = new int[] {
-                            HttpURLConnection.HTTP_OK,
-                            HttpURLConnection.HTTP_NOT_AUTHORITATIVE,
-                            HttpURLConnection.HTTP_PARTIAL,
-                            HttpURLConnection.HTTP_MULT_CHOICE,
-                            HttpURLConnection.HTTP_MOVED_PERM,
-                            HttpURLConnection.HTTP_GONE
-    };
-
-    /**
-     * The target address of the sender link used to send requests to the service.
-     */
-    protected final String linkTargetAddress;
-    /**
-     * The sampler to use for timing message processing.
-     */
-    protected final SendMessageSampler sampler;
-
-    private final Map<Object, TriTuple<Handler<AsyncResult<R>>, Object, Span>> replyMap = new HashMap<>();
-    private Handler<Void> drainHandler;
-    private final String replyToAddress;
-    private final String tenantId;
-
-    /**
-     * A cache to use for responses received from the service.
-     */
-    private ExpiringValueCache<Object, R> responseCache;
-
-    private long requestTimeoutMillis;
-
-    /**
-     * Creates a request-response client.
-     * <p>
-     * The created instance's sender link's target address is set to
-     * <em>${name}[/${tenantId}]</em> and the receiver link's source
-     * address is set to <em>${name}[/${tenantId}]/${UUID}</em>
-     * (where ${name} is the value returned by {@link #getName()}
-     * and ${UUID} is a generated UUID).
-     * <p>
-     * The latter address is also used as the value of the <em>reply-to</em>
-     * property of all request messages sent by this client.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to the service.
-     * @param tenantId The tenant that the client should be scoped to or {@code null} if the
-     *                 client should not be scoped to a tenant.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.
-     */
-    protected AbstractRequestResponseClient(
-            final HonoConnection connection,
-            final String tenantId,
-            final SendMessageSampler sampler) {
-
-        this(connection, tenantId, UUID.randomUUID().toString(), sampler);
-    }
-
-    /**
-     * Creates a request-response client.
-     * <p>
-     * The created instance's sender link's target address is set to
-     * <em>${name}[/${tenantId}]</em> and the receiver link's source
-     * address is set to <em>${name}[/${tenantId}]/${replyId}</em>
-     * (where ${name} is the value returned by {@link #getName()}).
-     * <p>
-     * The latter address is also used as the value of the <em>reply-to</em>
-     * property of all request messages sent by this client.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to the service.
-     * @param tenantId The tenant that the client should be scoped to or {@code null} if the
-     *                 client should not be scoped to a tenant.
-     * @param replyId The replyId to use in the reply-to address.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.
-     */
-    protected AbstractRequestResponseClient(
-            final HonoConnection connection,
-            final String tenantId,
-            final String replyId,
-            final SendMessageSampler sampler) {
-
-        super(connection);
-        Objects.requireNonNull(replyId);
-        this.sampler = Objects.requireNonNull(sampler);
-        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();
-        if (tenantId == null) {
-            this.linkTargetAddress = getName();
-            this.replyToAddress = String.format("%s/%s", getReplyToEndpointName(), replyId);
-        } else {
-            this.linkTargetAddress = String.format("%s/%s", getName(), tenantId);
-            this.replyToAddress = String.format("%s/%s/%s", getReplyToEndpointName(), tenantId, replyId);
-        }
-        this.tenantId = tenantId;
-    }
-
-    /**
-     * Creates a request-response client.
-     * <p>
-     * The instance created is scoped to the given device.
-     * In particular, the sender link's target address is set to
-     * <em>${name}/${tenantId}/${deviceId}</em> and the receiver link's source
-     * address is set to <em>${name}/${tenantId}/${deviceId}/${replyId}</em>
-     * (where ${name} is the value returned by {@link #getName()}).
-     * <p>
-     * The latter address is also used as the value of the <em>reply-to</em>
-     * property of all request messages sent by this client.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to the service.
-     * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to create the client for.
-     * @param replyId The replyId to use in the reply-to address.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected AbstractRequestResponseClient(
-            final HonoConnection connection,
-            final String tenantId,
-            final String deviceId,
-            final String replyId,
-            final SendMessageSampler sampler) {
-
-        super(connection);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(replyId);
-        Objects.requireNonNull(sampler);
-
-        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();
-        this.linkTargetAddress = String.format("%s/%s/%s", getName(), tenantId, deviceId);
-        this.replyToAddress = String.format("%s/%s/%s/%s", getReplyToEndpointName(), tenantId, deviceId, replyId);
-        this.tenantId = tenantId;
-        this.sampler = sampler;
-    }
-
-    /**
-     * Creates a request-response client for a sender and receiver link.
-     *
-     * @param connection The connection to the service.
-     * @param tenantId The tenant that the client should be scoped to or {@code null} if the
-     *                 client should not be scoped to a tenant.
-     * @param sender The AMQP 1.0 link to use for sending requests to the peer.
-     * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.
-     */
-    protected AbstractRequestResponseClient(
-            final HonoConnection connection,
-            final String tenantId,
-            final ProtonSender sender,
-            final ProtonReceiver receiver,
-            final SendMessageSampler sampler) {
-
-        this(connection, tenantId, sampler);
-        this.sender = Objects.requireNonNull(sender);
-        this.receiver = Objects.requireNonNull(receiver);
-    }
-
-    /**
-     * Sets a cache for responses received from the service.
-     *
-     * @param cache The cache or {@code null} if no responses should be cached.
-     */
-    public final void setResponseCache(final ExpiringValueCache<Object, R> cache) {
-        this.responseCache = cache;
-        LOG.debug("enabling caching of responses from {}", getName());
-    }
-
-    /**
-     * Gets the default value for the period of time after which an entry in the response cache
-     * is considered invalid.
-     * <p>
-     * The value is derived from the configuration properties as follows:
-     * <ol>
-     * <li>if the properties are of type {@link RequestResponseClientConfigProperties}
-     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>
-     * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT
-     * default timeout value} is used</li>
-     * </ol>
-     *
-     * @return The timeout period in seconds.
-     */
-    protected final long getResponseCacheDefaultTimeout() {
-        if (connection.getConfig() instanceof RequestResponseClientConfigProperties) {
-            return ((RequestResponseClientConfigProperties) connection.getConfig()).getResponseCacheDefaultTimeout();
-        } else {
-            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;
-        }
-    }
-
-    /**
-     * Sets the period of time after which any requests are considered to have timed out.
-     * <p>
-     * The client will fail the result handler passed in to any of the operations if no response
-     * has been received from the peer after the given amount of time.
-     * <p>
-     * When setting this property to 0, requests do not time out at all. Note that this will
-     * allow for unanswered requests piling up in the client, which eventually may cause the
-     * client to run out of memory.
-     * <p>
-     * The default value of this property is 200 milliseconds.
-     *
-     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.
-     * @throws IllegalArgumentException if the value is &lt; 0
-     */
-    @Override
-    public final void setRequestTimeout(final long timoutMillis) {
-
-        if (timoutMillis < 0) {
-            throw new IllegalArgumentException("request timeout must be >= 0");
-        } else {
-            this.requestTimeoutMillis = timoutMillis;
-        }
-    }
-
-    @Override
-    public final int getCredit() {
-        if (sender == null) {
-            return 0;
-        } else {
-            return sender.getCredit();
-        }
-    }
-
-    @Override
-    public final void sendQueueDrainHandler(final Handler<Void> handler) {
-        if (this.drainHandler != null) {
-            throw new IllegalStateException("already waiting for replenishment with credit");
-        } else {
-            this.drainHandler = Objects.requireNonNull(handler);
-            sender.sendQueueDrainHandler(replenishedSender -> {
-                LOG.trace("command client has received FLOW [credits: {}, queued:{}]", replenishedSender.getCredit(),
-                        replenishedSender.getQueued());
-                final Handler<Void> currentHandler = this.drainHandler;
-                this.drainHandler = null;
-                if (currentHandler != null) {
-                    currentHandler.handle(null);
-                }
-            });
-        }
-    }
-
-    /**
-     * Gets the name of the endpoint that this client targets at.
-     *
-     * @return The name of the endpoint for this client.
-     */
-    protected abstract String getName();
-
-    /**
-     * Gets the name of the endpoint that will be used for the reply-to address.
-     * <p>
-     * This default implementation returns the endpoint returned by {@link #getName()}.
-     * <p>
-     * Subclasses may override this method in order to use a different endpoint name.
-     *
-     * @return The name of the endpoint for the reply-to address.
-     */
-    protected String getReplyToEndpointName() {
-        return getName();
-    }
-
-    /**
-     * Build a unique messageId for a request that serves as an identifier for a new message.
-     *
-     * @return The unique messageId;
-     */
-    protected abstract String createMessageId();
-
-    /**
-     * Creates a result object from the status and payload of a response received from the endpoint.
-     *
-     * @param status The status of the response.
-     * @param contentType A media type describing the payload or {@code null} if unknown.
-     * @param payload The representation of the payload (may be {@code null}).
-     * @param cacheDirective Restrictions regarding the caching of the payload (may be {@code null}).
-     * @param applicationProperties Arbitrary properties conveyed in the response message's
-     *                              <em>application-properties</em>.
-     * @return The result object.
-     */
-    protected abstract R getResult(
-            int status,
-            String contentType,
-            Buffer payload,
-            CacheDirective cacheDirective,
-            ApplicationProperties applicationProperties);
-
-    /**
-     * The default target address for request messages sent with this client.
-     * <p>
-     * This default implementation returns the link target address.
-     * <p>
-     * Subclasses may override this method in order to use a different address as default for sending messages.
-     *
-     * @return The message target address.
-     */
-    protected String getDefaultMessageTargetAddress() {
-        return linkTargetAddress;
-    }
-
-    /**
-     * Creates the sender and receiver links to the peer for sending requests
-     * and receiving responses.
-     *
-     * @return A future indicating the outcome. The future will succeed if the links
-     *         have been created.
-     */
-    protected final Future<Void> createLinks() {
-        return createLinks(null, null);
-    }
-
-    /**
-     * Creates the sender and receiver links to the peer for sending requests
-     * and receiving responses.
-     *
-     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).
-     * @return A future indicating the outcome. The future will succeed if the links
-     *         have been created.
-     */
-    protected final Future<Void> createLinks(final Handler<String> senderCloseHook,
-            final Handler<String> receiverCloseHook) {
-
-        return createReceiver(replyToAddress, receiverCloseHook)
-                .compose(recv -> {
-                    this.receiver = recv;
-                    return createSender(linkTargetAddress, senderCloseHook);
-                }).compose(sender -> {
-                    LOG.debug("request-response client for peer [{}] created", connection.getConfig().getHost());
-                    this.sender = sender;
-                    return Future.succeededFuture();
-                });
-    }
-
-    private Future<ProtonSender> createSender(final String targetAddress, final Handler<String> closeHook) {
-
-        return connection.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook);
-    }
-
-    private Future<ProtonReceiver> createReceiver(final String sourceAddress, final Handler<String> closeHook) {
-
-        return connection.createReceiver(sourceAddress, ProtonQoS.AT_LEAST_ONCE, this::handleResponse, closeHook);
-    }
-
-    /**
-     * Handles a response received from the peer.
-     * <p>
-     * In particular, this method tries to correlate the message with a previous request
-     * using the message's <em>correlation-id</em> and, if successful, the delivery is <em>accepted</em>
-     * and the message is passed to the handler registered with the original request.
-     * <p>
-     * If the response cannot be correlated to a request, e.g. because the request has timed
-     * out, then the delivery is <em>released</em> and the message is silently discarded.
-     * <p>
-     * If the client has specified a cache key for the response when sending the request, then the
-     * {@link #addToCache(Object, RequestResponseResult)} method is invoked
-     * in order to add the response to the configured cache.
-     *
-     * @param delivery The handle for accessing the message's disposition.
-     * @param message The response message.
-     */
-    protected final void handleResponse(final ProtonDelivery delivery, final Message message) {
-
-        // the tuple from the reply map contains
-        // 1. the handler for processing the response and
-        // 2. the key to use for caching the response
-        // 3. the Opentracing span covering the execution
-        final TriTuple<Handler<AsyncResult<R>>, Object, Span> handler = replyMap.remove(message.getCorrelationId());
-
-        if (handler == null) {
-            LOG.debug("discarding unexpected response [reply-to: {}, correlation ID: {}]",
-                    replyToAddress, message.getCorrelationId());
-            ProtonHelper.rejected(delivery, true);
-        } else {
-            final R response = getRequestResponseResult(message);
-            final Span span = handler.three();
-            if (response == null) {
-                LOG.debug("discarding malformed response [reply-to: {}, correlation ID: {}]",
-                        replyToAddress, message.getCorrelationId());
-                handler.one().handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,
-                        "cannot process response from service [" + getName() + "]")));
-                ProtonHelper.released(delivery, true);
-            } else {
-                LOG.debug("received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}, cache-directive: {}]",
-                        replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus(), response.getCacheDirective());
-                addToCache(handler.two(), response);
-                if (span != null) {
-                    span.log("response from peer accepted");
-                }
-                handler.one().handle(Future.succeededFuture(response));
-                ProtonHelper.accepted(delivery, true);
-            }
-        }
-    }
-
-
-    /**
-     * Cancels an outstanding request with a given result.
-     *
-     * @param correlationId The identifier of the request to cancel.
-     * @param result The result to pass to the result handler registered for the correlation ID.
-     * @return {@code true} if a request with the given identifier was found and cancelled.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     * @throws IllegalArgumentException if the result is succeeded.
-     */
-    protected final boolean cancelRequest(final Object correlationId, final AsyncResult<R> result) {
-        Objects.requireNonNull(correlationId);
-        Objects.requireNonNull(result);
-
-        if (result.succeeded()) {
-            throw new IllegalArgumentException("result must be failed");
-        }
-        return cancelRequest(correlationId, result::cause);
-    }
-
-    /**
-     * Cancels an outstanding request with a given failure exception.
-     *
-     * @param correlationId The identifier of the request to cancel.
-     * @param exceptionSupplier The supplier of the failure exception.
-     * @return {@code true} if a request with the given identifier was found and cancelled.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected final boolean cancelRequest(final Object correlationId, final Supplier<Throwable> exceptionSupplier) {
-        Objects.requireNonNull(correlationId);
-        Objects.requireNonNull(exceptionSupplier);
-
-        return Optional.ofNullable(replyMap.remove(correlationId))
-                .map(handler -> {
-                    final Throwable throwable = exceptionSupplier.get();
-                    LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
-                            linkTargetAddress, correlationId, throwable.getMessage());
-                    handler.one().handle(Future.failedFuture(throwable));
-                    return true;
-                })
-                .orElse(false);
-    }
-
-    private R getRequestResponseResult(final Message message) {
-
-        final Integer status = MessageHelper.getStatus(message);
-        if (status == null) {
-            LOG.debug("response message has no status code application property [reply-to: {}, correlation ID: {}]",
-                    replyToAddress, message.getCorrelationId());
-            return null;
-        } else {
-            final CacheDirective cacheDirective = CacheDirective.from(MessageHelper.getCacheDirective(message));
-            return getResult(
-                    status,
-                    message.getContentType(),
-                    MessageHelper.getPayload(message),
-                    cacheDirective,
-                    message.getApplicationProperties());
-        }
-    }
-
-    /**
-     * Creates an AMQP message for a subject and address.
-     * <p>
-     * The message can be extended by arbitrary application properties passed in.
-     *
-     * @param subject The subject system property of the message.
-     * @param address The address of the message, put in the <em>to</em> property.
-     * @param appProperties The map containing arbitrary application properties.
-     *                      Maybe null if no application properties are needed.
-     * @return The Proton message constructed from the provided parameters.
-     * @throws NullPointerException if the subject is {@code null}.
-     * @throws IllegalArgumentException if the application properties contain not AMQP 1.0 compatible values
-     *                  (see {@link AbstractHonoClient#setApplicationProperties(Message, Map)}
-     */
-    private Message createMessage(final String subject, final String address,
-            final Map<String, Object> appProperties) {
-
-        Objects.requireNonNull(subject);
-        final Message msg = ProtonHelper.message();
-        final String messageId = createMessageId();
-        AbstractHonoClient.setApplicationProperties(msg, appProperties);
-        msg.setAddress(address);
-        msg.setReplyTo(replyToAddress);
-        msg.setMessageId(messageId);
-        msg.setSubject(subject);
-        return msg;
-    }
-
-    /**
-     * Creates a request message for a payload and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     * <p>
-     * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, Handler)} with {@code null} for the
-     * properties parameter.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param resultHandler The handler to notify about the outcome of the request.
-     * @throws NullPointerException if any of action or result handler is {@code null}.
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Buffer payload,
-            final Handler<AsyncResult<R>> resultHandler) {
-
-        createAndSendRequest(action, null, payload, resultHandler);
-    }
-
-    /**
-     * Creates a request message for a payload and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     * <p>
-     * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, String, Handler, Object, Span)} with
-     * {@code null} for the properties, content type and cache key parameters.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param resultHandler The handler to notify about the outcome of the request.
-     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
-     * @throws NullPointerException if any of action, result handler or current span is {@code null}.
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Buffer payload,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Span currentSpan) {
-
-        createAndSendRequest(action, null, payload, null, resultHandler, null, currentSpan);
-    }
-
-    /**
-     * Creates a request message for a payload and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     * <p>
-     * This method simply invokes {@link #createAndSendRequest(String, Map, Buffer, Handler)}
-     * with {@code null} for the properties parameter.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param resultHandler The handler to notify about the outcome of the request.
-     * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @throws NullPointerException if any of action, result handler or cacheKey is {@code null}.
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Buffer payload,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey) {
-
-        createAndSendRequest(action, null, payload, resultHandler, cacheKey, null);
-    }
-
-    /**
-     * Creates a request message for a payload and headers and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param properties The headers to include in the request message as AMQP application properties.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
-     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
-     *                      e.g. because there is no connection to the service or there are no credits available
-     *                      for sending the request or the request timed out.
-     * @throws NullPointerException if action or result handler are {@code null}.
-     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
-     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Map<String, Object> properties,
-            final Buffer payload,
-            final Handler<AsyncResult<R>> resultHandler) {
-
-        createAndSendRequest(action, properties, payload, resultHandler, null, null);
-    }
-
-    /**
-     * Creates a request message for a payload with content-type JSON and headers and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     * <p>
-     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
-     * Otherwise, the request message is sent and a timer is started which fails the result handler,
-     * if no response is received within <em>requestTimeout</em> milliseconds.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param properties The headers to include in the request message as AMQP application properties.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
-     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
-     *                      e.g. because there is no connection to the service or there are no credits available
-     *                      for sending the request or the request timed out.
-     * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @param spanContext The currently active OpenTracing span context or {@code null}.
-     * @throws NullPointerException if action or result handler are {@code null}.
-     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
-     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Map<String, Object> properties,
-            final Buffer payload,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey,
-            final SpanContext spanContext) {
-
-        createAndSendRequest(action, properties, payload, RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
-                resultHandler, cacheKey, spanContext);
-    }
-
-    /**
-     * Creates a request message for a payload and headers and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     * <p>
-     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
-     * Otherwise, the request message is sent and a timer is started which fails the result handler,
-     * if no response is received within <em>requestTimeout</em> milliseconds.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param properties The headers to include in the request message as AMQP application properties.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param contentType The content type of the payload.
-     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
-     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
-     *                      e.g. because there is no connection to the service or there are no credits available
-     *                      for sending the request or the request timed out.
-     * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @param spanContext The currently active OpenTracing span context or {@code null}.
-     * @throws NullPointerException if action or result handler are {@code null}.
-     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
-     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Map<String, Object> properties,
-            final Buffer payload,
-            final String contentType,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey,
-            final SpanContext spanContext) {
-
-        final Span currentSpan = newChildSpan(spanContext, "invoke '" + action + "' on " + getName() + " endpoint");
-        createAndSendRequest(action, properties, payload, contentType, ar -> {
-            if (ar.failed()) {
-                Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(ar.cause()));
-                TracingHelper.logError(currentSpan, ar.cause());
-            } else if (ar.result() != null) {
-                Tags.HTTP_STATUS.set(currentSpan, ar.result().getStatus());
-                if (ar.result().isError()) {
-                    Tags.ERROR.set(currentSpan, Boolean.TRUE);
-                }
-            } else {
-                Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-            }
-            currentSpan.finish();
-            resultHandler.handle(ar);
-        }, cacheKey, currentSpan);
-    }
-
-    /**
-     * Creates a request message for a payload and headers and sends it to the peer.
-     * <p>
-     * This method uses the {@link #getDefaultMessageTargetAddress()} method to determine the value of the message's
-     * <em>to</em> property.
-     * <p>
-     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
-     * Otherwise, the request message is sent and a timer is started which fails the result handler,
-     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.
-     * <p>
-     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.
-     * However, the span is never finished by this method.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param properties The headers to include in the request message as AMQP application properties.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param contentType The content type of the payload.
-     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
-     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
-     *                      e.g. because there is no connection to the service or there are no credits available
-     *                      for sending the request or the request timed out.
-     * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
-     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.
-     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
-     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final Map<String, Object> properties,
-            final Buffer payload,
-            final String contentType,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey,
-            final Span currentSpan) {
-
-        createAndSendRequest(action, getDefaultMessageTargetAddress(), properties, payload, contentType, resultHandler,
-                cacheKey, currentSpan);
-    }
-
-    /**
-     * Creates a request message for a payload and headers and sends it to the peer.
-     * <p>
-     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
-     * Otherwise, the request message is sent and a timer is started which fails the result handler,
-     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.
-     * <p>
-     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.
-     * However, the span is never finished by this method.
-     *
-     * @param action The operation that the request is supposed to trigger/invoke.
-     * @param address The address to send the message to.
-     * @param properties The headers to include in the request message as AMQP application properties.
-     * @param payload The payload to include in the request message as an AMQP Value section.
-     * @param contentType The content type of the payload.
-     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
-     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
-     *                      e.g. because there is no connection to the service or there are no credits available
-     *                      for sending the request or the request timed out.
-     * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
-     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.
-     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
-     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
-     */
-    protected final void createAndSendRequest(
-            final String action,
-            final String address,
-            final Map<String, Object> properties,
-            final Buffer payload,
-            final String contentType,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey,
-            final Span currentSpan) {
-
-        Objects.requireNonNull(action);
-        Objects.requireNonNull(resultHandler);
-        Objects.requireNonNull(currentSpan);
-
-        if (isOpen()) {
-            final Message request = createMessage(action, address, properties);
-            MessageHelper.setPayload(request, contentType, payload);
-            sendRequest(request, resultHandler, cacheKey, currentSpan);
-        } else {
-            resultHandler.handle(Future.failedFuture(new ServerErrorException(
-                    HttpURLConnection.HTTP_UNAVAILABLE, "sender and/or receiver link is not open")));
-        }
-    }
-
-    /**
-     * Sends a request message via this client's sender link to the peer.
-     * <p>
-     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
-     * Otherwise, the request message is sent and a timer is started which fails the result handler,
-     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.
-     * <p>
-     * The given span is never finished by this method.
-     *
-     * @param request The message to send.
-     * @param resultHandler The handler to notify about the outcome of the request.
-     * @param cacheKey The key to use for caching the response (if the service allows caching).
-     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.
-     */
-    protected final void sendRequest(
-            final Message request,
-            final Handler<AsyncResult<R>> resultHandler,
-            final Object cacheKey,
-            final Span currentSpan) {
-
-        final String requestTargetAddress = request.getAddress() != null ? request.getAddress() : getDefaultMessageTargetAddress();
-        Tags.MESSAGE_BUS_DESTINATION.set(currentSpan, requestTargetAddress);
-        Tags.SPAN_KIND.set(currentSpan, Tags.SPAN_KIND_CLIENT);
-        Tags.HTTP_METHOD.set(currentSpan, request.getSubject());
-        if (tenantId != null) {
-            currentSpan.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
-        }
-
-        connection.executeOnContext(res -> {
-
-            if (sender.sendQueueFull()) {
-
-                LOG.debug("cannot send request to peer, no credit left for link [link target: {}]", linkTargetAddress);
-                resultHandler.handle(Future.failedFuture(new ServerErrorException(
-                        HttpURLConnection.HTTP_UNAVAILABLE, "no credit available for sending request")));
-
-                sampler.queueFull(tenantId);
-
-            } else {
-
-                final Map<String, Object> details = new HashMap<>(3);
-                final Object correlationId = Optional.ofNullable(request.getCorrelationId()).orElse(request.getMessageId());
-                if (correlationId instanceof String) {
-                    details.put(TracingHelper.TAG_CORRELATION_ID.getKey(), correlationId);
-                }
-                details.put(TracingHelper.TAG_CREDIT.getKey(), sender.getCredit());
-                details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());
-                currentSpan.log(details);
-
-                final TriTuple<Handler<AsyncResult<R>>, Object, Span> handler = TriTuple.of(resultHandler, cacheKey, currentSpan);
-                TracingHelper.injectSpanContext(connection.getTracer(), currentSpan.context(), request);
-                replyMap.put(correlationId, handler);
-
-                final SendMessageSampler.Sample sample = sampler.start(tenantId);
-
-                sender.send(request, deliveryUpdated -> {
-                    final Promise<R> failedResult = Promise.promise();
-                    final DeliveryState remoteState = deliveryUpdated.getRemoteState();
-                    sample.completed(remoteState);
-                    if (Rejected.class.isInstance(remoteState)) {
-                        final Rejected rejected = (Rejected) remoteState;
-                        if (rejected.getError() != null) {
-                            LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}",
-                                    requestTargetAddress, request.getSubject(), correlationId, rejected.getError());
-                            failedResult.fail(StatusCodeMapper.fromTransferError(rejected.getError()));
-                            cancelRequest(correlationId, failedResult.future());
-                        } else {
-                            LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]",
-                                    requestTargetAddress, request.getSubject(), correlationId);
-                            failedResult.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
-                            cancelRequest(correlationId, failedResult.future());
-                        }
-                    } else if (Accepted.class.isInstance(remoteState)) {
-                        LOG.trace("service has accepted request [target address: {}, subject: {}, correlation ID: {}]",
-                                requestTargetAddress, request.getSubject(), correlationId);
-                        currentSpan.log("request accepted by peer");
-                        // if no reply-to is set, the request is assumed to be one-way (no response is expected)
-                        if (request.getReplyTo() == null) {
-                            if (replyMap.remove(correlationId) != null) {
-                                resultHandler.handle(Future.succeededFuture());
-                            } else {
-                                LOG.trace("accepted request won't be acted upon, request already cancelled [target address: {}, subject: {}, correlation ID: {}]",
-                                        requestTargetAddress, request.getSubject(), correlationId);
-                            }
-                        }
-                    } else if (Released.class.isInstance(remoteState)) {
-                        LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}], remote state: {}",
-                                requestTargetAddress, request.getSubject(), correlationId, remoteState);
-                        failedResult.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-                        cancelRequest(correlationId, failedResult.future());
-                    } else if (Modified.class.isInstance(remoteState)) {
-                        LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}], remote state: {}",
-                                requestTargetAddress, request.getSubject(), correlationId, remoteState);
-                        final Modified modified = (Modified) deliveryUpdated.getRemoteState();
-                        failedResult.fail(modified.getUndeliverableHere() ? new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)
-                                : new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-                        cancelRequest(correlationId, failedResult.future());
-                    } else if (remoteState == null) {
-                        // possible scenario here: sender link got closed while waiting on the delivery update
-                        final String furtherInfo = !sender.isOpen() ? ", sender link was closed in between" : "";
-                        LOG.warn("got undefined delivery state for service request{} [target address: {}, subject: {}, correlation ID: {}]",
-                                furtherInfo, requestTargetAddress, request.getSubject(), correlationId);
-                        failedResult.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-                        cancelRequest(correlationId, failedResult.future());
-                    }
-                });
-                if (requestTimeoutMillis > 0) {
-                    connection.getVertx().setTimer(requestTimeoutMillis, tid -> {
-                        if (cancelRequest(correlationId, () -> new ServerErrorException(
-                                HttpURLConnection.HTTP_UNAVAILABLE, "request timed out after " + requestTimeoutMillis + "ms"))) {
-                            sample.timeout();
-                        }
-                    });
-                }
-                if (LOG.isDebugEnabled()) {
-                    final String deviceId = MessageHelper.getDeviceId(request);
-                    if (deviceId == null) {
-                        LOG.debug("sent request [target address: {}, subject: {}, correlation ID: {}] to service",
-                                requestTargetAddress, request.getSubject(), correlationId);
-                    } else {
-                        LOG.debug("sent request [target address: {}, subject: {}, correlation ID: {}, device ID: {}] to service",
-                                requestTargetAddress, request.getSubject(), correlationId, deviceId);
-                    }
-                }
-            }
-        }).otherwise(t -> {
-            // there is no context to run on
-            TracingHelper.logError(currentSpan, "not connected");
-            resultHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
-                    "not connected")));
-            return null;
-        });
-
-    }
-
-    /**
-     * Checks if this client's sender and receiver links are open.
-     *
-     * @return {@code true} if a request can be sent to and a response can be received
-     * from the peer.
-     */
-    @Override
-    public final boolean isOpen() {
-        return HonoProtonHelper.isLinkOpenAndConnected(sender) && HonoProtonHelper.isLinkOpenAndConnected(receiver);
-    }
-
-    @Override
-    public final void close(final Handler<AsyncResult<Void>> closeHandler) {
-
-        LOG.debug("closing request-response client ...");
-        closeLinks(ok -> {
-            if (closeHandler != null) {
-                closeHandler.handle(Future.succeededFuture());
-            }
-        });
-
-    }
-
-    /**
-     * Checks if this client supports caching of results.
-     *
-     * @return {@code true} if caching is supported.
-     */
-    protected final boolean isCachingEnabled() {
-        return responseCache != null;
-    }
-
-    /**
-     * Gets a response from the cache.
-     *
-     * @param key The key to get the response for.
-     * @return A succeeded future containing the response from the cache
-     *         or a failed future if no response exists for the key
-     *         or the response is expired.
-     */
-    protected Future<R> getResponseFromCache(final Object key) {
-        return getResponseFromCache(key, null);
-    }
-
-    /**
-     * Gets a response from the cache.
-     * <p>
-     * Sets a tag on the given span according to whether there was a cache hit.
-     *
-     * @param key The key to get the response for.
-     * @param currentSpan The span to mark (may be {@code null}).
-     * @return A succeeded future containing the response from the cache
-     *         or a failed future if no response exists for the key
-     *         or the response is expired.
-     */
-    protected Future<R> getResponseFromCache(final Object key, final Span currentSpan) {
-
-        if (responseCache == null) {
-            return Future.failedFuture(new IllegalStateException("no cache configured"));
-        } else {
-            final R result = responseCache.get(key);
-            if (currentSpan != null) {
-                TracingHelper.TAG_CACHE_HIT.set(currentSpan, result != null);
-            }
-            if (result == null) {
-                return Future.failedFuture("cache miss");
-            } else {
-                return Future.succeededFuture(result);
-            }
-        }
-
-    }
-
-    /**
-     * Adds a response to the cache.
-     * <p>
-     * If the cache key is {@code null} or no cache is configured then this method does nothing.
-     * <p>
-     * Otherwise
-     * <ol>
-     * <li>if the response does not contain any cache directive and the response's status code is
-     * one of the codes defined by <a href="https://tools.ietf.org/html/rfc2616#section-13.4">
-     * RFC 2616, Section 13.4 Response Cacheability</a>, the response is put to the cache using
-     * the default timeout returned by {@link #getResponseCacheDefaultTimeout()}</li>
-     * <li>else if the response contains a <em>max-age</em> directive, the response
-     * is put to the cache using the max age from the directive.</li>
-     * <li>else if the response contains a <em>no-cache</em> directive, the response
-     * is not put to the cache.</li>
-     * </ol>
-     *
-     * @param key The key to use for the response.
-     * @param response The response to cache.
-     * @throws NullPointerException if response is {@code null}.
-     */
-    protected final void addToCache(final Object key, final R response) {
-
-        Objects.requireNonNull(response);
-
-        if (responseCache != null && key != null) {
-
-            final CacheDirective cacheDirective = Optional.ofNullable(response.getCacheDirective())
-                    .orElseGet(() -> {
-                        if (isCacheableStatusCode(response.getStatus())) {
-                            return CacheDirective.maxAgeDirective(getResponseCacheDefaultTimeout());
-                        } else {
-                            return CacheDirective.noCacheDirective();
-                        }
-                    });
-
-            if (cacheDirective.isCachingAllowed() && cacheDirective.getMaxAge() > 0) {
-                responseCache.put(key, response, Duration.ofSeconds(cacheDirective.getMaxAge()));
-            }
-        }
-    }
-
-    private boolean isCacheableStatusCode(final int code) {
-        return Arrays.binarySearch(CACHEABLE_STATUS_CODES, code) >= 0;
-    }
-
-    /**
-     * Get the tenantId of the tenant for that this client was created for.
-
-     * @return The tenantId for that this client was created for.
-     */
-    protected final String getTenantId() {
-        return tenantId;
-    }
-
-    /**
-     * Checks if an AMQP message contains the result of the successful invocation
-     * of an operation.
-     *
-     * @param status The status code from the message.
-     * @param contentType A media type describing the payload or {@code null} if unknown.
-     * @param payload The payload from the response (may be {@code null}).
-     * @return {@code true} if 200 =&lt; status &lt; 300 and the message contains a JSON
-     *                      payload.
-     */
-    protected final boolean isSuccessResponse(
-            final int status,
-            final String contentType,
-            final Buffer payload) {
-
-        return StatusCodeMapper.isSuccessful(status) && payload != null
-                && MessageHelper.CONTENT_TYPE_APPLICATION_JSON.equalsIgnoreCase(contentType);
-    }
-
-    /**
-     * Applies the given mapper function to the result of the given Future if it succeeded.
-     * <p>
-     * Makes sure that the given Span is finished when the given Future is completed.
-     * Also sets the {@code Tags.HTTP_STATUS} tag on the span and logs error information if there was an error.
-     *
-     * @param result The Future supplying the <em>RequestResponseResult</em> that the mapper will be applied on.
-     * @param resultMapper The mapper function.
-     * @param currentSpan The OpenTracing Span to use.
-     * @param <T> The type of the Future value to be returned.
-     * @return The Future with the result of applying the mapping function or with the error from the given Future.
-     * @throws NullPointerException if either of the parameters is {@code null}.
-     */
-    protected final <T> Future<T> mapResultAndFinishSpan(
-            final Future<R> result,
-            final Function<R, T> resultMapper,
-            final Span currentSpan) {
-        return result.recover(t -> {
-            Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(t));
-            TracingHelper.logError(currentSpan, t);
-            currentSpan.finish();
-            return Future.failedFuture(t);
-        }).map(resultValue -> {
-            if (resultValue != null) {
-                Tags.HTTP_STATUS.set(currentSpan, resultValue.getStatus());
-                if (resultValue.isError()) {
-                    Tags.ERROR.set(currentSpan, Boolean.TRUE);
-                }
-            } else {
-                Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-            }
-            currentSpan.finish();
-            return resultMapper.apply(resultValue);
-        });
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
deleted file mode 100644
index 611068bc6..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ /dev/null
@@ -1,489 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Modified;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageNotProcessedException;
-import org.eclipse.hono.client.MessageSender;
-import org.eclipse.hono.client.MessageUndeliverableException;
-import org.eclipse.hono.client.NoConsumerException;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.SendMessageTimeoutException;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.HonoProtonHelper;
-import org.eclipse.hono.util.MessageHelper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.log.Fields;
-import io.opentracing.tag.Tags;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for publishing messages to Hono.
- */
-public abstract class AbstractSender extends AbstractHonoClient implements MessageSender {
-
-    /**
-     * A counter to be used for creating message IDs.
-     */
-    protected static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
-
-    /**
-     * A logger to be shared with subclasses.
-     */
-    protected final Logger log = LoggerFactory.getLogger(getClass());
-    /**
-     * The identifier of the tenant that the devices belong to which have published the messages
-     * that this sender is used to send downstream.
-     */
-    protected final String tenantId;
-    /**
-     * The target address that this sender sends messages to.
-     */
-    protected final String targetAddress;
-    /**
-     * A sampler for sending messages.
-     */
-    protected final SendMessageSampler sampler;
-
-    private Handler<Void> drainHandler;
-
-    /**
-     * Creates a new sender.
-     *
-     * @param connection The connection to use for interacting with the server.
-     * @param sender The sender link to send messages over.
-     * @param tenantId The identifier of the tenant that the
-     *           devices belong to which have published the messages
-     *           that this sender is used to send downstream.
-     * @param sampler The sampler for sending messages.
-     * @param targetAddress The target address to send the messages to.
-     * @throws NullPointerException if any of the parameters except targetAddress is {@code null}.
-     */
-    protected AbstractSender(
-            final HonoConnection connection,
-            final ProtonSender sender,
-            final String tenantId,
-            final String targetAddress,
-            final SendMessageSampler sampler) {
-
-        super(connection);
-        this.sender = Objects.requireNonNull(sender);
-        this.tenantId = Objects.requireNonNull(tenantId);
-        this.targetAddress = targetAddress;
-        this.sampler = Objects.requireNonNull(sampler);
-        if (sender.isOpen()) {
-            this.offeredCapabilities = Optional.ofNullable(sender.getRemoteOfferedCapabilities())
-                    .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))
-                    .orElse(Collections.emptyList());
-        }
-    }
-
-    @Override
-    public final int getCredit() {
-        if (sender == null) {
-            return 0;
-        } else {
-            return sender.getCredit();
-        }
-    }
-
-    @Override
-    public final void sendQueueDrainHandler(final Handler<Void> handler) {
-        if (this.drainHandler != null) {
-            throw new IllegalStateException("already waiting for replenishment with credit");
-        } else {
-            this.drainHandler = Objects.requireNonNull(handler);
-            sender.sendQueueDrainHandler(replenishedSender -> {
-                log.trace("sender has received FLOW [credits: {}, queued:{}]", replenishedSender.getCredit(), replenishedSender.getQueued());
-                final Handler<Void> currentHandler = this.drainHandler;
-                this.drainHandler = null;
-                if (currentHandler != null) {
-                    currentHandler.handle(null);
-                }
-            });
-        }
-    }
-
-    @Override
-    public final void close(final Handler<AsyncResult<Void>> closeHandler) {
-        Objects.requireNonNull(closeHandler);
-        log.debug("closing sender ...");
-        closeLinks(ok -> closeHandler.handle(Future.succeededFuture()));
-    }
-
-    @Override
-    public final boolean isOpen() {
-        return HonoProtonHelper.isLinkOpenAndConnected(sender);
-    }
-
-    @Override
-    public final Future<ProtonDelivery> send(final Message rawMessage) {
-        return send(rawMessage, (SpanContext) null);
-    }
-
-    @Override
-    public final Future<ProtonDelivery> send(final Message rawMessage, final SpanContext parent) {
-
-        Objects.requireNonNull(rawMessage);
-
-        final Span span = startSpan(parent, rawMessage);
-        Tags.MESSAGE_BUS_DESTINATION.set(span, getMessageAddress(rawMessage));
-        TracingHelper.TAG_QOS.set(span, sender.getQoS().toString());
-        TracingHelper.setDeviceTags(span, tenantId, MessageHelper.getDeviceId(rawMessage));
-        TracingHelper.injectSpanContext(connection.getTracer(), span.context(), rawMessage);
-
-        return connection.executeOnContext(result -> {
-            if (sender.sendQueueFull()) {
-                final ServerErrorException e = new NoConsumerException("no credit available");
-                logMessageSendingError("error sending message [ID: {}, address: {}], no credit available (drain={})",
-                        rawMessage.getMessageId(), getMessageAddress(rawMessage), sender.getDrain());
-                TracingHelper.TAG_CREDIT.set(span, 0);
-                logError(span, e);
-                span.finish();
-                result.fail(e);
-                this.sampler.queueFull(this.tenantId);
-            } else {
-                sendMessage(rawMessage, span).onComplete(result);
-            }
-        });
-
-    }
-
-    /**
-     * Sends an AMQP 1.0 message to the peer this client is configured for.
-     * <p>
-     * The message is sent according to the delivery semantics defined by
-     * the Hono API this client interacts with.
-     *
-     * @param message The message to send.
-     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
-     *              The span will be finished by this method and will contain an error log if
-     *              the message has not been accepted by the peer.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events and commands it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or, in the case of events or commands, if no delivery update
-     *         was received from the peer within the configured timeout period
-     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    protected abstract Future<ProtonDelivery> sendMessage(Message message, Span currentSpan);
-
-    /**
-     * Creates and starts a new OpenTracing {@code Span} for a message to be sent.
-     *
-     * @param message The message to create the span for.
-     * @return The started span.
-     * @throws NullPointerException if message is {@code null}.
-     */
-    protected final Span startSpan(final Message message) {
-        return startSpan(null, message);
-    }
-
-    /**
-     * Creates and starts a new OpenTracing {@code Span} for a message to be sent
-     * in an existing context.
-     *
-     * @param context The context to create the span in. If {@code null}, then
-     *                  the span is created without a parent.
-     * @param message The message to create the span for.
-     * @return The started span.
-     * @throws NullPointerException if message is {@code null}.
-     */
-    protected abstract Span startSpan(SpanContext context, Message message);
-
-    /**
-     * Gets the value of the <em>to</em> property to be used for messages produced by this sender.
-     *
-     * @param deviceId The identifier of the device that the message's content originates from.
-     * @return The address.
-     */
-    protected abstract String getTo(String deviceId);
-
-    /**
-     * Sends an AMQP 1.0 message to the peer this client is configured for
-     * and waits for the outcome of the transfer.
-     *
-     * @param message The message to send.
-     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
-     *              The span will be finished by this method and will contain an error log if
-     *              the message has not been accepted by the peer.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been accepted (and settled)
-     *         by the peer.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or has not been accepted by the peer or if no delivery update
-     *         was received from the peer within the configured timeout period
-     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
-     * @throws NullPointerException if either of the parameters is {@code null}.
-     */
-    protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message, final Span currentSpan) {
-
-        Objects.requireNonNull(message);
-        Objects.requireNonNull(currentSpan);
-
-        final AtomicReference<ProtonDelivery> deliveryRef = new AtomicReference<>();
-        final Promise<ProtonDelivery> result = Promise.promise();
-        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
-        message.setMessageId(messageId);
-        logMessageIdAndSenderInfo(currentSpan, messageId);
-
-        final SendMessageSampler.Sample sample = this.sampler.start(this.tenantId);
-
-        final ClientConfigProperties config = connection.getConfig();
-        final Long timerId = config.getSendMessageTimeout() > 0
-                ? connection.getVertx().setTimer(config.getSendMessageTimeout(), id -> {
-                    if (!result.future().isComplete()) {
-                        handleSendMessageTimeout(message, config.getSendMessageTimeout(), deliveryRef.get(), sample,
-                                result, null);
-                    }
-                })
-                : null;
-
-        deliveryRef.set(sender.send(message, deliveryUpdated -> {
-            if (timerId != null) {
-                connection.getVertx().cancelTimer(timerId);
-            }
-            final DeliveryState remoteState = deliveryUpdated.getRemoteState();
-            if (result.future().isComplete()) {
-                log.debug("ignoring received delivery update for message [ID: {}, address: {}]: waiting for the update has already timed out",
-                        messageId, getMessageAddress(message));
-            } else if (deliveryUpdated.remotelySettled()) {
-                logUpdatedDeliveryState(currentSpan, message, deliveryUpdated);
-                sample.completed(remoteState);
-                if (Accepted.class.isInstance(remoteState)) {
-                    result.complete(deliveryUpdated);
-                } else {
-                    ServiceInvocationException e = null;
-                    if (Rejected.class.isInstance(remoteState)) {
-                        final Rejected rejected = (Rejected) remoteState;
-                        e = Optional.ofNullable(rejected.getError())
-                                .map(StatusCodeMapper::fromTransferError)
-                                .orElseGet(() -> new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
-                    } else if (Released.class.isInstance(remoteState)) {
-                        e = new MessageNotProcessedException();
-                    } else if (Modified.class.isInstance(remoteState)) {
-                        final Modified modified = (Modified) deliveryUpdated.getRemoteState();
-                        if (modified.getUndeliverableHere()) {
-                            e = new MessageUndeliverableException();
-                        } else {
-                            e = new MessageNotProcessedException();
-                        }
-                    }
-                    result.fail(e);
-                }
-            } else {
-                logMessageSendingError("peer did not settle message [ID: {}, address: {}, remote state: {}], failing delivery",
-                        messageId, getMessageAddress(message), remoteState.getClass().getSimpleName());
-                final ServiceInvocationException e = new ServerErrorException(
-                        HttpURLConnection.HTTP_INTERNAL_ERROR,
-                        "peer did not settle message, failing delivery");
-                result.fail(e);
-            }
-        }));
-        log.trace("sent AT_LEAST_ONCE message [ID: {}, address: {}], remaining credit: {}, queued messages: {}",
-                messageId, getMessageAddress(message), sender.getCredit(), sender.getQueued());
-
-        return result.future()
-                .map(delivery -> {
-                    Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-                    currentSpan.finish();
-                    return delivery;
-                }).recover(t -> {
-                    TracingHelper.logError(currentSpan, t);
-                    Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(t));
-                    currentSpan.finish();
-                    return Future.failedFuture(t);
-                });
-    }
-
-    /**
-     * Handles a timeout waiting for a delivery update after sending a message.
-     *
-     * @param message The message for which the timeout occurred.
-     * @param sendMessageTimeout The timeout value.
-     * @param delivery The message delivery to release (may be {@code null}).
-     * @param sample The sample to log a timeout on (may be {@code null}).
-     * @param resultPromise The promise to fail with an exception (may be {@code null}).
-     * @param spanToLogToAndFinish The span to log the error to and finish (may be {@code null})
-     * @throws NullPointerException if message is {@code null}.
-     */
-    protected void handleSendMessageTimeout(
-            final Message message,
-            final long sendMessageTimeout,
-            final ProtonDelivery delivery,
-            final SendMessageSampler.Sample sample,
-            final Promise<ProtonDelivery> resultPromise,
-            final Span spanToLogToAndFinish) {
-        Objects.requireNonNull(message);
-
-        final String linkOrConnectionClosedInfo = HonoProtonHelper.isLinkOpenAndConnected(sender)
-                ? "" : " (link or connection already closed)";
-        final String exceptionMsg = "waiting for delivery update timed out after " + sendMessageTimeout + "ms";
-
-        final ServerErrorException exception = HonoProtonHelper.isLinkOpenAndConnected(sender)
-                ? new SendMessageTimeoutException(exceptionMsg)
-                : new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, exceptionMsg + linkOrConnectionClosedInfo);
-        logMessageSendingError("waiting for delivery update timed out for message [ID: {}, address: {}] after {}ms{}",
-                message.getMessageId(), getMessageAddress(message), sendMessageTimeout, linkOrConnectionClosedInfo);
-        // settle and release the delivery - this ensures that the message isn't considered "in flight"
-        // anymore in the AMQP messaging network and that it doesn't count towards the link capacity
-        // (it would be enough to just settle the delivery without an outcome but that cannot be done with proton-j as of now)
-        if (delivery != null) {
-            ProtonHelper.released(delivery, true);
-        }
-        if (spanToLogToAndFinish != null) {
-            TracingHelper.logError(spanToLogToAndFinish, exception.getMessage());
-            Tags.HTTP_STATUS.set(spanToLogToAndFinish, HttpURLConnection.HTTP_UNAVAILABLE);
-            spanToLogToAndFinish.finish();
-        }
-        if (resultPromise != null) {
-            resultPromise.fail(exception);
-        }
-        if (sample != null) {
-            sample.timeout();
-        }
-    }
-
-    /**
-     * Creates a log entry in the given span with the message id and information about the sender (credits, QOS).
-     *
-     * @param currentSpan The current span to log to.
-     * @param messageId The message id.
-     * @throws NullPointerException if currentSpan is {@code null}.
-     */
-    protected final void logMessageIdAndSenderInfo(final Span currentSpan, final String messageId) {
-        final Map<String, Object> details = new HashMap<>(2);
-        details.put(TracingHelper.TAG_MESSAGE_ID.getKey(), messageId);
-        details.put(TracingHelper.TAG_CREDIT.getKey(), sender.getCredit());
-        currentSpan.log(details);
-    }
-
-    /**
-     * Creates a log entry in the given span with information about the message delivery outcome given in the delivery
-     * parameter. Sets the {@link Tags#HTTP_STATUS} as well.
-     * <p>
-     * Also corresponding log output is created.
-     *
-     * @param currentSpan The current span to log to.
-     * @param message The message.
-     * @param delivery The updated delivery.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected final void logUpdatedDeliveryState(final Span currentSpan, final Message message, final ProtonDelivery delivery) {
-        Objects.requireNonNull(currentSpan);
-        final String messageId = message.getMessageId() != null ? message.getMessageId().toString() : "";
-        final String messageAddress = getMessageAddress(message);
-        final DeliveryState remoteState = delivery.getRemoteState();
-        if (Accepted.class.isInstance(remoteState)) {
-            log.trace("message [ID: {}, address: {}] accepted by peer", messageId, messageAddress);
-            currentSpan.log("message accepted by peer");
-            Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-        } else {
-            final Map<String, Object> events = new HashMap<>();
-            if (Rejected.class.isInstance(remoteState)) {
-                final Rejected rejected = (Rejected) delivery.getRemoteState();
-                Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_BAD_REQUEST);
-                if (rejected.getError() == null) {
-                    logMessageSendingError("message [ID: {}, address: {}] rejected by peer", messageId, messageAddress);
-                    events.put(Fields.MESSAGE, "message rejected by peer");
-                } else {
-                    logMessageSendingError("message [ID: {}, address: {}] rejected by peer: {}, {}", messageId,
-                            messageAddress, rejected.getError().getCondition(), rejected.getError().getDescription());
-                    events.put(Fields.MESSAGE, String.format("message rejected by peer: %s, %s",
-                            rejected.getError().getCondition(), rejected.getError().getDescription()));
-                }
-            } else if (Released.class.isInstance(remoteState)) {
-                logMessageSendingError("message [ID: {}, address: {}] not accepted by peer, remote state: {}",
-                        messageId, messageAddress, remoteState.getClass().getSimpleName());
-                Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
-                events.put(Fields.MESSAGE, "message not accepted by peer, remote state: " + remoteState);
-            } else if (Modified.class.isInstance(remoteState)) {
-                final Modified modified = (Modified) delivery.getRemoteState();
-                logMessageSendingError("message [ID: {}, address: {}] not accepted by peer, remote state: {}",
-                        messageId, messageAddress, modified);
-                Tags.HTTP_STATUS.set(currentSpan, modified.getUndeliverableHere() ? HttpURLConnection.HTTP_NOT_FOUND
-                        : HttpURLConnection.HTTP_UNAVAILABLE);
-                events.put(Fields.MESSAGE, "message not accepted by peer, remote state: " + remoteState);
-            }
-            TracingHelper.logError(currentSpan, events);
-        }
-    }
-
-    /**
-     * Gets the address the message is targeted at.
-     * <p>
-     * This is either the message address or the link address of this sender.
-     *
-     * @param message The message.
-     * @return The message or link address.
-     * @throws NullPointerException if message is {@code null}.
-     */
-    protected final String getMessageAddress(final Message message) {
-        Objects.requireNonNull(message);
-        return message.getAddress() != null ? message.getAddress() : targetAddress;
-    }
-
-    /**
-     * Logs an error that occurred when sending a message.
-     * <p>
-     * This method logs on DEBUG level by default. Subclasses may override this
-     * method to use a different log level.
-     *
-     * @param format The log format string.
-     * @param arguments The arguments of the format string.
-     */
-    protected void logMessageSendingError(final String format, final Object... arguments) {
-        log.debug(format, arguments);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
deleted file mode 100644
index e479e4f1f..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
+++ /dev/null
@@ -1,257 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-import java.util.UUID;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.ApplicationClientFactory;
-import org.eclipse.hono.client.AsyncCommandClient;
-import org.eclipse.hono.client.CommandClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.CommandConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-
-
-/**
- * A factory for clients of Hono's north bound APIs.
- *
- */
-public class ApplicationClientFactoryImpl extends AbstractHonoClientFactory implements ApplicationClientFactory {
-
-    private final ClientFactory<MessageConsumer> consumerFactory;
-    private final CachingClientFactory<CommandClient> commandClientFactory;
-    private final CachingClientFactory<AsyncCommandClient> asyncCommandClientFactory;
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param samplerFactory The sampler factory to use.
-     */
-    public ApplicationClientFactoryImpl(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-        consumerFactory = new ClientFactory<>();
-        commandClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());
-        asyncCommandClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());
-    }
-
-    @Override
-    public Future<MessageConsumer> createTelemetryConsumer(final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> telemetryConsumer,
-            final boolean autoAccept,
-            final Handler<Void> closeHandler) {
-
-        return connection.executeOnContext(result -> {
-            consumerFactory.createClient(
-                    () -> TelemetryConsumerImpl.create(
-                            connection,
-                            tenantId,
-                            telemetryConsumer,
-                            autoAccept,
-                            closeHook -> closeHandler.handle(null)),
-                    result);
-        });
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createTelemetryConsumer(
-            final String tenantId,
-            final Consumer<Message> telemetryConsumer,
-            final Handler<Void> closeHandler) {
-
-        return createTelemetryConsumer(
-                tenantId,
-                (delivery, message) -> telemetryConsumer.accept(message),
-                true,
-                closeHandler);
-    }
-
-    @Override
-    public Future<MessageConsumer> createEventConsumer(final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> eventConsumer,
-            final boolean autoAccept,
-            final Handler<Void> closeHandler) {
-
-        return connection.executeOnContext(result -> {
-            consumerFactory.createClient(
-                    () -> EventConsumerImpl.create(
-                            connection,
-                            tenantId,
-                            eventConsumer,
-                            autoAccept,
-                            closeHook -> closeHandler.handle(null)),
-                    result);
-        });
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createEventConsumer(
-            final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> eventConsumer,
-            final Handler<Void> closeHandler) {
-
-        return createEventConsumer(tenantId, eventConsumer, true, closeHandler);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createEventConsumer(
-            final String tenantId,
-            final Consumer<Message> eventConsumer,
-            final Handler<Void> closeHandler) {
-
-        return createEventConsumer(
-                tenantId,
-                (delivery, message) -> eventConsumer.accept(message),
-                closeHandler);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<CommandClient> getOrCreateCommandClient(final String tenantId) {
-        Objects.requireNonNull(tenantId);
-
-        final String cacheKey = String.format("%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId);
-        return getOrCreateCommandClient(tenantId, UUID.randomUUID().toString(), cacheKey);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String replyId) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(replyId);
-
-        final String cacheKey = String.format("%s/%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, replyId);
-        return getOrCreateCommandClient(tenantId, replyId, cacheKey);
-    }
-
-    private Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String replyId,
-            final String cacheKey) {
-        log.debug("get or create command client for [tenantId: {}, replyId: {}]", tenantId, replyId);
-        return connection.executeOnContext(result -> {
-            commandClientFactory.getOrCreateClient(
-                    cacheKey,
-                    () -> CommandClientImpl.create(
-                            connection,
-                            tenantId,
-                            replyId,
-                            samplerFactory.create(CommandConstants.COMMAND_ENDPOINT),
-                            s -> removeCommandClient(cacheKey),
-                            s -> removeCommandClient(cacheKey)),
-                    result);
-        });
-    }
-
-    private void removeCommandClient(final String key) {
-        commandClientFactory.removeClient(key, client -> {
-            client.close(s -> {});
-            log.debug("closed and removed client for [{}]", key);
-        });
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<AsyncCommandClient> getOrCreateAsyncCommandClient(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-
-        return connection.executeOnContext(result -> {
-            final String key = String.format("%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId);
-            asyncCommandClientFactory.getOrCreateClient(
-                    key,
-                    () -> AsyncCommandClientImpl.create(
-                            connection,
-                            tenantId,
-                            samplerFactory.create(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT),
-                            s -> removeAsyncCommandClient(key)),
-                    result);
-        });
-    }
-
-    private void removeAsyncCommandClient(final String key) {
-        asyncCommandClientFactory.removeClient(key, client -> {
-            client.close(s -> {});
-            log.debug("closed and removed client for [{}]", key);
-        });
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<MessageConsumer> createAsyncCommandResponseConsumer(
-            final String tenantId,
-            final String replyId,
-            final BiConsumer<ProtonDelivery, Message> consumer,
-            final Handler<Void> closeHandler) {
-
-        return connection.executeOnContext(result -> {
-            consumerFactory.createClient(
-                    () -> AsyncCommandResponseConsumerImpl.create(
-                            connection,
-                            tenantId,
-                            replyId,
-                            consumer,
-                            closeHook -> closeHandler.handle(null)),
-                    result);
-        });
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<MessageConsumer> createAsyncCommandResponseConsumer(
-            final String tenantId,
-            final String replyId,
-            final Consumer<Message> consumer,
-            final Handler<Void> closeHandler) {
-
-        return createAsyncCommandResponseConsumer(tenantId, replyId, (delivery, msg) -> consumer.accept(msg), closeHandler);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onDisconnect() {
-        asyncCommandClientFactory.clearState();
-        commandClientFactory.clearState();
-        consumerFactory.clearState();
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AsyncCommandClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/AsyncCommandClientImpl.java
deleted file mode 100644
index e72c83ede..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AsyncCommandClientImpl.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Map;
-import java.util.Objects;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.AsyncCommandClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.MessageHelper;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonSender;
-
-/**
- * Sender for commands with asynchronous responses.
- */
-public class AsyncCommandClientImpl extends AbstractSender implements AsyncCommandClient {
-
-    private AsyncCommandClientImpl(
-            final HonoConnection con,
-            final ProtonSender sender,
-            final String tenantId,
-            final String targetAddress,
-            final SendMessageSampler sampler) {
-        super(con, sender, tenantId, targetAddress, sampler);
-    }
-
-    @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
-        return sendMessageAndWaitForOutcome(message, currentSpan);
-    }
-
-    @Override
-    protected Span startSpan(final SpanContext parent, final Message message) {
-        final Span span = newFollowingSpan(parent, "sending async command");
-        Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
-        return span;
-    }
-
-    @Override
-    protected String getTo(final String deviceId) {
-        return null;
-    }
-
-    @Override
-    public String getEndpoint() {
-        return CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT;
-    }
-
-    /**
-     * Gets the address to use for a command message to be sent to a device.
-     *
-     * @param tenantId The tenant id.
-     * @param deviceId The device id.
-     * @return The target address of the command message.
-     */
-    static String getTargetAddress(final String tenantId, final String deviceId) {
-        return String.format("%s/%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, deviceId);
-    }
-
-    /**
-     * Gets the target address to use for creating this client's sender link.
-     *
-     * @param tenantId The tenant id.
-     * @return The link target address.
-     */
-    static String getLinkTargetAddress(final String tenantId) {
-        return String.format("%s/%s", CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId);
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
-        return send(message);
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext context) {
-        return send(message, context);
-    }
-
-    @Override
-    public Future<Void> sendAsyncCommand(final String deviceId, final String command, final Buffer data, final String correlationId,
-            final String replyId) {
-        return sendAsyncCommand(deviceId, command, null, data, correlationId, replyId, null);
-    }
-
-    @Override
-    public Future<Void> sendAsyncCommand(final String deviceId, final String command, final String contentType,
-            final Buffer data, final String correlationId, final String replyId, final Map<String, Object> properties) {
-        return sendAsyncCommand(deviceId, command, contentType, data, correlationId, replyId, properties, null);
-    }
-
-    @Override
-    public Future<Void> sendAsyncCommand(final String deviceId, final String command, final String contentType, final Buffer data,
-            final String correlationId, final String replyId, final Map<String, Object> properties, final SpanContext context) {
-        Objects.requireNonNull(command);
-        Objects.requireNonNull(correlationId);
-        Objects.requireNonNull(replyId);
-
-        final Message message = ProtonHelper.message();
-        message.setCorrelationId(correlationId);
-        MessageHelper.setCreationTime(message);
-        MessageHelper.setPayload(message, contentType, data);
-        message.setSubject(command);
-        message.setAddress(getTargetAddress(tenantId, deviceId));
-        final String replyToAddress = String.format("%s/%s/%s", CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, replyId);
-        message.setReplyTo(replyToAddress);
-
-        return sendAndWaitForOutcome(message, context).compose(ignore -> Future.succeededFuture());
-    }
-
-    /**
-     * Creates a new asynchronous command client for a tenant and device.
-     * <p>
-     * The instance created is scoped to the given device. In particular, the target address of messages is set to
-     * <em>command/${tenantId}/${deviceId}</em>, whereas the sender link's target address is set to
-     * <em>command/${tenantId}</em>.
-     *
-     * @param con The connection to the Hono server.
-     * @param tenantId The tenant that the device belongs to.
-     * @param closeHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param sampler The sampler to use.
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except closeHook is {@code null}.
-     */
-    public static Future<AsyncCommandClient> create(
-            final HonoConnection con,
-            final String tenantId,
-            final SendMessageSampler sampler,
-            final Handler<String> closeHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(sampler);
-
-        final String linkTargetAddress = AsyncCommandClientImpl.getLinkTargetAddress(tenantId);
-        return con.createSender(linkTargetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook)
-                .compose(sender -> Future.succeededFuture(new AsyncCommandClientImpl(con, sender, tenantId, linkTargetAddress, sampler)));
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AsyncCommandResponseConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/AsyncCommandResponseConsumerImpl.java
deleted file mode 100644
index bb9ba351c..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/AsyncCommandResponseConsumerImpl.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-import java.util.function.BiConsumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.util.CommandConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * A Vertx-Proton based client for consuming async command response messages from a Hono server.
- */
-public class AsyncCommandResponseConsumerImpl extends AbstractConsumer implements MessageConsumer {
-
-    private static final String ASYNC_COMMAND_RESPONSE_ADDRESS_TEMPLATE = CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT
-            + "/%s/%s";
-
-    private AsyncCommandResponseConsumerImpl(
-            final HonoConnection con,
-            final ProtonReceiver receiver) {
-        super(con, receiver);
-    }
-
-    /**
-     * Creates a new asynchronous command response consumer for a tenant for commands with the given {@code replyId}.
-     *
-     * @param con The connection to the Hono server.
-     * @param tenantId The tenant to consume async command responses for.
-     * @param replyId The {@code replyId} of commands to consume async responses for.
-     * @param asyncCommandResponseConsumer The consumer to invoke with async command response received.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except close hook are {@code null}.
-     */
-    public static Future<MessageConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final String replyId,
-            final BiConsumer<ProtonDelivery, Message> asyncCommandResponseConsumer,
-            final Handler<String> closeHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(replyId);
-        Objects.requireNonNull(asyncCommandResponseConsumer);
-
-        final String sourceAddress = String.format(ASYNC_COMMAND_RESPONSE_ADDRESS_TEMPLATE, tenantId, replyId);
-        return con.createReceiver(sourceAddress, ProtonQoS.AT_LEAST_ONCE, asyncCommandResponseConsumer::accept, closeHook)
-                .compose(recv -> Future.succeededFuture((MessageConsumer) new AsyncCommandResponseConsumerImpl(con, recv)));
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
deleted file mode 100644
index 56260f3b9..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.nio.charset.StandardCharsets;
-import java.util.Map;
-import java.util.Objects;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.CommandClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.AddressHelper;
-import org.eclipse.hono.util.BufferResult;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.HonoProtonHelper;
-import org.eclipse.hono.util.MessageHelper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for Hono's Command and Control API.
- *
- */
-public class CommandClientImpl extends AbstractRequestResponseClient<BufferResult> implements CommandClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(CommandClientImpl.class);
-
-    private long messageCounter;
-
-    /**
-     * Creates a client for sending commands to devices.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to Hono.
-     * @param tenantId The tenant that the device belongs to.
-     * @param replyId The replyId to use in the reply-to address.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    CommandClientImpl(
-            final HonoConnection connection,
-            final String tenantId,
-            final String replyId,
-            final SendMessageSampler sampler) {
-
-        super(connection, Objects.requireNonNull(tenantId), replyId, sampler);
-    }
-
-    /**
-     * Creates a client for sending commands to devices.
-     *
-     * @param connection The connection to Hono.
-     * @param tenantId The tenant that the device belongs to.
-     * @param replyId The replyId to use in the reply-to address.
-     * @param sender The link to use for sending command requests.
-     * @param receiver The link to use for receiving command responses.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    CommandClientImpl(
-            final HonoConnection connection,
-            final String tenantId,
-            final String replyId,
-            final ProtonSender sender,
-            final ProtonReceiver receiver,
-            final SendMessageSampler sampler) {
-
-        this(connection, tenantId, replyId, sampler);
-        this.sender = Objects.requireNonNull(sender);
-        this.receiver = Objects.requireNonNull(receiver);
-    }
-
-    @Override
-    protected String getName() {
-        return CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT;
-    }
-
-    @Override
-    protected String getReplyToEndpointName() {
-        return CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT;
-    }
-
-    /**
-     * The command's message ID is transferred to the device in order to be able to correlate the
-     * response received from the device with the request message. It is therefore
-     * desirable to keep the message ID as short as possible in order to reduce the number of bytes
-     * exchanged with the device.
-     * <p>
-     * This methods creates message IDs based on a counter that is increased on each invocation.
-     *
-     * @return The message ID.
-     */
-    @Override
-    protected String createMessageId() {
-        return Long.toString(messageCounter++, Character.MAX_RADIX);
-    }
-
-    @Override
-    protected BufferResult getResult(
-            final int status,
-            final String contentType,
-            final Buffer payload,
-            final CacheDirective cacheDirective,
-            final ApplicationProperties applicationProperties) {
-        return BufferResult.from(status, contentType, payload, applicationProperties);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * This method simply invokes {@link #sendCommand(String, String, String, Buffer, Map)} with
-     * {@code null} as the *content-type* and {@code null} as *application properties*.
-     */
-    @Override
-    public Future<BufferResult> sendCommand(final String deviceId, final String command, final Buffer data) {
-        return sendCommand(deviceId, command, null, data, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * This method uses the {@linkplain #createMessageId() message ID} to correlate the response received
-     * from a device with the request.
-     */
-    @Override
-    public Future<BufferResult> sendCommand(final String deviceId, final String command, final String contentType,
-            final Buffer data, final Map<String, Object> properties) {
-
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(command);
-
-        final Span currentSpan = newChildSpan(null, command);
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-
-        final Promise<BufferResult> resultTracker = Promise.promise();
-
-        final String messageTargetAddress = AddressHelper.getTargetAddress(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, getTenantId(), deviceId, connection.getConfig());
-        createAndSendRequest(command, messageTargetAddress, properties, data, contentType, resultTracker,
-                null, currentSpan);
-
-        return mapResultAndFinishSpan(
-                resultTracker.future(),
-                result -> {
-                    if (result.isError()) {
-                        final String detailMessage = result.getPayload() != null && result.getPayload().length() > 0
-                                ? result.getPayload().toString(StandardCharsets.UTF_8)
-                                : null;
-                        throw StatusCodeMapper.from(result.getStatus(), detailMessage);
-                    }
-                    return result;
-                },
-                currentSpan);
-    }
-
-    @Override
-    public Future<Void> sendOneWayCommand(final String deviceId, final String command, final Buffer data) {
-        return sendOneWayCommand(deviceId, command, null, data, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<Void> sendOneWayCommand(
-            final String deviceId,
-            final String command,
-            final String contentType,
-            final Buffer data,
-            final Map<String, Object> properties) {
-
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(command);
-
-        final Span currentSpan = newChildSpan(null, command);
-        TracingHelper.setDeviceTags(currentSpan, getTenantId(), deviceId);
-
-        if (HonoProtonHelper.isLinkOpenAndConnected(sender)) {
-            final Promise<BufferResult> responseTracker = Promise.promise();
-            final Message request = ProtonHelper.message();
-
-            AbstractHonoClient.setApplicationProperties(request, properties);
-
-            final String messageId = createMessageId();
-            request.setAddress(AddressHelper.getTargetAddress(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, getTenantId(), deviceId, connection.getConfig()));
-            request.setMessageId(messageId);
-            request.setSubject(command);
-
-            MessageHelper.setPayload(request, contentType, data);
-            sendRequest(request, responseTracker, null, currentSpan);
-
-            return responseTracker.future()
-                    .recover(t -> {
-                        Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(t));
-                        TracingHelper.logError(currentSpan, t);
-                        currentSpan.finish();
-                        return Future.failedFuture(t);
-                    }).map(ignore -> {
-                        Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-                        currentSpan.finish();
-                        return null;
-                    });
-        } else {
-            Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
-            TracingHelper.logError(currentSpan, "sender link is not open");
-            currentSpan.finish();
-            return Future.failedFuture(new ServerErrorException(
-                    HttpURLConnection.HTTP_UNAVAILABLE, "sender link is not open"));
-        }
-    }
-
-    /**
-     * Creates a new command client for a tenant and device.
-     * <p>
-     * The instance created is scoped to the given device. In particular, the target address of messages is set to
-     * <em>command/${tenantId}/${deviceId}</em>, whereas the sender link's target address is set to
-     * <em>command/${tenantId}</em>. The receiver link's source address is set to
-     * <em>command_response/${tenantId}/${deviceId}/${replyId}</em>.
-     *
-     * This address is also used as the value of the <em>reply-to</em>
-     * property of all command request messages sent by this client.
-     *
-     * @param con The connection to Hono.
-     * @param tenantId The tenant that the device belongs to.
-     * @param replyId The replyId to use in the reply-to address.
-     * @param sampler The sampler to use
-     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except for the close hooks is {@code null}.
-     */
-    public static final Future<CommandClient> create(
-            final HonoConnection con,
-            final String tenantId,
-            final String replyId,
-            final SendMessageSampler sampler,
-            final Handler<String> senderCloseHook,
-            final Handler<String> receiverCloseHook) {
-
-        final CommandClientImpl client = new CommandClientImpl(con, tenantId, replyId, sampler);
-        return client.createLinks(senderCloseHook, receiverCloseHook)
-                .map(ok -> {
-                    LOG.debug("successfully created command client for [{}]", tenantId);
-                    return (CommandClient) client;
-                }).recover(t -> {
-                    LOG.debug("failed to create command client for [{}]", tenantId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
deleted file mode 100644
index 9209dfca5..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.CommandResponse;
-import org.eclipse.hono.client.CommandResponseSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.util.AddressHelper;
-import org.eclipse.hono.util.CommandConstants;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A wrapper around an AMQP link for sending response messages to
- * commands downstream.
- */
-public class CommandResponseSenderImpl extends AbstractSender implements CommandResponseSender {
-
-    /**
-     * The default amount of time to wait for credits after link creation. This is higher as in the client defaults,
-     * because for the command response the link is created on demand and the response should not fail.
-     */
-    public static final long DEFAULT_COMMAND_FLOW_LATENCY = 200L; // ms
-
-    /**
-     * Creates a command response sender instance for a given connection and proton sender.
-     *
-     * @param connection The open connection to the Hono server.
-     * @param sender The sender link to send command response messages over.
-     * @param tenantId The tenant that the messages will be published for.
-     * @param targetAddress The target address to send the messages to.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters except targetAddress is {@code null}.
-     */
-    protected CommandResponseSenderImpl(
-            final HonoConnection connection,
-            final ProtonSender sender,
-            final String tenantId,
-            final String targetAddress,
-            final SendMessageSampler sampler) {
-
-        super(connection, sender, tenantId, targetAddress, sampler);
-    }
-
-    @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
-        return sendMessageAndWaitForOutcome(message, currentSpan);
-    }
-
-    @Override
-    protected String getTo(final String deviceId) {
-        return null;
-    }
-
-    @Override
-    public String getEndpoint() {
-        return CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT;
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
-        return send(message);
-    }
-
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext context) {
-        return send(message, context);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<ProtonDelivery> sendCommandResponse(final CommandResponse commandResponse,
-            final SpanContext context) {
-
-        Objects.requireNonNull(commandResponse);
-        final Message message = commandResponse.toMessage();
-        Objects.requireNonNull(message);
-        message.setAddress(AddressHelper.getTargetAddress(CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, commandResponse.getReplyToId(), null));
-        return sendAndWaitForOutcome(message, context);
-    }
-
-    /**
-     * Creates a new sender to send responses for commands back to the business application.
-     * <p>
-     * The underlying sender link will be created with the following properties:
-     * <ul>
-     * <li><em>flow latency</em> will be set to @{@link #DEFAULT_COMMAND_FLOW_LATENCY} if the configured value is
-     * smaller than the default</li>
-     * </ul>
-     *
-     * @param con The connection to the AMQP network.
-     * @param tenantId The tenant that the command response will be send for and the device belongs to.
-     * @param replyId The reply id as the unique postfix of the replyTo address.
-     * @param sampler The sampler to use.
-     * @param closeHook A handler to invoke if the peer closes the link unexpectedly (may be {@code null}).
-     * @return A future indicating the result of the creation attempt.
-     * @throws NullPointerException if any of the parameters except closeHook is {@code null}.
-     */
-    public static Future<CommandResponseSender> create(
-            final HonoConnection con,
-            final String tenantId,
-            final String replyId,
-            final SendMessageSampler sampler,
-            final Handler<String> closeHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(replyId);
-        Objects.requireNonNull(sampler);
-
-        final String targetAddress = AddressHelper.getTargetAddress(CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, replyId, con.getConfig());
-        final ClientConfigProperties props = new ClientConfigProperties(con.getConfig());
-        if (props.getFlowLatency() < DEFAULT_COMMAND_FLOW_LATENCY) {
-            props.setFlowLatency(DEFAULT_COMMAND_FLOW_LATENCY);
-        }
-
-        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook)
-                .map(sender -> (CommandResponseSender) new CommandResponseSenderImpl(con, sender, tenantId,
-                        targetAddress, sampler));
-    }
-
-    @Override
-    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
-
-        final Span span = newChildSpan(parent, "forward Command response");
-        Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_CLIENT);
-        return span;
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
deleted file mode 100644
index 11c9d6bfe..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.CredentialsClient;
-import org.eclipse.hono.client.CredentialsClientFactory;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.CredentialsConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.eventbus.Message;
-
-
-/**
- * A factory for creating clients for the Hono APIs required
- * by protocol adapters.
- *
- */
-public class CredentialsClientFactoryImpl extends AbstractHonoClientFactory implements CredentialsClientFactory {
-
-    private final CachingClientFactory<CredentialsClient> credentialsClientFactory;
-    private final CacheProvider cacheProvider;
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param cacheProvider The cache provider to use for creating caches for credential objects
-     *                      or {@code null} if credentials objects should not be cached.
-     * @param samplerFactory The sampler factory to use.
-     */
-    public CredentialsClientFactoryImpl(final HonoConnection connection, final CacheProvider cacheProvider, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-        credentialsClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());
-        this.cacheProvider = cacheProvider;
-        connection.getVertx().eventBus().consumer(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT,
-                this::handleTenantTimeout);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onDisconnect() {
-        credentialsClientFactory.clearState();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<CredentialsClient> getOrCreateCredentialsClient(
-            final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-        return connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    credentialsClientFactory.getOrCreateClient(
-                            CredentialsClientImpl.getTargetAddress(tenantId),
-                            () -> CredentialsClientImpl.create(
-                                    cacheProvider,
-                                    connection,
-                                    tenantId,
-                                    samplerFactory.create(CredentialsConstants.CREDENTIALS_ENDPOINT),
-                                    this::removeCredentialsClient,
-                                    this::removeCredentialsClient),
-                            result);
-                }));
-    }
-
-    private void removeCredentialsClient(final String tenantId) {
-        credentialsClientFactory.removeClient(CredentialsClientImpl.getTargetAddress(tenantId));
-    }
-
-    private void handleTenantTimeout(final Message<String> msg) {
-        final String address = CredentialsClientImpl.getTargetAddress(msg.body());
-        final CredentialsClient client = credentialsClientFactory.getClient(address);
-        if (client != null) {
-            client.close(v -> credentialsClientFactory.removeClient(address));
-        }
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
deleted file mode 100644
index b66729afe..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.util.Objects;
-import java.util.UUID;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.CredentialsClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.CredentialsConstants;
-import org.eclipse.hono.util.CredentialsObject;
-import org.eclipse.hono.util.CredentialsResult;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RequestResponseApiConstants;
-import org.eclipse.hono.util.TriTuple;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for Hono's Credentials API.
- *
- */
-public class CredentialsClientImpl extends AbstractRequestResponseClient<CredentialsResult<CredentialsObject>> implements CredentialsClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(CredentialsClientImpl.class);
-    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
-
-    private static final String TAG_AUTH_ID = "auth_id";
-    private static final String TAG_CREDENTIALS_TYPE = "credentials_type";
-
-    /**
-     * Creates a new client for accessing the Credentials service.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to Hono.
-     * @param tenantId The identifier of the tenant for which the client should be created.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    CredentialsClientImpl(final HonoConnection connection, final String tenantId, final SendMessageSampler sampler) {
-        super(connection, Objects.requireNonNull(tenantId), sampler);
-    }
-
-    /**
-     * Creates a new client for accessing the Credentials service.
-     *
-     * @param connection The connection to Hono.
-     * @param tenantId The identifier of the tenant for which the client should be created.
-     * @param sender The AMQP link to use for sending requests to the service.
-     * @param receiver The AMQP link to use for receiving responses from the service.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    CredentialsClientImpl(
-            final HonoConnection connection,
-            final String tenantId,
-            final ProtonSender sender,
-            final ProtonReceiver receiver,
-            final SendMessageSampler sampler) {
-        super(connection, Objects.requireNonNull(tenantId), sender, receiver, sampler);
-    }
-
-    @Override
-    protected final String getName() {
-
-        return CredentialsConstants.CREDENTIALS_ENDPOINT;
-    }
-
-    @Override
-    protected final String createMessageId() {
-
-        return String.format("cred-client-%s", UUID.randomUUID());
-    }
-
-    @Override
-    protected final CredentialsResult<CredentialsObject> getResult(
-            final int status,
-            final String contentType,
-            final Buffer payload,
-            final CacheDirective cacheDirective,
-            final ApplicationProperties applicationProperties) {
-
-        if (isSuccessResponse(status, contentType, payload)) {
-            try {
-                return CredentialsResult.from(
-                        status,
-                        OBJECT_MAPPER.readValue(payload.getBytes(), CredentialsObject.class),
-                        cacheDirective,
-                        applicationProperties);
-            } catch (final IOException e) {
-                LOG.warn("received malformed payload from Credentials service", e);
-                return CredentialsResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR, null, null, applicationProperties);
-            }
-        } else {
-            return CredentialsResult.from(status, null, null, applicationProperties);
-        }
-    }
-
-    /**
-     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Credentials API endpoint.
-     *
-     * @param tenantId The tenant to upload data for.
-     * @return The target address.
-     * @throws NullPointerException if tenant is {@code null}.
-     */
-    public static final String getTargetAddress(final String tenantId) {
-        return String.format("%s/%s", CredentialsConstants.CREDENTIALS_ENDPOINT, Objects.requireNonNull(tenantId));
-    }
-
-    /**
-     * Creates a new credentials client for a tenant.
-     *
-     * @param cacheProvider The cache provider to use for creating caches for credential objects
-     *                      or {@code null} if credential objects should not be cached.
-     * @param con The connection to the server.
-     * @param tenantId The tenant for which credentials are handled.
-     * @param sampler The sampler to use.
-     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters except for the close hooks is {@code null}.
-     */
-    public static final Future<CredentialsClient> create(
-            final CacheProvider cacheProvider,
-            final HonoConnection con,
-            final String tenantId,
-            final SendMessageSampler sampler,
-            final Handler<String> senderCloseHook,
-            final Handler<String> receiverCloseHook) {
-
-        LOG.debug("creating new credentials client for [{}]", tenantId);
-        final CredentialsClientImpl client = new CredentialsClientImpl(con, tenantId, sampler);
-        if (cacheProvider != null) {
-            client.setResponseCache(cacheProvider.getCache(CredentialsClientImpl.getTargetAddress(tenantId)));
-        }
-        return client.createLinks(senderCloseHook, receiverCloseHook)
-                .map(ok -> {
-                    LOG.debug("successfully created credentials client for [{}]", tenantId);
-                    return (CredentialsClient) client;
-                }).recover(t -> {
-                    LOG.debug("failed to create credentials client for [{}]", tenantId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-
-    /**
-     * Invokes the <em>Get Credentials</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/credentials/">Credentials API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     */
-    @Override
-    public Future<CredentialsObject> get(final String type, final String authId) {
-        return get(type, authId, new JsonObject());
-    }
-
-    /**
-     * Invokes the <em>Get Credentials</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/credentials/">Credentials API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     */
-    @Override
-    public Future<CredentialsObject> get(final String type, final String authId, final JsonObject clientContext) {
-        return get(type, authId, clientContext, null);
-    }
-
-    /**
-     * Invokes the <em>Get Credentials</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/credentials/">Credentials API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     */
-    @Override
-    public final Future<CredentialsObject> get(final String type, final String authId, final JsonObject clientContext,
-            final SpanContext spanContext) {
-
-        Objects.requireNonNull(type);
-        Objects.requireNonNull(authId);
-        Objects.requireNonNull(clientContext);
-
-        final Promise<CredentialsResult<CredentialsObject>> responseTracker = Promise.promise();
-        final JsonObject specification = CredentialsConstants
-                .getSearchCriteria(type, authId)
-                .mergeIn(clientContext);
-        final TriTuple<CredentialsConstants.CredentialsAction, String, Integer> key = TriTuple
-                .of(CredentialsConstants.CredentialsAction.get, String.format("%s-%s", type, authId), clientContext.hashCode());
-
-        final Span span = newChildSpan(spanContext, "get Credentials");
-        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, getTenantId());
-        span.setTag(TAG_CREDENTIALS_TYPE, type);
-        span.setTag(TAG_AUTH_ID, authId);
-
-        final Future<CredentialsResult<CredentialsObject>> resultTracker = getResponseFromCache(key, span)
-                .recover(cacheMiss -> {
-                    createAndSendRequest(
-                            CredentialsConstants.CredentialsAction.get.toString(),
-                            null,
-                            specification.toBuffer(),
-                            RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
-                            responseTracker,
-                            key,
-                            span);
-                    return responseTracker.future();
-                });
-
-        return mapResultAndFinishSpan(resultTracker, result -> {
-            switch (result.getStatus()) {
-            case HttpURLConnection.HTTP_OK:
-            case HttpURLConnection.HTTP_CREATED:
-                return result.getPayload();
-            case HttpURLConnection.HTTP_NOT_FOUND:
-                throw new ClientErrorException(result.getStatus(), "no such credentials");
-            default:
-                throw StatusCodeMapper.from(result);
-            }
-        }, span);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java
deleted file mode 100644
index 5d9c3982b..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.DownstreamSenderFactory;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.AddressHelper;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.EventConstants;
-import org.eclipse.hono.util.TelemetryConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.eventbus.Message;
-
-
-/**
- * A factory for creating downstream senders.
- *
- */
-public class DownstreamSenderFactoryImpl extends AbstractHonoClientFactory implements DownstreamSenderFactory {
-
-    private final CachingClientFactory<DownstreamSender> clientFactory;
-
-    /**
-     * @param connection The connection to use.
-     * @param samplerFactory The factory to create samplers.
-     */
-    public DownstreamSenderFactoryImpl(final HonoConnection connection, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-        this.clientFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());
-        connection.getVertx().eventBus().consumer(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT,
-                this::handleTenantTimeout);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onDisconnect() {
-        clientFactory.clearState();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<DownstreamSender> getOrCreateTelemetrySender(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-        return connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    clientFactory.getOrCreateClient(
-                            AddressHelper.getTargetAddress(TelemetryConstants.TELEMETRY_ENDPOINT, tenantId, null, connection.getConfig()),
-                            () -> TelemetrySenderImpl.create(connection, tenantId, samplerFactory.create(TelemetryConstants.TELEMETRY_ENDPOINT),
-                                    onSenderClosed -> {
-                                        clientFactory.removeClient(AddressHelper.getTargetAddress(TelemetryConstants.TELEMETRY_ENDPOINT, tenantId, null, connection.getConfig()));
-                                    }),
-                            result);
-                }));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<DownstreamSender> getOrCreateEventSender(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-        return connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    clientFactory.getOrCreateClient(
-                            AddressHelper.getTargetAddress(EventConstants.EVENT_ENDPOINT, tenantId, null, connection.getConfig()),
-                            () -> EventSenderImpl.create(connection, tenantId, samplerFactory.create(EventConstants.EVENT_ENDPOINT),
-                                    onSenderClosed -> {
-                                        clientFactory.removeClient(AddressHelper.getTargetAddress(EventConstants.EVENT_ENDPOINT, tenantId, null, connection.getConfig()));
-                                    }),
-                            result);
-                }));
-    }
-
-    private void handleTenantTimeout(final Message<String> msg) {
-        final String telemetryAddress = AddressHelper.getTargetAddress(TelemetryConstants.TELEMETRY_ENDPOINT, msg.body(), null, connection.getConfig());
-        final DownstreamSender telemetryClient = clientFactory.getClient(telemetryAddress);
-        if (telemetryClient != null) {
-            telemetryClient.close(v -> clientFactory.removeClient(telemetryAddress));
-        }
-
-        final String eventAddress = AddressHelper.getTargetAddress(EventConstants.EVENT_ENDPOINT, msg.body(), null, connection.getConfig());
-        final DownstreamSender eventClient = clientFactory.getClient(eventAddress);
-        if (eventClient != null) {
-            eventClient.close(v -> clientFactory.removeClient(eventAddress));
-        }
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
deleted file mode 100644
index aa9baca7f..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-import java.util.function.BiConsumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.util.EventConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * A Vertx-Proton based client for consuming event messages from a Hono server.
- */
-public class EventConsumerImpl extends AbstractConsumer implements MessageConsumer {
-
-    private EventConsumerImpl(final HonoConnection connection, final ProtonReceiver receiver) {
-        super(connection, receiver);
-    }
-
-    /**
-     * Creates a new event consumer for a tenant.
-     * <p>
-     * The event messages passed in to the event consumer will be accepted and settled automatically if
-     * the consumer does not throw an exception and does not manually handle the message disposition
-     * using the passed in delivery.
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consumer events for.
-     * @param eventConsumer The consumer to invoke with each event received.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except the closeHook are {@code null}.
-     */
-    public static Future<MessageConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> eventConsumer,
-            final Handler<String> closeHook) {
-        return create(con, tenantId, eventConsumer, true, closeHook);
-    }
-
-    /**
-     * Creates a new event consumer for a tenant.
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consumer events for.
-     * @param eventConsumer The consumer to invoke with each event received.
-     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)
-     *                   after the message handler runs for them, if no other disposition has been applied
-     *                   during handling. NOTE: When using {@code false} here, make sure that deliveries are
-     *                   quickly updated and settled, so that the messages don't remain <em>in flight</em>
-     *                   for long.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except the closeHook are {@code null}.
-     */
-    public static Future<MessageConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> eventConsumer,
-            final boolean autoAccept,
-            final Handler<String> closeHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(eventConsumer);
-
-        final String sourceAddress = String.format("%s/%s", EventConstants.EVENT_ENDPOINT, tenantId);
-        final int preFetchSize = con.getConfig().getInitialCredits();
-        return con.createReceiver(
-                sourceAddress,
-                ProtonQoS.AT_LEAST_ONCE,
-                eventConsumer::accept,
-                preFetchSize,
-                autoAccept,
-                closeHook)
-                .compose(receiver -> Future.succeededFuture(new EventConsumerImpl(con, receiver)));
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
deleted file mode 100644
index 07b3c5e19..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.AddressHelper;
-import org.eclipse.hono.util.EventConstants;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for publishing event messages to a Hono server.
- */
-public class EventSenderImpl extends AbstractDownstreamSender {
-
-    /**
-     * Creates a event sender instance for a given connection and proton sender.
-     *
-     * @param con The open connection to the Hono server.
-     * @param sender The sender link to send events over.
-     * @param tenantId The tenant that the events will be published for.
-     * @param targetAddress The target address to send the events to.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters except targetAddress is {@code null}.
-     */
-    protected EventSenderImpl(
-            final HonoConnection con,
-            final ProtonSender sender,
-            final String tenantId,
-            final String targetAddress,
-            final SendMessageSampler sampler) {
-
-        super(con, sender, tenantId, targetAddress, sampler);
-    }
-
-    @Override
-    public String getEndpoint() {
-        return EventConstants.EVENT_ENDPOINT;
-    }
-
-    @Override
-    protected String getTo(final String deviceId) {
-        return AddressHelper.getTargetAddress(EventConstants.EVENT_ENDPOINT, tenantId, deviceId, null);
-    }
-
-    /**
-     * Creates a new sender for publishing events to a Hono server.
-     *
-     * @param con The connection to the Hono server.
-     * @param tenantId The tenant that the events will be published for.
-     * @param sampler The sampler to use.
-     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
-     *            sender's target address is provided as an argument to the handler.
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except remoteCloseHook is {@code null}.
-     */
-    public static Future<DownstreamSender> create(
-            final HonoConnection con,
-            final String tenantId,
-            final SendMessageSampler sampler,
-            final Handler<String> remoteCloseHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(sampler);
-
-        final String targetAddress = AddressHelper.getTargetAddress(EventConstants.EVENT_ENDPOINT, tenantId, null, con.getConfig());
-        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
-                .compose(sender -> Future.succeededFuture(new EventSenderImpl(con, sender, tenantId, targetAddress, sampler)));
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * This method simply invokes {@link #send(Message)} because events are
-     * always sent with at least once delivery semantics.
-     */
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
-
-        return send(message);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * This method simply invokes {@link #send(Message, SpanContext)} because events are
-     * always sent with at least once delivery semantics.
-     */
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
-
-        return send(message, parent);
-    }
-
-    /**
-     * Sends an AMQP 1.0 message to the peer this client is configured for
-     * and waits for the outcome of the transfer.
-     * <p>
-     * This method sets the message's <em>durable</em> property to {@code true} and
-     * then invokes {@link #sendMessageAndWaitForOutcome(Message, Span)}.
-     *
-     * @param message The message to send.
-     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
-     *              The span will be finished by this method and will contain an error log if
-     *              the message has not been accepted by the peer.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been accepted (and settled)
-     *         by the peer.
-     *         <p>
-     *         The future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException} if the
-     *         message could not be sent or has not been accepted by the peer or if no delivery update
-     *         was received from the peer within the configured timeout period
-     *         (see {@link org.eclipse.hono.config.ClientConfigProperties#getSendMessageTimeout()}).
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
-
-        message.setDurable(true);
-        return sendMessageAndWaitForOutcome(message, currentSpan);
-    }
-
-    @Override
-    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
-
-        final Span span = newChildSpan(parent, "forward Event");
-        Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
-        return span;
-    }
-
-    @Override
-    protected void logMessageSendingError(final String format, final Object... arguments) {
-        // log on INFO instead of DEBUG level since events are usually brokered and therefore errors here might indicate issues with the broker
-        log.info(format, arguments);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
deleted file mode 100644
index 8164323c3..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.RegistrationClientFactory;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.RegistrationConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.eventbus.Message;
-
-
-/**
- * A factory for creating clients for the Hono APIs required
- * by protocol adapters.
- *
- */
-public class RegistrationClientFactoryImpl extends AbstractHonoClientFactory implements RegistrationClientFactory {
-
-    private final CachingClientFactory<RegistrationClient> registrationClientFactory;
-    private final CacheProvider cacheProvider;
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param cacheProvider The cache provider to use for creating caches for tenant objects
-     *                      or {@code null} if tenant objects should not be cached.
-     * @param samplerFactory The sampler factory to use.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    public RegistrationClientFactoryImpl(final HonoConnection connection, final CacheProvider cacheProvider, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-        this.registrationClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());
-        this.cacheProvider = cacheProvider;
-        connection.getVertx().eventBus().consumer(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT,
-                this::handleTenantTimeout);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onDisconnect() {
-        registrationClientFactory.clearState();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<RegistrationClient> getOrCreateRegistrationClient(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-
-        return connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    registrationClientFactory.getOrCreateClient(
-                            RegistrationClientImpl.getTargetAddress(tenantId),
-                            () -> RegistrationClientImpl.create(
-                                    cacheProvider,
-                                    connection,
-                                    tenantId,
-                                    samplerFactory.create(RegistrationConstants.REGISTRATION_ENDPOINT),
-                                    this::removeRegistrationClient,
-                                    this::removeRegistrationClient),
-                            result);
-                }));
-    }
-
-    private void removeRegistrationClient(final String tenantId) {
-        registrationClientFactory.removeClient(RegistrationClientImpl.getTargetAddress(tenantId));
-    }
-
-    private void handleTenantTimeout(final Message<String> msg) {
-        final String address = RegistrationClientImpl.getTargetAddress(msg.body());
-        final RegistrationClient client = registrationClientFactory.getClient(address);
-        if (client != null) {
-            client.close(v -> registrationClientFactory.removeClient(address));
-        }
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
deleted file mode 100644
index 63c368754..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
+++ /dev/null
@@ -1,254 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.UUID;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RegistrationConstants;
-import org.eclipse.hono.util.RegistrationResult;
-import org.eclipse.hono.util.TriTuple;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.core.json.DecodeException;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for Hono's Registration API.
- *
- */
-public class RegistrationClientImpl extends AbstractRequestResponseClient<RegistrationResult> implements RegistrationClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(RegistrationClientImpl.class);
-
-    /**
-     * Creates a new client for accessing the Device Registration service.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to Hono.
-     * @param tenantId The identifier of the tenant for which the client should be created.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected RegistrationClientImpl(final HonoConnection connection, final String tenantId, final SendMessageSampler sampler) {
-        super(connection, Objects.requireNonNull(tenantId), sampler);
-    }
-
-    /**
-     * Creates a new client for accessing the Device Registration service.
-     *
-     * @param connection The connection to Hono.
-     * @param tenantId The identifier of the tenant for which the client should be created.
-     * @param sender The AMQP link to use for sending requests to the service.
-     * @param receiver The AMQP link to use for receiving responses from the service.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected RegistrationClientImpl(
-            final HonoConnection connection,
-            final String tenantId,
-            final ProtonSender sender,
-            final ProtonReceiver receiver,
-            final SendMessageSampler sampler) {
-
-        super(connection, Objects.requireNonNull(tenantId), sender, receiver, sampler);
-    }
-
-    /**
-     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Device Registration API endpoint.
-     *
-     * @param tenantId The tenant to upload data for.
-     * @return The target address.
-     * @throws NullPointerException if tenant is {@code null}.
-     */
-    public static final String getTargetAddress(final String tenantId) {
-        return String.format("%s/%s", RegistrationConstants.REGISTRATION_ENDPOINT, Objects.requireNonNull(tenantId));
-    }
-
-    @Override
-    protected final String getName() {
-
-        return RegistrationConstants.REGISTRATION_ENDPOINT;
-    }
-
-    @Override
-    protected final String createMessageId() {
-
-        return String.format("reg-client-%s", UUID.randomUUID());
-    }
-
-    @Override
-    protected final RegistrationResult getResult(
-            final int status,
-            final String contentType,
-            final Buffer payload,
-            final CacheDirective cacheDirective,
-            final ApplicationProperties applicationProperties) {
-
-        if (isSuccessResponse(status, contentType, payload)) {
-            try {
-                return RegistrationResult.from(status, new JsonObject(payload), cacheDirective, applicationProperties);
-            } catch (final DecodeException e) {
-                LOG.warn("received malformed payload from Device Registration service", e);
-                return RegistrationResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR, null, null, applicationProperties);
-            }
-        } else {
-            return RegistrationResult.from(status, null, null, applicationProperties);
-        }
-    }
-
-    /**
-     * Creates a new registration client for a tenant.
-     *
-     * @param cacheProvider A factory for cache instances for registration results. If {@code null}
-     *                     the client will not cache any results from the Device Registration service.
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consumer events for.
-     * @param sampler The sampler to use.
-     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if con, tenantId or sampler is {@code null}.
-     */
-    public static final Future<RegistrationClient> create(
-            final CacheProvider cacheProvider,
-            final HonoConnection con,
-            final String tenantId,
-            final SendMessageSampler sampler,
-            final Handler<String> senderCloseHook,
-            final Handler<String> receiverCloseHook) {
-
-        LOG.debug("creating new registration client for [{}]", tenantId);
-        final RegistrationClientImpl client = new RegistrationClientImpl(con, tenantId, sampler);
-        if (cacheProvider != null) {
-            client.setResponseCache(cacheProvider.getCache(RegistrationClientImpl.getTargetAddress(tenantId)));
-        }
-        return client.createLinks(senderCloseHook, receiverCloseHook)
-                .map(ok -> {
-                    LOG.debug("successfully created registration client for [{}]", tenantId);
-                    return (RegistrationClient) client;
-                }).recover(t -> {
-                    LOG.debug("failed to create registration client for [{}]", tenantId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-
-    private Map<String, Object> createDeviceIdProperties(final String deviceId) {
-        final Map<String, Object> properties = new HashMap<>();
-        properties.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);
-        return properties;
-    }
-
-    /**
-     * Invokes the <em>Assert Device Registration</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/device-registration/">Device Registration API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     * <p>
-     * This method delegates to {@link #assertRegistration(String, String)} with {@code null}
-     * as the <em>gatewayId</em>.
-     */
-    @Override
-    public final Future<JsonObject> assertRegistration(final String deviceId) {
-        return assertRegistration(deviceId, null);
-    }
-
-    /**
-     * Invokes the <em>Assert Device Registration</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/device-registration/">Device Registration API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     */
-    @Override
-    public final Future<JsonObject> assertRegistration(final String deviceId, final String gatewayId) {
-
-        return assertRegistration(deviceId, gatewayId, null);
-    }
-
-    /**
-     * Invokes the <em>Assert Device Registration</em> operation of Hono's
-     * <a href="https://www.eclipse.org/hono/docs/api/device-registration/">Device Registration API</a>
-     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
-     * <p>
-     * This method delegates to {@link #assertRegistration(String, String)} with {@code null}
-     * as the <em>gatewayId</em>.
-     */
-    @Override
-    public final Future<JsonObject> assertRegistration(
-            final String deviceId,
-            final String gatewayId,
-            final SpanContext parent) {
-
-        Objects.requireNonNull(deviceId);
-
-        final TriTuple<String, String, String> key = TriTuple.of(RegistrationConstants.ACTION_ASSERT, deviceId, gatewayId);
-        final Span span = newChildSpan(parent, "assert Device Registration");
-        TracingHelper.setDeviceTags(span, getTenantId(), deviceId);
-        TracingHelper.TAG_GATEWAY_ID.set(span, gatewayId);
-
-        final Future<RegistrationResult> resultTracker = getResponseFromCache(key, span)
-                .recover(t -> {
-                    final Promise<RegistrationResult> regResult = Promise.promise();
-                    final Map<String, Object> properties = createDeviceIdProperties(deviceId);
-                    if (gatewayId != null) {
-                        properties.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);
-                    }
-                    createAndSendRequest(
-                            RegistrationConstants.ACTION_ASSERT,
-                            properties,
-                            null,
-                            RegistrationConstants.CONTENT_TYPE_APPLICATION_JSON,
-                            regResult,
-                            key,
-                            span);
-                    return regResult.future();
-                });
-        return mapResultAndFinishSpan(resultTracker, result -> {
-            switch (result.getStatus()) {
-            case HttpURLConnection.HTTP_OK:
-                return result.getPayload();
-            case HttpURLConnection.HTTP_NOT_FOUND:
-                throw new ClientErrorException(result.getStatus(), "device unknown or disabled");
-            case HttpURLConnection.HTTP_FORBIDDEN:
-                throw new ClientErrorException(
-                        result.getStatus(),
-                        "gateway unknown, disabled or not authorized to act on behalf of device");
-            default:
-                throw StatusCodeMapper.from(result);
-            }
-        }, span);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
deleted file mode 100644
index 6fc2c4381..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.util.TelemetryConstants;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * A Vertx-Proton based client for consuming telemetry data from a Hono server.
- */
-public class TelemetryConsumerImpl extends AbstractConsumer implements MessageConsumer {
-
-    private TelemetryConsumerImpl(final HonoConnection connection, final ProtonReceiver receiver) {
-        super(connection, receiver);
-    }
-
-    /**
-     * Creates a new telemetry data consumer for a tenant.
-     * <p>
-     * The telemetry messages passed in to the consumer will be accepted and settled automatically if the
-     * consumer does not throw an exception.
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consumer events for.
-     * @param telemetryConsumer The consumer to invoke with each telemetry message received.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public static Future<MessageConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final Consumer<Message> telemetryConsumer,
-            final Handler<String> closeHook ) {
-
-        return create(
-                con,
-                tenantId,
-                (delivery, message) -> telemetryConsumer.accept(message),
-                true,
-                closeHook);
-    }
-
-    /**
-     * Creates a new telemetry data consumer for a tenant.
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consumer events for.
-     * @param telemetryConsumer The consumer to invoke with each telemetry message received.
-     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)
-     *                   after the message handler runs for them, if no other disposition has been applied
-     *                   during handling. NOTE: When using {@code false} here, make sure that deliveries are
-     *                   quickly updated and settled, so that the messages don't remain <em>in flight</em>
-     *                   for long.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public static Future<MessageConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> telemetryConsumer,
-            final boolean autoAccept,
-            final Handler<String> closeHook ) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(telemetryConsumer);
-
-        final String sourceAddress = String.format("%s/%s", TelemetryConstants.TELEMETRY_ENDPOINT, tenantId);
-        final int preFetchSize = con.getConfig().getInitialCredits();
-        return con.createReceiver(
-                sourceAddress,
-                ProtonQoS.AT_LEAST_ONCE,
-                telemetryConsumer::accept,
-                preFetchSize,
-                autoAccept,
-                closeHook)
-                .compose(receiver -> Future.succeededFuture(new TelemetryConsumerImpl(con, receiver)));
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
deleted file mode 100644
index 6475524b3..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.NoConsumerException;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.AddressHelper;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.TelemetryConstants;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for uploading telemetry data to a Hono server.
- */
-public class TelemetrySenderImpl extends AbstractDownstreamSender {
-
-    /**
-     * Creates a telemetry sender instance for a given connection and proton sender.
-     *
-     * @param con The open connection to the Hono server.
-     * @param sender The sender link to send telemetry messages over.
-     * @param tenantId The tenant that the messages will be published for.
-     * @param targetAddress The target address to send the messages to.
-     * @param sampler The sampler for sending messages.
-     * @throws NullPointerException if any of the parameters except targetAddress is {@code null}.
-     */
-    protected TelemetrySenderImpl(
-            final HonoConnection con,
-            final ProtonSender sender,
-            final String tenantId,
-            final String targetAddress,
-            final SendMessageSampler sampler) {
-
-        super(con, sender, tenantId, targetAddress, sampler);
-    }
-
-    @Override
-    public String getEndpoint() {
-        return TelemetryConstants.TELEMETRY_ENDPOINT;
-    }
-
-    @Override
-    protected String getTo(final String deviceId) {
-        return AddressHelper.getTargetAddress(TelemetryConstants.TELEMETRY_ENDPOINT, tenantId, deviceId, null);
-    }
-
-    /**
-     * Creates a new sender for publishing telemetry data to a Hono server.
-     *
-     * @param con The connection to the Hono server.
-     * @param tenantId The tenant that the telemetry data will be published for.
-     * @param sampler The sampler to use.
-     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
-     *            sender's target address is provided as an argument to the handler.
-     * @return A future indicating the outcome.
-     * @throws NullPointerException if any of the parameters except remoteCloseHook is {@code null}.
-     */
-    public static Future<DownstreamSender> create(
-            final HonoConnection con,
-            final String tenantId,
-            final SendMessageSampler sampler,
-            final Handler<String> remoteCloseHook) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(sampler);
-
-        final String targetAddress = AddressHelper.getTargetAddress(TelemetryConstants.TELEMETRY_ENDPOINT, tenantId, null, con.getConfig());
-        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
-                .compose(sender -> Future
-                        .succeededFuture(new TelemetrySenderImpl(con, sender, tenantId, targetAddress, sampler)));
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message rawMessage) {
-        return sendAndWaitForOutcome(rawMessage, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message rawMessage, final SpanContext parent) {
-
-        Objects.requireNonNull(rawMessage);
-
-        // we create a child span (instead of a following span) because we depend
-        // on the outcome of the sending operation
-        final Span span = startChildSpan(parent);
-        Tags.MESSAGE_BUS_DESTINATION.set(span, getMessageAddress(rawMessage));
-        TracingHelper.TAG_QOS.set(span, sender.getQoS().toString());
-        TracingHelper.setDeviceTags(span, tenantId, MessageHelper.getDeviceId(rawMessage));
-        TracingHelper.injectSpanContext(connection.getTracer(), span.context(), rawMessage);
-
-        return connection.executeOnContext(result -> {
-            if (sender.sendQueueFull()) {
-                final ServerErrorException e = new NoConsumerException("no credit available");
-                logMessageSendingError("error sending message [ID: {}, address: {}], no credit available (drain={})",
-                        rawMessage.getMessageId(), getMessageAddress(rawMessage), sender.getDrain());
-                TracingHelper.TAG_CREDIT.set(span, 0);
-                logError(span, e);
-                span.finish();
-                result.fail(e);
-            } else {
-                sendMessageAndWaitForOutcome(rawMessage, span).onComplete(result);
-            }
-        });
-    }
-
-    /**
-     * Sends an AMQP 1.0 message to the peer this client is configured for.
-     *
-     * @param message The message to send.
-     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
-     *              The span will be finished by this method and will contain an error log if
-     *              the message has not been accepted by the peer.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been sent to the peer.
-     *         The delivery contained in the future will represent the delivery
-     *         state at the time the future has been succeeded, i.e. it will be
-     *         locally <em>unsettled</em> without any outcome yet.
-     *         <p>
-     *         The future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException} if the
-     *         message could not be sent.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
-
-        Objects.requireNonNull(message);
-        Objects.requireNonNull(currentSpan);
-
-        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
-        message.setMessageId(messageId);
-        logMessageIdAndSenderInfo(currentSpan, messageId);
-
-        final SendMessageSampler.Sample sample = this.sampler.start(this.tenantId);
-
-        final AtomicReference<ProtonDelivery> deliveryRef = new AtomicReference<>();
-        final ClientConfigProperties config = connection.getConfig();
-        final AtomicBoolean timeoutReached = new AtomicBoolean(false);
-        final Long timerId = config.getSendMessageTimeout() > 0
-                ? connection.getVertx().setTimer(config.getSendMessageTimeout(), id -> {
-                    if (timeoutReached.compareAndSet(false, true)) {
-                        handleSendMessageTimeout(message, config.getSendMessageTimeout(), deliveryRef.get(), sample,
-                                null, currentSpan);
-                    }
-                })
-                : null;
-
-        final ProtonDelivery delivery = sender.send(message, deliveryUpdated -> {
-            if (timerId != null) {
-                connection.getVertx().cancelTimer(timerId);
-            }
-            final DeliveryState remoteState = deliveryUpdated.getRemoteState();
-            sample.completed(remoteState);
-            if (timeoutReached.get()) {
-                log.debug("ignoring received delivery update for message [ID: {}, address: {}]: waiting for the update has already timed out",
-                        messageId, getMessageAddress(message));
-            } else if (deliveryUpdated.remotelySettled()) {
-                logUpdatedDeliveryState(currentSpan, message, deliveryUpdated);
-            } else {
-                logMessageSendingError("peer did not settle message [ID: {}, address: {}, remote state: {}], failing delivery",
-                        messageId, getMessageAddress(message), remoteState.getClass().getSimpleName());
-                TracingHelper.logError(currentSpan, new ServerErrorException(
-                        HttpURLConnection.HTTP_INTERNAL_ERROR,
-                        "peer did not settle message, failing delivery"));
-            }
-            currentSpan.finish();
-        });
-        deliveryRef.set(delivery);
-        log.trace("sent AT_MOST_ONCE message [ID: {}, address: {}], remaining credit: {}, queued messages: {}",
-                messageId, getMessageAddress(message), sender.getCredit(), sender.getQueued());
-
-        return Future.succeededFuture(delivery);
-    }
-
-    @Override
-    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
-
-        final Span span = newFollowingSpan(parent, "forward Telemetry data");
-        Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
-        return span;
-    }
-
-    private Span startChildSpan(final SpanContext parent) {
-
-        final Span span = newChildSpan(parent, "forward Telemetry data");
-        Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
-        return span;
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java
deleted file mode 100644
index e2ad782d5..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.TenantClient;
-import org.eclipse.hono.client.TenantClientFactory;
-import org.eclipse.hono.util.TenantConstants;
-
-import io.vertx.core.Future;
-
-
-/**
- * A factory for creating clients for Hono's Tenant service.
- *
- */
-public class TenantClientFactoryImpl extends AbstractHonoClientFactory implements TenantClientFactory {
-
-    private final CachingClientFactory<TenantClient> tenantClientFactory;
-    private final CacheProvider cacheProvider;
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to use.
-     * @param cacheProvider The cache provider to use for creating caches for tenant objects
-     *                      or {@code null} if tenant objects should not be cached.
-     * @param samplerFactory The sampler factory to use.
-     * @throws NullPointerException if connection is {@code null}
-     */
-    public TenantClientFactoryImpl(final HonoConnection connection, final CacheProvider cacheProvider, final SendMessageSampler.Factory samplerFactory) {
-        super(connection, samplerFactory);
-        this.tenantClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());
-        this.cacheProvider = cacheProvider;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onDisconnect() {
-        tenantClientFactory.clearState();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<TenantClient> getOrCreateTenantClient() {
-
-        return connection.isConnected(getDefaultConnectionCheckTimeout())
-                .compose(v -> connection.executeOnContext(result -> {
-                    tenantClientFactory.getOrCreateClient(
-                            TenantClientImpl.getTargetAddress(),
-                            () -> TenantClientImpl.create(
-                                    cacheProvider,
-                                    connection,
-                                    samplerFactory.create(TenantConstants.TENANT_ENDPOINT),
-                                    this::removeTenantClient,
-                                    this::removeTenantClient),
-                            result);
-                }));
-    }
-
-    private void removeTenantClient(final String tenantId) {
-        // the tenantId is not relevant for this client, so ignore it
-        tenantClientFactory.removeClient(TenantClientImpl.getTargetAddress());
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
deleted file mode 100644
index 6651d136e..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
+++ /dev/null
@@ -1,269 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.util.Map;
-import java.util.Objects;
-import java.util.UUID;
-import java.util.function.Supplier;
-
-import javax.security.auth.x500.X500Principal;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.eclipse.hono.cache.CacheProvider;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.client.TenantClient;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RegistrationConstants;
-import org.eclipse.hono.util.TenantConstants;
-import org.eclipse.hono.util.TenantConstants.TenantAction;
-import org.eclipse.hono.util.TenantObject;
-import org.eclipse.hono.util.TenantResult;
-import org.eclipse.hono.util.TriTuple;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.fasterxml.jackson.databind.ObjectMapper;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.tag.StringTag;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A Vertx-Proton based client for Hono's Tenant API.
- *
- * @deprecated Use {@code org.eclipse.hono.client.registry.amqp.ProtonBasedTenantClient} instead.
- */
-@Deprecated
-public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult<TenantObject>>
-        implements TenantClient {
-
-    private static final Logger LOG = LoggerFactory.getLogger(TenantClientImpl.class);
-    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
-    private static final StringTag TAG_SUBJECT_DN = new StringTag("subject_dn");
-
-    /**
-     * Creates a client for invoking operations of the Tenant API.
-     * <p>
-     * The client will be ready to use after invoking {@link #createLinks()} or
-     * {@link #createLinks(Handler, Handler)} only.
-     *
-     * @param connection The connection to Hono.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    protected TenantClientImpl(final HonoConnection connection, final SendMessageSampler sampler) {
-        super(connection, null, sampler);
-    }
-
-    /**
-     * Creates a client for invoking operations of the Tenant API.
-     *
-     * @param connection The connection to Hono.
-     * @param sender The AMQP 1.0 link to use for sending requests to the peer.
-     * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
-     * @param sampler The sampler to use.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    protected TenantClientImpl(
-            final HonoConnection connection,
-            final ProtonSender sender,
-            final ProtonReceiver receiver,
-            final SendMessageSampler sampler) {
-
-        super(connection, null, sender, receiver, sampler);
-    }
-
-    @Override
-    protected final String getName() {
-
-        return TenantConstants.TENANT_ENDPOINT;
-    }
-
-    @Override
-    protected final String createMessageId() {
-
-        return String.format("tenant-client-%s", UUID.randomUUID());
-    }
-
-    @Override
-    protected final TenantResult<TenantObject> getResult(
-            final int status,
-            final String contentType,
-            final Buffer payload,
-            final CacheDirective cacheDirective,
-            final ApplicationProperties applicationProperties) {
-
-        if (isSuccessResponse(status, contentType, payload)) {
-            try {
-                return TenantResult.from(
-                        status,
-                        OBJECT_MAPPER.readValue(payload.getBytes(), TenantObject.class),
-                        cacheDirective,
-                        applicationProperties);
-            } catch (final IOException e) {
-                LOG.warn("received malformed payload from Tenant service", e);
-                return TenantResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR, null, null, applicationProperties);
-            }
-        } else {
-            return TenantResult.from(status, null, null, applicationProperties);
-        }
-    }
-
-    /**
-     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Tenant API endpoint.
-     *
-     * @return The target address.
-     */
-    public static final String getTargetAddress() {
-        return TenantConstants.TENANT_ENDPOINT;
-    }
-
-    /**
-     * Creates a new tenant client.
-     *
-     * @param cacheProvider A factory for cache instances for tenant configuration results. If {@code null}
-     *                     the client will not cache any results from the Tenant service.
-     * @param connection The connection to the server.
-     * @param sampler The sampler to use.
-     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).
-     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters, except for senderCloseHook and receiverCloseHook are {@code null}.
-     */
-    public static final Future<TenantClient> create(
-            final CacheProvider cacheProvider,
-            final HonoConnection connection,
-            final SendMessageSampler sampler,
-            final Handler<String> senderCloseHook,
-            final Handler<String> receiverCloseHook) {
-
-        LOG.debug("creating new tenant client");
-        final TenantClientImpl client = new TenantClientImpl(connection, sampler);
-        if (cacheProvider != null) {
-            client.setResponseCache(cacheProvider.getCache(TenantClientImpl.getTargetAddress()));
-        }
-        return client.createLinks(senderCloseHook, receiverCloseHook)
-            .map(ok -> {
-                LOG.debug("successfully created tenant client");
-                return (TenantClient) client;
-            }).recover(t -> {
-                LOG.debug("failed to create tenant client", t);
-                return Future.failedFuture(t);
-            });
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<TenantObject> get(final String tenantId) {
-        return get(tenantId, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<TenantObject> get(final String tenantId, final SpanContext parent) {
-
-        Objects.requireNonNull(tenantId);
-
-        final TriTuple<TenantAction, String, Object> key = TriTuple.of(TenantAction.get, tenantId, null);
-        final Span span = newChildSpan(parent, "get Tenant by ID");
-        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
-        return get(
-                key,
-                () -> new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, tenantId),
-                span);
-    }
-
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<TenantObject> get(final X500Principal subjectDn) {
-        return get(subjectDn, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<TenantObject> get(final X500Principal subjectDn, final SpanContext parent) {
-
-        Objects.requireNonNull(subjectDn);
-
-        final String subjectDnRfc2253 = subjectDn.getName(X500Principal.RFC2253);
-        final TriTuple<TenantAction, X500Principal, Object> key = TriTuple.of(TenantAction.get, subjectDn, null);
-        final Span span = newChildSpan(parent, "get Tenant by subject DN");
-        TAG_SUBJECT_DN.set(span, subjectDnRfc2253);
-        return get(
-                key,
-                () -> new JsonObject().put(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN, subjectDnRfc2253),
-                span);
-    }
-
-    private <T> Future<TenantObject> get(
-            final TriTuple<TenantAction, T, Object> key,
-            final Supplier<JsonObject> payloadSupplier,
-            final Span currentSpan) {
-
-        final Future<TenantResult<TenantObject>> resultTracker = getResponseFromCache(key, currentSpan)
-                .recover(cacheMiss -> {
-                    final Promise<TenantResult<TenantObject>> tenantResult = Promise.promise();
-                    createAndSendRequest(
-                            TenantAction.get.toString(),
-                            customizeRequestApplicationProperties(),
-                            payloadSupplier.get().toBuffer(),
-                            RegistrationConstants.CONTENT_TYPE_APPLICATION_JSON,
-                            tenantResult,
-                            key,
-                            currentSpan);
-                    return tenantResult.future();
-                });
-        return mapResultAndFinishSpan(resultTracker, tenantResult -> {
-            switch (tenantResult.getStatus()) {
-            case HttpURLConnection.HTTP_OK:
-                return tenantResult.getPayload();
-            case HttpURLConnection.HTTP_NOT_FOUND:
-                throw new ClientErrorException(tenantResult.getStatus(), "no such tenant");
-            default:
-                throw StatusCodeMapper.from(tenantResult);
-            }
-        }, currentSpan);
-    }
-
-    /**
-     * Customize AMQP application properties of the request by overwriting this method.
-     * @return The map that holds the properties to include in the AMQP 1.0 message, or null (if nothing is customized).
-     */
-    protected Map<String, Object> customizeRequestApplicationProperties() {
-        return null;
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/CommandResponseTest.java b/client/src/test/java/org/eclipse/hono/client/CommandResponseTest.java
deleted file mode 100644
index d0fe31d0b..000000000
--- a/client/src/test/java/org/eclipse/hono/client/CommandResponseTest.java
+++ /dev/null
@@ -1,367 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.junit.jupiter.api.Test;
-
-import io.vertx.proton.ProtonHelper;
-
-/**
- * Verifies behavior of {@link CommandResponse}.
- *
- */
-public class CommandResponseTest {
-
-    private static final String CORRELATION_ID = "the-correlation-id";
-    private static final String TENANT_ID = "tenant";
-    private static final String DEVICE_ID = "4711";
-    private static final String REPLY_TO_ID = "the-reply-to-id";
-    private static final String REPLY_TO_ID_WITH_DEVICE = DEVICE_ID + "/" + REPLY_TO_ID;
-
-    /**
-     * Verifies that a response can be created from a request ID.
-     */
-    @Test
-    public void testFromResponseSucceeds() {
-
-        final CommandResponse resp = CommandResponse.from(
-                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID, DEVICE_ID),
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK);
-        assertThat(resp).isNotNull();
-        assertThat(resp.toMessage()).isNotNull();
-        assertThat(resp.toMessage().getCorrelationId()).isEqualTo(CORRELATION_ID);
-        assertThat(resp.getReplyToId()).isEqualTo(REPLY_TO_ID);
-    }
-
-    /**
-     * Verifies that creating a response from a request ID which does not contain a hex encoded byte
-     * at the second position fails.
-     */
-    @Test
-    public void testFromFailsForRequestIdWithMalformedLengthPart() {
-
-        // make sure we succeed with a valid length string
-        final CommandResponse resp = CommandResponse.from(
-                "003anyString",
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK);
-        assertThat(resp).isNotNull();
-        assertThat(resp.toMessage()).isNotNull();
-        assertThat(resp.toMessage().getCorrelationId()).isEqualTo("any");
-        assertThat(resp.getReplyToId()).isEqualTo("String");
-
-        assertThat(CommandResponse.from("0ZZanyString", TENANT_ID, DEVICE_ID, null, null, HttpURLConnection.HTTP_OK))
-                .isNull();
-    }
-
-    /**
-     * Verifies that creating a response from a request ID which does not contain a single digit
-     * at the start position fails.
-     */
-    @Test
-    public void testFromFailsForRequestIdWithMalformedReplyIdOptionBitsPart() {
-
-        // make sure we succeed with a valid length string
-        final CommandResponse resp = CommandResponse.from(
-                "003anyString",
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK);
-        assertThat(resp).isNotNull();
-        assertThat(resp.toMessage()).isNotNull();
-        assertThat(resp.toMessage().getCorrelationId()).isEqualTo("any");
-        assertThat(resp.getReplyToId()).isEqualTo("String");
-
-        assertThat(CommandResponse.from("Z03anyString", TENANT_ID, DEVICE_ID, null, null, HttpURLConnection.HTTP_OK))
-                .isNull();
-    }
-
-    /**
-     * Verifies that creating a response for an invalid status code fails.
-     */
-    @Test
-    public void testFromFailsForInvalidStatusCode() {
-
-        // make sure we succeed with a valid status code
-        final CommandResponse resp = CommandResponse.from(
-                "103oneTwo", TENANT_ID, DEVICE_ID, null, null, 200);
-        assertThat(resp).isNotNull();
-        assertThat(resp.toMessage()).isNotNull();
-        assertThat(resp.toMessage().getCorrelationId()).isEqualTo("one");
-        assertThat(resp.getReplyToId()).isEqualTo(DEVICE_ID + "/Two");
-
-        assertThat(CommandResponse.from(
-                "103oneTwo", TENANT_ID, DEVICE_ID, null, null, 100)).isNull();
-        assertThat(CommandResponse.from(
-                "103oneTwo", TENANT_ID, DEVICE_ID, null, null, 310)).isNull();
-        assertThat(CommandResponse.from(
-                "103oneTwo", TENANT_ID, DEVICE_ID, null, null, 600)).isNull();
-        assertThat(CommandResponse.from(
-                "103oneTwo", TENANT_ID, DEVICE_ID, null, null, null)).isNull();
-    }
-
-    /**
-     * Verifies that creating a response from a request ID which contains less characters as indicated
-     * by the hex encoded byte at the start position fails.
-     */
-    @Test
-    public void testFromFailsForIncorrectCorrelationIdLength() {
-
-        final String id = "thisIsLessThan255Characters";
-        // make sure we succeed with valid length
-        final CommandResponse resp = CommandResponse.from(
-                String.format("0%02x%s", 4, id), TENANT_ID, DEVICE_ID, null, null, 200);
-        assertThat(resp).isNotNull();
-        assertThat(resp.toMessage()).isNotNull();
-        assertThat(resp.toMessage().getCorrelationId()).isEqualTo("this");
-        assertThat(resp.getReplyToId()).isEqualTo("IsLessThan255Characters");
-
-        assertThat(CommandResponse.from(
-                "1FFthisIsLessThan255Characters",
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK)).isNull();
-    }
-
-    /**
-     * Verifies that device-id is rendered into reply-to-id when the request-id
-     * starts with '1'.
-     */
-    @Test
-    public void testDeviceInReply() {
-        final CommandResponse resp = CommandResponse.from(
-                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID_WITH_DEVICE, DEVICE_ID),
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK);
-        assertThat(resp).isNotNull();
-        assertThat(resp.getReplyToId()).isEqualTo(REPLY_TO_ID_WITH_DEVICE);
-    }
-
-    /**
-     * Verifies that device-id is NOT rendered into reply-to-id when the request-id
-     * starts with a '0'.
-     */
-    @Test
-    public void testDeviceNotInReply() {
-        final CommandResponse resp = CommandResponse.from(
-                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID, DEVICE_ID),
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK);
-        assertThat(resp).isNotNull();
-        assertThat(resp.getReplyToId()).isEqualTo(REPLY_TO_ID);
-    }
-
-    /**
-     * Verifies that the device-id is part of the reply-to-id.
-     */
-    @Test
-    public void testForDeviceIdInReplyToId() {
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from("control", TENANT_ID, String.format("%s/%srid-1", DEVICE_ID, replyToOptionsBitFlag)).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNotNull();
-        assertThat(response.getReplyToId()).isEqualTo("4711/rid-1");
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with no correlation id.
-     */
-    @Test
-    public void testFromMessageFailsForMissingCorrelationId() {
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%srid-1", DEVICE_ID, replyToOptionsBitFlag)).toString());
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with no address set.
-     */
-    @Test
-    public void testFromMessageFailsForMissingAddress() {
-        final Message message = ProtonHelper.message();
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with no status property.
-     */
-    @Test
-    public void testFromMessageFailsForMissingStatus() {
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%srid-1", DEVICE_ID, replyToOptionsBitFlag)).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with status property containing an invalid value.
-     */
-    @Test
-    public void testFromMessageFailsForInvalidStatus() {
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%srid-1", DEVICE_ID, replyToOptionsBitFlag)).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, 777);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with an invalid address, containing nothing behind the
-     * device id part.
-     */
-    @Test
-    public void testFromMessageFailsForInvalidAddressWithNothingBehindDeviceId() {
-        final Message message = ProtonHelper.message();
-        // use address with an invalid resource id part (nothing behind the device id)
-        message.setAddress(ResourceIdentifier.from(getCommandResponseEndpoint(), TENANT_ID, DEVICE_ID).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with an invalid address, ending with the replyToOptions bit.
-     */
-    @Test
-    public void testFromMessageFailsForInvalidAddressWithOnlyReplyToOptionsBit() {
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%s", DEVICE_ID, replyToOptionsBitFlag)).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with an invalid address, containing an invalid
-     * replyToOptions bit.
-     */
-    @Test
-    public void testFromMessageFailsForInvalidAddressWithWrongReplyToOptionsBit() {
-        final String replyToOptionsBitFlag = "X"; // invalid value to test with
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%srid-1", DEVICE_ID, replyToOptionsBitFlag)).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that the device-id is not part of the CommandResponse replyToId.
-     */
-    @Test
-    public void testForNoDeviceIdInReplyToId() {
-        final boolean replyToContainedDeviceId = false;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%s%s", DEVICE_ID, replyToOptionsBitFlag, "rid-1")).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNotNull();
-        assertThat(response.getReplyToId()).isEqualTo("rid-1");
-    }
-
-    /**
-     * Verifies that creating a response fails for a message with an invalid address, having an empty id
-     * after the replyToOptions bit.
-     */
-    @Test
-    public void testFromMessageFailsForInvalidAddressWithEmptyReplyId() {
-        final boolean replyToContainedDeviceId = false;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Message message = ProtonHelper.message();
-        message.setAddress(ResourceIdentifier
-                .from(getCommandResponseEndpoint(), TENANT_ID, String.format("%s/%s%s", DEVICE_ID, replyToOptionsBitFlag, "")).toString());
-        message.setCorrelationId(CORRELATION_ID);
-        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        final CommandResponse response = CommandResponse.from(message);
-        assertThat(response).isNull();
-    }
-
-    /**
-     * Verifies that the tenant and device ids are present in the response message.
-     */
-    @Test
-    public void testForDeviceAndTenantIds() {
-        final CommandResponse response = CommandResponse.from(
-                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID, DEVICE_ID),
-                TENANT_ID,
-                DEVICE_ID,
-                null,
-                null,
-                HttpURLConnection.HTTP_OK);
-        assertThat(response).isNotNull();
-        assertThat(response.toMessage()).isNotNull();
-        assertThat(MessageHelper.getTenantId(response.toMessage())).isEqualTo(TENANT_ID);
-        assertThat(MessageHelper.getDeviceId(response.toMessage())).isEqualTo(DEVICE_ID);
-    }
-
-    private String getCommandResponseEndpoint() {
-        return CommandConstants.COMMAND_ENDPOINT;
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/CommandTest.java b/client/src/test/java/org/eclipse/hono/client/CommandTest.java
deleted file mode 100644
index 916004451..000000000
--- a/client/src/test/java/org/eclipse/hono/client/CommandTest.java
+++ /dev/null
@@ -1,411 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.qpid.proton.amqp.messaging.AmqpSequence;
-import org.apache.qpid.proton.amqp.messaging.AmqpValue;
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Section;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.junit.jupiter.api.Test;
-
-import io.vertx.proton.ProtonHelper;
-
-/**
- * Verifies behavior of {@link Command}.
- *
- */
-public class CommandTest {
-
-    /**
-     * Verifies that a command can be created from a valid message.
-     * Verifies that the replyToId are build up of all segments behind the tenant.
-     */
-    @Test
-    public void testFromMessageSucceeds() {
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-        message.setReplyTo(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getName()).isEqualTo("doThis");
-        assertThat(cmd.getDeviceId()).isEqualTo("4711");
-        assertThat(cmd.getOriginalDeviceId()).isEqualTo("4711");
-        assertThat(cmd.getReplyToId()).isEqualTo(String.format("4711/%s", replyToId));
-        assertThat(cmd.getReplyToEndpoint()).isEqualTo(CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT);
-        assertThat(cmd.getCorrelationId()).isEqualTo(correlationId);
-        assertFalse(cmd.isOneWay());
-        assertThat(cmd.getCommandMessage().getReplyTo()).isEqualTo(String.format("%s/%s/%s/%s%s",
-                CommandConstants.COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToOptionsBitFlag, replyToId));
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message, containing a message address with device id
-     * differing from the one given in the command constructor.
-     * Verifies that the replyToId are build up of all segments behind the tenant.
-     */
-    @Test
-    public void testFromMessageSucceedsWithDifferingDeviceId() {
-        final String gatewayId = "gw-1";
-        final String targetDeviceId = "4711";
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, targetDeviceId));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-        message.setReplyTo(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, targetDeviceId, replyToId));
-        final boolean replyToContainedDeviceId = true;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, gatewayId);
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getName()).isEqualTo("doThis");
-        assertThat(cmd.getDeviceId()).isEqualTo(gatewayId);
-        assertThat(cmd.getOriginalDeviceId()).isEqualTo(targetDeviceId);
-        assertThat(cmd.getReplyToId()).isEqualTo(String.format("%s/%s", targetDeviceId, replyToId));
-        assertThat(cmd.getReplyToEndpoint()).isEqualTo(CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT);
-        assertThat(cmd.getCorrelationId()).isEqualTo(correlationId);
-        assertFalse(cmd.isOneWay());
-        assertThat(cmd.getCommandMessage().getReplyTo()).isEqualTo(String.format("%s/%s/%s/%s%s",
-                CommandConstants.COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToOptionsBitFlag, replyToId));
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message having no device-id as part of the reply-to address.
-     * Verifies that the reply-to address contains the device-id and the reply-id is prefixed with flag 1.
-     */
-    @Test
-    public void testForReplyToWithoutDeviceId() {
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-        message.setReplyTo(String.format("%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, replyToId));
-        final boolean replyToContainedDeviceId = false;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getReplyToId()).isEqualTo(replyToId);
-        assertThat(cmd.getCommandMessage()).isNotNull();
-        assertThat(cmd.getCommandMessage().getReplyTo()).isNotNull();
-        assertThat(cmd.getCommandMessage().getReplyTo()).isEqualTo(String.format("%s/%s/%s/%s%s",
-                CommandConstants.COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToOptionsBitFlag, replyToId));
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message having device-id as part of the reply-to address.
-     * Verifies that the reply-to address contains the device-id and the reply-id is prefixed with flag 0.
-     */
-    @Test
-    public void testForReplyToWithDeviceId() {
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Message message = ProtonHelper.message("input data");
-        message.setAddress(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        message.setSubject("doThis");
-        message.setCorrelationId(correlationId);
-        message.setReplyTo(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(true);
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getReplyToId()).isEqualTo(String.format("4711/%s", replyToId));
-        assertThat(cmd.getCommandMessage()).isNotNull();
-        assertThat(cmd.getCommandMessage().getReplyTo()).isNotNull();
-        assertThat(cmd.getCommandMessage().getReplyTo()).isEqualTo(String.format("%s/%s/%s/%s%s",
-                CommandConstants.COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToOptionsBitFlag, replyToId));
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message that has an empty reply-to property.
-     * Verifies that the replyToId is {@code null} and the command reports that it is a one-way command.
-     */
-    @Test
-    public void testFromMessageSucceedsWithoutReplyTo() {
-        final String correlationId = "the-correlation-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn(correlationId);
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getName()).isEqualTo("doThis");
-        assertThat(cmd.getCorrelationId()).isEqualTo(correlationId);
-        assertThat(cmd.getReplyToId()).isNull();
-        assertTrue(cmd.isOneWay());
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message that has an empty reply-to property
-     * and no message-id and correlation-id properties.
-     * Verifies that the replyToId is {@code null} and the command reports that it is a one-way command.
-     */
-    @Test
-    public void testFromMessageSucceedsWithoutReplyToAndCorrelationId() {
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getSubject()).thenReturn("doThis");
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getName()).isEqualTo("doThis");
-        assertThat(cmd.getCorrelationId()).isNull();
-        assertThat(cmd.getReplyToId()).isNull();
-        assertTrue(cmd.isOneWay());
-    }
-
-    /**
-     * Verifies that a command can be created from a message with message id but no correlation id.
-     */
-    @Test
-    public void testFromMessageSucceedsWithMessageIdButNoCorrelationId() {
-        final String replyToId = "the-reply-to-id";
-        final String messageId = "the-message-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getApplicationProperties()).thenReturn(null);
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getMessageId()).thenReturn(messageId);
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getCorrelationId()).isEqualTo(messageId);
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message with application properties.
-     * Verifies that the application properties are able to be retrieved from the message.
-     */
-    @Test
-    public void testFromMessageSucceedsWithApplicationProperties() {
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Map<String, Object> applicationProperties = new HashMap<>();
-        applicationProperties.put("deviceId", "4711");
-        applicationProperties.put("tenantId", "DEFAULT_TENANT");
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getApplicationProperties()).thenReturn(new ApplicationProperties(applicationProperties));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn(correlationId);
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getApplicationProperties()).isNotNull();
-        assertThat(cmd.getApplicationProperties()).hasSize(2);
-        assertThat(cmd.getApplicationProperties().get("deviceId")).isEqualTo("4711");
-        assertThat(cmd.getApplicationProperties().get("tenantId")).isEqualTo("DEFAULT_TENANT");
-    }
-
-    /**
-     * Verifies that a command can be created from a valid message with no application properties is valid.
-     */
-    @Test
-    public void testFromMessageSucceedsWithNoApplicationProperties() {
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getApplicationProperties()).thenReturn(null);
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn(correlationId);
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertTrue(cmd.isValid());
-        assertThat(cmd.getApplicationProperties()).isNull();
-    }
-
-    /**
-     * Verifies that a command cannot be created from a message that has an unsupported body section.
-     */
-    @Test
-    public void testFromMessageFailsForUnsupportedMessageBody() {
-        final String replyToId = "the-reply-to-id";
-        final String correlationId = "the-correlation-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getApplicationProperties()).thenReturn(null);
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn(correlationId);
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-
-        Section body = new AmqpValue(5L);
-        when(message.getBody()).thenReturn(body);
-        Command command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("body");
-
-        body = new AmqpSequence(Collections.singletonList("test"));
-        when(message.getBody()).thenReturn(body);
-        command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("body");
-    }
-
-    /**
-     * Verifies that a command cannot be created from a message that neither
-     * contains a message nor correlation ID.
-     */
-    @Test
-    public void testFromMessageFailsForMissingCorrelationOrMessageId() {
-        final String replyToId = "the-reply-to-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
-        final Command command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("correlation-id");
-    }
-
-    /**
-     * Verifies that a command cannot be created from a message that contains
-     * a 'to' address without the device-id part.
-     */
-    @Test
-    public void testFromMessageFailsForMissingDeviceIdInAddress() {
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn("the-correlation-id");
-        final Command command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("address");
-    }
-
-    /**
-     * Verifies that a command cannot be created from a message that contains
-     * a 'to' address with the wrong tenant-id.
-     */
-    @Test
-    public void testFromMessageFailsForAddressWithWrongTenant() {
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, "other_tenant", "4711"));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn("the-correlation-id");
-        final Command command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("address");
-        assertThat(command.getInvalidCommandReason()).contains("other_tenant");
-    }
-
-    /**
-     * Verifies that a command cannot be created from a message that contains
-     * a reply-to address with the wrong tenant.
-     */
-    @Test
-    public void testFromMessageFailsForReplyToWithWrongTenant() {
-        final String correlationId = "the-correlation-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn(correlationId);
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, "wrong_tenant", "4711"));
-        final Command command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("reply-to");
-    }
-
-    /**
-     * Verifies that a command cannot be created from a message that contains
-     * a reply-to address without a reply id.
-     */
-    @Test
-    public void testFromMessageFailsForReplyToWithoutReplyId() {
-        final String correlationId = "the-correlation-id";
-        final Message message = mock(Message.class);
-        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
-        when(message.getSubject()).thenReturn("doThis");
-        when(message.getCorrelationId()).thenReturn(correlationId);
-        when(message.getReplyTo()).thenReturn(String.format("%s/%s",
-                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT));
-        final Command command = Command.from(message, Constants.DEFAULT_TENANT, "4712");
-        assertFalse(command.isValid());
-        assertThat(command.getInvalidCommandReason()).contains("reply-to");
-    }
-
-    /**
-     * Verifies the return value of getInvalidCommandReason().
-     */
-    @Test
-    public void testGetInvalidCommandReason() {
-        final Message message = mock(Message.class);
-        when(message.getReplyTo()).thenReturn("invalid-reply-to");
-        final Command command = Command.from(message, Constants.DEFAULT_TENANT, "4712");
-        assertFalse(command.isValid());
-        // verify the returned validation error contains all missing fields
-        assertThat(command.getInvalidCommandReason()).contains("address");
-        assertThat(command.getInvalidCommandReason()).contains("subject");
-        assertThat(command.getInvalidCommandReason()).contains("correlation-id");
-        assertThat(command.getInvalidCommandReason()).contains("reply-to");
-    }
-
-    /**
-     * Verifies the correct encoding and decoding of the bit flag with options relating to the reply-to address.
-     */
-    @Test
-    public void testEncodeDecodeReplyToOptions() {
-        final boolean replyToContainedDeviceId = false;
-        final String replyToOptionsBitFlag = Command.encodeReplyToOptions(replyToContainedDeviceId);
-        assertThat(Command.isReplyToContainedDeviceIdOptionSet(replyToOptionsBitFlag)).isEqualTo(replyToContainedDeviceId);
-
-        final boolean replyToContainedDeviceId2 = true;
-        final String replyToOptions2 = Command.encodeReplyToOptions(replyToContainedDeviceId2);
-        assertThat(Command.isReplyToContainedDeviceIdOptionSet(replyToOptions2)).isEqualTo(replyToContainedDeviceId2);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
deleted file mode 100644
index 62e6e9361..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.message.Message;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.junit5.Timeout;
-import io.vertx.junit5.VertxExtension;
-
-
-/**
- * Tests verifying behavior of {@link AbstractHonoClient}.
- *
- */
-@ExtendWith(VertxExtension.class)
-@Timeout(value = 5, timeUnit = TimeUnit.SECONDS)
-public class AbstractHonoClientTest {
-
-    /**
-     * Verifies that the given application properties are propagated to
-     * the message.
-     */
-    @Test
-    public void testApplicationPropertiesAreSetAtTheMessage() {
-
-        final Message msg = mock(Message.class);
-        final Map<String, Object> applicationProps = new HashMap<>();
-        applicationProps.put("string-key", "value");
-        applicationProps.put("int-key", 15);
-        applicationProps.put("long-key", 1000L);
-
-        final ArgumentCaptor<ApplicationProperties> applicationPropsCaptor = ArgumentCaptor.forClass(ApplicationProperties.class);
-
-        AbstractHonoClient.setApplicationProperties(msg, applicationProps);
-
-        verify(msg).setApplicationProperties(applicationPropsCaptor.capture());
-        assertThat(applicationPropsCaptor.getValue().getValue()).isEqualTo(applicationProps);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
deleted file mode 100644
index c1538a84a..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
+++ /dev/null
@@ -1,558 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.function.Consumer;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Data;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
-import org.apache.qpid.proton.amqp.transport.Target;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.cache.ExpiringValueCache;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.ResourceLimitExceededException;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.MessageHelper;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.core.json.JsonObject;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-
-/**
- * Tests verifying behavior of {@link AbstractRequestResponseClient}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class AbstractRequestResponseClientTest  {
-
-    private static final String MESSAGE_ID = "messageid";
-
-    private AbstractRequestResponseClient<SimpleRequestResponseResult> client;
-    private ExpiringValueCache<Object, SimpleRequestResponseResult> cache;
-    private Vertx vertx;
-    private ProtonReceiver receiver;
-    private ProtonSender sender;
-    private Span span;
-
-    /**
-     * Sets up the fixture.
-     */
-    @SuppressWarnings("unchecked")
-    @BeforeEach
-    public void setUp() {
-
-        span = TracingMockSupport.mockSpan();
-
-        vertx = mock(Vertx.class);
-        receiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-
-        final Target target = mock(Target.class);
-        when(target.getAddress()).thenReturn("peer/tenant");
-
-        when(sender.getCredit()).thenReturn(10);
-        when(sender.getRemoteTarget()).thenReturn(target);
-
-        cache = mock(ExpiringValueCache.class);
-
-        client = getClient("tenant", sender, receiver);
-        // do not time out requests by default
-        client.setRequestTimeout(0);
-    }
-
-    /**
-     * Verifies that the client fails the handler for sending a request message
-     * with a {@link ServerErrorException} if the link to the peer has no credit left.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestFailsWithServerErrorExceptionIfSendQueueFull(final VertxTestContext ctx) {
-
-        // GIVEN a request-response client with a full send queue
-        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
-
-        // WHEN sending a request message
-        client.createAndSendRequest(
-                "get",
-                Buffer.buffer("hello"),
-                ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the message is not sent
-                        verify(sender, never()).send(any(Message.class));
-                        // and the request result handler is failed with a 503
-                        assertFailureCause(span, t, HttpURLConnection.HTTP_UNAVAILABLE);
-                    });
-                    ctx.completeNow();
-                }),
-                span);
-    }
-
-    /**
-     * Verifies that the client creates and sends a message based on provided headers and payload
-     * and sets a timer for canceling the request if no response is received.
-     */
-    @Test
-    public void testCreateAndSendRequestSendsProperRequestMessage() {
-
-        // GIVEN a request-response client that times out requests after 200 ms
-        client.setRequestTimeout(200);
-
-        // WHEN sending a request message with some headers and payload
-        final JsonObject payload = new JsonObject().put("key", "value");
-        final Map<String, Object> props = Collections.singletonMap("test-key", "test-value");
-        client.createAndSendRequest("get", props, payload.toBuffer(), s -> {});
-
-        // THEN the message is sent and the message being sent contains the headers as application properties
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        assertThat(messageCaptor.getValue()).isNotNull();
-        assertThat(messageCaptor.getValue().getBody()).isNotNull();
-        assertThat(messageCaptor.getValue().getBody()).isInstanceOf(Data.class);
-        final Buffer body = MessageHelper.getPayload(messageCaptor.getValue());
-        assertThat(body.getBytes()).isEqualTo(payload.toBuffer().getBytes());
-        assertThat(messageCaptor.getValue().getApplicationProperties()).isNotNull();
-        assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("test-key")).isEqualTo("test-value");
-        // and a timer has been set to time out the request after 200 ms
-        verify(vertx).setTimer(eq(200L), VertxMockSupport.anyHandler());
-    }
-
-    /**
-     * Verifies that the sender fails with an 503 error code if the peer rejects
-     * a message with an "amqp:resource-limit-exceeded" error.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestFailsForResourceLimitExceeded(final VertxTestContext ctx) {
-        testCreateAndSendRequestFailsOnRejectedMessage(
-                ctx,
-                AmqpError.RESOURCE_LIMIT_EXCEEDED,
-                t -> {
-                    assertThat(t).isInstanceOf(ResourceLimitExceededException.class);
-                    assertThat(((ResourceLimitExceededException) t).getClientFacingMessage()).isNotEmpty();
-                });
-    }
-
-    /**
-     * Verifies that the sender fails with an 400 error code if the peer rejects
-     * a message with an arbitrary error condition.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestFailsForArbitraryError(final VertxTestContext ctx) {
-        testCreateAndSendRequestFailsOnRejectedMessage(
-                ctx,
-                Symbol.getSymbol("arbitrary-error"),
-                t -> {
-                    assertThat(t).isInstanceOf(ClientErrorException.class);
-                    assertThat(((ClientErrorException) t).getErrorCode())
-                            .isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                });
-    }
-
-    private void testCreateAndSendRequestFailsOnRejectedMessage(
-            final VertxTestContext ctx,
-            final Symbol errorCondition,
-            final Consumer<Throwable> failureAssertions) {
-
-        // GIVEN a request-response client that times out requests after 200 ms
-        client.setRequestTimeout(200);
-
-        // WHEN sending a request message with some headers and payload
-        final JsonObject payload = new JsonObject().put("key", "value");
-        client.createAndSendRequest(
-                "get",
-                payload.toBuffer(),
-                ctx.failing(t -> {
-                    ctx.verify(() -> {
-                        // THEN the result handler is failed with the expected error
-                        failureAssertions.accept(t);
-                    });
-                    ctx.completeNow();
-                }),
-                span);
-        // and the peer rejects the message
-        final Rejected rejected = new Rejected();
-        rejected.setError(ProtonHelper.condition(errorCondition, "request message cannot be processed"));
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        when(delivery.getRemoteState()).thenReturn(rejected);
-        @SuppressWarnings("unchecked")
-        final ArgumentCaptor<Handler<ProtonDelivery>> dispositionHandlerCaptor = ArgumentCaptor.forClass(Handler.class);
-        verify(sender).send(any(Message.class), dispositionHandlerCaptor.capture());
-        dispositionHandlerCaptor.getValue().handle(delivery);
-    }
-
-    /**
-     * Verifies that the client passes a response message to the handler registered for the request that
-     * the response correlates with.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testHandleResponseInvokesHandlerForMatchingCorrelationId(final VertxTestContext ctx) {
-
-        // GIVEN a request message that has been sent to a peer
-        client.createAndSendRequest(
-                "request",
-                Buffer.buffer("hello"),
-                ctx.succeeding(s -> {
-                    // THEN the response is passed to the handler registered with the request
-                    assertEquals(200, s.getStatus());
-                    assertEquals("payload", s.getPayload().toString());
-                    // and no response time-out handler has been set
-                    verify(vertx, never()).setTimer(anyLong(), VertxMockSupport.anyHandler());
-                    ctx.completeNow();
-                }),
-                span);
-
-        // WHEN a response is received for the request
-        final Message response = ProtonHelper.message("payload");
-        response.setCorrelationId(MESSAGE_ID);
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, 200);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that the client cancels and fails a request for which no response
-     * has been received after a certain amount of time. The request is then
-     * failed with a {@link ServerErrorException} with a 503 status code.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCancelRequestFailsResponseHandler(final VertxTestContext ctx) {
-
-        // GIVEN a request-response client which times out requests after 200 ms
-        client.setRequestTimeout(200);
-
-        // WHEN no response is received for a request sent to the peer
-        doAnswer(invocation -> {
-            // do not wait 200ms before running the timeout task but instead
-            // run it immediately
-            final Handler<Long> task = invocation.getArgument(1);
-            task.handle(1L);
-            return null;
-        }).when(vertx).setTimer(anyLong(), VertxMockSupport.anyHandler());
-
-        client.createAndSendRequest(
-                "request",
-                Buffer.buffer("hello"),
-                ctx.failing(t -> {
-                    // THEN the request handler is failed
-                    assertEquals(
-                            HttpURLConnection.HTTP_UNAVAILABLE,
-                            ((ServerErrorException) t).getErrorCode());
-                    verify(span, never()).finish();
-                    ctx.completeNow();
-                }),
-                span);
-    }
-
-    /**
-     * Verifies that a response handler is immediately failed with a
-     * {@link ServerErrorException} when the sender link is not open (yet).
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestFailsIfSenderIsNotOpen(final VertxTestContext ctx) {
-
-        // GIVEN a client whose sender is not open
-        when(sender.isOpen()).thenReturn(Boolean.FALSE);
-
-        // WHEN sending a request
-        client.createAndSendRequest(
-                "get",
-                Buffer.buffer("hello"),
-                ctx.failing(t -> {
-                    // THEN the request fails immediately with a 503
-                    ctx.verify(() -> {
-                        verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-                        assertFailureCause(span, t, HttpURLConnection.HTTP_UNAVAILABLE);
-                    });
-                    ctx.completeNow();
-                }),
-                span);
-    }
-
-    /**
-     * Verifies that a response handler is immediately failed with a
-     * {@link ServerErrorException} when the receiver link is not open (yet).
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestFailsIfReceiverIsNotOpen(final VertxTestContext ctx) {
-
-        // GIVEN a client whose receiver is not open
-        when(receiver.isOpen()).thenReturn(Boolean.FALSE);
-
-        // WHEN sending a request
-        client.createAndSendRequest("get", null, ctx.failing(t -> {
-            // THEN the request fails immediately
-            assertTrue(ServerErrorException.class.isInstance(t));
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the adapter puts the response from the service to the cache
-     * using the default cache timeout if the response does not contain a
-     * <em>no-cache</em> cache directive.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestAddsResponseToCache(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-
-        // WHEN sending a request
-        client.createAndSendRequest("get", (Buffer) null, ctx.succeeding(result -> {
-            assertEquals(200, result.getStatus());
-            // THEN the response has been put to the cache
-            verify(cache).put(eq("cacheKey"), any(SimpleRequestResponseResult.class),
-                    eq(Duration.ofSeconds(RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT)));
-            ctx.completeNow();
-        }), "cacheKey");
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message("result");
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that the adapter puts the response from the service to the cache
-     * using the max age indicated by a response's <em>max-age</em> cache directive.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestAddsResponseToCacheWithMaxAge(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-
-        // WHEN sending a request
-        client.createAndSendRequest("get", (Buffer) null, ctx.succeeding(result -> {
-            assertEquals(200, result.getStatus());
-            // THEN the response has been put to the cache
-            verify(cache).put(eq("cacheKey"), any(SimpleRequestResponseResult.class), eq(Duration.ofSeconds(35)));
-            ctx.completeNow();
-        }), "cacheKey");
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message("result");
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(35));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that the adapter does not put the response from the service to the cache
-     * if the response contains a <em>no-cache</em> cache directive.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestDoesNotAddResponseToCache(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-
-        // WHEN sending a request
-        client.createAndSendRequest("get", (Buffer) null, ctx.succeeding(result -> {
-            assertEquals(200, result.getStatus());
-            // THEN the response is not put to the cache
-            verify(cache, never()).put(eq("cacheKey"), any(SimpleRequestResponseResult.class), any(Duration.class));
-            ctx.completeNow();
-        }), "cacheKey");
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message("result");
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.noCacheDirective());
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that the adapter does not put a response from the service to the cache
-     * that does not contain any cache directive but has a <em>non-cacheable</em> status code.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateAndSendRequestDoesNotAddNonCacheableResponseToCache(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-
-        // WHEN getting a 404 response to a request which contains
-        // no cache directive
-        client.createAndSendRequest("get", (Buffer) null, ctx.succeeding(result -> {
-            // THEN the response is not put to the cache
-            verify(cache, never()).put(eq("cacheKey"), any(SimpleRequestResponseResult.class), any(Duration.class));
-            ctx.completeNow();
-        }), "cacheKey");
-
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message();
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NOT_FOUND);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that the client succeeds the result handler if the peer accepts
-     * the request message for a one-way request.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testSendOneWayRequestSucceedsOnAcceptedMessage(final VertxTestContext ctx) {
-
-        // GIVEN a request-response client that times out requests after 200 ms
-        client.setRequestTimeout(200);
-
-        // WHEN sending a one-way request message with some headers and payload
-        final JsonObject payload = new JsonObject().put("key", "value");
-        final Map<String, Object> applicationProps = new HashMap<>();
-
-        final Message request = ProtonHelper.message();
-        request.setMessageId("12345");
-        request.setCorrelationId("23456");
-        request.setSubject("aRequest");
-        request.setApplicationProperties(new ApplicationProperties(applicationProps));
-        MessageHelper.setPayload(request, "application/json", payload.toBuffer());
-
-        final Span span = TracingMockSupport.mockSpan();
-
-        client.sendRequest(request, ctx.succeeding(t -> {
-            // THEN the result handler is succeeded
-            ctx.completeNow();
-        }), null, span);
-        // and the peer accepts the message
-        final Accepted accepted = new Accepted();
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        when(delivery.getRemoteState()).thenReturn(accepted);
-        @SuppressWarnings("unchecked")
-        final ArgumentCaptor<Handler<ProtonDelivery>> dispositionHandlerCaptor = ArgumentCaptor.forClass(Handler.class);
-        verify(sender).send(any(Message.class), dispositionHandlerCaptor.capture());
-        dispositionHandlerCaptor.getValue().handle(delivery);
-    }
-
-    /**
-     * Verifies credits available.
-     *
-     */
-    @Test
-    public void testGetCreditsReturnsCreditsOfSenderLink() {
-        when(sender.getCredit()).thenReturn(10, 0);
-        assertThat(client.getCredit()).isEqualTo(10);
-        assertThat(client.getCredit()).isEqualTo(0);
-    }
-
-    private AbstractRequestResponseClient<SimpleRequestResponseResult> getClient(final String tenant, final ProtonSender sender, final ProtonReceiver receiver) {
-
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);
-        return new AbstractRequestResponseClient<SimpleRequestResponseResult>(connection, tenant, sender, receiver, SendMessageSampler.noop()) {
-
-            @Override
-            protected String getName() {
-                return "peer";
-            }
-
-            @Override
-            protected String createMessageId() {
-                return MESSAGE_ID;
-            }
-
-            @Override
-            protected SimpleRequestResponseResult getResult(
-                    final int status,
-                    final String contentType,
-                    final Buffer payload,
-                    final CacheDirective cacheDirective,
-                    final ApplicationProperties applicationProperties) {
-                return SimpleRequestResponseResult.from(status, payload, cacheDirective, applicationProperties);
-            }
-        };
-    }
-
-    private void assertFailureCause(
-            final Span span,
-            final Throwable cause,
-            final int expectedErrorCode) {
-
-        assertEquals(
-                expectedErrorCode,
-                ((ServiceInvocationException) cause).getErrorCode());
-        verify(span, never()).finish();
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
deleted file mode 100644
index f29867582..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
+++ /dev/null
@@ -1,199 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.MessageHelper;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.vertx.core.Future;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-
-/**
- * Tests verifying behavior of {@code AbstractSender}.
- *
- */
-public class AbstractSenderTest {
-
-    private ProtonSender protonSender;
-    private Vertx vertx;
-
-    /**
-     * Sets up the fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-        protonSender = HonoClientUnitTestHelper.mockProtonSender();
-        vertx = mock(Vertx.class);
-    }
-
-    /**
-     * Verifies that the sender removes the registration assertion
-     * from a message if the peer does not support validation of
-     * assertions.
-     */
-    @Test
-    public void testSendMessageRemovesRegistrationAssertion() {
-
-        // GIVEN a sender that is connected to a peer which does not
-        // support validation of registration assertions
-        when(protonSender.getRemoteOfferedCapabilities()).thenReturn(null);
-        when(protonSender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(mock(ProtonDelivery.class));
-        final AbstractSender sender = newSender("tenant", "endpoint");
-
-        // WHEN sending a message
-        final Message msg = ProtonHelper.message("some payload");
-        msg.setContentType("application/text");
-        MessageHelper.addDeviceId(msg, "device");
-        sender.send(msg);
-
-        // THEN the message is sent without the registration assertion
-        final ArgumentCaptor<Message> sentMessage = ArgumentCaptor.forClass(Message.class);
-        verify(protonSender).send(sentMessage.capture());
-        assertNull(MessageHelper.getAndRemoveRegistrationAssertion(sentMessage.getValue()));
-    }
-
-    /**
-     * Verifies that the sender fails if no credit is available.
-     */
-    @Test
-    public void testSendMessageFailsOnLackOfCredit() {
-
-        // GIVEN a sender that has no credit
-        when(protonSender.sendQueueFull()).thenReturn(Boolean.TRUE);
-        final AbstractSender sender = newSender("tenant", "endpoint");
-
-        // WHEN trying to send a message
-        final Message msg = ProtonHelper.message("test");
-        final Future<ProtonDelivery> result = sender.send(msg);
-
-        // THEN the message is not sent
-        assertFalse(result.succeeded());
-        verify(protonSender, never()).send(any(Message.class));
-    }
-
-    /**
-     * Verifies that the sender fails if a timeout occurs.
-     */
-    @Test
-    public void testSendMessageFailsOnTimeout() {
-
-        // GIVEN a sender that won't receive a delivery update on sending a message 
-        // and directly triggers the timeout handler
-        when(protonSender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(mock(ProtonDelivery.class));
-        VertxMockSupport.runTimersImmediately(vertx);
-        final AbstractSender sender = newSender("tenant", "endpoint");
-
-        // WHEN sending a message
-        final Message message = mock(Message.class);
-        final Span span = mock(Span.class);
-        final Future<ProtonDelivery> result = sender.sendMessageAndWaitForOutcome(message, span);
-
-        // THEN the returned result future will fail with a 503 status code.
-        assertFalse(result.succeeded());
-        assertTrue(result.cause() instanceof ServerErrorException);
-        assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) result.cause()).getErrorCode());
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies credits available.
-     *
-     */
-    @Test
-    public void testCredits() {
-        final AbstractSender sender = newSender("tenant", "endpoint");
-        when(protonSender.getCredit()).thenReturn(10);
-        assertThat(sender.getCredit()).isEqualTo(10);
-        when(protonSender.getCredit()).thenReturn(0);
-        assertThat(sender.getCredit()).isEqualTo(0);
-    }
-
-    private AbstractSender newSender(final String tenantId, final String targetAddress) {
-
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);
-        return new AbstractSender(
-                connection,
-                protonSender,
-                tenantId,
-                targetAddress,
-                SendMessageSampler.noop()) {
-
-            @Override
-            public String getEndpoint() {
-                return null;
-            }
-
-            @Override
-            protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
-                protonSender.send(message);
-                return Future.succeededFuture(mock(ProtonDelivery.class));
-            }
-
-            /**
-             * @return an incomplete future.
-             */
-            @Override
-            public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
-                protonSender.send(message);
-                final Promise<ProtonDelivery> result = Promise.promise();
-                return result.future();
-            }
-
-            @Override
-            public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext context) {
-                protonSender.send(message);
-                return null;
-            }
-
-            @Override
-            protected String getTo(final String deviceId) {
-                return null;
-            }
-
-            @Override
-            protected Span startSpan(final SpanContext context, final Message rawMessage) {
-                return TracingMockSupport.mockSpan();
-            }
-        };
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java
deleted file mode 100644
index 6adc844c6..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandClientImplTest.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.Constants;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.core.Vertx;
-import io.vertx.core.buffer.Buffer;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * Tests verifying behavior of {@link CommandClientImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class CommandClientImplTest {
-
-    private static final String DEVICE_ID = "device";
-    private static final String REPLY_ID = "very-unique";
-
-    private Vertx vertx;
-    private ProtonSender sender;
-    private ProtonReceiver receiver;
-    private CommandClientImpl client;
-
-    /**
-     * Sets up the fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-
-        vertx = mock(Vertx.class);
-        receiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-        final ClientConfigProperties config = new RequestResponseClientConfigProperties();
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config);
-        client = new CommandClientImpl(
-                connection,
-                Constants.DEFAULT_TENANT,
-                REPLY_ID,
-                sender,
-                receiver,
-                SendMessageSampler.noop());
-    }
-
-    /**
-     * Verifies that a command sent has its properties set correctly.
-     *
-     * <ul>
-     * <li>subject set to given command</li>
-     * <li>message-id not null</li>
-     * <li>content-type set to given type</li>
-     * <li>reply-to address set to default address created from device and UUID</li>
-     * </ul>
-     */
-    @Test
-    public void testSendCommandSetsProperties() {
-        final Map<String, Object> applicationProperties = new HashMap<>();
-        applicationProperties.put("appKey", "appValue");
-
-        client.sendCommand(DEVICE_ID, "doSomething", "text/plain", Buffer.buffer("payload"), applicationProperties);
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        assertThat(messageCaptor.getValue().getSubject()).isEqualTo("doSomething");
-        assertNotNull(messageCaptor.getValue().getMessageId());
-        assertThat(messageCaptor.getValue().getContentType()).isEqualTo("text/plain");
-        assertThat(messageCaptor.getValue().getReplyTo()).isEqualTo(
-                String.format("%s/%s/%s", client.getReplyToEndpointName(), Constants.DEFAULT_TENANT, REPLY_ID));
-        assertNotNull(messageCaptor.getValue().getApplicationProperties());
-        assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("appKey")).isEqualTo("appValue");
-    }
-
-    /**
-     * Verifies that a one-way command sends a message with an empty reply-to property.
-     *
-     * <ul>
-     * <li>subject set to given command</li>
-     * <li>message-id not null</li>
-     * <li>content-type set to given type</li>
-     * <li>reply-to address set to {@code null}</li>
-     * <li>correlationId set to a UUID</li>
-     * </ul>
-     */
-    @Test
-    public void testSendOneWayCommandSetsCorrelationIdAndEmptyReplyTo() {
-        final Map<String, Object> applicationProperties = new HashMap<>();
-        applicationProperties.put("appKey", "appValue");
-
-        client.sendOneWayCommand(DEVICE_ID, "doSomething", "text/plain", Buffer.buffer("payload"), applicationProperties);
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        assertThat(messageCaptor.getValue().getSubject()).isEqualTo("doSomething");
-        assertNotNull(messageCaptor.getValue().getMessageId());
-        assertThat(messageCaptor.getValue().getContentType()).isEqualTo("text/plain");
-        assertNull(messageCaptor.getValue().getReplyTo());
-        assertNotNull(messageCaptor.getValue().getApplicationProperties());
-        assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("appKey")).isEqualTo("appValue");
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImplTest.java
deleted file mode 100644
index f274a9c2e..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImplTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.client.CredentialsClient;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-
-import io.vertx.core.Future;
-
-/**
- * Tests verifying the behavior of {@link CredentialsClientFactoryImpl}.
- */
-public class CredentialsClientFactoryImplTest extends AbstractTenantTimeoutRelatedClientFactoryTest<CredentialsClient> {
-
-    @Override
-    protected Future<CredentialsClient> getClientFuture(final HonoConnection connection, final String tenantId) {
-        return new CredentialsClientFactoryImpl(connection, null, SendMessageSampler.Factory.noop())
-                .getOrCreateCredentialsClient(tenantId);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
deleted file mode 100644
index c61e87ce3..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
+++ /dev/null
@@ -1,277 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.cache.ExpiringValueCache;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.CredentialsConstants;
-import org.eclipse.hono.util.CredentialsObject;
-import org.eclipse.hono.util.CredentialsResult;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RequestResponseApiConstants;
-import org.eclipse.hono.util.TriTuple;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.core.json.JsonObject;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-/**
- * Tests verifying behavior of {@link CredentialsClientImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class CredentialsClientImplTest {
-
-    private ProtonSender sender;
-    private CredentialsClientImpl client;
-    private ExpiringValueCache<Object, CredentialsResult<CredentialsObject>> cache;
-    private Span span;
-
-    /**
-     * Sets up the fixture.
-     */
-    @SuppressWarnings("unchecked")
-    @BeforeEach
-    public void setUp() {
-
-        span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class),
-                new RequestResponseClientConfigProperties(), tracer);
-
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-        cache = mock(ExpiringValueCache.class);
-        client = new CredentialsClientImpl(connection, "tenant", sender, HonoClientUnitTestHelper.mockProtonReceiver(), SendMessageSampler.noop());
-    }
-
-    /**
-     * Verifies that the client retrieves credentials from the Device Registration service if no cache is configured.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testGetCredentialsInvokesServiceIfNoCacheConfigured(final VertxTestContext ctx) {
-
-        final String authId = "test-auth";
-        final String credentialsType = CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD;
-        final JsonObject credentialsObject = newCredentialsResult("device", authId);
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, credentialsObject.toBuffer());
-
-        // WHEN getting credential information information
-        final Future<CredentialsObject> getFuture = client.get(credentialsType, authId);
-
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        final Message sentMessage = messageCaptor.getValue();
-
-        getFuture.onComplete(ctx.succeeding(credentials -> {
-            ctx.verify(() -> {
-                // THEN the credentials has been retrieved from the service
-                assertNotNull(credentials);
-                assertEquals("device", credentials.getDeviceId());
-                // and not been put to the cache
-                verify(cache, never()).put(any(), any(CredentialsResult.class), any(Duration.class));
-                // and the span is finished
-                verify(span).finish();
-
-                assertEquals(sentMessage.getSubject(), CredentialsConstants.CredentialsAction.get.toString());
-                assertEquals(MessageHelper.getJsonPayload(sentMessage).getString(CredentialsConstants.FIELD_TYPE),
-                        credentialsType);
-                assertEquals(MessageHelper.getJsonPayload(sentMessage).getString(CredentialsConstants.FIELD_AUTH_ID), authId);
-            });
-            ctx.completeNow();
-        }));
-
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that on a cache miss the adapter retrieves credentials information from the credentials service and puts
-     * it to the cache.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testGetCredentialsAddsResponseToCacheOnCacheMiss(final VertxTestContext ctx) {
-
-        final String authId = "test-auth";
-        final String credentialsType = CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD;
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-        final JsonObject credentialsObject = newCredentialsResult("device", authId);
-        final JsonObject clientContext = new JsonObject();
-
-        // WHEN getting credentials information
-        client.get(credentialsType, authId, clientContext)
-                .onComplete(ctx.succeeding(credentials -> {
-                    ctx.verify(() -> {
-                        assertNotNull(credentials);
-                        assertEquals("device", credentials.getDeviceId());
-                        // THEN the credentials result has been added to the cache.
-                        verify(cache).put(
-                                eq(TriTuple.of(CredentialsConstants.CredentialsAction.get,
-                                        String.format("%s-%s", credentialsType, authId), clientContext.hashCode())),
-                                any(CredentialsResult.class), any(Duration.class));
-                        // and the span is finished
-                        verify(span).finish();
-                    });
-                    ctx.completeNow();
-                }));
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        verify(client.sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, credentialsObject.toBuffer());
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that credentials is taken from cache, if cache is configured and the cache has this credentials cached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetCredentialsReturnsValueFromCache(final VertxTestContext ctx) {
-
-        final String authId = "test-auth";
-        final String credentialsType = CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD;
-
-        // GIVEN a client with a cache containing a credentials
-        client.setResponseCache(cache);
-        final JsonObject credentialsObject = newCredentialsResult("device", authId);
-        final CredentialsResult<CredentialsObject> credentialsResult = client
-                .getResult(HttpURLConnection.HTTP_OK, RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
-                        credentialsObject.toBuffer(), null, null);
-        when(cache.get(any(TriTuple.class))).thenReturn(credentialsResult);
-
-        // WHEN getting credentials
-        client.get(credentialsType, authId)
-                .onComplete(ctx.succeeding(result -> {
-                    // THEN the credentials is read from the cache
-                    assertEquals(credentialsResult.getPayload(), result);
-                    verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-                    // and the span is finished
-                    verify(span).finish();
-                    ctx.completeNow();
-                }));
-
-    }
-
-    /**
-     * Verifies that the client fails if the credentials service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetCredentialsFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN getting credentials
-        client.get(CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD, "test-auth")
-                .onComplete(ctx.failing(t -> {
-                    // THEN the invocation fails and the span is marked as erroneous
-                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                    // and the span is finished
-                    verify(span).finish();
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that the client fails if the credentials service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetCredentialsFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN getting credentials
-        client.get(CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD, "test-auth")
-                .onComplete(ctx.failing(t -> {
-                    assertEquals(HttpURLConnection.HTTP_BAD_REQUEST,
-                            ((ServiceInvocationException) t).getErrorCode());
-                    // THEN the invocation fails and the span is marked as erroneous
-                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                    // and the span is finished
-                    verify(span).finish();
-                    ctx.completeNow();
-                }));
-    }
-
-    private JsonObject newCredentialsResult(final String deviceId, final String authId) {
-        return JsonObject.mapFrom(CredentialsObject.fromHashedPassword(
-                deviceId,
-                authId,
-                "$2a$11$gYh52ApJeJcLvKrXHkGm5.xtLf7PVJySmXrt0EvFfLjCfLdIdvoay",
-                CredentialsConstants.HASH_FUNCTION_BCRYPT,
-                null, null, null));
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplEventTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplEventTest.java
deleted file mode 100644
index 4b9e6a644..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplEventTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-
-import io.vertx.core.Future;
-
-/**
- * Tests verifying the event related behavior of {@link DownstreamSenderFactoryImpl}.
- */
-public class DownstreamSenderFactoryImplEventTest
-        extends AbstractTenantTimeoutRelatedClientFactoryTest<DownstreamSender> {
-
-    @Override
-    protected Future<DownstreamSender> getClientFuture(final HonoConnection connection, final String tenantId) {
-        return new DownstreamSenderFactoryImpl(connection, SendMessageSampler.Factory.noop()).getOrCreateEventSender(tenantId);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTelemetryTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTelemetryTest.java
deleted file mode 100644
index 7d9d25a94..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTelemetryTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-
-import io.vertx.core.Future;
-
-/**
- * Tests verifying the telemetry related behavior of {@link DownstreamSenderFactoryImpl}.
- */
-public class DownstreamSenderFactoryImplTelemetryTest
-        extends AbstractTenantTimeoutRelatedClientFactoryTest<DownstreamSender> {
-
-    @Override
-    protected Future<DownstreamSender> getClientFuture(final HonoConnection connection, final String tenantId) {
-        return new DownstreamSenderFactoryImpl(connection, SendMessageSampler.Factory.noop()).getOrCreateTelemetrySender(tenantId);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
deleted file mode 100644
index 1de55c50d..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.notNull;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.core.Future;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-import io.vertx.core.eventbus.EventBus;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonSender;
-
-
-/**
- * Tests verifying behavior of {@link DownstreamSenderFactoryImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class DownstreamSenderFactoryImplTest {
-
-    private Vertx vertx;
-    private HonoConnection connection;
-    private DownstreamSenderFactoryImpl factory;
-
-    /**
-     * Sets up the fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-        vertx = mock(Vertx.class);
-        VertxMockSupport.runTimersImmediately(vertx);
-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);
-        when(connection.isConnected()).thenReturn(Future.succeededFuture());
-        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
-        when(vertx.eventBus()).thenReturn(mock(EventBus.class));
-        factory = new DownstreamSenderFactoryImpl(connection, SendMessageSampler.Factory.noop());
-    }
-
-    /**
-     * Verifies that a concurrent request to create a sender fails the given future for tracking the attempt if the
-     * initial request doesn't complete.
-     *
-     * @param ctx The helper to use for running async tests.
-     */
-    @Test
-    public void testGetTelemetrySenderFailsIfInvokedConcurrently(final VertxTestContext ctx) {
-
-        // GIVEN a factory that already tries to create a telemetry sender for "tenant" (and never completes doing so)
-        final Promise<ProtonSender> sender = Promise.promise();
-        when(connection.createSender(anyString(), any(ProtonQoS.class), VertxMockSupport.anyHandler()))
-        .thenReturn(sender.future());
-        final Future<DownstreamSender> result = factory.getOrCreateTelemetrySender("telemetry/tenant");
-        assertThat(result.isComplete()).isFalse();
-
-        // WHEN an additional, concurrent attempt is made to create a telemetry sender for "tenant"
-        factory.getOrCreateTelemetrySender("telemetry/tenant").onComplete(ctx.failing(t -> {
-            // THEN the concurrent attempt fails after having done the default number of retries.
-            ctx.verify(() -> {
-                assertThat(t).isInstanceOf(ServerErrorException.class);
-                verify(vertx, times(CachingClientFactory.MAX_CREATION_RETRIES)).setTimer(anyLong(), notNull());
-            });
-        }));
-        sender.complete(mock(ProtonSender.class));
-        ctx.verify(() -> assertThat(result.isComplete()).isTrue());
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that a request to create a sender is failed immediately when the
-     * underlying connection to the server fails.
-     */
-    @Test
-    public void testGetTelemetrySenderFailsOnConnectionFailure() {
-
-        // GIVEN a factory that tries to create a telemetry sender for "tenant"
-        final Promise<ProtonSender> sender = Promise.promise();
-        when(connection.createSender(anyString(), any(ProtonQoS.class), VertxMockSupport.anyHandler()))
-            .thenReturn(sender.future());
-        @SuppressWarnings("unchecked")
-        final ArgumentCaptor<DisconnectListener<HonoConnection>> disconnectHandler = ArgumentCaptor.forClass(DisconnectListener.class);
-        verify(connection).addDisconnectListener(disconnectHandler.capture());
-
-        final Future<DownstreamSender> result = factory.getOrCreateTelemetrySender("telemetry/tenant");
-        assertThat(result.isComplete()).isFalse();
-
-        // WHEN the underlying connection fails
-        disconnectHandler.getValue().onDisconnect(connection);
-
-        // THEN all creation requests are failed
-        assertThat(result.failed()).isTrue();
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
deleted file mode 100644
index f46d98bf2..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
+++ /dev/null
@@ -1,126 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.util.concurrent.TimeUnit;
-import java.util.function.BiConsumer;
-
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.Source;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.core.Future;
-import io.vertx.core.Vertx;
-import io.vertx.junit5.Timeout;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-
-/**
- * Test cases verifying the behavior of {@link EventConsumerImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-@Timeout(value = 5, timeUnit = TimeUnit.SECONDS)
-public class EventConsumerImplTest {
-
-    private Vertx vertx;
-    private HonoConnection connection;
-
-    /**
-     * Initializes fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-        vertx = mock(Vertx.class);
-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);
-    }
-
-    /**
-     * Verifies that the message delivery for a received event is forwarded to the
-     * registered event consumer.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateRegistersBiConsumerAsMessageHandler(final VertxTestContext ctx) {
-
-        // GIVEN an event consumer that releases all messages
-        final BiConsumer<ProtonDelivery, Message> eventConsumer = (delivery, message) -> {
-            ProtonHelper.released(delivery, true);
-        };
-        final Source source = mock(Source.class);
-        when(source.getAddress()).thenReturn("event/tenant");
-        final ProtonReceiver receiver = mock(ProtonReceiver.class);
-        when(receiver.getSource()).thenReturn(source);
-        when(receiver.getRemoteSource()).thenReturn(source);
-        when(receiver.getRemoteQoS()).thenReturn(ProtonQoS.AT_LEAST_ONCE);
-
-        when(connection.createReceiver(
-                anyString(),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(receiver));
-
-        EventConsumerImpl.create(
-                connection,
-                "tenant",
-                eventConsumer,
-                remoteDetach -> {})
-
-            .onComplete(ctx.succeeding(c -> {
-
-                final ArgumentCaptor<ProtonMessageHandler> messageHandler = ArgumentCaptor.forClass(ProtonMessageHandler.class);
-                ctx.verify(() -> verify(connection).createReceiver(
-                        eq("event/tenant"),
-                        eq(ProtonQoS.AT_LEAST_ONCE),
-                        messageHandler.capture(),
-                        anyInt(),
-                        eq(true),
-                        VertxMockSupport.anyHandler()));
-
-                // WHEN an event is received
-                final ProtonDelivery delivery = mock(ProtonDelivery.class);
-                final Message msg = mock(Message.class);
-                messageHandler.getValue().handle(delivery, msg);
-
-                // THEN the message is released and settled
-                ctx.verify(() -> verify(delivery).disposition(any(Released.class), eq(Boolean.TRUE)));
-                ctx.completeNow();
-            }));
-
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
deleted file mode 100644
index 08d4741ca..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ResourceLimitExceededException;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-/**
- * Tests verifying behavior of {@link EventSenderImpl}.
- *
- */
-public class EventSenderImplTest {
-
-    private Vertx vertx;
-    private ProtonSender sender;
-    private ClientConfigProperties config;
-    private HonoConnection connection;
-
-    /**
-     * Sets up the fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-
-        vertx = mock(Vertx.class);
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-        config = new ClientConfigProperties();
-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config);
-    }
-
-    /**
-     * Verifies that the sender waits for the peer to settle and
-     * accept a message before succeeding the returned future.
-     */
-    @Test
-    public void testSendMessageWaitsForAcceptedOutcome() {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
-        final DownstreamSender messageSender = new EventSenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-        final AtomicReference<Handler<ProtonDelivery>> handlerRef = new AtomicReference<>();
-        doAnswer(invocation -> {
-            handlerRef.set(invocation.getArgument(1));
-            return mock(ProtonDelivery.class);
-        }).when(sender).send(any(Message.class), VertxMockSupport.anyHandler());
-
-        // WHEN trying to send a message
-        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text");
-
-        // THEN the message has been sent
-        // and the result is not completed yet
-        verify(sender).send(any(Message.class), eq(handlerRef.get()));
-        assertFalse(result.isComplete());
-
-        // until it gets accepted by the peer
-        final ProtonDelivery accepted = mock(ProtonDelivery.class);
-        when(accepted.remotelySettled()).thenReturn(Boolean.TRUE);
-        when(accepted.getRemoteState()).thenReturn(new Accepted());
-        handlerRef.get().handle(accepted);
-
-        assertTrue(result.succeeded());
-    }
-
-    /**
-     * Verifies that the sender fails with an 503 error code if the peer rejects
-     * a message with an "amqp:resource-limit-exceeded" error.
-     */
-    @Test
-    public void testSendMessageFailsForResourceLimitExceeded() {
-        testSendMessageFailsForRejectedOutcome(
-                AmqpError.RESOURCE_LIMIT_EXCEEDED,
-                t -> {
-                    assertThat(t).isInstanceOf(ResourceLimitExceededException.class);
-                    assertThat(((ResourceLimitExceededException) t).getClientFacingMessage()).isNotEmpty();
-                });
-    }
-
-    /**
-     * Verifies that the sender fails with an 400 error code if the peer rejects
-     * a message with an arbitrary error condition.
-     */
-    @Test
-    public void testSendMessageFailsForArbitraryError() {
-        testSendMessageFailsForRejectedOutcome(
-                Symbol.getSymbol("arbitrary-error"),
-                t -> {
-                    assertThat(t).isInstanceOf(ClientErrorException.class);
-                    assertThat(((ClientErrorException) t).getErrorCode())
-                            .isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                });
-    }
-
-    private void testSendMessageFailsForRejectedOutcome(
-            final Symbol errorCondition,
-            final Consumer<Throwable> failureAssertions) {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
-        final DownstreamSender messageSender = new EventSenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-        final AtomicReference<Handler<ProtonDelivery>> handlerRef = new AtomicReference<>();
-        doAnswer(invocation -> {
-            handlerRef.set(invocation.getArgument(1));
-            return mock(ProtonDelivery.class);
-        }).when(sender).send(any(Message.class), VertxMockSupport.anyHandler());
-
-        // WHEN trying to send a message
-        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text");
-
-        // THEN the message has been sent
-        // and the result is not completed yet
-        verify(sender).send(any(Message.class), eq(handlerRef.get()));
-        assertFalse(result.isComplete());
-
-        // and the result fails once the peer rejects the message
-        final ErrorCondition condition = new ErrorCondition();
-        condition.setCondition(errorCondition);
-        final Rejected error = new Rejected();
-        error.setError(condition);
-        final ProtonDelivery rejected = mock(ProtonDelivery.class);
-        when(rejected.remotelySettled()).thenReturn(Boolean.TRUE);
-        when(rejected.getRemoteState()).thenReturn(error);
-        handlerRef.get().handle(rejected);
-
-        // the request is failed
-        assertThat(result.failed()).isTrue();
-        // with the expected error
-        failureAssertions.accept(result.cause());
-    }
-
-    /**
-     * Verifies that the sender fails if no credit is available.
-     */
-    @Test
-    public void testSendAndWaitForOutcomeFailsOnLackOfCredit() {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
-        final DownstreamSender messageSender = new EventSenderImpl(connection, sender, "tenant", "event/tenant", SendMessageSampler.noop());
-
-        // WHEN trying to send a message
-        final Message event = ProtonHelper.message("event/tenant", "hello");
-        final Future<ProtonDelivery> result = messageSender.sendAndWaitForOutcome(event);
-
-        // THEN the message is not sent
-        assertFalse(result.succeeded());
-        verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-    }
-
-    /**
-     * Verifies that the sender marks messages as durable.
-     */
-    @Test
-    public void testSendMarksMessageAsDurable() {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
-        final DownstreamSender messageSender = new EventSenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(mock(ProtonDelivery.class));
-
-        // WHEN trying to send a message
-        final Message msg = ProtonHelper.message("telemetry/tenant/deviceId", "some payload");
-        messageSender.send(msg);
-
-        // THEN the message has been sent
-        verify(sender).send(any(Message.class), VertxMockSupport.anyHandler());
-        // and the message has been marked as durable
-        assertTrue(msg.isDurable());
-    }
-
-    /**
-     * Verifies that the sender marks messages as durable.
-     */
-    @Test
-    public void testSendAndWaitForOutcomeMarksMessageAsDurable() {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
-        final DownstreamSender messageSender = new EventSenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(mock(ProtonDelivery.class));
-
-        // WHEN trying to send a message
-        final Message msg = ProtonHelper.message("telemetry/tenant/deviceId", "some payload");
-        messageSender.sendAndWaitForOutcome(msg);
-
-        // THEN the message has been sent
-        verify(sender).send(any(Message.class), VertxMockSupport.anyHandler());
-        // and the message has been marked as durable
-        assertTrue(msg.isDurable());
-    }
-
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImplTest.java
deleted file mode 100644
index 6f3847feb..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImplTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.SendMessageSampler;
-
-import io.vertx.core.Future;
-
-/**
- * Tests verifying the behavior of {@link RegistrationClientFactoryImpl}.
- */
-public class RegistrationClientFactoryImplTest
-        extends AbstractTenantTimeoutRelatedClientFactoryTest<RegistrationClient> {
-
-    @Override
-    protected Future<RegistrationClient> getClientFuture(final HonoConnection connection, final String tenantId) {
-        return new RegistrationClientFactoryImpl(connection, null, SendMessageSampler.Factory.noop())
-                .getOrCreateRegistrationClient(tenantId);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
deleted file mode 100644
index 195c91372..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.cache.ExpiringValueCache;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RegistrationConstants;
-import org.eclipse.hono.util.RegistrationResult;
-import org.eclipse.hono.util.TriTuple;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.vertx.core.Vertx;
-import io.vertx.core.json.JsonObject;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-
-/**
- * Tests verifying behavior of {@link RegistrationClientImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class RegistrationClientImplTest {
-
-    private ProtonSender sender;
-    private RegistrationClientImpl client;
-    private ExpiringValueCache<Object, RegistrationResult> cache;
-    private Span span;
-
-    /**
-     * Sets up the fixture.
-     */
-    @SuppressWarnings("unchecked")
-    @BeforeEach
-    public void setUp() {
-
-        span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        final Vertx vertx = mock(Vertx.class);
-        final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-
-        cache = mock(ExpiringValueCache.class);
-        final RequestResponseClientConfigProperties config = new RequestResponseClientConfigProperties();
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config, tracer);
-
-        client = new RegistrationClientImpl(connection, "tenant", sender, receiver, SendMessageSampler.noop());
-    }
-
-    /**
-     * Verifies that on a cache miss the adapter retrieves registration information
-     * from the Device Registration service and puts it to the cache.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testAssertRegistrationAddsResponseToCacheOnCacheMiss(final VertxTestContext ctx) {
-
-        final JsonObject registrationAssertion = newRegistrationAssertionResult();
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-
-        // WHEN getting registration information
-        client.assertRegistration("myDevice").onComplete(ctx.succeeding(result -> {
-            ctx.verify(() -> {
-                // THEN the registration information has been added to the cache
-                assertThat(result).isEqualTo(registrationAssertion);
-                verify(cache).put(eq(TriTuple.of("assert", "myDevice", null)), any(RegistrationResult.class), any(Duration.class));
-                // and the span is finished
-                verify(span).finish();
-            });
-            ctx.completeNow();
-        }));
-
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, registrationAssertion.toBuffer());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that the client retrieves registration information from the
-     * Device Registration service if no cache is configured.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testAssertRegistrationInvokesServiceIfNoCacheConfigured(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with no cache configured
-        final JsonObject registrationAssertion = newRegistrationAssertionResult();
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, registrationAssertion.toBuffer());
-
-        // WHEN getting registration information
-        client.assertRegistration("device").onComplete(ctx.succeeding(result -> {
-            ctx.verify(() -> {
-                // THEN the registration information has been retrieved from the service
-                assertThat(result).isEqualTo(registrationAssertion);
-                // and not been put to the cache
-                verify(cache, never()).put(any(), any(RegistrationResult.class), any(Duration.class));
-                // and the span is finished
-                verify(span).finish();
-            });
-            ctx.completeNow();
-        }));
-
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that registration information is taken from cache.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetRegistrationInfoReturnsValueFromCache(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with a cache containing a registration assertion
-        // response for "device"
-        client.setResponseCache(cache);
-        final JsonObject registrationAssertion = newRegistrationAssertionResult();
-        final RegistrationResult regResult = RegistrationResult.from(HttpURLConnection.HTTP_OK, registrationAssertion);
-        when(cache.get(eq(TriTuple.of("assert", "device", "gateway")))).thenReturn(regResult);
-
-        // WHEN getting registration information
-        client.assertRegistration("device", "gateway").onComplete(ctx.succeeding(result -> {
-            // THEN the registration information is read from the cache
-            assertEquals(registrationAssertion, result);
-            // and no request message is sent to the service
-            verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-            // and the span is finished
-            verify(span).finish();
-            ctx.completeNow();
-        }));
-
-    }
-
-    /**
-     * Verifies that the client includes the required information in the request
-     * message sent to the Device Registration service.
-     */
-    @Test
-    public void testGetRegistrationInfoIncludesRequiredParamsInRequest() {
-
-        // GIVEN an adapter without a cache
-
-        // WHEN getting registration information
-        client.assertRegistration("device", "gateway");
-
-        // THEN the message being sent contains the device ID and the gateway ID
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message sentMessage = messageCaptor.getValue();
-        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo("device");
-        assertThat(
-                MessageHelper.getApplicationProperty(
-                        sentMessage.getApplicationProperties(),
-                        MessageHelper.APP_PROPERTY_GATEWAY_ID,
-                        String.class))
-                .isEqualTo("gateway");
-    }
-
-    private static JsonObject newRegistrationAssertionResult() {
-        return newRegistrationAssertionResult(null);
-    }
-
-    private static JsonObject newRegistrationAssertionResult(final String defaultContentType) {
-
-        final JsonObject result = new JsonObject();
-        if (defaultContentType != null) {
-            result.put(RegistrationConstants.FIELD_PAYLOAD_DEFAULTS, new JsonObject()
-                    .put(MessageHelper.SYS_PROPERTY_CONTENT_TYPE, defaultContentType));
-        }
-        return result;
-    }
-
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
deleted file mode 100644
index ff5d77f2f..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.DownstreamSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import io.opentracing.Span;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonSender;
-
-/**
- * Tests verifying behavior of {@link TelemetrySenderImpl}.
- *
- */
-public class TelemetrySenderImplTest {
-
-    private Vertx vertx;
-    private ProtonSender sender;
-    private ClientConfigProperties config;
-    private HonoConnection connection;
-
-    /**
-     * Sets up the fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-
-        vertx = mock(Vertx.class);
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-        config = new ClientConfigProperties();
-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config);
-    }
-
-    /**
-     * Verifies that the sender does not wait for the peer to settle and
-     * accept a message before succeeding.
-     */
-    @Test
-    public void testSendMessageDoesNotWaitForAcceptedOutcome() {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
-        final DownstreamSender messageSender = new TelemetrySenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-        final AtomicReference<Handler<ProtonDelivery>> handlerRef = new AtomicReference<>();
-        doAnswer(invocation -> {
-            handlerRef.set(invocation.getArgument(1));
-            return mock(ProtonDelivery.class);
-        }).when(sender).send(any(Message.class), VertxMockSupport.anyHandler());
-
-        // WHEN trying to send a message
-        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text");
-        // which gets rejected by the peer
-        final ProtonDelivery rejected = mock(ProtonDelivery.class);
-        when(rejected.remotelySettled()).thenReturn(Boolean.TRUE);
-        when(rejected.getRemoteState()).thenReturn(new Rejected());
-        handlerRef.get().handle(rejected);
-
-        // THEN the resulting future is succeeded nevertheless
-        assertTrue(result.succeeded());
-        // and the message has been sent
-        verify(sender).send(any(Message.class), eq(handlerRef.get()));
-    }
-
-    /**
-     * Verifies that the sender fails if no credit is available.
-     */
-    @Test
-    public void testSendAndWaitForOutcomeFailsOnLackOfCredit() {
-
-        // GIVEN a sender that has credit
-        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
-        final DownstreamSender messageSender = new TelemetrySenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-
-        // WHEN trying to send a message
-        final Message event = ProtonHelper.message("telemetry/tenant", "hello");
-        final Future<ProtonDelivery> result = messageSender.sendAndWaitForOutcome(event);
-
-        // THEN the message is not sent
-        assertFalse(result.succeeded());
-        verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-    }
-
-    /**
-     * Verifies that a timeout occurring while a message is sent doesn't cause the corresponding 
-     * OpenTracing span to stay unfinished.
-     */
-    @Test
-    public void testSendMessageFailsOnTimeout() {
-
-        // GIVEN a sender that won't receive a delivery update on sending a message 
-        // and directly triggers the timeout handler
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(mock(ProtonDelivery.class));
-        VertxMockSupport.runTimersImmediately(vertx);
-        final DownstreamSender messageSender = new TelemetrySenderImpl(connection, sender, "tenant", "telemetry/tenant", SendMessageSampler.noop());
-
-        // WHEN sending a message
-        final Message message = mock(Message.class);
-        final Span span = mock(Span.class);
-        ((TelemetrySenderImpl) messageSender).sendMessage(message, span);
-
-        // THEN the given Span will nonetheless be finished.
-        verify(span).finish();
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
deleted file mode 100644
index 80d695c9c..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
+++ /dev/null
@@ -1,308 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.time.Duration;
-
-import javax.security.auth.x500.X500Principal;
-
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.cache.ExpiringValueCache;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.RequestResponseClientConfigProperties;
-import org.eclipse.hono.client.SendMessageSampler;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.test.TracingMockSupport;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.CacheDirective;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.TenantConstants;
-import org.eclipse.hono.util.TenantConstants.TenantAction;
-import org.eclipse.hono.util.TenantObject;
-import org.eclipse.hono.util.TenantResult;
-import org.eclipse.hono.util.TriTuple;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.Tracer;
-import io.opentracing.tag.Tags;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-import io.vertx.core.json.JsonObject;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-
-/**
- * Tests verifying behavior of {@link TenantClientImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-public class TenantClientImplTest {
-
-    private ProtonSender sender;
-    private TenantClientImpl client;
-    private ExpiringValueCache<Object, TenantResult<TenantObject>> cache;
-    private Span span;
-
-    /**
-     * Sets up the fixture.
-     */
-    @SuppressWarnings("unchecked")
-    @BeforeEach
-    public void setUp() {
-
-        span = TracingMockSupport.mockSpan();
-        final Tracer tracer = TracingMockSupport.mockTracer(span);
-
-        final Vertx vertx = mock(Vertx.class);
-        final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
-        sender = HonoClientUnitTestHelper.mockProtonSender();
-
-        final RequestResponseClientConfigProperties config = new RequestResponseClientConfigProperties();
-        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config, tracer);
-
-        cache = mock(ExpiringValueCache.class);
-        client = new TenantClientImpl(connection, sender, receiver, SendMessageSampler.noop());
-    }
-
-    /**
-     * Verifies that the client retrieves registration information from the
-     * Device Registration service if no cache is configured.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testGetTenantInvokesServiceIfNoCacheConfigured(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with no cache configured
-        client.setResponseCache(null);
-        final JsonObject tenantResult = newTenantResult("tenant");
-
-        // WHEN getting tenant information by ID
-        client.get("tenant").onComplete(ctx.succeeding(tenant -> {
-            ctx.verify(() -> {
-                // THEN the registration information has been retrieved from the service
-                assertThat(tenant).isNotNull();
-                assertThat(tenant.getTenantId()).isEqualTo("tenant");
-                // and not been put to the cache
-                verify(cache, never()).put(any(), any(TenantResult.class), any(Duration.class));
-                // and the span is finished
-                verify(span).finish();
-            });
-            ctx.completeNow();
-        }));
-
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, tenantResult.toBuffer());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that on a cache miss the adapter retrieves tenant information
-     * from the Tenant service and puts it to the cache.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @SuppressWarnings("unchecked")
-    @Test
-    public void testGetTenantAddsInfoToCacheOnCacheMiss(final VertxTestContext ctx) {
-
-        // GIVEN an adapter with an empty cache
-        client.setResponseCache(cache);
-        final JsonObject tenantResult = newTenantResult("tenant");
-
-        // WHEN getting tenant information
-        client.get("tenant").onComplete(ctx.succeeding(tenant -> {
-            ctx.verify(() -> {
-                // THEN the tenant result has been added to the cache
-                assertThat(tenant).isNotNull();
-                assertThat(tenant.getTenantId()).isEqualTo("tenant");
-                verify(cache).put(eq(TriTuple.of(TenantAction.get, "tenant", null)), any(TenantResult.class), any(Duration.class));
-                // and the span is finished
-                verify(span).finish();
-            });
-            ctx.completeNow();
-        }));
-
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, tenantResult.toBuffer());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
-    }
-
-    /**
-     * Verifies that tenant information is taken from cache if cache is configured and the cache has this tenant
-     * information cached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetTenantReturnsValueFromCache(final VertxTestContext ctx) {
-
-        // GIVEN a client with a cache containing a tenant
-        client.setResponseCache(cache);
-
-        final JsonObject tenantJsonObject = newTenantResult("tenant");
-        final TenantResult<TenantObject> tenantResult = client.getResult(
-                HttpURLConnection.HTTP_OK, "application/json", tenantJsonObject.toBuffer(), null, null);
-
-        when(cache.get(any(TriTuple.class))).thenReturn(tenantResult);
-
-        // WHEN getting tenant information
-        client.get("tenant").onComplete(ctx.succeeding(result -> {
-            // THEN the tenant information is read from the cache
-            assertEquals(tenantResult.getPayload(), result);
-            // and no request message is sent to the service
-            verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
-            // and the span is finished
-            verify(span).finish();
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the client fails if the Tenant service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetTenantFailsWithSendError(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left 
-        when(sender.sendQueueFull()).thenReturn(true);
-
-        // WHEN getting tenant information
-        client.get("tenant").onComplete(ctx.failing(t -> {
-            // THEN the invocation fails and the span is marked as erroneous
-            verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-            // and the span is finished
-            verify(span).finish();
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the client fails if the Tenant service cannot be reached.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testGetTenantFailsWithRejectedRequest(final VertxTestContext ctx) {
-
-        // GIVEN a client with no credit left
-        final ProtonDelivery update = mock(ProtonDelivery.class);
-        when(update.getRemoteState()).thenReturn(new Rejected());
-        when(update.remotelySettled()).thenReturn(true);
-        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
-            dispositionHandler.handle(update);
-            return mock(ProtonDelivery.class);
-        });
-
-        // WHEN getting tenant information
-        client.get("tenant").onComplete(ctx.failing(t -> {
-            assertEquals(HttpURLConnection.HTTP_BAD_REQUEST, ((ServiceInvocationException) t).getErrorCode());
-            // THEN the invocation fails and the span is marked as erroneous
-            verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-            // and the span is finished
-            verify(span).finish();
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the client includes the required information in the request
-     * message sent to the Tenant service.
-     */
-    @Test
-    public void testGetTenantByCaUsesRFC2253SubjectDn() {
-
-        // GIVEN an adapter
-
-        // WHEN getting tenant information for a subject DN
-        final X500Principal dn = new X500Principal("CN=ca, OU=Hono, O=Eclipse");
-        client.get(dn);
-
-        // THEN the message being sent contains the subject DN in RFC 2253 format in the
-        // payload
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message sentMessage = messageCaptor.getValue();
-        final JsonObject payload = MessageHelper.getJsonPayload(sentMessage);
-        assertThat(payload.getString(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN)).isEqualTo("CN=ca,OU=Hono,O=Eclipse");
-    }
-
-    /**
-     * Verifies that the client includes the required information in the request
-     * message sent to the Tenant service.
-     */
-    @Test
-    public void testGetTenantIncludesRequiredInformationInRequest() {
-
-        // GIVEN an adapter without a cache
-
-        // WHEN getting tenant information
-        client.get("tenant");
-
-        // THEN the message being sent contains the tenant ID as search criteria
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message sentMessage = messageCaptor.getValue();
-        assertNull(MessageHelper.getTenantId(sentMessage));
-        assertThat(sentMessage.getMessageId()).isNotNull();
-        assertThat(sentMessage.getSubject()).isEqualTo(TenantConstants.TenantAction.get.toString());
-        assertThat(MessageHelper.getJsonPayload(sentMessage).getString(TenantConstants.FIELD_PAYLOAD_TENANT_ID)).isEqualTo("tenant");
-    }
-
-    private JsonObject newTenantResult(final String tenantId) {
-
-        final JsonObject returnObject = new JsonObject().
-                put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, tenantId).
-                put(TenantConstants.FIELD_ENABLED, true);
-        return returnObject;
-    }
-}
