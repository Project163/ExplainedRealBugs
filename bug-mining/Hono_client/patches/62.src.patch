diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 83b6a7d7e..17709d4ee 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -132,12 +132,14 @@ public interface HonoClient {
      * 
      * @param tenantId The tenant to consume data for.
      * @param telemetryConsumer The handler to invoke with every message received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
      * @return A future that will complete with the consumer once the link has been established.
      *         The future will fail if the link cannot be established, e.g. because this
      *         client is not connected.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    Future<MessageConsumer> createTelemetryConsumer(String tenantId, Consumer<Message> telemetryConsumer);
+    Future<MessageConsumer> createTelemetryConsumer(String tenantId, Consumer<Message> telemetryConsumer,
+            Handler<Void> closeHandler);
 
     /**
      * Creates a new consumer of events for a tenant.
@@ -147,12 +149,14 @@ public interface HonoClient {
      *
      * @param tenantId The tenant to consume events for.
      * @param eventConsumer The handler to invoke with every event received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
      * @return A future that will complete with the consumer once the link has been established.
      *         The future will fail if the link cannot be established, e.g. because this
      *         client is not connected.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    Future<MessageConsumer> createEventConsumer(String tenantId, Consumer<Message> eventConsumer);
+    Future<MessageConsumer> createEventConsumer(String tenantId, Consumer<Message> eventConsumer,
+            Handler<Void> closeHandler);
 
     /**
      * Creates a new consumer of events for a tenant.
@@ -163,12 +167,14 @@ public interface HonoClient {
      *
      * @param tenantId The tenant to consume events for.
      * @param eventConsumer The handler to invoke with every event received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
      * @return A future that will complete with the consumer once the link has been established.
      *         The future will fail if the link cannot be established, e.g. because this
      *         client is not connected.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    Future<MessageConsumer> createEventConsumer(String tenantId, BiConsumer<ProtonDelivery, Message> eventConsumer);
+    Future<MessageConsumer> createEventConsumer(String tenantId, BiConsumer<ProtonDelivery, Message> eventConsumer,
+            Handler<Void> closeHandler);
 
     /**
      * Gets a client for invoking operations on a service implementing
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 48fe37a29..a4b882b2b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -196,6 +196,19 @@ public abstract class AbstractHonoClient {
                     result.fail(senderOpen.cause());
                 }
             });
+            sender.detachHandler(remoteDetached -> {
+                if (remoteDetached.succeeded()) {
+                    LOG.debug("sender [{}] detached (with closed=false) by peer [{}]", sender.getRemoteSource(),
+                            con.getRemoteContainer());
+                } else {
+                    LOG.debug("sender [{}] detached (with closed=false) by peer [{}]: {}", sender.getRemoteSource(),
+                            con.getRemoteContainer(), remoteDetached.cause().getMessage());
+                }
+                sender.close();
+                if (closeHook != null) {
+                    closeHook.handle(targetAddress);
+                }
+            });
             sender.closeHandler(senderClosed -> {
                 if (senderClosed.succeeded()) {
                     LOG.debug("sender [{}] closed by peer", targetAddress);
@@ -264,6 +277,10 @@ public abstract class AbstractHonoClient {
                     result.fail(openAttach.cause());
                 }
                 else {
+                    if (LOG.isTraceEnabled()) {
+                        LOG.trace("receiver open attach succeeded [{}] by peer [{}]", receiver.getRemoteSource(),
+                                con.getRemoteContainer());
+                    }
                     result.complete(openAttach.result());
                 }
             });
@@ -273,6 +290,10 @@ public abstract class AbstractHonoClient {
                 } else {
                     LOG.debug("receiver [{}] detached (with closed=false) by peer [{}]: {}", receiver.getRemoteSource(), con.getRemoteContainer(), remoteDetached.cause().getMessage());
                 }
+                receiver.close();
+                if (closeHook != null) {
+                    closeHook.handle(sourceAddress);
+                }
             });
             receiver.closeHandler(remoteClosed -> {
                 if (remoteClosed.succeeded()) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
index bde596dec..13148f217 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
@@ -50,7 +50,8 @@ public class EventConsumerImpl extends AbstractConsumer implements MessageConsum
      * @param tenantId The tenant to consumer events for.
      * @param eventConsumer The consumer to invoke with each event received.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
+     * @throws NullPointerException if any of the parameters except the closeHook is {@code null}.
      */
     public static void create(
             final Context context,
@@ -58,9 +59,10 @@ public class EventConsumerImpl extends AbstractConsumer implements MessageConsum
             final ProtonConnection con,
             final String tenantId,
             final BiConsumer<ProtonDelivery, Message> eventConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Handler<AsyncResult<MessageConsumer>> creationHandler,
+            final Handler<String> closeHook) {
 
-        create(context, clientConfig, con, tenantId, Constants.DEFAULT_PATH_SEPARATOR, eventConsumer, creationHandler);
+        create(context, clientConfig, con, tenantId, Constants.DEFAULT_PATH_SEPARATOR, eventConsumer, creationHandler, closeHook);
     }
 
     /**
@@ -73,7 +75,8 @@ public class EventConsumerImpl extends AbstractConsumer implements MessageConsum
      * @param pathSeparator The address path separator character used by the server.
      * @param eventConsumer The consumer to invoke with each event received.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
+     * @throws NullPointerException if any of the parameters except the closeHook is {@code null}.
      */
     public static void create(
             final Context context,
@@ -82,7 +85,8 @@ public class EventConsumerImpl extends AbstractConsumer implements MessageConsum
             final String tenantId,
             final String pathSeparator,
             final BiConsumer<ProtonDelivery, Message> eventConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Handler<AsyncResult<MessageConsumer>> creationHandler,
+            final Handler<String> closeHook) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(clientConfig);
@@ -93,7 +97,7 @@ public class EventConsumerImpl extends AbstractConsumer implements MessageConsum
         Objects.requireNonNull(creationHandler);
 
         createReceiver(context, clientConfig, con, String.format(EVENT_ADDRESS_TEMPLATE, pathSeparator, tenantId),
-                ProtonQoS.AT_LEAST_ONCE, eventConsumer::accept, null).setHandler(created -> {
+                ProtonQoS.AT_LEAST_ONCE, eventConsumer::accept, closeHook).setHandler(created -> {
             if (created.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(
                         new EventConsumerImpl(context, clientConfig, created.result())));
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index d7ba6a00f..0d798392e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -403,21 +403,24 @@ public final class HonoClientImpl implements HonoClient {
     @Override
     public Future<MessageConsumer> createTelemetryConsumer(
             final String tenantId,
-            final Consumer<Message> messageConsumer) {
+            final Consumer<Message> messageConsumer,
+            final Handler<Void> closeHandler) {
 
         return createConsumer(
                 tenantId,
-                () -> newTelemetryConsumer(tenantId, messageConsumer));
+                () -> newTelemetryConsumer(tenantId, messageConsumer, closeHandler));
     }
 
     private Future<MessageConsumer> newTelemetryConsumer(
             final String tenantId,
-            final Consumer<Message> messageConsumer) {
+            final Consumer<Message> messageConsumer,
+            final Handler<Void> closeHandler) {
 
         return checkConnected().compose(con -> {
             final Future<MessageConsumer> result = Future.future();
             TelemetryConsumerImpl.create(context, clientConfigProperties, connection, tenantId,
-                        connectionFactory.getPathSeparator(), messageConsumer, result.completer());
+                        connectionFactory.getPathSeparator(), messageConsumer, result.completer(),
+                    closeHook -> closeHandler.handle(null));
             return result;
         });
     }
@@ -425,29 +428,33 @@ public final class HonoClientImpl implements HonoClient {
     @Override
     public Future<MessageConsumer> createEventConsumer(
             final String tenantId,
-            final Consumer<Message> eventConsumer) {
+            final Consumer<Message> eventConsumer,
+            final Handler<Void> closeHandler) {
 
-        return createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message));
+        return createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message), closeHandler);
     }
 
     @Override
     public Future<MessageConsumer> createEventConsumer(
             final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> messageConsumer) {
+            final BiConsumer<ProtonDelivery, Message> messageConsumer,
+            final Handler<Void> closeHandler) {
 
         return createConsumer(
                 tenantId,
-                () -> newEventConsumer(tenantId, messageConsumer));
+                () -> newEventConsumer(tenantId, messageConsumer, closeHandler));
     }
 
     private Future<MessageConsumer> newEventConsumer(
             final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> messageConsumer) {
+            final BiConsumer<ProtonDelivery, Message> messageConsumer,
+            final Handler<Void> closeHandler) {
 
         return checkConnected().compose(con -> {
             final Future<MessageConsumer> result = Future.future();
             EventConsumerImpl.create(context, clientConfigProperties, connection, tenantId,
-                    connectionFactory.getPathSeparator(), messageConsumer, result.completer());
+                    connectionFactory.getPathSeparator(), messageConsumer, result.completer(),
+                    closeHook -> closeHandler.handle(null));
             return result;
         });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
index 73fad01d3..38ce604e0 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
@@ -48,6 +48,7 @@ public class TelemetryConsumerImpl extends AbstractConsumer implements MessageCo
      * @param tenantId The tenant to consumer events for.
      * @param telemetryConsumer The consumer to invoke with each telemetry message received.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
+     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
     public static void create(
@@ -56,9 +57,10 @@ public class TelemetryConsumerImpl extends AbstractConsumer implements MessageCo
             final ProtonConnection con,
             final String tenantId,
             final Consumer<Message> telemetryConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Handler<AsyncResult<MessageConsumer>> creationHandler,
+            final Handler<String> closeHook ) {
 
-        create(context, clientConfig, con, tenantId, Constants.DEFAULT_PATH_SEPARATOR, telemetryConsumer, creationHandler);
+        create(context, clientConfig, con, tenantId, Constants.DEFAULT_PATH_SEPARATOR, telemetryConsumer, creationHandler, closeHook);
     }
 
     /**
@@ -71,6 +73,7 @@ public class TelemetryConsumerImpl extends AbstractConsumer implements MessageCo
      * @param pathSeparator The address path separator character used by the server.
      * @param telemetryConsumer The consumer to invoke with each telemetry message received.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
+     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
     public static void create(
@@ -80,7 +83,8 @@ public class TelemetryConsumerImpl extends AbstractConsumer implements MessageCo
             final String tenantId,
             final String pathSeparator,
             final Consumer<Message> telemetryConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Handler<AsyncResult<MessageConsumer>> creationHandler,
+            final Handler<String> closeHook) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(clientConfig);
@@ -91,7 +95,7 @@ public class TelemetryConsumerImpl extends AbstractConsumer implements MessageCo
         Objects.requireNonNull(creationHandler);
 
         createReceiver(context, clientConfig, con, String.format(TELEMETRY_ADDRESS_TEMPLATE, pathSeparator, tenantId), ProtonQoS.AT_LEAST_ONCE,
-                (delivery, message) -> telemetryConsumer.accept(message), null).setHandler(created -> {
+                (delivery, message) -> telemetryConsumer.accept(message), closeHook).setHandler(created -> {
                     if (created.succeeded()) {
                         creationHandler.handle(Future.succeededFuture(
                                 new TelemetryConsumerImpl(context, clientConfig, created.result())));
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
index e43768c4d..5f04bc233 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
@@ -16,6 +16,7 @@ import static org.mockito.Mockito.*;
 
 import java.util.function.BiConsumer;
 
+import io.vertx.ext.unit.junit.Timeout;
 import org.apache.qpid.proton.amqp.messaging.Released;
 import org.apache.qpid.proton.amqp.transport.Source;
 import org.apache.qpid.proton.message.Message;
@@ -47,6 +48,10 @@ import io.vertx.proton.ProtonReceiver;
 @RunWith(VertxUnitRunner.class)
 public class EventConsumerImplTest {
 
+    /**
+     * Timeout each test after 5 secs.
+     */
+    public Timeout timeout = Timeout.seconds(5);
     private Vertx vertx;
 
     /**
@@ -93,8 +98,8 @@ public class EventConsumerImplTest {
         Async consumerCreation = ctx.async();
         EventConsumerImpl.create(vertx.getOrCreateContext(), new ClientConfigProperties(), con, "tenant", eventConsumer, ctx.asyncAssertSuccess(s -> {
             consumerCreation.complete();
-        }));
-        consumerCreation.await(500);
+        }), closeHook -> {});
+        consumerCreation.await();
 
         // WHEN an event is received
         ProtonDelivery delivery = mock(ProtonDelivery.class);
@@ -107,4 +112,44 @@ public class EventConsumerImplTest {
         verify(delivery).disposition(any(Released.class), eq(Boolean.TRUE));
     }
 
+    /**
+     * Verifies that the close on receiver calls the closehook.
+     *
+     * @param ctx The test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCloseHookOnDetach(final TestContext ctx) {
+
+        // GIVEN an open event consumer
+        Async consumerCreation = ctx.async();
+        BiConsumer<ProtonDelivery, Message> eventConsumer = mock(BiConsumer.class);
+        ProtonReceiver receiver = mock(ProtonReceiver.class);
+        when(receiver.isOpen()).thenReturn(Boolean.TRUE);
+        when(receiver.open()).then(answer -> {
+            consumerCreation.complete();
+            return receiver;
+        });
+
+        ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createReceiver(anyString())).thenReturn(receiver);
+
+        Handler<String> closeHook = mock(Handler.class);
+        ArgumentCaptor<Handler> detachCaptor = ArgumentCaptor.forClass(Handler.class);
+        EventConsumerImpl.create(vertx.getOrCreateContext(), new ClientConfigProperties(), con, "tenant", eventConsumer,
+                ok->{}, closeHook );
+        consumerCreation.await();
+        verify(receiver).detachHandler(detachCaptor.capture());
+
+        // WHEN the receiver link is closed
+        detachCaptor.getValue().handle(Future.succeededFuture(receiver));
+
+        // THEN the close hook is called
+        verify(closeHook).handle(any());
+
+        // and the receiver link is closed
+        verify(receiver).close();
+    }
+
+
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index b84c052fd..f6e92f3e9 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -237,7 +237,7 @@ public class HonoClientImplTest {
         connected.await();
 
         final Async disconnected = ctx.async();
-        client.createTelemetryConsumer("tenant", msg -> {}).setHandler(ctx.asyncAssertFailure(cause -> {
+        client.createTelemetryConsumer("tenant", msg -> {}, close -> {}).setHandler(ctx.asyncAssertFailure(cause -> {
             disconnected.complete();
         }));
 
@@ -263,7 +263,7 @@ public class HonoClientImplTest {
         connected.await();
 
         final Async disconnected = ctx.async();
-        client.createEventConsumer("tenant", msg -> {}).setHandler(ctx.asyncAssertFailure(cause -> {
+        client.createEventConsumer("tenant", msg -> {}, close -> {}).setHandler(ctx.asyncAssertFailure(cause -> {
             disconnected.complete();
         }));
 
