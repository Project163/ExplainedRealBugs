diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index e587df69e..0577bc467 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -21,6 +21,8 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.impl.EventConsumerImpl;
+import org.eclipse.hono.client.impl.EventSenderImpl;
 import org.eclipse.hono.client.impl.RegistrationClientImpl;
 import org.eclipse.hono.client.impl.TelemetryConsumerImpl;
 import org.eclipse.hono.client.impl.TelemetrySenderImpl;
@@ -47,14 +49,14 @@ public class HonoClient {
     private final String host;
     private final int port;
     private final String pathSeparator;
-    private final Map<String, TelemetrySender> activeSenders = new ConcurrentHashMap<>();
+    private final Map<String, MessageSender> activeSenders = new ConcurrentHashMap<>();
     private final Map<String, RegistrationClient> activeRegClients = new ConcurrentHashMap<>();
     private final String user;
     private final String password;
     private ProtonClientOptions clientOptions;
     private ProtonConnection connection;
-    private AtomicBoolean connecting = new AtomicBoolean(false);
-    private Vertx vertx;
+    private final AtomicBoolean connecting = new AtomicBoolean(false);
+    private final Vertx vertx;
     private Context context;
 
     /**
@@ -120,7 +122,7 @@ public class HonoClient {
             }
             LOG.debug("connecting to server [{}:{}] as user [{}]...", host, port, user);
 
-            ProtonClient protonClient = ProtonClient.create(vertx);
+            final ProtonClient protonClient = ProtonClient.create(vertx);
             protonClient.connect(clientOptions, host, port, user, password, conAttempt -> {
 
                 if (conAttempt.succeeded()) {
@@ -177,9 +179,9 @@ public class HonoClient {
 
     public HonoClient getOrCreateTelemetrySender(
             final String tenantId,
-            final Handler<AsyncResult<TelemetrySender>> resultHandler) {
+            final Handler<AsyncResult<MessageSender>> resultHandler) {
 
-        TelemetrySender sender = activeSenders.get(Objects.requireNonNull(tenantId));
+        final MessageSender sender = activeSenders.get(Objects.requireNonNull(tenantId));
         if (sender != null) {
             resultHandler.handle(Future.succeededFuture(sender));
         } else {
@@ -190,7 +192,7 @@ public class HonoClient {
 
     public HonoClient createTelemetrySender(
             final String tenantId,
-            final Handler<AsyncResult<TelemetrySender>> creationHandler) {
+            final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         Objects.requireNonNull(tenantId);
         if (connection == null || connection.isDisconnected()) {
@@ -211,7 +213,7 @@ public class HonoClient {
     public HonoClient createTelemetryConsumer(
             final String tenantId,
             final Consumer<Message> telemetryConsumer,
-            final Handler<AsyncResult<TelemetryConsumer>> creationHandler) {
+            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
         Objects.requireNonNull(tenantId);
         if (connection == null || connection.isDisconnected()) {
@@ -222,11 +224,46 @@ public class HonoClient {
         return this;
     }
 
+    public HonoClient createEventConsumer(
+            final String tenantId,
+            final Consumer<Message> eventConsumer,
+            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+
+        Objects.requireNonNull(tenantId);
+        if (connection == null || connection.isDisconnected()) {
+            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
+        } else {
+            EventConsumerImpl.create(context, connection, tenantId, pathSeparator, eventConsumer, creationHandler);
+        }
+        return this;
+    }
+
+    public HonoClient createEventSender(
+            final String tenantId,
+            final Handler<AsyncResult<MessageSender>> creationHandler) {
+
+        Objects.requireNonNull(tenantId);
+        if (connection == null || connection.isDisconnected()) {
+            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
+        } else {
+            EventSenderImpl.create(context, connection, tenantId, creationResult -> {
+                if (creationResult.succeeded()) {
+                    activeSenders.put(tenantId, creationResult.result());
+                    creationHandler.handle(Future.succeededFuture(creationResult.result()));
+                } else {
+                    creationHandler.handle(Future.failedFuture(creationResult.cause()));
+                }
+            });
+        }
+        return this;
+    }
+
+
     public HonoClient getOrCreateRegistrationClient(
             final String tenantId,
             final Handler<AsyncResult<RegistrationClient>> resultHandler) {
 
-        RegistrationClient regClient = activeRegClients.get(Objects.requireNonNull(tenantId));
+        final RegistrationClient regClient = activeRegClients.get(Objects.requireNonNull(tenantId));
         if (regClient != null) {
             resultHandler.handle(Future.succeededFuture(regClient));
         } else {
@@ -261,7 +298,7 @@ public class HonoClient {
      * This method waits for at most 5 seconds for the connection to be closed properly.
      */
     public void shutdown() {
-        CountDownLatch latch = new CountDownLatch(1);
+        final CountDownLatch latch = new CountDownLatch(1);
         shutdown(done -> {
             if (done.succeeded()) {
                 latch.countDown();
@@ -273,7 +310,7 @@ public class HonoClient {
             if (!latch.await(5, TimeUnit.SECONDS)) {
                 LOG.error("shutdown of client timed out");
             }
-        } catch (InterruptedException e) {
+        } catch (final InterruptedException e) {
             Thread.currentThread().interrupt();
         }
     }
@@ -317,7 +354,7 @@ public class HonoClient {
         }
 
         public static HonoClientBuilder newClient(final HonoClientConfigProperties config) {
-            HonoClientBuilder builder = new HonoClientBuilder();
+            final HonoClientBuilder builder = new HonoClientBuilder();
             builder
                 .name(config.getName())
                 .host(config.getHost())
diff --git a/client/src/main/java/org/eclipse/hono/client/TelemetryConsumer.java b/client/src/main/java/org/eclipse/hono/client/MessageConsumer.java
similarity index 90%
rename from client/src/main/java/org/eclipse/hono/client/TelemetryConsumer.java
rename to client/src/main/java/org/eclipse/hono/client/MessageConsumer.java
index f2cb2a20a..833962073 100644
--- a/client/src/main/java/org/eclipse/hono/client/TelemetryConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageConsumer.java
@@ -16,10 +16,10 @@ import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
 
 /**
- * A client for consuming telemetry data from a Hono server.
+ * A client for consuming messages from a Hono server.
  *
  */
-public interface TelemetryConsumer {
+public interface MessageConsumer {
 
     /**
      * Closes the AMQP link with the Hono server this client is configured to use.
diff --git a/client/src/main/java/org/eclipse/hono/client/TelemetrySender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
similarity index 97%
rename from client/src/main/java/org/eclipse/hono/client/TelemetrySender.java
rename to client/src/main/java/org/eclipse/hono/client/MessageSender.java
index ec78895f8..ad9a04c7a 100644
--- a/client/src/main/java/org/eclipse/hono/client/TelemetrySender.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
@@ -8,22 +8,25 @@
  *
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
+ *
  */
 
 package org.eclipse.hono.client;
 
 import java.util.Map;
+import java.util.function.BiConsumer;
 
 import org.apache.qpid.proton.message.Message;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
 
 /**
  * A client for uploading telemetry data to a Hono server.
  *
  */
-public interface TelemetrySender {
+public interface MessageSender {
 
     /**
      * Checks if this sender can send or buffer (and send later) a telemetry message.
@@ -265,6 +268,13 @@ public interface TelemetrySender {
      */
     void setErrorHandler(Handler<AsyncResult<Void>> errorHandler);
 
+    /**
+     * Sets a callback for disposition updates for messages sent with this {@link MessageSender}.
+     *
+     * @param dispositionHandler consumer that accepts a message id and updated disposition
+     */
+    void setDispositionHandler(BiConsumer<String, ProtonDelivery> dispositionHandler);
+
     /**
      * Closes the AMQP link with the Hono server this sender is using.
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
new file mode 100644
index 000000000..f4120da3a
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -0,0 +1,238 @@
+/**
+ * Copyright (c) 2016 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ *
+ */
+
+package org.eclipse.hono.client.impl;
+
+import static org.eclipse.hono.util.MessageHelper.addDeviceId;
+
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.BiConsumer;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.qpid.proton.amqp.Binary;
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.amqp.messaging.Data;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+
+/**
+ * A Vertx-Proton based client for uploading telemtry data to a Hono server.
+ */
+abstract class AbstractSender extends AbstractHonoClient implements MessageSender {
+
+    private static final Logger     LOG = LoggerFactory.getLogger(AbstractSender.class);
+    private static final AtomicLong messageCounter = new AtomicLong();
+    private static final Pattern    CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
+
+    private Handler<Void> drainHandler;
+    private BiConsumer<String, ProtonDelivery> dispositionHandler = (id, delivery) -> LOG.info("Disposition updated for {}: {}", id, delivery.getRemoteState());
+
+    AbstractSender(final Context context) {
+        super(context);
+    }
+
+    @Override
+    public boolean sendQueueFull() {
+        return sender.sendQueueFull();
+    }
+
+    @Override
+    public void sendQueueDrainHandler(final Handler<Void> handler) {
+        if (this.drainHandler != null) {
+            throw new IllegalStateException("already waiting for replenishment with credit");
+        } else {
+            this.drainHandler = Objects.requireNonNull(handler);
+            sender.sendQueueDrainHandler(replenishedSender -> {
+                LOG.trace("telemetry sender has been replenished with {} credits", replenishedSender.getCredit());
+                final Handler<Void> currentHandler = this.drainHandler;
+                this.drainHandler = null;
+                if (currentHandler != null) {
+                    currentHandler.handle(null);
+                }
+            });
+        }
+    }
+
+    @Override
+    public void close(final Handler<AsyncResult<Void>> closeHandler) {
+        closeLinks(closeHandler);
+    }
+
+    @Override
+    public void setErrorHandler(final Handler<AsyncResult<Void>> errorHandler) {
+        sender.closeHandler(s -> {
+            if (s.failed()) {
+                LOG.debug("server closed link with error condition: {}", s.cause().getMessage());
+                sender.close();
+                errorHandler.handle(Future.failedFuture(s.cause()));
+            } else {
+                LOG.debug("server closed link");
+                sender.close();
+            }
+        });
+    }
+
+    @Override
+    public void setDispositionHandler(final BiConsumer<String, ProtonDelivery> dispositionHandler) {
+        this.dispositionHandler = dispositionHandler;
+    }
+
+    @Override
+    public void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler) {
+        Objects.requireNonNull(rawMessage);
+        if (capacityAvailableHandler == null) {
+            context.runOnContext(send -> {
+                sendMessage(rawMessage);
+            });
+        } else if (this.drainHandler != null) {
+            throw new IllegalStateException("cannot send message while waiting for replenishment with credit");
+        } else if (sender.isOpen()) {
+            context.runOnContext(send -> {
+                sendMessage(rawMessage);
+                if (sender.sendQueueFull()) {
+                    sendQueueDrainHandler(capacityAvailableHandler);
+                } else {
+                    capacityAvailableHandler.handle(null);
+                }
+            });
+        } else {
+            throw new IllegalStateException("sender is not open");
+        }
+    }
+
+    @Override
+    public boolean send(final Message rawMessage) {
+        Objects.requireNonNull(rawMessage);
+        if (sender.sendQueueFull()) {
+            return false;
+        } else {
+            context.runOnContext(send -> {
+                sendMessage(rawMessage);
+            });
+            return true;
+        }
+    }
+
+    private void sendMessage(final Message rawMessage) {
+        sender.send(rawMessage, deliveryUpdated ->
+                dispositionHandler.accept(rawMessage.getMessageId().toString(), deliveryUpdated));
+    }
+
+    @Override
+    public boolean send(final String deviceId, final byte[] payload, final String contentType) {
+        return send(deviceId, null, payload, contentType);
+    }
+
+    @Override
+    public void send(final String deviceId, final byte[] payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
+        send(deviceId, null, payload, contentType, capacityAvailableHandler);
+    }
+
+    @Override
+    public boolean send(final String deviceId, final String payload, final String contentType) {
+        return send(deviceId, null, payload, contentType);
+    }
+
+    @Override
+    public void send(final String deviceId, final String payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
+        send(deviceId, null, payload, contentType, capacityAvailableHandler);
+    }
+
+    @Override
+    public boolean send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType) {
+        Objects.requireNonNull(payload);
+        final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
+        return send(deviceId, properties, payload.getBytes(charset), contentType);
+    }
+
+    @Override
+    public boolean send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(payload);
+        Objects.requireNonNull(contentType);
+        final Message msg = ProtonHelper.message();
+        msg.setBody(new Data(new Binary(payload)));
+        setApplicationProperties(msg, properties);
+        addProperties(msg, deviceId, contentType);
+        return send(msg);
+    }
+
+    @Override
+    public void send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
+        Objects.requireNonNull(payload);
+        final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
+        send(deviceId, properties, payload.getBytes(charset), contentType, capacityAvailableHandler);
+    }
+
+    @Override
+    public void send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(payload);
+        Objects.requireNonNull(contentType);
+        final Message msg = ProtonHelper.message();
+        msg.setBody(new Data(new Binary(payload)));
+        setApplicationProperties(msg, properties);
+        addProperties(msg, deviceId, contentType);
+        send(msg, capacityAvailableHandler);
+    }
+
+    protected void addProperties(final Message msg, final String deviceId, final String contentType) {
+        msg.setMessageId(String.format("%s-%d", getClass().getSimpleName(), messageCounter.getAndIncrement()));
+        msg.setContentType(contentType);
+        addDeviceId(msg, deviceId);
+    }
+
+    private void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
+        if (properties != null) {
+
+            // check the three types not allowed by AMQP 1.0 spec for application properties (list, map and array)
+            for (final Map.Entry<String, ?> entry: properties.entrySet()) {
+                if (entry.getValue() instanceof  List) {
+                    throw new IllegalArgumentException(String.format("Application property %s can't be a List", entry.getKey()));
+                } else if (entry.getValue() instanceof Map) {
+                    throw new IllegalArgumentException(String.format("Application property %s can't be a Map", entry.getKey()));
+                } else if (entry.getValue().getClass().isArray()) {
+                    throw new IllegalArgumentException(String.format("Application property %s can't be an Array", entry.getKey()));
+                }
+            }
+
+            final ApplicationProperties applicationProperties = new ApplicationProperties(properties);
+            msg.setApplicationProperties(applicationProperties);
+        }
+    }
+
+    private Charset getCharsetForContentType(final String contentType) {
+
+        final Matcher m = CHARSET_PATTERN.matcher(contentType);
+        if (m.matches()) {
+            return Charset.forName(m.group(1));
+        } else {
+            return StandardCharsets.UTF_8;
+        }
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
new file mode 100644
index 000000000..bd4ffa380
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
@@ -0,0 +1,100 @@
+/**
+ * Copyright (c) 2016 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ *
+ */
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+import java.util.function.Consumer;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageConsumer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonReceiver;
+
+/**
+ * A Vertx-Proton based client for consuming telemetry data from a Hono server.
+ */
+public class EventConsumerImpl extends AbstractHonoClient implements MessageConsumer {
+
+    private static final String EVENT_ADDRESS_TEMPLATE = "event%s%s";
+    private static final Logger LOG = LoggerFactory.getLogger(EventConsumerImpl.class);
+
+    private EventConsumerImpl(final Context context, final ProtonReceiver receiver) {
+        super(context);
+        this.receiver = receiver;
+    }
+
+    public static void create(
+            final Context context,
+            final ProtonConnection con,
+            final String tenantId,
+            final String pathSeparator,
+            final Consumer<Message> eventConsumer,
+            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(pathSeparator);
+        createConsumer(context, con, tenantId, pathSeparator, eventConsumer).setHandler(created -> {
+            if (created.succeeded()) {
+                creationHandler.handle(Future.succeededFuture(
+                        new EventConsumerImpl(context, created.result())));
+            } else {
+                creationHandler.handle(Future.failedFuture(created.cause()));
+            }
+        });
+    }
+
+    private static Future<ProtonReceiver> createConsumer(
+            final Context context,
+            final ProtonConnection con,
+            final String tenantId,
+            final String pathSeparator,
+            final Consumer<Message> consumer) {
+
+        Future<ProtonReceiver> result = Future.future();
+        final String targetAddress = String.format(EVENT_ADDRESS_TEMPLATE, pathSeparator, tenantId);
+
+        context.runOnContext(open -> {
+            final ProtonReceiver receiver = con.createReceiver(targetAddress);
+            receiver.setAutoAccept(true).setPrefetch(DEFAULT_RECEIVER_CREDITS);
+            receiver.openHandler(receiverOpen -> {
+                if (receiverOpen.succeeded()) {
+                    LOG.debug("event receiver for [{}] open", receiverOpen.result().getRemoteSource());
+                    result.complete(receiverOpen.result());
+                } else {
+                    result.fail(receiverOpen.cause());
+                }
+            });
+            receiver.handler((delivery, message) -> {
+                if (consumer != null) {
+                    consumer.accept(message);
+                }
+            });
+            receiver.open();
+        });
+        return result;
+    }
+
+    @Override
+    public void close(final Handler<AsyncResult<Void>> closeHandler) {
+        closeLinks(closeHandler);
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
new file mode 100644
index 000000000..7c20275d3
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -0,0 +1,96 @@
+/**
+ * Copyright (c) 2016 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ *
+ */
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageSender;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * A Vertx-Proton based client for event messages to a Hono server.
+ */
+public class EventSenderImpl extends AbstractSender {
+
+    private static final String EVENT_ADDRESS_TEMPLATE = "event/%s";
+    private static final Logger LOG = LoggerFactory.getLogger(EventSenderImpl.class);
+
+    private EventSenderImpl(final Context context, final ProtonSender sender) {
+        super(context);
+        this.sender = sender;
+    }
+
+    public static void create(
+            final Context context,
+            final ProtonConnection con,
+            final String tenantId,
+            final Handler<AsyncResult<MessageSender>> creationHandler) {
+
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+        createSender(con, tenantId).setHandler(created -> {
+            if (created.succeeded()) {
+                creationHandler.handle(Future.succeededFuture(
+                        new EventSenderImpl(context, created.result())));
+            } else {
+                creationHandler.handle(Future.failedFuture(created.cause()));
+            }
+        });
+    }
+
+    private static Future<ProtonSender> createSender(
+            final ProtonConnection con,
+            final String tenantId) {
+
+        final Future<ProtonSender> result = Future.future();
+        final String targetAddress = String.format(EVENT_ADDRESS_TEMPLATE, tenantId);
+
+        final ProtonSender sender = con.createSender(targetAddress);
+        sender.setQoS(ProtonQoS.AT_LEAST_ONCE);
+        sender.openHandler(senderOpen -> {
+            if (senderOpen.succeeded()) {
+                LOG.debug("event sender for [{}] open", senderOpen.result().getRemoteTarget());
+                result.complete(senderOpen.result());
+            } else {
+                LOG.debug("event sender open failed [{}]", senderOpen.cause().getMessage());
+                result.fail(senderOpen.cause());
+            }
+        }).closeHandler(senderClosed -> {
+            if (senderClosed.succeeded()) {
+                LOG.debug("event sender for [{}] closed", targetAddress);
+            } else {
+                LOG.debug("event sender for [{}] closed: {}", targetAddress, senderClosed.cause().getMessage());
+            }
+        }).open();
+
+        return result;
+    }
+
+    @Override
+    protected void addProperties(final Message msg, final String deviceId, final String contentType) {
+        super.addProperties(msg, deviceId, contentType);
+        msg.setDurable(true);
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
index c3ec6c4dc..564fae218 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
@@ -16,7 +16,7 @@ import java.util.Objects;
 import java.util.function.Consumer;
 
 import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.TelemetryConsumer;
+import org.eclipse.hono.client.MessageConsumer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -30,7 +30,7 @@ import io.vertx.proton.ProtonReceiver;
 /**
  * A Vertx-Proton based client for consuming telemetry data from a Hono server.
  */
-public class TelemetryConsumerImpl extends AbstractHonoClient implements TelemetryConsumer {
+public class TelemetryConsumerImpl extends AbstractHonoClient implements MessageConsumer {
 
     private static final String     TELEMETRY_ADDRESS_TEMPLATE  = "telemetry%s%s";
     private static final Logger     LOG = LoggerFactory.getLogger(TelemetryConsumerImpl.class);
@@ -46,7 +46,7 @@ public class TelemetryConsumerImpl extends AbstractHonoClient implements Telemet
             final String tenantId,
             final String pathSeparator,
             final Consumer<Message> telemetryConsumer,
-            final Handler<AsyncResult<TelemetryConsumer>> creationHandler) {
+            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
         Objects.requireNonNull(con);
         Objects.requireNonNull(tenantId);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index b2faf217f..24c80d76d 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -12,22 +12,9 @@
 
 package org.eclipse.hono.client.impl;
 
-import static org.eclipse.hono.util.MessageHelper.addDeviceId;
-
-import java.nio.charset.Charset;
-import java.nio.charset.StandardCharsets;
-import java.util.List;
-import java.util.Map;
 import java.util.Objects;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
-import org.apache.qpid.proton.amqp.Binary;
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Data;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.TelemetrySender;
+import org.eclipse.hono.client.MessageSender;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,21 +23,16 @@ import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonHelper;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonSender;
 
 /**
  * A Vertx-Proton based client for uploading telemtry data to a Hono server.
  */
-public class TelemetrySenderImpl extends AbstractHonoClient implements TelemetrySender {
+public class TelemetrySenderImpl extends AbstractSender {
 
     private static final String     TELEMETRY_ADDRESS_TEMPLATE  = "telemetry/%s";
     private static final Logger     LOG = LoggerFactory.getLogger(TelemetrySenderImpl.class);
-    private static final AtomicLong messageCounter = new AtomicLong();
-    private static final Pattern    CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
-
-    private Handler<Void> drainHandler;
 
     private TelemetrySenderImpl(final Context context, final ProtonSender sender) {
         super(context);
@@ -61,7 +43,7 @@ public class TelemetrySenderImpl extends AbstractHonoClient implements Telemetry
             final Context context,
             final ProtonConnection con,
             final String tenantId,
-            final Handler<AsyncResult<TelemetrySender>> creationHandler) {
+            final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(con);
@@ -81,7 +63,7 @@ public class TelemetrySenderImpl extends AbstractHonoClient implements Telemetry
             final ProtonConnection con,
             final String tenantId) {
 
-        Future<ProtonSender> result = Future.future();
+        final Future<ProtonSender> result = Future.future();
         final String targetAddress = String.format(TELEMETRY_ADDRESS_TEMPLATE, tenantId);
 
         ctx.runOnContext(create -> {
@@ -92,181 +74,18 @@ public class TelemetrySenderImpl extends AbstractHonoClient implements Telemetry
                     LOG.debug("telemetry sender for [{}] open", senderOpen.result().getRemoteTarget());
                     result.complete(senderOpen.result());
                 } else {
+                    LOG.debug("telemetry sender open for [{}] failed: {}", targetAddress, senderOpen.cause().getMessage());
                     result.fail(senderOpen.cause());
                 }
+            }).closeHandler(senderClosed -> {
+                if (senderClosed.succeeded()) {
+                    LOG.debug("telemetry sender for [{}] closed", senderClosed.result().getRemoteTarget());
+                } else {
+                    LOG.debug("telemetry closed due to {}", senderClosed.cause().getMessage());
+                }
             }).open();
         });
 
         return result;
     }
-
-    @Override
-    public boolean sendQueueFull() {
-        return sender.sendQueueFull();
-    }
-
-    @Override
-    public void sendQueueDrainHandler(final Handler<Void> handler) {
-        if (this.drainHandler != null) {
-            throw new IllegalStateException("already waiting for replenishment with credit");
-        } else {
-            this.drainHandler = Objects.requireNonNull(handler);
-            sender.sendQueueDrainHandler(replenishedSender -> {
-                LOG.trace("telemetry sender has been replenished with {} credits", replenishedSender.getCredit());
-                Handler<Void> currentHandler = this.drainHandler;
-                this.drainHandler = null;
-                if (currentHandler != null) {
-                    currentHandler.handle(null);
-                }
-            });
-        }
-    }
-
-    @Override
-    public void close(final Handler<AsyncResult<Void>> closeHandler) {
-        closeLinks(closeHandler);
-    }
-
-    @Override
-    public void setErrorHandler(Handler<AsyncResult<Void>> errorHandler) {
-        sender.closeHandler(s -> {
-            if (s.failed()) {
-                LOG.debug("server closed link with error condition: {}", s.cause().getMessage());
-                sender.close();
-                errorHandler.handle(Future.failedFuture(s.cause()));
-            } else {
-                LOG.debug("server closed link");
-                sender.close();
-            }
-        });
-    }
-
-    @Override
-    public void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler) {
-        Objects.requireNonNull(rawMessage);
-        if (capacityAvailableHandler == null) {
-            context.runOnContext(send -> {
-                sender.send(rawMessage);
-            });
-        } else if (this.drainHandler != null) {
-            throw new IllegalStateException("cannot send message while waiting for replenishment with credit");
-        } else if (sender.isOpen()) {
-            context.runOnContext(send -> {
-                sender.send(rawMessage);
-                if (sender.sendQueueFull()) {
-                    sendQueueDrainHandler(capacityAvailableHandler);
-                } else {
-                    capacityAvailableHandler.handle(null);
-                }
-            });
-        } else {
-            throw new IllegalStateException("sender is not open");
-        }
-    }
-
-    @Override
-    public boolean send(final Message rawMessage) {
-        Objects.requireNonNull(rawMessage);
-        if (sender.sendQueueFull()) {
-            return false;
-        } else {
-            context.runOnContext(send -> {
-                sender.send(rawMessage);
-            });
-            return true;
-        }
-    }
-
-    @Override
-    public boolean send(final String deviceId, final byte[] payload, final String contentType) {
-        return send(deviceId, null, payload, contentType);
-    }
-
-    @Override
-    public void send(final String deviceId, final byte[] payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
-        send(deviceId, null, payload, contentType, capacityAvailableHandler);
-    }
-
-    @Override
-    public boolean send(final String deviceId, final String payload, final String contentType) {
-        return send(deviceId, null, payload, contentType);
-    }
-
-    @Override
-    public void send(final String deviceId, final String payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
-        send(deviceId, null, payload, contentType, capacityAvailableHandler);
-    }
-
-    @Override
-    public boolean send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType) {
-        Objects.requireNonNull(payload);
-        Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
-        return send(deviceId, properties, payload.getBytes(charset), contentType);
-    }
-
-    @Override
-    public boolean send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType) {
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(payload);
-        Objects.requireNonNull(contentType);
-        final Message msg = ProtonHelper.message();
-        msg.setBody(new Data(new Binary(payload)));
-        setApplicationProperties(msg, properties);
-        addProperties(msg, deviceId, contentType);
-        return send(msg);
-    }
-
-    @Override
-    public void send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
-        Objects.requireNonNull(payload);
-        Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
-        send(deviceId, properties, payload.getBytes(charset), contentType, capacityAvailableHandler);
-    }
-
-    @Override
-    public void send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType, final Handler<Void> capacityAvailableHandler) {
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(payload);
-        Objects.requireNonNull(contentType);
-        final Message msg = ProtonHelper.message();
-        msg.setBody(new Data(new Binary(payload)));
-        setApplicationProperties(msg, properties);
-        addProperties(msg, deviceId, contentType);
-        send(msg, capacityAvailableHandler);
-    }
-
-    private void addProperties(final Message msg, final String deviceId, final String contentType) {
-        msg.setMessageId(String.format("TelemetryClientImpl-%d", messageCounter.getAndIncrement()));
-        msg.setContentType(contentType);
-        addDeviceId(msg, deviceId);
-    }
-
-    private void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
-        if (properties != null) {
-
-            // check the three types not allowed by AMQP 1.0 spec for application properties (list, map and array)
-            for (Map.Entry<String, ?> entry: properties.entrySet()) {
-                if (entry.getValue() instanceof  List) {
-                    throw new IllegalArgumentException(String.format("Application property %s can't be a List", entry.getKey()));
-                } else if (entry.getValue() instanceof Map) {
-                    throw new IllegalArgumentException(String.format("Application property %s can't be a Map", entry.getKey()));
-                } else if (entry.getValue().getClass().isArray()) {
-                    throw new IllegalArgumentException(String.format("Application property %s can't be an Array", entry.getKey()));
-                }
-            }
-
-            final ApplicationProperties applicationProperties = new ApplicationProperties(properties);
-            msg.setApplicationProperties(applicationProperties);
-        }
-    }
-
-    private Charset getCharsetForContentType(final String contentType) {
-
-        Matcher m = CHARSET_PATTERN.matcher(contentType);
-        if (m.matches()) {
-            return Charset.forName(m.group(1));
-        } else {
-            return StandardCharsets.UTF_8;
-        }
-    }
 }
