diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 45e6e24b3..2dd290794 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -21,11 +21,14 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 
+import javax.net.ssl.HttpsURLConnection;
+
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
@@ -350,6 +353,16 @@ public abstract class AbstractHonoClient {
             HonoProtonHelper.setDetachHandler(sender, remoteDetached -> onRemoteDetach(sender, con.getRemoteContainer(), false, closeHook));
             HonoProtonHelper.setCloseHandler(sender, remoteClosed -> onRemoteDetach(sender, con.getRemoteContainer(), true, closeHook));
             sender.open();
+            ctx.owner().setTimer(clientConfig.getLinkEstablishmentTimeout(), tid -> {
+                if (!result.isComplete() && !sender.attachments().get(KEY_LINK_ESTABLISHED, Boolean.class)) {
+                    LOG.debug(
+                            "did not receive peer's attach frame after {}ms, failing attempt to establish sender link",
+                            clientConfig.getLinkEstablishmentTimeout());
+                    sender.close();
+                    sender.free();
+                    result.fail(new ServerErrorException(HttpsURLConnection.HTTP_UNAVAILABLE));
+                }
+            });
         });
     }
 
@@ -422,6 +435,16 @@ public abstract class AbstractHonoClient {
             HonoProtonHelper.setDetachHandler(receiver, remoteDetached -> onRemoteDetach(receiver, con.getRemoteContainer(), false, closeHook));
             HonoProtonHelper.setCloseHandler(receiver, remoteClosed -> onRemoteDetach(receiver, con.getRemoteContainer(), true, closeHook));
             receiver.open();
+            ctx.owner().setTimer(clientConfig.getLinkEstablishmentTimeout(), tid -> {
+                if (!result.isComplete() && !receiver.attachments().get(KEY_LINK_ESTABLISHED, Boolean.class)) {
+                    LOG.debug(
+                            "did not receive peer's attach frame after {}ms, failing attempt to establish receiver link",
+                            clientConfig.getLinkEstablishmentTimeout());
+                    receiver.close();
+                    receiver.free();
+                    result.fail(new ServerErrorException(HttpsURLConnection.HTTP_UNAVAILABLE));
+                }
+            });
         });
     }
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 7d447ce84..4a2d07a3d 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -13,7 +13,6 @@
 package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
-import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -105,7 +104,7 @@ public class HonoClientImpl implements HonoClient {
     protected volatile Context context;
 
     private final Map<String, RequestResponseClient> activeRequestResponseClients = new HashMap<>();
-    private final Map<String, Long> creationLocks = new HashMap<>();
+    private final Map<String, Boolean> creationLocks = new HashMap<>();
     private final List<Handler<Void>> creationRequests = new ArrayList<>();
     private final AtomicBoolean connecting = new AtomicBoolean(false);
     private final AtomicBoolean shuttingDown = new AtomicBoolean(false);
@@ -611,7 +610,7 @@ public class HonoClientImpl implements HonoClient {
         if (sender != null && sender.isOpen()) {
             LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
             result.tryComplete(sender);
-        } else if (creationLocks.computeIfAbsent(key, k -> 0L) == 0) {
+        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
             final Handler<Void> connectionFailureHandler = connectionLost -> {
@@ -621,8 +620,7 @@ public class HonoClientImpl implements HonoClient {
                         new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
             };
             creationRequests.add(connectionFailureHandler);
-            // set the timeout for the creation lock to one second in the future
-            creationLocks.put(key, calculateCreationTimeoutAsEpochMilliSeconds(1));
+            creationLocks.put(key, Boolean.TRUE);
             LOG.debug("creating new message sender for {}", key);
 
             newSenderSupplier.get().setHandler(creationAttempt -> {
@@ -642,26 +640,11 @@ public class HonoClientImpl implements HonoClient {
 
         } else {
             LOG.debug("already trying to create a message sender for {}", key);
-            if (isCreationLockExpired(key)) {
-                LOG.info("Releasing expired lock for {}", key);
-                creationLocks.remove(key);
-                getOrCreateSender(key, newSenderSupplier, result);
-            } else {
-                result.tryFail(new ServerErrorException(
-                        HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-            }
+            result.tryFail(new ServerErrorException(
+                    HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
         }
     }
 
-    private long calculateCreationTimeoutAsEpochMilliSeconds(final int seconds) {
-        return Instant.now().plusSeconds(seconds).toEpochMilli();
-    }
-
-    private boolean isCreationLockExpired(final String key) {
-        return Optional.ofNullable(creationLocks.get(key)).map(timeMs ->
-                (Instant.ofEpochMilli(timeMs).isBefore(Instant.now()))).orElse(false);
-    }
-
     /**
      * {@inheritDoc}
      */
@@ -1020,7 +1003,7 @@ public class HonoClientImpl implements HonoClient {
         if (client != null && client.isOpen()) {
             LOG.debug("reusing existing client [target: {}]", key);
             result.complete(client);
-        } else if (creationLocks.computeIfAbsent(key, k -> 0L) == 0) {
+        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
 
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
@@ -1030,8 +1013,7 @@ public class HonoClientImpl implements HonoClient {
                 result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
             };
             creationRequests.add(connectionFailureHandler);
-            // set the timeout for the creation lock to one second in the future
-            creationLocks.put(key, calculateCreationTimeoutAsEpochMilliSeconds(1));
+            creationLocks.put(key, Boolean.TRUE);
             LOG.debug("creating new client [target: {}]", key);
 
             clientSupplier.get().setHandler(creationAttempt -> {
@@ -1050,14 +1032,8 @@ public class HonoClientImpl implements HonoClient {
 
         } else {
             LOG.debug("already trying to create a client [target: {}]", key);
-            if (isCreationLockExpired(key)) {
-                LOG.info("Releasing expired lock for {}", key);
-                creationLocks.remove(key);
-                getOrCreateRequestResponseClient(key, clientSupplier, result);
-            } else {
-                result.fail(new ServerErrorException(
-                        HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-            }
+            result.fail(new ServerErrorException(
+                    HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
         }
     }
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
index d4ac8ed8f..59b722a46 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
@@ -13,9 +13,12 @@
 
 package org.eclipse.hono.client.impl;
 
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyString;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.*;
 
 import java.net.HttpURLConnection;
@@ -27,6 +30,7 @@ import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.engine.Record;
 import org.apache.qpid.proton.engine.impl.RecordImpl;
 import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.junit.Before;
@@ -39,6 +43,7 @@ import org.mockito.ArgumentCaptor;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
 import io.vertx.proton.ProtonConnection;
@@ -60,6 +65,7 @@ public class AbstractHonoClientTest {
     @Rule
     public final Timeout timeout = Timeout.seconds(5);
 
+    private Vertx vertx;
     private Context context;
     private ClientConfigProperties props;
 
@@ -69,6 +75,7 @@ public class AbstractHonoClientTest {
     @SuppressWarnings("unchecked")
     @Before
     public void setUp() {
+        vertx = mock(Vertx.class);
         props = new ClientConfigProperties();
         context = mock(Context.class);
         doAnswer(invocation -> {
@@ -76,6 +83,7 @@ public class AbstractHonoClientTest {
             handler.handle(null);
             return null;
         }).when(context).runOnContext(any(Handler.class));
+        when(context.owner()).thenReturn(vertx);
     }
 
     /**
@@ -122,6 +130,7 @@ public class AbstractHonoClientTest {
         final Future<ProtonSender> result = AbstractHonoClient.createSender(context, props, con,
                 "target", ProtonQoS.AT_LEAST_ONCE, null);
 
+        verify(vertx).setTimer(eq(props.getLinkEstablishmentTimeout()), any(Handler.class));
         final ArgumentCaptor<Handler> openHandler = ArgumentCaptor.forClass(Handler.class);
         verify(sender).openHandler(openHandler.capture());
         openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
@@ -129,6 +138,38 @@ public class AbstractHonoClientTest {
         assertTrue(failureAssertion.test(result.cause()));
     }
 
+    /**
+     * Verifies that the attempt to create a sender fails with a
+     * {@code ServerErrorException} if the remote peer doesn't
+     * send its attach frame in time.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateSenderFailsOnTimeout(final TestContext ctx) {
+
+        final Record attachments = new RecordImpl();
+        final ProtonSender sender = mock(ProtonSender.class);
+        when(sender.attachments()).thenReturn(attachments);
+        final ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createSender(anyString())).thenReturn(sender);
+        // run any timer immediately
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgument(1);
+            handler.handle(null);
+            return 1L;
+        }).when(vertx).setTimer(anyLong(), any(Handler.class));
+
+        final Future<ProtonSender> result = AbstractHonoClient.createSender(context, props, con,
+                "target", ProtonQoS.AT_LEAST_ONCE, null);
+        assertTrue(result.failed());
+        assertThat(((ServerErrorException) result.cause()).getErrorCode(), is(HttpURLConnection.HTTP_UNAVAILABLE));
+        verify(sender).open();
+        verify(sender).close();
+        verify(sender).free();
+    }
+
     /**
      * Verifies that the attempt to create a receiver fails with a
      * {@code ServiceInvocationException} if the remote peer refuses
@@ -173,10 +214,44 @@ public class AbstractHonoClientTest {
         final Future<ProtonReceiver> result = AbstractHonoClient.createReceiver(context, props, con,
                 "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, null);
 
+        verify(vertx).setTimer(eq(props.getLinkEstablishmentTimeout()), any(Handler.class));
         final ArgumentCaptor<Handler> openHandler = ArgumentCaptor.forClass(Handler.class);
         verify(receiver).openHandler(openHandler.capture());
         openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
         assertTrue(result.failed());
         assertTrue(failureAssertion.test(result.cause()));
     }
+
+    /**
+     * Verifies that the attempt to create a receiver fails with a
+     * {@code ServerErrorException} if the remote peer doesn't
+     * send its attach frame in time.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateReceiverFailsOnTimeout(final TestContext ctx) {
+
+        final Record attachments = new RecordImpl();
+        final ProtonReceiver receiver = mock(ProtonReceiver.class);
+        when(receiver.attachments()).thenReturn(attachments);
+        final ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createReceiver(anyString())).thenReturn(receiver);
+        // run any timer immediately
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgument(1);
+            handler.handle(null);
+            return 1L;
+        }).when(vertx).setTimer(anyLong(), any(Handler.class));
+
+        final Future<ProtonReceiver> result = AbstractHonoClient.createReceiver(context, props, con,
+                "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, null);
+        assertTrue(result.failed());
+        assertThat(((ServerErrorException) result.cause()).getErrorCode(), is(HttpURLConnection.HTTP_UNAVAILABLE));
+        verify(receiver).open();
+        verify(receiver).close();
+        verify(receiver).free();
+    }
+
 }
