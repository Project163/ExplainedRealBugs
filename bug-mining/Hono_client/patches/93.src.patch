diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 352212f47..a81b8aae0 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -66,6 +66,30 @@ public interface HonoClient {
      */
     Future<HonoClient> connect();
 
+    /**
+     * Disconnects the connection to the Hono server. Upon terminating the connection to the server,
+     * this method does not automatically try to reconnect to the server again. To connect to the server,
+     * an explicit call to {@code HonoClient#connect()} should be made. Unlike {@code HonoClient#shutdown()},
+     * which does not allow to connect back to the server, this method allows to connect back to the server.
+     *
+     * Disconnecting from the Hono server is necessary when, for instance, the open frame of the connection contains
+     * permission information from an authorization service. If after connecting to the server the permissions
+     * from the service have changed, then it will be necessary to drop the connection and connect back to the server
+     * to retrieve the updated permissions.
+     *
+     */
+    void disconnect();
+
+    /**
+     * Similar to {@code HonoClient#disconnect()} but takes a handler to notify the caller about the result
+     * of the disconnect operation. The caller can use the handler to determine if the operation succeeded or failed.
+     *
+     * @param completionHandler The completion handler to notify about the success or failure of the operation. A failure could occur
+     * if this method is called in the middle of a disconnect operation.
+     * @throws NullPointerException if the completionHandler is {@code null}.
+     */
+    void disconnect(Handler<AsyncResult<Void>> completionHandler);
+
     /**
      * Connects to the Hono server using given options.
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index eadaf2827..3964eea7b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -73,6 +73,7 @@ public class HonoClientImpl implements HonoClient {
     private final List<Handler<Void>> creationRequests = new ArrayList<>();
     private final AtomicBoolean connecting = new AtomicBoolean(false);
     private final AtomicBoolean shuttingDown = new AtomicBoolean(false);
+    private final AtomicBoolean disconnecting = new AtomicBoolean(false);
     private final ConnectionFactory connectionFactory;
     protected final ClientConfigProperties clientConfigProperties;
     private final Vertx vertx;
@@ -953,38 +954,78 @@ public class HonoClientImpl implements HonoClient {
      */
     @Override
     public final void shutdown(final Handler<AsyncResult<Void>> completionHandler) {
-
+        Objects.requireNonNull(completionHandler);
         if (shuttingDown.compareAndSet(Boolean.FALSE, Boolean.TRUE)) {
-            context.runOnContext(shutDown -> {
-                if (isConnectedInternal()) {
-                    shutdownConnection(completionHandler);
-                } else {
-                    LOG.info("connection to server [{}:{}] already closed", connectionFactory.getHost(),
-                            connectionFactory.getPort());
-                    completionHandler.handle(Future.succeededFuture());
-                }
+            context.runOnContext(shutDownResult -> {
+                closeConnection(completionHandler);
             });
         } else {
-            completionHandler.handle(Future.failedFuture(new IllegalStateException("already shutting down")));
+            completionHandler.handle(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already in the middle of a shutdown operation")));
         }
     }
 
-    private void shutdownConnection(final Handler<AsyncResult<Void>> completionHandler) {
-
-        LOG.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
-        connection.disconnectHandler(null); // make sure we are not trying to re-connect
-        connection.closeHandler(closedCon -> {
-            if (closedCon.succeeded()) {
-                LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
-                        connectionFactory.getPort());
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final void disconnect() {
+        final CountDownLatch countDown = new CountDownLatch(1);
+        disconnect(disconnectResult -> {
+            if (disconnectResult.succeeded()) {
+                LOG.info("successfully disconnected from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+                countDown.countDown();
             } else {
-                LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
-                        connectionFactory.getPort(), closedCon.cause());
+                LOG.error("could not disconnect from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
             }
-            connection.disconnect();
-            if (completionHandler != null) {
-                completionHandler.handle(Future.succeededFuture());
+        });
+        try {
+            if (!countDown.await(5, TimeUnit.SECONDS)) {
+                LOG.error("Disconnecting from the server [{}:{}] timed out after 5 seconds", connectionFactory.getHost(), connectionFactory.getPort());
             }
-        }).close();
+        } catch (final InterruptedException e) {
+            Thread.currentThread().interrupt();
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
+        Objects.requireNonNull(completionHandler);
+        if (disconnecting.compareAndSet(Boolean.FALSE, Boolean.TRUE)) {
+            context.runOnContext(disconnectResult -> {
+                closeConnection(completionHandler);
+            });
+        } else {
+            completionHandler.handle(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already in the middle of a disconnect operation")));
+        }
     }
+
+    //-----------------------------------< private methods >---
+
+    private void closeConnection(final Handler<AsyncResult<Void>> completionHandler) {
+        if (isConnectedInternal()) {
+            LOG.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
+            connection.disconnectHandler(null); // make sure we are not trying to re-connect
+            connection.closeHandler(closedCon -> {
+                if (closedCon.succeeded()) {
+                    LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
+                            connectionFactory.getPort());
+                } else {
+                    LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
+                            connectionFactory.getPort(), closedCon.cause());
+                }
+                connection.disconnect();
+                disconnecting.compareAndSet(Boolean.TRUE, Boolean.FALSE);
+
+                completionHandler.handle(Future.succeededFuture());
+            }).close();
+        } else {
+            LOG.info("connection to server [{}:{}] already closed", connectionFactory.getHost(), connectionFactory.getPort());
+            disconnecting.compareAndSet(Boolean.TRUE, Boolean.FALSE);
+            completionHandler.handle(Future.succeededFuture());
+        }
+    }
+
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 5ddb86b93..16b5499c6 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -59,7 +59,7 @@ public class HonoClientImplTest {
      * Global timeout for each test case.
      */
     @Rule
-    public Timeout timeout = Timeout.seconds(5);
+    public Timeout timeout = Timeout.seconds(2);
 
     private static Vertx vertx;
 
@@ -479,6 +479,32 @@ public class HonoClientImplTest {
                 }));
     }
 
+    /**
+     * Verifies that if a client disconnects from the server, then an attempt to connect again will be succcessful.
+     *
+     * @param ctx The test execution context.
+     */
+    @Test
+    public void testConnectSucceedsAfterDisconnect(final TestContext ctx) {
+
+        // If a client disconnects from the server
+        final Async disconnectTracker = ctx.async();
+        client.disconnect(ctx.asyncAssertSuccess(succeeds -> {
+            // client successfully disconnected from remote AMQP container.
+            disconnectTracker.complete();
+        }));
+        disconnectTracker.await();
+
+        // AND tries to reconnect again
+        final Async connectionTracker = ctx.async();
+        client.connect(new ProtonClientOptions()).setHandler(
+                ctx.asyncAssertSuccess(success -> {
+                    connectionTracker.complete();
+                }));
+
+        // THEN the connection succeeds
+        connectionTracker.await();
+    }
     /**
      * Verifies that the client does not try to re-connect to a server instance if the client was shutdown.
      * 
