diff --git a/client/src/main/java/org/eclipse/hono/client/Command.java b/client/src/main/java/org/eclipse/hono/client/Command.java
index 6b47d529a..12632552a 100644
--- a/client/src/main/java/org/eclipse/hono/client/Command.java
+++ b/client/src/main/java/org/eclipse/hono/client/Command.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -18,6 +18,8 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.StringJoiner;
 
+import org.apache.qpid.proton.amqp.messaging.AmqpValue;
+import org.apache.qpid.proton.amqp.messaging.Data;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.MessageHelper;
@@ -122,6 +124,11 @@ public final class Command {
             validationErrorJoiner.add("subject not set");
         }
 
+        if (message.getBody() != null) {
+            // check for unsupported message body
+            getUnsupportedPayloadReason(message).ifPresent(validationErrorJoiner::add);
+        }
+
         String correlationId = null;
         final Object correlationIdObj = MessageHelper.getCorrelationId(message);
         if (correlationIdObj != null) {
@@ -161,7 +168,7 @@ public final class Command {
             }
         }
 
-        final Command result = new Command(
+        return new Command(
                 validationErrorJoiner.length() > 0 ? Optional.of(validationErrorJoiner.toString()) : Optional.empty(),
                 message,
                 tenantId,
@@ -169,8 +176,6 @@ public final class Command {
                 correlationId,
                 originalReplyToId,
                 getRequestId(correlationId, originalReplyToId, originalDeviceId));
-
-        return result;
     }
 
     /**
@@ -327,12 +332,10 @@ public final class Command {
     /**
      * Gets the size of this command's payload.
      *
-     * @return The payload size in bytes, 0 if the command has no payload.
+     * @return The payload size in bytes, 0 if the command has no (valid) payload.
      */
     public int getPayloadSize() {
-        return Optional.ofNullable(MessageHelper.getPayload(message))
-                .map(b -> b.length())
-                .orElse(0);
+        return MessageHelper.getPayloadSize(message);
     }
 
     /**
@@ -500,4 +503,40 @@ public final class Command {
         final String bitFlagString = encodeReplyToOptions(replyToContainedDeviceId);
         return String.format("%s/%s%s", deviceId, bitFlagString, replyToIdWithoutDeviceId);
     }
+
+    /**
+     * Validates the type of the message body containing the payload data and returns an error string if it is
+     * unsupported.
+     * <p>
+     * The message body is considered unsupported if there is a body section and it is neither
+     * <ul>
+     * <li>a Data section,</li>
+     * <li>nor an AmqpValue section containing a byte array or a String.</li>
+     * </ul>
+     *
+     * @param msg The AMQP 1.0 message to parse.
+     * @return An Optional with the error string or an empty Optional if the payload is supported or the
+     *         message has no body section.
+     * @throws NullPointerException if the message is {@code null}.
+     * @see MessageHelper#getPayload(Message)
+     */
+    private static Optional<String> getUnsupportedPayloadReason(final Message msg) {
+        Objects.requireNonNull(msg);
+
+        String reason = null;
+        if (msg.getBody() instanceof AmqpValue) {
+            final Object value = ((AmqpValue) msg.getBody()).getValue();
+            if (value == null) {
+                reason = "message has body with empty amqp-value section";
+            } else if (!(value instanceof byte[] || value instanceof String)) {
+                reason = String.format("message has amqp-value section body with unsupported value type [%s], supported is byte[] or String",
+                        value.getClass().getName());
+            }
+
+        } else if (msg.getBody() != null && !(msg.getBody() instanceof Data)) {
+            reason = String.format("message has unsupported body section [%s], supported section types are 'data' and 'amqp-value'",
+                    msg.getBody().getClass().getName());
+        }
+        return Optional.ofNullable(reason);
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/CommandTest.java b/client/src/test/java/org/eclipse/hono/client/CommandTest.java
index 1342d50a5..6aa1067f1 100644
--- a/client/src/test/java/org/eclipse/hono/client/CommandTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/CommandTest.java
@@ -19,10 +19,14 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.qpid.proton.amqp.messaging.AmqpSequence;
+import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.amqp.messaging.Section;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.Constants;
@@ -256,6 +260,35 @@ public class CommandTest {
         assertThat(cmd.getApplicationProperties()).isNull();
     }
 
+    /**
+     * Verifies that a command cannot be created from a message that has an unsupported body section.
+     */
+    @Test
+    public void testFromMessageFailsForUnsupportedMessageBody() {
+        final String replyToId = "the-reply-to-id";
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        when(message.getAddress()).thenReturn(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711"));
+        when(message.getApplicationProperties()).thenReturn(null);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
+                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
+
+        Section body = new AmqpValue(5L);
+        when(message.getBody()).thenReturn(body);
+        Command command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
+        assertFalse(command.isValid());
+        assertThat(command.getInvalidCommandReason()).contains("body");
+
+        body = new AmqpSequence(Collections.singletonList("test"));
+        when(message.getBody()).thenReturn(body);
+        command = Command.from(message, Constants.DEFAULT_TENANT, "4711");
+        assertFalse(command.isValid());
+        assertThat(command.getInvalidCommandReason()).contains("body");
+    }
+
     /**
      * Verifies that a command cannot be created from a message that neither
      * contains a message nor correlation ID.
