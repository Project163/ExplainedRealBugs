diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 17709d4ee..091ceaf87 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -30,12 +30,15 @@ import io.vertx.proton.ProtonDelivery;
  * A factory maintains a single AMQP 1.0 connection and a single
  * session to the peer. This session is shared by all AMQP 1.0 links
  * established for <em>senders</em>, <em>consumers</em> and <em>clients</em>
- * created using the factory methods.
+ * created using the corresponding factory methods.
  * <p>
  * The <em>getOrCreate</em> factory methods return an existing client for the
  * given address if available. Note that factory methods for creating consumers
- * <em>always</em> return a new instance so that all messages received are processed
- * by the given handler passed in to the factory method.
+ * <em>always</em> return a new instance so that all messages received are only
+ * processed by the handler passed in to the factory method.
+ * <p>
+ * Before any of the factory methods can be invoked successfully, the client needs
+ * to connect to Hono. This is done by invoking any of the client's <em>connect</em> methods.
  */
 public interface HonoClient {
 
@@ -47,31 +50,85 @@ public interface HonoClient {
      */
     Future<Boolean> isConnected();
 
+    /**
+     * Connects to the Hono server using default options.
+     * <p>
+     * Using the default options, the client will try to (re-)connect to the peer
+     * an unlimited number of times.
+     * 
+     * @return A future that will succeed with the connected client once the connection has been established.
+     *         The future will fail if the connection cannot be established, e.g. because
+     *         <ul>
+     *         <li>authentication of the client failed, or</li>
+     *         <li>one of the client's <em>shutdown</em> methods has been invoked before the
+     *         connection could be established.</li>
+     *         </ul>
+     */
+    Future<HonoClient> connect();
+
     /**
      * Connects to the Hono server using given options.
      * <p>
-     * This method will (re-)try to establish the connection until it succeeds if
-     * the <em>reconnectAttempts</em> property of the options is &gt; 0.
+     * The number of times that the client tries to (re-)connect to the peer is determined
+     * by the <em>reconnectAttempts</em> property of the given options. If set to -1 then
+     * the client will try to (re-)connect an unlimited number of times.
      * 
      * @param options The options to use. If {@code null} a set of default properties will be used.
-     * @return A future that will complete with the connected client once the connection has been established.
-     *         The future will fail if the connection cannot be established, e.g. because one of the client's
-     *         <em>shutdown</em> methods has been invoked already.
+     * @return A future that will succeed with the connected client once the connection has been established.
+     *         The future will fail if the connection cannot be established, e.g. because
+     *         <ul>
+     *         <li>authentication of the client failed, or</li>
+     *         <li>one of the client's <em>shutdown</em> methods has been invoked before the
+     *         connection could be established, or</li>
+     *         <li>the maximum number of (unsuccessful) (re-)connection attempts have been made.</li>
+     *         </ul>
+     * @throws NullPointerException if the options are {@code null}.
      */
     Future<HonoClient> connect(ProtonClientOptions options);
 
+    /**
+     * Connects to the Hono server using default options.
+     * <p>
+     * Using the default options, the client will try to <em>initially</em> connect to the peer
+     * an unlimited number of times. When an established connection to the server fails, the
+     * disconnect handler will be invoked. The client will <em>not</em> automatically try to
+     * re-connect to the server in this case.
+     * 
+     * @param disconnectHandler A handler to notify about connection loss.
+     * @return A future that will succeed with the connected client once the connection has been established.
+     *         The future will fail if the connection cannot be established, e.g. because
+     *         <ul>
+     *         <li>authentication of the client failed, or</li>
+     *         <li>one of the client's <em>shutdown</em> methods has been invoked before the
+     *         connection could be established.</li>
+     *         </ul>
+     * @throws NullPointerException if the disconnect handler is {@code null}.
+     */
+    Future<HonoClient> connect(Handler<ProtonConnection> disconnectHandler);
+
     /**
      * Connects to the Hono server using given options.
      * <p>
-     * This method will (re-)try to establish the connection until it succeeds if
-     * the <em>reconnectAttempts</em> property of the options is &gt; 0.
+     * The number of times that the client tries to <em>initially</em> connect to the peer
+     * is determined by the <em>reconnectAttempts</em> property of the given options.
+     * If set to -1 then the client will try to connect an unlimited number of times.
+     * <p>
+     * When an established connection to the server fails, the disconnect handler will be
+     * invoked (if not {@code null}) and the client will <em>not</em> automatically try to
+     * re-connect to the server in this case. If the disconnect handler is {@code null},
+     * the client will try to re-connect to the server using the same number of attempts
+     * as for the initial connection.
      * 
      * @param options The options to use. If {@code null} a set of default properties will be used.
      * @param disconnectHandler A handler to notify about connection loss (may be {@code null}).
-     * @return A future that will complete with the connected client once the connection has been established.
-     *         The future will fail if the connection cannot be established, e.g. because one of the client's
-     *         <em>shutdown</em> methods has been invoked already.
-     * @throws NullPointerException if the connection handler is {@code null}.
+     * @return A future that will succeed with the connected client once the connection has been established.
+     *         The future will fail if the connection cannot be established, e.g. because
+     *         <ul>
+     *         <li>authentication of the client failed, or</li>
+     *         <li>one of the client's <em>shutdown</em> methods has been invoked before the
+     *         connection could be established, or</li>
+     *         <li>the maximum number of (unsuccessful) (re-)connection attempts have been made.</li>
+     *         </ul>
      */
     Future<HonoClient> connect(
             ProtonClientOptions options,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 72e846fae..0508a4d6c 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -22,6 +22,7 @@ import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
@@ -73,6 +74,7 @@ public final class HonoClientImpl implements HonoClient {
     private ProtonClientOptions clientOptions;
     private ProtonConnection connection;
     private CacheManager cacheManager;
+    private AtomicInteger reconnectAttempts = new AtomicInteger(0);
 
     /**
      * Creates a new client for a set of configuration properties.
@@ -126,6 +128,9 @@ public final class HonoClientImpl implements HonoClient {
         this.cacheManager = Objects.requireNonNull(manager);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<Boolean> isConnected() {
 
@@ -162,11 +167,33 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<HonoClient> connect() {
+        return connect(null, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<HonoClient> connect(final ProtonClientOptions options) {
-        return connect(options, null);
+        return connect(Objects.requireNonNull(options), null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<HonoClient> connect(final Handler<ProtonConnection> disconnectHandler) {
+        return connect(null, Objects.requireNonNull(disconnectHandler));
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<HonoClient> connect(
             final ProtonClientOptions options,
@@ -194,7 +221,11 @@ public final class HonoClientImpl implements HonoClient {
             } else if (connecting.compareAndSet(false, true)) {
 
                 if (options == null) {
-                    clientOptions = new ProtonClientOptions();
+                    // by default, try to re-connect forever
+                    clientOptions = new ProtonClientOptions()
+                            .setConnectTimeout(200)
+                            .setReconnectAttempts(-1)
+                            .setReconnectInterval(Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS);
                 } else {
                     clientOptions = options;
                 }
@@ -206,9 +237,15 @@ public final class HonoClientImpl implements HonoClient {
                         conAttempt -> {
                             connecting.compareAndSet(true, false);
                             if (conAttempt.failed()) {
-                                reconnect(connectionHandler, disconnectHandler);
+                                if (conAttempt.cause() instanceof SecurityException) {
+                                    connectionHandler.handle(Future.failedFuture(conAttempt.cause()));
+                                } else {
+                                    reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
+                                }
                             } else {
                                 setConnection(conAttempt.result());
+                                // make sure we try to re-connect as often as we tried to connect initially
+                                reconnectAttempts = new AtomicInteger(0);
                                 if (shuttingDown.get()) {
                                     // if client was already shutdown in the meantime we give our best to cleanup connection
                                     shutdownConnection(result -> {});
@@ -277,27 +314,50 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     private void reconnect(final Handler<AsyncResult<HonoClient>> connectionHandler, final Handler<ProtonConnection> disconnectHandler) {
+        reconnect(null, connectionHandler, disconnectHandler);
+    }
+
+    private void reconnect(
+            final Throwable connectionFailureCause,
+            final Handler<AsyncResult<HonoClient>> connectionHandler,
+            final Handler<ProtonConnection> disconnectHandler) {
 
-        if (clientOptions == null || clientOptions.getReconnectAttempts() == 0) {
-            connectionHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
-        } else if (shuttingDown.get()) {
+        if (shuttingDown.get()) {
             // no need to try to re-connect
             connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
+        } else if (clientOptions.getReconnectAttempts() - reconnectAttempts.get() == 0) {
+            reconnectAttempts = new AtomicInteger(0);
+            LOG.debug("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
+                    clientOptions.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
+            if (connectionFailureCause == null) {
+                connectionHandler.handle(Future.failedFuture(
+                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
+            } else {
+                connectionHandler.handle(Future.failedFuture(connectionFailureCause));
+            }
         } else {
-            LOG.trace("scheduling re-connect attempt ...");
+            LOG.trace("scheduling attempt to re-connect ...");
+            reconnectAttempts.getAndIncrement();
             // give Vert.x some time to clean up NetClient
-            vertx.setTimer(Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS, tid -> {
-                LOG.debug("attempting to re-connect to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+            vertx.setTimer(clientOptions.getReconnectInterval(), tid -> {
+                LOG.debug("starting attempt [#{}] to re-connect to server [{}:{}]",
+                        reconnectAttempts.get(), connectionFactory.getHost(), connectionFactory.getPort());
                 connect(clientOptions, connectionHandler, disconnectHandler);
             });
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageSender> getOrCreateTelemetrySender(final String tenantId) {
         return getOrCreateTelemetrySender(tenantId, null);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageSender> getOrCreateTelemetrySender(final String tenantId, final String deviceId) {
 
@@ -322,11 +382,17 @@ public final class HonoClientImpl implements HonoClient {
         });
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageSender> getOrCreateEventSender(final String tenantId) {
         return getOrCreateEventSender(tenantId, null);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageSender> getOrCreateEventSender(
             final String tenantId,
@@ -400,6 +466,9 @@ public final class HonoClientImpl implements HonoClient {
         return result;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageConsumer> createTelemetryConsumer(
             final String tenantId,
@@ -425,6 +494,9 @@ public final class HonoClientImpl implements HonoClient {
         });
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageConsumer> createEventConsumer(
             final String tenantId,
@@ -434,6 +506,9 @@ public final class HonoClientImpl implements HonoClient {
         return createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message), closeHandler);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<MessageConsumer> createEventConsumer(
             final String tenantId,
@@ -485,6 +560,9 @@ public final class HonoClientImpl implements HonoClient {
         return result;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<CredentialsClient> getOrCreateCredentialsClient(
             final String tenantId) {
@@ -531,6 +609,9 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public Future<RegistrationClient> getOrCreateRegistrationClient(
             final String tenantId) {
@@ -633,6 +714,9 @@ public final class HonoClientImpl implements HonoClient {
         });
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public void shutdown() {
 
@@ -653,6 +737,9 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public void shutdown(final Handler<AsyncResult<Void>> completionHandler) {
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 4cffc4162..0c6c8e12d 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -16,6 +16,7 @@ package org.eclipse.hono.client.impl;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.*;
 
+import java.net.InetAddress;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
@@ -95,6 +96,32 @@ public class HonoClientImplTest {
             vertx.close(ctx.asyncAssertSuccess());
         }
     }
+
+    /**
+     * Verifies that the client tries to connect a limited
+     * number of times only.
+     * 
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testConnectFailsAfterMaxConnectionAttempts(final TestContext ctx) {
+
+        // GIVEN a client that is configured to connect
+        // to a peer that is not listening
+        props.setHost(InetAddress.getLoopbackAddress().getHostAddress());
+        props.setPort(45000);
+        client = new HonoClientImpl(vertx, props);
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setConnectTimeout(50)
+                .setReconnectAttempts(3)
+                .setReconnectInterval(50);
+
+        // WHEN the client tries to connect
+        client.connect(options).setHandler(ctx.asyncAssertFailure(t -> {
+            // THEN the connection attempt fails
+        }));
+    }
+
     /**
      * Verifies that a concurrent request to create a request-response client fails the given
      * future for tracking the attempt.
@@ -268,13 +295,16 @@ public class HonoClientImplTest {
         // expect the connection factory to be invoked twice
         // first on initial connection
         // second on reconnect
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
 
-        // GIVEN a client trying to create a sender to the peer
-        final Async connected = ctx.async();
+        // GIVEN a client trying to create a sender to a peer
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setReconnectInterval(50)
+                .setReconnectAttempts(3);
         client = new HonoClientImpl(vertx, connectionFactory, props);
-        client.connect(new ProtonClientOptions().setReconnectAttempts(1)).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
+        client.connect(options).setHandler(ctx.asyncAssertSuccess());
+        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // WHEN the downstream connection fails just when the client wants to open a sender link
         final Async senderCreationFailure = ctx.async();
@@ -296,30 +326,32 @@ public class HonoClientImplTest {
     /**
      * Verifies that the client tries to re-establish a lost connection to a server.
      * 
-     * @param ctx The Vertx test context.
+     * @param ctx The vert.x test context.
      */
     @Test
     public void testDownstreamDisconnectTriggersReconnect(final TestContext ctx) {
 
-        // expect the connection factory to be invoked twice
-        // first on initial connection
-        // second on re-connect attempt
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 2);
-
-        // GIVEN an client connected to a server
-        final Async connected = ctx.async();
+        // GIVEN an client that is connected to a peer to which the
+        // connection can be established on the third attempt only
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setReconnectInterval(50)
+                .setReconnectAttempts(3);
         client = new HonoClientImpl(vertx, connectionFactory, props);
-        client.connect(new ProtonClientOptions().setReconnectAttempts(1)).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
+        client.connect(options).setHandler(ctx.asyncAssertSuccess());
+        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        connectionFactory.setExpectedFailingConnectionAttempts(2);
+        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // WHEN the downstream connection fails
         connectionFactory.getDisconnectHandler().handle(con);
 
         // THEN the adapter reconnects to the downstream container
         assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        connectionFactory.setExpectedFailingConnectionAttempts(2);
+        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // and when the downstream connection fails again
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
         connectionFactory.getDisconnectHandler().handle(con);
 
         // THEN the adapter reconnects to the downstream container again
@@ -327,29 +359,31 @@ public class HonoClientImplTest {
     }
 
     /**
-     * Verifies that the client adapter repeatedly tries to connect until a connection is established.
+     * Verifies that the client repeatedly tries to connect until a connection is established.
      * 
      * @param ctx The test context.
      */
     @Test
     public void testConnectTriesToReconnectOnFailedConnectAttempt(final TestContext ctx) {
 
-        // GIVEN a client that cannot connect to the server
-        // expect the connection factory to fail twice and succeed on third connect attempt
+        // GIVEN a client that is configured to connect to a peer
+        // to which the connection can be established on the third attempt only
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);
         client = new HonoClientImpl(vertx, connectionFactory, props);
 
         // WHEN trying to connect
-        Async disconnectHandlerInvocation = ctx.async();
-        Async connectionEstablished = ctx.async();
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setReconnectInterval(50)
+                .setReconnectAttempts(3);
+        final Async disconnectHandlerInvocation = ctx.async();
         client.connect(
-                new ProtonClientOptions().setReconnectAttempts(1),
+                options,
                 failedCon -> disconnectHandlerInvocation.complete())
-            .setHandler(ctx.asyncAssertSuccess(ok -> connectionEstablished.complete()));
+            .setHandler(ctx.asyncAssertSuccess());
 
-        // THEN the client repeatedly tries to connect
-        connectionEstablished.await(4 * Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS);
-        // and sets the disconnect handler provided as a param in the connect method invocation
+        // THEN the client succeeds to connect on the third attempt
+        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        // and sets the disconnect handler provided as a parameter to the connect method
         connectionFactory.getDisconnectHandler().handle(con);
         disconnectHandlerInvocation.await();
     }
@@ -505,6 +539,10 @@ public class HonoClientImplTest {
             return closeHandler;
         }
 
+        public void setExpectedFailingConnectionAttempts(final int attempts) {
+            expectedFailingConnectionAttempts = new CountDownLatch(attempts);
+        }
+
         public void setExpectedSucceedingConnectionAttempts(final int attempts) {
             expectedSucceedingConnectionAttempts = new CountDownLatch(attempts);
         }
