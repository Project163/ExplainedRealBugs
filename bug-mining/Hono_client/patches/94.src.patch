diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index a81b8aae0..425ffd3db 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -39,7 +39,21 @@ import io.vertx.proton.ProtonDelivery;
  * processed by the handler passed in to the factory method.
  * <p>
  * Before any of the factory methods can be invoked successfully, the client needs to connect to Hono. This is done by
- * invoking any of the client's <em>connect</em> methods.
+ * invoking one of the client's <em>connect</em> methods.
+ * <p>
+ * An AMQP connection is established in multiple stages:
+ * <ol>
+ * <li>The client establishes a TCP connection to the peer. For this to succeed, the peer must have registered a
+ * socket listener on the IP address and port that the client is configured to use.</li>
+ * <li>The client performs a SASL handshake with the peer if required by the peer. The client needs to be
+ * configured with correct credentials in order for this stage to succeed.</li>
+ * <li>Finally, the client and the peer need to agree on AMQP 1.0 specific connection parameters like capabilities
+ * and session window size.</li>
+ * </ol>
+ * Some of the <em>connect</em> methods accept a {@code ProtonClientOptions} type parameter. Note that these options
+ * only influence the client's behavior when establishing the TCP connection with the peer. The overall behavior of
+ * the client regarding the establishment of the AMQP connection must be configured using the
+ * {@link ClientConfigProperties} passed in to the <em>newClient</em> method.
  */
 public interface HonoClient {
 
@@ -52,50 +66,56 @@ public interface HonoClient {
     Future<Void> isConnected();
 
     /**
-     * Connects to the Hono server using default options.
+     * Connects to the Hono server using default TCP client options.
+     * <p>
+     * With the default options a client will try three times to establish a TCP connection to the peer
+     * before giving up. Each attempt will be canceled after 200ms and the client will wait 500ms
+     * before making the next attempt. Note that each connection attempt is made using the same IP
+     * address that has been resolved when the method was initially invoked.
+     * <p>
+     * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
+     * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
+     * opens the AMQP connection to the peer, based on the negotiated parameters.
+     * <p>
+     * The number of times that the client should try to establish the AMQP connection with the peer
+     * can be configured by means of the <em>connectAttempts</em> property of the 
+     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * method.
      * <p>
-     * Using the default options, the client will try to (re-)connect to the peer an unlimited number of times.
+     * When an established connection to the peer fails, the client will automatically try to re-connect
+     * to the peer using the same options and behavior as used for establishing the initial connection.
      *
-     * @return A future that will succeed with the connected client once the connection has been established. The future
-     *         will fail with a {@link ServiceInvocationException} if the connection cannot be established, e.g. because
+     * @return A future that will be completed with the connected client once the connection has been established.
+     *         The future will fail with a {@link ServiceInvocationException} if the connection cannot be
+     *         established, e.g. because
      *         <ul>
      *         <li>authentication of the client failed, or</li>
      *         <li>one of the client's <em>shutdown</em> methods has been invoked before the connection could be
      *         established.</li>
+     *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
      *         </ul>
      */
     Future<HonoClient> connect();
 
     /**
-     * Disconnects the connection to the Hono server. Upon terminating the connection to the server,
-     * this method does not automatically try to reconnect to the server again. To connect to the server,
-     * an explicit call to {@code HonoClient#connect()} should be made. Unlike {@code HonoClient#shutdown()},
-     * which does not allow to connect back to the server, this method allows to connect back to the server.
-     *
-     * Disconnecting from the Hono server is necessary when, for instance, the open frame of the connection contains
-     * permission information from an authorization service. If after connecting to the server the permissions
-     * from the service have changed, then it will be necessary to drop the connection and connect back to the server
-     * to retrieve the updated permissions.
-     *
-     */
-    void disconnect();
-
-    /**
-     * Similar to {@code HonoClient#disconnect()} but takes a handler to notify the caller about the result
-     * of the disconnect operation. The caller can use the handler to determine if the operation succeeded or failed.
-     *
-     * @param completionHandler The completion handler to notify about the success or failure of the operation. A failure could occur
-     * if this method is called in the middle of a disconnect operation.
-     * @throws NullPointerException if the completionHandler is {@code null}.
-     */
-    void disconnect(Handler<AsyncResult<Void>> completionHandler);
-
-    /**
-     * Connects to the Hono server using given options.
+     * Connects to the Hono server using given TCP client options.
+     * <p>
+     * The client will try to establish a TCP connection to the peer based on the values of the
+     * <em>connectTimeout</em>, <em>reconnectAttempts</em> and <em>reconnectInterval</em> properties
+     * of the given options. Note that each connection attempt is made using the same IP
+     * address that has been resolved when the method was initially invoked.
      * <p>
-     * The number of times that the client tries to (re-)connect to the peer is determined by the
-     * <em>reconnectAttempts</em> property of the given options. If set to -1 then the client will try to (re-)connect
-     * an unlimited number of times.
+     * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
+     * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
+     * opens the AMQP connection to the peer, based on the negotiated parameters.
+     * <p>
+     * The number of times that the client should try to establish the AMQP connection with the peer
+     * can be configured by means of the <em>connectAttempts</em> property of the 
+     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * method.
+     * <p>
+     * When an established connection to the peer fails, the client will automatically try to re-connect
+     * to the peer using the same options and behavior as used for establishing the initial connection.
      *
      * @param options The options to use. If {@code null} a set of default properties will be used.
      * @return A future that will succeed with the connected client once the connection has been established. The future
@@ -104,7 +124,7 @@ public interface HonoClient {
      *         <li>authentication of the client failed, or</li>
      *         <li>one of the client's <em>shutdown</em> methods has been invoked before the connection could be
      *         established, or</li>
-     *         <li>the maximum number of (unsuccessful) (re-)connection attempts have been made.</li>
+     *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
      *         </ul>
      * @throws NullPointerException if the options are {@code null}.
      */
@@ -113,9 +133,22 @@ public interface HonoClient {
     /**
      * Connects to the Hono server using default options.
      * <p>
-     * Using the default options, the client will try to <em>initially</em> connect to the peer an unlimited number of
-     * times. When an established connection to the server fails, the disconnect handler will be invoked. The client
-     * will <em>not</em> automatically try to re-connect to the server in this case.
+     * With the default options a client will try three times to establish a TCP connection to the peer
+     * before giving up. Each attempt will be canceled after 200ms and the client will wait 500ms
+     * before making the next attempt. Note that each connection attempt is made using the same IP
+     * address that has been resolved when the method was initially invoked.
+     * <p>
+     * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
+     * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
+     * opens the AMQP connection to the peer, based on the negotiated parameters.
+     * <p>
+     * The number of times that the client should try to establish the AMQP connection with the peer
+     * can be configured by means of the <em>connectAttempts</em> property of the 
+     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * method.
+     * <p>
+     * When an established connection to the peer fails, the given disconnect handler will be invoked.
+     * Note that the client will <em>not</em> automatically try to re-connect to the peer in this case.
      *
      * @param disconnectHandler A handler to notify about connection loss.
      * @return A future that will succeed with the connected client once the connection has been established. The future
@@ -132,16 +165,26 @@ public interface HonoClient {
     /**
      * Connects to the Hono server using given options.
      * <p>
-     * The number of times that the client tries to <em>initially</em> connect to the peer is determined by the
-     * <em>reconnectAttempts</em> property of the given options. If set to -1 then the client will try to connect an
-     * unlimited number of times.
+     * The client will try to establish a TCP connection to the peer based on the values of the
+     * <em>connectTimeout</em>, <em>reconnectAttempts</em> and <em>reconnectInterval</em> properties
+     * of the given options. Note that each connection attempt is made using the same IP
+     * address that has been resolved when the method was initially invoked.
+     * <p>
+     * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
+     * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
+     * opens the AMQP connection to the peer, based on the negotiated parameters.
      * <p>
-     * When an established connection to the server fails, the disconnect handler will be invoked (if not {@code null})
-     * and the client will <em>not</em> automatically try to re-connect to the server in this case. If the disconnect
-     * handler is {@code null}, the client will try to re-connect to the server using the same number of attempts as for
-     * the initial connection.
+     * The number of times that the client should try to establish the AMQP connection with the peer
+     * can be configured by means of the <em>connectAttempts</em> property of the 
+     * {@code ClientConfigProperties} passed in to the {@link #newClient(Vertx, ClientConfigProperties)}
+     * method.
+     * <p>
+     * When an established connection to the peer fails, the given disconnect handler will be invoked.
+     * Note that the client will <em>not</em> automatically try to re-connect to the peer in this case.
+     * If the disconnect handler is {@code null}, the client will automatically try to re-connect
+     * to the peer using the same options and behavior as used for establishing the initial connection.
      *
-     * @param options The options to use. If {@code null} a set of default properties will be used.
+     * @param options The options to use. If {@code null} the default properties will be used.
      * @param disconnectHandler A handler to notify about connection loss (may be {@code null}).
      * @return A future that will succeed with the connected client once the connection has been established. The future
      *         will fail with a {@link ServiceInvocationException} if the connection cannot be established, e.g. because
@@ -156,6 +199,30 @@ public interface HonoClient {
             ProtonClientOptions options,
             Handler<ProtonConnection> disconnectHandler);
 
+    /**
+     * Disconnects the connection to the Hono server. Upon terminating the connection to the server,
+     * this method does not automatically try to reconnect to the server again. To connect to the server,
+     * an explicit call to {@code HonoClient#connect()} should be made. Unlike {@code HonoClient#shutdown()},
+     * which does not allow to connect back to the server, this method allows to connect back to the server.
+     *
+     * Disconnecting from the Hono server is necessary when, for instance, the open frame of the connection contains
+     * permission information from an authorization service. If after connecting to the server the permissions
+     * from the service have changed, then it will be necessary to drop the connection and connect back to the server
+     * to retrieve the updated permissions.
+     *
+     */
+    void disconnect();
+
+    /**
+     * Similar to {@code HonoClient#disconnect()} but takes a handler to notify the caller about the result
+     * of the disconnect operation. The caller can use the handler to determine if the operation succeeded or failed.
+     *
+     * @param completionHandler The completion handler to notify about the success or failure of the operation. A failure could occur
+     * if this method is called in the middle of a disconnect operation.
+     * @throws NullPointerException if the completionHandler is {@code null}.
+     */
+    void disconnect(Handler<AsyncResult<Void>> completionHandler);
+
     /**
      * Gets a client for sending telemetry messages to a Hono server.
      *
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 79899d954..77d0beb77 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -99,7 +99,7 @@ public class HonoClientImpl implements HonoClient {
 
     private ProtonClientOptions clientOptions;
     private CacheProvider cacheProvider;
-    private AtomicInteger reconnectAttempts = new AtomicInteger(0);
+    private AtomicInteger connectAttempts;
     private List<Symbol> offeredCapabilities = Collections.emptyList();
 
     /**
@@ -144,6 +144,7 @@ public class HonoClientImpl implements HonoClient {
         }
         this.context = this.vertx.getOrCreateContext();
         this.clientConfigProperties = clientConfigProperties;
+        this.connectAttempts = new AtomicInteger(0);
     }
 
     /**
@@ -288,15 +289,18 @@ public class HonoClientImpl implements HonoClient {
             } else if (connecting.compareAndSet(false, true)) {
 
                 if (options == null) {
-                    // by default, try to re-connect forever
+                    // by default, try to establish the TCP connection
+                    // three times before giving up
                     clientOptions = new ProtonClientOptions()
                             .setConnectTimeout(200)
-                            .setReconnectAttempts(-1)
+                            .setReconnectAttempts(3)
                             .setReconnectInterval(Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS);
                 } else {
                     clientOptions = options;
                 }
 
+                LOG.debug("starting attempt [#{}] to connect to server [{}:{}]",
+                        connectAttempts.get() + 1, connectionFactory.getHost(), connectionFactory.getPort());
                 connectionFactory.connect(
                         clientOptions,
                         remoteClose -> onRemoteClose(remoteClose, disconnectHandler),
@@ -306,8 +310,6 @@ public class HonoClientImpl implements HonoClient {
                             if (conAttempt.failed()) {
                                 reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
                             } else {
-                                // make sure we try to re-connect as often as we tried to connect initially
-                                reconnectAttempts = new AtomicInteger(0);
                                 final ProtonConnection newConnection = conAttempt.result();
                                 if (shuttingDown.get()) {
                                     // if client was shut down in the meantime, we need to immediately
@@ -315,6 +317,8 @@ public class HonoClientImpl implements HonoClient {
                                     newConnection.closeHandler(null);
                                     newConnection.disconnectHandler(null);
                                     newConnection.close();
+                                    // make sure we try to re-connect as often as we tried to connect initially
+                                    connectAttempts = new AtomicInteger(0);
                                     connectionHandler.handle(Future.failedFuture(
                                             new ClientErrorException(HttpURLConnection.HTTP_CONFLICT,
                                                     "client is already shut down")));
@@ -364,19 +368,25 @@ public class HonoClientImpl implements HonoClient {
         }
 
         final ProtonConnection failedConnection = this.connection;
+        clearState();
+
+        if (connectionLossHandler != null) {
+            connectionLossHandler.handle(failedConnection);
+        } else {
+            reconnect(attempt -> {}, null);
+        }
+    }
+
+    private void clearState() {
+
         setConnection(null);
         offeredCapabilities = Collections.emptyList();
 
         activeSenders.clear();
         activeRequestResponseClients.clear();
         failAllCreationRequests();
-
-        if (connectionLossHandler != null) {
-            connectionLossHandler.handle(failedConnection);
-        } else {
-            reconnect(attempt -> {
-            }, null);
-        }
+        // make sure we make configured number of attempts to re-connect
+        connectAttempts = new AtomicInteger(0);
     }
 
     private void failAllCreationRequests() {
@@ -400,10 +410,10 @@ public class HonoClientImpl implements HonoClient {
         if (shuttingDown.get()) {
             // no need to try to re-connect
             connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
-        } else if (clientOptions.getReconnectAttempts() - reconnectAttempts.get() == 0) {
-            reconnectAttempts = new AtomicInteger(0);
+        } else if (clientConfigProperties.getReconnectAttempts() - connectAttempts.getAndIncrement() == 0) {
             LOG.debug("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
-                    clientOptions.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
+                    clientConfigProperties.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
+            connectAttempts = new AtomicInteger(0);
             if (connectionFailureCause == null) {
                 connectionHandler.handle(Future.failedFuture(
                         new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
@@ -417,12 +427,9 @@ public class HonoClientImpl implements HonoClient {
                                 connectionFailureCause)));
             }
         } else {
-            LOG.trace("scheduling attempt to re-connect ...");
-            reconnectAttempts.getAndIncrement();
+            LOG.trace("scheduling new attempt to connect ...");
             // give Vert.x some time to clean up NetClient
             vertx.setTimer(clientOptions.getReconnectInterval(), tid -> {
-                LOG.debug("starting attempt [#{}] to re-connect to server [{}:{}]",
-                        reconnectAttempts.get(), connectionFactory.getHost(), connectionFactory.getPort());
                 connect(clientOptions, connectionHandler, disconnectHandler);
             });
         }
@@ -1036,38 +1043,38 @@ public class HonoClientImpl implements HonoClient {
     public final void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
         Objects.requireNonNull(completionHandler);
         if (disconnecting.compareAndSet(Boolean.FALSE, Boolean.TRUE)) {
-            context.runOnContext(disconnectResult -> {
-                closeConnection(completionHandler);
-            });
+            closeConnection(completionHandler);
         } else {
-            completionHandler.handle(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already in the middle of a disconnect operation")));
+            completionHandler.handle(Future.failedFuture(
+                    new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already disconnecting")));
         }
     }
 
     //-----------------------------------< private methods >---
 
     private void closeConnection(final Handler<AsyncResult<Void>> completionHandler) {
-        if (isConnectedInternal()) {
-            LOG.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
-            connection.disconnectHandler(null); // make sure we are not trying to re-connect
-            connection.closeHandler(closedCon -> {
-                if (closedCon.succeeded()) {
-                    LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
-                            connectionFactory.getPort());
-                } else {
-                    LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
-                            connectionFactory.getPort(), closedCon.cause());
-                }
-                connection.disconnect();
-                disconnecting.compareAndSet(Boolean.TRUE, Boolean.FALSE);
-
-                completionHandler.handle(Future.succeededFuture());
-            }).close();
-        } else {
-            LOG.info("connection to server [{}:{}] already closed", connectionFactory.getHost(), connectionFactory.getPort());
+        context.runOnContext(close -> {
+            if (isConnectedInternal()) {
+                LOG.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
+                final ProtonConnection connectionToClose = connection;
+                connectionToClose.disconnectHandler(null); // make sure we are not trying to re-connect
+                connectionToClose.closeHandler(closedCon -> {
+                    if (closedCon.succeeded()) {
+                        LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
+                                connectionFactory.getPort());
+                    } else {
+                        LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
+                                connectionFactory.getPort(), closedCon.cause());
+                    }
+                    connectionToClose.disconnect();
+                });
+                connectionToClose.close();
+                clearState();
+            } else {
+                LOG.info("connection to server [{}:{}] already closed", connectionFactory.getHost(), connectionFactory.getPort());
+            }
             disconnecting.compareAndSet(Boolean.TRUE, Boolean.FALSE);
             completionHandler.handle(Future.succeededFuture());
-        }
+        });
     }
-
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 16b5499c6..d464652fe 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -17,9 +17,8 @@ import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.*;
 
 import java.net.HttpURLConnection;
-import java.net.InetAddress;
+import java.util.Objects;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
@@ -59,7 +58,7 @@ public class HonoClientImplTest {
      * Global timeout for each test case.
      */
     @Rule
-    public Timeout timeout = Timeout.seconds(2);
+    public Timeout timeout = Timeout.seconds(3);
 
     private static Vertx vertx;
 
@@ -109,21 +108,25 @@ public class HonoClientImplTest {
     @Test
     public void testConnectFailsAfterMaxConnectionAttempts(final TestContext ctx) {
 
-        // GIVEN a client that is configured to connect
-        // to a peer that is not listening
-        props.setHost(InetAddress.getLoopbackAddress().getHostAddress());
-        props.setPort(45000);
-        client = new HonoClientImpl(vertx, props);
-        final ProtonClientOptions options = new ProtonClientOptions()
-                .setConnectTimeout(50)
-                .setReconnectAttempts(3)
-                .setReconnectInterval(50);
+        // GIVEN a client that is configured to reconnect
+        // two times before failing
+        props.setReconnectAttempts(2);
+        // expect three unsuccessful connection attempts
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(3);
+        client = new HonoClientImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setConnectTimeout(10)
+                .setReconnectAttempts(0)
+                .setReconnectInterval(100);
         client.connect(options).setHandler(ctx.asyncAssertFailure(t -> {
             // THEN the connection attempt fails
             ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) t).getErrorCode());
         }));
+        // and the client has indeed tried three times in total before giving up
+        assertTrue(connectionFactory.awaitFailure());
     }
 
     /**
@@ -132,36 +135,28 @@ public class HonoClientImplTest {
      * 
      * @param ctx The vert.x test client.
      */
-    @SuppressWarnings("unchecked")
     @Test
     public void testConnectFailsWithClientErrorForSecurityException(final TestContext ctx) {
 
         // GIVEN a client that is configured to connect
         // to a peer using invalid credentials
-        props.setHost(InetAddress.getLoopbackAddress().getHostAddress());
-        props.setPort(45000);
-        props.setUsername("username");
-        props.setPassword("wrongpassword");
-        final ConnectionFactory factory = mock(ConnectionFactory.class);
-        doAnswer(invocation -> {
-            final Handler<AsyncResult<ProtonConnection>> resultHandler = invocation.getArgument(3);
-            resultHandler.handle(Future.failedFuture(new SecurityException("invalid credentials")));
-            return null;
-        }).when(factory).connect(any(ProtonClientOptions.class), any(Handler.class), any(Handler.class), any(Handler.class));
-        when(factory.getHost()).thenReturn(InetAddress.getLoopbackAddress().getHostAddress());
-        when(factory.getPort()).thenReturn(45000);
-        client = new HonoClientImpl(vertx, factory, props);
+        props.setReconnectAttempts(2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(3)
+                .failWith(new SecurityException("invalid credentials"));
+        client = new HonoClientImpl(vertx, connectionFactory, props);
         final ProtonClientOptions options = new ProtonClientOptions()
-                .setConnectTimeout(50)
-                .setReconnectAttempts(3)
+                .setConnectTimeout(10)
+                .setReconnectAttempts(0)
                 .setReconnectInterval(50);
 
         // WHEN the client tries to connect
         client.connect(options).setHandler(ctx.asyncAssertFailure(t -> {
-            // THEN the connection attempt fails after 4 overall attempts
+            // THEN the connection attempt fails due do lack of authorization
             ctx.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, ((ServiceInvocationException) t).getErrorCode());
-            verify(factory, times(4)).connect(any(ProtonClientOptions.class), any(Handler.class), any(Handler.class), any(Handler.class));
         }));
+        // and the client has indeed tried three times in total
+        assertTrue(connectionFactory.awaitFailure());
     }
 
     /**
@@ -334,18 +329,14 @@ public class HonoClientImplTest {
     @Test
     public void testDownstreamDisconnectClearsSenderCreationLocks(final TestContext ctx) {
 
-        // expect the connection factory to be invoked twice
-        // first on initial connection
-        // second on reconnect
+        // GIVEN a client connected to a peer
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
-
-        // GIVEN a client trying to create a sender to a peer
         final ProtonClientOptions options = new ProtonClientOptions()
                 .setReconnectInterval(50)
-                .setReconnectAttempts(3);
+                .setReconnectAttempts(0);
         client = new HonoClientImpl(vertx, connectionFactory, props);
         client.connect(options).setHandler(ctx.asyncAssertSuccess());
-        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // WHEN the downstream connection fails just when the client wants to open a sender link
@@ -358,7 +349,7 @@ public class HonoClientImplTest {
         // THEN the sender creation fails,
         senderCreationFailure.await();
         // the connection is re-established
-        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        assertTrue(connectionFactory.await());
         // and the next attempt to create a sender succeeds
         client.getOrCreateSender(
                 "telemetry/tenant",
@@ -375,29 +366,28 @@ public class HonoClientImplTest {
 
         // GIVEN an client that is connected to a peer to which the
         // connection can be established on the third attempt only
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
+        props.setReconnectAttempts(1);
         final ProtonClientOptions options = new ProtonClientOptions()
                 .setReconnectInterval(50)
-                .setReconnectAttempts(3);
+                .setReconnectAttempts(0);
         client = new HonoClientImpl(vertx, connectionFactory, props);
         client.connect(options).setHandler(ctx.asyncAssertSuccess());
-        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
-        connectionFactory.setExpectedFailingConnectionAttempts(2);
+        assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // WHEN the downstream connection fails
         connectionFactory.getDisconnectHandler().handle(con);
 
         // THEN the adapter reconnects to the downstream container
-        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
-        connectionFactory.setExpectedFailingConnectionAttempts(2);
+        assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // and when the downstream connection fails again
         connectionFactory.getDisconnectHandler().handle(con);
 
         // THEN the adapter reconnects to the downstream container again
-        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        assertTrue(connectionFactory.await());
     }
 
     /**
@@ -410,21 +400,23 @@ public class HonoClientImplTest {
 
         // GIVEN a client that is configured to connect to a peer
         // to which the connection can be established on the third attempt only
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(2);
+        props.setReconnectAttempts(2);
         client = new HonoClientImpl(vertx, connectionFactory, props);
 
         // WHEN trying to connect
-        final ProtonClientOptions options = new ProtonClientOptions()
-                .setReconnectInterval(50)
-                .setReconnectAttempts(3);
         final Async disconnectHandlerInvocation = ctx.async();
-        client.connect(
-                options,
-                failedCon -> disconnectHandlerInvocation.complete())
-            .setHandler(ctx.asyncAssertSuccess());
-
-        // THEN the client succeeds to connect on the third attempt
-        assertTrue(connectionFactory.await(1, TimeUnit.SECONDS));
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setConnectTimeout(10)
+                .setReconnectAttempts(0)
+                .setReconnectInterval(100);
+        client.connect(options, failedCon -> disconnectHandlerInvocation.complete()).setHandler(ctx.asyncAssertSuccess());
+
+        // THEN the client fails twice to connect
+        assertTrue(connectionFactory.awaitFailure());
+        // and succeeds to connect on the third attempt
+        assertTrue(connectionFactory.await());
         // and sets the disconnect handler provided as a parameter to the connect method
         connectionFactory.getDisconnectHandler().handle(con);
         disconnectHandlerInvocation.await();
@@ -480,7 +472,7 @@ public class HonoClientImplTest {
     }
 
     /**
-     * Verifies that if a client disconnects from the server, then an attempt to connect again will be succcessful.
+     * Verifies that if a client disconnects from the server, then an attempt to connect again will be successful.
      *
      * @param ctx The test execution context.
      */
@@ -516,9 +508,10 @@ public class HonoClientImplTest {
 
         // GIVEN a client that tries to connect to a server but does not succeed
         final Async connectionHandlerInvocation = ctx.async();
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 0, Integer.MAX_VALUE);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(Integer.MAX_VALUE);
         client = new HonoClientImpl(vertx, connectionFactory, props);
-        client.connect(new ProtonClientOptions().setReconnectAttempts(1)).setHandler(
+        client.connect().setHandler(
                 ctx.asyncAssertFailure(cause -> connectionHandlerInvocation.complete()));
 
         // WHEN client gets shutdown
@@ -535,25 +528,19 @@ public class HonoClientImplTest {
      */
     private static class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {
 
+        private final ProtonConnection connectionToCreate;
+
         private Handler<ProtonConnection> disconnectHandler;
         private Handler<AsyncResult<ProtonConnection>> closeHandler;
         private CountDownLatch expectedSucceedingConnectionAttempts;
         private CountDownLatch expectedFailingConnectionAttempts;
-        private ProtonConnection connectionToCreate;
+        private Throwable causeForFailure;
 
         DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
-            this(conToCreate, 1);
-        }
-
-        DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate, final int expectedSucceedingConnectionAttempts) {
-            this(conToCreate, expectedSucceedingConnectionAttempts, 0);
-        }
-
-        DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate, final int expectedSucceedingConnectionAttempts,
-                final int expectedFailingConnectionAttempts) {
-            this.connectionToCreate = conToCreate;
-            this.expectedSucceedingConnectionAttempts = new CountDownLatch(expectedSucceedingConnectionAttempts);
-            this.expectedFailingConnectionAttempts = new CountDownLatch(expectedFailingConnectionAttempts);
+            this.connectionToCreate = Objects.requireNonNull(conToCreate);
+            failWith(new IllegalStateException("connection refused"));
+            setExpectedFailingConnectionAttempts(0);
+            setExpectedSucceedingConnectionAttempts(1);
         }
 
         @Override
@@ -577,7 +564,7 @@ public class HonoClientImplTest {
             this.closeHandler = closeHandler;
             this.disconnectHandler = disconnectHandler;
             if (expectedFailingConnectionAttempts.getCount() > 0) {
-                connectionResultHandler.handle(Future.failedFuture("cannot connect"));
+                connectionResultHandler.handle(Future.failedFuture(causeForFailure));
                 expectedFailingConnectionAttempts.countDown();
             } else {
                 connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
@@ -613,22 +600,51 @@ public class HonoClientImplTest {
             return closeHandler;
         }
 
-        public void setExpectedFailingConnectionAttempts(final int attempts) {
+        public DisconnectHandlerProvidingConnectionFactory setExpectedFailingConnectionAttempts(final int attempts) {
             expectedFailingConnectionAttempts = new CountDownLatch(attempts);
+            return this;
         }
 
-        public void setExpectedSucceedingConnectionAttempts(final int attempts) {
+        public DisconnectHandlerProvidingConnectionFactory setExpectedSucceedingConnectionAttempts(final int attempts) {
             expectedSucceedingConnectionAttempts = new CountDownLatch(attempts);
+            return this;
         }
 
-        public boolean await(final long timeout, final TimeUnit unit) {
+        public DisconnectHandlerProvidingConnectionFactory failWith(final Throwable cause) {
+            this.causeForFailure = Objects.requireNonNull(cause);
+            return this;
+        }
+
+        /**
+         * Waits for the expected number of succeeding connection attempts to
+         * occur.
+         * 
+         * @return {@code true} if the expected number of attempts have succeeded.
+         */
+        public boolean await() {
             try {
-                return expectedSucceedingConnectionAttempts.await(timeout, unit);
+                expectedSucceedingConnectionAttempts.await();
+                return true;
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
                 return false;
             }
         }
-    }
 
+        /**
+         * Waits for the expected number of failing connection attempts to
+         * occur.
+         *  
+         * @return {@code true} if the expected number of attempts have failed.
+         */
+        public boolean awaitFailure() {
+            try {
+                expectedFailingConnectionAttempts.await();
+                return true;
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+                return false;
+            }
+        }
+    }
 }
