diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index eabe89fa8..c66befc26 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -41,6 +41,7 @@ import org.slf4j.LoggerFactory;
 
 import io.opentracing.Span;
 import io.opentracing.SpanContext;
+import io.opentracing.log.Fields;
 import io.opentracing.tag.Tags;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
@@ -252,11 +253,7 @@ public abstract class AbstractSender extends AbstractHonoClient implements Messa
         final Future<ProtonDelivery> result = Future.future();
         final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
         message.setMessageId(messageId);
-        final Map<String, Object> details = new HashMap<>(2);
-        details.put(TracingHelper.TAG_MESSAGE_ID.getKey(), messageId);
-        details.put(TracingHelper.TAG_CREDIT.getKey(), sender.getCredit());
-        details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());
-        currentSpan.log(details);
+        logMessageIdAndSenderInfo(currentSpan, messageId);
 
         final Long timerId = connection.getConfig().getSendMessageTimeout() > 0
                 ? connection.getVertx().setTimer(connection.getConfig().getSendMessageTimeout(), id -> {
@@ -279,27 +276,19 @@ public abstract class AbstractSender extends AbstractHonoClient implements Messa
             if (result.isComplete()) {
                 LOG.debug("ignoring received delivery update for message [message ID: {}]: waiting for the update has already timed out", messageId);
             } else if (deliveryUpdated.remotelySettled()) {
+                logUpdatedDeliveryState(currentSpan, messageId, deliveryUpdated);
                 if (Accepted.class.isInstance(remoteState)) {
-                    LOG.trace("message [message ID: {}] accepted by peer", messageId);
-                    currentSpan.log("message accepted by peer");
                     result.complete(deliveryUpdated);
                 } else {
                     ServiceInvocationException e = null;
                     if (Rejected.class.isInstance(remoteState)) {
                         final Rejected rejected = (Rejected) remoteState;
-                        if (rejected.getError() == null) {
-                            LOG.debug("message [message ID: {}] rejected by peer", messageId);
-                            e = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST);
-                        } else {
-                            LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
-                                    rejected.getError().getCondition(), rejected.getError().getDescription());
-                            e = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription());
-                        }
+                        e = rejected.getError() == null
+                                ? new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST)
+                                : new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription());
                     } else if (Released.class.isInstance(remoteState)) {
-                        LOG.debug("message [message ID: {}] not accepted by peer, remote state: {}", messageId, remoteState);
                         e = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE);
                     } else if (Modified.class.isInstance(remoteState)) {
-                        LOG.debug("message [message ID: {}] not accepted by peer, remote state: {}", messageId, remoteState);
                         final Modified modified = (Modified) deliveryUpdated.getRemoteState();
                         e = modified.getUndeliverableHere() ? new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)
                                 : new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE);
@@ -329,4 +318,68 @@ public abstract class AbstractSender extends AbstractHonoClient implements Messa
             return Future.failedFuture(t);
         });
     }
+
+    /**
+     * Creates a log entry in the given span with the message id and information about the sender (credits, QOS).
+     * 
+     * @param currentSpan The current span to log to.
+     * @param messageId The message id.
+     * @throws NullPointerException if currentSpan is {@code null}.
+     */
+    protected final void logMessageIdAndSenderInfo(final Span currentSpan, final String messageId) {
+        final Map<String, Object> details = new HashMap<>(3);
+        details.put(TracingHelper.TAG_MESSAGE_ID.getKey(), messageId);
+        details.put(TracingHelper.TAG_CREDIT.getKey(), sender.getCredit());
+        details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());
+        currentSpan.log(details);
+    }
+
+    /**
+     * Creates a log entry in the given span with information about the message delivery outcome given in the delivery
+     * parameter. Sets the {@link Tags#HTTP_STATUS} as well.
+     * <p>
+     * Also corresponding log output is created.
+     *
+     * @param currentSpan The current span to log to.
+     * @param messageId The message id.
+     * @param delivery The updated delivery.
+     * @throws NullPointerException if currentSpan or delivery is {@code null}.
+     */
+    protected final void logUpdatedDeliveryState(final Span currentSpan, final String messageId, final ProtonDelivery delivery) {
+        Objects.requireNonNull(currentSpan);
+        final DeliveryState remoteState = delivery.getRemoteState();
+        if (Accepted.class.isInstance(remoteState)) {
+            LOG.trace("message [message ID: {}] accepted by peer", messageId);
+            currentSpan.log("message accepted by peer");
+            Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
+        } else {
+            final Map<String, Object> events = new HashMap<>();
+            if (Rejected.class.isInstance(remoteState)) {
+                final Rejected rejected = (Rejected) delivery.getRemoteState();
+                Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_BAD_REQUEST);
+                if (rejected.getError() == null) {
+                    LOG.debug("message [message ID: {}] rejected by peer", messageId);
+                    events.put(Fields.MESSAGE, "message rejected by peer");
+                } else {
+                    LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
+                            rejected.getError().getCondition(), rejected.getError().getDescription());
+                    events.put(Fields.MESSAGE, String.format("message rejected by peer: %s, %s",
+                            rejected.getError().getCondition(), rejected.getError().getDescription()));
+                }
+            } else if (Released.class.isInstance(remoteState)) {
+                LOG.debug("message [message ID: {}] not accepted by peer, remote state: {}",
+                        messageId, remoteState.getClass().getSimpleName());
+                Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
+                events.put(Fields.MESSAGE, "message not accepted by peer, remote state: " + remoteState);
+            } else if (Modified.class.isInstance(remoteState)) {
+                final Modified modified = (Modified) delivery.getRemoteState();
+                LOG.debug("message [message ID: {}] not accepted by peer, remote state: {}",
+                        messageId, modified);
+                Tags.HTTP_STATUS.set(currentSpan, modified.getUndeliverableHere() ? HttpURLConnection.HTTP_NOT_FOUND
+                        : HttpURLConnection.HTTP_UNAVAILABLE);
+                events.put(Fields.MESSAGE, "message not accepted by peer, remote state: " + remoteState);
+            }
+            TracingHelper.logError(currentSpan, events);
+        }
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
index 5a3ca3882..cc2f7728e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
@@ -16,12 +16,14 @@ package org.eclipse.hono.client.impl;
 import java.net.HttpURLConnection;
 import java.util.Objects;
 
+import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.Command;
 import org.eclipse.hono.client.DelegatedCommandSender;
 import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.MessageHelper;
@@ -88,14 +90,91 @@ public class DelegatedCommandSenderImpl extends AbstractSender implements Delega
                 span.finish();
                 result.fail(e);
             } else {
-                // TODO improve error-handling: we have to use a different kind of sendMessageAndWaitForOutcome() here
-                //  where a non-Accepted updatedProtonDelivery.getRemoteState() does not fail the returned Future
-                //  (we want to transfer such errors as is, not by way of translating them to/from ServiceInvocationExceptions)
                 sendMessageAndWaitForOutcome(rawMessage, span).setHandler(result);
             }
         });
     }
 
+    /**
+     * Sends an AMQP 1.0 message to the peer this client is configured for and waits for the outcome of the transfer.
+     * <p>
+     * This method overrides the base implementation to also return a succeeded Future if a delivery update other than
+     * <em>Accepted</em> was received.
+     *
+     * @param message The message to send.
+     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
+     *              The span will be finished by this method and will contain an error log if
+     *              the message has not been accepted by the peer.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled)
+     *         by the consumer.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent or if no delivery update
+     *         was received from the peer within the configured timeout period
+     *         (see {@link ClientConfigProperties#getSendMessageTimeout()}).
+     * @throws NullPointerException if either of the parameters is {@code null}.
+     */
+    @Override
+    protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message, final Span currentSpan) {
+
+        Objects.requireNonNull(message);
+        Objects.requireNonNull(currentSpan);
+
+        final Future<ProtonDelivery> result = Future.future();
+        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
+        message.setMessageId(messageId);
+        logMessageIdAndSenderInfo(currentSpan, messageId);
+
+        final Long timerId = connection.getConfig().getSendMessageTimeout() > 0
+                ? connection.getVertx().setTimer(connection.getConfig().getSendMessageTimeout(), id -> {
+                    if (!result.isComplete()) {
+                        final ServerErrorException exception = new ServerErrorException(
+                                HttpURLConnection.HTTP_UNAVAILABLE,
+                                "waiting for delivery update timed out after "
+                                        + connection.getConfig().getSendMessageTimeout() + "ms");
+                        LOG.debug("waiting for delivery update timed out for message [message ID: {}] after {}ms",
+                                messageId, connection.getConfig().getSendMessageTimeout());
+                        result.fail(exception);
+                    }
+                })
+                : null;
+
+        sender.send(message, deliveryUpdated -> {
+            if (timerId != null) {
+                connection.getVertx().cancelTimer(timerId);
+            }
+            final DeliveryState remoteState = deliveryUpdated.getRemoteState();
+            if (result.isComplete()) {
+                LOG.debug("ignoring received delivery update for message [message ID: {}]: waiting for the update has already timed out", messageId);
+            } else if (deliveryUpdated.remotelySettled()) {
+                logUpdatedDeliveryState(currentSpan, messageId, deliveryUpdated);
+                result.complete(deliveryUpdated);
+            } else {
+                LOG.debug("peer did not settle message [message ID: {}, remote state: {}], failing delivery",
+                        messageId, remoteState.getClass().getSimpleName());
+                final ServiceInvocationException e = new ServerErrorException(
+                        HttpURLConnection.HTTP_INTERNAL_ERROR,
+                        "peer did not settle message, failing delivery");
+                result.fail(e);
+            }
+        });
+        LOG.trace("sent message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
+
+        return result.map(delivery -> {
+            LOG.trace("message [ID: {}] accepted by peer", messageId);
+            Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
+            currentSpan.finish();
+            return delivery;
+        }).recover(t -> {
+            TracingHelper.logError(currentSpan, t);
+            Tags.HTTP_STATUS.set(currentSpan, ServiceInvocationException.extractStatusCode(t));
+            currentSpan.finish();
+            return Future.failedFuture(t);
+        });
+    }
+
     @Override
     public Future<ProtonDelivery> sendCommandMessage(final Command command, final SpanContext spanContext) {
         Objects.requireNonNull(command);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index c7f803650..a1b2c8637 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -14,15 +14,9 @@
 package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
-import java.util.HashMap;
-import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Modified;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.DownstreamSender;
@@ -36,7 +30,6 @@ import org.eclipse.hono.util.TelemetryConstants;
 
 import io.opentracing.Span;
 import io.opentracing.SpanContext;
-import io.opentracing.log.Fields;
 import io.opentracing.tag.Tags;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -172,11 +165,7 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
 
         final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
         message.setMessageId(messageId);
-        final Map<String, Object> details = new HashMap<>(3);
-        details.put(TracingHelper.TAG_MESSAGE_ID.getKey(), messageId);
-        details.put(TracingHelper.TAG_CREDIT.getKey(), sender.getCredit());
-        details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());
-        currentSpan.log(details);
+        logMessageIdAndSenderInfo(currentSpan, messageId);
 
         final ClientConfigProperties config = connection.getConfig();
         final AtomicBoolean timeoutReached = new AtomicBoolean(false);
@@ -203,39 +192,7 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
             if (timeoutReached.get()) {
                 LOG.debug("ignoring received delivery update for message [message ID: {}]: waiting for the update has already timed out", messageId);
             } else if (deliveryUpdated.remotelySettled()) {
-                if (Accepted.class.isInstance(remoteState)) {
-                    LOG.trace("message [message ID: {}] accepted by peer", messageId);
-                    currentSpan.log("message accepted by peer");
-                    Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
-                } else {
-                    final Map<String, Object> events = new HashMap<>();
-                    if (Rejected.class.isInstance(remoteState)) {
-                        final Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
-                        Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_BAD_REQUEST);
-                        if (rejected.getError() == null) {
-                            LOG.debug("message [message ID: {}] rejected by peer", messageId);
-                            events.put(Fields.MESSAGE, "message rejected by peer");
-                        } else {
-                            LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
-                                    rejected.getError().getCondition(), rejected.getError().getDescription());
-                            events.put(Fields.MESSAGE, String.format("message rejected by peer: %s, %s",
-                                    rejected.getError().getCondition(), rejected.getError().getDescription()));
-                        }
-                    } else if (Released.class.isInstance(remoteState)) {
-                        LOG.debug("message [message ID: {}] not accepted by peer, remote state: {}",
-                                messageId, remoteState.getClass().getSimpleName());
-                        Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
-                        events.put(Fields.MESSAGE, "message not accepted by peer, remote state: " + remoteState);
-                    } else if (Modified.class.isInstance(remoteState)) {
-                        final Modified modified = (Modified) deliveryUpdated.getRemoteState();
-                        LOG.debug("message [message ID: {}] not accepted by peer, remote state: {}",
-                                messageId, modified);
-                        Tags.HTTP_STATUS.set(currentSpan, modified.getUndeliverableHere() ? HttpURLConnection.HTTP_NOT_FOUND
-                                        : HttpURLConnection.HTTP_UNAVAILABLE);
-                        events.put(Fields.MESSAGE, "message not accepted by peer, remote state: " + remoteState);
-                    }
-                    TracingHelper.logError(currentSpan, events);
-                }
+                logUpdatedDeliveryState(currentSpan, messageId, deliveryUpdated);
             } else {
                 LOG.warn("peer did not settle message [message ID: {}, remote state: {}]",
                         messageId, remoteState.getClass().getSimpleName());
