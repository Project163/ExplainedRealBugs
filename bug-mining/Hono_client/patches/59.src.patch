diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 830798ad2..83b6a7d7e 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -49,82 +49,95 @@ public interface HonoClient {
 
     /**
      * Connects to the Hono server using given options.
+     * <p>
+     * This method will (re-)try to establish the connection until it succeeds if
+     * the <em>reconnectAttempts</em> property of the options is &gt; 0.
      * 
-     * @param options The options to use (may be {@code null}).
-     * @param connectionHandler The handler to notify about the outcome of the connection attempt. Always fails if one
-     *            of the shutdown methods was called before.
-     * @throws NullPointerException if the connection handler is {@code null}.
+     * @param options The options to use. If {@code null} a set of default properties will be used.
+     * @return A future that will complete with the connected client once the connection has been established.
+     *         The future will fail if the connection cannot be established, e.g. because one of the client's
+     *         <em>shutdown</em> methods has been invoked already.
      */
-    void connect(ProtonClientOptions options, Handler<AsyncResult<HonoClient>> connectionHandler);
+    Future<HonoClient> connect(ProtonClientOptions options);
 
     /**
      * Connects to the Hono server using given options.
+     * <p>
+     * This method will (re-)try to establish the connection until it succeeds if
+     * the <em>reconnectAttempts</em> property of the options is &gt; 0.
      * 
-     * @param options The options to use (may be {@code null}).
-     * @param connectionHandler The handler to notify about the outcome of the connection attempt. Always fails if one
-     *            of the shutdown methods was called before.
+     * @param options The options to use. If {@code null} a set of default properties will be used.
      * @param disconnectHandler A handler to notify about connection loss (may be {@code null}).
+     * @return A future that will complete with the connected client once the connection has been established.
+     *         The future will fail if the connection cannot be established, e.g. because one of the client's
+     *         <em>shutdown</em> methods has been invoked already.
      * @throws NullPointerException if the connection handler is {@code null}.
      */
-    void connect(
+    Future<HonoClient> connect(
             ProtonClientOptions options,
-            Handler<AsyncResult<HonoClient>> connectionHandler,
             Handler<ProtonConnection> disconnectHandler);
 
     /**
      * Gets a client for sending telemetry messages to a Hono server.
      * 
      * @param tenantId The ID of the tenant to send messages for.
-     * @param resultHandler The handler to notify about the client.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @return A future that will complete with the sender once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected or if a concurrent request to create a sender for the same
+     *         tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
      */
-    void getOrCreateTelemetrySender(String tenantId, Handler<AsyncResult<MessageSender>> resultHandler);
+    Future<MessageSender> getOrCreateTelemetrySender(String tenantId);
 
     /**
      * Gets a client for sending telemetry messages to a Hono server.
      * 
      * @param tenantId The ID of the tenant to send messages for.
      * @param deviceId The ID of the device to send events for (may be {@code null}).
-     * @param resultHandler The handler to notify about the client.
-     * @throws NullPointerException if any of the tenantId or resultHandler is {@code null}.
+     * @return A future that will complete with the sender once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected or if a concurrent request to create a sender for the same
+     *         tenant and device is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
      */
-    void getOrCreateTelemetrySender(String tenantId, String deviceId,
-            Handler<AsyncResult<MessageSender>> resultHandler);
+    Future<MessageSender> getOrCreateTelemetrySender(String tenantId, String deviceId);
 
     /**
      * Gets a client for sending events to a Hono server.
      * 
      * @param tenantId The ID of the tenant to send events for.
-     * @param resultHandler The handler to notify about the client.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @return A future that will complete with the sender once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected or if a concurrent request to create a sender for the same
+     *         tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
      */
-    void getOrCreateEventSender(String tenantId, Handler<AsyncResult<MessageSender>> resultHandler);
+    Future<MessageSender> getOrCreateEventSender(String tenantId);
 
     /**
      * Gets a client for sending events to a Hono server.
      * 
      * @param tenantId The ID of the tenant to send events for.
      * @param deviceId The ID of the device to send events for (may be {@code null}).
-     * @param resultHandler The handler to notify about the client.
-     * @throws NullPointerException if any of the tenantId or resultHandler is {@code null}.
+     * @return A future that will complete with the sender once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected or if a concurrent request to create a sender for the same
+     *         tenant and device is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
      */
-    void getOrCreateEventSender(
-            String tenantId,
-            String deviceId,
-            Handler<AsyncResult<MessageSender>> resultHandler);
+    Future<MessageSender> getOrCreateEventSender(String tenantId, String deviceId);
 
     /**
      * Creates a new consumer of telemetry data for a tenant.
      * 
      * @param tenantId The tenant to consume data for.
      * @param telemetryConsumer The handler to invoke with every message received.
-     * @param creationHandler The handler to invoke with the outcome of the operation.
+     * @return A future that will complete with the consumer once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    void createTelemetryConsumer(
-            String tenantId,
-            Consumer<Message> telemetryConsumer,
-            Handler<AsyncResult<MessageConsumer>> creationHandler);
+    Future<MessageConsumer> createTelemetryConsumer(String tenantId, Consumer<Message> telemetryConsumer);
 
     /**
      * Creates a new consumer of events for a tenant.
@@ -134,13 +147,12 @@ public interface HonoClient {
      *
      * @param tenantId The tenant to consume events for.
      * @param eventConsumer The handler to invoke with every event received.
-     * @param creationHandler The handler to invoke with the outcome of the operation.
+     * @return A future that will complete with the consumer once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    void createEventConsumer(
-            String tenantId,
-            Consumer<Message> eventConsumer,
-            Handler<AsyncResult<MessageConsumer>> creationHandler);
+    Future<MessageConsumer> createEventConsumer(String tenantId, Consumer<Message> eventConsumer);
 
     /**
      * Creates a new consumer of events for a tenant.
@@ -151,35 +163,37 @@ public interface HonoClient {
      *
      * @param tenantId The tenant to consume events for.
      * @param eventConsumer The handler to invoke with every event received.
-     * @param creationHandler The handler to invoke with the outcome of the operation.
+     * @return A future that will complete with the consumer once the link has been established.
+     *         The future will fail if the link cannot be established, e.g. because this
+     *         client is not connected.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    void createEventConsumer(
-            String tenantId,
-            BiConsumer<ProtonDelivery, Message> eventConsumer,
-            Handler<AsyncResult<MessageConsumer>> creationHandler);
+    Future<MessageConsumer> createEventConsumer(String tenantId, BiConsumer<ProtonDelivery, Message> eventConsumer);
 
     /**
-     * Gets a client for interacting with Hono's <em>Registration</em> API.
+     * Gets a client for invoking operations on a service implementing
+     * Hono's <em>Device Registration</em> API.
      * 
      * @param tenantId The tenant to manage device registration data for.
-     * @param resultHandler The handler to invoke with the result of the operation.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @return A future that will complete with the registration client (if successful) or
+     *         fail if the client cannot be created, e.g. because the underlying connection
+     *         is not established or if a concurrent request to create a client for the same
+     *         tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
      */
-    void getOrCreateRegistrationClient(
-            String tenantId,
-            Handler<AsyncResult<RegistrationClient>> resultHandler);
+    Future<RegistrationClient> getOrCreateRegistrationClient(String tenantId);
 
     /**
      * Gets a client for interacting with Hono's <em>Credentials</em> API.
      *
      * @param tenantId The tenant to manage device credentials data for.
-     * @param resultHandler The handler to invoke with the result of the operation.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @return A future that will complete with the credentials client (if successful) or
+     *         fail if the client cannot be created, e.g. because the underlying connection
+     *         is not established or if a concurrent request to create a client for the same
+     *         tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
      */
-    void getOrCreateCredentialsClient(
-            String tenantId,
-            Handler<AsyncResult<CredentialsClient>> resultHandler);
+    Future<CredentialsClient> getOrCreateCredentialsClient(String tenantId);
 
     /**
      * Closes this client's connection to the Hono server.
@@ -199,5 +213,4 @@ public interface HonoClient {
      * @throws NullPointerException if the handler is {@code null}.
      */
     void shutdown(Handler<AsyncResult<Void>> completionHandler);
-
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index ee0534b8d..d57709ec6 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -152,60 +152,66 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     @Override
-    public void connect(final ProtonClientOptions options, final Handler<AsyncResult<HonoClient>> connectionHandler) {
-        connect(options, connectionHandler, null);
+    public Future<HonoClient> connect(final ProtonClientOptions options) {
+        return connect(options, null);
     }
 
     @Override
-    public void connect(
+    public Future<HonoClient> connect(
             final ProtonClientOptions options,
-            final Handler<AsyncResult<HonoClient>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
 
-        Objects.requireNonNull(connectionHandler);
-
+        final Future<HonoClient> result = Future.future();
         if (shuttingDown.get()) {
-            connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
+            result.fail(new IllegalStateException("client is shut down"));
         } else {
+            connect(options, result.completer(), disconnectHandler);
+        }
+        return result;
+    }
 
-            context.runOnContext(connect -> {
+    private void connect(
+            final ProtonClientOptions options,
+            final Handler<AsyncResult<HonoClient>> connectionHandler,
+            final Handler<ProtonConnection> disconnectHandler) {
 
-                if (isConnectedInternal()) {
-                    LOG.debug("already connected to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
-                    connectionHandler.handle(Future.succeededFuture(this));
-                } else if (connecting.compareAndSet(false, true)) {
+        context.runOnContext(connect -> {
 
-                    if (options == null) {
-                        clientOptions = new ProtonClientOptions();
-                    } else {
-                        clientOptions = options;
-                    }
+            if (isConnectedInternal()) {
+                LOG.debug("already connected to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+                connectionHandler.handle(Future.succeededFuture(this));
+            } else if (connecting.compareAndSet(false, true)) {
 
-                    connectionFactory.connect(
-                            clientOptions,
-                            remoteClose -> onRemoteClose(remoteClose, disconnectHandler),
-                            failedConnection -> onRemoteDisconnect(failedConnection, disconnectHandler),
-                            conAttempt -> {
-                                connecting.compareAndSet(true, false);
-                                if (conAttempt.failed()) {
-                                    reconnect(connectionHandler, disconnectHandler);
-                                } else {
-                                    setConnection(conAttempt.result());
-                                    if (shuttingDown.get()) {
-                                        // if client was already shutdown in the meantime we give our best to cleanup connection
-                                        shutdownConnection(result -> {});
-                                        connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
-                                    } else {
-                                        connectionHandler.handle(Future.succeededFuture(this));
-                                    }
-                                }
-                            });
+                if (options == null) {
+                    clientOptions = new ProtonClientOptions();
                 } else {
-                    LOG.debug("already trying to connect to server ...");
-                    connectionHandler.handle(Future.failedFuture(new IllegalStateException("already connecting to server")));
+                    clientOptions = options;
                 }
-            });
-        }
+
+                connectionFactory.connect(
+                        clientOptions,
+                        remoteClose -> onRemoteClose(remoteClose, disconnectHandler),
+                        failedConnection -> onRemoteDisconnect(failedConnection, disconnectHandler),
+                        conAttempt -> {
+                            connecting.compareAndSet(true, false);
+                            if (conAttempt.failed()) {
+                                reconnect(connectionHandler, disconnectHandler);
+                            } else {
+                                setConnection(conAttempt.result());
+                                if (shuttingDown.get()) {
+                                    // if client was already shutdown in the meantime we give our best to cleanup connection
+                                    shutdownConnection(result -> {});
+                                    connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
+                                } else {
+                                    connectionHandler.handle(Future.succeededFuture(this));
+                                }
+                            }
+                        });
+            } else {
+                LOG.debug("already trying to connect to server ...");
+                connectionHandler.handle(Future.failedFuture(new IllegalStateException("already connecting to server")));
+            }
+        });
     }
 
     private void onRemoteClose(final AsyncResult<ProtonConnection> remoteClose, final Handler<ProtonConnection> connectionLossHandler) {
@@ -263,6 +269,9 @@ public final class HonoClientImpl implements HonoClient {
 
         if (clientOptions == null || clientOptions.getReconnectAttempts() == 0) {
             connectionHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
+        } else if (shuttingDown.get()) {
+            // no need to try to re-connect
+            connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
         } else {
             LOG.trace("scheduling re-connect attempt ...");
             // give Vert.x some time to clean up NetClient
@@ -274,17 +283,17 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     @Override
-    public void getOrCreateTelemetrySender(final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
-        getOrCreateTelemetrySender(tenantId, null, resultHandler);
+    public Future<MessageSender> getOrCreateTelemetrySender(final String tenantId) {
+        return getOrCreateTelemetrySender(tenantId, null);
     }
 
     @Override
-    public void getOrCreateTelemetrySender(final String tenantId, final String deviceId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+    public Future<MessageSender> getOrCreateTelemetrySender(final String tenantId, final String deviceId) {
+
         Objects.requireNonNull(tenantId);
-        getOrCreateSender(
+        return getOrCreateSender(
                 TelemetrySenderImpl.getTargetAddress(tenantId, deviceId),
-                () -> createTelemetrySender(tenantId, deviceId),
-                resultHandler);
+                () -> createTelemetrySender(tenantId, deviceId));
     }
 
     private Future<MessageSender> createTelemetrySender(
@@ -303,22 +312,19 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     @Override
-    public void getOrCreateEventSender(final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
-        getOrCreateEventSender(tenantId, null, resultHandler);
+    public Future<MessageSender> getOrCreateEventSender(final String tenantId) {
+        return getOrCreateEventSender(tenantId, null);
     }
 
     @Override
-    public void getOrCreateEventSender(
+    public Future<MessageSender> getOrCreateEventSender(
             final String tenantId,
-            final String deviceId,
-            final Handler<AsyncResult<MessageSender>> resultHandler) {
+            final String deviceId) {
 
         Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(resultHandler);
-        getOrCreateSender(
+        return getOrCreateSender(
                 EventSenderImpl.getTargetAddress(tenantId, deviceId),
-                () -> createEventSender(tenantId, deviceId),
-                resultHandler);
+                () -> createEventSender(tenantId, deviceId));
     }
 
     private Future<MessageSender> createEventSender(
@@ -336,64 +342,64 @@ public final class HonoClientImpl implements HonoClient {
         });
     }
 
-    void getOrCreateSender(
+    Future<MessageSender> getOrCreateSender(
             final String key,
-            final Supplier<Future<MessageSender>> newSenderSupplier,
-            final Handler<AsyncResult<MessageSender>> resultHandler) {
+            final Supplier<Future<MessageSender>> newSenderSupplier) {
+
+        final Future<MessageSender> result = Future.future();
 
         context.runOnContext(get -> {
             final MessageSender sender = activeSenders.get(key);
             if (sender != null && sender.isOpen()) {
                 LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
-                resultHandler.handle(Future.succeededFuture(sender));
+                result.complete(sender);
             } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
                 // register a handler to be notified if the underlying connection to the server fails
                 // so that we can fail the result handler passed in
                 final Handler<Void> connectionFailureHandler = connectionLost -> {
                     // remove lock so that next attempt to open a sender doesn't fail
                     creationLocks.remove(key);
-                    resultHandler.handle(Future.failedFuture(
-                            new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service")));
+                    result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
                 };
                 creationRequests.add(connectionFailureHandler);
                 creationLocks.put(key, Boolean.TRUE);
                 LOG.debug("creating new message sender for {}", key);
 
                 newSenderSupplier.get().setHandler(creationAttempt -> {
+                    creationLocks.remove(key);
+                    creationRequests.remove(connectionFailureHandler);
                     if (creationAttempt.succeeded()) {
                         MessageSender newSender = creationAttempt.result();
                         LOG.debug("successfully created new message sender for {}", key);
                         activeSenders.put(key, newSender);
+                        result.tryComplete(newSender);
                     } else {
                         LOG.debug("failed to create new message sender for {}", key, creationAttempt.cause());
                         activeSenders.remove(key);
+                        result.tryFail(creationAttempt.cause());
                     }
-                    creationLocks.remove(key);
-                    creationRequests.remove(connectionFailureHandler);
-                    resultHandler.handle(creationAttempt);
                 });
 
             } else {
                 LOG.debug("already trying to create a message sender for {}", key);
-                resultHandler.handle(Future.failedFuture(new ServerErrorException(
-                        HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service")));
+                result.fail(new ServerErrorException(
+                        HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
             }
         });
+        return result;
     }
 
     @Override
-    public void createTelemetryConsumer(
+    public Future<MessageConsumer> createTelemetryConsumer(
             final String tenantId,
-            final Consumer<Message> messageConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Consumer<Message> messageConsumer) {
 
-        createConsumer(
+        return createConsumer(
                 tenantId,
-                () -> createTelemetryConsumer(tenantId, messageConsumer),
-                creationHandler);
+                () -> newTelemetryConsumer(tenantId, messageConsumer));
     }
 
-    private Future<MessageConsumer> createTelemetryConsumer(
+    private Future<MessageConsumer> newTelemetryConsumer(
             final String tenantId,
             final Consumer<Message> messageConsumer) {
 
@@ -406,27 +412,24 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     @Override
-    public void createEventConsumer(
+    public Future<MessageConsumer> createEventConsumer(
             final String tenantId,
-            final Consumer<Message> eventConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Consumer<Message> eventConsumer) {
 
-        createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message), creationHandler);
+        return createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message));
     }
 
     @Override
-    public void createEventConsumer(
+    public Future<MessageConsumer> createEventConsumer(
             final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> messageConsumer,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final BiConsumer<ProtonDelivery, Message> messageConsumer) {
 
-        createConsumer(
+        return createConsumer(
                 tenantId,
-                () -> createEventConsumer(tenantId, messageConsumer),
-                creationHandler);
+                () -> newEventConsumer(tenantId, messageConsumer));
     }
 
-    private Future<MessageConsumer> createEventConsumer(
+    private Future<MessageConsumer> newEventConsumer(
             final String tenantId,
             final BiConsumer<ProtonDelivery, Message> messageConsumer) {
 
@@ -438,50 +441,52 @@ public final class HonoClientImpl implements HonoClient {
         });
     }
 
-    void createConsumer(
+    Future<MessageConsumer> createConsumer(
             final String tenantId,
-            final Supplier<Future<MessageConsumer>> newConsumerSupplier,
-            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+            final Supplier<Future<MessageConsumer>> newConsumerSupplier) {
 
+        final Future<MessageConsumer> result = Future.future();
         context.runOnContext(get -> {
 
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
             final Handler<Void> connectionFailureHandler = connectionLost -> {
-                creationHandler.handle(Future.failedFuture(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost")));
+                result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost"));
             };
             creationRequests.add(connectionFailureHandler);
 
             newConsumerSupplier.get().setHandler(attempt -> {
                 creationRequests.remove(connectionFailureHandler);
-                creationHandler.handle(attempt);
+                if (attempt.succeeded()) {
+                    result.tryComplete(attempt.result());
+                } else {
+                    result.tryFail(attempt.cause());
+                }
             });
         });
+        return result;
     }
 
     @Override
-    public void getOrCreateCredentialsClient(
-            final String tenantId,
-            final Handler<AsyncResult<CredentialsClient>> resultHandler) {
+    public Future<CredentialsClient> getOrCreateCredentialsClient(
+            final String tenantId) {
 
         Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(resultHandler);
+        final Future<CredentialsClient> result = Future.future();
         getOrCreateRequestResponseClient(
                 CredentialsClientImpl.getTargetAddress(tenantId),
-                () -> createCredentialsClient(tenantId),
+                () -> newCredentialsClient(tenantId),
                 attempt -> {
                     if (attempt.succeeded()) {
-                        resultHandler.handle(Future.succeededFuture((CredentialsClient) attempt.result()));
+                        result.complete((CredentialsClient) attempt.result());
                     } else {
-                        resultHandler.handle(Future.failedFuture(attempt.cause()));
+                        result.fail(attempt.cause());
                     }
                 });
+        return result;
     }
 
-    private Future<RequestResponseClient> createCredentialsClient(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
+    private Future<RequestResponseClient> newCredentialsClient(final String tenantId) {
 
         return checkConnected().compose(connected -> {
 
@@ -509,25 +514,26 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     @Override
-    public void getOrCreateRegistrationClient(
-            final String tenantId,
-            final Handler<AsyncResult<RegistrationClient>> resultHandler) {
+    public Future<RegistrationClient> getOrCreateRegistrationClient(
+            final String tenantId) {
 
         Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(resultHandler);
+
+        final Future<RegistrationClient> result = Future.future();
         getOrCreateRequestResponseClient(
                 RegistrationClientImpl.getTargetAddress(tenantId),
-                () -> createRegistrationClient(tenantId),
+                () -> newRegistrationClient(tenantId),
                 attempt -> {
                     if (attempt.succeeded()) {
-                        resultHandler.handle(Future.succeededFuture((RegistrationClient) attempt.result()));
+                        result.complete((RegistrationClient) attempt.result());
                     } else {
-                        resultHandler.handle(Future.failedFuture(attempt.cause()));
+                        result.fail(attempt.cause());
                     }
                 });
+        return result;
     }
 
-    private Future<RequestResponseClient> createRegistrationClient(final String tenantId) {
+    private Future<RequestResponseClient> newRegistrationClient(final String tenantId) {
 
         Objects.requireNonNull(tenantId);
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 570a8e3e6..f18767289 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -101,7 +101,7 @@ public class HonoClientImplTest {
         // GIVEN a client that already tries to create a registration client for "tenant"
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         client.getOrCreateRequestResponseClient(
@@ -134,7 +134,7 @@ public class HonoClientImplTest {
         // GIVEN a client that tries to create a registration client for "tenant"
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async creationFailure = ctx.async();
@@ -168,10 +168,10 @@ public class HonoClientImplTest {
         // GIVEN a client that already tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
-        client.getOrCreateSender("telemetry/tenant", () -> Future.future(), result -> {});
+        client.getOrCreateSender("telemetry/tenant", () -> Future.future());
 
         // WHEN an additional, concurrent attempt is made to create a telemetry sender for "tenant"
         client.getOrCreateSender(
@@ -179,8 +179,7 @@ public class HonoClientImplTest {
                 () -> {
                     ctx.fail("should not create concurrent client");
                     return Future.succeededFuture(mock(MessageSender.class));
-                },
-                ctx.asyncAssertFailure(t -> {
+                }).setHandler(ctx.asyncAssertFailure(t -> {
                     // THEN the concurrent attempt fails without any attempt being made to create another sender
                     ctx.assertTrue(ServerErrorException.class.isInstance(t));
                 }));
@@ -198,7 +197,7 @@ public class HonoClientImplTest {
         // GIVEN a client that tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async disconnected = ctx.async();
@@ -210,8 +209,7 @@ public class HonoClientImplTest {
                     ctx.assertFalse(disconnected.isCompleted());
                     supplierInvocation.complete();
                     return Future.future();
-                },
-                ctx.asyncAssertFailure(cause -> {
+                }).setHandler(ctx.asyncAssertFailure(cause -> {
                     disconnected.complete();
                 }));
 
@@ -235,11 +233,11 @@ public class HonoClientImplTest {
         // GIVEN a client that already tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async disconnected = ctx.async();
-        client.createTelemetryConsumer("tenant", msg -> {}, ctx.asyncAssertFailure(cause -> {
+        client.createTelemetryConsumer("tenant", msg -> {}).setHandler(ctx.asyncAssertFailure(cause -> {
             disconnected.complete();
         }));
 
@@ -262,11 +260,11 @@ public class HonoClientImplTest {
         // GIVEN a client that already tries to create a telemetry sender for "tenant"
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         final Async disconnected = ctx.async();
-        client.createEventConsumer("tenant", msg -> {}, ctx.asyncAssertFailure(cause -> {
+        client.createEventConsumer("tenant", msg -> {}).setHandler(ctx.asyncAssertFailure(cause -> {
             disconnected.complete();
         }));
 
@@ -293,7 +291,7 @@ public class HonoClientImplTest {
         // GIVEN a client trying to create a sender to the peer
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions().setReconnectAttempts(1), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1)).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         // WHEN the downstream connection fails just when the client wants to open a sender link
@@ -301,7 +299,7 @@ public class HonoClientImplTest {
         client.getOrCreateSender("telemetry/tenant", () -> {
             connectionFactory.getDisconnectHandler().handle(con);
             return Future.future();
-        }, ctx.asyncAssertFailure(cause -> senderCreationFailure.complete()));
+        }).setHandler(ctx.asyncAssertFailure(cause -> senderCreationFailure.complete()));
 
         // THEN the sender creation fails,
         senderCreationFailure.await();
@@ -310,8 +308,7 @@ public class HonoClientImplTest {
         // and the next attempt to create a sender succeeds
         client.getOrCreateSender(
                 "telemetry/tenant",
-                () -> Future.succeededFuture(mock(MessageSender.class)),
-                ctx.asyncAssertSuccess());
+                () -> Future.succeededFuture(mock(MessageSender.class))).setHandler(ctx.asyncAssertSuccess());
     }
 
     /**
@@ -330,7 +327,7 @@ public class HonoClientImplTest {
         // GIVEN an client connected to a server
         final Async connected = ctx.async();
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.connect(new ProtonClientOptions().setReconnectAttempts(1), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1)).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         // WHEN the downstream connection fails
@@ -358,8 +355,8 @@ public class HonoClientImplTest {
         Async connectionEstablished = ctx.async();
         client.connect(
                 new ProtonClientOptions().setReconnectAttempts(1),
-                ctx.asyncAssertSuccess(ok -> connectionEstablished.complete()),
-                failedCon -> disconnectHandlerInvocation.complete());
+                failedCon -> disconnectHandlerInvocation.complete())
+            .setHandler(ctx.asyncAssertSuccess(ok -> connectionEstablished.complete()));
 
         // THEN the client repeatedly tries to connect
         connectionEstablished.await(4 * Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS);
@@ -384,8 +381,8 @@ public class HonoClientImplTest {
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
         client.connect(
                 new ProtonClientOptions().setReconnectAttempts(1),
-                ctx.asyncAssertSuccess(ok -> connected.complete()),
-                failedCon -> disconnectHandlerInvocation.complete());
+                failedCon -> disconnectHandlerInvocation.complete())
+            .setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
         connected.await();
 
         // WHEN the peer closes the connection
@@ -412,8 +409,7 @@ public class HonoClientImplTest {
         client.shutdown();
 
         // WHEN client connects
-        client.connect(
-                new ProtonClientOptions(),
+        client.connect(new ProtonClientOptions()).setHandler(
                 ctx.asyncAssertFailure(cause -> {
                     //THEN connect fails
                 }));
@@ -429,11 +425,10 @@ public class HonoClientImplTest {
     public void testDoesNotTriggerReconnectionAfterShutdown(final TestContext ctx) {
 
         // GIVEN a client that tries to connect to a server but does not succeed
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, Integer.MAX_VALUE);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 0, Integer.MAX_VALUE);
         final HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
         final Async connectionHandlerInvocation = ctx.async();
-        client.connect(
-                new ProtonClientOptions().setReconnectAttempts(1),
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1)).setHandler(
                 ctx.asyncAssertFailure(cause -> connectionHandlerInvocation.complete()));
 
         // WHEN client gets shutdown
