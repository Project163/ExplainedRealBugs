diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index f06fb2c65..0b15db7a5 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -163,11 +163,12 @@ public abstract class AbstractHonoClient {
             sender.setQoS(qos);
             sender.openHandler(senderOpen -> {
                 if (senderOpen.succeeded()) {
-                    LOG.debug("sender open [{}] sendQueueFull [{}]", sender.getRemoteTarget(), sender.sendQueueFull());
+                    LOG.debug("sender open [target: {}, sendQueueFull: {}]", targetAddress, sender.sendQueueFull());
                     // wait on credits a little time, if not already given
                     if (sender.sendQueueFull()) {
                         ctx.owner().setTimer(waitForInitialCredits, timerID -> {
-                            LOG.debug("waited [{}] ms on credits [{}]", waitForInitialCredits, sender.getCredit());
+                            LOG.debug("sender [target: {}] has {} credits after grace period of {}ms", targetAddress,
+                                    sender.getCredit(), waitForInitialCredits);
                             result.complete(sender);
                         });
                     } else {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index e636f7ab9..b4f49ca39 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -150,7 +150,7 @@ public final class HonoClientImpl implements HonoClient {
         Objects.requireNonNull(connectionHandler);
 
         if (shutdown) {
-            connectionHandler.handle(Future.failedFuture("client was already shutdown"));
+            connectionHandler.handle(Future.failedFuture(new IllegalStateException("client was already shutdown")));
         } else if (isConnected()) {
             LOG.debug("already connected to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
             connectionHandler.handle(Future.succeededFuture(this));
@@ -176,7 +176,7 @@ public final class HonoClientImpl implements HonoClient {
                             if (shutdown) {
                                 // if client was already shutdown in the meantime we give our best to cleanup connection
                                 shutdownConnection(result -> {});
-                                connectionHandler.handle(Future.failedFuture("client was already shutdown"));
+                                connectionHandler.handle(Future.failedFuture(new IllegalStateException("client was already shutdown")));
                             } else {
                                 connectionHandler.handle(Future.succeededFuture(this));
                             }
@@ -191,7 +191,7 @@ public final class HonoClientImpl implements HonoClient {
     private void reconnect(final Handler<AsyncResult<HonoClient>> connectionHandler, final Handler<ProtonConnection> disconnectHandler) {
 
         if (clientOptions == null || clientOptions.getReconnectAttempts() == 0) {
-            connectionHandler.handle(Future.failedFuture("failed to connect"));
+            connectionHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
         } else {
             LOG.trace("scheduling re-connect attempt ...");
             // give Vert.x some time to clean up NetClient
@@ -287,7 +287,8 @@ public final class HonoClientImpl implements HonoClient {
             final Handler<Void> connectionFailureHandler = connectionLost -> {
                 // remove lock so that next attempt to open a sender doesn't fail
                 creationLocks.remove(key);
-                resultHandler.handle(Future.failedFuture("connection to server lost"));
+                resultHandler.handle(Future.failedFuture(
+                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost")));
             };
             creationRequests.add(connectionFailureHandler);
             creationLocks.put(key, Boolean.TRUE);
@@ -309,7 +310,7 @@ public final class HonoClientImpl implements HonoClient {
 
         } else {
             LOG.debug("already trying to create a message sender for {}", key);
-            resultHandler.handle(Future.failedFuture("sender link not established yet"));
+            resultHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)));
         }
     }
 
@@ -350,7 +351,8 @@ public final class HonoClientImpl implements HonoClient {
         // register a handler to be notified if the underlying connection to the server fails
         // so that we can fail the result handler passed in
         final Handler<Void> connectionFailureHandler = connectionLost -> {
-            creationHandler.handle(Future.failedFuture("connection to server lost"));
+            creationHandler.handle(Future.failedFuture(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost")));
         };
         creationRequests.add(connectionFailureHandler);
 
@@ -407,7 +409,8 @@ public final class HonoClientImpl implements HonoClient {
         // register a handler to be notified if the underlying connection to the server fails
         // so that we can fail the result handler passed in
         final Handler<Void> connectionFailureHandler = connectionLost -> {
-            creationHandler.handle(Future.failedFuture("connection to server lost"));
+            creationHandler.handle(Future.failedFuture(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost")));
         };
         creationRequests.add(connectionFailureHandler);
 
@@ -472,7 +475,8 @@ public final class HonoClientImpl implements HonoClient {
             final Handler<Void> connectionFailureHandler = connectionLost -> {
                 // remove lock so that next attempt to open a sender doesn't fail
                 creationLocks.remove(key);
-                resultHandler.handle(Future.failedFuture("connection to server lost"));
+                resultHandler.handle(Future.failedFuture(
+                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service")));
             };
             creationRequests.add(connectionFailureHandler);
             creationLocks.put(key, Boolean.TRUE);
@@ -494,7 +498,7 @@ public final class HonoClientImpl implements HonoClient {
 
         } else {
             LOG.debug("already trying to create a client for {}", key);
-            resultHandler.handle(Future.failedFuture("request-response links not established yet"));
+            resultHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)));
         }
     }
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 007936af3..99f65b748 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -22,6 +22,7 @@ import org.eclipse.hono.client.HonoClient;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.client.RequestResponseClient;
+import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.connection.ConnectionFactory;
 import org.eclipse.hono.util.Constants;
 import org.junit.After;
@@ -89,16 +90,16 @@ public class HonoClientImplTest {
         final Async creationFailure = ctx.async();
         client.getOrCreateRequestResponseClient("registration/tenant", handler -> {
             handler.handle(Future.succeededFuture(mock(RegistrationClient.class)));
-        }, creationAttempt -> {
-            ctx.assertFalse(creationAttempt.succeeded());
+        }, ctx.asyncAssertFailure(t -> {
+            ctx.assertTrue(ServerErrorException.class.isInstance(t));
             creationFailure.complete();
-        });
-
-        // THEN the concurrent attempt fails immediately without any attempt being made to create another client
-        creationFailure.await(2000);
+        }));
 
         // succeed first creation attempt, thus invoking result handler
         firstClientTracker.complete(mock(RegistrationClient.class));
+
+        // THEN the concurrent attempt fails immediately without any attempt being made to create another client
+        creationFailure.await(2000);
     }
 
     /**
@@ -154,16 +155,16 @@ public class HonoClientImplTest {
         final Async creationFailure = ctx.async();
         client.getOrCreateSender("telemetry/tenant", handler -> {
             handler.handle(Future.succeededFuture(mock(MessageSender.class)));
-        }, creationAttempt -> {
-            ctx.assertFalse(creationAttempt.succeeded());
+        }, ctx.asyncAssertFailure(t -> {
+            ctx.assertTrue(ServerErrorException.class.isInstance(t));
             creationFailure.complete();
-        });
-
-        // THEN the concurrent attempt fails immediately without any attempt being made to create another sender
-        creationFailure.await(2000);
+        }));
 
         // succeed first creation attempt, thus invoking result handler
         firstSenderTracker.complete(mock(MessageSender.class));
+
+        // THEN the concurrent attempt fails immediately without any attempt being made to create another sender
+        creationFailure.await(2000);
     }
 
     /**
