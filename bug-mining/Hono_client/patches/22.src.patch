diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 811069dcf..26f55c3d3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -221,7 +221,6 @@ public final class HonoClientImpl implements HonoClient {
      * @see org.eclipse.hono.client.HonoClient#getOrCreateTelemetrySender(java.lang.String, java.lang.String, io.vertx.core.Handler)
      */
     @Override
-    @SuppressWarnings("unchecked")
     public HonoClient getOrCreateTelemetrySender(final String tenantId, final String deviceId, final Handler<AsyncResult<MessageSender>> resultHandler) {
         Objects.requireNonNull(tenantId);
         getOrCreateSender(
@@ -243,7 +242,6 @@ public final class HonoClientImpl implements HonoClient {
      * @see org.eclipse.hono.client.HonoClient#getOrCreateEventSender(java.lang.String, java.lang.String, io.vertx.core.Handler)
      */
     @Override
-    @SuppressWarnings("unchecked")
     public HonoClient getOrCreateEventSender(
             final String tenantId,
             final String deviceId,
@@ -258,8 +256,7 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    @SuppressWarnings("rawtypes")
-    private void getOrCreateSender(final String key, final Consumer<Handler> newSenderSupplier,
+    void getOrCreateSender(final String key, final Consumer<Handler<AsyncResult<MessageSender>>> newSenderSupplier,
             final Handler<AsyncResult<MessageSender>> resultHandler) {
 
         final MessageSender sender = activeSenders.get(key);
@@ -269,8 +266,8 @@ public final class HonoClientImpl implements HonoClient {
         } else if (!senderCreationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
             senderCreationLocks.put(key, Boolean.TRUE);
             LOG.debug("creating new message sender for {}", key);
-            final Future<MessageSender> internal = Future.future();
-            internal.setHandler(creationAttempt -> {
+
+            newSenderSupplier.accept(creationAttempt -> {
                 if (creationAttempt.succeeded()) {
                     MessageSender newSender = creationAttempt.result();
                     LOG.debug("successfully created new message sender for {}", key);
@@ -282,7 +279,7 @@ public final class HonoClientImpl implements HonoClient {
                 senderCreationLocks.remove(key);
                 resultHandler.handle(creationAttempt);
             });
-            newSenderSupplier.accept(internal.completer());
+
         } else {
             LOG.debug("already trying to create a message sender for {}", key);
             resultHandler.handle(Future.failedFuture("sender link not established yet"));
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 6b98654b5..35ef0fc8e 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -12,22 +12,20 @@
 
 package org.eclipse.hono.client.impl;
 
-import static org.mockito.Mockito.*;
+import static org.mockito.Mockito.mock;
 
-import org.eclipse.hono.client.impl.HonoClientImpl;
+import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.connection.ConnectionFactory;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import io.vertx.core.Handler;
+import io.vertx.core.Future;
 import io.vertx.core.Vertx;
 import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
-import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonSender;
 
 /**
  * Test cases verifying the behavior of {@code HonoClient}.
@@ -61,33 +59,32 @@ public class HonoClientImplTest {
      * 
      * @param ctx The helper to use for running async tests.
      */
-    @SuppressWarnings("unchecked")
     @Test
     public void testGetOrCreateTelemetrySenderFailsIfInvokedConcurrently(final TestContext ctx) {
 
         // GIVEN a client that already tries to create a telemetry sender for "tenant"
         ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-        ProtonConnection con = mock(ProtonConnection.class);
-        ProtonSender sender = mock(ProtonSender.class);
-        when(con.createSender("telemetry/tenant")).thenReturn(sender);
-        when(sender.openHandler(any(Handler.class))).thenReturn(sender);
-        when(sender.closeHandler(any(Handler.class))).thenReturn(sender);
         HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
-        client.setConnection(con);
-        client.setContext(vertx.getOrCreateContext());
-        client.getOrCreateTelemetrySender("tenant", creationAttempt -> {
-            ctx.fail("should not have created sender");
-        });
+        final Future<MessageSender> firstSenderTracker = Future.future();
+        client.getOrCreateSender("telemetry/tenant", handler -> {
+            firstSenderTracker.setHandler(creationAttempt -> {
+                handler.handle(creationAttempt);
+            });
+        }, result -> {});
 
         // WHEN an additional, concurrent attempt is made to create a telemetry sender for "tenant"
         final Async creationFailure = ctx.async();
-        client.getOrCreateTelemetrySender("tenant", creationAttempt -> {
+        client.getOrCreateSender("telemetry/tenant", handler -> {
+            handler.handle(Future.succeededFuture(mock(MessageSender.class)));
+        }, creationAttempt -> {
             ctx.assertFalse(creationAttempt.succeeded());
             creationFailure.complete();
         });
 
         // THEN the concurrent attempt fails immediately without any attempt being made to create another sender
         creationFailure.await(2000);
-        verify(con).createSender("telemetry/tenant");
+
+        // succeed first creation attempt, thus invoking result handler
+        firstSenderTracker.complete(mock(MessageSender.class));
     }
 }
