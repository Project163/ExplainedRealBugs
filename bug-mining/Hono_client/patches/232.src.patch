diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
index 65ac1df05..c0e5b638d 100644
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
@@ -98,6 +98,10 @@ public interface DeviceConnectionClient extends RequestResponseClient {
      * @return A future indicating the outcome of the operation, with its value indicating whether the protocol
      *         adapter instance value was removed or not.
      *         <p>
+     *         NOTE: this method maps an outcome with status 404 or 412 as defined in the
+     *         <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
+     *         specification</a> to a succeeded future with value {@code false} here.
+     *         <p>
      *         The future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException} if there
      *         was an error removing the value.
      * @throws NullPointerException if device id or adapter instance id is {@code null}.
diff --git a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java
index b99d8bdfc..0cc598926 100644
--- a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumer.java
@@ -26,7 +26,10 @@ public interface ProtocolAdapterCommandConsumer {
      * Closes the consumer.
      *
      * @param spanContext The span context (may be {@code null}).
-     * @return A future indicating the outcome of the operation.
+     * @return A future indicating the outcome of the operation. The future will be failed with a
+     *         {@link ServiceInvocationException} if there was an error closing the consumer and with a
+     *         {@link ClientErrorException} with {@link java.net.HttpURLConnection#HTTP_PRECON_FAILED} if the consumer
+     *         was found to have been closed/overwritten already.
      */
     Future<Void> close(SpanContext spanContext);
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
index 6dad3bd2e..967019197 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
@@ -131,7 +131,7 @@ public final class AdapterInstanceCommandHandler {
      * @param commandHandler The command handler. The handler must invoke one of the terminal methods of the passed
      *                       in {@link CommandContext} in order to settle the command message transfer and finish
      *                       the trace span associated with the {@link CommandContext}.
-     * @return The previous handler entry or {@code null} if there was none.
+     * @return The replaced handler entry or {@code null} if there was none.
      * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.
      */
     public CommandHandlerWrapper putDeviceSpecificCommandHandler(final String tenantId, final String deviceId,
@@ -140,11 +140,25 @@ public final class AdapterInstanceCommandHandler {
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(commandHandler);
 
-        final String key = getDeviceKey(tenantId, deviceId);
+        return putDeviceSpecificCommandHandler(new CommandHandlerWrapper(tenantId, deviceId, gatewayId, commandHandler));
+    }
+
+    /**
+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
+     *
+     * @param commandHandlerWrapper The wrapper containing the command handler and device/gateway identifier.
+     * @return The replaced entry or {@code null} if there was none.
+     * @throws NullPointerException If commandHandlerWrapper is {@code null}.
+     */
+    public CommandHandlerWrapper putDeviceSpecificCommandHandler(final CommandHandlerWrapper commandHandlerWrapper) {
+        Objects.requireNonNull(commandHandlerWrapper);
+
+        final String key = getDeviceKey(commandHandlerWrapper);
         if (commandHandlers.containsKey(key)) {
-            LOG.debug("replacing existing command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
+            LOG.debug("replacing existing command handler [tenant-id: {}, device-id: {}]",
+                    commandHandlerWrapper.getTenantId(), commandHandlerWrapper.getDeviceId());
         }
-        return commandHandlers.put(key, new CommandHandlerWrapper(tenantId, deviceId, gatewayId, commandHandler));
+        return commandHandlers.put(key, commandHandlerWrapper);
     }
 
     /**
@@ -189,6 +203,24 @@ public final class AdapterInstanceCommandHandler {
         return removedHandler != null;
     }
 
+    /**
+     * Removes the given handler.
+     *
+     * @param commandHandlerWrapper The handler to remove.
+     * @return {@code true} if the handler was removed.
+     * @throws NullPointerException If commandHandlerWrapper is {@code null}.
+     */
+    public boolean removeDeviceSpecificCommandHandler(final CommandHandlerWrapper commandHandlerWrapper) {
+        Objects.requireNonNull(commandHandlerWrapper);
+        final boolean removed = commandHandlers.remove(getDeviceKey(commandHandlerWrapper), commandHandlerWrapper);
+        LOG.trace("Removed {}: {}", commandHandlerWrapper, removed);
+        return removed;
+    }
+
+    private String getDeviceKey(final CommandHandlerWrapper commandHandlerWrapper) {
+        return getDeviceKey(commandHandlerWrapper.getTenantId(), commandHandlerWrapper.getDeviceId());
+    }
+
     private String getDeviceKey(final String tenantId, final String deviceId) {
         return Device.asAddress(tenantId, deviceId);
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
index 750076096..4485ce964 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
@@ -90,8 +90,9 @@ public final class CommandHandlerWrapper {
     @Override
     public String toString() {
         return "CommandHandlerWrapper{" +
-                "deviceId='" + deviceId + '\'' +
-                ", gatewayId='" + gatewayId + '\'' +
+                "tenantId='" + tenantId + '\'' +
+                ", deviceId='" + deviceId + '\'' +
+                (gatewayId != null ? (", gatewayId='" + gatewayId + '\'') : "") +
                 '}';
     }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
index f3adfc2d1..c1c8cd6cf 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
@@ -15,6 +15,7 @@ package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
 import java.time.Duration;
+import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
@@ -23,6 +24,7 @@ import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;
+import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.CommandContext;
 import org.eclipse.hono.client.CommandResponseSender;
 import org.eclipse.hono.client.CommandTargetMapper;
@@ -165,18 +167,23 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
             getOrCreateMappingAndDelegatingCommandConsumer(tenantId)
                     .compose(res -> {
                         // register the command handler
+                        final CommandHandlerWrapper commandHandlerWrapper = new CommandHandlerWrapper(tenantId,
+                                deviceId, gatewayId, commandHandler);
                         final CommandHandlerWrapper replacedHandler = adapterInstanceCommandHandler
-                                .putDeviceSpecificCommandHandler(tenantId, deviceId, gatewayId, commandHandler);
+                                .putDeviceSpecificCommandHandler(commandHandlerWrapper);
                         if (replacedHandler != null) {
                             // TODO find a way to provide a notification here so that potential resources associated with the replaced consumer can be freed (maybe add a commandHandlerOverwritten Handler param to createCommandConsumer())
                         }
                         // associate handler with this adapter instance
-                        return setCommandHandlingAdapterInstance(tenantId, deviceId, sanitizedLifespan, context);
-                    })
-                    .map(res -> {
-                        final Function<SpanContext, Future<Void>> onCloseAction = onCloseSpanContext -> removeCommandConsumer(tenantId, deviceId,
-                                onCloseSpanContext);
-                        return (ProtocolAdapterCommandConsumer) new ProtocolAdapterCommandConsumerImpl(onCloseAction);
+                        final Instant lifespanStart = Instant.now();
+                        return setCommandHandlingAdapterInstance(tenantId, deviceId, sanitizedLifespan, context)
+                                .map(v -> {
+                                    final Function<SpanContext, Future<Void>> onCloseAction = onCloseSpanContext -> {
+                                        return removeCommandConsumer(commandHandlerWrapper, sanitizedLifespan,
+                                                lifespanStart, onCloseSpanContext);
+                                    };
+                                    return (ProtocolAdapterCommandConsumer) new ProtocolAdapterCommandConsumerImpl(onCloseAction);
+                                });
                     })
                     .onComplete(result);
         });
@@ -195,11 +202,28 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                 });
     }
 
-    private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId,
-            final SpanContext onCloseSpanContext) {
-        log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
-        adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
+    private Future<Void> removeCommandConsumer(final CommandHandlerWrapper commandHandlerWrapper, final Duration lifespan,
+            final Instant lifespanStart, final SpanContext onCloseSpanContext) {
+
+        final String tenantId = commandHandlerWrapper.getTenantId();
+        final String deviceId = commandHandlerWrapper.getDeviceId();
 
+        log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
+        if (!adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(commandHandlerWrapper)) {
+            // This case happens when trying to remove a command consumer which has been overwritten since its creation
+            // via a 2nd invocation of 'createCommandConsumer' with the same device/tenant id. Since the 2nd 'createCommandConsumer'
+            // invocation has registered a different 'commandHandlerWrapper' instance (and possibly already removed it),
+            // trying to remove the original object will return false here.
+            // On a more abstract level, this case happens when 2 consecutive command subscription requests from the
+            // same device (with no intermittent disconnect/unsubscribe - possibly because of a broken connection in between) have
+            // reached the *same* adapter instance and verticle, using this CommandConsumerFactory. Invoking 'removeCommandConsumer'
+            // on the 1st (obsolete and overwritten) command subscription shall have no impact. Throwing an explicit exception
+            // here will enable the protocol adapter to detect this case and skip an (incorrect) "disconnectedTtd" event message.
+            log.debug("command consumer not removed - handler already replaced or removed [tenant: {}, device: {}]",
+                    tenantId, deviceId);
+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,
+                    "local command handler already replaced or removed"));
+        }
         return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
                 .compose(client -> client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId,
                         onCloseSpanContext))
@@ -208,7 +232,23 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                             deviceId, thr);
                     return Future.failedFuture(thr);
                 })
-                .mapEmpty();
+                .compose(removed -> {
+                    final boolean entryNotExpired = lifespan.isNegative() || Instant.now().isBefore(lifespanStart.plus(lifespan));
+                    if (!removed && entryNotExpired) {
+                        // entry wasn't actually removed and entry hasn't expired (yet);
+                        // This case happens when 2 consecutive command subscription requests from the same device
+                        // (with no intermittent disconnect/unsubscribe - possibly because of a broken connection in between)
+                        // have reached *different* protocol adapter instances/verticles. Now calling 'removeCommandHandlingAdapterInstance'
+                        // on the 1st subscription fails because of the non-matching adapterInstanceId parameter.
+                        // Throwing an explicit exception here will enable the protocol adapter to detect this case
+                        // and skip sending an (incorrect) "disconnectedTtd" event message.
+                        log.debug("command handling adapter instance not removed - not matched or already removed [tenant: {}, device: {}]",
+                                tenantId, deviceId);
+                        return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,
+                                "no matching command consumer mapping found to be removed"));
+                    }
+                    return Future.succeededFuture((Void) null);
+                });
     }
 
     private Future<MessageConsumer> getOrCreateMappingAndDelegatingCommandConsumer(final String tenantId) {
