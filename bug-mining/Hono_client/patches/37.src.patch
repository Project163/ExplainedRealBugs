diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 3f9628812..5cc0b20fe 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -13,6 +13,7 @@
 package org.eclipse.hono.client;
 
 import java.util.Map;
+import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 
 import org.apache.qpid.proton.message.Message;
@@ -22,6 +23,7 @@ import io.vertx.core.Handler;
 import io.vertx.core.json.JsonArray;
 import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
 
 /**
  * A factory for creating clients for Hono's arbitrary APIs.
@@ -153,6 +155,9 @@ public interface HonoClient {
 
     /**
      * Creates a new consumer of events for a tenant.
+     * <p>
+     * The events passed in to the registered eventConsumer will be settled
+     * automatically if the consumer does not throw an exception.
      * 
      * @param tenantId The tenant to consume events for.
      * @param eventConsumer The handler to invoke with every event received.
@@ -165,6 +170,24 @@ public interface HonoClient {
             Consumer<Message> eventConsumer,
             Handler<AsyncResult<MessageConsumer>> creationHandler);
 
+    /**
+     * Creates a new consumer of events for a tenant.
+     * <p>
+     * The events passed in to the registered eventConsumer will be settled
+     * automatically if the consumer does not throw an exception and does not
+     * manually handle the message disposition using the passed in delivery.
+     * 
+     * @param tenantId The tenant to consume events for.
+     * @param eventConsumer The handler to invoke with every event received.
+     * @param creationHandler The handler to invoke with the outcome of the operation.
+     * @return This client for command chaining.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    HonoClient createEventConsumer(
+            String tenantId,
+            BiConsumer<ProtonDelivery, Message> eventConsumer,
+            Handler<AsyncResult<MessageConsumer>> creationHandler);
+
     /**
      * Gets a client for interacting with Hono's <em>Registration</em> API.
      * 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
index 385ba3d12..dd6dd42c3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2016 Bosch Software Innovations GmbH.
+ * Copyright (c) 2016, 2017 Bosch Software Innovations GmbH.
  *
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
@@ -14,7 +14,7 @@
 package org.eclipse.hono.client.impl;
 
 import java.util.Objects;
-import java.util.function.Consumer;
+import java.util.function.BiConsumer;
 
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.MessageConsumer;
@@ -27,6 +27,7 @@ import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonReceiver;
 
 /**
@@ -56,7 +57,7 @@ public class EventConsumerImpl extends AbstractHonoClient implements MessageCons
             final Context context,
             final ProtonConnection con,
             final String tenantId,
-            final Consumer<Message> eventConsumer,
+            final BiConsumer<ProtonDelivery, Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
         create(context, con, tenantId, Constants.DEFAULT_PATH_SEPARATOR, eventConsumer, creationHandler);
@@ -78,7 +79,7 @@ public class EventConsumerImpl extends AbstractHonoClient implements MessageCons
             final ProtonConnection con,
             final String tenantId,
             final String pathSeparator,
-            final Consumer<Message> eventConsumer,
+            final BiConsumer<ProtonDelivery, Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
         Objects.requireNonNull(context);
@@ -102,14 +103,15 @@ public class EventConsumerImpl extends AbstractHonoClient implements MessageCons
             final ProtonConnection con,
             final String tenantId,
             final String pathSeparator,
-            final Consumer<Message> consumer) {
+            final BiConsumer<ProtonDelivery, Message> consumer) {
 
         Future<ProtonReceiver> result = Future.future();
         final String targetAddress = String.format(EVENT_ADDRESS_TEMPLATE, pathSeparator, tenantId);
 
         context.runOnContext(open -> {
             final ProtonReceiver receiver = con.createReceiver(targetAddress);
-            receiver.setAutoAccept(true).setPrefetch(DEFAULT_SENDER_CREDITS);
+            receiver.setAutoAccept(true);
+            receiver.setPrefetch(DEFAULT_SENDER_CREDITS);
             receiver.openHandler(receiverOpen -> {
                 if (receiverOpen.succeeded()) {
                     LOG.debug("event receiver for [{}] open", receiverOpen.result().getRemoteSource());
@@ -120,7 +122,7 @@ public class EventConsumerImpl extends AbstractHonoClient implements MessageCons
             });
             receiver.handler((delivery, message) -> {
                 if (consumer != null) {
-                    consumer.accept(message);
+                    consumer.accept(delivery, message);
                 }
             });
             receiver.open();
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 9dc993e2b..17d7fcf03 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -22,6 +22,7 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 
 import org.apache.qpid.proton.message.Message;
@@ -44,6 +45,7 @@ import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
 
 /**
  * A helper class for creating Vert.x based clients for Hono's arbitrary APIs.
@@ -377,6 +379,19 @@ public final class HonoClientImpl implements HonoClient {
             final Consumer<Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
+        createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message), creationHandler);
+        return this;
+    }
+
+    /* (non-Javadoc)
+     * @see org.eclipse.hono.client.HonoClient#createEventConsumer(java.lang.String, java.util.function.BiConsumer, io.vertx.core.Handler)
+     */
+    @Override
+    public HonoClient createEventConsumer(
+            final String tenantId,
+            final BiConsumer<ProtonDelivery, Message> eventConsumer,
+            final Handler<AsyncResult<MessageConsumer>> creationHandler) {
+
         // register a handler to be notified if the underlying connection to the server fails
         // so that we can fail the result handler passed in
         final Handler<Void> connectionFailureHandler = connectionLost -> {
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
new file mode 100644
index 000000000..f4cb8b5c7
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
@@ -0,0 +1,107 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+
+package org.eclipse.hono.client.impl;
+
+import static org.mockito.Mockito.*;
+
+import java.util.function.BiConsumer;
+
+import org.apache.qpid.proton.amqp.messaging.Released;
+import org.apache.qpid.proton.amqp.transport.Source;
+import org.apache.qpid.proton.message.Message;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.ext.unit.Async;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonMessageHandler;
+import io.vertx.proton.ProtonReceiver;
+
+
+/**
+ * Test cases verifying the behavior of {@link EventConsumerImpl}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class EventConsumerImplTest {
+
+    private Vertx vertx;
+
+    /**
+     * Initializes fixture.
+     */
+    @Before
+    public void setUp() {
+        vertx = Vertx.vertx();
+    }
+
+    /**
+     * Cleans up fixture.
+     */
+    @After
+    public void shutDown() {
+        vertx.close();
+    }
+
+    /**
+     * Verifies that the message delivery for a received event is forwarded to the
+     * registered event consumer.
+     * 
+     * @param ctx The test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateRegistersBiConsumerAsMessageHandler(final TestContext ctx) {
+
+        // GIVEN an event consumer that releases all messages
+        BiConsumer<ProtonDelivery, Message> eventConsumer = (delivery, message) -> {
+            ProtonHelper.released(delivery, true);
+        };
+        Source source = mock(Source.class);
+        when(source.toString()).thenReturn("event/tenant");
+        ProtonReceiver receiver = mock(ProtonReceiver.class);
+        when(receiver.getRemoteSource()).thenReturn(source);
+        ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createReceiver(anyString())).thenReturn(receiver);
+        when(receiver.openHandler(any(Handler.class))).thenAnswer(invocation -> {
+            invocation.getArgumentAt(0, Handler.class).handle(Future.succeededFuture(receiver));
+            return receiver;
+        });
+        Async consumerCreation = ctx.async();
+        EventConsumerImpl.create(vertx.getOrCreateContext(), con, "tenant", eventConsumer, ctx.asyncAssertSuccess(s -> {
+            consumerCreation.complete();
+        }));
+        consumerCreation.await(500);
+
+        // WHEN an event is received
+        ProtonDelivery delivery = mock(ProtonDelivery.class);
+        Message msg = mock(Message.class);
+        ArgumentCaptor<ProtonMessageHandler> messageHandler = ArgumentCaptor.forClass(ProtonMessageHandler.class);
+        verify(receiver).handler(messageHandler.capture());
+
+        // THEN the message is released and settled
+        messageHandler.getValue().handle(delivery, msg);
+        verify(delivery).disposition(any(Released.class), eq(Boolean.TRUE));
+    }
+
+}
