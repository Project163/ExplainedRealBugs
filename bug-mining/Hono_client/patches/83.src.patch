diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 1dc6529ac..344861cc2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -14,7 +14,7 @@ package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
 import java.time.Duration;
-import java.time.Instant;
+import java.util.Arrays;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
@@ -31,10 +31,12 @@ import org.eclipse.hono.client.RequestResponseClientConfigProperties;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.ExpiringValueCache;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RequestResponseApiConstants;
 import org.eclipse.hono.util.RequestResponseResult;
+import org.eclipse.hono.util.TriTuple;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -63,8 +65,16 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         extends AbstractHonoClient implements RequestResponseClient {
 
     private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestResponseClient.class);
-
-    private final Map<Object, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
+    private static final int[] CACHEABLE_STATUS_CODES = new int[] {
+                            HttpURLConnection.HTTP_OK,
+                            HttpURLConnection.HTTP_NOT_AUTHORITATIVE,
+                            HttpURLConnection.HTTP_PARTIAL,
+                            HttpURLConnection.HTTP_MULT_CHOICE,
+                            HttpURLConnection.HTTP_MOVED_PERM,
+                            HttpURLConnection.HTTP_GONE
+    };
+
+    private final Map<Object, TriTuple<Handler<AsyncResult<R>>, Object, Object>> replyMap = new ConcurrentHashMap<>();
     private final String replyToAddress;
     private final String targetAddress;
     private final String tenantId;
@@ -123,25 +133,24 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     }
 
     /**
-     * Gets the period of time after which an entry in the response cache
+     * Gets the default value for the period of time after which an entry in the response cache
      * is considered invalid.
      * <p>
      * The value is derived from the configuration properties as follows:
      * <ol>
      * <li>if the properties are of type {@link RequestResponseClientConfigProperties}
-     * then its <em>responseCacheDefaultTimeout</em> property is used</li>
+     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>
      * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT
      * default timeout value} is used</li>
      * </ol>
      *
      * @return The timeout period in seconds.
      */
-    public Duration getResponseCacheTimeoutSeconds() {
+    protected final long getResponseCacheDefaultTimeout() {
         if (config instanceof RequestResponseClientConfigProperties) {
-            return Duration.ofSeconds(
-                    ((RequestResponseClientConfigProperties) config).getResponseCacheDefaultTimeout());
+            return ((RequestResponseClientConfigProperties) config).getResponseCacheDefaultTimeout();
         } else {
-            return Duration.ofSeconds(RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT);
+            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;
         }
     }
 
@@ -188,10 +197,11 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * Creates a result object from the status and payload of a response received from the endpoint.
      *
      * @param status The status of the response.
-     * @param payload The json payload of the response as String.
+     * @param payload The String representation of the response's JSON payload (may be {@code null}).
+     * @param cacheDirective Restrictions regarding the caching of the payload (may be {@code null}).
      * @return The result object.
      */
-    protected abstract R getResult(final int status, final String payload);
+    protected abstract R getResult(final int status, final String payload, final CacheDirective cacheDirective);
 
     /**
      * Creates the sender and receiver links to the peer for sending requests
@@ -251,18 +261,23 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * <p>
      * If the response cannot be correlated to a request, e.g. because the request has timed
      * out, then the delivery is <em>released</em> and the message is silently discarded.
+     * <p>
+     * If the client has specified a cache key for the response when sending the request, then the
+     * {@link #addToCache(Object, RequestResponseResult)} method is invoked
+     * in order to add the response to the configured cache.
      * 
      * @param delivery The handle for accessing the message's disposition.
      * @param message The response message.
      */
     protected final void handleResponse(final ProtonDelivery delivery, final Message message) {
 
-        final Handler<AsyncResult<R>> handler = replyMap.remove(message.getCorrelationId());
+        final TriTuple<Handler<AsyncResult<R>>, Object, Object> handler = replyMap.remove(message.getCorrelationId());
         if (handler != null) {
             final R response = getRequestResponseResult(message);
             LOG.debug("received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}]",
                     replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus());
-            handler.handle(Future.succeededFuture(response));
+            addToCache(handler.two(), response);
+            handler.one().handle(Future.succeededFuture(response));
             ProtonHelper.accepted(delivery, true);
         } else {
             LOG.debug("discarding unexpected response [reply-to: {}, correlation ID: {}]",
@@ -271,6 +286,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         }
     }
 
+
     /**
      * Cancels an outstanding request with a given result.
      * 
@@ -286,11 +302,11 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         if (!result.failed()) {
             throw new IllegalArgumentException("result must be failed");
         } else {
-            final Handler<AsyncResult<R>> responseHandler = replyMap.remove(correlationId);
-            if (responseHandler != null) {
+            final TriTuple<Handler<AsyncResult<R>>, Object, Object> handler = replyMap.remove(correlationId);
+            if (handler != null) {
                 LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
                         targetAddress, correlationId, result.cause().getMessage());
-                responseHandler.handle(result);
+                handler.one().handle(result);
             }
         }
     }
@@ -301,7 +317,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                 MessageHelper.APP_PROPERTY_STATUS,
                 Integer.class);
         final String payload = MessageHelper.getPayload(message);
-        return getResult(status, payload);
+        final CacheDirective cacheDirective = CacheDirective.from(MessageHelper.getCacheDirective(message));
+
+        return getResult(status, payload, cacheDirective);
     }
 
     /**
@@ -341,10 +359,33 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @param resultHandler The handler to notify about the outcome of the request.
      * @throws NullPointerException if any of action or result handler is {@code null}.
      */
-    protected final void createAndSendRequest(final String action, final JsonObject payload, final Handler<AsyncResult<R>> resultHandler) {
+    protected final void createAndSendRequest(
+            final String action,
+            final JsonObject payload,
+            final Handler<AsyncResult<R>> resultHandler) {
         createAndSendRequest(action, null, payload, resultHandler);
     }
 
+    /**
+     * Creates a request message for a payload and sends it to the peer.
+     * <p>
+     * This method simply invokes {@link #createAndSendRequest(String, Map, JsonObject, Handler)}
+     * with {@code null} for the properties parameter.
+     * 
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param resultHandler The handler to notify about the outcome of the request.
+     * @param cacheKey The key to use for caching the response (if the service allows caching).
+     * @throws NullPointerException if any of action, result handler or cacheKey is {@code null}.
+     */
+    protected final void createAndSendRequest(
+            final String action,
+            final JsonObject payload,
+            final Handler<AsyncResult<R>> resultHandler,
+            final Object cacheKey) {
+        createAndSendRequest(action, null, payload, resultHandler, cacheKey);
+    }
+
     /**
      * Creates a request message for a payload and headers and sends it to the peer.
      * 
@@ -361,6 +402,34 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      */
     protected final void createAndSendRequest(final String action, final Map<String, Object> properties, final JsonObject payload,
                                       final Handler<AsyncResult<R>> resultHandler) {
+        createAndSendRequest(action, properties, payload, resultHandler, null);
+    }
+
+    /**
+     * Creates a request message for a payload and headers and sends it to the peer.
+     * <p>
+     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.
+     * Otherwise, the request message is sent and a timer is started which fails the result handler,
+     * if no response is received within <em>requestTimeout</em> milliseconds.
+     * 
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param properties The headers to include in the request message as AMQP application properties.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param resultHandler The handler to notify about the outcome of the request. The handler is failed with
+     *                      a {@link ServerErrorException} if the request cannot be sent to the remote service,
+     *                      e.g. because there is no connection to the service or there are no credits available
+     *                      for sending the request or the request timed out.
+     * @param cacheKey The key to use for caching the response (if the service allows caching).
+     * @throws NullPointerException if action or result handler are {@code null}.
+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
+     */
+    protected final void createAndSendRequest(
+            final String action,
+            final Map<String, Object> properties,
+            final JsonObject payload,
+            final Handler<AsyncResult<R>> resultHandler,
+            final Object cacheKey) {
 
         Objects.requireNonNull(action);
         Objects.requireNonNull(resultHandler);
@@ -371,7 +440,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                 request.setContentType(RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON);
                 request.setBody(new AmqpValue(payload.encode()));
             }
-            sendRequest(request, resultHandler);
+            sendRequest(request, resultHandler, cacheKey);
         } else {
             resultHandler.handle(Future.failedFuture(new ServerErrorException(
                     HttpURLConnection.HTTP_UNAVAILABLE, "sender and/or receiver link is not open")));
@@ -387,8 +456,9 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * 
      * @param request The message to send.
      * @param resultHandler The handler to notify about the outcome of the request.
+     * @param cacheKey The key to use for caching the response (if the service allows caching).
      */
-    private final void sendRequest(final Message request, final Handler<AsyncResult<R>> resultHandler) {
+    private final void sendRequest(final Message request, final Handler<AsyncResult<R>> resultHandler, final Object cacheKey) {
 
         context.runOnContext(req -> {
             if (sender.sendQueueFull()) {
@@ -397,7 +467,8 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                         HttpURLConnection.HTTP_UNAVAILABLE, "no credit available for sending request")));
             } else {
                 final Object correlationId = Optional.ofNullable(request.getCorrelationId()).orElse(request.getMessageId());
-                replyMap.put(correlationId, resultHandler);
+                final TriTuple<Handler<AsyncResult<R>>, Object, Object> handler = TriTuple.of(resultHandler, cacheKey, null);
+                replyMap.put(correlationId, handler);
                 sender.send(request, deliveryUpdated -> {
                     if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
                         final Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
@@ -492,22 +563,52 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
 
     /**
      * Adds a response to the cache.
+     * <p>
+     * If the cache key is {@code null} or no cache is configured then this method does nothing.
+     * <p>
+     * Otherwise
+     * <ol>
+     * <li>if the response does not contain any cache directive and the response's status code is
+     * one of the codes defined by <a href="https://tools.ietf.org/html/rfc2616#section-13.4">
+     * RFC 2616, Section 13.4 Response Cacheability</a>, the response is put to the cache using
+     * the default timeout returned by {@link #getResponseCacheDefaultTimeout()}<li>
+     * <li>else if the response contains a <em>max-age</em> directive, the response
+     * is put to the cache using the max age from the directive.</li>
+     * <li>else if the response contains a <em>no-cache</em> directive, the response
+     * is not put to the cache.</li>
+     * </ol>
      * 
-     * @param key The key to store the value under.
-     * @param response The response to cache. Any existing response for the key will be replaced.
-     * @param expirationTime The time after which the response should be considered invalid.
-     * @throws IllegalArgumentException if the current time is not before the expiration time.
-     * @throws IllegalStateException if no cache has been configured.
+     * @param key The key to use for the response.
+     * @param response The response to cache.
+     * @throws NullPointerException if response is {@code null}.
      */
-    protected final void putResponseToCache(final Object key, final R response, final Instant expirationTime) {
+    protected final void addToCache(final Object key, final R response) {
 
-        if (responseCache == null) {
-            throw new IllegalStateException("no cache configured");
-        } else {
-            responseCache.put(key, response, expirationTime);
+        Objects.requireNonNull(response);
+
+        if (responseCache != null && key != null) {
+
+            final CacheDirective cacheDirective = Optional.ofNullable(response.getCacheDirective())
+                    .orElseGet(() -> {
+                        if (isCacheableStatusCode(response.getStatus())) {
+                            return CacheDirective.maxAgeDirective(getResponseCacheDefaultTimeout());
+                        } else {
+                            return CacheDirective.noCacheDirective();
+                        }
+                    });
+
+            if (cacheDirective.isCachingAllowed()) {
+                if (cacheDirective.getMaxAge() > 0) {
+                    responseCache.put(key, response, Duration.ofSeconds(cacheDirective.getMaxAge()));
+                }
+            }
         }
     }
 
+    private boolean isCacheableStatusCode(final int code) {
+        return Arrays.binarySearch(CACHEABLE_STATUS_CODES, code) >= 0;
+    }
+
     /**
      * Get the tenantId of the tenant for that this client was created for.
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
index 53eaf89d0..bc83be9b3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
@@ -20,6 +20,7 @@ import java.util.UUID;
 import org.eclipse.hono.client.CredentialsClient;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.CredentialsConstants;
 import org.eclipse.hono.util.CredentialsObject;
 import org.eclipse.hono.util.CredentialsResult;
@@ -42,7 +43,7 @@ import io.vertx.proton.ProtonConnection;
 public class CredentialsClientImpl extends AbstractRequestResponseClient<CredentialsResult<CredentialsObject>> implements CredentialsClient {
 
     private static Logger LOG = LoggerFactory.getLogger(CredentialsClientImpl.class);
-    private static final ObjectMapper objectMapper = new ObjectMapper();
+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
 
     /**
      * Creates a new client for accessing the Credentials service.
@@ -68,15 +69,17 @@ public class CredentialsClientImpl extends AbstractRequestResponseClient<Credent
     }
 
     @Override
-    protected final CredentialsResult<CredentialsObject> getResult(final int status, final String payload) {
-        try {
-            if (status == HttpURLConnection.HTTP_OK) {
-                return CredentialsResult.from(status, objectMapper.readValue(payload, CredentialsObject.class));
-            } else {
-                return CredentialsResult.from(status);
+    protected final CredentialsResult<CredentialsObject> getResult(final int status, final String payload, final CacheDirective cacheDirective) {
+
+        if (payload == null) {
+            return CredentialsResult.from(status);
+        } else {
+            try {
+                return CredentialsResult.from(status, OBJECT_MAPPER.readValue(payload, CredentialsObject.class), cacheDirective);
+            } catch (final IOException e) {
+                LOG.warn("received malformed payload from Credentials service", e);
+                return CredentialsResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR);
             }
-        } catch (IOException e) {
-            return CredentialsResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR);
         }
     }
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
index 95a4485cf..d4dd50bd5 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
@@ -22,7 +22,7 @@ import java.util.UUID;
 import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.util.JwtHelper;
+import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RegistrationConstants;
 import org.eclipse.hono.util.RegistrationResult;
@@ -37,6 +37,7 @@ import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.core.json.DecodeException;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonReceiver;
@@ -101,9 +102,18 @@ public class RegistrationClientImpl extends AbstractRequestResponseClient<Regist
     }
 
     @Override
-    protected final RegistrationResult getResult(final int status, final String payload) {
-
-        return RegistrationResult.from(status, payload);
+    protected final RegistrationResult getResult(final int status, final String payload, final CacheDirective cacheDirective) {
+
+        if (payload == null) {
+            return RegistrationResult.from(status);
+        } else {
+            try {
+                return RegistrationResult.from(status, new JsonObject(payload), cacheDirective);
+            } catch (final DecodeException e) {
+                LOG.warn("received malformed payload from Device Registration service", e);
+                return RegistrationResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR);
+            }
+        }
     }
 
     /**
@@ -286,18 +296,8 @@ public class RegistrationClientImpl extends AbstractRequestResponseClient<Regist
             if (gatewayId != null) {
                 properties.put(RegistrationConstants.APP_PROPERTY_GATEWAY_ID, gatewayId);
             }
-            createAndSendRequest(RegistrationConstants.ACTION_ASSERT, properties, null, regResult.completer());
-            return regResult.map(response -> {
-                switch(response.getStatus()) {
-                case HttpURLConnection.HTTP_OK:
-                    if (isCachingEnabled()) {
-                        final String token = response.getPayload().getString(RegistrationConstants.FIELD_ASSERTION);
-                        putResponseToCache(key, response, JwtHelper.getExpiration(token).toInstant());
-                    }
-                default:
-                    return response;
-                }
-            });
+            createAndSendRequest(RegistrationConstants.ACTION_ASSERT, properties, null, regResult.completer(), key);
+            return regResult;
         }).map(result -> {
             switch(result.getStatus()) {
             case HttpURLConnection.HTTP_OK:
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
index 201546315..4feae2818 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientImpl.java
@@ -15,7 +15,6 @@ package org.eclipse.hono.client.impl;
 
 import java.io.IOException;
 import java.net.HttpURLConnection;
-import java.time.Instant;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.UUID;
@@ -23,6 +22,7 @@ import java.util.UUID;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.client.TenantClient;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.SpringBasedExpiringValueCache;
 import org.eclipse.hono.util.TenantConstants;
@@ -53,7 +53,7 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
         implements TenantClient {
 
     private static final Logger LOG = LoggerFactory.getLogger(TenantClientImpl.class);
-    private static final ObjectMapper objectMapper = new ObjectMapper();
+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();
 
     /**
      * Creates a tenant API client.
@@ -94,15 +94,17 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
     }
 
     @Override
-    protected final TenantResult<TenantObject> getResult(final int status, final String payload) {
-        try {
-            if (status == HttpURLConnection.HTTP_OK) {
-                return TenantResult.from(status, objectMapper.readValue(payload, TenantObject.class));
-            } else {
-                return TenantResult.from(status);
+    protected final TenantResult<TenantObject> getResult(final int status, final String payload, final CacheDirective cacheDirective) {
+
+        if (payload == null) {
+            return TenantResult.from(status);
+        } else {
+            try {
+                return TenantResult.from(status, OBJECT_MAPPER.readValue(payload, TenantObject.class), cacheDirective);
+            } catch (final IOException e) {
+                LOG.warn("received malformed payload from Tenant service", e);
+                return TenantResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR);
             }
-        } catch (final IOException e) {
-            return TenantResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR);
         }
     }
 
@@ -166,17 +168,8 @@ public class TenantClientImpl extends AbstractRequestResponseClient<TenantResult
         return getResponseFromCache(key).recover(t -> {
             final Future<TenantResult<TenantObject>> tenantResult = Future.future();
             createAndSendRequest(TenantConstants.TenantAction.get.toString(), createTenantProperties(tenantId), null,
-                    tenantResult.completer());
-            return tenantResult.map(result -> {
-                switch(result.getStatus()) {
-                    case HttpURLConnection.HTTP_OK:
-                        if (isCachingEnabled()) {
-                            putResponseToCache(key, result, Instant.now().plus(getResponseCacheTimeoutSeconds()));
-                        }
-                    default:
-                        return result;
-                }
-            });
+                    tenantResult.completer(), key);
+            return tenantResult;
         }).map(tenantResult -> {
             switch(tenantResult.getStatus()) {
                 case HttpURLConnection.HTTP_OK:
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
index 5242fcdd7..f13c5a097 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
@@ -14,11 +14,13 @@ package org.eclipse.hono.client.impl;
 
 import static org.hamcrest.CoreMatchers.*;
 import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.anyLong;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.*;
 
+import java.net.HttpURLConnection;
+import java.time.Duration;
 import java.util.Collections;
 import java.util.Map;
 
@@ -26,8 +28,11 @@ import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.transport.Target;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.RequestResponseClientConfigProperties;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CacheDirective;
+import org.eclipse.hono.util.ExpiringValueCache;
 import org.eclipse.hono.util.MessageHelper;
 import org.junit.Before;
 import org.junit.Rule;
@@ -56,10 +61,7 @@ import io.vertx.proton.ProtonSender;
 @RunWith(VertxUnitRunner.class)
 public class AbstractRequestResponseClientTest  {
 
-    private Vertx vertx;
-    private Context context;
-    private ProtonReceiver receiver;
-    private ProtonSender sender;
+    private static final String MESSAGE_ID = "messageid";
 
     /**
      * Global timeout for all test cases.
@@ -67,8 +69,13 @@ public class AbstractRequestResponseClientTest  {
     @Rule
     public Timeout timeout = Timeout.seconds(5);
 
-    private static final String MESSAGE_ID = "messageid";
     private AbstractRequestResponseClient<SimpleRequestResponseResult> client;
+    private ExpiringValueCache<Object, SimpleRequestResponseResult> cache;
+    private Vertx vertx;
+    private Context context;
+    private ProtonReceiver receiver;
+    private ProtonSender sender;
+
 
     /**
      * Sets up the fixture.
@@ -88,6 +95,8 @@ public class AbstractRequestResponseClientTest  {
         when(sender.getCredit()).thenReturn(10);
         when(sender.getRemoteTarget()).thenReturn(target);
 
+        cache = mock(ExpiringValueCache.class);
+
         client = getClient("tenant", sender, receiver);
         // do not time out requests by default
         client.setRequestTimeout(0);
@@ -136,12 +145,12 @@ public class AbstractRequestResponseClientTest  {
         client.createAndSendRequest("get", props, payload, s -> {});
 
         // THEN the message is sent and the message being sent contains the headers as application properties
-        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
         verify(sender).send(messageCaptor.capture(), any(Handler.class));
         assertThat(messageCaptor.getValue(), is(notNullValue()));
         assertThat(messageCaptor.getValue().getBody(), is(notNullValue()));
         assertThat(messageCaptor.getValue().getBody(), instanceOf(AmqpValue.class));
-        AmqpValue body = (AmqpValue) messageCaptor.getValue().getBody();
+        final AmqpValue body = (AmqpValue) messageCaptor.getValue().getBody();
         assertThat(body.getValue(), is(payload.encode()));
         assertThat(messageCaptor.getValue().getApplicationProperties(), is(notNullValue()));
         assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("test-key"), is("test-value"));
@@ -193,7 +202,7 @@ public class AbstractRequestResponseClientTest  {
 
         // GIVEN a request message that has been sent to a peer
         final Async responseReceived = ctx.async();
-        client.createAndSendRequest("request", null, null, ctx.asyncAssertSuccess(s -> {
+        client.createAndSendRequest("request", null, (JsonObject) null, ctx.asyncAssertSuccess(s -> {
             ctx.assertEquals(200, s.getStatus());
             ctx.assertEquals("payload", s.getPayload());
             responseReceived.complete();
@@ -234,7 +243,7 @@ public class AbstractRequestResponseClientTest  {
             return null;
         }).when(vertx).setTimer(anyLong(), any(Handler.class));
         final Async requestFailure = ctx.async();
-        client.createAndSendRequest("request", null, null, ctx.asyncAssertFailure(t -> {
+        client.createAndSendRequest("request", null, (JsonObject) null, ctx.asyncAssertFailure(t -> {
             ctx.assertTrue(ServerErrorException.class.isInstance(t));
             requestFailure.complete();
         }));
@@ -289,6 +298,122 @@ public class AbstractRequestResponseClientTest  {
         requestFailure.await();
     }
 
+    /**
+     * Verifies that the adapter puts the response from the service to the cache
+     * using the default cache timeout if the response does not contain a
+     * <em>no-cache</em> cache directive.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateAndSendRequestAddsResponseToCache(final TestContext ctx) {
+
+        // GIVEN an adapter with an empty cache
+        client.setResponseCache(cache);
+
+        // WHEN sending a request
+        client.createAndSendRequest("get", (JsonObject) null, ctx.asyncAssertSuccess(result -> {
+            // THEN the response has been put to the cache
+            verify(cache).put(eq("cacheKey"), any(SimpleRequestResponseResult.class),
+                    eq(Duration.ofSeconds(RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT)));
+        }), "cacheKey");
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message("result");
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+    }
+
+    /**
+     * Verifies that the adapter puts the response from the service to the cache
+     * using the max age indicated by a response's <em>max-age</em> cache directive.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateAndSendRequestAddsResponseToCacheWithMaxAge(final TestContext ctx) {
+
+        // GIVEN an adapter with an empty cache
+        client.setResponseCache(cache);
+
+        // WHEN sending a request
+        client.createAndSendRequest("get", (JsonObject) null, ctx.asyncAssertSuccess(result -> {
+            // THEN the response has been put to the cache
+            verify(cache).put(eq("cacheKey"), any(SimpleRequestResponseResult.class), eq(Duration.ofSeconds(35)));
+        }), "cacheKey");
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message("result");
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(35));
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+    }
+
+    /**
+     * Verifies that the adapter does not put the response from the service to the cache
+     * if the response contains a <em>no-cache</em> cache directive.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateAndSendRequestDoesNotAddResponseToCache(final TestContext ctx) {
+
+        // GIVEN an adapter with an empty cache
+        client.setResponseCache(cache);
+
+        // WHEN sending a request
+        client.createAndSendRequest("get", (JsonObject) null, ctx.asyncAssertSuccess(result -> {
+            // THEN the response is not put to the cache
+            verify(cache, never()).put(eq("cacheKey"), any(SimpleRequestResponseResult.class), any(Duration.class));
+        }), "cacheKey");
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message("result");
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.noCacheDirective());
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+    }
+
+    /**
+     * Verifies that the adapter does not put a response from the service to the cache
+     * that does not contain any cache directive but has a <em>non-cacheable</em> status code.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateAndSendRequestDoesNotAddNonCacheableResponseToCache(final TestContext ctx) {
+
+        // GIVEN an adapter with an empty cache
+        client.setResponseCache(cache);
+
+        // WHEN getting a 404 response to a request which contains
+        // no cache directive
+        final Async invocation = ctx.async();
+        client.createAndSendRequest("get", (JsonObject) null, ctx.asyncAssertSuccess(result -> invocation.complete()), "cacheKey");
+
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message();
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NOT_FOUND);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+
+        // THEN the response is not put to the cache
+        invocation.await();
+        verify(cache, never()).put(eq("cacheKey"), any(SimpleRequestResponseResult.class), any(Duration.class));
+    }
+
     private AbstractRequestResponseClient<SimpleRequestResponseResult> getClient(final String tenant, final ProtonSender sender, final ProtonReceiver receiver) {
 
         return new AbstractRequestResponseClient<SimpleRequestResponseResult>(context, new ClientConfigProperties(), tenant, sender, receiver) {
@@ -304,8 +429,8 @@ public class AbstractRequestResponseClientTest  {
             }
 
             @Override
-            protected SimpleRequestResponseResult getResult(int status, String payload) {
-                return SimpleRequestResponseResult.from(status, payload);
+            protected SimpleRequestResponseResult getResult(final int status, final String payload, final CacheDirective cacheDirective) {
+                return SimpleRequestResponseResult.from(status, payload, cacheDirective);
             }
         };
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
index d56fa204d..15421b448 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
@@ -21,10 +21,12 @@ import static org.mockito.Mockito.*;
 
 import java.net.HttpURLConnection;
 import java.sql.Date;
+import java.time.Duration;
 import java.time.Instant;
 
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.RequestResponseClientConfigProperties;
+import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.ExpiringValueCache;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RegistrationConstants;
@@ -97,25 +99,27 @@ public class RegistrationClientImplTest {
      */
     @SuppressWarnings("unchecked")
     @Test
-    public void testAssertRegistrationAddsInfoOnCacheMiss(final TestContext ctx) {
+    public void testAssertRegistrationAddsResponseToCacheOnCacheMiss(final TestContext ctx) {
 
         // GIVEN an adapter with an empty cache
         client.setResponseCache(cache);
-        final JsonObject registrationAssertion = newRegistrationAssertionResult();
-        final Message response = ProtonHelper.message(registrationAssertion.encode());
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
 
         // WHEN getting registration information
         final Async assertion = ctx.async();
         client.assertRegistration("device").setHandler(ctx.asyncAssertSuccess(result -> assertion.complete()));
-        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
         verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final JsonObject registrationAssertion = newRegistrationAssertionResult();
+        final Message response = ProtonHelper.message(registrationAssertion.encode());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
         response.setCorrelationId(messageCaptor.getValue().getMessageId());
         final ProtonDelivery delivery = mock(ProtonDelivery.class);
         client.handleResponse(delivery, response);
 
         // THEN the registration information has been added to the cache
-        verify(cache).put(eq(TriTuple.of("assert", "device", null)), any(RegistrationResult.class), any(Instant.class));
+        verify(cache).put(eq(TriTuple.of("assert", "device", null)), any(RegistrationResult.class), any(Duration.class));
     }
 
     /**
@@ -137,7 +141,7 @@ public class RegistrationClientImplTest {
         final Async assertion = ctx.async();
         client.assertRegistration("device").setHandler(ctx.asyncAssertSuccess(result -> assertion.complete()));
 
-        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
         verify(sender).send(messageCaptor.capture(), any(Handler.class));
         response.setCorrelationId(messageCaptor.getValue().getMessageId());
         final ProtonDelivery delivery = mock(ProtonDelivery.class);
@@ -146,7 +150,7 @@ public class RegistrationClientImplTest {
         // THEN the registration information has been retrieved from the service
         assertion.await();
         // and not been put to the cache
-        verify(cache, never()).put(any(), any(RegistrationResult.class), any(Instant.class));
+        verify(cache, never()).put(any(), any(RegistrationResult.class), any(Duration.class));
     }
 
     /**
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
index f660d2267..9adc262b1 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
@@ -16,18 +16,15 @@ package org.eclipse.hono.client.impl;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.CoreMatchers.startsWith;
 import static org.junit.Assert.assertThat;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.*;
 
-import io.vertx.core.Context;
-import io.vertx.core.Vertx;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
+import java.net.HttpURLConnection;
+import java.time.Duration;
+
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.RequestResponseClientConfigProperties;
+import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.ExpiringValueCache;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.TenantConstants;
@@ -42,13 +39,17 @@ import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 
+import io.vertx.core.Context;
 import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.core.json.JsonObject;
 import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
-
-import java.net.HttpURLConnection;
-import java.time.Instant;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
 
 
 /**
@@ -62,7 +63,7 @@ public class TenantClientImplTest {
      * Time out test cases after 5 seconds.
      */
     @Rule
-    public Timeout globalTimeout = Timeout.seconds(5000);
+    public Timeout globalTimeout = Timeout.seconds(5);
 
     private Vertx vertx;
     private Context context;
@@ -124,8 +125,6 @@ public class TenantClientImplTest {
         // GIVEN an adapter with an empty cache
         client.setResponseCache(cache);
         final JsonObject tenantResult = newTenantResult("tenant");
-        final Message response = ProtonHelper.message(tenantResult.encode());
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
 
         // WHEN getting tenant information
         final Async get = ctx.async();
@@ -133,13 +132,16 @@ public class TenantClientImplTest {
 
         final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
         verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message(tenantResult.encode());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
         response.setCorrelationId(messageCaptor.getValue().getMessageId());
         final ProtonDelivery delivery = mock(ProtonDelivery.class);
         client.handleResponse(delivery, response);
 
         // THEN the tenant result has been added to the cache
         get.await();
-        verify(cache).put(eq(TriTuple.of(TenantAction.get, "tenant", null)), any(TenantResult.class), any(Instant.class));
+        verify(cache).put(eq(TriTuple.of(TenantAction.get, "tenant", null)), any(TenantResult.class), any(Duration.class));
     }
 
     /**
@@ -155,7 +157,7 @@ public class TenantClientImplTest {
         client.setResponseCache(cache);
 
         final JsonObject tenantJsonObject = newTenantResult("tenant");
-        final TenantResult<TenantObject> tenantResult = client.getResult(HttpURLConnection.HTTP_OK, tenantJsonObject.toString());
+        final TenantResult<TenantObject> tenantResult = client.getResult(HttpURLConnection.HTTP_OK, tenantJsonObject.toString(), null);
 
         when(cache.get(any(TriTuple.class))).thenReturn(tenantResult);
 
