diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 06d1b93e0..ebdbb5a41 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -13,6 +13,7 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.time.Instant;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
@@ -221,4 +222,49 @@ public abstract class AbstractHonoClient {
             msg.setApplicationProperties(applicationProperties);
         }
     }
+
+    /**
+     * TODO.
+     */
+    protected final void startAutoCloseTimer() {
+        final long inactiveLinkTimeout = connection.getConfig().getInactiveLinkTimeout();
+        if (inactiveLinkTimeout > 0) {
+            startAutoCloseTimer(inactiveLinkTimeout);
+        }
+    }
+
+    /**
+     * Stores the current time stamp on the sender link. This is used to detect and close inactive AMQP sender links.
+     */
+    protected final void storeLastSendTime() {
+        sender.attachments().set("last-send-time", Long.class, Instant.now().toEpochMilli());
+    }
+
+    private void startAutoCloseTimer(final long delay) {
+        connection.getVertx().setTimer(delay, id -> {
+            final Long lastSendTime = sender.attachments().get("last-send-time", Long.class);
+            long remaining = 0;
+            if (lastSendTime != null) {
+                remaining = getRemainingTimeout(lastSendTime, Instant.now().toEpochMilli(),
+                        connection.getConfig().getInactiveLinkTimeout());
+            }
+
+            if (lastSendTime == null || remaining == 0) {
+                closeLinks(v -> {
+                });
+            } else {
+                startAutoCloseTimer(remaining);
+            }
+        });
+    }
+
+    // visible for testing
+    long getRemainingTimeout(final long lastSend, final long now, final long timeout) {
+        final long timeDiff = now - lastSend;
+        if (timeDiff >= timeout) {
+            return 0L;
+        } else {
+            return timeout - timeDiff;
+        }
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 6e6f91085..80abed8be 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -219,6 +219,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         this(connection, tenantId);
         this.sender = Objects.requireNonNull(sender);
         this.receiver = Objects.requireNonNull(receiver);
+        startAutoCloseTimer();
     }
 
     /**
@@ -395,6 +396,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                 }).compose(sender -> {
                     LOG.debug("request-response client for peer [{}] created", connection.getConfig().getHost());
                     this.sender = sender;
+                    startAutoCloseTimer();
                     return Future.succeededFuture();
                 });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index cda653fbe..a781ba781 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -100,6 +100,7 @@ public abstract class AbstractSender extends AbstractHonoClient implements Messa
                     .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))
                     .orElse(Collections.emptyList());
         }
+        startAutoCloseTimer();
     }
 
     @Override
@@ -250,6 +251,8 @@ public abstract class AbstractSender extends AbstractHonoClient implements Messa
         Objects.requireNonNull(message);
         Objects.requireNonNull(currentSpan);
 
+        storeLastSendTime();
+
         final Future<ProtonDelivery> result = Future.future();
         final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
         message.setMessageId(messageId);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index e7e3ac6eb..fd8f56ba3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -162,6 +162,7 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
 
         Objects.requireNonNull(message);
         Objects.requireNonNull(currentSpan);
+        storeLastSendTime();
 
         final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
         message.setMessageId(messageId);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
index 195a47584..491b90b27 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
@@ -13,24 +13,39 @@
 
 package org.eclipse.hono.client.impl;
 
+import static org.eclipse.hono.client.impl.VertxMockSupport.anyHandler;
 import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
 
+import java.time.Instant;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.amqp.messaging.Target;
+import org.apache.qpid.proton.engine.Record;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.config.ClientConfigProperties;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonSender;
 
 
 /**
@@ -68,4 +83,83 @@ public class AbstractHonoClientTest {
         verify(msg).setApplicationProperties(applicationPropsCaptor.capture());
         assertThat(applicationPropsCaptor.getValue().getValue(), is(applicationProps));
     }
+
+    /**
+     * TODO.
+     */
+    @Test
+    public void testNoAutoCloseOnDefault() {
+        final AbstractHonoClient client = createClient();
+        client.startAutoCloseTimer();
+        verify(client.connection.getVertx(), never()).setTimer(eq(1L), anyHandler());
+    }
+
+    /**
+     * TODO.
+     */
+    @Test
+    public void testTimeoutExceededAndNeverSent() {
+        final AbstractHonoClient client = createClient();
+        client.connection.getConfig().setInactiveLinkTimeout(1L);
+        when(client.sender.attachments().get("last-send-time", Long.class)).thenReturn(0L);
+
+        client.startAutoCloseTimer();
+        verify(client.connection.getVertx()).setTimer(eq(1L), anyHandler());
+        verify(client.connection).closeAndFree(eq(client.sender), anyHandler());
+    }
+
+    /**
+     * TODO.
+     * @throws InterruptedException if sleep is interrupted.
+     */
+    @Test
+    public void testTimerIsRestartedWhenTimeoutNotExceeded() throws InterruptedException {
+        final AbstractHonoClient client = createClient();
+        client.connection.getConfig().setInactiveLinkTimeout(100L);
+        final long now = Instant.now().toEpochMilli();
+        when(client.sender.attachments().get("last-send-time", Long.class)).thenReturn(now);
+        Thread.sleep(1);
+
+        client.startAutoCloseTimer();
+        verify(client.connection.getVertx(), atLeastOnce()).setTimer(anyLong(), anyHandler());
+        verify(client.connection).closeAndFree(eq(client.sender), anyHandler());
+    }
+
+    private AbstractHonoClient createClient() {
+        final ProtonSender protonSender = HonoClientUnitTestHelper.mockProtonSender();
+        when(protonSender.getTarget()).thenReturn(new Target());
+
+        final Record attachments = mock(Record.class);
+        when(protonSender.attachments()).thenReturn(attachments);
+
+        final Vertx vertx = mock(Vertx.class);
+        when(vertx.setTimer(anyLong(), anyHandler())).thenAnswer(invocation -> {
+            final Handler<Long> handler = invocation.getArgument(1);
+            final long timerId = 1;
+            handler.handle(timerId);
+            return timerId;
+        });
+
+        final HonoConnection connection = mock(HonoConnection.class);
+        when(connection.getVertx()).thenReturn(vertx);
+        when(connection.getConfig()).thenReturn(new ClientConfigProperties());
+
+        final AbstractHonoClient client = new AbstractHonoClient(connection) {
+        };
+        client.sender = protonSender;
+        return client;
+    }
+
+    /**
+     * TODO.
+     */
+    @Test
+    public void testRemainingTimeout() {
+        final AbstractHonoClient client = new AbstractHonoClient(mock(HonoConnectionImpl.class)) {
+        };
+        assertEquals(0L, client.getRemainingTimeout(10, 20, 5));
+        assertEquals(0L, client.getRemainingTimeout(0, 20, 5)); // never seen
+        assertEquals(1L, client.getRemainingTimeout(10, 20, 11));
+        assertEquals(5L, client.getRemainingTimeout(20, 20, 5));
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
index 6518624e2..ed3703f47 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
@@ -29,6 +29,7 @@ import static org.mockito.Mockito.when;
 
 import java.net.HttpURLConnection;
 
+import org.apache.qpid.proton.engine.Record;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.ServerErrorException;
@@ -63,6 +64,7 @@ public class AbstractSenderTest {
     public void setUp() {
         protonSender = HonoClientUnitTestHelper.mockProtonSender();
         vertx = mock(Vertx.class);
+        when(protonSender.attachments()).thenReturn(mock(Record.class));
     }
 
     /**
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
index ab6912d24..a63fcdfec 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
@@ -13,11 +13,13 @@
 
 package org.eclipse.hono.client.impl;
 
+import static org.eclipse.hono.client.impl.VertxMockSupport.anyHandler;
 import static org.hamcrest.CoreMatchers.instanceOf;
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
 
+import io.vertx.core.Vertx;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Modified;
@@ -30,6 +32,7 @@ import org.eclipse.hono.client.Command;
 import org.eclipse.hono.client.CommandContext;
 import org.eclipse.hono.client.DelegatedCommandSender;
 import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.CommandConstants;
 import org.junit.Before;
 import org.junit.Test;
@@ -54,6 +57,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
     private DelegateViaDownstreamPeerCommandHandler delegateViaDownstreamPeerCommandHandler;
     private DelegatedCommandSender delegatedCommandSender;
     private String replyTo;
+    private HonoConnection connection;
 
     /**
      * Sets up common fixture.
@@ -76,6 +80,12 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
 
         delegateViaDownstreamPeerCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
                 tenantIdParam -> Future.succeededFuture(delegatedCommandSender));
+
+        connection= mock(HonoConnection.class);
+        when(connection.getConfig()).thenReturn(new ClientConfigProperties());
+        final Vertx vertx = mock(Vertx.class);
+        when(connection.getVertx()).thenReturn(vertx);
+        when(vertx.setTimer(anyLong(), anyHandler())).thenReturn(1L);
     }
 
     /**
@@ -89,7 +99,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
         when(protonDelivery.getRemoteState()).thenReturn(Accepted.getInstance());
         // not using a DelegatedCommandSender mock here since mocking the #sendAndWaitForOutcome(Message, SpanContext) method (which has a default implementation) doesn't seem to work
-        delegatedCommandSender = new DelegatedCommandSenderImpl(mock(HonoConnection.class), mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -123,7 +133,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         final ErrorCondition error = new ErrorCondition(Symbol.valueOf("someError"), "error message");
         rejected.setError(error);
         when(protonDelivery.getRemoteState()).thenReturn(rejected);
-        delegatedCommandSender = new DelegatedCommandSenderImpl(mock(HonoConnection.class), mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -158,7 +168,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         modified.setDeliveryFailed(true);
         modified.setUndeliverableHere(true);
         when(protonDelivery.getRemoteState()).thenReturn(modified);
-        delegatedCommandSender = new DelegatedCommandSenderImpl(mock(HonoConnection.class), mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -189,7 +199,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         // GIVEN a message sender that returns an 'Released' delivery result
         final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
         when(protonDelivery.getRemoteState()).thenReturn(Released.getInstance());
-        delegatedCommandSender = new DelegatedCommandSenderImpl(mock(HonoConnection.class), mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -217,7 +227,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
     public void testHandleWithFailureToSend() {
 
         // GIVEN a message sender that fails to send the message
-        delegatedCommandSender = new DelegatedCommandSenderImpl(mock(HonoConnection.class), mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 return Future.failedFuture("expected send failure");
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
index 44c235b43..abc09b582 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
@@ -16,10 +16,12 @@ import static org.eclipse.hono.client.impl.VertxMockSupport.anyHandler;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -27,6 +29,7 @@ import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.engine.Record;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.DownstreamSender;
 import org.eclipse.hono.client.HonoConnection;
@@ -55,6 +58,7 @@ public class EventSenderImplTest {
     private ProtonSender sender;
     private ClientConfigProperties config;
     private HonoConnection connection;
+    private Record attachments;
 
     /**
      * Sets up the fixture.
@@ -66,6 +70,9 @@ public class EventSenderImplTest {
         sender = HonoClientUnitTestHelper.mockProtonSender();
         config = new ClientConfigProperties();
         connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config);
+        attachments = mock(Record.class);
+        when(sender.attachments()).thenReturn(attachments);
+        when(attachments.get("last-send-time", Long.class)).thenReturn(0L);
     }
 
     /**
@@ -202,4 +209,23 @@ public class EventSenderImplTest {
         assertTrue(msg.isDurable());
     }
 
+    /**
+     * Verifies that sending a message sets the "last-send-time", which is used for the automatic close of the link.
+     */
+    @Test
+    public void testMessageSendSetsLastSendTime() {
+
+        // GIVEN a sender
+        final DownstreamSender messageSender = new EventSenderImpl(connection, sender, "tenant", "telemetry/tenant");
+
+        // WHEN sending messages
+        final Message msg = ProtonHelper.message("telemetry/tenant/deviceId", "some payload");
+        messageSender.sendAndWaitForOutcome(msg);
+        messageSender.send(msg, null);
+        messageSender.send("dev1", null, "some payload", "application/text");
+
+        // THEN the last sent times is reset each time
+        verify(attachments, times(3)).set(eq("last-send-time"), any(), anyLong());
+    }
+
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
index 765d03793..2bf540510 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
@@ -21,12 +21,15 @@ import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.messaging.Target;
+import org.apache.qpid.proton.engine.Record;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.DownstreamSender;
 import org.eclipse.hono.client.HonoConnection;
@@ -56,6 +59,7 @@ public class TelemetrySenderImplTest {
     private ProtonSender sender;
     private ClientConfigProperties config;
     private HonoConnection connection;
+    private Record attachments;
 
     /**
      * Sets up the fixture.
@@ -67,6 +71,9 @@ public class TelemetrySenderImplTest {
         sender = HonoClientUnitTestHelper.mockProtonSender();
         config = new ClientConfigProperties();
         connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config);
+        attachments = mock(Record.class);
+        when(attachments.get("last-send-time", Long.class)).thenReturn(0L);
+        when(sender.attachments()).thenReturn(attachments);
     }
 
     /**
@@ -136,6 +143,7 @@ public class TelemetrySenderImplTest {
             handler.handle(timerId);
             return timerId;
         });
+        when(sender.getTarget()).thenReturn(new Target());
         final DownstreamSender messageSender = new TelemetrySenderImpl(connection, sender, "tenant", "telemetry/tenant");
 
         // WHEN sending a message
@@ -146,4 +154,24 @@ public class TelemetrySenderImplTest {
         // THEN the given Span will nonetheless be finished.
         verify(span).finish();
     }
+
+    /**
+     * Verifies that sending a message sets the "last-send-time", which is used for the automatic close of the link.
+     */
+    @Test
+    public void testMessageSendSetsLastSendTime() {
+
+        // GIVEN a sender
+        final DownstreamSender messageSender = new TelemetrySenderImpl(connection, sender, "tenant",
+                "telemetry/tenant");
+
+        // WHEN sending messages
+        final Message msg = ProtonHelper.message("telemetry/tenant/deviceId", "some payload");
+        messageSender.sendAndWaitForOutcome(msg);
+        messageSender.send(msg, null);
+        messageSender.send("dev1", null, "some payload", "application/text");
+
+        // THEN the last sent times is reset each time
+        verify(attachments, times(3)).set(eq("last-send-time"), any(), anyLong());
+    }
 }
