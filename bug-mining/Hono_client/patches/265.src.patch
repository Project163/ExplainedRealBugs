diff --git a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
deleted file mode 100644
index 924ac9daa..000000000
--- a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/**
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-
-/**
- * Provides access to the life cycle of a connection to a Hono service.
- *
- * @param <T> The type of connection that this is the life-cycle of.
- */
-public interface ConnectionLifecycle<T> {
-
-    /**
-     * Establishes the underlying AMQP connection to the service.
-     *
-     * @return A future that will be completed with the established connection.
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         connection cannot be established, e.g. because
-     *         <ul>
-     *         <li>authentication failed, or</li>
-     *         <li>the connection has been shut down before the connection could be
-     *         established.</li>
-     *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
-     *         </ul>
-     */
-    Future<T> connect();
-
-    /**
-     * Adds a listener to be notified when the connection is lost unexpectedly.
-     *
-     * @param listener The listener to add.
-     */
-    void addDisconnectListener(DisconnectListener<T> listener);
-
-    /**
-     * Adds a listener to be notified when the connection has been re-established after
-     * it had been lost unexpectedly.
-     *
-     * @param listener The listener to add.
-     */
-    void addReconnectListener(ReconnectListener<T> listener);
-
-    /**
-     * Checks whether the connection is currently established.
-     *
-     * @return A succeeded future if this connection is established.
-     *         Otherwise, the future will be failed with a
-     *         {@link ServerErrorException}.
-     */
-    Future<Void> isConnected();
-
-    /**
-     * Checks whether the connection is currently established.
-     * <p>
-     * If a connection attempt is currently in progress, the returned future is completed
-     * with the outcome of the connection attempt. If the connection attempt (including
-     * potential reconnect attempts) isn't finished after the given timeout, the returned
-     * future is failed.
-     * <p>
-     * This default implementation simply returns {@link #isConnected()}.
-     *
-     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for
-     *                                            an ongoing connection attempt to finish.
-     * @return A succeeded future if this connection is established.
-     *         Otherwise, the future will be failed with a {@link ServerErrorException}.
-     */
-    default Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
-        return isConnected();
-    }
-
-    /**
-     * Disconnects from the service.
-     * <p>
-     * Upon terminating the connection to the server, this method does not automatically try to reconnect
-     * to the server again.
-     *
-     */
-    void disconnect();
-
-    /**
-     * Disconnects from the service.
-     * <p>
-     * Similar to {@code #disconnect()} but takes a handler to be notified about the result
-     * of the disconnect operation. The caller can use the handler to determine if the operation succeeded or failed.
-     *
-     * @param completionHandler The handler to notify about the outcome of the operation.
-     *                          A failure could occur if this method is called in the middle of a disconnect operation.
-     * @throws NullPointerException if the completionHandler is {@code null}.
-     */
-    void disconnect(Handler<AsyncResult<Void>> completionHandler);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java b/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
deleted file mode 100644
index ed718f8e2..000000000
--- a/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-
-/**
- * A listener to be notified when a connection is lost unexpectedly.
- *
- * @param <T> The type of connection that this is a listener for.
- */
-@FunctionalInterface
-public interface DisconnectListener<T> {
-
-    /**
-     * Invoked when the connection to a Hono service is lost unexpectedly.
-     *
-     * @param client The client representing the connection to the service.
-     */
-    void onDisconnect(T client);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
deleted file mode 100644
index c0e7ba47a..000000000
--- a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
+++ /dev/null
@@ -1,413 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.eclipse.hono.client.impl.HonoConnectionImpl;
-import org.eclipse.hono.config.ClientConfigProperties;
-
-import io.opentracing.Tracer;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-import io.vertx.proton.ProtonClientOptions;
-import io.vertx.proton.ProtonLink;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-
-/**
- * A wrapper around a single AMQP 1.0 connection and a single session to a Hono service endpoint.
- * <p>
- * The session is shared by all AMQP 1.0 links established for <em>sender</em> and <em>receiver</em>
- * links created using the corresponding factory methods.
- * <p>
- * Before any links can be created, the underlying AMQP connection needs to be established. This is done by
- * invoking one of the <em>connect</em> methods.
- * <p>
- * This class represents the <em>client</em> side when establishing the AMQP connection:
- * <ol>
- * <li>The client tries to establish a TCP/TLS connection to the peer. For this to succeed, the peer must have registered a
- * socket listener on the IP address and port that the client is configured to use.</li>
- * <li>The client initiates a SASL handshake if requested by the peer. The client needs to be
- * configured with correct credentials in order for this stage to succeed.</li>
- * <li>Finally, the client and the peer need to agree on AMQP 1.0 specific connection parameters like capabilities
- * and session window size.</li>
- * </ol>
- * Some of the <em>connect</em> methods accept a {@code ProtonClientOptions} type parameter. Note that these options
- * only influence the client's behavior when establishing the TCP/TLS connection with the peer. The overall behavior of
- * the client regarding the establishment of the AMQP connection must be configured using the
- * {@link ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)} method.
- * In particular, the {@link ClientConfigProperties#setReconnectAttempts(int)} method can be used to specify,
- * how many times the client should try to establish a connection to the peer before giving up.
- * <p>
- * <em>NB</em> When the client tries to establish a connection to the peer, it stores the <em>current</em>
- * vert.x {@code Context} in a local variable and performs all further interactions with the peer running
- * on this Context. Invoking any of the connection's methods from a vert.x Context other than the one
- * used for establishing the connection may cause race conditions or even deadlocks, because the handlers
- * registered on the {@code Future}s returned by these methods will be invoked from the stored Context.
- * It is the invoking code's responsibility to either ensure that the connection's methods are always invoked
- * from the same Context or to make sure that the handlers are running on the correct Context, e.g. by using
- * the {@link #executeOnContext(Handler)} method. 
- */
-public interface HonoConnection extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new connection using the default implementation.
-     * <p>
-     * <strong>Note:</strong> Instances of {@link ClientConfigProperties} are not thread safe and not immutable.
-     * They must therefore not be modified after calling this method.
-     *
-     * @param vertx The vert.x instance to use.
-     * @param clientConfigProperties The client properties to use.
-     * @return The newly created connection. Note that the underlying AMQP connection will not be established
-     *         until one of its <em>connect</em> methods is invoked.
-     * @throws NullPointerException if vertx or clientConfigProperties is {@code null}.
-     */
-    static HonoConnection newConnection(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
-        return new HonoConnectionImpl(vertx, clientConfigProperties);
-    }
-
-    /**
-     * Creates a new connection using the default implementation.
-     * <p>
-     * <strong>Note:</strong> Instances of {@link ClientConfigProperties} are not thread safe and not immutable.
-     * They must therefore not be modified after calling this method.
-     *
-     * @param vertx The vert.x instance to use.
-     * @param clientConfigProperties The client properties to use.
-     * @param tracer The OpenTracing tracer.
-     * @return The newly created connection. Note that the underlying AMQP connection will not be established
-     *         until one of its <em>connect</em> methods is invoked.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    static HonoConnection newConnection(final Vertx vertx, final ClientConfigProperties clientConfigProperties, final Tracer tracer) {
-        final HonoConnectionImpl connection = new HonoConnectionImpl(vertx, clientConfigProperties);
-        connection.setTracer(tracer);
-        return connection;
-    }
-
-    /**
-     * Gets the vert.x instance used by this connection.
-     * <p>
-     * The returned instance may be used to e.g. schedule timers.
-     *
-     * @return The vert.x instance.
-     */
-    Vertx getVertx();
-
-    /**
-     * Gets the <em>OpenTracing</em> {@code Tracer} used for tracking
-     * distributed interactions across process boundaries.
-     *
-     * @return The tracer.
-     */
-    Tracer getTracer();
-
-    /**
-     * Gets the configuration properties used for creating this connection.
-     *
-     * @return The configuration.
-     */
-    ClientConfigProperties getConfig();
-
-    /**
-     * {@inheritDoc}
-     *
-     * The connection will be established using default options.
-     * <p>
-     * With the default options the client will try to establish a TCP connection to the peer a single
-     * time and then give up.
-     * <p>
-     * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
-     * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
-     * opens the AMQP connection to the peer, based on the negotiated parameters.
-     * <p>
-     * The overall number of times that the client should try to establish the AMQP connection with the peer
-     * can be configured by means of the <em>connectAttempts</em> property of the 
-     * {@code ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)}
-     * method. The client will perform a new DNS lookup of the peer's hostname with each attempt to 
-     * establish the AMQP connection.
-     * <p>
-     * When an established connection to the peer fails, the client will automatically try to re-connect
-     * to the peer using the same options and behavior as used for establishing the initial connection.
-     *
-     * @return A future that will be completed with the connected client once the connection has been established.
-     *         The future will fail with a {@link ServiceInvocationException} if the connection cannot be
-     *         established, e.g. because
-     *         <ul>
-     *         <li>authentication of the client failed, or</li>
-     *         <li>one of the client's <em>shutdown</em> methods has been invoked before the connection could be
-     *         established, or</li>
-     *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
-     *         </ul>
-     */
-    @Override
-    Future<HonoConnection> connect();
-
-    /**
-     * Connects to the Hono server using given TCP client options.
-     * <p>
-     * The client will try to establish a TCP connection to the peer based on the given options.
-     * If no options are given, the used default properties will have the <em>connectTimeout</em> and
-     * <em>heartBeat</em> values from the {@link ClientConfigProperties}. Note that each connection
-     * attempt is made using the same IP address that has been resolved when the method was initially
-     * invoked.
-     * <p>
-     * Once a TCP connection is established, the client performs a SASL handshake (if requested by the
-     * peer) using the credentials set in the {@link ClientConfigProperties}. Finally, the client
-     * opens the AMQP connection to the peer, based on the negotiated parameters.
-     * <p>
-     * The number of times that the client should try to establish the AMQP connection with the peer
-     * can be configured by means of the <em>connectAttempts</em> property of the 
-     * {@code ClientConfigProperties} passed in to the {@link #newConnection(Vertx, ClientConfigProperties)}
-     * method. The client will perform a new DNS lookup of the peer's hostname with each attempt to 
-     * establish the AMQP connection.
-     * <p>
-     * When an established connection to the peer fails, the client will automatically try to re-connect
-     * to the peer using the same options and behavior as used for establishing the initial connection.
-     *
-     * @param options The options to use. If {@code null} a set of default properties will be used.
-     * @return A future that will succeed with the connected client once the connection has been established. The future
-     *         will fail with a {@link ServiceInvocationException} if the connection cannot be established, e.g. because
-     *         <ul>
-     *         <li>authentication of the client failed, or</li>
-     *         <li>one of the client's <em>shutdown</em> methods has been invoked before the connection could be
-     *         established, or</li>
-     *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
-     *         </ul>
-     * @throws NullPointerException if the options are {@code null}.
-     */
-    Future<HonoConnection> connect(ProtonClientOptions options);
-
-    /**
-     * {@inheritDoc}
-     *
-     * To re-connect to the server, an explicit call to {@code #connect()} should be made.
-     * Unlike {@code #shutdown()}, which does not allow to connect back to the server,
-     * this method allows to connect back to the server.
-     * <p>
-     * Disconnecting from the Hono server is necessary when, for instance, the open frame of the connection contains
-     * permission information from an authorization service. If after connecting to the server the permissions
-     * from the service have changed, then it will be necessary to drop the connection and connect back to the server
-     * to retrieve the updated permissions.
-     * <p>
-     * If not called from a Vert.x event loop thread, this method waits for at most half of the configured
-     * connect timeout for the connection to be closed properly.
-     */
-    @Override
-    void disconnect();
-
-    /**
-     * Closes this client's connection to the Hono server.
-     * <p>
-     * If not called from a Vert.x event loop thread, this method waits for at most half of the configured
-     * connect timeout for the connection to be closed properly.
-     * <p>
-     * Any senders or consumers opened by this client will be implicitly closed as well. Any subsequent attempts to
-     * connect this client again will fail.
-     */
-    void shutdown();
-
-    /**
-     * Closes this client's connection to the Hono server.
-     * <p>
-     * Any senders or consumers opened by this client will be implicitly closed as well. Any subsequent attempts to
-     * connect this client again will fail.
-     *
-     * @param completionHandler The handler to invoke with the result of the operation.
-     * @throws NullPointerException if the handler is {@code null}.
-     */
-    void shutdown(Handler<AsyncResult<Void>> completionHandler);
-
-    /**
-     * Checks if this connection is shut down.
-     *
-     * @return {@code true} if this connection is shut down already
-     *         or is in the process of shutting down.
-     */
-    boolean isShutdown();
-
-    /**
-     * Gets the remote container id as advertised by the peer.
-     *
-     * @return The remote container id or {@code null}.
-     */
-    String getRemoteContainerId();
-
-    /**
-     * Gets the container id that is advertised to the peer.
-     * <p>
-     * The identifier is supposed to be unique for this HonoConnection.
-     *
-     * @return The container id.
-     */
-    String getContainerId();
-
-    /**
-     * Checks if this client supports a certain capability.
-     * <p>
-     * The result of this method should only be considered reliable if this client is connected to the server.
-     *
-     * @param capability The capability to check support for.
-     * @return {@code true} if the capability is included in the list of capabilities that the server has offered in its
-     *         AMQP <em>open</em> frame, {@code false} otherwise.
-     */
-    boolean supportsCapability(Symbol capability);
-
-    /**
-     * Executes some code on the vert.x Context that has been used to establish the
-     * connection to the peer.
-     *
-     * @param <T> The type of the result that the code produces.
-     * @param codeToRun The code to execute. The code is required to either complete or
-     *                  fail the promise that is passed into the handler.
-     * @return The future containing the result of the promise passed in to the handler
-     *         for executing the code. The future thus indicates the outcome of executing
-     *         the code. The future will always be failed with a {@link ServerErrorException}
-     *         if this connection's <em>context</em> property is {@code null}.
-     */
-    <T> Future<T> executeOnContext(Handler<Promise<T>> codeToRun);
-
-    /**
-     * Creates a sender link.
-     *
-     * @param targetAddress The target address of the link. If the address is {@code null}, the
-     *                      sender link will be established to the 'anonymous relay' and each
-     *                      message must specify its destination address.
-     * @param qos The quality of service to use for the link.
-     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
-     * @throws NullPointerException if qos is {@code null}.
-     */
-    Future<ProtonSender> createSender(
-            String targetAddress,
-            ProtonQoS qos,
-            Handler<String> remoteCloseHook);
-
-    /**
-     * Creates a receiver link.
-     * <p>
-     * The receiver will be created with its <em>autoAccept</em> property set to {@code true}
-     * and with the connection's default pre-fetch size.
-     *
-     * @param sourceAddress The address to receive messages from.
-     * @param qos The quality of service to use for the link.
-     * @param messageHandler The handler to invoke with every message received.
-     * @param remoteCloseHook The handler to invoke when the link is closed at the peer's request (may be {@code null}).
-     * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
-     * @throws NullPointerException if any of the arguments other than close hook is {@code null}.
-     */
-    Future<ProtonReceiver> createReceiver(
-            String sourceAddress,
-            ProtonQoS qos,
-            ProtonMessageHandler messageHandler,
-            Handler<String> remoteCloseHook);
-
-    /**
-     * Creates a receiver link.
-     * <p>
-     * The receiver will be created with its <em>autoAccept</em> property set to {@code true}.
-     *
-     * @param sourceAddress The address to receive messages from.
-     * @param qos The quality of service to use for the link.
-     * @param messageHandler The handler to invoke with every message received.
-     * @param preFetchSize The number of credits to flow to the peer as soon as the link
-     *                     has been established. A value of 0 prevents pre-fetching and
-     *                     allows for manual flow control using the returned receiver's
-     *                     <em>flow</em> method.
-     * @param remoteCloseHook The handler to invoke when the link is closed at the peer's request (may be {@code null}).
-     * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
-     * @throws NullPointerException if any of the arguments other than close hook is {@code null}.
-     * @throws IllegalArgumentException if the pre-fetch size is &lt; 0.
-     */
-    Future<ProtonReceiver> createReceiver(
-            String sourceAddress,
-            ProtonQoS qos,
-            ProtonMessageHandler messageHandler,
-            int preFetchSize,
-            Handler<String> remoteCloseHook);
-
-    /**
-     * Creates a receiver link.
-     *
-     * @param sourceAddress The address to receive messages from.
-     * @param qos The quality of service to use for the link.
-     * @param messageHandler The handler to invoke with every message received.
-     * @param preFetchSize The number of credits to flow to the peer as soon as the link
-     *                     has been established. A value of 0 prevents pre-fetching and
-     *                     allows for manual flow control using the returned receiver's
-     *                     <em>flow</em> method.
-     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)
-     *                   after the message handler runs for them, if no other disposition has been applied
-     *                   during handling.
-     * @param remoteCloseHook The handler to invoke when the link is closed at the peer's request (may be {@code null}).
-     * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
-     * @throws NullPointerException if any of the arguments other than close hook is {@code null}.
-     * @throws IllegalArgumentException if the pre-fetch size is &lt; 0.
-     */
-    Future<ProtonReceiver> createReceiver(
-            String sourceAddress,
-            ProtonQoS qos,
-            ProtonMessageHandler messageHandler,
-            int preFetchSize,
-            boolean autoAccept,
-            Handler<String> remoteCloseHook);
-
-    /**
-     * Closes an AMQP link and frees up its allocated resources.
-     * <p>
-     * This method is equivalent to {@link #closeAndFree(ProtonLink, long, Handler)}
-     * but will use an implementation specific default time-out value.
-     * <p>
-     * If this connection is not established, the given handler is invoked immediately.
-     *
-     * @param link The link to close. If {@code null}, the given handler is invoked immediately.
-     * @param closeHandler The handler to notify once the link has been closed.
-     * @throws NullPointerException if close handler is {@code null}.
-     */
-    void closeAndFree(ProtonLink<?> link, Handler<Void> closeHandler);
-
-    /**
-     * Closes an AMQP link and frees up its allocated resources.
-     * <p>
-     * This method will invoke the given handler as soon as
-     * <ul>
-     * <li>the peer's <em>detach</em> frame has been received or</li>
-     * <li>the given number of milliseconds have passed</li>
-     * </ul>
-     * Afterwards the link's resources are freed up.
-     * <p>
-     * If this connection is not established, the given handler is invoked immediately.
-     *
-     * @param link The link to close. If {@code null}, the given handler is invoked immediately.
-     * @param detachTimeOut The maximum number of milliseconds to wait for the peer's
-     *                      detach frame or 0, if this method should wait indefinitely
-     *                      for the peer's detach frame.
-     * @param closeHandler The handler to notify once the link has been closed.
-     * @throws NullPointerException if close handler is {@code null}.
-     * @throws IllegalArgumentException if detach time-out is &lt; 0.
-     */
-    void closeAndFree(
-            ProtonLink<?> link,
-            long detachTimeOut,
-            Handler<Void> closeHandler);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java b/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
deleted file mode 100644
index f02729767..000000000
--- a/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client;
-
-
-/**
- * A listener to be notified when a connection is re-established after
- * it has been lost unexpectedly.
- *
- * @param <T> The type of connection that this is a listener for.
- */
-@FunctionalInterface
-public interface ReconnectListener<T> {
-
-    /**
-     * Invoked after the connection to a Hono service has been re-established
-     * after it had been lost unexpectedly.
-     *
-     * @param client The client representing the (re-established) connection to the service.
-     */
-    void onReconnect(T client);
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java b/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java
deleted file mode 100644
index 77392b27b..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2022 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.client.ConnectionLifecycle;
-import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.ReconnectListener;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-
-/**
- * ConnectionLifecycle base class that delegates all method invocations to a given
- * ConnectionLifecycle instance.
- *
- * @param <T> The type of connection.
- */
-public abstract class ConnectionLifecycleWrapper<T> implements ConnectionLifecycle<T> {
-
-    private final ConnectionLifecycle<T> delegate;
-
-    /**
-     * Creates a new ConnectionLifecycleWrapper instance.
-     *
-     * @param delegate The object to invoke the ConnectionLifecycle methods on.
-     * @throws NullPointerException if delegate is {@code null}.
-     */
-    protected ConnectionLifecycleWrapper(final ConnectionLifecycle<T> delegate) {
-        this.delegate = Objects.requireNonNull(delegate);
-    }
-
-    @Override
-    public Future<T> connect() {
-        return delegate.connect();
-    }
-
-    @Override
-    public void addDisconnectListener(final DisconnectListener<T> listener) {
-        delegate.addDisconnectListener(listener);
-    }
-
-    @Override
-    public void addReconnectListener(final ReconnectListener<T> listener) {
-        delegate.addReconnectListener(listener);
-    }
-
-    @Override
-    public Future<Void> isConnected() {
-        return delegate.isConnected();
-    }
-
-    @Override
-    public Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
-        return delegate.isConnected(waitForCurrentConnectAttemptTimeout);
-    }
-
-    @Override
-    public void disconnect() {
-        delegate.disconnect();
-    }
-
-    @Override
-    public void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
-        delegate.disconnect(completionHandler);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
deleted file mode 100644
index 232783c73..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Consumer;
-
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ServerErrorException;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Context;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-
-/**
- * Handles connection checks that should be completed only when a concurrent connection attempt has finished
- * (or when a timeout period has elapsed).
- */
-public final class DeferredConnectionCheckHandler {
-
-    private static final Logger LOG = LoggerFactory.getLogger(DeferredConnectionCheckHandler.class);
-
-    /**
-     * While a (re)connection attempt is ongoing, this field references a list of the connection check promises
-     * that are to be completed after connection success/failure or a timeout.
-     * <p>
-     * When the (re)connection attempt is finished, the reference value is set back to {@code null}.
-     */
-    private final AtomicReference<List<ExpiringConnectionCheckPromise>> connectionCheckPromises = new AtomicReference<>();
-    private final Vertx vertx;
-
-    /**
-     * Creates a new DeferredConnectionCheckHandler.
-     *
-     * @param vertx The Vert.x instance to run expiration timers with.
-     */
-    public DeferredConnectionCheckHandler(final Vertx vertx) {
-        this.vertx = vertx;
-    }
-
-    /**
-     * Checks whether a (re)connection attempt is currently in progress.
-     *
-     * @return {@code true} if an attempt is in progress.
-     */
-    public boolean isConnectionAttemptInProgress() {
-        return connectionCheckPromises.get() != null;
-    }
-
-    /**
-     * Signals a (re)connection attempt to be currently in progress.
-     */
-    public void setConnectionAttemptInProgress() {
-        connectionCheckPromises.compareAndSet(null, Collections.emptyList());
-    }
-
-    /**
-     * Marks an ongoing connection attempt as finished, providing the connection result.
-     * <p>
-     * This causes any accumulated connection checks to be completed.
-     *
-     * @param connectionResult The result of the connection attempt.
-     */
-    public void setConnectionAttemptFinished(final AsyncResult<HonoConnection> connectionResult) {
-        final List<ExpiringConnectionCheckPromise> promises = connectionCheckPromises.getAndSet(null);
-        if (promises != null && !promises.isEmpty()) {
-            LOG.trace("completing {} accumulated connection checks", promises.size());
-            final Context ctx = vertx.getOrCreateContext();
-            promises.forEach(promise -> ctx.runOnContext(v -> promise.tryCompleteAndCancelTimer(connectionResult)));
-        }
-    }
-
-    /**
-     * Adds a connection check, represented by the handler to be invoked with the connection check result.
-     * <p>
-     * If a connection attempt is in progress, the given handler is completed once the attempt is finished or once the
-     * given timout value has elapsed.
-     * <p>
-     * If no connection attempt is currently in progress, this method just returns {@code false}.
-     *
-     * @param resultHandler The handler to be invoked with the connection check result.
-     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for
-     *                                            an ongoing connection attempt to finish.
-     * @return {@code true} if the check was successfully added, or {@code false} if no connection attempt is currently
-     *         in progress.
-     * @throws IllegalArgumentException If the given timeout value is &lt; 1.
-     */
-    public boolean addConnectionCheck(final Handler<AsyncResult<Void>> resultHandler,
-            final long waitForCurrentConnectAttemptTimeout) {
-        if (waitForCurrentConnectAttemptTimeout <= 0) {
-            throw new IllegalArgumentException("timeout must be greater 0");
-        }
-        if (!isConnectionAttemptInProgress()) {
-            return false;
-        }
-        final ExpiringConnectionCheckPromise promiseToAdd = new ExpiringConnectionCheckPromise(resultHandler);
-        if (!addToConnectionCheckPromises(promiseToAdd)) {
-            // connectionCheckPromises has been cleared in between
-            return false;
-        }
-        // promise added to list, now use a timer to ensure that we wait no more than the given timeout
-        promiseToAdd.startExpirationTimer(
-                waitForCurrentConnectAttemptTimeout,
-                // cleanup after expiration; not strictly necessary but keeps the list from growing
-                // if (re)connection attempts don't get finished for a long time
-                (v) -> removeFromConnectionCheckPromises(promiseToAdd));
-        return true;
-    }
-
-
-    private boolean addToConnectionCheckPromises(final ExpiringConnectionCheckPromise promiseToAdd) {
-        // atomically add to connectionCheckPromises - but only if connectionCheckPromises hasn't been set to null in between
-        final List<ExpiringConnectionCheckPromise> newPromises = connectionCheckPromises
-                .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {
-                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required
-                    if (existing == null) {
-                        return null;
-                    }
-                    final List<ExpiringConnectionCheckPromise> promises = new ArrayList<>(existing.size() + 1);
-                    promises.addAll(existing);
-                    promises.add(toAdd.get(0));
-                    return promises;
-                });
-        return newPromises != null;
-    }
-
-    private void removeFromConnectionCheckPromises(final ExpiringConnectionCheckPromise promiseToRemove) {
-        connectionCheckPromises
-                .accumulateAndGet(Collections.singletonList(promiseToRemove), (existing, toRemove) -> {
-                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required
-                    if (existing == null) {
-                        return null;
-                    }
-                    final List<ExpiringConnectionCheckPromise> promises = new ArrayList<>(existing);
-                    promises.remove(toRemove.get(0));
-                    return promises;
-                });
-    }
-
-    /**
-     * Wrapped promise with an expiration mechanism, failing the promise after a given time if it has not been
-     * completed yet.
-     */
-    private class ExpiringConnectionCheckPromise {
-        private final Promise<Void> promise;
-        private Long timerId;
-
-        ExpiringConnectionCheckPromise(final Handler<AsyncResult<Void>> connectionCheckResultHandler) {
-            this.promise = Promise.promise();
-            promise.future().onComplete(connectionCheckResultHandler);
-        }
-
-        /**
-         * Starts a timer so that after the given timeout value, this promise shall get failed if not completed already.
-         *
-         * @param timeout The number of milliseconds to use for the timer.
-         * @param postExpirationOperation The operation to run after this promise got failed as part of a timeout.
-         */
-        public void startExpirationTimer(final long timeout, final Consumer<Void> postExpirationOperation) {
-            timerId = vertx.setTimer(timeout, id -> {
-                LOG.debug("canceling connection check after {}ms", timeout);
-                timerId = null;
-                promise.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
-                if (postExpirationOperation != null) {
-                    postExpirationOperation.accept(null);
-                }
-            });
-        }
-
-        /**
-         * Completes this promise with the given result and stops the expiration timer.
-         *
-         * @param connectionResult The connection result to complete this promise with.
-         */
-        public void tryCompleteAndCancelTimer(final AsyncResult<HonoConnection> connectionResult) {
-            if (timerId != null) {
-                vertx.cancelTimer(timerId);
-            }
-            if (connectionResult.succeeded()) {
-                promise.tryComplete();
-            } else {
-                promise.tryFail(connectionResult.cause());
-            }
-        }
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
deleted file mode 100644
index 9641f9911..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ /dev/null
@@ -1,1217 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2022 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.UUID;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ThreadLocalRandom;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import javax.net.ssl.SSLException;
-import javax.security.sasl.AuthenticationException;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.UnsignedLong;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ReconnectListener;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.client.StatusCodeMapper;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.HonoProtonHelper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Tracer;
-import io.opentracing.noop.NoopTracerFactory;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Context;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-import io.vertx.core.impl.VertxInternal;
-import io.vertx.proton.ProtonClientOptions;
-import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonLink;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-import io.vertx.proton.ProtonSession;
-import io.vertx.proton.sasl.MechanismMismatchException;
-import io.vertx.proton.sasl.SaslSystemException;
-
-/**
- * A helper class for managing a vertx-proton based AMQP connection to a
- * Hono service endpoint.
- * <p>
- * The connection ensures that all interactions with the peer are performed on the
- * same vert.x {@code Context}. For this purpose the <em>connect</em> methods
- * either use the current Context or create a new Context for connecting to
- * the peer. This same Context is then used for all consecutive interactions with
- * the peer as well, e.g. when creating consumers or senders.
- * <p>
- * Closing or disconnecting the client will <em>release</em> the Context. The next
- * invocation of any of the connect methods will then use the same approach as
- * described above to determine the Context to use.
- */
-public class HonoConnectionImpl implements HonoConnection {
-
-    /**
-     * A logger to be shared with subclasses.
-     */
-    protected final Logger log = LoggerFactory.getLogger(HonoConnectionImpl.class);
-    /**
-     * The configuration properties for this client.
-     */
-    protected final ClientConfigProperties clientConfigProperties;
-    /**
-     * The vert.x instance to run on.
-     */
-    protected final Vertx vertx;
-
-    /**
-     * The AMQP connection to the peer.
-     */
-    protected ProtonConnection connection;
-    /**
-     * The vert.x Context to use for interacting with the peer.
-     */
-    protected volatile Context context;
-
-    private final List<DisconnectListener<HonoConnection>> disconnectListeners = new ArrayList<>();
-    private final List<DisconnectListener<HonoConnection>> oneTimeDisconnectListeners = Collections.synchronizedList(new ArrayList<>());
-    private final List<ReconnectListener<HonoConnection>> reconnectListeners = new ArrayList<>();
-    private final AtomicBoolean shuttingDown = new AtomicBoolean(false);
-    private final AtomicBoolean disconnecting = new AtomicBoolean(false);
-    private final ConnectionFactory connectionFactory;
-    private final Object connectionLock = new Object();
-    private final AtomicReference<ConnectionAttempt> currentConnectionAttempt = new AtomicReference<>();
-
-    private final String containerId;
-    private final DeferredConnectionCheckHandler deferredConnectionCheckHandler;
-
-    private ProtonClientOptions lastUsedClientOptions;
-    private List<Symbol> offeredCapabilities = Collections.emptyList();
-    private Tracer tracer = NoopTracerFactory.create();
-    private ProtonSession session;
-
-    /**
-     * Creates a new client for a set of configuration properties.
-     * <p>
-     * This constructor creates a connection factory using
-     * {@link ConnectionFactory#newConnectionFactory(Vertx, ClientConfigProperties)}.
-     *
-     * @param vertx The Vert.x instance to execute the client on.
-     * @param clientConfigProperties The configuration properties to use.
-     * @throws NullPointerException if vertx or clientConfigProperties is {@code null}.
-     */
-    public HonoConnectionImpl(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
-        this(vertx, null, clientConfigProperties);
-    }
-
-    /**
-     * Creates a new client for a set of configuration properties.
-     * <p>
-     * <em>NB</em> Make sure to always use the same set of configuration properties for both the connection factory as
-     * well as the Hono client in order to prevent unexpected behavior.
-     *
-     * @param vertx The Vert.x instance to execute the client on.
-     * @param connectionFactory The factory to use for creating an AMQP connection to the Hono server.
-     * @param clientConfigProperties The configuration properties to use.
-     * @throws NullPointerException if vertx or clientConfigProperties is {@code null}.
-     */
-    public HonoConnectionImpl(final Vertx vertx, final ConnectionFactory connectionFactory,
-            final ClientConfigProperties clientConfigProperties) {
-
-        Objects.requireNonNull(vertx);
-        Objects.requireNonNull(clientConfigProperties);
-
-        this.vertx = vertx;
-        this.deferredConnectionCheckHandler = new DeferredConnectionCheckHandler(vertx);
-        if (connectionFactory != null) {
-            this.connectionFactory = connectionFactory;
-        } else {
-            this.connectionFactory = ConnectionFactory.newConnectionFactory(this.vertx, clientConfigProperties);
-        }
-        this.containerId = ConnectionFactory.createContainerId(clientConfigProperties.getName(),
-                clientConfigProperties.getServerRole(), UUID.randomUUID());
-        this.clientConfigProperties = clientConfigProperties;
-    }
-
-    @Override
-    public final Vertx getVertx() {
-        return vertx;
-    }
-
-    /**
-     * Sets the OpenTracing {@code Tracer} to use for tracing messages
-     * published by devices across Hono's components.
-     * <p>
-     * If not set explicitly, the {@code NoopTracer} from OpenTracing will
-     * be used.
-     *
-     * @param opentracingTracer The tracer.
-     */
-    public final void setTracer(final Tracer opentracingTracer) {
-        log.info("using OpenTracing implementation [{}]", opentracingTracer.getClass().getName());
-        this.tracer = Objects.requireNonNull(opentracingTracer);
-    }
-
-    /**
-     * Gets the OpenTracing {@code Tracer} to use for tracing the processing
-     * of messages received from or sent to devices.
-     *
-     * @return The tracer.
-     */
-    @Override
-    public final Tracer getTracer() {
-        return tracer;
-    }
-
-    @Override
-    public final ClientConfigProperties getConfig() {
-        return clientConfigProperties;
-    }
-
-    @Override
-    public final void addDisconnectListener(final DisconnectListener<HonoConnection> listener) {
-        disconnectListeners.add(listener);
-    }
-
-    @Override
-    public final void addReconnectListener(final ReconnectListener<HonoConnection> listener) {
-        reconnectListeners.add(listener);
-    }
-
-    /**
-     * Executes some code on the vert.x Context that has been used to establish the
-     * connection to the peer.
-     *
-     * @param <T> The type of the result that the code produces.
-     * @param codeToRun The code to execute. The code is required to either complete or
-     *                  fail the future that is passed into the handler.
-     * @return The future passed into the handler for executing the code. The future
-     *         thus indicates the outcome of executing the code. The future will
-     *         be failed with a {@link ServerErrorException} if the <em>context</em>
-     *         property is {@code null}.
-     */
-    @Override
-    public final <T> Future<T> executeOnContext(final Handler<Promise<T>> codeToRun) {
-
-        if (context == null) {
-            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
-            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
-        } else {
-            return HonoProtonHelper.executeOnContext(context, codeToRun);
-        }
-    }
-
-    @Override
-    public final Future<Void> isConnected() {
-        return executeOnContext(this::checkConnected);
-    }
-
-    /**
-     * Checks if this client is currently connected to the server.
-     *
-     * @return A succeeded future if this client is connected.
-     */
-    protected final Future<Void> checkConnected() {
-        final Promise<Void> result = Promise.promise();
-        checkConnected(result);
-        return result.future();
-    }
-
-    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {
-        if (isConnectedInternal()) {
-            resultHandler.handle(Future.succeededFuture());
-        } else {
-            resultHandler.handle(Future.failedFuture(
-                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
-        }
-    }
-
-    @Override
-    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
-        return executeOnContext(result -> checkConnected(result, waitForCurrentConnectAttemptTimeout));
-    }
-
-    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler, final long waitForCurrentConnectAttemptTimeout) {
-        if (isConnectedInternal()) {
-            resultHandler.handle(Future.succeededFuture());
-        } else if (waitForCurrentConnectAttemptTimeout > 0 && deferredConnectionCheckHandler.isConnectionAttemptInProgress()) {
-            // connect attempt in progress - let its completion complete the resultHandler here
-            log.debug("connection attempt to server [{}:{}] in progress, connection check will be completed with its result",
-                    connectionFactory.getHost(), connectionFactory.getPort());
-            final boolean added = deferredConnectionCheckHandler.addConnectionCheck(resultHandler,
-                    waitForCurrentConnectAttemptTimeout);
-            if (!added) {
-                // connection attempt was finished in between
-                checkConnected(resultHandler);
-            }
-        } else {
-            resultHandler.handle(Future.failedFuture(
-                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
-        }
-    }
-
-    /**
-     * Checks if this client is currently connected to the server.
-     * <p>
-     * Note that the result returned by this method is only meaningful
-     * if running on the vert.x event loop context that this client has been
-     * created on.
-     *
-     * @return {@code true} if the connection is established.
-     */
-    protected boolean isConnectedInternal() {
-        return connection != null && !connection.isDisconnected() && session != null;
-    }
-
-    @Override
-    public final boolean isShutdown() {
-        return shuttingDown.get();
-    }
-
-    /**
-     * Sets the connection used to interact with the Hono server.
-     *
-     * @param connection The connection to use.
-     * @param session The session to use for links created on the connection.
-     */
-    void setConnection(final ProtonConnection connection, final ProtonSession session) {
-        synchronized (connectionLock) {
-            this.connection = connection;
-            this.session = session;
-            if (connection == null) {
-                this.offeredCapabilities = Collections.emptyList();
-                context = null;
-            } else {
-                this.offeredCapabilities = Optional.ofNullable(connection.getRemoteOfferedCapabilities())
-                        .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))
-                        .orElse(Collections.emptyList());
-            }
-        }
-    }
-
-    /**
-     * Gets the underlying connection object that this client uses to interact with the server.
-     *
-     * @return The connection.
-     */
-    protected final ProtonConnection getConnection() {
-        synchronized (connectionLock) {
-            return this.connection;
-        }
-    }
-
-    @Override
-    public final boolean supportsCapability(final Symbol capability) {
-        if (capability == null) {
-            return false;
-        } else {
-            synchronized (connectionLock) {
-                return offeredCapabilities.contains(capability);
-            }
-        }
-    }
-
-    @Override
-    public final Future<HonoConnection> connect() {
-        return connect(null);
-    }
-
-    @Override
-    public final Future<HonoConnection> connect(final ProtonClientOptions options) {
-        final Promise<HonoConnection> result = Promise.promise();
-        connect(options, result, false);
-        return result.future();
-    }
-
-    private void connect(
-            final ProtonClientOptions options,
-            final Handler<AsyncResult<HonoConnection>> connectionHandler,
-            final boolean isReconnect) {
-
-        if (shuttingDown.get()) {
-            connectionHandler.handle(Future.failedFuture(
-                    new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "client is already shut down")));
-            return;
-        }
-        context = vertx.getOrCreateContext();
-        log.trace("running on vert.x context [event-loop context: {}]", context.isEventLoopContext());
-
-        // context cannot be null thus it is safe to
-        // ignore the Future returned by executeOrRunContext
-        executeOnContext(ignore -> {
-
-            if (isConnectedInternal()) {
-                log.debug("already connected to server [{}:{}, role: {}]",
-                        connectionFactory.getHost(),
-                        connectionFactory.getPort(),
-                        connectionFactory.getServerRole());
-                connectionHandler.handle(Future.succeededFuture(this));
-            } else {
-                final ConnectionAttempt connectionAttempt = new ConnectionAttempt(options, connectionHandler);
-                if (connectionAttempt.start(isReconnect)) {
-                    lastUsedClientOptions = options;
-                } else {
-                    log.debug("already trying to connect to server ...");
-                    connectionHandler.handle(Future.failedFuture(
-                            new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already connecting to server")));
-                }
-            }
-        });
-    }
-
-    private void onRemoteClose(final AsyncResult<ProtonConnection> remoteClose) {
-
-        if (remoteClose.failed()) {
-            log.info("remote server [{}:{}, role: {}] closed connection: {}",
-                    connectionFactory.getHost(),
-                    connectionFactory.getPort(),
-                    connectionFactory.getServerRole(),
-                    remoteClose.cause().getMessage());
-        } else {
-            log.info("remote server [{}:{}, role: {}] closed connection",
-                    connectionFactory.getHost(),
-                    connectionFactory.getPort(),
-                    connectionFactory.getServerRole());
-        }
-        connection.disconnectHandler(null);
-        connection.close();
-        handleConnectionLoss();
-    }
-
-    private void onRemoteDisconnect(final ProtonConnection con) {
-
-        if (con != connection) {
-            log.warn("cannot handle failure of unknown connection");
-        } else {
-            log.debug("lost connection to server [{}:{}, role: {}]",
-                    connectionFactory.getHost(),
-                    connectionFactory.getPort(),
-                    connectionFactory.getServerRole());
-            handleConnectionLoss();
-        }
-    }
-
-    private void handleConnectionLoss() {
-
-        if (isConnectedInternal()) {
-            connection.disconnect();
-        }
-
-        notifyDisconnectHandlers();
-        clearState();
-
-        if (!shuttingDown.get() && clientConfigProperties.getReconnectAttempts() != 0) {
-            connect(lastUsedClientOptions, this::notifyReconnectHandlers, true);
-        }
-    }
-
-    private void notifyReconnectHandlers(final AsyncResult<HonoConnection> reconnectAttempt) {
-        if (reconnectAttempt.succeeded()) {
-            for (final ReconnectListener<HonoConnection> listener : reconnectListeners) {
-                listener.onReconnect(this);
-            }
-        }
-    }
-
-    /**
-     * Reset all connection and link based state.
-     */
-    protected void clearState() {
-        setConnection(null, null);
-    }
-
-    private void notifyDisconnectHandlers() {
-        for (final DisconnectListener<HonoConnection> listener : disconnectListeners) {
-            notifyDisconnectHandler(listener);
-        }
-        for (final Iterator<DisconnectListener<HonoConnection>> iter = oneTimeDisconnectListeners.iterator(); iter.hasNext();) {
-            notifyDisconnectHandler(iter.next());
-            iter.remove();
-        }
-    }
-
-    private void notifyDisconnectHandler(final DisconnectListener<HonoConnection> listener) {
-        try {
-            listener.onDisconnect(this);
-        } catch (final Exception ex) {
-            log.warn("error running disconnectHandler", ex);
-        }
-    }
-
-    /**
-     * Get the maximum delay to be applied before the given reconnect attempt.
-     *
-     * @param reconnectAttempt The reconnect attempt.
-     * @return The delay in milliseconds.
-     */
-    final long getReconnectMaxDelay(final int reconnectAttempt) {
-        if (reconnectAttempt <= 0) {
-            return 0L;
-        } else if (reconnectAttempt <= 31) {
-            // determine the max delay for this reconnect attempt as 2^attempt * delayIncrement
-            final long currentMaxDelay = (1 << (reconnectAttempt - 1)) * clientConfigProperties.getReconnectDelayIncrement();
-            return currentMaxDelay >= 0 ? Math.min(clientConfigProperties.getReconnectMaxDelay(), currentMaxDelay)
-                    : clientConfigProperties.getReconnectMaxDelay();
-        } else {
-            // higher reconnectAttempt values would result in a maxDelay of more than a year, so use the configured maxDelay
-            return clientConfigProperties.getReconnectMaxDelay();
-        }
-    }
-    /**
-     * {@inheritDoc}
-     *
-     * This method simply invokes {@link HonoProtonHelper#closeAndFree(Context, ProtonLink, Handler)}
-     * with this connection's vert.x context.
-     *
-     * @param link The link to close. If {@code null}, the given handler is invoked immediately.
-     * @param closeHandler The handler to notify once the link has been closed.
-     * @throws NullPointerException if close handler is {@code null}.
-     */
-    @Override
-    public void closeAndFree(
-            final ProtonLink<?> link,
-            final Handler<Void> closeHandler) {
-
-        if (context == null) {
-            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
-            closeHandler.handle(null);
-        } else {
-            HonoProtonHelper.closeAndFree(context, link, closeHandler);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     *
-     * This method simply invokes {@link HonoProtonHelper#closeAndFree(Context, ProtonLink, long, Handler)}
-     * with this connection's vert.x context.
-     */
-    @Override
-    public void closeAndFree(
-            final ProtonLink<?> link,
-            final long detachTimeOut,
-            final Handler<Void> closeHandler) {
-
-        if (context == null) {
-            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
-            closeHandler.handle(null);
-        } else {
-            HonoProtonHelper.closeAndFree(context, link, detachTimeOut, closeHandler);
-        }
-    }
-
-    private ProtonSession createDefaultSession(final ProtonConnection connection) {
-
-        if (connection == null) {
-            throw new IllegalStateException("no connection to create session for");
-        } else {
-            log.debug("establishing AMQP session with server [{}:{}, role: {}]",
-                    connectionFactory.getHost(),
-                    connectionFactory.getPort(),
-                    connectionFactory.getServerRole());
-            final ProtonSession newSession = connection.createSession();
-            newSession.closeHandler(remoteClose -> {
-                final StringBuilder msgBuilder = new StringBuilder("the connection's session closed unexpectedly");
-                Optional.ofNullable(newSession.getRemoteCondition())
-                    .ifPresent(error -> {
-                        msgBuilder.append(String.format(" [condition: %s, description: %s]",
-                                error.getCondition(), error.getDescription()));
-                    });
-                newSession.close();
-                onRemoteClose(Future.failedFuture(msgBuilder.toString()));
-            });
-            newSession.setIncomingCapacity(clientConfigProperties.getMaxSessionWindowSize());
-            newSession.open();
-            return newSession;
-        }
-    }
-
-    /**
-     * Creates a sender link.
-     *
-     * @param targetAddress The target address of the link. If the address is {@code null}, the
-     *                      sender link will be established to the 'anonymous relay' and each
-     *                      message must specify its destination address.
-     * @param qos The quality of service to use for the link.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
-     * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
-     * @throws NullPointerException if qos is {@code null}.
-     */
-    @Override
-    public final Future<ProtonSender> createSender(
-            final String targetAddress,
-            final ProtonQoS qos,
-            final Handler<String> closeHook) {
-
-        Objects.requireNonNull(qos);
-
-        return executeOnContext(result -> {
-            checkConnected().compose(v -> {
-
-                if (targetAddress == null && !supportsCapability(Constants.CAP_ANONYMOUS_RELAY)) {
-                    // AnonTerm spec requires peer to offer ANONYMOUS-RELAY capability
-                    // before a client can use anonymous terminus
-                    return Future.failedFuture(new ServerErrorException(
-                            HttpURLConnection.HTTP_NOT_IMPLEMENTED,
-                            "server does not support anonymous terminus"));
-                }
-
-                final Promise<ProtonSender> senderPromise = Promise.promise();
-                final ProtonSender sender = session.createSender(targetAddress);
-                sender.setQoS(qos);
-                sender.setAutoSettle(true);
-                final DisconnectListener<HonoConnection> disconnectBeforeOpenListener = (con) -> {
-                    log.debug("opening sender [{}] failed: got disconnected", targetAddress);
-                    senderPromise.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
-                };
-                oneTimeDisconnectListeners.add(disconnectBeforeOpenListener);
-                sender.openHandler(senderOpen -> {
-
-                    oneTimeDisconnectListeners.remove(disconnectBeforeOpenListener);
-
-                    // the result future may have already been completed here in case of a link establishment timeout
-                    if (senderPromise.future().isComplete()) {
-                        log.debug("ignoring server response for opening sender [{}]: sender creation already timed out", targetAddress);
-                    } else if (senderOpen.failed()) {
-                        // this means that we have received the peer's attach
-                        // and the subsequent detach frame in one TCP read
-                        final ErrorCondition error = sender.getRemoteCondition();
-                        if (error == null) {
-                            log.debug("opening sender [{}] failed", targetAddress, senderOpen.cause());
-                            senderPromise.tryFail(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,
-                                    "cannot open sender", senderOpen.cause()));
-                        } else {
-                            log.debug("opening sender [{}] failed: {} - {}", targetAddress, error.getCondition(), error.getDescription());
-                            senderPromise.tryFail(StatusCodeMapper.fromAttachError(error));
-                        }
-
-                    } else if (HonoProtonHelper.isLinkEstablished(sender)) {
-
-                        log.debug("sender open [target: {}, sendQueueFull: {}, remote max-message-size: {}]",
-                                targetAddress, sender.sendQueueFull(), sender.getRemoteMaxMessageSize());
-                        final long remoteMaxMessageSize = Optional.ofNullable(sender.getRemoteMaxMessageSize())
-                                .map(UnsignedLong::longValue)
-                                .orElse(0L);
-                        if (remoteMaxMessageSize > 0 && remoteMaxMessageSize < clientConfigProperties.getMinMaxMessageSize()) {
-                            // peer won't accept our (biggest) messages
-                            sender.close();
-                            final String msg = String.format(
-                                    "peer does not support minimum max-message-size [required: %d, supported: %d",
-                                    clientConfigProperties.getMinMaxMessageSize(), remoteMaxMessageSize);
-                            log.debug(msg);
-                            senderPromise.tryFail(new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED, msg));
-                        } else if (sender.getCredit() <= 0) {
-                            // wait on credits a little time, if not already given
-                            final long waitOnCreditsTimerId = vertx.setTimer(clientConfigProperties.getFlowLatency(),
-                                    timerID -> {
-                                        log.debug("sender [target: {}] has {} credits after grace period of {}ms",
-                                                targetAddress,
-                                                sender.getCredit(), clientConfigProperties.getFlowLatency());
-                                        sender.sendQueueDrainHandler(null);
-                                        senderPromise.tryComplete(sender);
-                                    });
-                            sender.sendQueueDrainHandler(replenishedSender -> {
-                                log.debug("sender [target: {}] has received {} initial credits",
-                                        targetAddress, replenishedSender.getCredit());
-                                if (vertx.cancelTimer(waitOnCreditsTimerId)) {
-                                    result.tryComplete(replenishedSender);
-                                    replenishedSender.sendQueueDrainHandler(null);
-                                } // otherwise the timer has already completed the future and cleaned up
-                                  // sendQueueDrainHandler
-                            });
-                        } else {
-                            senderPromise.tryComplete(sender);
-                        }
-
-                    } else {
-                        // this means that the peer did not create a local terminus for the link
-                        // and will send a detach frame for closing the link very shortly
-                        // see AMQP 1.0 spec section 2.6.3
-                        log.debug("peer did not create terminus for target [{}] and will detach the link", targetAddress);
-                        senderPromise.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-                    }
-                });
-                HonoProtonHelper.setDetachHandler(sender,
-                        remoteDetached -> onRemoteDetach(sender, connection.getRemoteContainer(), false, closeHook));
-                HonoProtonHelper.setCloseHandler(sender,
-                        remoteClosed -> onRemoteDetach(sender, connection.getRemoteContainer(), true, closeHook));
-                sender.open();
-                vertx.setTimer(clientConfigProperties.getLinkEstablishmentTimeout(),
-                        tid -> {
-                            final boolean notOpenedAndNotDisconnectedYet = oneTimeDisconnectListeners.remove(disconnectBeforeOpenListener);
-                            if (notOpenedAndNotDisconnectedYet) {
-                                onLinkEstablishmentTimeout(sender, clientConfigProperties, senderPromise);
-                            }
-                        });
-                return senderPromise.future();
-            }).onComplete(result);
-        });
-    }
-
-    @Override
-    public Future<ProtonReceiver> createReceiver(
-            final String sourceAddress,
-            final ProtonQoS qos,
-            final ProtonMessageHandler messageHandler,
-            final Handler<String> remoteCloseHook) {
-        return createReceiver(sourceAddress, qos, messageHandler, clientConfigProperties.getInitialCredits(), remoteCloseHook);
-    }
-
-    @Override
-    public Future<ProtonReceiver> createReceiver(
-            final String sourceAddress,
-            final ProtonQoS qos,
-            final ProtonMessageHandler messageHandler,
-            final int preFetchSize,
-            final Handler<String> remoteCloseHook) {
-        return createReceiver(sourceAddress, qos, messageHandler, preFetchSize, true, remoteCloseHook);
-    }
-
-    @Override
-    public Future<ProtonReceiver> createReceiver(
-            final String sourceAddress,
-            final ProtonQoS qos,
-            final ProtonMessageHandler messageHandler,
-            final int preFetchSize,
-            final boolean autoAccept,
-            final Handler<String> remoteCloseHook) {
-
-        Objects.requireNonNull(sourceAddress);
-        Objects.requireNonNull(qos);
-        Objects.requireNonNull(messageHandler);
-        if (preFetchSize < 0) {
-            throw new IllegalArgumentException("pre-fetch size must be >= 0");
-        }
-
-        return executeOnContext(result -> {
-            checkConnected().compose(v -> {
-                final Promise<ProtonReceiver> receiverPromise = Promise.promise();
-                final ProtonReceiver receiver = session.createReceiver(sourceAddress);
-                if (clientConfigProperties.getMaxMessageSize() > ClientConfigProperties.MAX_MESSAGE_SIZE_UNLIMITED) {
-                    receiver.setMaxMessageSize(new UnsignedLong(clientConfigProperties.getMaxMessageSize()));
-                }
-                receiver.setAutoAccept(autoAccept);
-                receiver.setQoS(qos);
-                receiver.setPrefetch(preFetchSize);
-                receiver.handler((delivery, message) -> {
-                    HonoProtonHelper.onReceivedMessageDeliveryUpdatedFromRemote(delivery,
-                            d -> log.debug("got unexpected disposition update for received message [remote state: {}]", delivery.getRemoteState()));
-                    try {
-                        messageHandler.handle(delivery, message);
-                        if (log.isTraceEnabled()) {
-                            final int remainingCredits = receiver.getCredit() - receiver.getQueued();
-                            log.trace("handling message [remotely settled: {}, queued messages: {}, remaining credit: {}]",
-                                    delivery.remotelySettled(), receiver.getQueued(), remainingCredits);
-                        }
-                    } catch (final Exception ex) {
-                        log.warn("error handling message", ex);
-                        ProtonHelper.released(delivery, true);
-                    }
-                });
-                final DisconnectListener<HonoConnection> disconnectBeforeOpenListener = (con) -> {
-                    log.debug("opening receiver [{}] failed: got disconnected", sourceAddress);
-                    receiverPromise.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
-                };
-                oneTimeDisconnectListeners.add(disconnectBeforeOpenListener);
-                receiver.openHandler(recvOpen -> {
-
-                    oneTimeDisconnectListeners.remove(disconnectBeforeOpenListener);
-
-                    // the result future may have already been completed here in case of a link establishment timeout
-                    if (receiverPromise.future().isComplete()) {
-                        log.debug("ignoring server response for opening receiver [{}]: receiver creation already timed out", sourceAddress);
-                    } else if (recvOpen.failed()) {
-                        // this means that we have received the peer's attach
-                        // and the subsequent detach frame in one TCP read
-                        final ErrorCondition error = receiver.getRemoteCondition();
-                        if (error == null) {
-                            log.debug("opening receiver [{}] failed", sourceAddress, recvOpen.cause());
-                            receiverPromise.tryFail(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,
-                                    "cannot open receiver", recvOpen.cause()));
-                        } else {
-                            log.debug("opening receiver [{}] failed: {} - {}", sourceAddress, error.getCondition(), error.getDescription());
-                            receiverPromise.tryFail(StatusCodeMapper.fromAttachError(error));
-                        }
-                    } else if (HonoProtonHelper.isLinkEstablished(receiver)) {
-                        log.debug("receiver open [source: {}]", sourceAddress);
-                        receiverPromise.tryComplete(recvOpen.result());
-                    } else {
-                        // this means that the peer did not create a local terminus for the link
-                        // and will send a detach frame for closing the link very shortly
-                        // see AMQP 1.0 spec section 2.6.3
-                        log.debug("peer did not create terminus for source [{}] and will detach the link", sourceAddress);
-                        receiverPromise.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-                    }
-                });
-                HonoProtonHelper.setDetachHandler(receiver, remoteDetached -> onRemoteDetach(receiver,
-                        connection.getRemoteContainer(), false, remoteCloseHook));
-                HonoProtonHelper.setCloseHandler(receiver, remoteClosed -> onRemoteDetach(receiver,
-                        connection.getRemoteContainer(), true, remoteCloseHook));
-                receiver.open();
-                vertx.setTimer(clientConfigProperties.getLinkEstablishmentTimeout(),
-                        tid -> {
-                            final boolean notOpenedAndNotDisconnectedYet = oneTimeDisconnectListeners.remove(disconnectBeforeOpenListener);
-                            if (notOpenedAndNotDisconnectedYet) {
-                                onLinkEstablishmentTimeout(receiver, clientConfigProperties, receiverPromise);
-                            }
-                        });
-                return receiverPromise.future();
-            }).onComplete(result);
-        });
-    }
-
-    private void onLinkEstablishmentTimeout(
-            final ProtonLink<?> link,
-            final ClientConfigProperties clientConfig,
-            final Promise<?> result) {
-
-        if (link.isOpen() && !HonoProtonHelper.isLinkEstablished(link)) {
-            log.info("link establishment [peer: {}] timed out after {}ms",
-                    clientConfig.getHost(), clientConfig.getLinkEstablishmentTimeout());
-            link.close();
-            // don't free the link here - this may result in an inconsistent session state (see PROTON-2177)
-            // instead the link will be freed when the detach from the server is received
-            result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-        }
-    }
-
-    private void onRemoteDetach(
-            final ProtonLink<?> link,
-            final String remoteContainer,
-            final boolean closed,
-            final Handler<String> closeHook) {
-
-        final ErrorCondition error = link.getRemoteCondition();
-        final String type = link instanceof ProtonSender ? "sender" : "receiver";
-        final String address = link instanceof ProtonSender ? link.getTarget().getAddress() :
-            link.getSource().getAddress();
-        if (error == null) {
-            log.debug("{} [{}] detached (with closed={}) by peer [{}]",
-                    type, address, closed, remoteContainer);
-        } else {
-            log.debug("{} [{}] detached (with closed={}) by peer [{}]: {} - {}",
-                    type, address, closed, remoteContainer, error.getCondition(), error.getDescription());
-        }
-        link.close();
-        if (HonoProtonHelper.isLinkEstablished(link) && closeHook != null) {
-            closeHook.handle(address);
-        }
-    }
-
-    @Override
-    public final void shutdown() {
-        // we don't want to block any event loop thread (even if it's different from the one of the 'context' variable)
-        // therefore the latch used for blocking is not used in that case
-        final CountDownLatch latch = Context.isOnEventLoopThread() ? null : new CountDownLatch(1);
-
-        shutdown(done -> {
-            if (!done.succeeded()) {
-                log.warn("could not close connection to server", done.cause());
-            }
-            if (latch != null) {
-                latch.countDown();
-            }
-        });
-        if (latch != null) {
-            try {
-                // use a timeout slightly higher than the one used in closeConnection()
-                final int timeout = getCloseConnectionTimeout() + 20;
-                if (!latch.await(timeout, TimeUnit.MILLISECONDS)) {
-                    log.warn("shutdown of client timed out after {}ms", timeout);
-                }
-            } catch (final InterruptedException e) {
-                Thread.currentThread().interrupt();
-            }
-        }
-    }
-
-    @Override
-    public final void shutdown(final Handler<AsyncResult<Void>> completionHandler) {
-        Objects.requireNonNull(completionHandler);
-        cancelCurrentConnectionAttempt("client is getting shut down");
-        if (shuttingDown.compareAndSet(Boolean.FALSE, Boolean.TRUE)) {
-            closeConnection(completionHandler);
-        } else {
-            completionHandler.handle(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_CONFLICT,
-                    "already shutting down")));
-        }
-    }
-
-    @Override
-    public final void disconnect() {
-        // we don't want to block any event loop thread (even if it's different from the one of the 'context' variable)
-        // therefore the latch used for blocking is not used in that case
-        final CountDownLatch latch = Context.isOnEventLoopThread() ? null : new CountDownLatch(1);
-
-        disconnect(disconnectResult -> {
-            if (disconnectResult.succeeded()) {
-                log.info("successfully disconnected from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
-            } else {
-                log.warn("could not disconnect from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
-            }
-            if (latch != null) {
-                latch.countDown();
-            }
-        });
-        if (latch != null) {
-            try {
-                // use a timeout slightly higher than the one used in closeConnection()
-                final int timeout = getCloseConnectionTimeout() + 20;
-                if (!latch.await(timeout, TimeUnit.MILLISECONDS)) {
-                    log.warn("Disconnecting from server [{}:{}, role: {}] timed out after {}ms",
-                            connectionFactory.getHost(),
-                            connectionFactory.getPort(),
-                            connectionFactory.getServerRole(),
-                            timeout);
-                }
-            } catch (final InterruptedException e) {
-                Thread.currentThread().interrupt();
-            }
-        }
-    }
-
-    @Override
-    public final void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
-        Objects.requireNonNull(completionHandler);
-        cancelCurrentConnectionAttempt("client got disconnected");
-        if (disconnecting.compareAndSet(Boolean.FALSE, Boolean.TRUE)) {
-            closeConnection(completionHandler);
-        } else {
-            completionHandler.handle(Future.failedFuture(
-                    new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already disconnecting")));
-        }
-    }
-
-    private void cancelCurrentConnectionAttempt(final String errorMessage) {
-        Optional.ofNullable(currentConnectionAttempt.get()).ifPresent(
-                attempt -> attempt.cancel(errorMessage));
-    }
-
-    /**
-     * Gets the remote container id as advertised by the peer.
-     *
-     * @return The remote container id or {@code null}.
-     */
-    @Override
-    public String getRemoteContainerId() {
-        if (!isConnectedInternal()) {
-            return null;
-        }
-        return connection.getRemoteContainer();
-    }
-
-    @Override
-    public String getContainerId() {
-        return containerId;
-    }
-
-    //-----------------------------------< private methods >---
-
-    private void closeConnection(final Handler<AsyncResult<Void>> completionHandler) {
-
-        final Handler<AsyncResult<Object>> handler = attempt -> {
-            disconnecting.compareAndSet(Boolean.TRUE, Boolean.FALSE);
-            if (attempt.succeeded()) {
-                completionHandler.handle(Future.succeededFuture());
-            } else {
-                completionHandler.handle(Future.failedFuture(attempt.cause()));
-            }
-        };
-
-        synchronized (connectionLock) {
-            if (isConnectedInternal()) {
-                executeOnContext(r -> {
-                    final ProtonConnection connectionToClose = connection;
-                    connectionToClose.disconnectHandler(null); // make sure we are not trying to re-connect
-                    final Handler<AsyncResult<ProtonConnection>> closeHandler = remoteClose -> {
-                        if (remoteClose.succeeded()) {
-                            log.info("closed connection to container [{}] at [{}:{}, role: {}]",
-                                    connectionToClose.getRemoteContainer(),
-                                    connectionFactory.getHost(),
-                                    connectionFactory.getPort(),
-                                    connectionFactory.getServerRole());
-                        } else {
-                            log.info("closed connection to container [{}] at [{}:{}, role: {}]",
-                                    connectionToClose.getRemoteContainer(),
-                                    connectionFactory.getHost(),
-                                    connectionFactory.getPort(),
-                                    connectionFactory.getServerRole(),
-                                    remoteClose.cause());
-                        }
-                        notifyDisconnectHandlers();
-                        clearState();
-                        r.complete();
-                    };
-                    final int timeout = getCloseConnectionTimeout();
-                    final long timerId = vertx.setTimer(timeout, tid -> {
-                        log.info("did not receive remote peer's close frame after {}ms", timeout);
-                        closeHandler.handle(Future.succeededFuture());
-                    });
-                    connectionToClose.closeHandler(remoteClose -> {
-                        if (vertx.cancelTimer(timerId)) {
-                            // timer has not fired yet
-                            closeHandler.handle(remoteClose);
-                        }
-                    });
-                    log.info("closing connection to container [{}] at [{}:{}, role: {}] ...",
-                            connectionToClose.getRemoteContainer(),
-                            connectionFactory.getHost(),
-                            connectionFactory.getPort(),
-                            connectionFactory.getServerRole());
-                    connectionToClose.close();
-                }).onComplete(handler);
-            } else {
-                log.info("connection to server [{}:{}, role: {}] already closed",
-                        connectionFactory.getHost(),
-                        connectionFactory.getPort(),
-                        connectionFactory.getServerRole());
-                handler.handle(Future.succeededFuture());
-            }
-        }
-    }
-
-    private int getCloseConnectionTimeout() {
-        final int connectTimeoutToUse = clientConfigProperties.getConnectTimeout() > 0
-                ? clientConfigProperties.getConnectTimeout()
-                : ClientConfigProperties.DEFAULT_CONNECT_TIMEOUT;
-        return connectTimeoutToUse / 2;
-    }
-
-    /**
-     * Encapsulates a connection attempt (with possible retries).
-     */
-    private class ConnectionAttempt {
-
-        private final ProtonClientOptions clientOptions;
-        private final Handler<AsyncResult<HonoConnection>> connectionHandler;
-        private final AtomicInteger connectAttempts = new AtomicInteger(0);
-        private final AtomicBoolean cancelled = new AtomicBoolean();
-
-        private Long reconnectTimerId;
-
-        ConnectionAttempt(final ProtonClientOptions clientOptions, final Handler<AsyncResult<HonoConnection>> connectionHandler) {
-            this.clientOptions = clientOptions;
-
-            this.connectionHandler = ar -> {
-                if (ar.failed()) {
-                    clearState();
-                }
-                currentConnectionAttempt.compareAndSet(this, null);
-                connectionHandler.handle(ar);
-                deferredConnectionCheckHandler.setConnectionAttemptFinished(ar);
-            };
-        }
-
-        /**
-         * Starts the connection attempt.
-         * Must be called on the vert.x context created for the connection attempt.
-         *
-         * @param isReconnect if {@code true}, the connection attempt is started after the configured minimum
-         *            reconnect delay.
-         * @return {@code true} if the attempt was started, {@code false} if there already is an ongoing attempt.
-         */
-        public boolean start(final boolean isReconnect) {
-            if (!currentConnectionAttempt.compareAndSet(null, this)) {
-                // there already is another ongoing attempt
-                return false;
-            }
-            deferredConnectionCheckHandler.setConnectionAttemptInProgress();
-            if (isReconnect) {
-                reconnect(null);
-            } else {
-                connect();
-            }
-            return true;
-        }
-
-        /**
-         * Cancels the connection attempt.
-         *
-         * @param errorMessage The error message with which to fail the connection handler.
-         */
-        public void cancel(final String errorMessage) {
-            if (currentConnectionAttempt.get() != this || !cancelled.compareAndSet(false, true)) {
-                // attempt already finished or cancelled
-                return;
-            }
-            final boolean timerCancelled = Optional.ofNullable(reconnectTimerId)
-                    .map(vertx::cancelTimer).orElse(false);
-            log.debug("cancelled {} connection attempt [#{}] to server [{}:{}, role: {}]",
-                    timerCancelled ? "upcoming" : "ongoing",
-                    connectAttempts.get() + 1,
-                    connectionFactory.getHost(),
-                    connectionFactory.getPort(),
-                    connectionFactory.getServerRole());
-            final ClientErrorException ex = new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, errorMessage);
-            connectionHandler.handle(Future.failedFuture(ex));
-        }
-
-        private void connect() {
-            if (cancelled.get()) {
-                return;
-            }
-            log.debug("starting attempt [#{}] to connect to server [{}:{}, role: {}]",
-                    connectAttempts.get() + 1,
-                    connectionFactory.getHost(),
-                    connectionFactory.getPort(),
-                    connectionFactory.getServerRole());
-
-            connectionFactory.connect(
-                    clientOptions,
-                    null,
-                    null,
-                    containerId,
-                    HonoConnectionImpl.this::onRemoteClose,
-                    HonoConnectionImpl.this::onRemoteDisconnect,
-                    conAttempt -> {
-                        if (conAttempt.failed()) {
-                            reconnect(conAttempt.cause());
-                        } else {
-                            final ProtonConnection newConnection = conAttempt.result();
-                            if (cancelled.get()) {
-                                log.debug("attempt [#{}]: connected but will directly be closed because attempt got cancelled; server [{}:{}, role: {}]",
-                                        connectAttempts.get() + 1,
-                                        connectionFactory.getHost(),
-                                        connectionFactory.getPort(),
-                                        connectionFactory.getServerRole());
-                                newConnection.closeHandler(null);
-                                newConnection.disconnectHandler(null);
-                                newConnection.close();
-                            } else {
-                                log.debug("attempt [#{}]: connected to server [{}:{}, role: {}]; remote container: {}",
-                                        connectAttempts.get() + 1,
-                                        connectionFactory.getHost(),
-                                        connectionFactory.getPort(),
-                                        connectionFactory.getServerRole(),
-                                        newConnection.getRemoteContainer());
-                                final ProtonSession defaultSession = createDefaultSession(newConnection);
-                                setConnection(newConnection, defaultSession);
-                                connectionHandler.handle(Future.succeededFuture(HonoConnectionImpl.this));
-                            }
-                        }
-                    });
-        }
-
-        private void reconnect(final Throwable connectionFailureCause) {
-            if (cancelled.get()) {
-                return;
-            }
-            if (connectionFailureCause != null) {
-                logConnectionError(connectionFailureCause);
-            }
-            if (vertx instanceof VertxInternal && ((VertxInternal) vertx).closeFuture().isClosed()) {
-                log.info("stopping attempts to re-connect to server [{}:{}, role: {}], vertx instance is closed",
-                        connectionFactory.getHost(),
-                        connectionFactory.getPort(),
-                        connectionFactory.getServerRole());
-                connectionHandler.handle(Future.failedFuture(mapConnectionAttemptFailure(connectionFailureCause)));
-            } else if (clientConfigProperties.getReconnectAttempts() - connectAttempts.get() == 0) {
-                log.info("max number of attempts [{}] to re-connect to server [{}:{}, role: {}] have been made, giving up",
-                        clientConfigProperties.getReconnectAttempts(),
-                        connectionFactory.getHost(),
-                        connectionFactory.getPort(),
-                        connectionFactory.getServerRole());
-                connectionHandler.handle(Future.failedFuture(mapConnectionAttemptFailure(connectionFailureCause)));
-            } else {
-                final int reconnectAttempt = connectAttempts.getAndIncrement();
-                // apply exponential backoff with jitter
-                final long reconnectMaxDelay = getReconnectMaxDelay(reconnectAttempt);
-                // let the actual reconnect delay be a random between the minDelay and the current maxDelay
-                final long reconnectDelay = reconnectMaxDelay > clientConfigProperties.getReconnectMinDelay()
-                        ? ThreadLocalRandom.current().nextLong(clientConfigProperties.getReconnectMinDelay(), reconnectMaxDelay)
-                        : clientConfigProperties.getReconnectMinDelay();
-                if (reconnectDelay > 0) {
-                    log.trace("scheduling new connection attempt in {}ms ...", reconnectDelay);
-                    reconnectTimerId = vertx.setTimer(reconnectDelay, tid -> {
-                        reconnectTimerId = null;
-                        connect();
-                    });
-                } else {
-                    connect();
-                }
-            }
-        }
-
-        private ServiceInvocationException mapConnectionAttemptFailure(final Throwable connectionFailureCause) {
-            final ServiceInvocationException serviceInvocationException;
-            if (connectionFailureCause == null) {
-                serviceInvocationException = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
-                        "failed to connect");
-            } else if (connectionFailureCause instanceof AuthenticationException) {
-                // wrong credentials?
-                serviceInvocationException = new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED,
-                        "failed to authenticate with server");
-            } else if (connectionFailureCause instanceof MechanismMismatchException) {
-                serviceInvocationException = new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED,
-                        "no suitable SASL mechanism found for authentication with server");
-            } else if (connectionFailureCause instanceof SSLException) {
-                serviceInvocationException = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST,
-                        "TLS handshake with server failed: " + connectionFailureCause.getMessage(), connectionFailureCause);
-            } else {
-                serviceInvocationException = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
-                        "failed to connect", connectionFailureCause);
-            }
-            return serviceInvocationException;
-        }
-
-        private void logConnectionError(final Throwable connectionFailureCause) {
-            if (isNoteworthyConnectionError(connectionFailureCause)) {
-                log.warn("attempt [#{}] to connect to server [{}:{}, role: {}] failed",
-                        connectAttempts.get() + 1,
-                        clientConfigProperties.getHost(),
-                        clientConfigProperties.getPort(),
-                        connectionFactory.getServerRole(),
-                        connectionFailureCause);
-            } else {
-                log.debug("attempt [#{}] to connect to server [{}:{}, role: {}] failed",
-                        connectAttempts.get() + 1,
-                        clientConfigProperties.getHost(),
-                        clientConfigProperties.getPort(),
-                        connectionFactory.getServerRole(),
-                        connectionFailureCause);
-            }
-        }
-
-        private boolean isNoteworthyConnectionError(final Throwable connectionFailureCause) {
-            return connectionFailureCause instanceof SSLException ||
-                    connectionFailureCause instanceof AuthenticationException ||
-                    connectionFailureCause instanceof MechanismMismatchException ||
-                    (connectionFailureCause instanceof SaslSystemException && ((SaslSystemException) connectionFailureCause).isPermanent());
-        }
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DisconnectHandlerProvidingConnectionFactory.java b/client/src/test/java/org/eclipse/hono/client/impl/DisconnectHandlerProvidingConnectionFactory.java
deleted file mode 100644
index d0a602a66..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DisconnectHandlerProvidingConnectionFactory.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/**
- * Copyright (c) 2018, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- */
-
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.util.Constants;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonClientOptions;
-import io.vertx.proton.ProtonConnection;
-
-/**
- * A connection factory that provides access to the disconnect handler registered with
- * a connection created by the factory.
- *
- */
-public class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {
-
-    private final ProtonConnection connectionToCreate;
-    private final AtomicInteger connectInvocations = new AtomicInteger(0);
-
-    private Handler<ProtonConnection> disconnectHandler;
-    private Handler<AsyncResult<ProtonConnection>> closeHandler;
-    private CountDownLatch expectedSucceedingConnectionAttempts;
-    private CountDownLatch expectedFailingConnectionAttempts;
-    private Throwable causeForFailure;
-
-    DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
-        this.connectionToCreate = Objects.requireNonNull(conToCreate);
-        failWith(new IllegalStateException("connection refused"));
-        setExpectedFailingConnectionAttempts(0);
-        setExpectedSucceedingConnectionAttempts(1);
-    }
-
-    @Override
-    public void connect(
-            final ProtonClientOptions options,
-            final Handler<AsyncResult<ProtonConnection>> closeHandler,
-            final Handler<ProtonConnection> disconnectHandler,
-            final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-        connect(options, null, null, closeHandler, disconnectHandler, connectionResultHandler);
-    }
-
-    @Override
-    public void connect(
-            final ProtonClientOptions options,
-            final String username,
-            final String password,
-            final Handler<AsyncResult<ProtonConnection>> closeHandler,
-            final Handler<ProtonConnection> disconnectHandler,
-            final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-        connect(options, null, null, null, closeHandler, disconnectHandler, connectionResultHandler);
-    }
-
-    @Override
-    public void connect(
-            final ProtonClientOptions options,
-            final String username,
-            final String password,
-            final String containerId,
-            final Handler<AsyncResult<ProtonConnection>> closeHandler,
-            final Handler<ProtonConnection> disconnectHandler,
-            final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-
-        connectInvocations.incrementAndGet();
-        this.closeHandler = closeHandler;
-        this.disconnectHandler = disconnectHandler;
-        if (expectedFailingConnectionAttempts.getCount() > 0) {
-            expectedFailingConnectionAttempts.countDown();
-            connectionResultHandler.handle(Future.failedFuture(causeForFailure));
-        } else {
-            expectedSucceedingConnectionAttempts.countDown();
-            connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
-        }
-    }
-
-    @Override
-    public String getHost() {
-        return "server";
-    }
-
-    @Override
-    public int getPort() {
-        return Constants.PORT_AMQP;
-    }
-
-    @Override
-    public String getPathSeparator() {
-        return Constants.DEFAULT_PATH_SEPARATOR;
-    }
-
-    /**
-     * Gets the disconnect handler which will be invoked on loss of
-     * connection.
-     *
-     * @return The handler.
-     */
-    public Handler<ProtonConnection> getDisconnectHandler() {
-        return disconnectHandler;
-    }
-
-    /**
-     * Gets the handler which will be invoked when the peer closes
-     * the connection.
-     *
-     * @return The handler.
-     */
-    public Handler<AsyncResult<ProtonConnection>> getCloseHandler() {
-        return closeHandler;
-    }
-
-    /**
-     * Sets the number of connection attempts that this factory should fail
-     * before succeeding.
-     *
-     * @param attempts The number of attempts.
-     * @return This factory for command chaining.
-     * @see #awaitFailure()
-     */
-    public DisconnectHandlerProvidingConnectionFactory setExpectedFailingConnectionAttempts(final int attempts) {
-        expectedFailingConnectionAttempts = new CountDownLatch(attempts);
-        return this;
-    }
-
-    /**
-     * Sets the number of successful invocations of the connect method that this factory should expect.
-     *
-     * @param attempts The number of attempts.
-     * @return This factory for command chaining.
-     * @see #await()
-     */
-    public DisconnectHandlerProvidingConnectionFactory setExpectedSucceedingConnectionAttempts(final int attempts) {
-        expectedSucceedingConnectionAttempts = new CountDownLatch(attempts);
-        return this;
-    }
-
-    /**
-     * Sets the root cause that this factory should fail connection attempts with.
-     *
-     * @param cause The root cause.
-     * @return This factory for command chaining.
-     */
-    public DisconnectHandlerProvidingConnectionFactory failWith(final Throwable cause) {
-        this.causeForFailure = Objects.requireNonNull(cause);
-        return this;
-    }
-
-    /**
-     * Waits for the expected number of succeeding connection attempts to
-     * occur.
-     *
-     * @return {@code true} if the expected number of attempts have succeeded.
-     */
-    public boolean await() {
-        try {
-            expectedSucceedingConnectionAttempts.await();
-            return true;
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-            return false;
-        }
-    }
-
-    /**
-     * Waits for the expected number of failing connection attempts to
-     * occur.
-     *
-     * @return {@code true} if the expected number of attempts have failed.
-     */
-    public boolean awaitFailure() {
-        try {
-            expectedFailingConnectionAttempts.await();
-            return true;
-        } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-            return false;
-        }
-    }
-
-    /**
-     * Gets the number of times the <em>connect</em> method got invoked up to now.
-     *
-     * @return The number of connect invocations.
-     */
-    public int getConnectInvocations() {
-        return connectInvocations.get();
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
deleted file mode 100644
index f31ef4ae5..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ /dev/null
@@ -1,1433 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2021 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.net.HttpURLConnection;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.BiConsumer;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.UnsignedLong;
-import org.apache.qpid.proton.amqp.messaging.Target;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.amqp.transport.Source;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.test.VertxMockSupport;
-import org.eclipse.hono.util.TelemetryConstants;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.AdditionalAnswers;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.core.AsyncResult;
-import io.vertx.core.CompositeFuture;
-import io.vertx.core.Context;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-import io.vertx.junit5.Timeout;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonClientOptions;
-import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
-import io.vertx.proton.ProtonSession;
-import io.vertx.proton.sasl.SaslSystemException;
-
-/**
- * Test cases verifying the behavior of {@link HonoConnection}.
- *
- */
-@ExtendWith(VertxExtension.class)
-@Timeout(value = 5, timeUnit = TimeUnit.SECONDS)
-public class HonoConnectionImplTest {
-
-    private Vertx vertx;
-    private ProtonConnection con;
-    private ProtonSession session;
-    private DisconnectHandlerProvidingConnectionFactory connectionFactory;
-    private ClientConfigProperties props;
-    private HonoConnectionImpl honoConnection;
-
-    /**
-     * Sets up fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-        vertx = mock(Vertx.class);
-        final Context context = VertxMockSupport.mockContext(vertx);
-        when(vertx.getOrCreateContext()).thenReturn(context);
-        VertxMockSupport.runTimersImmediately(vertx);
-        session = mock(ProtonSession.class);
-        con = mock(ProtonConnection.class);
-        when(con.getRemoteContainer()).thenReturn("server");
-        when(con.createSession()).thenReturn(session);
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
-        props = new ClientConfigProperties();
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-    }
-
-    /**
-     * Verifies that the client establishes an AMQP session with the
-     * configured incoming window size on the connection.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectEstablishesSession(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured with a specific incoming session
-        // window size
-        props.setMaxFrameSize(16 * 1024);
-        props.setMaxSessionFrames(10);
-
-        // WHEN the client tries to connect
-        honoConnection.connect()
-            .onComplete(ctx.succeeding(con -> {
-                // THEN the session has been configured with an incoming window size
-                ctx.verify(() -> {
-                    verify(session).setIncomingCapacity(10 * 16 * 1024);
-                    verify(session).open();
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the client tries to connect a limited
-     * number of times only.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectFailsAfterMaxConnectionAttempts(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured to reconnect
-        // two times before failing
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        // expect three unsuccessful connection attempts
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(3);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().onComplete(ctx.failing(t -> {
-            // THEN the connection attempt fails
-            ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
-        }));
-        // and the client has indeed tried three times in total before giving up
-        ctx.verify(() -> assertThat(connectionFactory.awaitFailure()).isTrue());
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that a connection attempt from the client is failed if there already is an ongoing
-     * connection attempt.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectFailsIfAnotherConnectAttemptOngoing(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection isn't getting established immediately
-        final Promise<Void> delayedConnectPromise = Promise.promise();
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
-            @Override
-            public void connect(final ProtonClientOptions options, final String username, final String password,
-                    final String containerId,
-                    final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                    final Handler<ProtonConnection> disconnectHandler,
-                    final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                delayedConnectPromise.future().onComplete(v -> {
-                    super.connect(options, username, password, containerId, closeHandler, disconnectHandler, connectionResultHandler);
-                });
-            }
-        };
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1); // let connectionFactory.connect succeed
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN trying to connect
-        final Future<HonoConnection> connectFuture = honoConnection.connect();
-        // and starting another connect attempt before the connection has been established
-        final Future<HonoConnection> connectFuture2 = honoConnection.connect();
-
-        delayedConnectPromise.complete();
-        // THEN the first connect invocation succeeds and the second is failed
-        connectFuture.onComplete(ctx.succeeding(con -> {
-            ctx.verify(() -> {
-                assertThat(connectFuture2.failed()).isTrue();
-                assertThat(connectFuture2.cause()).isInstanceOf(ClientErrorException.class);
-                assertThat(((ClientErrorException) connectFuture2.cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_CONFLICT);
-            });
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that a connection attempt by the client is failed if it occurs while another connect invocation is
-     * waiting for the next reconnect attempt.
-     *
-     * @param ctx The test execution context.
-     */
-    @Test
-    public void testConnectFailsIfAnotherConnectAttemptIsScheduled(final VertxTestContext ctx) {
-        final long reconnectMinDelay = 20L;
-
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection is only getting established on the 2nd attempt, after some delay.
-
-        // the reconnect timer handler only shall get invoked on demand (after a corresponding promise gets completed)
-        final AtomicBoolean reconnectTimerStarted = new AtomicBoolean();
-        final Promise<Void> reconnectTimerContinuePromise = Promise.promise();
-        when(vertx.setTimer(eq(reconnectMinDelay), any())).thenAnswer(invocation -> {
-            reconnectTimerStarted.set(true);
-            final Handler<Long> reconnectTimerHandler = invocation.getArgument(1);
-            reconnectTimerContinuePromise.future().onComplete(ar -> reconnectTimerHandler.handle(0L));
-            return 1L;
-        });
-
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
-            @Override
-            public void connect(final ProtonClientOptions options, final String username, final String password,
-                    final String containerId,
-                    final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                    final Handler<ProtonConnection> disconnectHandler,
-                    final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                super.connect(options, username, password, containerId, closeHandler, disconnectHandler, connectionResultHandler);
-            }
-        };
-        connectionFactory.setExpectedFailingConnectionAttempts(1);
-        props.setReconnectMinDelay(reconnectMinDelay);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN trying to connect
-        final Future<HonoConnection> connectFuture = honoConnection.connect();
-        assertThat(reconnectTimerStarted.get()).isTrue();
-        // and starting another connect attempt before the connection has been established
-        final Future<HonoConnection> connectFuture2 = honoConnection.connect();
-
-        // and letting the first attempt finish
-        reconnectTimerContinuePromise.complete();
-
-        // THEN the first connect invocation succeeds and the second is failed
-        connectFuture.onComplete(ctx.succeeding(cause -> {
-            ctx.verify(() -> {
-                assertThat(connectFuture2.failed()).isTrue();
-                assertThat(connectFuture2.cause()).isInstanceOf(ClientErrorException.class);
-                assertThat(((ClientErrorException) connectFuture2.cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_CONFLICT);
-            });
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the delay between reconnect attempts conforms
-     * to how it is configured in the ClientConfigProperties.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testReconnectDelay(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured to reconnect 5 times with custom delay times.
-        final int reconnectAttempts = 5;
-        props.setReconnectAttempts(reconnectAttempts);
-        props.setReconnectMinDelay(10);
-        props.setReconnectMaxDelay(1000);
-        props.setReconnectDelayIncrement(100);
-        props.setConnectTimeout(10);
-        // expect 6 unsuccessful connection attempts
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(reconnectAttempts + 1);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().onComplete(ctx.failing(t -> {
-            // THEN the connection attempt fails
-            ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
-        }));
-        // and the client has indeed tried 6 times in total before giving up
-        ctx.verify(() -> {
-            assertThat(connectionFactory.awaitFailure()).isTrue();
-            final ArgumentCaptor<Long> delayValueCaptor = ArgumentCaptor.forClass(Long.class);
-            verify(vertx, times(reconnectAttempts)).setTimer(delayValueCaptor.capture(), VertxMockSupport.anyHandler());
-            // and the first delay period is the minDelay value
-            assertThat(delayValueCaptor.getAllValues().get(0)).isEqualTo(10L);
-        });
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that the client fails with a ServerErrorException with status code 503
-     * if it cannot authenticate to the server because of a transient error.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectFailsWithClientErrorForTransientSaslSystemException(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured to connect
-        // to a peer that always throws a SaslSystemException with permanent=false
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(3)
-                .failWith(new SaslSystemException(false, "SASL handshake failed due to a transient error"));
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().onComplete(ctx.failing(t -> {
-            // THEN the connection attempt fails
-            ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
-        }));
-        // and the client has indeed tried three times in total
-        ctx.verify(() -> assertThat(connectionFactory.awaitFailure()).isTrue());
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that the client tries to re-establish a lost connection to a server.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testDownstreamDisconnectTriggersReconnect(final VertxTestContext ctx) {
-
-        // GIVEN an client that is connected to a peer to which the
-        // connection can be established on the third attempt only
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
-        props.setReconnectAttempts(1);
-        final ProtonClientOptions options = new ProtonClientOptions()
-                .setReconnectAttempts(0);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        final AtomicInteger reconnectListenerInvocations = new AtomicInteger();
-        honoConnection.addReconnectListener(con -> reconnectListenerInvocations.incrementAndGet());
-        honoConnection.connect(options).onFailure(ctx::failNow);
-        ctx.verify(() -> assertThat(connectionFactory.await()).isTrue());
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
-
-        // WHEN the downstream connection fails
-        connectionFactory.getDisconnectHandler().handle(con);
-
-        // THEN the adapter reconnects to the downstream container
-        ctx.verify(() -> assertThat(connectionFactory.await()).isTrue());
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
-
-        // and when the downstream connection fails again
-        connectionFactory.getDisconnectHandler().handle(con);
-
-        // THEN the adapter reconnects to the downstream container again
-        ctx.verify(() -> {
-            assertThat(connectionFactory.await()).isTrue();
-            assertThat(reconnectListenerInvocations.get()).isEqualTo(2);
-        });
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that the client repeatedly tries to connect until a connection is established.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testConnectTriesToReconnectOnFailedConnectAttempt(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection can be established on the third attempt only
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(2);
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        final AtomicInteger reconnectListenerInvocations = new AtomicInteger();
-        honoConnection.addReconnectListener(con -> reconnectListenerInvocations.incrementAndGet());
-
-        // WHEN trying to connect
-        honoConnection.connect().onFailure(ctx::failNow);
-
-        ctx.verify(() -> {
-            // THEN the client fails twice to connect
-            assertThat(connectionFactory.awaitFailure()).isTrue();
-            // and succeeds to connect on the third attempt
-            assertThat(connectionFactory.await()).isTrue();
-            // and there are no reconnect listener invocations (all of the above represents one connection attempt)
-            assertThat(reconnectListenerInvocations.get()).isEqualTo(0);
-        });
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that the client tries to re-connect to a server instance if the
-     * connection is closed by the peer.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testOnRemoteCloseTriggersReconnection(final VertxTestContext ctx) {
-
-        // GIVEN a client that is connected to a server
-        final Promise<HonoConnection> connected = Promise.promise();
-        @SuppressWarnings("unchecked")
-        final DisconnectListener<HonoConnection> disconnectListener = mock(DisconnectListener.class);
-        honoConnection.addDisconnectListener(disconnectListener);
-        final AtomicInteger reconnectListenerInvocations = new AtomicInteger();
-        honoConnection.addReconnectListener(con -> reconnectListenerInvocations.incrementAndGet());
-        honoConnection.connect(new ProtonClientOptions())
-            .onComplete(connected);
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
-
-        connected.future().onComplete(ctx.succeeding(c -> {
-            // WHEN the peer closes the connection
-            connectionFactory.getCloseHandler().handle(Future.failedFuture("shutting down for maintenance"));
-
-            ctx.verify(() -> {
-                // THEN the client invokes the registered disconnect handler
-                verify(disconnectListener).onDisconnect(honoConnection);
-                // and the original connection has been closed locally
-                verify(con).close();
-                verify(con).disconnectHandler(null);
-                // and the connection is re-established
-                assertThat(connectionFactory.await()).isTrue();
-                assertThat(reconnectListenerInvocations.get()).isEqualTo(1);
-            });
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that when the client tries to re-connect to a server instance if the
-     * connection is closed by the peer, the configured number of reconnect attempts is taken
-     * into account, skipping the reconnect if that number is zero.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testOnRemoteCloseTriggeredReconnectChecksReconnectAttempts(final VertxTestContext ctx) {
-
-        // GIVEN a client that is connected to a server but should do no automatic reconnect
-        props.setReconnectAttempts(0);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        final Promise<HonoConnection> connected = Promise.promise();
-        @SuppressWarnings("unchecked")
-        final DisconnectListener<HonoConnection> disconnectListener = mock(DisconnectListener.class);
-        honoConnection.addDisconnectListener(disconnectListener);
-        final AtomicInteger reconnectListenerInvocations = new AtomicInteger();
-        honoConnection.addReconnectListener(con -> reconnectListenerInvocations.incrementAndGet());
-        honoConnection.connect(new ProtonClientOptions().setReconnectAttempts(0))
-                .onComplete(connected);
-
-        connected.future().onComplete(ctx.succeeding(c -> {
-            // WHEN the peer closes the connection
-            connectionFactory.getCloseHandler().handle(Future.failedFuture("shutting down for maintenance"));
-
-            ctx.verify(() -> {
-                // THEN the client invokes the registered disconnect handler
-                verify(disconnectListener).onDisconnect(honoConnection);
-                // and the original connection has been closed locally
-                verify(con).close();
-                verify(con).disconnectHandler(null);
-
-                // and no further connect invocation has been done
-                assertThat(connectionFactory.getConnectInvocations()).isEqualTo(1);
-                assertThat(reconnectListenerInvocations.get()).isEqualTo(0);
-            });
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the client tries to reconnect to the peer if the peer
-     * closes the connection's session.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testRemoteSessionCloseTriggersReconnection(final VertxTestContext ctx) {
-
-        // GIVEN a client that is connected to a server
-        final Promise<HonoConnection> connected = Promise.promise();
-        @SuppressWarnings("unchecked")
-        final DisconnectListener<HonoConnection> disconnectListener = mock(DisconnectListener.class);
-        honoConnection.addDisconnectListener(disconnectListener);
-        final AtomicInteger reconnectListenerInvocations = new AtomicInteger();
-        honoConnection.addReconnectListener(con -> reconnectListenerInvocations.incrementAndGet());
-        props.setServerRole("service-provider");
-        honoConnection.connect(new ProtonClientOptions())
-            .onComplete(connected);
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
-
-        connected.future().onComplete(ctx.succeeding(c -> {
-
-            ctx.verify(() -> {
-                // WHEN the peer closes the session
-                final ArgumentCaptor<Handler<AsyncResult<ProtonSession>>> sessionCloseHandler = VertxMockSupport.argumentCaptorHandler();
-                verify(session).closeHandler(sessionCloseHandler.capture());
-                sessionCloseHandler.getValue().handle(Future.succeededFuture(session));
-                // THEN the client invokes the registered disconnect handler
-                verify(disconnectListener).onDisconnect(honoConnection);
-                // and the original connection has been closed locally
-                verify(con).close();
-                verify(con).disconnectHandler(null);
-                // and the connection is re-established
-                assertThat(connectionFactory.await()).isTrue();
-                assertThat(reconnectListenerInvocations.get()).isEqualTo(1);
-            });
-            ctx.completeNow();
-        }));
-
-    }
-
-    /**
-     * Verifies that it fails to connect after client was shutdown.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testConnectFailsAfterShutdown(final VertxTestContext ctx) {
-
-        honoConnection.connect().compose(ok -> {
-            // GIVEN a client that is in the process of shutting down
-            honoConnection.shutdown(Promise.promise());
-            // WHEN the client tries to reconnect before shut down is complete
-            return honoConnection.connect();
-        })
-        .onComplete(ctx.failing(cause -> {
-            // THEN the connection attempt fails
-            ctx.verify(() -> assertThat(((ClientErrorException) cause).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_CONFLICT));
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that if a client disconnects from the server, then an attempt to connect again will be successful.
-     *
-     * @param ctx The test execution context.
-     */
-    @Test
-    public void testConnectSucceedsAfterDisconnect(final VertxTestContext ctx) {
-
-        honoConnection.connect()
-            .compose(ok -> {
-                // GIVEN a client that is connected to a server
-                final Promise<Void> disconnected = Promise.promise();
-                // WHEN the client disconnects
-                honoConnection.disconnect(disconnected);
-                final ArgumentCaptor<Handler<AsyncResult<ProtonConnection>>> closeHandler = VertxMockSupport.argumentCaptorHandler();
-                ctx.verify(() -> verify(con).closeHandler(closeHandler.capture()));
-                closeHandler.getValue().handle(Future.succeededFuture(con));
-                return disconnected.future();
-            })
-            .compose(d -> {
-                // AND tries to reconnect again
-                return honoConnection.connect(new ProtonClientOptions());
-            })
-            // THEN the connection succeeds
-            .onComplete(ctx.succeedingThenComplete());
-    }
-
-    /**
-     * Verifies that if a client disconnects from the server, then an ongoing attempt to connect is cancelled.
-     *
-     * @param ctx The test execution context.
-     */
-    @Test
-    public void testDisconnectAbortsConnectAttempt(final VertxTestContext ctx) {
-
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection isn't getting established immediately
-        final Promise<Void> delayedConnectPromise = Promise.promise();
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
-            @Override
-            public void connect(final ProtonClientOptions options, final String username, final String password,
-                    final String containerId,
-                    final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                    final Handler<ProtonConnection> disconnectHandler,
-                    final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                delayedConnectPromise.future().onComplete(v -> {
-                    super.connect(options, username, password, containerId, closeHandler, disconnectHandler, connectionResultHandler);
-                });
-            }
-        };
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1); // let connectionFactory.connect succeed
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN trying to connect
-        final Future<HonoConnection> connectFuture = honoConnection.connect();
-        // and disconnecting before the connection has been established
-        honoConnection.disconnect();
-
-        delayedConnectPromise.complete();
-        // THEN the connect attempt is failed
-        connectFuture.onComplete(ctx.failing(cause -> {
-            ctx.verify(() -> assertThat(((ClientErrorException) cause).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_CONFLICT));
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that if a client disconnects from the server, then an ongoing attempt to connect, currently waiting
-     * for the next reconnect attempt, is cancelled.
-     *
-     * @param ctx The test execution context.
-     */
-    @Test
-    public void testDisconnectAbortsConnectAttemptWaitingForReconnect(final VertxTestContext ctx) {
-        final long reconnectTimerId = 32L;
-        final long reconnectMinDelay = 20L;
-
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection is only getting established on the 2nd attempt, after some delay.
-
-        // the reconnect timer handler will not get invoked, timer should get cancelled
-        final AtomicBoolean reconnectTimerStarted = new AtomicBoolean();
-        when(vertx.setTimer(eq(reconnectMinDelay), any())).thenAnswer(invocation -> {
-            reconnectTimerStarted.set(true);
-            return reconnectTimerId;
-        });
-        when(vertx.cancelTimer(eq(reconnectTimerId))).thenReturn(true);
-
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
-            @Override
-            public void connect(final ProtonClientOptions options, final String username, final String password,
-                    final String containerId,
-                    final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                    final Handler<ProtonConnection> disconnectHandler,
-                    final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                super.connect(options, username, password, containerId, closeHandler, disconnectHandler, connectionResultHandler);
-            }
-        };
-        connectionFactory.setExpectedFailingConnectionAttempts(1);
-        props.setReconnectMinDelay(reconnectMinDelay);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN trying to connect
-        final Future<HonoConnection> connectFuture = honoConnection.connect();
-        assertThat(reconnectTimerStarted.get()).isTrue();
-        // and disconnecting before the connection has been established
-        honoConnection.disconnect();
-
-        // THEN the reconnectTimer has been cancelled
-        verify(vertx).cancelTimer(eq(reconnectTimerId));
-
-        // AND the connect attempt is failed
-        connectFuture.onComplete(ctx.failing(cause -> {
-            ctx.verify(() -> assertThat(((ClientErrorException) cause).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_CONFLICT));
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that {@link HonoConnectionImpl#isConnected(long)} only completes once a concurrent
-     * connection attempt (which eventually succeeds here) is finished.
-     *
-     * @param ctx The test execution context.
-     */
-    @Test
-    public void testIsConnectedWithTimeoutSucceedsAfterConcurrentReconnectSucceeded(final VertxTestContext ctx) {
-
-        final long isConnectedTimeout = 44444L;
-        // let the vertx timer for the isConnectedTimeout do nothing
-        when(vertx.setTimer(eq(isConnectedTimeout), VertxMockSupport.anyHandler())).thenAnswer(invocation -> 0L);
-        final AtomicBoolean isConnectedInvocationsDone = new AtomicBoolean(false);
-        final AtomicReference<Future<Void>> isConnected1FutureRef = new AtomicReference<>();
-        final AtomicReference<Future<Void>> isConnectedTimeoutForcedFutureRef = new AtomicReference<>();
-        final AtomicReference<Future<Void>> isConnected2FutureRef = new AtomicReference<>();
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection can be established on the third attempt only
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
-            @Override
-            public void connect(final ProtonClientOptions options, final String username, final String password,
-                                final String containerId,
-                                final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                                final Handler<ProtonConnection> disconnectHandler,
-                                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                // and GIVEN "isConnected" invocations done while the "connect" invocation is still in progress
-                if (isConnectedInvocationsDone.compareAndSet(false, true)) {
-                    isConnected1FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
-                    isConnectedTimeoutForcedFutureRef.set(honoConnection.isConnected(1L));
-                    isConnected2FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
-                    // assert "isConnected" invocations have not completed yet, apart from the one with the forced timeout
-                    ctx.verify(() -> {
-                        assertThat(isConnected1FutureRef.get().isComplete()).isFalse();
-                        assertThat(isConnectedTimeoutForcedFutureRef.get().failed()).isTrue();
-                        assertThat(isConnected2FutureRef.get().isComplete()).isFalse();
-                    });
-                }
-                super.connect(options, username, password, containerId, closeHandler, disconnectHandler, connectionResultHandler);
-            }
-        };
-        connectionFactory.setExpectedFailingConnectionAttempts(2);
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN trying to connect
-        honoConnection.connect()
-                // THEN the "isConnected" futures succeed
-                .compose(v -> CompositeFuture.all(isConnected1FutureRef.get(), isConnected2FutureRef.get()))
-                .onFailure(ctx::failNow);
-
-        ctx.verify(() -> {
-            // and the client fails twice to connect
-            assertThat(connectionFactory.awaitFailure()).isTrue();
-            // and succeeds to connect on the third attempt
-            assertThat(connectionFactory.await()).isTrue();
-        });
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that {@link HonoConnectionImpl#isConnected(long)} only completes once a concurrent
-     * connection attempt (which eventually fails here) is finished.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testIsConnectedWithTimeoutFailsAfterConcurrentReconnectFailed(final VertxTestContext ctx) {
-
-        final long isConnectedTimeout = 44444L;
-        // let the vertx timer for the isConnectedTimeout do nothing
-        when(vertx.setTimer(eq(isConnectedTimeout), VertxMockSupport.anyHandler())).thenAnswer(invocation -> 0L);
-        final AtomicBoolean isConnectedInvocationsDone = new AtomicBoolean(false);
-        final AtomicReference<Future<Void>> isConnected1FutureRef = new AtomicReference<>();
-        final AtomicReference<Future<Void>> isConnected2FutureRef = new AtomicReference<>();
-        // GIVEN a client that is configured to connect to a peer
-        // to which the connection can be established on the third attempt only
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
-            @Override
-            public void connect(final ProtonClientOptions options, final String username, final String password,
-                                final String containerId,
-                                final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                                final Handler<ProtonConnection> disconnectHandler,
-                                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                // and GIVEN "isConnected" invocations done while the "connect" invocation is still in progress
-                if (isConnectedInvocationsDone.compareAndSet(false, true)) {
-                    isConnected1FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
-                    isConnected2FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
-                    // assert "isConnected" invocations have not completed yet
-                    ctx.verify(() -> {
-                        assertThat(isConnected1FutureRef.get().isComplete()).isFalse();
-                        assertThat(isConnected2FutureRef.get().isComplete()).isFalse();
-                    });
-                }
-                super.connect(options, username, password, containerId, closeHandler, disconnectHandler, connectionResultHandler);
-            }
-        };
-        connectionFactory.setExpectedFailingConnectionAttempts(3);
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().onComplete(ctx.failing(t -> {
-            ctx.verify(() -> {
-                // THEN the connection attempt fails and the "isConnected" futures fail as well
-                assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-
-                assertThat(isConnected1FutureRef.get().failed()).isTrue();
-                assertThat(((ServerErrorException) isConnected1FutureRef.get().cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-
-                assertThat(isConnected2FutureRef.get().failed()).isTrue();
-                assertThat(((ServerErrorException) isConnected2FutureRef.get().cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-            });
-        }));
-        // and the client has indeed tried three times in total before giving up
-        ctx.verify(() -> assertThat(connectionFactory.awaitFailure()).isTrue());
-        ctx.completeNow();
-    }
-
-    /**
-     * Verifies that the client does not try to re-connect to a server instance if the client was shutdown.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testClientDoesNotTriggerReconnectionAfterShutdown(final VertxTestContext ctx) {
-
-        // GIVEN a client that tries to connect to a server but does not succeed
-        final AtomicInteger connectAttempts = new AtomicInteger(0);
-        final ConnectionFactory factory = mock(ConnectionFactory.class);
-        when(factory.getHost()).thenReturn("server");
-        when(factory.getPort()).thenReturn(5672);
-        doAnswer(invocation -> {
-            final Handler<AsyncResult<ProtonConnection>> resultHandler = invocation.getArgument(6);
-            if (connectAttempts.incrementAndGet() == 3) {
-                // WHEN client gets shutdown
-                honoConnection.shutdown();
-            }
-            resultHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)));
-            return null;
-        }).when(factory).connect(any(), any(), any(), anyString(), VertxMockSupport.anyHandler(),
-                VertxMockSupport.anyHandler(), VertxMockSupport.anyHandler());
-        honoConnection = new HonoConnectionImpl(vertx, factory, props);
-        honoConnection.connect().onComplete(ctx.failing(cause -> {
-                    // THEN three attempts have been made to connect
-                    ctx.verify(() -> assertThat(connectAttempts.get()).isEqualTo(3));
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that the close handler set on a receiver link calls
-     * the close hook passed in when creating the receiver.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCloseHandlerCallsCloseHook(final VertxTestContext ctx) {
-        testHandlerCallsCloseHook(ctx, (receiver, captor) -> verify(receiver).closeHandler(captor.capture()));
-    }
-
-    /**
-     * Verifies that the detach handler set on a receiver link calls
-     * the close hook passed in when creating the receiver.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testDetachHandlerCallsCloseHook(final VertxTestContext ctx) {
-        testHandlerCallsCloseHook(ctx, (receiver, captor) -> verify(receiver).detachHandler(captor.capture()));
-    }
-
-    private void testHandlerCallsCloseHook(
-            final VertxTestContext ctx,
-            final BiConsumer<ProtonReceiver, ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>>> handlerCaptor) {
-
-        // GIVEN an established connection
-        final Source source = mock(Source.class);
-        when(source.getAddress()).thenReturn("source/address");
-        final ProtonReceiver receiver = mock(ProtonReceiver.class);
-        when(receiver.isOpen()).thenReturn(Boolean.TRUE);
-        when(receiver.getSource()).thenReturn(source);
-        when(receiver.getRemoteSource()).thenReturn(source);
-        when(session.createReceiver(anyString())).thenReturn(receiver);
-
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-        final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> captor = VertxMockSupport.argumentCaptorHandler();
-
-        honoConnection.connect()
-            .compose(c -> {
-
-                // WHEN creating a receiver link with a close hook
-
-                final Future<ProtonReceiver> r = c.createReceiver(
-                        "source",
-                        ProtonQoS.AT_LEAST_ONCE,
-                        mock(ProtonMessageHandler.class),
-                        remoteCloseHook);
-
-                // wait for peer's attach frame
-                final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> openHandlerCaptor = VertxMockSupport.argumentCaptorHandler();
-                ctx.verify(() -> verify(receiver).openHandler(openHandlerCaptor.capture()));
-                openHandlerCaptor.getValue().handle(Future.succeededFuture(receiver));
-
-                return r;
-            })
-            .onComplete(ctx.succeeding(recv -> {
-
-                // WHEN the peer sends a detach frame
-                handlerCaptor.accept(receiver, captor);
-                captor.getValue().handle(Future.succeededFuture(receiver));
-
-                ctx.verify(() -> {
-                    // THEN the close hook is called
-                    verify(remoteCloseHook).handle(any());
-
-                    // and the receiver link is closed
-                    verify(receiver).close();
-                    verify(receiver).free();
-                });
-                ctx.completeNow();
-            }));
-
-    }
-
-    /**
-     * Verifies that the client sets configured properties on receiver links
-     * that it creates.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateReceiverSetsConfiguredProperties(final VertxTestContext ctx) {
-
-        // GIVEN a client configured with some properties
-        props.setMaxMessageSize(3000L);
-        props.setInitialCredits(123);
-        final ProtonReceiver receiver = mock(ProtonReceiver.class);
-        when(session.createReceiver(anyString())).thenReturn(receiver);
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // WHEN establishing a connection
-        honoConnection.connect()
-            .onComplete(ctx.succeeding(c -> {
-
-                // and then creating a receiver
-                c.createReceiver(
-                        "source",
-                        ProtonQoS.AT_LEAST_ONCE,
-                        (delivery, msg) -> {},
-                        remoteCloseHook);
-                ctx.verify(() -> {
-                    // THEN the client configures the receiver according to the given properties
-                    verify(receiver).setMaxMessageSize(eq(new UnsignedLong(3000L)));
-                    verify(receiver).setQoS(ProtonQoS.AT_LEAST_ONCE);
-                    verify(receiver).setPrefetch(123);
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the attempt to create a receiver fails with a
-     * {@code ServiceInvocationException} if the remote peer refuses
-     * to open the link with an error condition.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateReceiverFailsForErrorCondition(final VertxTestContext ctx) {
-
-        testCreateReceiverFails(ctx, () -> new ErrorCondition(AmqpError.RESOURCE_LIMIT_EXCEEDED, "unauthorized"), cause -> {
-            return cause instanceof ServiceInvocationException;
-        });
-    }
-
-    /**
-     * Verifies that the attempt to create a receiver fails with a
-     * {@code ClientErrorException} if the remote peer refuses
-     * to open the link without an error condition.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateReceiverFailsWithoutErrorCondition(final VertxTestContext ctx) {
-
-        testCreateReceiverFails(ctx, () -> null, cause -> {
-            return cause instanceof ClientErrorException &&
-                    ((ClientErrorException) cause).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND;
-        });
-    }
-
-    private void testCreateReceiverFails(
-            final VertxTestContext ctx,
-            final Supplier<ErrorCondition> errorSupplier,
-            final Predicate<Throwable> failureAssertion) {
-
-        final ProtonReceiver receiver = mock(ProtonReceiver.class);
-        when(receiver.getRemoteCondition()).thenReturn(errorSupplier.get());
-        when(session.createReceiver(anyString())).thenReturn(receiver);
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-        when(vertx.setTimer(anyLong(), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            // do not run timers immediately
-            return 0L;
-        });
-
-        // GIVEN an established connection
-        honoConnection.connect()
-        .compose(c -> {
-
-            // WHEN creating a receiver
-            final Future<ProtonReceiver> r = c.createReceiver(
-                    "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, remoteCloseHook);
-            ctx.verify(() -> {
-                // and when the peer rejects to open the link
-                final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> openHandler = VertxMockSupport.argumentCaptorHandler();
-                verify(receiver).openHandler(openHandler.capture());
-                openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
-            });
-            return r;
-        })
-        .onComplete(ctx.failing(t -> {
-            ctx.verify(() -> {
-                // THEN link establishment is failed after the configured amount of time
-                verify(vertx).setTimer(eq(props.getLinkEstablishmentTimeout()), VertxMockSupport.anyHandler());
-                // with the expected error condition
-                assertThat(failureAssertion.test(t)).isTrue();
-                verify(remoteCloseHook, never()).handle(anyString());
-            });
-            ctx.completeNow();
-        }));
-    }
-
-    /**
-     * Verifies that the attempt to create a receiver fails with a
-     * {@code ServerErrorException} if the remote peer doesn't
-     * send its attach frame in time.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateReceiverFailsOnTimeout(final VertxTestContext ctx) {
-
-        final ProtonReceiver receiver = mock(ProtonReceiver.class);
-        when(receiver.isOpen()).thenReturn(Boolean.TRUE);
-        when(session.createReceiver(anyString())).thenReturn(receiver);
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> honoConnection.createReceiver(
-                "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, remoteCloseHook))
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> {
-                    assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-                    verify(receiver).open();
-                    verify(receiver).close();
-                    verify(remoteCloseHook, never()).handle(anyString());
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the attempt to create a receiver fails with a
-     * {@code ServerErrorException} if the connection gets disconnected
-     * before the remote peer has sent its attach frame. It is verified
-     * that this is done before the link establishment timeout.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateReceiverFailsOnDisconnectBeforeOpen(final VertxTestContext ctx) {
-
-        final long linkEstablishmentTimeout = 444L; // choose a distinct value here
-        props.setLinkEstablishmentTimeout(linkEstablishmentTimeout);
-        // don't run linkEstablishmentTimeout timer handler
-        when(vertx.setTimer(eq(linkEstablishmentTimeout), VertxMockSupport.anyHandler())).thenAnswer(invocation -> 0L);
-
-        final Source source = mock(Source.class);
-        when(source.getAddress()).thenReturn("source/address");
-        final ProtonReceiver receiver = mock(ProtonReceiver.class);
-        when(receiver.isOpen()).thenReturn(Boolean.TRUE);
-        when(receiver.getSource()).thenReturn(source);
-        when(receiver.getRemoteSource()).thenReturn(source);
-        when(session.createReceiver(anyString())).thenReturn(receiver);
-
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> {
-                // WHEN creating a receiver link with a close hook
-                final Future<ProtonReceiver> result = honoConnection.createReceiver("source", ProtonQoS.AT_LEAST_ONCE,
-                        mock(ProtonMessageHandler.class), remoteCloseHook);
-                // THEN the result is not completed at first
-                ctx.verify(() -> assertThat(result.isComplete()).isFalse());
-                // WHEN the downstream connection fails
-                connectionFactory.getDisconnectHandler().handle(con);
-                return result;
-            })
-            // THEN the attempt is failed
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the attempt to create a sender fails with a
-     * {@code ServiceInvocationException} if the remote peer refuses
-     * to open the link with an error condition.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsForErrorCondition(final VertxTestContext ctx) {
-
-        testCreateSenderFails(
-                ctx,
-                () -> new ErrorCondition(AmqpError.RESOURCE_LIMIT_EXCEEDED, "unauthorized"),
-                cause -> {
-                    return cause instanceof ServiceInvocationException;
-                });
-    }
-
-    /**
-     * Verifies that the attempt to create a sender fails with a
-     * {@code ClientErrorException} if the remote peer refuses
-     * to open the link without an error condition.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsWithoutErrorCondition(final VertxTestContext ctx) {
-
-        testCreateSenderFails(
-                ctx,
-                () -> null,
-                cause -> {
-                    return cause instanceof ClientErrorException &&
-                        ((ClientErrorException) cause).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND;
-                });
-    }
-
-    private void testCreateSenderFails(
-            final VertxTestContext ctx,
-            final Supplier<ErrorCondition> errorSupplier,
-            final Predicate<Throwable> failureAssertion) {
-
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.getRemoteCondition()).thenReturn(errorSupplier.get());
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-        when(vertx.setTimer(anyLong(), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            // do not run timers immediately
-            return 0L;
-        });
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> {
-                final Future<ProtonSender> s = honoConnection.createSender(
-                        "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook);
-                ctx.verify(() -> {
-                    verify(vertx).setTimer(eq(props.getLinkEstablishmentTimeout()), VertxMockSupport.anyHandler());
-                    final ArgumentCaptor<Handler<AsyncResult<ProtonSender>>> openHandler = VertxMockSupport.argumentCaptorHandler();
-                    verify(sender).openHandler(openHandler.capture());
-                    openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
-                });
-                return s;
-            })
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> {
-                    assertThat(failureAssertion.test(t)).isTrue();
-                    verify(remoteCloseHook, never()).handle(anyString());
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the attempt to create a sender fails with a
-     * {@code ServerErrorException} if the remote peer doesn't
-     * send its attach frame in time.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsOnTimeout(final VertxTestContext ctx) {
-
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> honoConnection.createSender(
-                "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> {
-                    assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-                    verify(sender).open();
-                    verify(sender).close();
-                    verify(remoteCloseHook, never()).handle(anyString());
-                });
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the attempt to create a sender for a {@code null} target address
-     * fails with a {@code ServerErrorException} if the remote peer doesn't
-     * support the anonymous terminus.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsForUnsupportedAnonTerminus(final VertxTestContext ctx) {
-
-        when(con.getRemoteOfferedCapabilities()).thenReturn(new Symbol[] {Symbol.valueOf("some-feature")});
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> honoConnection.createSender(
-                null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> {
-                    // THEN the attempt fails
-                    assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_NOT_IMPLEMENTED);
-                    // and the remote close hook is not invoked
-                    verify(remoteCloseHook, never()).handle(anyString());
-                });
-                ctx.completeNow();
-            }));
-
-    }
-
-    /**
-     * Verifies that the attempt to create a sender fails with a
-     * {@code ServerErrorException} if the remote peer sends a
-     * {@code null} target in its attach frame.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsIfPeerDoesNotCreateTerminus(final VertxTestContext ctx) {
-
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.getRemoteTarget()).thenReturn(null);
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> {
-                // WHEN the client tries to open a sender link
-                final Future<ProtonSender> s = c.createSender(
-                        TelemetryConstants.TELEMETRY_ENDPOINT, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook);
-                ctx.verify(() -> {
-                    final ArgumentCaptor<Handler<AsyncResult<ProtonSender>>> openHandler = VertxMockSupport.argumentCaptorHandler();
-                    verify(sender).open();
-                    verify(sender).openHandler(openHandler.capture());
-                    // and the peer does not allocate a local terminus for the link
-                    openHandler.getValue().handle(Future.succeededFuture(sender));
-                });
-                return s;
-            })
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> {
-
-                    // THEN the link does not get established
-                    assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
-                    // and the remote close hook does not get invoked
-                    verify(remoteCloseHook, never()).handle(anyString());
-                });
-                ctx.completeNow();
-            }));
-
-    }
-
-    /**
-     * Verifies that the attempt to create a sender fails with a
-     * {@code ClientErrorException} if the remote peer does not support the
-     * client's minimum max-message-size.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsForInsufficientMaxMessageSize(final VertxTestContext ctx) {
-
-        // GIVEN a client that requires a minimum max-message-size of 2kb
-        props.setMinMaxMessageSize(2048L);
-
-        // WHEN trying to open a sender link to a peer that has a max-message-size of 1kb
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Target target = new Target();
-        target.setAddress("someAddress");
-        when(sender.getRemoteTarget()).thenReturn(target);
-        when(sender.getRemoteMaxMessageSize()).thenReturn(new UnsignedLong(1024L));
-        // mock handlers
-        doAnswer(AdditionalAnswers.answerVoid(
-                (final Handler<AsyncResult<ProtonSender>> handler) -> handler.handle(Future.succeededFuture(sender))))
-                        .when(sender).openHandler(VertxMockSupport.anyHandler());
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        honoConnection.connect()
-            .compose(c -> honoConnection.createSender(
-                "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .onComplete(ctx.failing(t -> {
-                // THEN link establishment fails
-                ctx.verify(() -> {
-                    assertThat(t).isInstanceOf(ClientErrorException.class);
-                    // and the sender link has been closed locally
-                    verify(sender).close();
-                });
-                ctx.completeNow();
-            }));
-
-    }
-
-    /**
-     * Verifies that the attempt to create a sender succeeds when sender never gets credits.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderThatGetsNoCredits(final VertxTestContext ctx) {
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Target target = new Target();
-        target.setAddress("someAddress");
-        when(sender.getRemoteTarget()).thenReturn(target);
-        when(sender.getCredit()).thenReturn(0);
-        // just invoke openHandler with succeeded future
-        doAnswer(AdditionalAnswers.answerVoid(
-                (final Handler<AsyncResult<ProtonSender>> handler) -> handler.handle(Future.succeededFuture(sender))))
-                        .when(sender).openHandler(VertxMockSupport.anyHandler());
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> honoConnection.createSender(
-                "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .onComplete(ctx.succeeding(s -> {
-                    ctx.verify(() -> {
-                        assertThat(s).isEqualTo(sender);
-                        // sendQueueDrainHandler gets unset
-                        verify(sender).sendQueueDrainHandler(null);
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that the attempt to create a sender succeeds when sender gets credits within flowLatency.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderThatGetsDelayedCredits(final VertxTestContext ctx) {
-        // We need to delay timer task. In this case simply forever.
-        final long waitOnCreditsTimerId = 23;
-        when(vertx.setTimer(anyLong(), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
-            // do not call handler any time
-            return waitOnCreditsTimerId;
-        });
-        when(vertx.cancelTimer(waitOnCreditsTimerId)).thenReturn(true);
-
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Target target = new Target();
-        target.setAddress("someAddress");
-        when(sender.getRemoteTarget()).thenReturn(target);
-        when(sender.getCredit()).thenReturn(0);
-        // mock handlers
-        doAnswer(AdditionalAnswers.answerVoid(
-                (final Handler<AsyncResult<ProtonSender>> handler) -> handler.handle(Future.succeededFuture(sender))))
-                        .when(sender).openHandler(VertxMockSupport.anyHandler());
-        doAnswer(AdditionalAnswers.answerVoid(
-                (final Handler<ProtonSender> handler) -> handler.handle(sender)))
-                        .when(sender).sendQueueDrainHandler(VertxMockSupport.anyHandler());
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> honoConnection.createSender(
-                "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .onComplete(ctx.succeeding(s -> {
-                    ctx.verify(() -> {
-                        assertThat(s).isEqualTo(sender);
-                        // sendQueueDrainHandler gets unset
-                        verify(sender).sendQueueDrainHandler(null);
-                        verify(vertx).cancelTimer(waitOnCreditsTimerId);
-                    });
-                    ctx.completeNow();
-                }));
-    }
-
-    /**
-     * Verifies that the attempt to create a sender fails with a
-     * {@code ServerErrorException} if the connection gets disconnected
-     * before the remote peer has sent its attach frame. It is verified
-     * that this is done before the link establishment timeout.
-     *
-     * @param ctx The vert.x test context.
-     */
-    @Test
-    public void testCreateSenderFailsOnDisconnectBeforeOpen(final VertxTestContext ctx) {
-        final long linkEstablishmentTimeout = 444L; // choose a distinct value here
-        props.setLinkEstablishmentTimeout(linkEstablishmentTimeout);
-        // don't run linkEstablishmentTimeout timer handler
-        when(vertx.setTimer(eq(linkEstablishmentTimeout), VertxMockSupport.anyHandler())).thenAnswer(invocation -> 0L);
-
-        final ProtonSender sender = mock(ProtonSender.class);
-        when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(session.createSender(anyString())).thenReturn(sender);
-        final Target target = new Target();
-        target.setAddress("someAddress");
-        when(sender.getRemoteTarget()).thenReturn(target);
-        when(sender.getCredit()).thenReturn(0);
-        // mock handlers
-        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
-
-        // GIVEN an established connection
-        honoConnection.connect()
-            .compose(c -> {
-                // WHEN creating a sender link with a close hook
-                final Future<ProtonSender> result = honoConnection.createSender(
-                        "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook);
-                // THEN the result is not completed at first
-                ctx.verify(() -> assertThat(result.isComplete()).isFalse());
-                // WHEN the downstream connection fails
-                connectionFactory.getDisconnectHandler().handle(con);
-                return result;
-            })
-            // THEN the attempt is failed
-            .onComplete(ctx.failing(t -> {
-                ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the calculation of the maximum reconnect delay value works as expected (also for high reconnect
-     * attempt numbers).
-     */
-    @Test
-    public void testGetReconnectMaxDelay() {
-        final long reconnectMaxDelay = 20000;
-        props.setReconnectMaxDelay(reconnectMaxDelay);
-        props.setReconnectDelayIncrement(100);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        assertThat(honoConnection.getReconnectMaxDelay(0)).isEqualTo(0);
-        assertThat(honoConnection.getReconnectMaxDelay(1)).isEqualTo(100);
-        assertThat(honoConnection.getReconnectMaxDelay(3)).isEqualTo(400);
-        assertThat(honoConnection.getReconnectMaxDelay(31)).isEqualTo(reconnectMaxDelay);
-        assertThat(honoConnection.getReconnectMaxDelay(Integer.MAX_VALUE)).isEqualTo(reconnectMaxDelay);
-
-        props.setReconnectDelayIncrement(Long.MAX_VALUE);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        assertThat(honoConnection.getReconnectMaxDelay(31)).isEqualTo(reconnectMaxDelay);
-        assertThat(honoConnection.getReconnectMaxDelay(Integer.MAX_VALUE)).isEqualTo(reconnectMaxDelay);
-    }
-}
