diff --git a/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java b/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java
index 9503924b0..21ca12f2c 100644
--- a/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java
@@ -13,8 +13,12 @@
 
 package org.eclipse.hono.client;
 
+import java.net.HttpURLConnection;
+import java.util.Objects;
 import java.util.Optional;
 
+import org.apache.qpid.proton.amqp.transport.AmqpError;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.eclipse.hono.util.RegistrationConstants;
 import org.eclipse.hono.util.RegistrationResult;
 import org.eclipse.hono.util.RequestResponseResult;
@@ -74,4 +78,22 @@ public abstract class StatusCodeMapper {
             return new ServiceInvocationException(statusCode, detailMessage);
         }
     }
+
+    /**
+     * Creates an exception for an AMQP error condition.
+     * 
+     * @param error The error condition.
+     * @return The exception.
+     * @throws NullPointerException if error is {@code null}.
+     */
+    public static final ServiceInvocationException from(final ErrorCondition error) {
+
+        Objects.requireNonNull(error);
+
+        if (AmqpError.RESOURCE_LIMIT_EXCEEDED.equals(error.getCondition())) {
+            return new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, error.getDescription());
+        } else {
+            return new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, error.getDescription());
+        }
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index ab6277031..1a5832e10 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -13,13 +13,18 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.net.HttpURLConnection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -158,7 +163,7 @@ public abstract class AbstractHonoClient {
      * @param qos The quality of service to use for the link.
      * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
      * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail if the link cannot be opened.
+     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
      * @throws NullPointerException if any of the arguments other than close hook is {@code null}.
      */
     protected static final Future<ProtonSender> createSender(
@@ -195,8 +200,14 @@ public abstract class AbstractHonoClient {
                         result.complete(sender);
                     }
                 } else {
-                    LOG.debug("opening sender [{}] failed: {}", targetAddress, senderOpen.cause().getMessage());
-                    result.fail(senderOpen.cause());
+                    final ErrorCondition error = sender.getRemoteCondition();
+                    if (error == null) {
+                        LOG.debug("opening sender [{}] failed", targetAddress, senderOpen.cause());
+                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, "cannot open sender", senderOpen.cause()));
+                    } else {
+                        LOG.debug("opening sender [{}] failed: {} - {}", targetAddress, error.getCondition(), error.getDescription());
+                        result.fail(StatusCodeMapper.from(error));
+                    }
                 }
             });
             sender.detachHandler(remoteDetached -> {
@@ -242,7 +253,7 @@ public abstract class AbstractHonoClient {
      * @param messageHandler The handler to invoke with every message received.
      * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
      * @return A future for the created link. The future will be completed once the link is open.
-     *         The future will fail if the link cannot be opened.
+     *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
      * @throws NullPointerException if any of the arguments other than close hook is {@code null}.
      */
     protected static final Future<ProtonReceiver> createReceiver(
@@ -274,17 +285,19 @@ public abstract class AbstractHonoClient {
                     LOG.trace("handling message [remotely settled: {}, queued messages: {}, remaining credit: {}]", delivery.remotelySettled(), receiver.getQueued(), remainingCredits);
                 }
             });
-            receiver.openHandler(openAttach -> {
-                if(openAttach.failed()) {
-                    LOG.debug("receiver open attach failed [{}] by peer [{}]: {}", receiver.getRemoteSource(), con.getRemoteContainer(), openAttach.cause().getMessage());
-                    result.fail(openAttach.cause());
-                }
-                else {
-                    if (LOG.isTraceEnabled()) {
-                        LOG.trace("receiver open attach succeeded [{}] by peer [{}]", receiver.getRemoteSource(),
-                                con.getRemoteContainer());
+            receiver.openHandler(recvOpen -> {
+                if(recvOpen.succeeded()) {
+                    LOG.debug("receiver open [source: {}]", sourceAddress);
+                    result.complete(recvOpen.result());
+                } else {
+                    final ErrorCondition error = receiver.getRemoteCondition();
+                    if (error == null) {
+                        LOG.debug("opening receiver [{}] failed", sourceAddress, recvOpen.cause());
+                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, "cannot open receiver", recvOpen.cause()));
+                    } else {
+                        LOG.debug("opening receiver [{}] failed: {} - {}", sourceAddress, error.getCondition(), error.getDescription());
+                        result.fail(StatusCodeMapper.from(error));
                     }
-                    result.complete(openAttach.result());
                 }
             });
             receiver.detachHandler(remoteDetached -> {
@@ -312,6 +325,5 @@ public abstract class AbstractHonoClient {
             receiver.open();
         });
         return result;
-
     }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
new file mode 100644
index 000000000..cc84a07dd
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
@@ -0,0 +1,181 @@
+/**
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 1.0 which is available at
+ * https://www.eclipse.org/legal/epl-v10.html
+ *
+ * SPDX-License-Identifier: EPL-1.0
+ */
+
+package org.eclipse.hono.client.impl;
+
+import static org.hamcrest.CoreMatchers.instanceOf;
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.*;
+
+import java.net.HttpURLConnection;
+
+import org.apache.qpid.proton.amqp.transport.AmqpError;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
+
+
+/**
+ * Tests verifying behavior of {@link AbstractHonoClient}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class AbstractHonoClientTest {
+
+    /**
+     * Time out each test after five seconds.
+     */
+    @Rule
+    public final Timeout timeout = Timeout.seconds(5);
+
+    private Context context;
+    private ClientConfigProperties props;
+
+    /**
+     * Sets up the fixture.
+     */
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+        props = new ClientConfigProperties();
+        context = mock(Context.class);
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgumentAt(0, Handler.class);
+            handler.handle(null);
+            return null;
+        }).when(context).runOnContext(any(Handler.class));
+    }
+
+    /**
+     * Verifies that the attempt to create a sender fails with a
+     * {@code ServiceInvocationException} if the remote peer refuses
+     * to open the link.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void testCreateSenderFailsForErrorCondition(final TestContext ctx) {
+
+        final ProtonSender sender = mock(ProtonSender.class);
+        when(sender.getRemoteCondition()).thenReturn(new ErrorCondition(AmqpError.RESOURCE_LIMIT_EXCEEDED, "unauthorized"));
+        final ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createSender(anyString())).thenReturn(sender);
+
+        final Future<ProtonSender> result = AbstractHonoClient.createSender(context, props, con,
+                "target", ProtonQoS.AT_LEAST_ONCE, null);
+
+        final ArgumentCaptor<Handler> openHandler = ArgumentCaptor.forClass(Handler.class);
+        verify(sender).openHandler(openHandler.capture());
+        openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
+        assertTrue(result.failed());
+        assertThat(result.cause(), instanceOf(ServiceInvocationException.class));
+    }
+
+    /**
+     * Verifies that the attempt to create a sender fails with a
+     * {@code ServiceInvocationException} if the remote peer refuses
+     * to open the link.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void testCreateSenderFailsWithoutErrorCondition(final TestContext ctx) {
+
+        final ProtonSender sender = mock(ProtonSender.class);
+        final ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createSender(anyString())).thenReturn(sender);
+
+        final Future<ProtonSender> result = AbstractHonoClient.createSender(context, props, con,
+                "target", ProtonQoS.AT_LEAST_ONCE, null);
+
+        final ArgumentCaptor<Handler> openHandler = ArgumentCaptor.forClass(Handler.class);
+        verify(sender).openHandler(openHandler.capture());
+        openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
+        assertTrue(result.failed());
+        assertThat(((ClientErrorException) result.cause()).getErrorCode(), is(HttpURLConnection.HTTP_NOT_FOUND));
+    }
+
+    /**
+     * Verifies that the attempt to create a receiver fails with a
+     * {@code ServiceInvocationException} if the remote peer refuses
+     * to open the link.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void testCreateReceiverFailsForErrorCondition(final TestContext ctx) {
+
+        final ProtonReceiver sender = mock(ProtonReceiver.class);
+        when(sender.getRemoteCondition()).thenReturn(new ErrorCondition(AmqpError.RESOURCE_LIMIT_EXCEEDED, "unauthorized"));
+        final ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createReceiver(anyString())).thenReturn(sender);
+
+        final Future<ProtonReceiver> result = AbstractHonoClient.createReceiver(context, props, con,
+                "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, null);
+
+        final ArgumentCaptor<Handler> openHandler = ArgumentCaptor.forClass(Handler.class);
+        verify(sender).openHandler(openHandler.capture());
+        openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
+        assertTrue(result.failed());
+        assertThat(result.cause(), instanceOf(ServiceInvocationException.class));
+    }
+
+    /**
+     * Verifies that the attempt to create a receiver fails with a
+     * {@code ServiceInvocationException} if the remote peer refuses
+     * to open the link.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void testCreateReceiverFailsWithoutErrorCondition(final TestContext ctx) {
+
+        final ProtonReceiver sender = mock(ProtonReceiver.class);
+        final ProtonConnection con = mock(ProtonConnection.class);
+        when(con.createReceiver(anyString())).thenReturn(sender);
+
+        final Future<ProtonReceiver> result = AbstractHonoClient.createReceiver(context, props, con,
+                "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, null);
+
+        final ArgumentCaptor<Handler> openHandler = ArgumentCaptor.forClass(Handler.class);
+        verify(sender).openHandler(openHandler.capture());
+        openHandler.getValue().handle(Future.failedFuture(new IllegalStateException()));
+        assertTrue(result.failed());
+        assertThat(((ClientErrorException) result.cause()).getErrorCode(), is(HttpURLConnection.HTTP_NOT_FOUND));
+    }
+}
