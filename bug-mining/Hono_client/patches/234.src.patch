diff --git a/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java b/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
index c0ff56592..a9dfea354 100644
--- a/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
@@ -13,8 +13,15 @@
 
 package org.eclipse.hono.client;
 
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
 import org.eclipse.hono.client.impl.CommandTargetMapperImpl;
 import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.RegistrationConstants;
 
 import io.opentracing.SpanContext;
 import io.opentracing.Tracer;
@@ -45,6 +52,53 @@ import io.vertx.core.json.JsonObject;
  */
 public interface CommandTargetMapper {
 
+    /**
+     * Access to collaborators that the mapper needs for doing its work.
+     *
+     */
+    interface CommandTargetMapperContext {
+
+        /**
+         * Gets the device identifiers of the gateways that an edge device may connect via.
+         *
+         * @param tenant The tenant that the device belongs to.
+         * @param deviceId The device id.
+         * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+         *            Implementing classes should use this as the parent for any span they create for tracing the execution
+         *            of this operation.
+         * @return The gateway identifiers.
+         * @throws NullPointerException if any of the parameters except context is {@code null}.
+         */
+        Future<List<String>> getViaGateways(String tenant, String deviceId, SpanContext context);
+
+        /**
+         * Gets information about the adapter instances that can handle a command for the given device.
+         * <p>
+         * See Hono's <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
+         * specification</a> for a detailed description of the method's behaviour and the returned JSON object.
+         * <p>
+         * If no adapter instances are found, the returned future is failed.
+         *
+         * @param tenant The tenant that the device belongs to.
+         * @param deviceId The device id.
+         * @param viaGateways The list of gateways that may act on behalf of the given device.
+         * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+         *            Implementing classes should use this as the parent for any span they create for tracing the execution
+         *            of this operation.
+         * @return A future indicating the outcome of the operation.
+         *         <p>
+         *         If instances were found, the future will be succeeded with a JSON object containing one or more mappings
+         *         from device id to adapter instance id. Otherwise the future will be failed with a
+         *         {@link org.eclipse.hono.client.ServiceInvocationException}.
+         * @throws NullPointerException if any of the parameters except context is {@code null}.
+         */
+        Future<JsonObject> getCommandHandlingAdapterInstances(
+                String tenant,
+                String deviceId,
+                List<String> viaGateways,
+                SpanContext context);
+    }
+
     /**
      * Creates a new {@link CommandTargetMapper} using the default implementation.
      *
@@ -57,16 +111,65 @@ public interface CommandTargetMapper {
     }
 
     /**
-     * Initializes the CommandTargetMapper with the given components.
+     * Creates a mapper context for client factories.
      *
-     * @param registrationClientFactory The factory to create a registration client instance. Note that no
-     *            initialization of this factory will be done here, that is supposed to be done by the calling method.
-     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no
-     *            initialization of this factory will be done here, that is supposed to be done by the calling method.
-     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @param registrationClientFactory The factory for creating Device Registration service clients.
+     * @param deviceConnectionClientFactory The factory for creating Device Connection service clients.
+     * @return The mapper context.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    static CommandTargetMapperContext createContext(
+            final RegistrationClientFactory registrationClientFactory,
+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {
+
+        Objects.requireNonNull(registrationClientFactory);
+        Objects.requireNonNull(deviceConnectionClientFactory);
+
+        return new CommandTargetMapperContext() {
+
+            @Override
+            public Future<List<String>> getViaGateways(
+                    final String tenant,
+                    final String deviceId,
+                    final SpanContext context) {
+
+                Objects.requireNonNull(tenant);
+                Objects.requireNonNull(deviceId);
+
+                return registrationClientFactory.getOrCreateRegistrationClient(tenant)
+                        .compose(client -> client.assertRegistration(deviceId, null, context))
+                        .map(json -> Optional.ofNullable(json.getJsonArray(RegistrationConstants.FIELD_VIA))
+                                .map(array -> array.stream()
+                                        .filter(String.class::isInstance)
+                                        .map(String.class::cast)
+                                        .collect(Collectors.toList()))
+                                .orElse(Collections.emptyList()));
+            }
+
+            @Override
+            public Future<JsonObject> getCommandHandlingAdapterInstances(
+                    final String tenant, 
+                    final String deviceId,
+                    final List<String> viaGateways,
+                    final SpanContext context) {
+
+                Objects.requireNonNull(tenant);
+                Objects.requireNonNull(deviceId);
+                Objects.requireNonNull(viaGateways);
+
+                return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenant)
+                        .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, context));
+            }
+        };
+    }
+
+    /**
+     * Initializes the mapper with the given context.
+     *
+     * @param context The context that the mapper needs for doing its work.
+     * @throws NullPointerException if context is {@code null}.
      */
-    void initialize(RegistrationClientFactory registrationClientFactory,
-            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);
+    void initialize(CommandTargetMapperContext context);
 
     /**
      * Determines the target protocol adapter instance for a command directed at the given device. Also determines
@@ -90,8 +193,8 @@ public interface CommandTargetMapper {
      * mapped to a gateway here, the {@link DeviceConnectionConstants#FIELD_PAYLOAD_DEVICE_ID} contains the given device
      * id itself.
      * <p>
-     * Note that {@link #initialize(RegistrationClientFactory, BasicDeviceConnectionClientFactory)} has to have been
-     * called already, otherwise a failed future is returned.
+     * Note that {@link #initialize(CommandTargetMapperContext)} has to have been called already,
+     * otherwise a failed future is returned.
      *
      * @param tenantId The tenant identifier.
      * @param deviceId The device identifier.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
index 03805933b..da331f64c 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
@@ -14,21 +14,16 @@
 package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;
 import org.eclipse.hono.client.CommandTargetMapper;
-import org.eclipse.hono.client.RegistrationClientFactory;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.DeviceConnectionConstants;
 import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RegistrationConstants;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -50,8 +45,7 @@ public class CommandTargetMapperImpl implements CommandTargetMapper {
 
     private final Tracer tracer;
     private final AtomicBoolean initialized = new AtomicBoolean(false);
-    private RegistrationClientFactory registrationClientFactory;
-    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;
+    private CommandTargetMapperContext mapperContext;
 
     /**
      * Creates a new GatewayMapperImpl instance.
@@ -64,10 +58,8 @@ public class CommandTargetMapperImpl implements CommandTargetMapper {
     }
 
     @Override
-    public void initialize(final RegistrationClientFactory registrationClientFactory,
-            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {
-        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);
-        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);
+    public void initialize(final CommandTargetMapperContext context) {
+        this.mapperContext = Objects.requireNonNull(context);
         initialized.set(true);
     }
 
@@ -85,19 +77,13 @@ public class CommandTargetMapperImpl implements CommandTargetMapper {
                 .withTag(TracingHelper.TAG_DEVICE_ID, deviceId)
                 .start();
 
-        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)
-                .compose(client -> client.assertRegistration(deviceId, null, span.context()))
+        return mapperContext.getViaGateways(tenantId, deviceId, span.context())
                 .recover(t -> {
-                    LOG.debug("Error getting registration assertion", t);
+                    LOG.debug("Error retrieving gateways authorized to act on behalf of device [tenant-id: {}, device-id: {}]",
+                            tenantId, deviceId, t);
                     return Future.failedFuture(t);
-                }).compose(registrationAssertionJson -> {
-                    final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);
-                    @SuppressWarnings("unchecked")
-                    final List<String> viaGateways = viaObject instanceof JsonArray
-                            ? new ArrayList<String>(((JsonArray) viaObject).getList())
-                            : Collections.emptyList();
-                    return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
-                            .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, span.context()))
+                }).compose(viaGateways -> {
+                    return mapperContext.getCommandHandlingAdapterInstances(tenantId, deviceId, viaGateways, span.context())
                             .compose(resultJson -> determineTargetInstanceJson(resultJson, deviceId, viaGateways, span));
                 }).map(result -> {
                     span.finish();
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
index 8213a170d..f51b12de0 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
@@ -21,14 +21,12 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.DeviceConnectionClientFactory;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.RegistrationClientFactory;
+import org.eclipse.hono.client.CommandTargetMapper.CommandTargetMapperContext;
 import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.RegistrationConstants;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -45,8 +43,7 @@ import io.vertx.core.json.JsonObject;
 public class CommandTargetMapperImplTest {
 
     private CommandTargetMapperImpl commandTargetMapper;
-    private RegistrationClient regClient;
-    private DeviceConnectionClient devConClient;
+    private CommandTargetMapperContext mapperContext;
     private String tenantId;
     private String deviceId;
     private Span span;
@@ -65,17 +62,9 @@ public class CommandTargetMapperImplTest {
 
         tenantId = "testTenant";
         deviceId = "testDevice";
-        regClient = mock(RegistrationClient.class);
-        final RegistrationClientFactory registrationClientFactory = mock(RegistrationClientFactory.class);
-        when(registrationClientFactory.getOrCreateRegistrationClient(anyString()))
-                .thenReturn(Future.succeededFuture(regClient));
-
-        devConClient = mock(DeviceConnectionClient.class);
-        final DeviceConnectionClientFactory deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);
-        when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
-                .thenReturn(Future.succeededFuture(devConClient));
+        mapperContext = mock(CommandTargetMapperContext.class);
         commandTargetMapper = new CommandTargetMapperImpl(tracer);
-        commandTargetMapper.initialize(registrationClientFactory, deviceConnectionClientFactory);
+        commandTargetMapper.initialize(mapperContext);
     }
 
     /**
@@ -85,8 +74,8 @@ public class CommandTargetMapperImplTest {
     @Test
     public void testGetTargetGatewayAndAdapterInstanceUsingDeviceWithNoVia() {
         // GIVEN assertRegistration result with no 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
+        when(mapperContext.getViaGateways(anyString(), anyString(), any()))
+            .thenReturn(Future.succeededFuture(Collections.emptyList()));
 
         // and a getCommandHandlingAdapterInstances result with one object for the device
         final String adapterInstanceId = "adapter1";
@@ -95,7 +84,7 @@ public class CommandTargetMapperImplTest {
         adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId);
         adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
         adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, new JsonArray(Collections.singletonList(adapterInstanceEntry)));
-        when(devConClient.getCommandHandlingAdapterInstances(eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
+        when(mapperContext.getCommandHandlingAdapterInstances(eq(tenantId), eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
 
         // WHEN getTargetGatewayAndAdapterInstance() is invoked
         final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
@@ -116,10 +105,8 @@ public class CommandTargetMapperImplTest {
         final String gatewayId = "testDeviceVia";
 
         // GIVEN assertRegistration result with non-empty 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
+        when(mapperContext.getViaGateways(anyString(), anyString(), any()))
+            .thenReturn(Future.succeededFuture(Collections.singletonList(gatewayId)));
 
         // and a getCommandHandlingAdapterInstances result with one object for the gateway
         final String adapterInstanceId = "adapter1";
@@ -128,7 +115,7 @@ public class CommandTargetMapperImplTest {
         adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, gatewayId);
         adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
         adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, new JsonArray(Collections.singletonList(adapterInstanceEntry)));
-        when(devConClient.getCommandHandlingAdapterInstances(eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
+        when(mapperContext.getCommandHandlingAdapterInstances(eq(tenantId), eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
 
         // WHEN getMappedGatewayDevice() is invoked
         final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
@@ -147,14 +134,11 @@ public class CommandTargetMapperImplTest {
     public void tesGetTargetGatewayAndAdapterInstanceUsingDeviceWithMappedGateway() {
         final String gatewayId = "testDeviceVia";
         final String otherGatewayId = "otherGatewayId";
-
+        final List<String> viaList = new ArrayList<>();
+        viaList.add(gatewayId);
+        viaList.add(otherGatewayId);
         // GIVEN assertRegistration result with non-empty 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray();
-        viaArray.add(gatewayId);
-        viaArray.add(otherGatewayId);
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
+        when(mapperContext.getViaGateways(anyString(), anyString(), any())).thenReturn(Future.succeededFuture(viaList));
 
         // and a getCommandHandlingAdapterInstances result with 2 objects with the one with 'gatewayId' being first
         final String adapterInstanceId = "adapter1";
@@ -171,7 +155,7 @@ public class CommandTargetMapperImplTest {
         adapterInstances.add(adapterInstanceEntry);
         adapterInstances.add(adapterInstanceOtherEntry);
         adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, adapterInstances);
-        when(devConClient.getCommandHandlingAdapterInstances(eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
+        when(mapperContext.getCommandHandlingAdapterInstances(eq(tenantId), eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
 
         // WHEN getMappedGatewayDevice() is invoked
         final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
