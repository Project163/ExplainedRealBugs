diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 6208c5c73..9dc993e2b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -168,12 +168,12 @@ public final class HonoClientImpl implements HonoClient {
 
             connectionFactory.connect(
                     clientOptions,
-                    this::onRemoteClose,
+                    remoteClose -> onRemoteClose(remoteClose, disconnectHandler),
                     failedConnection -> onRemoteDisconnect(failedConnection, disconnectHandler),
                     conAttempt -> {
                         connecting.compareAndSet(true, false);
                         if (conAttempt.failed()) {
-                            reconnect(connectionHandler);
+                            reconnect(connectionHandler, disconnectHandler);
                         } else {
                             setConnection(conAttempt.result());
                             setContext(Vertx.currentContext());
@@ -186,7 +186,7 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    private void reconnect(final Handler<AsyncResult<HonoClient>> connectionHandler) {
+    private void reconnect(final Handler<AsyncResult<HonoClient>> connectionHandler, Handler<ProtonConnection> disconnectHandler) {
 
         if (clientOptions == null || clientOptions.getReconnectAttempts() == 0) {
             connectionHandler.handle(Future.failedFuture("failed to connect"));
@@ -195,18 +195,18 @@ public final class HonoClientImpl implements HonoClient {
             // give Vert.x some time to clean up NetClient
             vertx.setTimer(Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS, tid -> {
                 LOG.info("attempting to re-connect to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
-                connect(clientOptions, connectionHandler);
+                connect(clientOptions, connectionHandler, disconnectHandler);
             });
         }
     }
 
-    private void onRemoteClose(final AsyncResult<ProtonConnection> remoteClose) {
+    private void onRemoteClose(final AsyncResult<ProtonConnection> remoteClose, Handler<ProtonConnection> disconnectHandler) {
         if (remoteClose.failed()) {
             LOG.info("remote server [{}:{}] closed connection with error condition: {}",
                     connectionFactory.getHost(), connectionFactory.getPort(), remoteClose.cause().getMessage());
         }
         connection.close();
-        onRemoteDisconnect(connection, null);
+        onRemoteDisconnect(connection, disconnectHandler);
     }
 
     private void onRemoteDisconnect(final ProtonConnection con, final Handler<ProtonConnection> nextHandler) {
@@ -224,7 +224,7 @@ public final class HonoClientImpl implements HonoClient {
             if (nextHandler != null) {
                 nextHandler.handle(con);
             } else {
-                reconnect(attempt -> {});
+                reconnect(attempt -> {}, failedCon -> onRemoteDisconnect(failedCon, null));
             }
         }
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 5167ee35c..daf902c57 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -260,36 +260,75 @@ public class HonoClientImplTest {
 
     /**
      * Verifies that the client adapter repeatedly tries to connect until a connection is established.
+     * 
+     * @param ctx The test context.
      */
     @Test
-    public void testConnectTriesToReconnectOnFailedConnectAttempt() {
-
-        // expect the connection factory to be invoked 3 times
-        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(null, 3);
+    public void testConnectTriesToReconnectOnFailedConnectAttempt(final TestContext ctx) {
 
-        // GIVEN an client that cannot connect to the server
+        // GIVEN a client that cannot connect to the server
+        ProtonConnection con = mock(ProtonConnection.class);
+        // expect the connection factory to fail twice and succeed on third connect attempt
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 1, 2);
         HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
 
         // WHEN trying to connect
-        client.connect(new ProtonClientOptions().setReconnectAttempts(1), attempt -> {});
+        Async disconnectHandlerInvocation = ctx.async();
+        Handler<ProtonConnection> disconnectHandler = failedCon -> disconnectHandlerInvocation.complete();
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1), attempt -> {}, disconnectHandler);
 
         // THEN the client repeatedly tries to connect
         assertTrue(connectionFactory.await(4 * Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS, TimeUnit.MILLISECONDS));
+        // and sets the disconnect handler provided as a param in the connect method invocation
+        connectionFactory.getDisconnectHandler().handle(con);
+        disconnectHandlerInvocation.await(1000);
+    }
+
+    /**
+     * Verifies that the client tries to re-connect to a server instance if the connection is closed by the peer.
+     * 
+     * @param ctx The test context.
+     *
+     */
+    @Test
+    public void testOnRemoteCloseTriggersReconnection(final TestContext ctx) {
+
+        // GIVEN a client that is connected to a server
+        ProtonConnection con = mock(ProtonConnection.class);
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con, 2);
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        Async disconnectHandlerInvocation = ctx.async();
+        Handler<ProtonConnection> disconnectHandler = failedCon -> disconnectHandlerInvocation.complete();
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1), attempt -> {}, disconnectHandler);
+
+        // WHEN the peer closes the connection
+        connectionFactory.getCloseHandler().handle(Future.failedFuture("shutting down for maintenance"));
+
+        // THEN the client invokes the disconnect handler provided in the original connect method call
+        disconnectHandlerInvocation.await(500);
     }
 
     private class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {
 
         private Handler<ProtonConnection> disconnectHandler;
-        private CountDownLatch expectedConnectionAttemps;
+        private Handler<AsyncResult<ProtonConnection>> closeHandler;
+        private CountDownLatch expectedSucceedingConnectionAttemps;
+        private CountDownLatch expectedFailingConnectionAttempts;
         private ProtonConnection connectionToCreate;
 
         public DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
             this(conToCreate, 1);
         }
 
-        public DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate, final int expectedConnectionAttempts) {
+        public DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate, final int expectedSucceedingConnectionAttempts) {
+            this(conToCreate, expectedSucceedingConnectionAttempts, 0);
+        }
+
+        public DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate, final int expectedSucceedingConnectionAttempts,
+                final int expectedFailingConnectionAttempts) {
             this.connectionToCreate = conToCreate;
-            this.expectedConnectionAttemps = new CountDownLatch(expectedConnectionAttempts);
+            this.expectedSucceedingConnectionAttemps = new CountDownLatch(expectedSucceedingConnectionAttempts);
+            this.expectedFailingConnectionAttempts = new CountDownLatch(expectedFailingConnectionAttempts);
         }
 
         @Override
@@ -310,11 +349,13 @@ public class HonoClientImplTest {
                 final Handler<ProtonConnection> disconnectHandler,
                 final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
 
-            expectedConnectionAttemps.countDown();
+            this.closeHandler = closeHandler;
             this.disconnectHandler = disconnectHandler;
-            if (connectionToCreate == null) {
+            if (expectedFailingConnectionAttempts.getCount() > 0) {
+                expectedFailingConnectionAttempts.countDown();
                 connectionResultHandler.handle(Future.failedFuture("cannot connect"));
             } else {
+                expectedSucceedingConnectionAttemps.countDown();
                 connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
             }
         }
@@ -343,9 +384,13 @@ public class HonoClientImplTest {
             return disconnectHandler;
         }
 
+        public Handler<AsyncResult<ProtonConnection>> getCloseHandler() {
+            return closeHandler;
+        }
+
         public boolean await(long timeout, TimeUnit unit) {
             try {
-                return expectedConnectionAttemps.await(timeout, unit);
+                return expectedSucceedingConnectionAttemps.await(timeout, unit);
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
                 return false;
