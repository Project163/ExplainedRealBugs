diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AuthenticationServerClient.java b/client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java
similarity index 99%
rename from client/src/main/java/org/eclipse/hono/client/impl/AuthenticationServerClient.java
rename to client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java
index e425901e7..c2a0d58ce 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AuthenticationServerClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java
@@ -11,7 +11,7 @@
  * SPDX-License-Identifier: EPL-2.0
  *******************************************************************************/
 
-package org.eclipse.hono.client.impl;
+package org.eclipse.hono.client;
 
 import java.util.Objects;
 
diff --git a/client/src/main/java/org/eclipse/hono/client/Command.java b/client/src/main/java/org/eclipse/hono/client/Command.java
new file mode 100644
index 000000000..cbd552532
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/Command.java
@@ -0,0 +1,327 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.ResourceIdentifier;
+
+import io.vertx.core.buffer.Buffer;
+
+/**
+ * A wrapper around an AMQP 1.0 message representing a command.
+ *
+ */
+public final class Command {
+
+    private final boolean valid;
+    private final Message message;
+    private final String tenantId;
+    private final String deviceId;
+    private final String correlationId;
+    private final String replyToId;
+    private final String requestId;
+
+    private Command(
+            final boolean valid,
+            final Message message,
+            final String tenantId,
+            final String deviceId,
+            final String correlationId,
+            final String replyToId) {
+
+        this.valid = valid;
+        this.message = message;
+        if (valid) {
+            this.message.setCorrelationId(correlationId);
+            this.message.setReplyTo(replyToId);
+        }
+        this.tenantId = tenantId;
+        this.deviceId = deviceId;
+        this.correlationId = correlationId;
+        this.replyToId = replyToId;
+        this.requestId = getRequestId(correlationId, replyToId, deviceId);
+    }
+
+    /**
+     * Creates a command for an AMQP 1.0 message that should be sent to a device.
+     * <p>
+     * The message is expected to contain
+     * <ul>
+     * <li>a non-null <em>subject</em></li>
+     * <li>a non-null <em>reply-to</em> address that matches the tenant and device IDs and consists
+     * of four segments</li>
+     * <li>a String valued <em>correlation-id</em> and/or <em>message-id</em></li>
+     * </ul>
+     * <p>
+     * If any of the requirements above are not met, then the returned command's {@link Command#isValid()}
+     * method will return {@code false}.
+     *
+     * @param message The message containing the command.
+     * @param tenantId The tenant that the device belongs to.
+     * @param deviceId The identifier of the device.
+     * @return The command.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    public static Command from(
+            final Message message,
+            final String tenantId,
+            final String deviceId) {
+
+        Objects.requireNonNull(message);
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+
+        boolean valid = message.getSubject() != null;
+
+        final String correlationId = Optional.ofNullable(message.getCorrelationId()).map(obj -> {
+            if (obj instanceof String) {
+                return (String) obj;
+            } else {
+                return null;
+            }
+        }).orElseGet(() -> {
+            final Object obj = message.getMessageId();
+            if (obj instanceof String) {
+                return (String) obj;
+            } else {
+                return null;
+            }
+        });
+
+        if (correlationId == null) {
+            valid = false;
+        }
+
+        String replyToId = null;
+
+        if (message.getReplyTo() == null) {
+            valid = false;
+        } else {
+            try {
+                final ResourceIdentifier replyTo = ResourceIdentifier.fromString(message.getReplyTo());
+                if (!CommandConstants.COMMAND_ENDPOINT.equals(replyTo.getEndpoint())) {
+                    // not a command message
+                    valid = false;
+                } else if (!tenantId.equals(replyTo.getTenantId())) {
+                    // command response is targeted at wrong tenant
+                    valid = false;
+                } else {
+                    replyToId = replyTo.getPathWithoutBase();
+                    if (replyToId == null) {
+                        valid = false;
+                    }
+                }
+            } catch (IllegalArgumentException e) {
+                // reply-to could not be parsed
+                valid = false;
+            }
+        }
+
+        final Command result = new Command(
+                valid,
+                message,
+                tenantId,
+                deviceId,
+                correlationId,
+                replyToId);
+
+        return result;
+    }
+
+    /**
+     * Gets the AMQP 1.0 message representing this command.
+     * 
+     * @return The command message.
+     */
+    public Message getCommandMessage() {
+        return message;
+    }
+
+    /**
+     * Checks if this command contains all required information.
+     *
+     * @return {@code true} if this is a valid command.
+     */
+    public boolean isValid() {
+        return valid;
+    }
+
+    /**
+     * Gets the name of this command.
+     *
+     * @return The name.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getName() {
+        if (isValid()) {
+            return message.getSubject();
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the tenant that the device belongs to.
+     *
+     * @return The tenant identifier.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getTenant() {
+        if (isValid()) {
+            return tenantId;
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the device's identifier.
+     *
+     * @return The identifier.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getDeviceId() {
+        if (isValid()) {
+            return deviceId;
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the request identifier of this command.
+     *
+     * @return The identifier.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getRequestId() {
+        if (isValid()) {
+            return requestId;
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the payload of this command.
+     *
+     * @return The message payload or {@code null} if the command message contains no payload.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public Buffer getPayload() {
+        if (isValid()) {
+            return MessageHelper.getPayload(message);
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the type of this command's payload.
+     *
+     * @return The content type or {@code null} if not set.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getContentType() {
+        if (isValid()) {
+            return message.getContentType();
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets this command's reply-to-id.
+     *
+     * @return The identifier.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getReplyToId() {
+        if (isValid()) {
+            return replyToId;
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the ID to use for correlating a response to this command.
+     *
+     * @return The identifier.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public String getCorrelationId() {
+        if (isValid()) {
+            return correlationId;
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+
+    /**
+     * Gets the application properties of a message if any.
+     *
+     * @return The application properties.
+     * @throws IllegalStateException if this command is invalid.
+     */
+    public Map<String, Object> getApplicationProperties() {
+        if (isValid()) {
+            if (message.getApplicationProperties() == null) {
+                return null;
+            }
+            return message.getApplicationProperties().getValue();
+        } else {
+            throw new IllegalStateException("command is invalid");
+        }
+    }
+    /**
+     * Creates a request ID for a command.
+     *
+     * @param correlationId The identifier to use for correlating the response with the request.
+     * @param replyToId An arbitrary identifier to encode into the request ID.
+     * @param deviceId The target of the command.
+     * @return The request identifier or {@code null} if any of the parameters are {@code null}.
+     */
+    public static String getRequestId(final String correlationId, final String replyToId, final String deviceId) {
+
+        if (correlationId == null || replyToId == null || deviceId == null) {
+            return null;
+        }
+
+        final String stringOne = Optional.ofNullable(correlationId).orElse("");
+        String stringTwo = Optional.ofNullable(replyToId).orElse("");
+        final boolean removeDeviceFromReplyTo = stringTwo.startsWith(deviceId + "/");
+        if (removeDeviceFromReplyTo) {
+            stringTwo = stringTwo.substring(deviceId.length() + 1);
+        }
+        return String.format("%s%02x%s%s", removeDeviceFromReplyTo ? "1" : "0", stringOne.length(), stringOne,
+                stringTwo);
+    }
+
+    @Override
+    public String toString() {
+        if (valid) {
+            return String.format("Command [name: %s, tenant-id: %s, device-id %s, request-id: %s]",
+                    getName(), getTenant(), getDeviceId(), getRequestId());
+        } else {
+            return "Invalid Command";
+        }
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConnection.java b/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
new file mode 100644
index 000000000..416b1541b
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
@@ -0,0 +1,81 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import org.eclipse.hono.client.impl.CommandConnectionImpl;
+import org.eclipse.hono.config.ClientConfigProperties;
+
+/**
+ * A bidirectional connection between an Adapter and the AMQP 1.0 network to receive commands and send a response.
+ */
+public interface CommandConnection extends HonoClient {
+
+    /**
+     * Gets a command consumer for a device.
+     * <p>
+     * Implementations may choose to cache consumers for devices and
+     * return a cached instance instead of creating a new consumer on
+     * each instantiation.
+     * 
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @param commandHandler The handler to invoke with every command received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
+     * @return A future that will complete with the consumer once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * @throws NullPointerException if tenantId, deviceId or messageConsumer is {@code null}.
+     */
+    Future<MessageConsumer> getOrCreateCommandConsumer(
+            String tenantId,
+            String deviceId,
+            Handler<CommandContext> commandHandler,
+            Handler<Void> closeHandler);
+
+    /**
+     * Closes the command consumer for a given device.
+     *
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @return A future indicating the outcome of the operation.
+     * @throws NullPointerException if tenantId or deviceId are {@code null}.
+     */
+    Future<Void> closeCommandConsumer(String tenantId, String deviceId);
+
+    /**
+     * Gets a sender for sending command responses to a business application.
+     * 
+     * @param tenantId The ID of the tenant to send the command responses for.
+     * @param replyId The ID used to build the reply address as {@code control/tenantId/replyId}.
+     * @return A future that will complete with the sender once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    Future<CommandResponseSender> getCommandResponseSender(String tenantId, String replyId);
+
+    /**
+     * Creates a new client for a set of configuration properties.
+     *
+     * @param vertx The Vert.x instance to execute the client on, if {@code null} a new Vert.x instance is used.
+     * @param clientConfigProperties The configuration properties to use.
+     *
+     * @return CommandConnection The client that was created.
+     * @throws NullPointerException if clientConfigProperties is {@code null}
+     */
+    static CommandConnection newConnection(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
+        return new CommandConnectionImpl(vertx, clientConfigProperties);
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java
new file mode 100644
index 000000000..f1437d331
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java
@@ -0,0 +1,164 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+package org.eclipse.hono.client;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.eclipse.hono.client.impl.AbstractConsumer;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.tracing.MessageAnnotationsExtractAdapter;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.ResourceIdentifier;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.References;
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.log.Fields;
+import io.opentracing.propagation.Format;
+import io.opentracing.tag.Tags;
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+
+/**
+ * A wrapper around an AMQP receiver link for consuming commands.
+ */
+public class CommandConsumer extends AbstractConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(CommandConsumer.class);
+
+    private CommandConsumer(
+            final Context context,
+            final ClientConfigProperties config,
+            final ProtonReceiver protonReceiver,
+            final Tracer tracer) {
+
+        super(context, config, protonReceiver, tracer);
+    }
+
+    /**
+     * Creates a new command consumer.
+     * <p>
+     * The underlying receiver link will be created with the following properties:
+     * <ul>
+     * <li><em>auto accept</em> will be set to {@code true}</li>
+     * <li><em>pre-fetch size</em> will be set to {@code 0} to enforce manual flow control.
+     * However, the sender will be issued one credit on link establishment.</li>
+     * </ul>
+     *
+     * @param context The vert.x context to run all interactions with the server on.
+     * @param clientConfig The configuration properties to use.
+     * @param con The AMQP connection to the server.
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the commands should be consumed.
+     * @param commandHandler The handler to invoke for each command received.
+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
+     * @param creationHandler The handler to invoke with the outcome of the creation attempt.
+     * @param tracer The tracer to use for tracking the processing of received
+     *               messages. If {@code null}, OpenTracing's {@code NoopTracer} will
+     *               be used.
+     * @throws NullPointerException if any of the parameters other than tracer are {@code null}.
+     */
+    public static final void create(
+            final Context context,
+            final ClientConfigProperties clientConfig,
+            final ProtonConnection con,
+            final String tenantId,
+            final String deviceId,
+            final Handler<CommandContext> commandHandler,
+            final Handler<String> receiverCloseHook,
+            final Handler<AsyncResult<MessageConsumer>> creationHandler,
+            final Tracer tracer) {
+
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(clientConfig);
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(commandHandler);
+        Objects.requireNonNull(receiverCloseHook);
+        Objects.requireNonNull(creationHandler);
+
+        LOG.trace("creating new command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
+
+        final String address = ResourceIdentifier.from(CommandConstants.COMMAND_ENDPOINT, tenantId, deviceId).toString();
+        final ClientConfigProperties props = new ClientConfigProperties(clientConfig);
+        props.setInitialCredits(0);
+
+        final AtomicReference<ProtonReceiver> receiverRef = new AtomicReference<>();
+
+        createReceiver(
+                context,
+                props,
+                con,
+                address,
+                ProtonQoS.AT_LEAST_ONCE,
+                (delivery, msg) -> {
+
+                    final Command command = Command.from(msg, tenantId, deviceId);
+
+                    // try to extract Span context from incoming message
+                    final SpanContext spanContext = tracer.extract(Format.Builtin.TEXT_MAP, new MessageAnnotationsExtractAdapter(msg));
+                    // start a Span to use for tracing the delivery of the command to the device
+                    // we set the component tag to the class name because we have no access to
+                    // the name of the enclosing component we are running in
+                    final Span currentSpan = tracer.buildSpan("send command")
+                            .addReference(References.CHILD_OF, spanContext)
+                            .ignoreActiveSpan()
+                            .withTag(Tags.COMPONENT.getKey(), CommandConsumer.class.getSimpleName())
+                            .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)
+                            .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)
+                            .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)
+                            .start();
+
+                    final Map<String, String> items = new HashMap<>(3);
+                    items.put(Fields.EVENT, "received command message");
+                    if (command.isValid()) {
+                        currentSpan.setTag(Constants.HEADER_COMMAND_REQUEST_ID, command.getRequestId());
+                        items.put("name", command.getName());
+                        items.put("content-type", command.getContentType());
+                    }
+                    currentSpan.log(items);
+                    try {
+                        commandHandler.handle(CommandContext.from(command, delivery, receiverRef.get(), currentSpan));
+                    } finally {
+                        currentSpan.finish();
+                    }
+                },
+                receiverCloseHook).setHandler(s -> {
+
+                    if (s.succeeded()) {
+                        final ProtonReceiver receiver = s.result();
+                        LOG.debug("successfully created command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
+                        receiverRef.set(receiver);
+                        receiver.flow(1); // allow sender to sender one command
+                        creationHandler.handle(Future.succeededFuture(new CommandConsumer(context, props, receiver, tracer)));
+                    } else {
+                        LOG.debug("failed to create command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId, s.cause());
+                        creationHandler.handle(Future.failedFuture(s.cause()));
+                    }
+                });
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandContext.java b/client/src/main/java/org/eclipse/hono/client/CommandContext.java
new file mode 100644
index 000000000..65684b94d
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandContext.java
@@ -0,0 +1,155 @@
+/**
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
+import org.eclipse.hono.tracing.TracingHelper;
+import org.eclipse.hono.util.MapBasedExecutionContext;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.Span;
+import io.opentracing.log.Fields;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonReceiver;
+
+
+/**
+ * A context for passing around parameters relevant for processing a {@code Command}.
+ *
+ */
+public final class CommandContext extends MapBasedExecutionContext {
+
+    /**
+     * The key under which the current CommandContext is stored.
+     */
+    public static final String KEY_COMMAND_CONTEXT = "command-context";
+
+    private static final Logger LOG = LoggerFactory.getLogger(CommandContext.class);
+
+    private final Command command;
+    private final ProtonDelivery delivery;
+    private final ProtonReceiver receiver;
+    private final Span currentSpan;
+
+    private CommandContext(
+            final Command command,
+            final ProtonDelivery delivery,
+            final ProtonReceiver receiver,
+            final Span currentSpan) {
+
+        this.command = command;
+        this.delivery = delivery;
+        this.receiver = receiver;
+        this.currentSpan = currentSpan;
+    }
+
+    /**
+     * Creates a context for a command.
+     * 
+     * @param command The command to be processed.
+     * @param delivery The delivery corresponding to the message.
+     * @param receiver The AMQP link over which the command has been received.
+     * @param currentSpan The OpenTracing span to use for tracking the processing of the command.
+     * @return The context.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    public static CommandContext from(
+            final Command command,
+            final ProtonDelivery delivery,
+            final ProtonReceiver receiver,
+            final Span currentSpan) {
+
+        Objects.requireNonNull(command);
+        Objects.requireNonNull(delivery);
+        Objects.requireNonNull(receiver);
+        Objects.requireNonNull(currentSpan);
+        return new CommandContext(command, delivery, receiver, currentSpan);
+    }
+
+    /**
+     * Gets the command to process.
+     * 
+     * @return The command.
+     */
+    public Command getCommand() {
+        return command;
+    }
+
+    /**
+     * Gets the OpenTracing span to use for tracking the processing of the command.
+     * 
+     * @return The span.
+     */
+    public Span getCurrentSpan() {
+        return currentSpan;
+    }
+
+    /**
+     * Settles the command message with the <em>accepted</em> outcome.
+     */
+    public void accept() {
+
+        LOG.trace("accepting command message [{}]", getCommand());
+        ProtonHelper.accepted(delivery, true);
+        currentSpan.log("accepted command for delivery to device");
+    }
+
+    /**
+     * Settles the command message with the <em>released</em> outcome.
+     */
+    public void release() {
+        ProtonHelper.released(delivery, true);
+        TracingHelper.logError(currentSpan, "cannot process command");
+    }
+
+    /**
+     * Settles the command message with the <em>rejected</em> outcome.
+     * 
+     * @param errorCondition The error condition to send in the disposition frame (may be {@code null}).
+     */
+    public void reject(final ErrorCondition errorCondition) {
+        final Rejected rejected = new Rejected();
+        final Map<String, String> items = new HashMap<>(2);
+        items.put(Fields.EVENT, "cannot process command");
+        if (errorCondition != null) {
+            items.put(Fields.MESSAGE, errorCondition.getDescription());
+            rejected.setError(errorCondition);
+        }
+        delivery.disposition(rejected, true);
+        TracingHelper.logError(currentSpan, items);
+    }
+
+    /**
+     * Issues credits to the peer that the command has been received from.
+     * 
+     * @param credits The number of credits.
+     * @throws IllegalArgumentException if credits is &lt; 1
+     */
+    public void flow(final int credits) {
+        if (credits < 1) {
+            throw new IllegalArgumentException("credits must be positve");
+        }
+        currentSpan.log(String.format("flowing %d credits to sender", credits));
+        receiver.flow(credits);
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandResponse.java b/client/src/main/java/org/eclipse/hono/client/CommandResponse.java
new file mode 100644
index 000000000..7d6fca317
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandResponse.java
@@ -0,0 +1,167 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import java.util.function.Predicate;
+
+import io.vertx.core.buffer.Buffer;
+
+/**
+ * A wrapper around payload that has been sent by a device in
+ * response to a command.
+ *
+ */
+public final class CommandResponse {
+
+    private static final Predicate<Integer> INVALID_STATUS_CODE = code ->
+        code == null || code < 200 || (code >= 300 && code < 400) || code >= 600;
+
+    private final Buffer payload;
+    private final String contentType;
+    private final int status;
+    private final String replyTo;
+    private final String correlationId;
+
+    private CommandResponse(final Buffer payload, final String contentType, final int status, final String correlationId, final String replyTo) {
+        this.payload = payload;
+        this.contentType = contentType;
+        this.status = status;
+        this.replyTo = replyTo;
+        this.correlationId = correlationId;
+    }
+
+    /**
+     * Creates an empty response for a request ID that contains only the status.
+     *
+     * @param requestId The request ID of the command that this is the response for.
+     * @param deviceId The device ID of the device sending the response.
+     * @param status The HTTP status code indicating the outcome of the command.
+     * @return The response or {@code null} if the request ID could not be parsed, the status is {@code null} or if the
+     *         status code is &lt; 200 or &gt;= 600.
+     */
+    public static CommandResponse from(final String requestId, final String deviceId, final Integer status) {
+        return from(requestId, deviceId, null, null, status);
+    }
+
+    /**
+     * Creates a response for a request ID.
+     * 
+     * @param requestId The request ID of the command that this is the response for.
+     * @param deviceId The device ID of the device sending the response.
+     * @param payload The payload of the response.
+     * @param contentType The contentType of the response. Maybe {@code null} since it is not required.
+     * @param status The HTTP status code indicating the outcome of the command.
+     * @return The response or {@code null} if the request ID could not be parsed, the status is {@code null} or if the
+     *         status code is &lt; 200 or &gt;= 600.
+     */
+    public static CommandResponse from(
+            final String requestId,
+            final String deviceId,
+            final Buffer payload,
+            final String contentType,
+            final Integer status) {
+
+        if (requestId == null) {
+            return null;
+        } else if (INVALID_STATUS_CODE.test(status)) {
+            return null;
+        } else if (requestId.length() < 3) {
+            return null;
+        } else {
+            try {
+                final boolean addDeviceIdToReply = "1".equals(requestId.substring(0, 1));
+                final int lengthStringOne = Integer.parseInt(requestId.substring(1, 3), 16);
+                final String replyId = requestId.substring(3 + lengthStringOne);
+                return from(
+                        payload,
+                        contentType,
+                        status,
+                        requestId.substring(3, 3 + lengthStringOne), // correlation ID
+                        addDeviceIdToReply ? deviceId + "/" + replyId : replyId);
+            } catch (NumberFormatException | StringIndexOutOfBoundsException se) {
+                return null;
+            }
+        }
+    }
+
+    /**
+     * Creates a command response for a reply-to ID, correlation ID and status.
+     * 
+     * @param payload The command response payload.
+     * @param contentType The content-type of the response payload.
+     * @param status The HTTP status code indicating the outcome of executing the command on the device.
+     * @param correlationId The identifier used to correlate this response with the command request.
+     * @param replyTo The reply-to ID of the command response.
+     * 
+     * @return The command response or {@code null} if any of correlationId, replyTo and status is null or if the
+     *         status code is &lt; 200 or &gt;= 600.
+     */
+    public static CommandResponse from(final Buffer payload, final String contentType, final Integer status,
+            final String correlationId, final String replyTo) {
+
+        if (correlationId == null || replyTo == null || status == null) {
+            return null;
+        } else if (INVALID_STATUS_CODE.test(status)) {
+            return null;
+        } else {
+            return new CommandResponse(payload, contentType, status, correlationId, replyTo);
+        }
+    }
+
+    /**
+     * Gets the reply-to identifier that has been extracted from the request ID.
+     * 
+     * @return The identifier or {@code null} if the request ID could not be parsed.
+     */
+    public String getReplyToId() {
+        return replyTo;
+    }
+
+    /**
+     * Gets the correlation identifier that has bee extracted from the request ID.
+     * 
+     * @return The identifier or {@code null} if the request ID could not be parsed.
+     */
+    public String getCorrelationId() {
+        return correlationId;
+    }
+
+    /**
+     * Gets the payload of the response message.
+     * 
+     * @return The payload or {@code null} if the response is empty.
+     */
+    public Buffer getPayload() {
+        return payload;
+    }
+
+    /**
+     * Gets the contentType of the response message.
+     *
+     * @return The contentType or {@code null} if the contentType was not set for the response.
+     */
+    public String getContentType() {
+        return contentType;
+    }
+
+    /**
+     * Gets the HTTP status code that indicates the outcome of
+     * executing the command.
+     * 
+     * @return The status code.
+     */
+    public int getStatus() {
+        return status;
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandResponseSender.java b/client/src/main/java/org/eclipse/hono/client/CommandResponseSender.java
new file mode 100644
index 000000000..af5e31df9
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandResponseSender.java
@@ -0,0 +1,74 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+package org.eclipse.hono.client;
+
+import java.util.Map;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.buffer.Buffer;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A sender to send back the response message of a command.
+ */
+public interface CommandResponseSender extends MessageSender {
+
+    /**
+     * Sends a response message to a command back to the business application.
+     *
+     * @param correlationId The correlation id of the command.
+     * @param contentType The content type describing the response message's payload (may be {@code null}).
+     * @param payload The payload or {@code null}.
+     * @param properties The properties or {@code null}.
+     * @param status The status of the command, which was send to the device.
+     * @param context The currently active OpenTracing span or {@code null} if no
+     *         span is currently active. An implementation should use this as the
+     *         parent for any new span(s) it creates for tracing the execution of
+     *         this operation.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled)
+     *         by the application.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent or has not been accepted by the application.
+     * @throws NullPointerException if any of tenantId, deviceId, replyId or correlationId is {@code null}.
+     */
+    Future<ProtonDelivery> sendCommandResponse(
+            String correlationId,
+            String contentType,
+            Buffer payload,
+            Map<String, Object> properties,
+            int status,
+            SpanContext context);
+
+    /**
+     * Sends a response message to a command back to the business application.
+     *
+     * @param response The response.
+     * @param context The currently active OpenTracing span or {@code null} if no
+     *         span is currently active. An implementation should use this as the
+     *         parent for any new span(s) it creates for tracing the execution of
+     *         this operation.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled)
+     *         by the application.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent or has not been accepted by the application.
+     * @throws NullPointerException if response is {@code null}.
+     */
+    Future<ProtonDelivery> sendCommandResponse(CommandResponse response, SpanContext context);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandSubscription.java b/client/src/main/java/org/eclipse/hono/client/CommandSubscription.java
new file mode 100644
index 000000000..056163592
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandSubscription.java
@@ -0,0 +1,162 @@
+/**
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * https://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+package org.eclipse.hono.client;
+
+import java.util.Objects;
+
+import org.eclipse.hono.auth.Device;
+import org.eclipse.hono.util.CommandConstants;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The MQTT subscription of devices, to get commands.
+ *
+ * <p>
+ * Format of subscription need to be: {@code control|c/+|TENANT/+|DEVICE_ID/req|q/#} - e.g.:
+ * </p>
+ * <ol>
+ * <li>{@code control/+/+/req/#} - authenticated device and verbose format</li>
+ * <li>{@code c/+/+/q/#} - authenticated device with short format</li>
+ * <li>{@code control/DEFAULT_TENANT/4711/req/#} unauthenticated device with verbose format</li>
+ * </ol>
+ */
+public class CommandSubscription {
+
+    private static final Logger LOG = LoggerFactory.getLogger(CommandSubscription.class);
+
+    private String endpoint;
+    private String req;
+    private String tenant;
+    private String deviceId;
+    private boolean isAuthenticated;
+
+    private CommandSubscription(final String topic) {
+        Objects.requireNonNull(topic);
+        final String[] parts = topic.split("\\/");
+        if (parts.length != 5 || !"#".equals(parts[4])) {
+            throw new IllegalArgumentException("topic filter does not match pattern: control|c/+/+/req|q/#");
+        }
+        endpoint = parts[0];
+        if (!CommandConstants.isCommandEndpoint(endpoint)) {
+            throw new IllegalArgumentException(
+                    "the endpoint needs to be '" + CommandConstants.COMMAND_ENDPOINT + "' or '"
+                            + CommandConstants.COMMAND_ENDPOINT_SHORT + "'");
+        }
+        req = parts[3];
+        if (!CommandConstants.COMMAND_RESPONSE_REQUEST_PART.equals(req)
+                && !CommandConstants.COMMAND_RESPONSE_REQUEST_PART_SHORT.equals(req)) {
+            throw new IllegalArgumentException(
+                    "the request part needs to be '" + CommandConstants.COMMAND_RESPONSE_REQUEST_PART + "' or '"
+                            + CommandConstants.COMMAND_RESPONSE_REQUEST_PART_SHORT + "'");
+        }
+        if (!"+".equals(parts[1])) {
+            tenant = parts[1];
+        }
+        if (!"+".equals(parts[2])) {
+            deviceId = parts[2];
+        }
+    }
+
+    private CommandSubscription(final String topic, final Device authenticatedDevice) {
+        this(topic);
+        if (authenticatedDevice == null) {
+            isAuthenticated = false;
+            if (tenant == null || tenant.isEmpty()) {
+                throw new IllegalArgumentException(
+                        "for unauthenticated devices the tenant needs to be given in the subscription");
+            }
+            if (deviceId == null || deviceId.isEmpty()) {
+                throw new IllegalArgumentException(
+                        "for unauthenticated devices the device-id needs to be given in the subscription");
+            }
+        } else {
+            isAuthenticated = true;
+            if ((tenant != null && !authenticatedDevice.getTenantId().equals(tenant)) ||
+                    (deviceId != null && !authenticatedDevice.getDeviceId().equals(deviceId))) {
+                throw new IllegalArgumentException(
+                        "for authenticated devices the given device-id and tenant need to match the authentication or be undefined ('+')");
+            } else {
+                tenant = authenticatedDevice.getTenantId();
+                deviceId = authenticatedDevice.getDeviceId();
+            }
+        }
+    }
+
+    /**
+     * Gets the tenant from topic or authentication .
+     *
+     * @return The tenant.
+     */
+    public String getTenant() {
+        return tenant;
+    }
+
+    /**
+     * Gets the device id from topic or authentication.
+     *
+     * @return The device id.
+     */
+    public String getDeviceId() {
+        return deviceId;
+    }
+
+    /**
+     * Gets the endpoint of the subscription.
+     *
+     * @return The endpoint.
+     */
+    public String getEndpoint() {
+        return endpoint;
+    }
+
+    /**
+     * Gets the request part of the subscription.
+     *
+     * @return The request part.
+     */
+    public String getRequestPart() {
+        return req;
+    }
+
+    /**
+     * Gets the authentication status, which indicates the need to publish on tenant/device-id for unauthenticated
+     * devices.
+     *
+     * @return {@code true} if created with an authenticated device.
+     */
+    public boolean isAuthenticated() {
+        return isAuthenticated;
+    }
+
+    /**
+     * Creates a command subscription object for the given topic. When the authenticated device is given
+     * it is used to either check given tenant and device-id from topic or fill this
+     * fields if not given.
+     *
+     * @param topic The topic to subscribe for commands.
+     * @param authenticatedDevice The authenticated device or {@code null}.
+     * @return The CommandSubscription object or {@code null} if the topic does not match the rules.
+     * @throws NullPointerException if topic is {@code null}.
+     */
+    public static CommandSubscription fromTopic(final String topic, final Device authenticatedDevice) {
+        try {
+            return new CommandSubscription(topic, authenticatedDevice);
+        } catch (final IllegalArgumentException e) {
+            LOG.debug(e.getMessage());
+            return null;
+        }
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index c02e4be37..16b5d20e2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -105,7 +105,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      *                 client should not be scoped to a tenant.
      * @throws NullPointerException if any of context or configuration are {@code null}.
      */
-    AbstractRequestResponseClient(final Context context, final ClientConfigProperties config, final String tenantId) {
+    protected AbstractRequestResponseClient(final Context context, final ClientConfigProperties config, final String tenantId) {
         this(context, config, (Tracer) null, tenantId);
     }
 
@@ -132,7 +132,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      *                 client should not be scoped to a tenant.
      * @throws NullPointerException if any of context or configuration are {@code null}.
      */
-    AbstractRequestResponseClient(
+    protected AbstractRequestResponseClient(
             final Context context,
             final ClientConfigProperties config,
             final Tracer tracer,
@@ -164,7 +164,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @param replyId The replyId to use in the reply-to address.
      * @throws NullPointerException if any of the parameters are {@code null}.
      */
-    AbstractRequestResponseClient(
+    protected AbstractRequestResponseClient(
             final Context context,
             final ClientConfigProperties config,
             final String tenantId,
@@ -197,7 +197,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @param replyId The replyId to use in the reply-to address.
      * @throws NullPointerException if any of the parameters other than tracer are {@code null}.
      */
-    AbstractRequestResponseClient(
+    protected AbstractRequestResponseClient(
             final Context context,
             final ClientConfigProperties config,
             final Tracer tracer,
@@ -227,7 +227,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
      * @throws NullPointerException if any of the parameters other than tenant are {@code null}.
      */
-    AbstractRequestResponseClient(
+    protected AbstractRequestResponseClient(
             final Context context,
             final ClientConfigProperties config,
             final String tenantId,
@@ -251,7 +251,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @throws NullPointerException if any of the parameters other than tracer or tenant
      *                              are {@code null}.
      */
-    AbstractRequestResponseClient(
+    protected AbstractRequestResponseClient(
             final Context context,
             final ClientConfigProperties config,
             final Tracer tracer,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
new file mode 100644
index 000000000..f2a1afcfd
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
@@ -0,0 +1,161 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+
+import org.eclipse.hono.client.CommandConnection;
+import org.eclipse.hono.client.CommandResponseSender;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.CommandConsumer;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.auth.Device;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.connection.ConnectionFactory;
+
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+
+/**
+ * Implements a connection between an Adapter and the AMQP 1.0 network to receive commands and send a response.
+ */
+public class CommandConnectionImpl extends HonoClientImpl implements CommandConnection {
+
+    /**
+     * The consumers that can be used to receive command messages.
+     * The device, which belongs to a tenant is used as the key, e.g. <em>DEFAULT_TENANT/4711</em>.
+     */
+    private final Map<String, MessageConsumer> commandReceivers = new HashMap<>();
+
+    /**
+     * Creates a new client for a set of configuration properties.
+     * <p>
+     * This constructor creates a connection factory using
+     * {@link ConnectionFactory#newConnectionFactory(Vertx, ClientConfigProperties)}.
+     *
+     * @param vertx The Vert.x instance to execute the client on, if {@code null} a new Vert.x instance is used.
+     * @param clientConfigProperties The configuration properties to use.
+     * @throws NullPointerException if clientConfigProperties is {@code null}
+     */
+    public CommandConnectionImpl(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
+        super(vertx, clientConfigProperties);
+    }
+
+    /**
+     * Creates a new client for a set of configuration properties.
+     * <p>
+     * This constructor creates a connection factory using
+     * {@link ConnectionFactory#newConnectionFactory(Vertx, ClientConfigProperties)}.
+     *
+     * @param vertx The Vert.x instance to execute the client on, if {@code null} a new Vert.x instance is used.
+     * @param connectionFactory Factory to invoke for a new connection.
+     * @param clientConfigProperties The configuration properties to use.
+     * @throws NullPointerException if clientConfigProperties is {@code null}
+     */
+    public CommandConnectionImpl(final Vertx vertx, final ConnectionFactory connectionFactory, final ClientConfigProperties clientConfigProperties) {
+        super(vertx, connectionFactory, clientConfigProperties);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void clearState() {
+        super.clearState();
+        commandReceivers.clear();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public final Future<MessageConsumer> getOrCreateCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final Handler<CommandContext> commandConsumer,
+            final Handler<Void> closeHandler) {
+        final MessageConsumer messageConsumer = commandReceivers.get(Device.asAddress(tenantId, deviceId));
+        if (messageConsumer != null) {
+            return Future.succeededFuture(messageConsumer);
+        } else {
+            return createConsumer(
+                    tenantId,
+                    () -> newCommandConsumer(tenantId, deviceId, commandConsumer, closeHandler));
+        }
+    }
+
+    private Future<MessageConsumer> newCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final Handler<CommandContext> commandConsumer,
+            final Handler<Void> closeHandler) {
+
+        return checkConnected().compose(con -> {
+            final Future<MessageConsumer> result = Future.future();
+            CommandConsumer.create(context, clientConfigProperties, connection, tenantId, deviceId,
+                    commandConsumer, closeHook -> {
+                        closeCommandConsumer(tenantId, deviceId);
+                    }, creation -> {
+                        if (creation.succeeded()) {
+                            commandReceivers.put(Device.asAddress(tenantId, deviceId), creation.result());
+                        }
+                        result.complete(creation.result());
+                    }, getTracer());
+            return result;
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Future<Void> closeCommandConsumer(final String tenantId, final String deviceId) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+
+        final Future<Void> result = Future.future();
+        final String deviceAddress = Device.asAddress(tenantId, deviceId);
+
+        Optional.ofNullable(commandReceivers.remove(deviceAddress)).map(commandReceiverLink -> {
+            commandReceiverLink.close(result);
+            return commandReceiverLink;
+        });
+
+        return result;
+    }
+
+    /**
+     * {@inheritDoc}
+     * 
+     * This implementation always creates a new sender link.
+     */
+    public Future<CommandResponseSender> getCommandResponseSender(
+            final String tenantId,
+            final String replyId) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(replyId);
+        return checkConnected().compose(connected -> {
+            final Future<CommandResponseSender> result = Future.future();
+            CommandResponseSenderImpl.create(context, clientConfigProperties, connection, tenantId, replyId,
+                    onSenderClosed -> {},
+                    result.completer(),
+                    getTracer());
+            return result;
+        });
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
new file mode 100644
index 000000000..6162201dd
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
@@ -0,0 +1,213 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+package org.eclipse.hono.client.impl;
+
+import java.util.Map;
+import java.util.Objects;
+
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.CommandResponseSender;
+import org.eclipse.hono.client.CommandResponse;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.MessageHelper;
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.tag.Tags;
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.buffer.Buffer;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * The response sender for a received command.
+ */
+public class CommandResponseSenderImpl extends AbstractSender implements CommandResponseSender {
+
+    /**
+     * The default amount of time to wait for credits after link creation. This is higher as in the client defaults,
+     * because for the command response the link is created on demand and the response should not fail.
+     */
+    public static final long DEFAULT_COMMAND_FLOW_LATENCY = 200L; // ms
+
+    CommandResponseSenderImpl(
+            final ClientConfigProperties config,
+            final ProtonSender sender,
+            final String tenantId,
+            final String targetAddress,
+            final Context context,
+            final Tracer tracer) {
+
+        super(config, sender, tenantId, targetAddress, context, tracer);
+    }
+
+    @Override
+    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
+        return sendMessageAndWaitForOutcome(message, currentSpan);
+    }
+
+    @Override
+    protected String getTo(final String deviceId) {
+        return null;
+    }
+
+    @Override
+    public String getEndpoint() {
+        return CommandConstants.COMMAND_ENDPOINT;
+    }
+
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
+        return send(message);
+    }
+
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext context) {
+        return send(message, context);
+    }
+
+    static final String getTargetAddress(final String tenantId, final String replyId) {
+        return String.format("%s/%s/%s", CommandConstants.COMMAND_ENDPOINT, tenantId, replyId);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<ProtonDelivery> sendCommandResponse(
+            final String correlationId,
+            final String contentType,
+            final Buffer payload,
+            final Map<String, Object> properties,
+            final int status,
+            final SpanContext context) {
+
+        LOG.trace("sending command response [correlationId: {}, status: {}]", correlationId, status);
+        return sendAndWaitForOutcome(
+                createResponseMessage(targetAddress, correlationId, contentType, payload, properties, status),
+                context);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<ProtonDelivery> sendCommandResponse(final CommandResponse commandResponse,
+            final SpanContext context) {
+
+        Objects.requireNonNull(commandResponse);
+        return sendAndWaitForOutcome(createResponseMessage(commandResponse), context);
+    }
+
+    private Message createResponseMessage(final CommandResponse commandResponse) {
+
+        return createResponseMessage(
+                targetAddress,
+                commandResponse.getCorrelationId(),
+                commandResponse.getContentType(),
+                commandResponse.getPayload(),
+                null,
+                commandResponse.getStatus());
+    }
+
+    private static Message createResponseMessage(
+            final String targetAddress,
+            final String correlationId,
+            final String contentType,
+            final Buffer payload,
+            final Map<String, Object> properties,
+            final int status) {
+
+        Objects.requireNonNull(targetAddress);
+        Objects.requireNonNull(correlationId);
+        final Message msg = ProtonHelper.message();
+        msg.setCorrelationId(correlationId);
+        msg.setAddress(targetAddress);
+        MessageHelper.setPayload(msg, contentType, payload);
+        if (properties != null) {
+            msg.setApplicationProperties(new ApplicationProperties(properties));
+        }
+        MessageHelper.setCreationTime(msg);
+        MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_STATUS, status);
+        return msg;
+    }
+
+    /**
+     * Creates a new sender to send responses for commands back to the business application.
+     * <p>
+     * The underlying sender link will be created with the following properties:
+     * <ul>
+     * <li><em>flow latency</em> will be set to @{@link #DEFAULT_COMMAND_FLOW_LATENCY} if the configured value is
+     * smaller than the default</li>
+     * </ul>
+     *
+     * @param context The vert.x context to run all interactions with the server on.
+     * @param clientConfig The configuration properties to use.
+     * @param con The connection to the AMQP network.
+     * @param tenantId The tenant that the command response will be send for and the device belongs to.
+     * @param replyId The reply id as the unique postfix of the replyTo address.
+     * @param closeHook A handler to invoke if the peer closes the link unexpectedly.
+     * @param creationHandler The handler to invoke with the result of the creation attempt.
+     * @param tracer The tracer to use for tracking the processing of received messages. If {@code null}, OpenTracing's
+     *            {@code NoopTracer} will be used.
+     * @throws NullPointerException if any of context, clientConfig, con, tenantId, deviceId or replyId are
+     *             {@code null}.
+     */
+    public static void create(
+            final Context context,
+            final ClientConfigProperties clientConfig,
+            final ProtonConnection con,
+            final String tenantId,
+            final String replyId,
+            final Handler<String> closeHook,
+            final Handler<AsyncResult<CommandResponseSender>> creationHandler,
+            final Tracer tracer) {
+
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(clientConfig);
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(replyId);
+
+        final String targetAddress = CommandResponseSenderImpl.getTargetAddress(tenantId, replyId);
+        final ClientConfigProperties props = new ClientConfigProperties(clientConfig);
+        if (props.getFlowLatency() < DEFAULT_COMMAND_FLOW_LATENCY) {
+            props.setFlowLatency(DEFAULT_COMMAND_FLOW_LATENCY);
+        }
+
+        createSender(context, props, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook)
+                .map(sender -> (CommandResponseSender) new CommandResponseSenderImpl(clientConfig, sender, tenantId,
+                        targetAddress, context, tracer))
+                .setHandler(creationHandler);
+    }
+
+    @Override
+    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
+
+        if (tracer == null) {
+            throw new IllegalStateException("no tracer configured");
+        } else {
+            final Span span = newChildSpan(parent, "forward Command response");
+            Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_CLIENT);
+            return span;
+        }
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/CommandResponseTest.java b/client/src/test/java/org/eclipse/hono/client/CommandResponseTest.java
new file mode 100644
index 000000000..ed35d2b5f
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/CommandResponseTest.java
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import static org.junit.Assert.*;
+import static org.hamcrest.CoreMatchers.*;
+
+import java.net.HttpURLConnection;
+
+import org.junit.Test;
+
+
+/**
+ * Verifies behavior of {@link CommandResponse}.
+ *
+ */
+public class CommandResponseTest {
+
+    private static final String CORRELATION_ID = "the-correlation-id";
+    private static final String DEVICE_ID = "4711";
+    private static final String REPLY_TO_ID = "the-reply-to-id";
+    private static final String REPLY_TO_ID_WITH_DEVICE = DEVICE_ID + "/" + REPLY_TO_ID;
+
+    /**
+     * Verifies that a response can be created from a request ID.
+     */
+    @Test
+    public void testFromResponseSucceeds() {
+
+        final CommandResponse resp = CommandResponse.from(
+                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID, DEVICE_ID),
+                DEVICE_ID,
+                HttpURLConnection.HTTP_OK);
+        assertNotNull(resp);
+        assertThat(resp.getCorrelationId(), is(CORRELATION_ID));
+        assertThat(resp.getReplyToId(), is(REPLY_TO_ID));
+    }
+
+    /**
+     * Verifies that creating a response from a request ID which does not contain a hex encoded byte
+     * at the start position fails.
+     */
+    @Test
+    public void testFromFailsForMalformedRequestId() {
+
+        // make sure we succeed with a valid length string
+        final CommandResponse resp = CommandResponse.from(
+                "003anyString", DEVICE_ID, HttpURLConnection.HTTP_OK);
+        assertThat(resp.getCorrelationId(), is("any"));
+        assertThat(resp.getReplyToId(), is("String"));
+
+        assertNull(CommandResponse.from("0ZZanyString", DEVICE_ID, HttpURLConnection.HTTP_OK));
+    }
+
+    /**
+     * Verifies that creating a response for an invalid status code fails.
+     */
+    @Test
+    public void testFromFailsForInvalidStatusCode() {
+
+        // make sure we succeed with a valid status code
+        final CommandResponse resp = CommandResponse.from(
+                "103oneTwo", DEVICE_ID, 200);
+        assertThat(resp.getCorrelationId(), is("one"));
+        assertThat(resp.getReplyToId(), is(DEVICE_ID + "/Two"));
+
+        assertNull(CommandResponse.from(
+                "103oneTwo", DEVICE_ID, 100));
+        assertNull(CommandResponse.from(
+                "103oneTwo", DEVICE_ID, 310));
+        assertNull(CommandResponse.from(
+                "103oneTwo", DEVICE_ID, 600));
+        assertNull(CommandResponse.from(
+                "103oneTwo", DEVICE_ID, null));
+    }
+
+    /**
+     * Verifies that creating a response from a request ID which contains less characters as indicated
+     * by the hex encoded byte at the start position fails.
+     */
+    @Test
+    public void testFailsForIncorrectCorrelationIdLength() {
+
+        final String id = "thisIsLessThan255Characters";
+        // make sure we succeed with valid length
+        final CommandResponse resp = CommandResponse.from(
+                String.format("0%02x%s", 4, id), DEVICE_ID, 200);
+        assertThat(resp.getCorrelationId(), is("this"));
+        assertThat(resp.getReplyToId(), is("IsLessThan255Characters"));
+
+        assertNull(CommandResponse.from(
+                "1FFthisIsLessThan255Characters",
+                DEVICE_ID,
+                HttpURLConnection.HTTP_OK));
+    }
+
+    /**
+     * Verifies that device-id is rendered into reply-to-id when the request-id
+     * starts with '1'.
+     */
+    @Test
+    public void testDeviceInReply() {
+        final CommandResponse resp = CommandResponse.from(
+                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID_WITH_DEVICE, DEVICE_ID),
+                DEVICE_ID,
+                HttpURLConnection.HTTP_OK);
+        assertThat(resp.getReplyToId(), is(REPLY_TO_ID_WITH_DEVICE));
+    }
+
+    /**
+     * Verifies that device-id is NOT rendered into reply-to-id when the request-id
+     * starts with a '0'.
+     */
+    @Test
+    public void testDeviceNotInReply() {
+        final CommandResponse resp = CommandResponse.from(
+                Command.getRequestId(CORRELATION_ID, REPLY_TO_ID, DEVICE_ID),
+                DEVICE_ID,
+                HttpURLConnection.HTTP_OK);
+        assertThat(resp.getReplyToId(), is(REPLY_TO_ID));
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/CommandSubscriptionTest.java b/client/src/test/java/org/eclipse/hono/client/CommandSubscriptionTest.java
new file mode 100644
index 000000000..ddb672f83
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/CommandSubscriptionTest.java
@@ -0,0 +1,147 @@
+/**
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * https://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+package org.eclipse.hono.client;
+
+import org.eclipse.hono.auth.Device;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
+
+/**
+ * Verifies behavior of {@link CommandSubscription}.
+ *
+ */
+@RunWith(MockitoJUnitRunner.class)
+public class CommandSubscriptionTest {
+
+    private Device device = new Device("tenant", "device");
+
+    /**
+     * Verifies subscription pattern without authenticated device and correct pattern.
+     */
+    @Test
+    public void testSubscriptionUnauth() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("control/tenant/device/req/#", null);
+        assertNotNull(subscription);
+        assertThat(subscription.getDeviceId(), is("device"));
+        assertThat(subscription.getTenant(), is("tenant"));
+        assertThat(subscription.getEndpoint(), is("control"));
+        assertThat(subscription.getRequestPart(), is("req"));
+    }
+
+    /**
+     * Verifies subscription pattern without authenticated device and correct short pattern.
+     */
+    @Test
+    public void testSubscriptionUnauthShort() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("c/tenant/device/q/#", null);
+        assertNotNull(subscription);
+        assertThat(subscription.getDeviceId(), is("device"));
+        assertThat(subscription.getTenant(), is("tenant"));
+        assertThat(subscription.getEndpoint(), is("c"));
+        assertThat(subscription.getRequestPart(), is("q"));
+    }
+
+    /**
+     * Verifies subscription pattern with authenticated device and correct pattern.
+     */
+    @Test
+    public void testSubscriptionAuth() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("control/tenant/device/req/#", device);
+        assertNotNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with authenticated device and correct short pattern.
+     */
+    @Test
+    public void testSubscriptionAuthShort() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("c/tenant/device/q/#", device);
+        assertNotNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with authenticated device and correct pattern with different tenant/device as in
+     * authentication is not allowed.
+     */
+    @Test
+    public void testSubscriptionAuthDeviceDifferent() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("control/tenantA/deviceB/req/#", device);
+        assertNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with authenticated device and correct pattern without given tenant/device.
+     */
+    @Test
+    public void testSubscriptionAuthWithPattern() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("control/+/+/req/#", device);
+        assertNotNull(subscription);
+        assertThat(subscription.getDeviceId(), is("device"));
+        assertThat(subscription.getTenant(), is("tenant"));
+    }
+
+    /**
+     * Verifies subscription pattern without authenticated device and not given tenant/device is not allowed.
+     */
+    @Test
+    public void testSubscriptionUnauthWithPattern() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("control/+/+/req/#", null);
+        assertNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with other endpoint as c and control is not allowed.
+     */
+    @Test
+    public void testSubscriptionEndpoint() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("cx/tenant/device/q/#", null);
+        assertNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with other req part as q and req is not allowed.
+     */
+    @Test
+    public void testSubscriptionReq() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("c/tenant/device/qx/#", null);
+        assertNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with other ending part as # is not allowed.
+     */
+    @Test
+    public void testSubscriptionEnd() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("c/tenant/device/q/a", null);
+        assertNull(subscription);
+    }
+
+    /**
+     * Verifies subscription pattern with other then 5 parts is not allowed.
+     */
+    @Test
+    public void testSubscriptionParts() {
+        final CommandSubscription subscription = CommandSubscription.fromTopic("c/tenant/device/q/#/x", null);
+        assertNull(subscription);
+        final CommandSubscription subscription2 = CommandSubscription.fromTopic("c/tenant/device/q", null);
+        assertNull(subscription2);
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/CommandTest.java b/client/src/test/java/org/eclipse/hono/client/CommandTest.java
new file mode 100644
index 000000000..e5b72e573
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/CommandTest.java
@@ -0,0 +1,163 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.notNullValue;
+import static org.hamcrest.CoreMatchers.nullValue;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.Constants;
+import org.junit.Test;
+
+/**
+ * Verifies behavior of {@link Command}.
+ *
+ */
+public class CommandTest {
+
+    /**
+     * Verifies that a command can be created from a valid message.
+     * Verifies that the replyToId are build up of all segments behind the tenant.
+     */
+    @Test
+    public void testFromMessageSucceeds() {
+        final String replyToId = "the-reply-to-id";
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
+        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
+        assertTrue(cmd.isValid());
+        assertThat(cmd.getName(), is("doThis"));
+        assertThat(cmd.getReplyToId(), is(String.format("4711/%s", replyToId)));
+        assertThat(cmd.getCorrelationId(), is(correlationId));
+    }
+
+    /**
+     * Verifies that a command can be created from a valid message with application properties.
+     * Verifies that the application properties are able to be retrieved from the message.
+     */
+    @Test
+    public void testFromMessageSucceedsWithApplicationProperties() {
+        final String replyToId = "the-reply-to-id";
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        final Map<String, Object> applicationProperties = new HashMap<String, Object>() {
+            {
+                put("deviceId", "4711");
+                put("tenantId", "DEFAULT_TENANT");
+            }
+        };
+        when(message.getApplicationProperties()).thenReturn(new ApplicationProperties(applicationProperties));
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
+        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
+        assertTrue(cmd.isValid());
+        assertThat(cmd.getApplicationProperties(), is(notNullValue()));
+        assertThat(cmd.getApplicationProperties().size(), is(2));
+        assertThat(cmd.getApplicationProperties().get("deviceId"), is("4711"));
+        assertThat(cmd.getApplicationProperties().get("tenantId"), is("DEFAULT_TENANT"));
+    }
+
+    /**
+     * Verifies that a command can be created from a valid message with no application properties is valid.
+     */
+    @Test
+    public void testFromMessageSucceedsWithNoApplicationProperties() {
+        final String replyToId = "the-reply-to-id";
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        when(message.getApplicationProperties()).thenReturn(null);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
+        final Command cmd = Command.from(message, Constants.DEFAULT_TENANT, "4711");
+        assertTrue(cmd.isValid());
+        assertThat(cmd.getApplicationProperties(), is(nullValue()));
+    }
+
+    /**
+     * Verifies that a command cannot be created from a message that neither
+     * contains a message nor correlation ID.
+     */
+    @Test
+    public void testFromMessageFailsForMissingCorrelationId() {
+        final String replyToId = "the-reply-to-id";
+        final Message message = mock(Message.class);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, "4711", replyToId));
+        assertFalse(Command.from(message, Constants.DEFAULT_TENANT, "4711").isValid());
+    }
+
+    /**
+     * Verifies that a command cannot be created from a message that does not
+     * contain a reply-to address.
+     */
+    @Test
+    public void testFromMessageFailsForMissingReplyToAddress() {
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        assertFalse(Command.from(message, Constants.DEFAULT_TENANT, "4711").isValid());
+    }
+
+    /**
+     * Verifies that a command cannot be created from a message that contains
+     * a malformed reply-to address.
+     */
+    @Test
+    public void testFromMessageFailsForMalformedReplyToAddress() {
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, "4711", Constants.DEFAULT_TENANT));
+        assertFalse(Command.from(message, Constants.DEFAULT_TENANT, "4711").isValid());
+    }
+
+    /**
+     * Verifies that a command cannot be created from a message that contains
+     * a reply-to address that does not match the target device.
+     */
+    @Test
+    public void testFromMessageFailsForNonMatchingReplyToAddress() {
+        final String replyToId = "the-reply-to-id";
+        final String correlationId = "the-correlation-id";
+        final Message message = mock(Message.class);
+        when(message.getSubject()).thenReturn("doThis");
+        when(message.getCorrelationId()).thenReturn(correlationId);
+        when(message.getReplyTo()).thenReturn(String.format("%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, replyToId));
+        assertFalse(Command.from(message, Constants.DEFAULT_TENANT, "4712").isValid());
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
index 43b8e46a0..4f44ba7d5 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractHonoClientTest.java
@@ -35,6 +35,8 @@ import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.client.impl.AbstractHonoClient;
+import org.eclipse.hono.client.impl.HonoClientUnitTestHelper;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.junit.Before;
 import org.junit.Rule;
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
index f642e49cb..a99c0c6e8 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
@@ -33,6 +33,9 @@ import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.cache.ExpiringValueCache;
 import org.eclipse.hono.client.RequestResponseClientConfigProperties;
 import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.impl.AbstractRequestResponseClient;
+import org.eclipse.hono.client.impl.HonoClientUnitTestHelper;
+import org.eclipse.hono.client.impl.SimpleRequestResponseResult;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.MessageHelper;
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
index 391eb384c..b830552e8 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
@@ -19,6 +19,8 @@ import static org.mockito.Mockito.*;
 
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.impl.AbstractSender;
+import org.eclipse.hono.client.impl.HonoClientUnitTestHelper;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.MessageHelper;
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
new file mode 100644
index 000000000..10e7d017d
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
@@ -0,0 +1,191 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.contains;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Objects;
+
+import org.apache.qpid.proton.engine.impl.RecordImpl;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.CommandConnection;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.auth.Device;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.connection.ConnectionFactory;
+import org.eclipse.hono.util.Constants;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.ext.unit.Async;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonClientOptions;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonReceiver;
+
+
+/**
+ * Verifies behavior of {@link CommandConnectionImpl}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class CommandConnectionImplTest {
+
+    /**
+     * Global timeout for each test case.
+     */
+    @Rule
+    public Timeout timeout = Timeout.seconds(3);
+
+    private static Vertx vertx;
+    private ClientConfigProperties props;
+    private ProtonConnection con;
+
+    private CommandConnection commandConnection;
+    private ConnectionFactory connectionFactory;
+    private ProtonReceiver receiver;
+
+    /**
+     * Sets up vertx.
+     */
+    @BeforeClass
+    public static void setUpVertx() {
+        vertx = Vertx.vertx();
+    }
+
+    /**
+     * Sets up fixture.
+     */
+    @Before
+    public void setUp() {
+        props = new ClientConfigProperties();
+
+        receiver = mock(ProtonReceiver.class);
+        when(receiver.attachments()).thenReturn(new RecordImpl());
+        doAnswer(invocationOnMock -> {
+            final Handler<AsyncResult<ProtonReceiver>> receiverHandler = invocationOnMock.getArgument(0);
+            receiverHandler.handle(Future.succeededFuture(receiver));
+            return receiver;
+        }).when(receiver).openHandler(any(Handler.class));
+
+        con = mock(ProtonConnection.class);
+        when(con.isDisconnected()).thenReturn(Boolean.FALSE);
+        when(con.createReceiver(anyString())).thenReturn(receiver);
+
+        connectionFactory = new ConnectionResultHandlerProvidingConnectionFactory(con);
+        commandConnection = new CommandConnectionImpl(vertx, connectionFactory, props);
+    }
+
+    /**
+     * Verifies that a command consumer can be created for a tenant and deviceId and opens a receiver link
+     * that is scoped to the device.
+     *
+     * @param ctx The test context.
+     */
+    @Test
+    public void testCreateCommandConsumerSucceedsAndOpensReceiverLink(final TestContext ctx) {
+
+        final Handler<CommandContext> commandHandler = mock(Handler.class);
+        final Handler<Void> closeHandler = mock(Handler.class);
+
+        final Async connected = ctx.async();
+
+        commandConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await();
+
+        final Future<MessageConsumer> messageConsumerFuture =
+                commandConnection.getOrCreateCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
+        assertNotNull(messageConsumerFuture);
+
+        final Async consumerCreated = ctx.async();
+        messageConsumerFuture.setHandler(ctx.asyncAssertSuccess(ok ->
+                consumerCreated.complete()));
+        consumerCreated.await();
+
+        verify(receiver).open();
+        verify(con).createReceiver(contains(Device.asAddress("theTenant", "theDevice")));
+    }
+
+
+    /**
+     * A connection factory that provides access to the connection result handler registered with
+     * a connection passed to the factory.
+     */
+    private static class ConnectionResultHandlerProvidingConnectionFactory implements ConnectionFactory {
+
+        private final ProtonConnection connectionToCreate;
+
+        ConnectionResultHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
+            this.connectionToCreate = Objects.requireNonNull(conToCreate);
+        }
+
+        @Override
+        public void connect(
+                final ProtonClientOptions options,
+                final Handler<AsyncResult<ProtonConnection>> closeHandler,
+                final Handler<ProtonConnection> disconnectHandler,
+                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+            connect(options, null, null, closeHandler, disconnectHandler, connectionResultHandler);
+        }
+
+        @Override
+        public void connect(
+                final ProtonClientOptions options,
+                final String username,
+                final String password,
+                final Handler<AsyncResult<ProtonConnection>> closeHandler,
+                final Handler<ProtonConnection> disconnectHandler,
+                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+
+            connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
+        }
+
+        @Override
+        public String getName() {
+            return "client";
+        }
+
+        @Override
+        public String getHost() {
+            return "server";
+        }
+
+        @Override
+        public int getPort() {
+            return Constants.PORT_AMQP;
+        }
+
+        @Override
+        public String getPathSeparator() {
+            return Constants.DEFAULT_PATH_SEPARATOR;
+        }
+    }
+
+}
