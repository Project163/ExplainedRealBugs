diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index e0e602e73..dcb4ba05e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -30,6 +30,7 @@ import javax.net.ssl.SSLException;
 import javax.security.sasl.AuthenticationException;
 
 import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.amqp.UnsignedLong;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.DisconnectListener;
@@ -62,6 +63,7 @@ import io.vertx.proton.ProtonMessageHandler;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
+import io.vertx.proton.ProtonSession;
 import io.vertx.proton.sasl.MechanismMismatchException;
 import io.vertx.proton.sasl.SaslSystemException;
 
@@ -119,6 +121,8 @@ public class HonoConnectionImpl implements HonoConnection {
     private AtomicInteger connectAttempts;
     private List<Symbol> offeredCapabilities = Collections.emptyList();
     private Tracer tracer = NoopTracerFactory.create();
+    private ProtonSession session;
+    private Handler<AsyncResult<ProtonConnection>> connectionCloseHandler;
 
     /**
      * Creates a new client for a set of configuration properties.
@@ -301,7 +305,7 @@ public class HonoConnectionImpl implements HonoConnection {
      * @return {@code true} if the connection is established.
      */
     protected boolean isConnectedInternal() {
-        return connection != null && !connection.isDisconnected();
+        return connection != null && !connection.isDisconnected() && session != null;
     }
 
     @Override
@@ -313,10 +317,12 @@ public class HonoConnectionImpl implements HonoConnection {
      * Sets the connection used to interact with the Hono server.
      *
      * @param connection The connection to use.
+     * @param session The session to use for links created on the connection.
      */
-    void setConnection(final ProtonConnection connection) {
+    void setConnection(final ProtonConnection connection, final ProtonSession session) {
         synchronized (connectionLock) {
             this.connection = connection;
+            this.session = session;
             if (connection == null) {
                 this.offeredCapabilities = Collections.emptyList();
                 context = null;
@@ -405,12 +411,13 @@ public class HonoConnectionImpl implements HonoConnection {
                         connectionFactory.getServerRole());
 
                 clientOptions = options;
+                connectionCloseHandler = remoteClose -> onRemoteClose(remoteClose, disconnectHandler);
                 connectionFactory.connect(
                         clientOptions,
                         null,
                         null,
                         containerId,
-                        remoteClose -> onRemoteClose(remoteClose, disconnectHandler),
+                        connectionCloseHandler,
                         failedConnection -> onRemoteDisconnect(failedConnection, disconnectHandler),
                         conAttempt -> {
                             connecting.compareAndSet(true, false);
@@ -436,7 +443,8 @@ public class HonoConnectionImpl implements HonoConnection {
                                             connectionFactory.getPort(),
                                             connectionFactory.getServerRole(),
                                             newConnection.getRemoteContainer());
-                                    setConnection(newConnection);
+                                    final ProtonSession session = createDefaultSession(newConnection);
+                                    setConnection(newConnection, session);
                                     wrappedConnectionHandler.handle(Future.succeededFuture(this));
                                 }
                             }
@@ -453,7 +461,7 @@ public class HonoConnectionImpl implements HonoConnection {
             final Handler<ProtonConnection> connectionLossHandler) {
 
         if (remoteClose.failed()) {
-            log.info("remote server [{}:{}, role: {}] closed connection with error condition: {}",
+            log.info("remote server [{}:{}, role: {}] closed connection: {}",
                     connectionFactory.getHost(),
                     connectionFactory.getPort(),
                     connectionFactory.getServerRole(),
@@ -511,7 +519,8 @@ public class HonoConnectionImpl implements HonoConnection {
      */
     protected void clearState() {
 
-        setConnection(null);
+        connectionCloseHandler = null;
+        setConnection(null, null);
 
         notifyDisconnectHandlers();
         // make sure we make configured number of attempts to re-connect
@@ -707,6 +716,33 @@ public class HonoConnectionImpl implements HonoConnection {
         }
     }
 
+    private ProtonSession createDefaultSession(final ProtonConnection connection) {
+
+        if (connection == null) {
+            throw new IllegalStateException("no connection to create session for");
+        } else {
+            log.debug("establishing AMQP session with server [{}:{}, role: {}]",
+                    connectionFactory.getHost(),
+                    connectionFactory.getPort(),
+                    connectionFactory.getServerRole());
+            final ProtonSession session = connection.createSession();
+            session.closeHandler(remoteClose -> {
+                final StringBuilder msgBuilder = new StringBuilder("the connection's session closed unexpectedly");
+                Optional.ofNullable(session.getRemoteCondition())
+                    .ifPresent(error -> {
+                        msgBuilder.append(String.format(" [condition: %s, description: %s]",
+                                error.getCondition(), error.getDescription()));
+                    });
+                session.close();
+                Optional.ofNullable(connectionCloseHandler)
+                    .ifPresent(ch -> ch.handle(Future.failedFuture(msgBuilder.toString())));
+            });
+            session.setIncomingCapacity(clientConfigProperties.getMaxSessionWindowSize());
+            session.open();
+            return session;
+        }
+    }
+
     /**
      * Creates a sender link.
      *
@@ -739,7 +775,7 @@ public class HonoConnectionImpl implements HonoConnection {
                 }
 
                 final Promise<ProtonSender> senderPromise = Promise.promise();
-                final ProtonSender sender = connection.createSender(targetAddress);
+                final ProtonSender sender = session.createSender(targetAddress);
                 sender.setQoS(qos);
                 sender.setAutoSettle(true);
                 final DisconnectListener<HonoConnection> disconnectBeforeOpenListener = (con) -> {
@@ -769,9 +805,21 @@ public class HonoConnectionImpl implements HonoConnection {
 
                     } else if (HonoProtonHelper.isLinkEstablished(sender)) {
 
-                        log.debug("sender open [target: {}, sendQueueFull: {}]", targetAddress, sender.sendQueueFull());
-                        // wait on credits a little time, if not already given
-                        if (sender.getCredit() <= 0) {
+                        log.debug("sender open [target: {}, sendQueueFull: {}, remote max-message-size: {}]",
+                                targetAddress, sender.sendQueueFull(), sender.getRemoteMaxMessageSize());
+                        final long remoteMaxMessageSize = Optional.ofNullable(sender.getRemoteMaxMessageSize())
+                                .map(UnsignedLong::longValue)
+                                .orElse(0L);
+                        if (remoteMaxMessageSize > 0 && remoteMaxMessageSize < clientConfigProperties.getMinMaxMessageSize()) {
+                            // peer won't accept our (biggest) messages
+                            sender.close();
+                            final String msg = String.format(
+                                    "peer does not support minimum max-message-size [required: {}, supported: {}",
+                                    clientConfigProperties.getMinMaxMessageSize(), remoteMaxMessageSize);
+                            log.debug(msg);
+                            senderPromise.tryFail(new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED, msg));
+                        } else if (sender.getCredit() <= 0) {
+                            // wait on credits a little time, if not already given
                             final long waitOnCreditsTimerId = vertx.setTimer(clientConfigProperties.getFlowLatency(),
                                     timerID -> {
                                         log.debug("sender [target: {}] has {} credits after grace period of {}ms",
@@ -856,7 +904,10 @@ public class HonoConnectionImpl implements HonoConnection {
         return executeOnContext(result -> {
             checkConnected().compose(v -> {
                 final Promise<ProtonReceiver> receiverPromise = Promise.promise();
-                final ProtonReceiver receiver = connection.createReceiver(sourceAddress);
+                final ProtonReceiver receiver = session.createReceiver(sourceAddress);
+                if (clientConfigProperties.getMaxMessageSize() > ClientConfigProperties.MAX_MESSAGE_SIZE_UNLIMITED) {
+                    receiver.setMaxMessageSize(new UnsignedLong(clientConfigProperties.getMaxMessageSize()));
+                }
                 receiver.setAutoAccept(autoAccept);
                 receiver.setQoS(qos);
                 receiver.setPrefetch(preFetchSize);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index f5e6d5ae1..522ae41a8 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -35,6 +35,7 @@ import java.util.function.Predicate;
 import java.util.function.Supplier;
 
 import org.apache.qpid.proton.amqp.Symbol;
+import org.apache.qpid.proton.amqp.UnsignedLong;
 import org.apache.qpid.proton.amqp.messaging.Target;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
@@ -69,6 +70,7 @@ import io.vertx.proton.ProtonMessageHandler;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
+import io.vertx.proton.ProtonSession;
 import io.vertx.proton.sasl.SaslSystemException;
 
 /**
@@ -81,6 +83,7 @@ public class HonoConnectionImplTest {
 
     private Vertx vertx;
     private ProtonConnection con;
+    private ProtonSession session;
     private DisconnectHandlerProvidingConnectionFactory connectionFactory;
     private ClientConfigProperties props;
     private HonoConnectionImpl honoConnection;
@@ -99,13 +102,69 @@ public class HonoConnectionImplTest {
             handler.handle(null);
             return 0L;
         });
+        session = mock(ProtonSession.class);
         con = mock(ProtonConnection.class);
         when(con.getRemoteContainer()).thenReturn("server");
+        when(con.createSession()).thenReturn(session);
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
         props = new ClientConfigProperties();
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
     }
 
+    /**
+     * Verifies that the client establishes an AMQP session with the
+     * configured incoming window size on the connection.
+     *
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testConnectEstablishesSession(final VertxTestContext ctx) {
+
+        // GIVEN a client that is configured with a specific incoming session
+        // window size
+        props.setMaxFrameSize(16 * 1024);
+        props.setMaxSessionFrames(10);
+
+        // WHEN the client tries to connect
+        honoConnection.connect()
+            .onComplete(ctx.succeeding(con -> {
+                // THEN the session has been configured with an incoming window size
+                ctx.verify(() -> {
+                    verify(session).setIncomingCapacity(10 * 16 * 1024);
+                    verify(session).open();
+                });
+                ctx.completeNow();
+            }));
+    }
+
+    /**
+     * Verifies that the client fails a connection attempt if no AMQP session can be established
+     * with the peer.
+     *
+     * @param ctx The vert.x test client.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testConnectFailsIfSessionCannotBeEstablished(final VertxTestContext ctx) {
+
+        // GIVEN a client attempting to connect to a peer that does not allow opening
+        // a session
+        final Future<HonoConnection> result = honoConnection.connect();
+        ctx.verify(() -> {
+            verify(session).open();
+            // WHEN the peer closes the session
+            final ArgumentCaptor<Handler<AsyncResult<ProtonSession>>> sessionCloseHandler = ArgumentCaptor.forClass(Handler.class);
+            verify(session).closeHandler(sessionCloseHandler.capture());
+            sessionCloseHandler.getValue().handle(Future.failedFuture("malfunction"));
+
+            // THEN the connection attempt fails
+            assertThat(result.failed());
+            // and the connection has been closed again
+            verify(con).close();
+        });
+        ctx.completeNow();
+    }
+
     /**
      * Verifies that the client tries to connect a limited
      * number of times only.
@@ -297,6 +356,45 @@ public class HonoConnectionImplTest {
         }));
     }
 
+    /**
+     * Verifies that the client tries to reconnect to the peer if the peer
+     * closes the connection's session.
+     *
+     * @param ctx The test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testRemoteSessionCloseTriggersReconnection(final VertxTestContext ctx) {
+
+        // GIVEN a client that is connected to a server
+        final Promise<HonoConnection> connected = Promise.promise();
+        final DisconnectListener<HonoConnection> disconnectListener = mock(DisconnectListener.class);
+        props.setServerRole("service-provider");
+        honoConnection.addDisconnectListener(disconnectListener);
+        honoConnection.connect(new ProtonClientOptions().setReconnectAttempts(1))
+            .onComplete(connected);
+        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
+
+        connected.future().onComplete(ctx.succeeding(c -> {
+
+            ctx.verify(() -> {
+                // WHEN the peer closes the session
+                final ArgumentCaptor<Handler<AsyncResult<ProtonSession>>> sessionCloseHandler = ArgumentCaptor.forClass(Handler.class);
+                verify(session).closeHandler(sessionCloseHandler.capture());
+                sessionCloseHandler.getValue().handle(Future.succeededFuture(session));
+                // THEN the client invokes the registered disconnect handler
+                verify(disconnectListener).onDisconnect(honoConnection);
+                // and the original connection has been closed locally
+                verify(con).close();
+                verify(con).disconnectHandler(null);
+                // and the connection is re-established
+                assertThat(connectionFactory.await()).isTrue();
+            });
+            ctx.completeNow();
+        }));
+
+    }
+
     /**
      * Verifies that it fails to connect after client was shutdown.
      *
@@ -532,7 +630,7 @@ public class HonoConnectionImplTest {
         when(receiver.isOpen()).thenReturn(Boolean.TRUE);
         when(receiver.getSource()).thenReturn(source);
         when(receiver.getRemoteSource()).thenReturn(source);
-        when(con.createReceiver(anyString())).thenReturn(receiver);
+        when(session.createReceiver(anyString())).thenReturn(receiver);
 
         final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
         final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> captor = VertxMockSupport.argumentCaptorHandler();
@@ -574,6 +672,43 @@ public class HonoConnectionImplTest {
 
     }
 
+    /**
+     * Verifies that the client sets configured properties on receiver links
+     * that it creates.
+     *
+     * @param ctx The test context.
+     */
+    @Test
+    public void testCreateReceiverSetsConfiguredProperties(final VertxTestContext ctx) {
+
+        // GIVEN a client configured with some properties
+        props.setMaxMessageSize(3000L);
+        props.setInitialCredits(123);
+        final ProtonReceiver receiver = mock(ProtonReceiver.class);
+        when(session.createReceiver(anyString())).thenReturn(receiver);
+        @SuppressWarnings("unchecked")
+        final Handler<String> remoteCloseHook = mock(Handler.class);
+
+        // WHEN establishing a connection
+        honoConnection.connect()
+            .onComplete(ctx.succeeding(c -> {
+
+                // and then creating a receiver
+                c.createReceiver(
+                        "source",
+                        ProtonQoS.AT_LEAST_ONCE,
+                        (delivery, msg) -> {},
+                        remoteCloseHook);
+                ctx.verify(() -> {
+                    // THEN the client configures the receiver according to the given properties
+                    verify(receiver).setMaxMessageSize(eq(new UnsignedLong(3000L)));
+                    verify(receiver).setQoS(ProtonQoS.AT_LEAST_ONCE);
+                    verify(receiver).setPrefetch(123);
+                });
+                ctx.completeNow();
+            }));
+    }
+
     /**
      * Verifies that the attempt to create a receiver fails with a
      * {@code ServiceInvocationException} if the remote peer refuses
@@ -612,7 +747,7 @@ public class HonoConnectionImplTest {
 
         final ProtonReceiver receiver = mock(ProtonReceiver.class);
         when(receiver.getRemoteCondition()).thenReturn(errorSupplier.get());
-        when(con.createReceiver(anyString())).thenReturn(receiver);
+        when(session.createReceiver(anyString())).thenReturn(receiver);
         @SuppressWarnings("unchecked")
         final Handler<String> remoteCloseHook = mock(Handler.class);
         when(vertx.setTimer(anyLong(), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
@@ -660,7 +795,7 @@ public class HonoConnectionImplTest {
 
         final ProtonReceiver receiver = mock(ProtonReceiver.class);
         when(receiver.isOpen()).thenReturn(Boolean.TRUE);
-        when(con.createReceiver(anyString())).thenReturn(receiver);
+        when(session.createReceiver(anyString())).thenReturn(receiver);
         final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
 
         // GIVEN an established connection
@@ -700,7 +835,7 @@ public class HonoConnectionImplTest {
         when(receiver.isOpen()).thenReturn(Boolean.TRUE);
         when(receiver.getSource()).thenReturn(source);
         when(receiver.getRemoteSource()).thenReturn(source);
-        when(con.createReceiver(anyString())).thenReturn(receiver);
+        when(session.createReceiver(anyString())).thenReturn(receiver);
 
         final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
 
@@ -767,7 +902,7 @@ public class HonoConnectionImplTest {
 
         final ProtonSender sender = mock(ProtonSender.class);
         when(sender.getRemoteCondition()).thenReturn(errorSupplier.get());
-        when(con.createSender(anyString())).thenReturn(sender);
+        when(session.createSender(anyString())).thenReturn(sender);
         final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
         when(vertx.setTimer(anyLong(), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
             // do not run timers immediately
@@ -808,7 +943,7 @@ public class HonoConnectionImplTest {
 
         final ProtonSender sender = mock(ProtonSender.class);
         when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(con.createSender(anyString())).thenReturn(sender);
+        when(session.createSender(anyString())).thenReturn(sender);
         final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
 
         // GIVEN an established connection
@@ -855,7 +990,6 @@ public class HonoConnectionImplTest {
 
     }
 
-
     /**
      * Verifies that the attempt to create a sender fails with a
      * {@code ServerErrorException} if the remote peer sends a
@@ -868,7 +1002,7 @@ public class HonoConnectionImplTest {
 
         final ProtonSender sender = mock(ProtonSender.class);
         when(sender.getRemoteTarget()).thenReturn(null);
-        when(con.createSender(anyString())).thenReturn(sender);
+        when(session.createSender(anyString())).thenReturn(sender);
         final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
 
         // GIVEN an established connection
@@ -899,6 +1033,48 @@ public class HonoConnectionImplTest {
 
     }
 
+    /**
+     * Verifies that the attempt to create a sender fails with a
+     * {@code ClientErrorException} if the remote peer does not support the
+     * client's minimum max-message-size.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testCreateSenderFailsForInsufficientMaxMessageSize(final VertxTestContext ctx) {
+
+        // GIVEN a client that requires a minimum max-message-size of 2kb
+        props.setMinMaxMessageSize(2048L);
+
+        // WHEN trying to open a sender link to a peer that has a max-message-size of 1kb
+        final ProtonSender sender = mock(ProtonSender.class);
+        when(sender.isOpen()).thenReturn(Boolean.TRUE);
+        when(session.createSender(anyString())).thenReturn(sender);
+        final Target target = new Target();
+        target.setAddress("someAddress");
+        when(sender.getRemoteTarget()).thenReturn(target);
+        when(sender.getRemoteMaxMessageSize()).thenReturn(new UnsignedLong(1024L));
+        // mock handlers
+        doAnswer(AdditionalAnswers.answerVoid(
+                (final Handler<AsyncResult<ProtonSender>> handler) -> handler.handle(Future.succeededFuture(sender))))
+                        .when(sender).openHandler(VertxMockSupport.anyHandler());
+        final Handler<String> remoteCloseHook = VertxMockSupport.mockHandler();
+
+        honoConnection.connect()
+            .compose(c -> honoConnection.createSender(
+                "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
+            .onComplete(ctx.failing(t -> {
+                // THEN link establishment fails
+                ctx.verify(() -> {
+                    assertThat(t).isInstanceOf(ClientErrorException.class);
+                    // and the sender link has been closed locally
+                    verify(sender).close();
+                });
+                ctx.completeNow();
+            }));
+
+    }
+
     /**
      * Verifies that the attempt to create a sender succeeds when sender never gets credits.
      *
@@ -908,7 +1084,7 @@ public class HonoConnectionImplTest {
     public void testCreateSenderThatGetsNoCredits(final VertxTestContext ctx) {
         final ProtonSender sender = mock(ProtonSender.class);
         when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(con.createSender(anyString())).thenReturn(sender);
+        when(session.createSender(anyString())).thenReturn(sender);
         final Target target = new Target();
         target.setAddress("someAddress");
         when(sender.getRemoteTarget()).thenReturn(target);
@@ -950,7 +1126,7 @@ public class HonoConnectionImplTest {
 
         final ProtonSender sender = mock(ProtonSender.class);
         when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(con.createSender(anyString())).thenReturn(sender);
+        when(session.createSender(anyString())).thenReturn(sender);
         final Target target = new Target();
         target.setAddress("someAddress");
         when(sender.getRemoteTarget()).thenReturn(target);
@@ -996,7 +1172,7 @@ public class HonoConnectionImplTest {
 
         final ProtonSender sender = mock(ProtonSender.class);
         when(sender.isOpen()).thenReturn(Boolean.TRUE);
-        when(con.createSender(anyString())).thenReturn(sender);
+        when(session.createSender(anyString())).thenReturn(sender);
         final Target target = new Target();
         target.setAddress("someAddress");
         when(sender.getRemoteTarget()).thenReturn(target);
