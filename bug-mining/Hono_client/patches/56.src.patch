diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index d33b1d0f0..099ff946e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -19,8 +19,11 @@ import java.util.Optional;
 import java.util.UUID;
 import java.util.concurrent.ConcurrentHashMap;
 
+import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.AmqpValue;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.config.ClientConfigProperties;
@@ -58,7 +61,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestResponseClient.class);
     private static final long DEFAULT_TIMEOUT_MILLIS = 200L;
 
-    private final Map<String, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
+    private final Map<Object, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
     private final String replyToAddress;
     private final String targetAddress;
 
@@ -248,7 +251,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * @throws NullPointerException if any of the parameters is {@code null}.
      * @throws IllegalArgumentException if the result has not failed.
      */
-    protected final void cancelRequest(final String correlationId, final AsyncResult<R> result) {
+    protected final void cancelRequest(final Object correlationId, final AsyncResult<R> result) {
 
         Objects.requireNonNull(correlationId);
         Objects.requireNonNull(result);
@@ -365,17 +368,41 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                 resultHandler.handle(Future.failedFuture(new ServerErrorException(
                         HttpURLConnection.HTTP_UNAVAILABLE, "no credit available for sending request")));
             } else {
-                final String messageId = (String) request.getMessageId();
-                replyMap.put(messageId, resultHandler);
-                sender.send(request);
+                final Object correlationId = Optional.ofNullable(request.getCorrelationId()).orElse(request.getMessageId());
+                replyMap.put(correlationId, resultHandler);
+                sender.send(request, deliveryUpdated -> {
+
+                    // settle locally
+                    deliveryUpdated.settle();
+
+                    if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
+                        final Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
+                        if (rejected.getError() != null) {
+                            LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}",
+                                    targetAddress, request.getSubject(), correlationId, rejected.getError());
+                            cancelRequest(correlationId, Future.failedFuture(new ClientErrorException(
+                                    HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getCondition().toString())));
+                        } else {
+                            LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]",
+                                    targetAddress, request.getSubject(), correlationId);
+                            cancelRequest(correlationId, Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST)));
+                        }
+                    } else if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
+                        LOG.trace("service has accepted request [target address: {}, subject: {}, correlation ID: {}]",
+                                targetAddress, request.getSubject(), correlationId);
+                    } else {
+                        LOG.debug("service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}",
+                                targetAddress, request.getSubject(), correlationId, deliveryUpdated.getRemoteState());
+                        cancelRequest(correlationId, Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)));
+                    }
+                });
                 if (requestTimeoutMillis > 0) {
                     context.owner().setTimer(requestTimeoutMillis, tid -> {
-                        cancelRequest(messageId, Future.failedFuture(new ServerErrorException(
+                        cancelRequest(correlationId, Future.failedFuture(new ServerErrorException(
                                 HttpURLConnection.HTTP_UNAVAILABLE, "request timed out after " + requestTimeoutMillis + "ms")));
                     });
                 }
                 if (LOG.isDebugEnabled()) {
-                    final Object correlationId = Optional.ofNullable(request.getCorrelationId()).orElse(messageId);
                     final String deviceId = MessageHelper.getDeviceId(request);
                     if (deviceId == null) {
                         LOG.debug("sent request [target address: {}, subject: {}, correlation ID: {}] to service",
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
index e02309d0c..b744f1905 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
@@ -23,13 +23,16 @@ import java.util.Collections;
 import java.util.Map;
 
 import org.apache.qpid.proton.amqp.messaging.AmqpValue;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.transport.Target;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.MessageHelper;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 import org.mockito.ArgumentCaptor;
 
@@ -53,6 +56,12 @@ import io.vertx.proton.ProtonSender;
 @RunWith(VertxUnitRunner.class)
 public class AbstractRequestResponseClientTest {
 
+    /**
+     * Global timeout for all test cases.
+     */
+    @Rule
+    public Timeout timeout = Timeout.seconds(5);
+
     private static final String MESSAGE_ID = "messageid";
     private ProtonReceiver recv;
     private ProtonSender sender;
@@ -110,7 +119,7 @@ public class AbstractRequestResponseClientTest {
         }));
 
         // THEN the message is not sent and the request result handler is failed
-        sendFailure.await(2000);
+        sendFailure.await();
         verify(sender, never()).send(any(Message.class));
     }
 
@@ -134,7 +143,7 @@ public class AbstractRequestResponseClientTest {
 
         // THEN the message is sent and the message being sent contains the headers as application properties
         ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture());
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
         assertThat(messageCaptor.getValue(), is(notNullValue()));
         assertThat(messageCaptor.getValue().getBody(), is(notNullValue()));
         assertThat(messageCaptor.getValue().getBody(), instanceOf(AmqpValue.class));
@@ -146,6 +155,38 @@ public class AbstractRequestResponseClientTest {
         verify(vertx).setTimer(eq(200L), any(Handler.class));
     }
 
+    /**
+     * Verifies that the client fails the result handler if the peer rejects
+     * the request message.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    @Test
+    public void testCreateAndSendRequestFailsOnRejectedMessage(final TestContext ctx) {
+
+        // GIVEN a request-response client that times out requests after 200 ms
+        client.setRequestTimeout(200);
+
+        // WHEN sending a request message with some headers and payload
+        final Async sendFailure = ctx.async();
+        final JsonObject payload = new JsonObject().put("key", "value");
+        client.createAndSendRequest("get", null, payload, ctx.asyncAssertFailure(t -> {
+            sendFailure.complete();
+        }));
+        // and the peer rejects the message
+        final Rejected rejected = new Rejected();
+        rejected.setError(ProtonHelper.condition("bad-request", "request message is malformed"));
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        when(delivery.getRemoteState()).thenReturn(rejected);
+        final ArgumentCaptor<Handler> dispositionHandlerCaptor = ArgumentCaptor.forClass(Handler.class);
+        verify(sender).send(any(Message.class), dispositionHandlerCaptor.capture());
+        dispositionHandlerCaptor.getValue().handle(delivery);
+
+        // THEN the result handler is failed
+        sendFailure.await();
+    }
+
     /**
      * Verifies that the client passes a response message to the handler registered for the request that
      * the response correlates with.
@@ -172,7 +213,7 @@ public class AbstractRequestResponseClientTest {
         client.handleResponse(delivery, response);
 
         // THEN the response is passed to the handler registered with the request
-        responseReceived.await(1000);
+        responseReceived.await();
         verify(vertx, never()).setTimer(anyLong(), any(Handler.class));
     }
 
@@ -205,7 +246,7 @@ public class AbstractRequestResponseClientTest {
         }));
 
         // THEN the request handler is failed
-        requestFailure.await(1000);
+        requestFailure.await();
     }
 
     /**
@@ -228,7 +269,7 @@ public class AbstractRequestResponseClientTest {
         }));
 
         // THEN the request fails immediately
-        requestFailure.await(1000);
+        requestFailure.await();
     }
 
     /**
@@ -251,7 +292,7 @@ public class AbstractRequestResponseClientTest {
         }));
 
         // THEN the request fails immediately
-        requestFailure.await(1000);
+        requestFailure.await();
     }
 
     private AbstractRequestResponseClient<SimpleRequestResponseResult> getClient(final String tenant, final ProtonSender sender, final ProtonReceiver receiver) {
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
index f988e6eb6..c05a0fc4a 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
@@ -96,6 +96,7 @@ public class RegistrationClientImplTest {
      * 
      * @param ctx The vert.x test context.
      */
+    @SuppressWarnings("unchecked")
     @Test
     public void testAssertRegistrationAddsInfoOnCacheMiss(final TestContext ctx) {
 
@@ -115,7 +116,7 @@ public class RegistrationClientImplTest {
             ctx.assertEquals(registrationAssertion, result.getPayload());
         }));
         ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture());
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
         response.setCorrelationId(messageCaptor.getValue().getMessageId());
         final ProtonDelivery delivery = mock(ProtonDelivery.class);
         client.handleResponse(delivery, response);
@@ -127,6 +128,7 @@ public class RegistrationClientImplTest {
      * 
      * @param ctx The vert.x test context.
      */
+    @SuppressWarnings("unchecked")
     @Test
     public void testAssertRegistrationInvokesServiceOnIfNoCacheConfigured(final TestContext ctx) {
 
@@ -145,7 +147,7 @@ public class RegistrationClientImplTest {
             ctx.assertEquals(registrationAssertion, result.getPayload());
         }));
         ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture());
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
         response.setCorrelationId(messageCaptor.getValue().getMessageId());
         final ProtonDelivery delivery = mock(ProtonDelivery.class);
         client.handleResponse(delivery, response);
