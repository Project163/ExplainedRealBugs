diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
index e7219facf..ab5e4a91e 100644
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
@@ -13,6 +13,7 @@
 
 package org.eclipse.hono.client;
 
+import java.time.Duration;
 import java.util.List;
 
 import io.opentracing.SpanContext;
@@ -72,15 +73,16 @@ public interface DeviceConnectionClient extends RequestResponseClient {
      *
      * @param deviceId The device id.
      * @param adapterInstanceId The protocol adapter instance id.
-     * @param lifespanSeconds The lifespan of the mapping entry in seconds. A negative value is interpreted as an
-     *            unlimited lifespan.
+     * @param lifespan The lifespan of the mapping entry. Using a negative duration or {@code null} here is
+     *                 interpreted as an unlimited lifespan. Only the number of seconds in the given duration
+     *                 will be taken into account.
      * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
      *            An implementation should use this as the parent for any span it creates for tracing
      *            the execution of this operation.
      * @return A future indicating whether the operation succeeded or not.
      * @throws NullPointerException if device id or adapter instance id is {@code null}.
      */
-    Future<Void> setCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, int lifespanSeconds,
+    Future<Void> setCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, Duration lifespan,
             SpanContext context);
 
     /**
diff --git a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
index d4e98590b..4313b2be5 100644
--- a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
@@ -13,6 +13,8 @@
 
 package org.eclipse.hono.client;
 
+import java.time.Duration;
+
 import org.eclipse.hono.client.impl.CommandConsumer;
 import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;
 
@@ -67,6 +69,9 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
      * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
      *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
      *                       message transfer and finish the trace span associated with the {@link CommandContext}.
+     * @param lifespan The time period in which the command consumer shall be active. Using a negative duration or
+     *                 {@code null} here is interpreted as an unlimited lifespan. The guaranteed granularity
+     *                 taken into account here is seconds.
      * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
      *                An implementation should use this as the parent for any span it creates for tracing
      *                the execution of this operation.
@@ -83,6 +88,7 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
             String tenantId,
             String deviceId,
             Handler<CommandContext> commandHandler,
+            Duration lifespan,
             SpanContext context);
 
     /**
@@ -104,6 +110,9 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
      * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
      *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
      *                       message transfer and finish the trace span associated with the {@link CommandContext}.
+     * @param lifespan The time period in which the command consumer shall be active. Using a negative duration or
+     *                 {@code null} here is interpreted as an unlimited lifespan. The guaranteed granularity
+     *                 taken into account here is seconds.
      * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
      *                An implementation should use this as the parent for any span it creates for tracing
      *                the execution of this operation.
@@ -121,6 +130,7 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
             String deviceId,
             String gatewayId,
             Handler<CommandContext> commandHandler,
+            Duration lifespan,
             SpanContext context);
 
     /**
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
index 427323317..42a77ade8 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
@@ -14,6 +14,7 @@
 package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
+import java.time.Duration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -260,10 +261,11 @@ public class DeviceConnectionClientImpl extends AbstractRequestResponseClient<De
 
     @Override
     public Future<Void> setCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId,
-            final int lifespanSeconds, final SpanContext context) {
+            final Duration lifespan, final SpanContext context) {
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(adapterInstanceId);
 
+        final int lifespanSeconds = lifespan != null && lifespan.getSeconds() <= Integer.MAX_VALUE ? (int) lifespan.getSeconds() : -1;
         final Map<String, Object> properties = createDeviceIdProperties(deviceId);
         properties.put(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
         properties.put(MessageHelper.APP_PROPERTY_LIFESPAN, lifespanSeconds);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
index c8f2b4721..eda0cd53b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
@@ -14,6 +14,8 @@
 package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
+import java.time.Duration;
+import java.time.Instant;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
@@ -28,6 +30,7 @@ import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;
 import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.ResourceIdentifier;
@@ -47,7 +50,7 @@ import io.vertx.proton.ProtonReceiver;
  * <ul>
  * <li>A single consumer link on an address containing the protocol adapter instance id.</li>
  * <li>A tenant-scoped link, created (if not already existing for that tenant) when
- * {@link #createCommandConsumer(String, String, Handler, SpanContext)} is invoked.</li>
+ * {@link #createCommandConsumer(String, String, Handler, Duration, SpanContext)} is invoked.</li>
  * </ul>
  * <p>
  * Command messages are first received on the tenant-scoped consumer address. It is then determined whether there is
@@ -124,11 +127,11 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
      */
     @Override
     public final Future<MessageConsumer> createCommandConsumer(final String tenantId, final String deviceId,
-            final Handler<CommandContext> commandHandler, final SpanContext context) {
+            final Handler<CommandContext> commandHandler, final Duration lifespan, final SpanContext context) {
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(commandHandler);
-        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, context);
+        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, lifespan, context);
     }
 
     /**
@@ -136,20 +139,25 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
      */
     @Override
     public final Future<MessageConsumer> createCommandConsumer(final String tenantId, final String deviceId,
-            final String gatewayId, final Handler<CommandContext> commandHandler, final SpanContext context) {
+            final String gatewayId, final Handler<CommandContext> commandHandler, final Duration lifespan,
+            final SpanContext context) {
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(gatewayId);
         Objects.requireNonNull(commandHandler);
-        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, context);
+        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, lifespan, context);
     }
 
     private Future<MessageConsumer> doCreateCommandConsumer(final String tenantId, final String deviceId,
-            final String gatewayId, final Handler<CommandContext> commandHandler, final SpanContext context) {
+            final String gatewayId, final Handler<CommandContext> commandHandler, final Duration lifespan,
+            final SpanContext context) {
         if (!initialized.get()) {
             log.error("not initialized");
             return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
         }
+        // lifespan greater than what can be expressed in nanoseconds (i.e. 292 years) is considered unlimited, preventing ArithmeticExceptions down the road
+        final Duration sanitizedLifespan = lifespan == null || lifespan.isNegative()
+                || lifespan.getSeconds() > (Long.MAX_VALUE / 1000_000_000L) ? Duration.ofSeconds(-1) : lifespan;
         log.trace("create command consumer [tenant-id: {}, device-id: {}, gateway-id: {}]", tenantId, deviceId, gatewayId);
         return connection.executeOnContext(result -> {
             // create the tenant-scoped consumer ("command/<tenantId>") that maps/delegates incoming commands to the right handler/adapter-instance
@@ -162,20 +170,23 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                             // TODO find a way to provide a notification here so that potential resources associated with the replaced consumer can be freed (maybe add a commandHandlerOverwritten Handler param to createCommandConsumer())
                         }
                         // associate handler with this adapter instance
-                        return setCommandHandlingAdapterInstance(tenantId, deviceId, context);
+                        return setCommandHandlingAdapterInstance(tenantId, deviceId, sanitizedLifespan, context);
                     })
                     .map(res -> {
-                        final Supplier<Future<Void>> onCloseAction = () -> removeCommandConsumer(tenantId, deviceId, context);
+                        final Instant lifespanStart = Instant.now();
+                        final Supplier<Future<Void>> onCloseAction = () -> removeCommandConsumer(tenantId, deviceId,
+                                sanitizedLifespan, lifespanStart, context);
                         return (MessageConsumer) new DeviceSpecificCommandConsumer(onCloseAction);
                     })
                     .setHandler(result);
         });
     }
 
-    private Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {
+    private Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId,
+            final Duration lifespan, final SpanContext context) {
         return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
                 .compose(client -> {
-                    return client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, -1, context);
+                    return client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, lifespan, context);
                 }).recover(thr -> {
                     log.info("error setting command handling adapter instance [tenant: {}, device: {}]", tenantId,
                             deviceId, thr);
@@ -185,16 +196,34 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                 });
     }
 
-    private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId, final SpanContext context) {
+    private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId, final Duration lifespan,
+            final Instant lifespanStart, final SpanContext createCommandConsumerSpanContext) {
         log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
         adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
+
+        final boolean lifespanReached = !lifespan.isNegative() && Instant.now().isAfter(lifespanStart.plus(lifespan));
+        // TODO when making handling of the lifespan property mandatory for implementors of the Device Connection API,
+        //  removing the adapter instance can be skipped here if 'lifespanReached' is true
         return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
                 .compose(client -> {
+                    // The given span context from the createCommandConsumer invocation is only used here if a non-unlimited lifespan is set
+                    // meaning creating and removing the consumer will probably happen in a timespan short enough for one overall trace.
+                    // The span context isn't used however if lifespanReached is true since the below 'remove' operation will usually (but not necessarily)
+                    // result in a "not found" error in that case, which is expected and should not cause the overall trace to be marked with an error.
+                    final SpanContext context = !lifespan.isNegative() && !lifespanReached ? createCommandConsumerSpanContext : null;
                     return client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, context);
                 }).recover(thr -> {
-                    log.info("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
-                            deviceId, thr);
-                    return Future.failedFuture(thr);
+                    if (lifespanReached && thr instanceof ServiceInvocationException
+                            && ((ServiceInvocationException) thr).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
+                        // entry was not found, meaning it has expired
+                        log.trace("ignoring 404 error when removing command handling adapter instance; entry has already expired [tenant: {}, device: {}]",
+                                tenantId, deviceId);
+                        return Future.succeededFuture();
+                    } else {
+                        log.info("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
+                                deviceId, thr);
+                        return Future.failedFuture(thr);
+                    }
                 });
     }
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
index 0d810150a..c0bdb18ce 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
@@ -162,7 +162,7 @@ public class DeviceConnectionClientImplTest {
     public void testSetCommandHandlingAdapterInstance(final VertxTestContext ctx) {
 
         // WHEN setting the last known gateway
-        client.setCommandHandlingAdapterInstance("deviceId", "gatewayId", -1, span.context())
+        client.setCommandHandlingAdapterInstance("deviceId", "gatewayId", null, span.context())
                 .setHandler(ctx.succeeding(r -> {
                     ctx.verify(() -> {
                         // THEN the response for setting the command handling adapter instance has been handled by the service
@@ -290,7 +290,7 @@ public class DeviceConnectionClientImplTest {
         when(sender.sendQueueFull()).thenReturn(true);
 
         // WHEN getting last known gateway information
-        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", -1, span.context())
+        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, span.context())
                 .setHandler(ctx.failing(t -> {
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
@@ -438,7 +438,7 @@ public class DeviceConnectionClientImplTest {
         });
 
         // WHEN getting last known gateway information
-        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", -1, span.context())
+        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, span.context())
                 .setHandler(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
                     ctx.verify(() -> {
@@ -561,7 +561,7 @@ public class DeviceConnectionClientImplTest {
     public void testSetCommandHandlingAdapterInstanceIncludesRequiredInformationInRequest() {
 
         // WHEN getting last known gateway information
-        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", -1, span.context());
+        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, span.context());
 
         // THEN the message being sent contains the device ID in its properties
         final Message sentMessage = verifySenderSend();
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
index ba8feaaa4..f1adb6787 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
@@ -22,9 +22,11 @@ import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.net.HttpURLConnection;
+import java.time.Duration;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
 
@@ -33,6 +35,7 @@ import org.eclipse.hono.client.CommandTargetMapper;
 import org.eclipse.hono.client.DeviceConnectionClient;
 import org.eclipse.hono.client.DeviceConnectionClientFactory;
 import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
@@ -132,7 +135,8 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
         when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));
         when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
                 .thenReturn(Future.succeededFuture(devConClient));
-        when(devConClient.setCommandHandlingAdapterInstance(anyString(), anyString(), anyInt(), any())).thenReturn(Future.succeededFuture());
+        when(devConClient.setCommandHandlingAdapterInstance(anyString(), anyString(), any(), any())).thenReturn(Future.succeededFuture());
+        when(devConClient.removeCommandHandlingAdapterInstance(anyString(), anyString(), any())).thenReturn(Future.succeededFuture());
 
         commandConsumerFactory = new ProtocolAdapterCommandConsumerFactoryImpl(connection);
         commandConsumerFactory.initialize(commandTargetMapper, deviceConnectionClientFactory);
@@ -158,7 +162,7 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
                 VertxMockSupport.anyHandler()))
         .thenReturn(Future.failedFuture(ex));
 
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null)
+        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
             .setHandler(ctx.failing(t -> {
                 ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
                 ctx.completeNow();
@@ -166,8 +170,8 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
     }
 
     /**
-     * Verifies that the connection successfully opens a command consumer for a
-     * tenant and device Id and opens a receiver link that is scoped to the device.
+     * Verifies that creating a command consumer successfully creates a tenant-scoped
+     * receiver link and registers the command handling adapter instance.
      *
      * @param ctx The test context.
      */
@@ -176,8 +180,46 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
 
         final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
 
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null)
-            .setHandler(ctx.completing());
+        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
+            .setHandler(ctx.succeeding(c -> {
+                ctx.verify(() -> {
+                    verify(connection).createReceiver(eq(tenantCommandAddress), eq(ProtonQoS.AT_LEAST_ONCE), any(), anyInt(),
+                            eq(false), any());
+                    verify(devConClient).setCommandHandlingAdapterInstance(eq(deviceId), anyString(), any(), any());
+                });
+                ctx.completeNow();
+            }));
+    }
+
+    /**
+     * Verifies that creating a command consumer with a positive lifespan and
+     * closing the consumer afterwards succeeds.
+     *
+     * @param ctx The test context.
+     */
+    @Test
+    public void testCreateTimeLimitedCommandConsumerSucceeds(final VertxTestContext ctx) {
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+
+        final Duration lifespan = Duration.ofSeconds(10);
+        final Future<MessageConsumer> commandConsumerFuture = commandConsumerFactory.createCommandConsumer(tenantId,
+                deviceId, commandHandler, lifespan, null);
+        commandConsumerFuture.setHandler(ctx.succeeding(consumer -> {
+            ctx.verify(() -> {
+                verify(connection).createReceiver(eq(tenantCommandAddress), eq(ProtonQoS.AT_LEAST_ONCE), any(), anyInt(),
+                        eq(false), any());
+                verify(devConClient).setCommandHandlingAdapterInstance(eq(deviceId), anyString(), any(), any());
+                // verify closing the consumer is successful
+                consumer.close(ctx.succeeding(v -> {
+                    ctx.verify(() -> {
+                        // verify command handling adapter instance has been explicitly removed (since lifespan hasn't elapsed yet)
+                        verify(devConClient).removeCommandHandlingAdapterInstance(eq(deviceId), anyString(), any());
+                    });
+                    ctx.completeNow();
+                }));
+            });
+        }));
     }
 
 }
