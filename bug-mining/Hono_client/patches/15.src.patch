diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 0577bc467..bcba3ff73 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -177,36 +177,43 @@ public class HonoClient {
         }
     }
 
-    public HonoClient getOrCreateTelemetrySender(
-            final String tenantId,
+    public HonoClient getOrCreateTelemetrySender( final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+        Objects.requireNonNull(tenantId);
+        getOrCreateSender( "telemetry/" + tenantId,  (creationResult) -> createTelemetrySender(tenantId, creationResult), resultHandler);
+        return this;
+    }
+
+    public HonoClient getOrCreateEventSender( final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
+        Objects.requireNonNull(tenantId);
+        getOrCreateSender("event/" + tenantId, (creationResult) -> createEventSender(tenantId, creationResult), resultHandler);
+        return this;
+    }
+
+    private void getOrCreateSender(final String key, final Consumer<Handler> newSenderSupplier,
             final Handler<AsyncResult<MessageSender>> resultHandler) {
 
-        final MessageSender sender = activeSenders.get(Objects.requireNonNull(tenantId));
-        if (sender != null) {
+        final MessageSender sender = activeSenders.get(key);
+        if (sender != null && sender.isOpen()) {
             resultHandler.handle(Future.succeededFuture(sender));
         } else {
-            createTelemetrySender(tenantId, resultHandler);
+            final Future<MessageSender> internal = Future.future();
+            internal.setHandler(result -> {
+                if (result.succeeded()) {
+                    activeSenders.put(key, result.result());
+                }
+                resultHandler.handle(result);
+            });
+            newSenderSupplier.accept(internal.completer());
         }
-        return this;
     }
 
-    public HonoClient createTelemetrySender(
+    private HonoClient createTelemetrySender(
             final String tenantId,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
-        Objects.requireNonNull(tenantId);
-        if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
-        } else {
-            TelemetrySenderImpl.create(context, connection, tenantId, creationResult -> {
-                if (creationResult.succeeded()) {
-                    activeSenders.put(tenantId, creationResult.result());
-                    creationHandler.handle(Future.succeededFuture(creationResult.result()));
-                } else {
-                    creationHandler.handle(Future.failedFuture(creationResult.cause()));
-                }
-            });
-        }
+        checkConnection().compose(
+                connected -> TelemetrySenderImpl.create(context, connection, tenantId, creationHandler),
+                Future.<MessageSender> future().setHandler(creationHandler));
         return this;
     }
 
@@ -215,12 +222,9 @@ public class HonoClient {
             final Consumer<Message> telemetryConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
-        Objects.requireNonNull(tenantId);
-        if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
-        } else {
-            TelemetryConsumerImpl.create(context, connection, tenantId, pathSeparator, telemetryConsumer, creationHandler);
-        }
+        checkConnection().compose(
+                connected -> TelemetryConsumerImpl.create(context, connection, tenantId, pathSeparator, telemetryConsumer, creationHandler),
+                Future.<MessageConsumer> future().setHandler(creationHandler));
         return this;
     }
 
@@ -229,36 +233,30 @@ public class HonoClient {
             final Consumer<Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
-        Objects.requireNonNull(tenantId);
-        if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
-        } else {
-            EventConsumerImpl.create(context, connection, tenantId, pathSeparator, eventConsumer, creationHandler);
-        }
+        checkConnection().compose(
+                connected -> EventConsumerImpl.create(context, connection, tenantId, pathSeparator, eventConsumer, creationHandler),
+                Future.<MessageConsumer> future().setHandler(creationHandler));
         return this;
     }
 
-    public HonoClient createEventSender(
+    private HonoClient createEventSender(
             final String tenantId,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
-        Objects.requireNonNull(tenantId);
+        checkConnection().compose(
+                connected -> EventSenderImpl.create(context, connection, tenantId, creationHandler),
+                Future.<MessageSender> future().setHandler(creationHandler));
+        return this;
+    }
+
+    private <T> Future<T> checkConnection() {
         if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
+            return Future.failedFuture("client is not connected to Hono (yet)");
         } else {
-            EventSenderImpl.create(context, connection, tenantId, creationResult -> {
-                if (creationResult.succeeded()) {
-                    activeSenders.put(tenantId, creationResult.result());
-                    creationHandler.handle(Future.succeededFuture(creationResult.result()));
-                } else {
-                    creationHandler.handle(Future.failedFuture(creationResult.cause()));
-                }
-            });
+            return Future.succeededFuture();
         }
-        return this;
     }
 
-
     public HonoClient getOrCreateRegistrationClient(
             final String tenantId,
             final Handler<AsyncResult<RegistrationClient>> resultHandler) {
diff --git a/client/src/main/java/org/eclipse/hono/client/MessageSender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
index ad9a04c7a..1f748e74f 100644
--- a/client/src/main/java/org/eclipse/hono/client/MessageSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
@@ -23,13 +23,13 @@ import io.vertx.core.Handler;
 import io.vertx.proton.ProtonDelivery;
 
 /**
- * A client for uploading telemetry data to a Hono server.
+ * A client for publishing messages to a Hono server.
  *
  */
 public interface MessageSender {
 
     /**
-     * Checks if this sender can send or buffer (and send later) a telemetry message.
+     * Checks if this sender can send or buffer (and send later) a message.
      * 
      * @return {@code false} if a message can be sent or buffered.
      */
@@ -37,7 +37,7 @@ public interface MessageSender {
 
     /**
      * Sets a handler to be notified once this sender has capacity available to send or
-     * buffer a telemetry message.
+     * buffer a message.
      * <p>
      * The handler registered using this method will be invoked <em>exactly once</em> when
      * this sender is replenished with more credit from the server. For subsequent notifications
@@ -46,7 +46,7 @@ public interface MessageSender {
      * Client code should register a handler after it has checked this sender's capacity to send
      * messages using the <em>sendQueueFull</em> method, e.g.
      * <pre>
-     * TelemetrySender sender;
+     * MessageSender sender;
      * ...
      * sender.send(msg);
      * if (sender.sendQueueFull()) {
@@ -61,7 +61,7 @@ public interface MessageSender {
     void sendQueueDrainHandler(Handler<Void> handler);
 
     /**
-     * Sends an AMQP 1.0 message to the telemetry endpoint configured for this client.
+     * Sends an AMQP 1.0 message to the endpoint configured for this client.
      * <p>
      * The message will be sent immediately if this client has enough credit available on its
      * link to the Hono server or it will be sent later after this client has been replenished
@@ -76,7 +76,7 @@ public interface MessageSender {
     void send(Message message, Handler<Void> capacityAvailableHandler);
 
     /**
-     * Sends an AMQP 1.0 message to the telemetry endpoint configured for this client.
+     * Sends an AMQP 1.0 message to the endpoint configured for this client.
      * 
      * @param message The message to send.
      * @return {@code true} if this client has enough capacity to accept and send the message. If not,
@@ -86,7 +86,7 @@ public interface MessageSender {
     boolean send(Message message);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      * 
      * @param deviceId The id of the device.
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
@@ -105,7 +105,7 @@ public interface MessageSender {
     boolean send(String deviceId, String payload, String contentType);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      * <p>
      * The message will be sent immediately if this client has enough credit available on its
      * link to the Hono server or it will be sent later after this client has been replenished
@@ -129,7 +129,7 @@ public interface MessageSender {
     void send(String deviceId, String payload, String contentType, Handler<Void> capacityAvailableHandler);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      * 
      * @param deviceId The id of the device.
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
@@ -144,7 +144,7 @@ public interface MessageSender {
     boolean send(String deviceId, byte[] payload, String contentType);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      * <p>
      * The message will be sent immediately if this client has enough credit available on its
      * link to the Hono server or it will be sent later after this client has been replenished
@@ -164,7 +164,7 @@ public interface MessageSender {
     void send(String deviceId, byte[] payload, String contentType, Handler<Void> capacityAvailableHandler);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      *
      * @param deviceId The id of the device.
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
@@ -185,7 +185,7 @@ public interface MessageSender {
     boolean send(String deviceId, Map<String, ?> properties, String payload, String contentType);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      *
      * @param deviceId The id of the device.
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
@@ -202,7 +202,7 @@ public interface MessageSender {
     boolean send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      * <p>
      * The message will be sent immediately if this client has enough credit available on its
      * link to the Hono server or it will be sent later after this client has been replenished
@@ -228,7 +228,7 @@ public interface MessageSender {
     void send(String deviceId, Map<String, ?> properties, String payload, String contentType, Handler<Void> capacityAvailableHandler);
 
     /**
-     * Uploads telemetry data for a given device to the telemetry endpoint configured for this client.
+     * Sends a message for a given device to the endpoint configured for this client.
      * <p>
      * The message will be sent immediately if this client has enough credit available on its
      * link to the Hono server or it will be sent later after this client has been replenished
@@ -253,11 +253,11 @@ public interface MessageSender {
      * Sets a callback for handling the closing of this sender due to an error condition indicated by
      * the server.
      * <p>
-     * When this handler is called back, this client's link to the Hono server's telemetry endpoint has been
+     * When this handler is called back, this client's link to the Hono server's endpoint has been
      * closed due to an error condition. Possible reasons include:
      * <ul>
-     * <li>A sent message does not comply with the Hono Telemetry API.</li>
-     * <li>This client is not authorized to upload data for the tenant it has been configured for.</li>
+     * <li>A sent message does not comply with the Hono API.</li>
+     * <li>This client is not authorized to publish messages for the tenant it has been configured for.</li>
      * </ul>
      * The former problem usually indicates an implementation error in the client whereas the
      * latter problem indicates that the client's authorizations might have changed on the server
@@ -283,4 +283,9 @@ public interface MessageSender {
      * @param closeHandler A handler that is called back with the outcome of the attempt to close the link.
      */
     void close(Handler<AsyncResult<Void>> closeHandler);
+
+    /**
+     * @return true if the sender is open, false otherwise
+     */
+    boolean isOpen();
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index f4120da3a..1b3807321 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -41,7 +41,7 @@ import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonHelper;
 
 /**
- * A Vertx-Proton based client for uploading telemtry data to a Hono server.
+ * A Vertx-Proton based client for publishing messages to a Hono server.
  */
 abstract class AbstractSender extends AbstractHonoClient implements MessageSender {
 
@@ -68,7 +68,7 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         } else {
             this.drainHandler = Objects.requireNonNull(handler);
             sender.sendQueueDrainHandler(replenishedSender -> {
-                LOG.trace("telemetry sender has been replenished with {} credits", replenishedSender.getCredit());
+                LOG.trace("sender has been replenished with {} credits", replenishedSender.getCredit());
                 final Handler<Void> currentHandler = this.drainHandler;
                 this.drainHandler = null;
                 if (currentHandler != null) {
@@ -83,6 +83,11 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         closeLinks(closeHandler);
     }
 
+    @Override
+    public boolean isOpen() {
+        return sender.isOpen();
+    }
+
     @Override
     public void setErrorHandler(final Handler<AsyncResult<Void>> errorHandler) {
         sender.closeHandler(s -> {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
index bd4ffa380..46b4d1aaa 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
@@ -29,7 +29,7 @@ import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonReceiver;
 
 /**
- * A Vertx-Proton based client for consuming telemetry data from a Hono server.
+ * A Vertx-Proton based client for consuming event messages from a Hono server.
  */
 public class EventConsumerImpl extends AbstractHonoClient implements MessageConsumer {
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index 7c20275d3..163c98ad3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -29,7 +29,7 @@ import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonSender;
 
 /**
- * A Vertx-Proton based client for event messages to a Hono server.
+ * A Vertx-Proton based client for publishing event messages to a Hono server.
  */
 public class EventSenderImpl extends AbstractSender {
 
