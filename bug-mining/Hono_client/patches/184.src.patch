diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index 70d8b4dce..43f1f3a3b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -234,7 +234,6 @@ public class HonoConnectionImpl implements HonoConnection {
      */
     @Override
     public final Future<Void> isConnected() {
-
         return executeOrRunOnContext(result -> checkConnected(result));
     }
 
@@ -244,7 +243,6 @@ public class HonoConnectionImpl implements HonoConnection {
      * @return A succeeded future if this client is connected.
      */
     protected final Future<Void> checkConnected() {
-
         final Future<Void> result = Future.future();
         checkConnected(result);
         return result;
@@ -369,11 +367,7 @@ public class HonoConnectionImpl implements HonoConnection {
                         conAttempt -> {
                             connecting.compareAndSet(true, false);
                             if (conAttempt.failed()) {
-                                if (isTerminalConnectionError(conAttempt.cause())) {
-                                    failConnectionAttempt(conAttempt.cause(), connectionHandler);
-                                } else {
-                                    reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
-                                }
+                                reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
                             } else {
                                 final ProtonConnection newConnection = conAttempt.result();
                                 if (shuttingDown.get()) {
@@ -444,7 +438,7 @@ public class HonoConnectionImpl implements HonoConnection {
 
     private void notifyReconnectHandlers(final AsyncResult<HonoConnection> reconnectAttempt) {
         if (reconnectAttempt.succeeded()) {
-            for (ReconnectListener<HonoConnection> listener : reconnectListeners) {
+            for (final ReconnectListener<HonoConnection> listener : reconnectListeners) {
                 listener.onReconnect(this);
             }
         }
@@ -464,7 +458,7 @@ public class HonoConnectionImpl implements HonoConnection {
 
     private void notifyDisconnectHandlers() {
 
-        for (DisconnectListener<HonoConnection> listener : disconnectListeners) {
+        for (final DisconnectListener<HonoConnection> listener : disconnectListeners) {
             listener.onDisconnect(this);
         }
     }
@@ -494,7 +488,7 @@ public class HonoConnectionImpl implements HonoConnection {
 
         } else {
             if (connectionFailureCause != null) {
-                log.debug("connection attempt failed", connectionFailureCause);
+                logConnectionError(connectionFailureCause);
             }
             // apply exponential backoff with jitter
             // determine the max delay for this reconnect attempt as 2^attempt * delayIncrement
@@ -520,7 +514,20 @@ public class HonoConnectionImpl implements HonoConnection {
         }
     }
 
-    private boolean isTerminalConnectionError(final Throwable connectionFailureCause) {
+    /**
+     * Log the connection error.
+     * 
+     * @param connectionFailureCause The connection error to log, never is {@code null}.
+     */
+    private void logConnectionError(final Throwable connectionFailureCause) {
+        if (isNoteworthyError(connectionFailureCause)) {
+            log.warn("connection attempt failed", connectionFailureCause);
+        } else {
+            log.debug("connection attempt failed", connectionFailureCause);
+        }
+    }
+
+    private boolean isNoteworthyError(final Throwable connectionFailureCause) {
 
         return connectionFailureCause instanceof SSLException ||
                 connectionFailureCause instanceof AuthenticationException ||
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index 4f5f85e63..db7fd1530 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -36,8 +36,6 @@ import java.util.function.BiConsumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
-import javax.security.sasl.AuthenticationException;
-
 import org.apache.qpid.proton.amqp.messaging.Target;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
@@ -70,7 +68,6 @@ import io.vertx.proton.ProtonMessageHandler;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
-import io.vertx.proton.sasl.MechanismMismatchException;
 import io.vertx.proton.sasl.SaslSystemException;
 
 /**
@@ -175,61 +172,6 @@ public class HonoConnectionImplTest {
         ctx.assertEquals(10L, delayValueCaptor.getAllValues().get(0));
     }
 
-    /**
-     * Verifies that the client fails with a ClientErrorException with status code 401
-     * if it cannot authenticate to the server due to wrong credentials.
-     * 
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectFailsWithClientErrorForAuthenticationException(final TestContext ctx) {
-
-        // GIVEN a client that is configured to connect
-        // to a peer that always throws an AuthenticationException
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
-                .failWith(new AuthenticationException("Failed to authenticate"));
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
-            // THEN the connection attempt fails due do lack of authorization
-            ctx.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, ((ServiceInvocationException) t).getErrorCode());
-        }));
-        // and the client has indeed tried three times in total
-        assertTrue(connectionFactory.awaitFailure());
-    }
-
-    /**
-     * Verifies that the client fails with a ClientErrorException with status code 401
-     * if it cannot authenticate to the server because no suitable SASL mechanism was found.
-     * 
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectFailsWithClientErrorForNoSaslMechanismException(final TestContext ctx) {
-
-        // GIVEN a client that is configured to connect
-        // to a peer that always throws a SaslSystemException (as if no credentials were given)
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
-                .failWith(new MechanismMismatchException(
-                        "Could not find a suitable SASL mechanism for the remote peer using the available credentials."));
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
-            // THEN the connection attempt fails due do lack of authorization
-            ctx.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, ((ServiceInvocationException) t).getErrorCode());
-        }));
-        // and the client has indeed tried three times in total
-        assertTrue(connectionFactory.awaitFailure());
-    }
-
     /**
      * Verifies that the client fails with a ServerErrorException with status code 503
      * if it cannot authenticate to the server because of a transient error.
@@ -257,33 +199,6 @@ public class HonoConnectionImplTest {
         assertTrue(connectionFactory.awaitFailure());
     }
 
-    /**
-     * Verifies that the client fails with a ServerErrorException with status code 503
-     * if it cannot authenticate to the server because of a permanent error.
-     *
-     * @param ctx The vert.x test client.
-     */
-    @Test
-    public void testConnectFailsWithClientErrorForPermanentSaslSystemException(final TestContext ctx) {
-
-        // GIVEN a client that is configured to connect
-        // to a peer that always throws a SaslSystemException with permanent=true
-        props.setReconnectAttempts(2);
-        props.setConnectTimeout(10);
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
-                .failWith(new SaslSystemException(true, "SASL handshake failed due to an unrecoverable error"));
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-
-        // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
-            // THEN the connection attempt fails
-            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServiceInvocationException) t).getErrorCode());
-        }));
-        // and the client has indeed tried three times in total
-        assertTrue(connectionFactory.awaitFailure());
-    }
-
     /**
      * Verifies that the client tries to re-establish a lost connection to a server.
      * 
