diff --git a/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
index bb892136b..388385c4c 100644
--- a/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
@@ -34,4 +34,19 @@ public interface RequestResponseClient {
      * @return {@code true} if this client can be used to exchange messages with the peer.
      */
     boolean isOpen();
+
+    /**
+     * Sets the period of time after which any requests are considered to have timed out.
+     * <p>
+     * The client will fail the result handler passed in to any of the operations if no response
+     * has been received from the peer after the given amount of time.
+     * <p>
+     * When setting this property to 0, requests do not time out at all. Note that this will
+     * allow for unanswered requests piling up in the client, which eventually may cause the
+     * client to run out of memory.
+     * 
+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.
+     * @throws IllegalArgumentException if the value is &lt; 0
+     */
+    void setRequestTimeout(long timoutMillis);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 66695fba5..10cd89f44 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -33,7 +33,6 @@ import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * A Vertx-Proton based parent class for the implementation of API clients that follow the request response pattern.
- * The class is a generic that expects two classes:
  * <p>
  * Subclasses only need to implement some abstract helper methods (see the method descriptions) and their own
  * API specific methods. This allows for implementation classes that focus on the API specific code.
@@ -45,11 +44,14 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         extends AbstractHonoClient implements RequestResponseClient {
 
     private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestResponseClient.class);
+    private static final long DEFAULT_TIMEOUT_MILLIS = 200L;
 
     private final Map<String, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
     private final String replyToAddress;
     private final String targetAddress;
 
+    private long requestTimeoutMillis = DEFAULT_TIMEOUT_MILLIS;
+
     /**
      * Creates a request-response client.
      * <p>
@@ -80,6 +82,31 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         this.receiver = Objects.requireNonNull(receiver);
     }
 
+    /**
+     * Sets the period of time after which any requests are considered to have timed out.
+     * <p>
+     * The client will fail the result handler passed in to any of the operations if no response
+     * has been received from the peer after the given amount of time.
+     * <p>
+     * When setting this property to 0, requests do not time out at all. Note that this will
+     * allow for unanswered requests piling up in the client, which eventually may cause the
+     * client to run out of memory.
+     * <p>
+     * The default value of this property is 200 milliseconds.
+     * 
+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.
+     * @throws IllegalArgumentException if the value is &lt; 0
+     */
+    @Override
+    public final void setRequestTimeout(final long timoutMillis) {
+
+        if (timoutMillis < 0) {
+            throw new IllegalArgumentException("request timeout must be >= 0");
+        } else {
+            this.requestTimeoutMillis = timoutMillis;
+        }
+    }
+
     /**
      * Get the name of the endpoint that this client targets at.
      *
@@ -180,6 +207,30 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         }
     }
 
+    /**
+     * Cancels an outstanding request with a given result.
+     * 
+     * @param correlationId The correlation id of the request to cancel.
+     * @param result The result to pass to the request's result handler.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     * @throws IllegalArgumentException if the result has not failed.
+     */
+    protected final void cancelRequest(final String correlationId, final AsyncResult<R> result) {
+
+        Objects.requireNonNull(correlationId);
+        Objects.requireNonNull(result);
+        if (!result.failed()) {
+            throw new IllegalArgumentException("result must be failed");
+        } else {
+            Handler<AsyncResult<R>> responseHandler = replyMap.remove(correlationId);
+            if (responseHandler != null) {
+                LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
+                        targetAddress, correlationId, result.cause().getMessage());
+                responseHandler.handle(result);
+            }
+        }
+    }
+
     private R getRequestResponseResult(final Message message) {
         final String status = MessageHelper.getApplicationProperty(
                 message.getApplicationProperties(),
@@ -247,12 +298,16 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         Objects.requireNonNull(action);
         Objects.requireNonNull(resultHandler);
 
-        final Message request = createMessage(action, properties);
-        if (payload != null) {
-            request.setContentType(RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON);
-            request.setBody(new AmqpValue(payload.encode()));
+        if (isOpen()) {
+            final Message request = createMessage(action, properties);
+            if (payload != null) {
+                request.setContentType(RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON);
+                request.setBody(new AmqpValue(payload.encode()));
+            }
+            sendRequest(request, resultHandler);
+        } else {
+            resultHandler.handle(Future.failedFuture(new IllegalStateException("sender and/or receiver link is not open")));
         }
-        sendRequest(request, resultHandler);
     }
 
     /**
@@ -268,8 +323,14 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
 
         context.runOnContext(req -> {
             if (sender.getCredit() > 0) {
-                replyMap.put((String) request.getMessageId(), resultHandler);
+                final String messageId = (String) request.getMessageId();
+                replyMap.put(messageId, resultHandler);
                 sender.send(request);
+                if (requestTimeoutMillis > 0) {
+                    context.owner().setTimer(requestTimeoutMillis, tid -> {
+                        cancelRequest(messageId, Future.failedFuture(String.format("request timed out after %d ms", requestTimeoutMillis)));
+                    });
+                }
             } else {
                 LOG.debug("cannot send request to peer, no credit left for link [target: {}]", sender.getRemoteTarget().getAddress());
                 resultHandler.handle(Future.failedFuture("no credit to send request to peer"));
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
index ed62739ba..d1825dd0e 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
@@ -31,6 +31,7 @@ import org.mockito.ArgumentCaptor;
 
 import io.vertx.core.Context;
 import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
 import io.vertx.core.json.JsonObject;
 import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
@@ -52,6 +53,8 @@ public class AbstractRequestResponseClientTest {
     private ProtonReceiver recv;
     private ProtonSender sender;
     private Context context;
+    private Vertx vertx;
+    private AbstractRequestResponseClient<SimpleRequestResponseResult> client;
 
     /**
      * Sets up the fixture.
@@ -59,14 +62,28 @@ public class AbstractRequestResponseClientTest {
     @SuppressWarnings("unchecked")
     @Before
     public void setUp() {
+        vertx = mock(Vertx.class);
         context = mock(Context.class);
         doAnswer(invocation -> {
             Handler<Void> handler = invocation.getArgumentAt(0, Handler.class);
             handler.handle(null);
             return null;
         }).when(context).runOnContext(any(Handler.class));
+        when(context.owner()).thenReturn(vertx);
+
+        Target target = mock(Target.class);
+        when(target.getAddress()).thenReturn("peer/tenant");
+
         recv = mock(ProtonReceiver.class);
+        when(recv.isOpen()).thenReturn(Boolean.TRUE);
         sender = mock(ProtonSender.class);
+        when(sender.getCredit()).thenReturn(10);
+        when(sender.getRemoteTarget()).thenReturn(target);
+        when(sender.isOpen()).thenReturn(Boolean.TRUE);
+
+        client = getClient("tenant", sender, recv);
+        // do not time out requests by default
+        client.setRequestTimeout(0);
     }
 
     /**
@@ -79,11 +96,7 @@ public class AbstractRequestResponseClientTest {
     public void testCreateAndSendRequestFailsIfNoCreditAvailable(final TestContext ctx) {
 
         // GIVEN a request-response client with no credit left for the link to the peer service
-        Target target = mock(Target.class);
-        when(target.getAddress()).thenReturn("peer/tenant");
         when(sender.getCredit()).thenReturn(0);
-        when(sender.getRemoteTarget()).thenReturn(target);
-        AbstractRequestResponseClient<SimpleRequestResponseResult> client = getClient("tenant", sender, recv);
 
         // WHEN sending a request message
         final Async sendFailure = ctx.async();
@@ -97,19 +110,17 @@ public class AbstractRequestResponseClientTest {
     }
 
     /**
-     * Verifies that the client creates and sends a message based on provided headers and payload.
+     * Verifies that the client creates and sends a message based on provided headers and payload
+     * and sets a timer for canceling the request if no response is received.
      * 
      * @param ctx The vert.x test context.
      */
+    @SuppressWarnings("unchecked")
     @Test
     public void testCreateAndSendRequestSendsProperRequestMessage(final TestContext ctx) {
 
-        // GIVEN a request-response client with some credit for the sender link to the peer service
-        Target target = mock(Target.class);
-        when(target.getAddress()).thenReturn("peer/tenant");
-        when(sender.getCredit()).thenReturn(10);
-        when(sender.getRemoteTarget()).thenReturn(target);
-        AbstractRequestResponseClient<SimpleRequestResponseResult> client = getClient("tenant", sender, recv);
+        // GIVEN a request-response client that times out requests after 200 ms
+        client.setRequestTimeout(200);
 
         // WHEN sending a request message with some headers and payload
         final JsonObject payload = new JsonObject().put("key", "value");
@@ -126,6 +137,8 @@ public class AbstractRequestResponseClientTest {
         assertThat(body.getValue(), is(payload.encode()));
         assertThat(messageCaptor.getValue().getApplicationProperties(), is(notNullValue()));
         assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("test-key"), is("test-value"));
+        // and a timer has been set to time out the request after 200 ms
+        verify(vertx).setTimer(eq(200L), any(Handler.class));
     }
 
     /**
@@ -134,15 +147,11 @@ public class AbstractRequestResponseClientTest {
      * 
      * @param ctx The vert.x test context.
      */
+    @SuppressWarnings("unchecked")
     @Test
     public void testHandleResponseInvokesHandlerForMatchingCorrelationId(final TestContext ctx) {
 
         // GIVEN a request message that has been sent to a peer
-        Target target = mock(Target.class);
-        when(target.getAddress()).thenReturn("peer/tenant");
-        when(sender.getCredit()).thenReturn(10);
-        when(sender.getRemoteTarget()).thenReturn(target);
-        AbstractRequestResponseClient<SimpleRequestResponseResult> client = getClient("tenant", sender, recv);
         final Async responseReceived = ctx.async();
         client.createAndSendRequest("request", null, null, ctx.asyncAssertSuccess(s -> {
             ctx.assertEquals(200, s.getStatus());
@@ -160,7 +169,73 @@ public class AbstractRequestResponseClientTest {
 
         // THEN the response is passed to the handler registered with the request
         responseReceived.await(1000);
-        
+        verify(vertx, never()).setTimer(anyLong(), any(Handler.class));
+    }
+
+    /**
+     * Verifies that the client cancels a request for which no response has been received
+     * after a certain amount of time.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCancelRequestFailsResponseHandler(final TestContext ctx) {
+
+        // GIVEN a request-response client which times out requests after 200 ms
+        client.setRequestTimeout(200);
+
+        // WHEN no response is received for a request sent to the peer
+        doAnswer(invocation -> {
+            // do not wait 200ms before running the timeout task but instead
+            // run it immediately
+            Handler<Long> task = invocation.getArgumentAt(1, Handler.class);
+            task.handle(1L);
+            return null;
+        }).when(vertx).setTimer(anyLong(), any(Handler.class));
+        final Async requestFailure = ctx.async();
+        client.createAndSendRequest("request", null, null, ctx.asyncAssertFailure(s -> requestFailure.complete()));
+
+        // THEN the request handler is failed
+        requestFailure.await(1000);
+    }
+
+    /**
+     * Verifies that a response handler is immediately failed when the sender link is not open (yet).
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testCreateAndSendRequestFailsIfSenderIsNotOpen(final TestContext ctx) {
+
+        // GIVEN a client whose sender and receiver are not open
+        when(sender.isOpen()).thenReturn(Boolean.FALSE);
+
+        // WHEN sending a request
+        Async requestFailure = ctx.async();
+        client.createAndSendRequest("get", null, ctx.asyncAssertFailure(s -> requestFailure.complete()));
+
+        // THEN the request fails immediately
+        requestFailure.await(1000);
+    }
+
+    /**
+     * Verifies that a response handler is immediately failed when the receiver link is not open (yet).
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testCreateAndSendRequestFailsIfReceiverIsNotOpen(final TestContext ctx) {
+
+        // GIVEN a client whose sender and receiver are not open
+        when(recv.isOpen()).thenReturn(Boolean.FALSE);
+
+        // WHEN sending a request
+        Async requestFailure = ctx.async();
+        client.createAndSendRequest("get", null, ctx.asyncAssertFailure(s -> requestFailure.complete()));
+
+        // THEN the request fails immediately
+        requestFailure.await(1000);
     }
 
     private AbstractRequestResponseClient<SimpleRequestResponseResult> getClient(final String tenant, final ProtonSender sender, final ProtonReceiver receiver) {
