diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index f593b889c..c3ceb3767 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -53,7 +53,18 @@ import io.vertx.proton.ProtonDelivery;
  * Some of the <em>connect</em> methods accept a {@code ProtonClientOptions} type parameter. Note that these options
  * only influence the client's behavior when establishing the TCP connection with the peer. The overall behavior of
  * the client regarding the establishment of the AMQP connection must be configured using the
- * {@link ClientConfigProperties} passed in to the <em>newClient</em> method.
+ * {@link ClientConfigProperties} passed in to the <em>newClient</em> method. In particular, the
+ * {@link ClientConfigProperties#setReconnectAttempts(int)} method can be used to specify, how many
+ * times the client should try to establish a connection to the peer before giving up.
+ * <p>
+ * <em>NB</em> When the client tries to establish a connection to the peer, it stores the <em>current</em>
+ * vert.x {@code Context} in a local variable and performs all further interactions with the peer running
+ * on this Context. Invoking any of the methods of the client from a vert.x Context other than the one
+ * used for establishing the connection may cause race conditions or even deadlocks because the handlers
+ * registered on the {@code Future}s returned by these methods will be invoked from the stored Context.
+ * It is the invoking code's responsibility to either ensure that the client's methods are always invoked
+ * from the same Context or to make sure that the handlers are running on the correct Context, e.g. by using
+ * the {@code Context}'s <em>runOnContext</em> method.
  */
 public interface HonoClient {
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index cd0cc3e77..222f35206 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -120,6 +120,22 @@ public abstract class AbstractHonoClient {
         this.tracer = Optional.ofNullable(tracer).orElse(NoopTracerFactory.create());
     }
 
+    /**
+     * Executes some code on the vert.x Context that has been used to establish the
+     * connection to the peer.
+     * 
+     * @param <T> The type of the result that the code produces.
+     * @param codeToRun The code to execute. The code is required to either complete or
+     *                  fail the future that is passed into the handler.
+     * @return The future passed into the handler for executing the code. The future
+     *         thus indicates the outcome of executing the code.
+     */
+    protected final <T> Future<T> executeOrRunOnContext(
+            final Handler<Future<T>> codeToRun) {
+
+        return HonoProtonHelper.executeOrRunOnContext(context, codeToRun);
+    }
+
     /**
      * Marks an <em>OpenTracing</em> span as erroneous and logs an exception.
      * <p>
@@ -221,33 +237,9 @@ public abstract class AbstractHonoClient {
 
         Objects.requireNonNull(closeHandler);
 
-        final Future<Void> senderCloseHandler = Future.future();
-        senderCloseHandler.compose(closedSender -> {
-
-            final Future<Void> receiverCloseHandler = Future.future();
-
-            if (receiver == null) {
-                receiverCloseHandler.handle(Future.succeededFuture());
-            } else {
-                final Handler<AsyncResult<ProtonReceiver>> wrappedHandler = HonoProtonHelper.setCloseHandler(receiver, closeAttempt -> {
-                    LOG.debug("closed message consumer for [{}]", receiver.getSource().getAddress());
-                    receiverCloseHandler.complete();
-                });
-                if (receiver.isOpen()) {
-                    // wait for peer's detach frame to trigger the handler
-                    receiver.close();
-                } else {
-                    // trigger handler manually to make sure that
-                    // resources are freed up
-                    wrappedHandler.handle(Future.succeededFuture());
-                }
-            }
-            return receiverCloseHandler;
-
-        }).setHandler(closeHandler);
-
-        context.runOnContext(go -> {
+        final Future<Void> res = executeOrRunOnContext(result -> {
 
+            final Future<Void> senderCloseHandler = Future.future();
             if (sender == null) {
                 senderCloseHandler.complete();
             } else {
@@ -264,7 +256,29 @@ public abstract class AbstractHonoClient {
                     wrappedHandler.handle(Future.succeededFuture());
                 }
             }
+
+            senderCloseHandler.compose(closedSender -> {
+
+                if (receiver == null) {
+                    result.complete((Void) null);
+                } else {
+                    final Handler<AsyncResult<ProtonReceiver>> wrappedHandler = HonoProtonHelper.setCloseHandler(receiver, closeAttempt -> {
+                        LOG.debug("closed message consumer for [{}]", receiver.getSource().getAddress());
+                        result.complete((Void) null);
+                    });
+                    if (receiver.isOpen()) {
+                        // wait for peer's detach frame to trigger the handler
+                        receiver.close();
+                    } else {
+                        // trigger handler manually to make sure that
+                        // resources are freed up
+                        wrappedHandler.handle(Future.succeededFuture());
+                    }
+                }
+
+            }, result);
         });
+        res.setHandler(closeHandler);
     }
 
     /**
@@ -325,9 +339,7 @@ public abstract class AbstractHonoClient {
         Objects.requireNonNull(targetAddress);
         Objects.requireNonNull(qos);
 
-        final Future<ProtonSender> result = Future.future();
-
-        ctx.runOnContext(create -> {
+        return HonoProtonHelper.executeOrRunOnContext(ctx, result -> {
 
             final ProtonSender sender = con.createSender(targetAddress);
             sender.attachments().set(KEY_LINK_ESTABLISHED, Boolean.class, Boolean.FALSE);
@@ -362,8 +374,6 @@ public abstract class AbstractHonoClient {
             HonoProtonHelper.setCloseHandler(sender, remoteClosed -> onRemoteDetach(sender, con.getRemoteContainer(), true, closeHook));
             sender.open();
         });
-
-        return result;
     }
 
     /**
@@ -398,9 +408,7 @@ public abstract class AbstractHonoClient {
         Objects.requireNonNull(qos);
         Objects.requireNonNull(messageHandler);
 
-        final Future<ProtonReceiver> result = Future.future();
-        ctx.runOnContext(go -> {
-
+        return HonoProtonHelper.executeOrRunOnContext(ctx, result -> {
             final ProtonReceiver receiver = con.createReceiver(sourceAddress);
             receiver.attachments().set(KEY_LINK_ESTABLISHED, Boolean.class, Boolean.FALSE);
             receiver.setAutoAccept(true);
@@ -434,7 +442,6 @@ public abstract class AbstractHonoClient {
             HonoProtonHelper.setCloseHandler(receiver, remoteClosed -> onRemoteDetach(receiver, con.getRemoteContainer(), true, closeHook));
             receiver.open();
         });
-        return result;
     }
 
     private static void onRemoteDetach(
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index e343f3ebe..4edbd466f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -679,7 +679,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
             currentSpan.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
         }
 
-        context.runOnContext(req -> {
+        executeOrRunOnContext(res -> {
             if (sender.sendQueueFull()) {
                 LOG.debug("cannot send request to peer, no credit left for link [target: {}]", targetAddress);
                 resultHandler.handle(Future.failedFuture(new ServerErrorException(
@@ -739,6 +739,11 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                     }
                 }
             }
+        }).otherwise(t -> {
+            // there is no context to run on
+            resultHandler.handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
+                    "not connected")));
+            return null;
         });
     }
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index bb34d97b8..eceeab4e9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -166,18 +166,13 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
 
         Objects.requireNonNull(rawMessage);
 
-        if (capacityAvailableHandler == null) {
-            final Future<ProtonDelivery> result = Future.future();
-            context.runOnContext(send -> {
+        return executeOrRunOnContext(result -> {
+            if (capacityAvailableHandler == null) {
                 final Span currentSpan = startSpan(rawMessage);
                 sendMessage(rawMessage, currentSpan).setHandler(result.completer());
-            });
-            return result;
-        } else if (this.drainHandler != null) {
-            throw new IllegalStateException("cannot send message while waiting for replenishment with credit");
-        } else if (sender.isOpen()) {
-            final Future<ProtonDelivery> result = Future.future();
-            context.runOnContext(send -> {
+            } else if (this.drainHandler != null) {
+                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
+            } else if (sender.isOpen()) {
                 final Span currentSpan = startSpan(rawMessage);
                 sendMessage(rawMessage, currentSpan).setHandler(result.completer());
                 if (sender.sendQueueFull()) {
@@ -185,11 +180,10 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
                 } else {
                     capacityAvailableHandler.handle(null);
                 }
-            });
-            return result;
-        } else {
-            throw new IllegalStateException("sender is not open");
-        }
+            } else {
+                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
+            }
+        });
     }
 
     @Override
@@ -213,8 +207,7 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
         span.setTag(MessageHelper.APP_PROPERTY_DEVICE_ID, MessageHelper.getDeviceId(rawMessage));
         tracer.inject(span.context(), Format.Builtin.TEXT_MAP, new MessageAnnotationsInjectAdapter(rawMessage));
 
-        final Future<ProtonDelivery> result = Future.future();
-        context.runOnContext(send -> {
+        return executeOrRunOnContext(result -> {
             if (sender.sendQueueFull()) {
                 final ServiceInvocationException e = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available");
                 logError(span, e);
@@ -224,7 +217,6 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
                 sendMessage(rawMessage, span).setHandler(result.completer());
             }
         });
-        return result;
     }
 
     @Override
@@ -468,5 +460,4 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
             return Future.failedFuture(t);
         });
     }
-
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 3216609ae..9e5973b35 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -49,6 +49,7 @@ import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.connection.ConnectionFactory;
 import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.HonoProtonHelper;
 import org.eclipse.hono.util.ResourceIdentifier;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -68,6 +69,16 @@ import io.vertx.proton.ProtonDelivery;
 
 /**
  * A helper class for creating Vert.x based clients for Hono's arbitrary APIs.
+ * <p>
+ * The client ensures that all interactions with the peer are performed on the
+ * same vert.x {@code Context}. For this purpose the <em>connect</em> methods
+ * either use the current Context or create a new Context for connecting to
+ * the peer. This same Context is then used for all consecutive interactions with
+ * the peer as well, e.g. when creating consumers or senders.
+ * <p>
+ * Closing or disconnecting the client will <em>release</em> the Context. The next
+ * invocation of any of the connect methods will then use the same approach as
+ * described above to determine the Context to use.
  */
 public class HonoClientImpl implements HonoClient {
 
@@ -77,10 +88,6 @@ public class HonoClientImpl implements HonoClient {
      * The configuration properties for this client.
      */
     protected final ClientConfigProperties clientConfigProperties;
-    /**
-     * The vert.x Context to use for interacting with the peer.
-     */
-    protected final Context context;
     /**
      * The senders that can be used to send telemetry and or event messages.
      * The target address is used as the key, e.g. <em>telemetry/DEFAULT_TENANT</em>.
@@ -91,6 +98,10 @@ public class HonoClientImpl implements HonoClient {
      * The AMQP connection to the peer.
      */
     protected ProtonConnection connection;
+    /**
+     * The vert.x Context to use for interacting with the peer.
+     */
+    protected volatile Context context;
 
     private final Map<String, RequestResponseClient> activeRequestResponseClients = new HashMap<>();
     private final Map<String, Boolean> creationLocks = new HashMap<>();
@@ -148,7 +159,6 @@ public class HonoClientImpl implements HonoClient {
         } else {
             this.connectionFactory = ConnectionFactory.newConnectionFactory(this.vertx, clientConfigProperties);
         }
-        this.context = this.vertx.getOrCreateContext();
         this.clientConfigProperties = clientConfigProperties;
         this.connectAttempts = new AtomicInteger(0);
     }
@@ -178,21 +188,29 @@ public class HonoClientImpl implements HonoClient {
         this.tracer = Objects.requireNonNull(opentracingTracer);
     }
 
+    /**
+     * Executes some code on the vert.x Context that has been used to establish the
+     * connection to the peer.
+     * 
+     * @param <T> The type of the result that the code produces.
+     * @param codeToRun The code to execute. The code is required to either complete or
+     *                  fail the future that is passed into the handler.
+     * @return The future passed into the handler for executing the code. The future
+     *         thus indicates the outcome of executing the code. The future will
+     *         be failed if the <em>context</em> property is {@code null}.
+     */
+    private <T> Future<T> executeOrRunOnContext(final Handler<Future<T>> codeToRun) {
+
+        return HonoProtonHelper.executeOrRunOnContext(context, codeToRun);
+    }
+
     /**
      * {@inheritDoc}
      */
     @Override
     public final Future<Void> isConnected() {
 
-        final Future<Void> result = Future.future();
-        context.runOnContext(check -> {
-            if (isConnectedInternal()) {
-                result.complete();
-            } else {
-                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-            }
-        });
-        return result;
+        return executeOrRunOnContext(result -> checkConnected(result));
     }
 
     /**
@@ -203,12 +221,17 @@ public class HonoClientImpl implements HonoClient {
     protected final Future<Void> checkConnected() {
 
         final Future<Void> result = Future.future();
+        checkConnected(result);
+        return result;
+    }
+
+    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {
         if (isConnectedInternal()) {
-            result.complete();
+            resultHandler.handle(Future.succeededFuture());
         } else {
-            result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
+            resultHandler.handle(Future.failedFuture(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
         }
-        return result;
     }
 
     private boolean isConnectedInternal() {
@@ -225,6 +248,7 @@ public class HonoClientImpl implements HonoClient {
             this.connection = connection;
             if (connection == null) {
                 this.offeredCapabilities = Collections.emptyList();
+                context = null;
             } else {
                 this.offeredCapabilities = Optional.ofNullable(connection.getRemoteOfferedCapabilities())
                         .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))
@@ -301,7 +325,12 @@ public class HonoClientImpl implements HonoClient {
             final Handler<AsyncResult<HonoClient>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
 
-        context.runOnContext(connect -> {
+        context = vertx.getOrCreateContext();
+        LOG.trace("running on vert.x context [event-loop context: {}]", context.isEventLoopContext());
+
+        // context cannot be null thus it is safe to
+        // ignore the Future returned by executeOrRunContext
+        executeOrRunOnContext(ignore -> {
 
             if (isConnectedInternal()) {
                 LOG.debug("already connected to server [{}:{}]", connectionFactory.getHost(),
@@ -437,7 +466,7 @@ public class HonoClientImpl implements HonoClient {
         } else if (clientConfigProperties.getReconnectAttempts() - connectAttempts.getAndIncrement() == 0) {
             LOG.debug("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
                     clientConfigProperties.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
-            connectAttempts = new AtomicInteger(0);
+            clearState();
             if (connectionFailureCause == null) {
                 connectionHandler.handle(Future.failedFuture(
                         new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
@@ -450,6 +479,7 @@ public class HonoClientImpl implements HonoClient {
                         new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect",
                                 connectionFailureCause)));
             }
+
         } else {
             if (connectionFailureCause != null) {
                 LOG.debug("connection attempt failed", connectionFailureCause);
@@ -553,48 +583,51 @@ public class HonoClientImpl implements HonoClient {
             final String key,
             final Supplier<Future<MessageSender>> newSenderSupplier) {
 
-        final Future<MessageSender> result = Future.future();
-
-        context.runOnContext(get -> {
-            final MessageSender sender = activeSenders.get(key);
-            if (sender != null && sender.isOpen()) {
-                LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
-                result.complete(sender);
-            } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
-                // register a handler to be notified if the underlying connection to the server fails
-                // so that we can fail the result handler passed in
-                final Handler<Void> connectionFailureHandler = connectionLost -> {
-                    // remove lock so that next attempt to open a sender doesn't fail
-                    creationLocks.remove(key);
-                    result.tryFail(
-                            new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-                };
-                creationRequests.add(connectionFailureHandler);
-                creationLocks.put(key, Boolean.TRUE);
-                LOG.debug("creating new message sender for {}", key);
-
-                newSenderSupplier.get().setHandler(creationAttempt -> {
-                    creationLocks.remove(key);
-                    creationRequests.remove(connectionFailureHandler);
-                    if (creationAttempt.succeeded()) {
-                        final MessageSender newSender = creationAttempt.result();
-                        LOG.debug("successfully created new message sender for {}", key);
-                        activeSenders.put(key, newSender);
-                        result.tryComplete(newSender);
-                    } else {
-                        LOG.debug("failed to create new message sender for {}", key, creationAttempt.cause());
-                        activeSenders.remove(key);
-                        result.tryFail(creationAttempt.cause());
-                    }
-                });
+        return executeOrRunOnContext(result -> getOrCreateSender(key, newSenderSupplier, result));
+    }
 
-            } else {
-                LOG.debug("already trying to create a message sender for {}", key);
-                result.fail(new ServerErrorException(
-                        HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-            }
-        });
-        return result;
+    private void getOrCreateSender(
+            final String key,
+            final Supplier<Future<MessageSender>> newSenderSupplier,
+            final Future<MessageSender> result) {
+
+        final MessageSender sender = activeSenders.get(key);
+        if (sender != null && sender.isOpen()) {
+            LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
+            result.tryComplete(sender);
+        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
+            // register a handler to be notified if the underlying connection to the server fails
+            // so that we can fail the result handler passed in
+            final Handler<Void> connectionFailureHandler = connectionLost -> {
+                // remove lock so that next attempt to open a sender doesn't fail
+                creationLocks.remove(key);
+                result.tryFail(
+                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
+            };
+            creationRequests.add(connectionFailureHandler);
+            creationLocks.put(key, Boolean.TRUE);
+            LOG.debug("creating new message sender for {}", key);
+
+            newSenderSupplier.get().setHandler(creationAttempt -> {
+                creationLocks.remove(key);
+                creationRequests.remove(connectionFailureHandler);
+                if (creationAttempt.succeeded()) {
+                    final MessageSender newSender = creationAttempt.result();
+                    LOG.debug("successfully created new message sender for {}", key);
+                    activeSenders.put(key, newSender);
+                    result.complete(newSender);
+                } else {
+                    LOG.debug("failed to create new message sender for {}", key, creationAttempt.cause());
+                    activeSenders.remove(key);
+                    result.tryFail(creationAttempt.cause());
+                }
+            });
+
+        } else {
+            LOG.debug("already trying to create a message sender for {}", key);
+            result.tryFail(new ServerErrorException(
+                    HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
+        }
     }
 
     /**
@@ -680,27 +713,30 @@ public class HonoClientImpl implements HonoClient {
             final String tenantId,
             final Supplier<Future<MessageConsumer>> newConsumerSupplier) {
 
-        final Future<MessageConsumer> result = Future.future();
-        context.runOnContext(get -> {
-
-            // register a handler to be notified if the underlying connection to the server fails
-            // so that we can fail the returned future
-            final Handler<Void> connectionFailureHandler = connectionLost -> {
-                result.tryFail(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost"));
-            };
-            creationRequests.add(connectionFailureHandler);
+        return executeOrRunOnContext(result -> createConsumer(tenantId, newConsumerSupplier, result));
+    }
 
-            newConsumerSupplier.get().setHandler(attempt -> {
-                creationRequests.remove(connectionFailureHandler);
-                if (attempt.succeeded()) {
-                    result.tryComplete(attempt.result());
-                } else {
-                    result.tryFail(attempt.cause());
-                }
-            });
+    private void createConsumer(
+            final String tenantId,
+            final Supplier<Future<MessageConsumer>> newConsumerSupplier,
+            final Future<MessageConsumer> result) {
+
+        // register a handler to be notified if the underlying connection to the server fails
+        // so that we can fail the returned future
+        final Handler<Void> connectionFailureHandler = connectionLost -> {
+            result.tryFail(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "connection to server lost"));
+        };
+        creationRequests.add(connectionFailureHandler);
+
+        newConsumerSupplier.get().setHandler(attempt -> {
+            creationRequests.remove(connectionFailureHandler);
+            if (attempt.succeeded()) {
+                result.tryComplete(attempt.result());
+            } else {
+                result.tryFail(attempt.cause());
+            }
         });
-        return result;
     }
 
     /**
@@ -938,47 +974,50 @@ public class HonoClientImpl implements HonoClient {
             final String key,
             final Supplier<Future<RequestResponseClient>> clientSupplier) {
 
-        final Future<RequestResponseClient> result = Future.future();
-
-        context.runOnContext(go -> {
-            final RequestResponseClient client = activeRequestResponseClients.get(key);
-            if (client != null && client.isOpen()) {
-                LOG.debug("reusing existing client [target: {}]", key);
-                result.complete(client);
-            } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
-
-                // register a handler to be notified if the underlying connection to the server fails
-                // so that we can fail the result handler passed in
-                final Handler<Void> connectionFailureHandler = connectionLost -> {
-                    // remove lock so that next attempt to open a sender doesn't fail
-                    creationLocks.remove(key);
-                    result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-                };
-                creationRequests.add(connectionFailureHandler);
-                creationLocks.put(key, Boolean.TRUE);
-                LOG.debug("creating new client [target: {}]", key);
-
-                clientSupplier.get().setHandler(creationAttempt -> {
-                    if (creationAttempt.succeeded()) {
-                        LOG.debug("successfully created new client [target: {}]", key);
-                        activeRequestResponseClients.put(key, creationAttempt.result());
-                        result.tryComplete(creationAttempt.result());
-                    } else {
-                        LOG.debug("failed to create new client [target: {}]", key, creationAttempt.cause());
-                        activeRequestResponseClients.remove(key);
-                        result.tryFail(creationAttempt.cause());
-                    }
-                    creationLocks.remove(key);
-                    creationRequests.remove(connectionFailureHandler);
-                });
+        return executeOrRunOnContext(result -> getOrCreateRequestResponseClient(key, clientSupplier, result));
+    }
 
-            } else {
-                LOG.debug("already trying to create a client [target: {}]", key);
-                result.fail(new ServerErrorException(
-                        HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-            }
-        });
-        return result;
+    private void getOrCreateRequestResponseClient(
+            final String key,
+            final Supplier<Future<RequestResponseClient>> clientSupplier,
+            final Future<RequestResponseClient> result) {
+
+        final RequestResponseClient client = activeRequestResponseClients.get(key);
+        if (client != null && client.isOpen()) {
+            LOG.debug("reusing existing client [target: {}]", key);
+            result.complete(client);
+        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
+
+            // register a handler to be notified if the underlying connection to the server fails
+            // so that we can fail the result handler passed in
+            final Handler<Void> connectionFailureHandler = connectionLost -> {
+                // remove lock so that next attempt to open a sender doesn't fail
+                creationLocks.remove(key);
+                result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
+            };
+            creationRequests.add(connectionFailureHandler);
+            creationLocks.put(key, Boolean.TRUE);
+            LOG.debug("creating new client [target: {}]", key);
+
+            clientSupplier.get().setHandler(creationAttempt -> {
+                if (creationAttempt.succeeded()) {
+                    LOG.debug("successfully created new client [target: {}]", key);
+                    activeRequestResponseClients.put(key, creationAttempt.result());
+                    result.tryComplete(creationAttempt.result());
+                } else {
+                    LOG.debug("failed to create new client [target: {}]", key, creationAttempt.cause());
+                    activeRequestResponseClients.remove(key);
+                    result.tryFail(creationAttempt.cause());
+                }
+                creationLocks.remove(key);
+                creationRequests.remove(connectionFailureHandler);
+            });
+
+        } else {
+            LOG.debug("already trying to create a client [target: {}]", key);
+            result.fail(new ServerErrorException(
+                    HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
+        }
     }
 
     /**
@@ -1059,7 +1098,8 @@ public class HonoClientImpl implements HonoClient {
     //-----------------------------------< private methods >---
 
     private void closeConnection(final Handler<AsyncResult<Void>> completionHandler) {
-        context.runOnContext(close -> {
+
+        final Future<Void> result = executeOrRunOnContext(r -> {
             if (isConnectedInternal()) {
                 LOG.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
                 final ProtonConnection connectionToClose = connection;
@@ -1080,7 +1120,8 @@ public class HonoClientImpl implements HonoClient {
                 LOG.info("connection to server [{}:{}] already closed", connectionFactory.getHost(), connectionFactory.getPort());
             }
             disconnecting.compareAndSet(Boolean.TRUE, Boolean.FALSE);
-            completionHandler.handle(Future.succeededFuture());
+            r.complete();
         });
+        result.setHandler(completionHandler);
     }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index 0a879f601..9e318ea9c 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -157,8 +157,7 @@ public final class TelemetrySenderImpl extends AbstractSender {
         if (!isRegistrationAssertionRequired()) {
             MessageHelper.getAndRemoveRegistrationAssertion(rawMessage);
         }
-        final Future<ProtonDelivery> result = Future.future();
-        context.runOnContext(send -> {
+        return executeOrRunOnContext(result -> {
             if (sender.sendQueueFull()) {
                 final ServiceInvocationException e = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available");
                 logError(span, e);
@@ -168,7 +167,6 @@ public final class TelemetrySenderImpl extends AbstractSender {
                 sendMessageAndWaitForOutcome(rawMessage, span).setHandler(result.completer());
             }
         });
-        return result;
     }
 
     /**
