diff --git a/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java b/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java
index 7e7f64081..2082bf0a6 100644
--- a/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/CredentialsClient.java
@@ -28,7 +28,7 @@ import java.net.HttpURLConnection;
  * Credentials API specification</a> for a description of the result codes returned.
  * </p>
  */
-public interface CredentialsClient {
+public interface CredentialsClient extends RequestResponseClient {
 
     /**
      * Gets credentials data of a specific type by authId of a device.
@@ -43,21 +43,4 @@ public interface CredentialsClient {
 
      */
     void get(String type, String authId,  Handler<AsyncResult<CredentialsResult>> resultHandler);
-
-    /**
-     * Closes the AMQP link(s) with the Hono server this client is configured to use.
-     * <p>
-     * The underlying AMQP connection to the server is not affected by this operation.
-     * </p>
-     * 
-     * @param closeHandler A handler that is called back with the result of the attempt to close the links.
-     */
-    void close(Handler<AsyncResult<Void>> closeHandler);
-
-    /**
-     * Checks if this client's sender and receiver are (locally) open.
-     * 
-     * @return {@code true} if this client can be used to exchange messages with the peer.
-     */
-    boolean isOpen();
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java b/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java
index 8723c03c9..d6c970125 100644
--- a/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/RegistrationClient.java
@@ -30,11 +30,11 @@ import io.vertx.core.json.JsonObject;
  * Registration API specification</a> for a description of the result codes returned.
  * </p>
  */
-public interface RegistrationClient {
+public interface RegistrationClient extends RequestResponseClient {
 
     /**
      * Asserts that a device is registered with a given tenant and is enabled.
-     * 
+     *
      * @param deviceId The ID of the device to get the assertion for.
      * @param resultHandler The handler to invoke with the result of the operation. If a device with the
      *         given ID is registered for the tenant and its <em>enabled</em> property is {@code true},
@@ -46,7 +46,7 @@ public interface RegistrationClient {
 
     /**
      * Checks whether a given device is registered.
-     * 
+     *
      * @param deviceId The id of the device to check.
      * @param resultHandler The handler to invoke with the result of the operation.
      */
@@ -54,7 +54,7 @@ public interface RegistrationClient {
 
     /**
      * Finds a device registration by a key that it is registered with.
-     * 
+     *
      * @param key The name of the key to find the device registration under.
      * @param value The value that the key must match.
      * @param resultHandler The handler to invoke with the result of the operation.
@@ -67,7 +67,7 @@ public interface RegistrationClient {
      * A device needs to be (successfully) registered before a client can upload
      * telemetry data for it.
      * </p>
-     * 
+     *
      * @param deviceId The id of the device to register.
      * @param data The data to register with the device.
      * @param resultHandler The handler to invoke with the result of the operation.
@@ -80,11 +80,11 @@ public interface RegistrationClient {
      * A device needs to be (successfully) registered before a client can upload
      * telemetry data for it.
      * </p>
-     * 
+     *
      * @param deviceId The id of the device to register.
      * @param data The data to update the registration with (may be {@code null}).
      *             The original data will be <em>replaced</em> with this data, i.e.
-     *             the data will not be merged with the existing data. 
+     *             the data will not be merged with the existing data.
      * @param resultHandler The handler to invoke with the result of the operation.
      */
     void update(String deviceId, JsonObject data, Handler<AsyncResult<RegistrationResult>> resultHandler);
@@ -95,26 +95,9 @@ public interface RegistrationClient {
      * Once a device has been (successfully) deregistered, no more telemtry data can be uploaded
      * for it nor can commands be sent to it anymore.
      * </p>
-     * 
+     *
      * @param deviceId The id of the device to deregister.
      * @param resultHandler The handler to invoke with the result of the operation.
      */
     void deregister(String deviceId, Handler<AsyncResult<RegistrationResult>> resultHandler);
-
-    /**
-     * Closes the AMQP link(s) with the Hono server this client is configured to use.
-     * <p>
-     * The underlying AMQP connection to the server is not affected by this operation.
-     * </p>
-     * 
-     * @param closeHandler A handler that is called back with the result of the attempt to close the links.
-     */
-    void close(Handler<AsyncResult<Void>> closeHandler);
-
-    /**
-     * Checks if this client's sender and receiver are (locally) open.
-     * 
-     * @return {@code true} if this client can be used to exchange messages with the peer.
-     */
-    boolean isOpen();
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
new file mode 100644
index 000000000..bb892136b
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/RequestResponseClient.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+package org.eclipse.hono.client;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Handler;
+
+/**
+ * Interface for common methods that all clients that follow the request response pattern need to implement.
+ */
+public interface RequestResponseClient {
+    /**
+     * Closes the AMQP link(s) with the Hono server this client is configured to use.
+     * <p>
+     * The underlying AMQP connection to the server is not affected by this operation.
+     * </p>
+     *
+     * @param closeHandler A handler that is called back with the result of the attempt to close the links.
+     */
+    void close(Handler<AsyncResult<Void>> closeHandler);
+
+    /**
+     * Checks if this client's sender and receiver are (locally) open.
+     *
+     * @return {@code true} if this client can be used to exchange messages with the peer.
+     */
+    boolean isOpen();
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 791ce1345..9d84e6091 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -12,8 +12,12 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.message.Message;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -103,4 +107,32 @@ public abstract class AbstractHonoClient {
             }
         });
     }
+
+    /**
+     * Set the application properties for a Proton Message but do a check for all properties first if they only contain
+     * values that the AMQP 1.0 spec allows.
+     *
+     * @param msg The Proton message. Must not be null.
+     * @param properties The map containing application properties.
+     * @throws NullPointerException if the message passed in is null.
+     * @throws IllegalArgumentException if the properties contain any value that AMQP 1.0 disallows.
+     */
+    protected final void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
+        if (properties != null) {
+
+            // check the three types not allowed by AMQP 1.0 spec for application properties (list, map and array)
+            for (final Map.Entry<String, ?> entry: properties.entrySet()) {
+                if (entry.getValue() instanceof List) {
+                    throw new IllegalArgumentException(String.format("Application property %s can't be a List", entry.getKey()));
+                } else if (entry.getValue() instanceof Map) {
+                    throw new IllegalArgumentException(String.format("Application property %s can't be a Map", entry.getKey()));
+                } else if (entry.getValue().getClass().isArray()) {
+                    throw new IllegalArgumentException(String.format("Application property %s can't be an Array", entry.getKey()));
+                }
+            }
+
+            final ApplicationProperties applicationProperties = new ApplicationProperties(properties);
+            msg.setApplicationProperties(applicationProperties);
+        }
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
new file mode 100644
index 000000000..539a01cc1
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -0,0 +1,216 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ * <p>
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * <p>
+ * Contributors:
+ * Bosch Software Innovations GmbH - initial creation
+ */
+package org.eclipse.hono.client.impl;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.json.JsonObject;
+import io.vertx.proton.*;
+import org.apache.qpid.proton.amqp.messaging.AmqpValue;
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.RequestResponseClient;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RequestResponseResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * A Vertx-Proton based parent class for the implementation of API clients that follow the request response pattern.
+ * The class is a generic that expects two classes:
+ *
+ * @param <C> denotes the concrete interface for the API
+ * @param <R> denotes the concrete result container class of the API
+ *
+ * <p>
+ * Both type parameter classes have their own parent and need to be subclassed.
+ *
+ * A subclass of this class only needs to implement some abstract helper methods (see the method descriptions) and their own
+ * API specific methods. This allows for implementation classes that focus on the API specific code.
+ */
+public abstract class AbstractRequestResponseClient<C extends RequestResponseClient, R extends RequestResponseResult>
+        extends AbstractHonoClient implements RequestResponseClient {
+
+    private static final Logger           LOG = LoggerFactory.getLogger(AbstractRequestResponseClient.class);
+    protected final AtomicLong            messageCounter  = new AtomicLong();
+    private final String                  requestResponseAddressTemplate;
+    private final String                  requestResponseReplyToAddressTemplate;
+
+    protected final Map<String, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
+    protected final String                replyToAddress;
+
+    /**
+     * Get the name of the endpoint that this client targets at.
+     *
+     * @return The name of the endpoint for this client.
+     */
+    protected abstract String getName();
+
+    /**
+     * Build a unique messageId for a request that serves as an identifier for a new message.
+     *
+     * @return The unique messageId;
+     */
+    protected abstract String createMessageId();
+
+    /**
+     * Creates a result object from the status and payload of a response received from the endpoint.
+     *
+     * @param status The status of the response.
+     * @param payload The json payload of the response.
+     * @return The result object.
+     */
+    protected abstract R getResult(final int status, final JsonObject payload);
+
+    /**
+     * Creates a client for a vert.x context.
+     *
+     * @param context The context to run all interactions with the server on.
+     */
+    protected AbstractRequestResponseClient(final Context context, final ProtonConnection con, final String tenantId,
+                                            final Handler<AsyncResult<C>> creationHandler) {
+
+        super(context);
+        requestResponseAddressTemplate        = String.format("%s/%%s",getName());
+        requestResponseReplyToAddressTemplate = String.format("%s/%%s/%%s",getName());
+        this.replyToAddress = String.format(
+                requestResponseReplyToAddressTemplate,
+                Objects.requireNonNull(tenantId),
+                UUID.randomUUID());
+
+        final Future<ProtonSender> senderTracker = Future.future();
+        senderTracker.setHandler(r -> {
+            if (r.succeeded()) {
+                LOG.debug("request response client created");
+                this.sender = r.result();
+                creationHandler.handle(Future.succeededFuture((C) this));
+            } else {
+                creationHandler.handle(Future.failedFuture(r.cause()));
+            }
+        });
+
+        final Future<ProtonReceiver> receiverTracker = Future.future();
+        context.runOnContext(create -> {
+            final ProtonReceiver receiver = con.createReceiver(replyToAddress);
+            receiver
+                    .setAutoAccept(true)
+                    .setPrefetch(DEFAULT_SENDER_CREDITS)
+                    .handler((delivery, message) -> {
+                        final Handler<AsyncResult<R>> handler = replyMap.remove(message.getCorrelationId());
+                        if (handler != null) {
+                            R result = getRequestResponseResult(message);
+                            LOG.debug("received response [correlation ID: {}, status: {}]",
+                                    message.getCorrelationId(), result.getStatus());
+                            handler.handle(Future.succeededFuture(result));
+                        } else {
+                            LOG.debug("discarding unexpected response [correlation ID: {}]",
+                                    message.getCorrelationId());
+                        }
+                    }).openHandler(receiverTracker.completer())
+                    .open();
+
+            receiverTracker.compose(openReceiver -> {
+                this.receiver = openReceiver;
+                ProtonSender sender = con.createSender(String.format(requestResponseAddressTemplate, tenantId));
+                sender
+                        .setQoS(ProtonQoS.AT_LEAST_ONCE)
+                        .openHandler(senderTracker.completer())
+                        .open();
+            }, senderTracker);
+        });
+    }
+
+    /**
+     * Build a Proton message with a provided subject (serving as the operation that shall be invoked).
+     * The message can be extended by arbitrary application properties passed in.
+     * <p>
+     * To enable specific message properties that are not considered here, the method can be overridden by subclasses.
+     *
+     * @param subject The subject system property of the message.
+     * @param appProperties The map containing arbitrary application properties.
+     *                      Maybe null if no application properties are needed.
+     * @return The Proton message constructed from the provided parameters.
+     * @throws IllegalArgumentException if the application properties contain not AMQP 1.0 compatible values
+     *                  (see {@link AbstractHonoClient#setApplicationProperties(Message, Map)}
+     */
+    protected Message createMessage(final String subject, final Map<String, Object> appProperties) {
+        final Message msg = ProtonHelper.message();
+        final String messageId = createMessageId();
+        setApplicationProperties(msg,appProperties);
+        msg.setReplyTo(replyToAddress);
+        msg.setMessageId(messageId);
+        msg.setSubject(subject);
+        return msg;
+    }
+
+
+    private R getRequestResponseResult(final Message message) {
+        final String status = MessageHelper.getApplicationProperty(
+                message.getApplicationProperties(),
+                MessageHelper.APP_PROPERTY_STATUS,
+                String.class);
+        final JsonObject payload = MessageHelper.getJsonPayload(message);
+        return getResult(Integer.valueOf(status), payload);
+    }
+
+    protected final void createAndSendRequest(final String action, final JsonObject payload,
+                                        final Handler<AsyncResult<R>> resultHandler) {
+        createAndSendRequest(action,null,payload,resultHandler);
+    }
+
+    protected final void createAndSendRequest(final String action, final Map<String, Object> properties, final JsonObject payload,
+                                      final Handler<AsyncResult<R>> resultHandler) {
+
+        final Message request = createMessage(action, properties);
+        if (payload != null) {
+            request.setContentType("application/json; charset=utf-8");
+            request.setBody(new AmqpValue(payload.encode()));
+        }
+        sendMessage(request, resultHandler);
+    }
+
+    /**
+     * Send the Proton message to the endpoint link and call the resultHandler later with the result object.
+     *
+     * @param request The Proton message that was fully prepared for sending.
+     * @param resultHandler The result handler to be called with the response and the status of the request.
+     */
+    // TODO: improve so that the available credits are checked. Wait for enough credits before sending first.
+    protected final void sendMessage(final Message request, final Handler<AsyncResult<R>> resultHandler) {
+
+        context.runOnContext(req -> {
+            replyMap.put((String) request.getMessageId(), resultHandler);
+            sender.send(request);
+        });
+    }
+
+    @Override
+    public final boolean isOpen() {
+        return sender != null && sender.isOpen() && receiver != null && receiver.isOpen();
+    }
+
+    @Override
+    public final void close(final Handler<AsyncResult<Void>> closeHandler) {
+
+        Objects.requireNonNull(closeHandler);
+        LOG.info("closing request response client ...");
+        closeLinks(closeHandler);
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 71b686dc5..615b7c5d2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -276,25 +276,6 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         // empty
     }
 
-    private void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
-        if (properties != null) {
-
-            // check the three types not allowed by AMQP 1.0 spec for application properties (list, map and array)
-            for (final Map.Entry<String, ?> entry: properties.entrySet()) {
-                if (entry.getValue() instanceof  List) {
-                    throw new IllegalArgumentException(String.format("Application property %s can't be a List", entry.getKey()));
-                } else if (entry.getValue() instanceof Map) {
-                    throw new IllegalArgumentException(String.format("Application property %s can't be a Map", entry.getKey()));
-                } else if (entry.getValue().getClass().isArray()) {
-                    throw new IllegalArgumentException(String.format("Application property %s can't be an Array", entry.getKey()));
-                }
-            }
-
-            final ApplicationProperties applicationProperties = new ApplicationProperties(properties);
-            msg.setApplicationProperties(applicationProperties);
-        }
-    }
-
     private Charset getCharsetForContentType(final String contentType) {
 
         final Matcher m = CHARSET_PATTERN.matcher(contentType);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
index 7905abc92..673b0ea27 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
@@ -22,6 +22,7 @@ import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.CredentialsClient;
+import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -38,73 +39,33 @@ import static org.eclipse.hono.util.MessageHelper.APP_PROPERTY_STATUS;
  * A Vertx-Proton based client for Hono's Credentials API.
  *
  */
-public final class CredentialsClientImpl extends AbstractHonoClient implements CredentialsClient {
+public final class CredentialsClientImpl extends AbstractRequestResponseClient<CredentialsClient, CredentialsResult> implements CredentialsClient {
 
-    private static final Logger                  LOG = LoggerFactory.getLogger(CredentialsClientImpl.class);
-    private static final String                  CREDENTIALS_ADDRESS_TEMPLATE = "credentials/%s";
-    private static final String                  CREDENTIALS_REPLY_TO_ADDRESS_TEMPLATE = "credentials/%s/%s";
+    private static final String                  CREDENTIALS_NAME = "credentials";
 
-    private final Map<String, Handler<AsyncResult<CredentialsResult>>> replyMap = new ConcurrentHashMap<>();
-    private final String                         credentialsReplyToAddress;
+    private static final Logger                  LOG = LoggerFactory.getLogger(CredentialsClientImpl.class);
 
     private CredentialsClientImpl(final Context context, final ProtonConnection con, final String tenantId,
                                   final Handler<AsyncResult<CredentialsClient>> creationHandler) {
+        super(context, con, tenantId, creationHandler);
+    }
 
-        super(context);
-        this.credentialsReplyToAddress = String.format(
-                CREDENTIALS_REPLY_TO_ADDRESS_TEMPLATE,
-                Objects.requireNonNull(tenantId),
-                UUID.randomUUID());
-
-        final Future<ProtonSender> senderTracker = Future.future();
-        senderTracker.setHandler(r -> {
-            if (r.succeeded()) {
-                LOG.debug("credentials client created");
-                this.sender = r.result();
-                creationHandler.handle(Future.succeededFuture(this));
-            } else {
-                creationHandler.handle(Future.failedFuture(r.cause()));
-            }
-        });
-
-        final Future<ProtonReceiver> receiverTracker = Future.future();
-        context.runOnContext(create -> {
-            final ProtonReceiver receiver = con.createReceiver(credentialsReplyToAddress);
-            receiver
-                    .setAutoAccept(true)
-                    .setPrefetch(DEFAULT_SENDER_CREDITS)
-                    .handler((delivery, message) -> {
-                        final Handler<AsyncResult<CredentialsResult>> handler = replyMap.remove(message.getCorrelationId());
-                        if (handler != null) {
-                            CredentialsResult result = getCredentialsResult(message);
-                            LOG.debug("received response [correlation ID: {}, status: {}]",
-                                    message.getCorrelationId(), result.getStatus());
-                            handler.handle(Future.succeededFuture(result));
-                        } else {
-                            LOG.info("discarding unexpected response [correlation ID: {}]",
-                                    message.getCorrelationId());
-                        }
-                    }).openHandler(receiverTracker.completer())
-                    .open();
-
-            receiverTracker.compose(openReceiver -> {
-                this.receiver = openReceiver;
-                ProtonSender sender = con.createSender(String.format(CREDENTIALS_ADDRESS_TEMPLATE, tenantId));
-                sender
-                        .setQoS(ProtonQoS.AT_LEAST_ONCE)
-                        .openHandler(senderTracker.completer())
-                        .open();
-            }, senderTracker);
-        });
+    @Override
+    protected String getName() {
+
+        return CREDENTIALS_NAME;
+    }
+
+    @Override
+    protected String createMessageId() {
+
+        return String.format("cred-client-%s", UUID.randomUUID());
     }
 
-    private static CredentialsResult getCredentialsResult(final Message message) {
-        final String status = MessageHelper.getApplicationProperty(
-                                                message.getApplicationProperties(),
-                                                APP_PROPERTY_STATUS,
-                                                String.class);
-        final JsonObject payload = MessageHelper.getJsonPayload(message);
-        return CredentialsResult.from(Integer.valueOf(status), payload);
+    @Override
+    protected CredentialsResult getResult(final int status, final JsonObject payload) {
+
+        return CredentialsResult.from(status, payload);
     }
 
     /**
@@ -125,55 +86,6 @@ public final class CredentialsClientImpl extends AbstractHonoClient implements C
                 Objects.requireNonNull(creationHandler));
     }
 
-    @Override
-    public boolean isOpen() {
-        return sender != null && sender.isOpen() && receiver != null && receiver.isOpen();
-    }
-
-
-    @Override
-    public void close(final Handler<AsyncResult<Void>> closeHandler) {
-
-        Objects.requireNonNull(closeHandler);
-        LOG.info("closing credentials client ...");
-        closeLinks(closeHandler);
-    }
-
-    private void createAndSendRequest(final String action, final JsonObject payload,
-                                      final Handler<AsyncResult<CredentialsResult>> resultHandler) {
-
-        final Message request = createMessage(null);
-        request.setSubject(action);
-        if (payload != null) {
-            request.setContentType("application/json; charset=utf-8");
-            request.setBody(new AmqpValue(payload.encode()));
-        }
-        sendMessage(request, resultHandler);
-    }
-
-    private void sendMessage(final Message request, final Handler<AsyncResult<CredentialsResult>> resultHandler) {
-
-        context.runOnContext(req -> {
-            replyMap.put((String) request.getMessageId(), resultHandler);
-            sender.send(request);
-        });
-    }
-
-    private Message createMessage(final Map<String, Object> appProperties) {
-        final Message msg = ProtonHelper.message();
-        final String messageId = createMessageId();
-        if (appProperties != null) {
-            msg.setApplicationProperties(new ApplicationProperties(appProperties));
-        }
-        msg.setReplyTo(credentialsReplyToAddress);
-        msg.setMessageId(messageId);
-        return msg;
-    }
-
-    private String createMessageId() {
-        return String.format("cred-client-%s", UUID.randomUUID());
-    }
-
     @Override
     public final void get(final String type, final String authId, final Handler<AsyncResult<CredentialsResult>> resultHandler) {
         JsonObject specification = new JsonObject().put(CredentialsConstants.FIELD_TYPE, type).put(CredentialsConstants.FIELD_AUTH_ID, authId);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
index 274bf6fba..521d0003a 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
@@ -17,102 +17,55 @@ import static org.eclipse.hono.util.RegistrationConstants.*;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
-import java.util.UUID;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.qpid.proton.amqp.messaging.AmqpValue;
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.RegistrationClient;
+import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RegistrationResult;
+import org.eclipse.hono.util.RequestResponseResult;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
-import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-import io.vertx.proton.ProtonSender;
 
 /**
  * A Vertx-Proton based client for Hono's Registration API.
  *
  */
-public final class RegistrationClientImpl extends AbstractHonoClient implements RegistrationClient {
+public final class RegistrationClientImpl extends AbstractRequestResponseClient<RegistrationClient, RegistrationResult> implements RegistrationClient {
 
     private static final Logger                  LOG = LoggerFactory.getLogger(RegistrationClientImpl.class);
-    private static final String                  REGISTRATION_ADDRESS_TEMPLATE = "registration/%s";
-    private static final String                  REGISTRATION_REPLY_TO_ADDRESS_TEMPLATE = "registration/%s/%s";
-
-    private final AtomicLong                     messageCounter  = new AtomicLong();
-    private final Map<String, Handler<AsyncResult<RegistrationResult>>> replyMap = new ConcurrentHashMap<>();
-    private final String                         registrationReplyToAddress;
+    private static final String                  REGISTRATION_NAME = "registration";
 
     private RegistrationClientImpl(final Context context, final ProtonConnection con, final String tenantId,
-            final Handler<AsyncResult<RegistrationClient>> creationHandler) {
+                                   final Handler<AsyncResult<RegistrationClient>> creationHandler) {
 
-        super(context);
-        this.registrationReplyToAddress = String.format(
-                REGISTRATION_REPLY_TO_ADDRESS_TEMPLATE,
-                Objects.requireNonNull(tenantId),
-                UUID.randomUUID());
-
-        final Future<ProtonSender> senderTracker = Future.future();
-        senderTracker.setHandler(r -> {
-            if (r.succeeded()) {
-                LOG.debug("registration client created");
-                this.sender = r.result();
-                creationHandler.handle(Future.succeededFuture(this));
-            } else {
-                creationHandler.handle(Future.failedFuture(r.cause()));
-            }
-        });
-
-        final Future<ProtonReceiver> receiverTracker = Future.future();
-        context.runOnContext(create -> {
-            final ProtonReceiver receiver = con.createReceiver(registrationReplyToAddress);
-            receiver
-                .setAutoAccept(true)
-                .setPrefetch(DEFAULT_SENDER_CREDITS)
-                .handler((delivery, message) -> {
-                    final Handler<AsyncResult<RegistrationResult>> handler = replyMap.remove(message.getCorrelationId());
-                    if (handler != null) {
-                        RegistrationResult result = getRegistrationResult(message);
-                        LOG.debug("received response [correlation ID: {}, status: {}]",
-                                message.getCorrelationId(), result.getStatus());
-                        handler.handle(Future.succeededFuture(result));
-                    } else {
-                        LOG.debug("discarding unexpected response [correlation ID: {}]",
-                                message.getCorrelationId());
-                    }
-                }).openHandler(receiverTracker.completer())
-                .open();
-
-            receiverTracker.compose(openReceiver -> {
-                this.receiver = openReceiver;
-                ProtonSender sender = con.createSender(String.format(REGISTRATION_ADDRESS_TEMPLATE, tenantId));
-                sender
-                    .setQoS(ProtonQoS.AT_LEAST_ONCE)
-                    .openHandler(senderTracker.completer())
-                    .open();
-            }, senderTracker);
-        });
+        super(context,con,tenantId,creationHandler);
+    }
+
+
+    @Override
+    protected String getName() {
+
+        return REGISTRATION_NAME;
     }
 
-    private static RegistrationResult getRegistrationResult(final Message message) {
-        final String status = MessageHelper.getApplicationProperty(
-                                                message.getApplicationProperties(),
-                                                MessageHelper.APP_PROPERTY_STATUS,
-                                                String.class);
-        final JsonObject payload = MessageHelper.getJsonPayload(message);
-        return RegistrationResult.from(Integer.valueOf(status), payload);
+    @Override
+    protected String createMessageId() {
+
+        return String.format("reg-client-%d", messageCounter.getAndIncrement());
+    }
+
+    @Override
+    protected RegistrationResult getResult(final int status, final JsonObject payload) {
+
+        return RegistrationResult.from(status,payload);
     }
 
     /**
@@ -134,89 +87,46 @@ public final class RegistrationClientImpl extends AbstractHonoClient implements
                 Objects.requireNonNull(creationHandler));
     }
 
-    @Override
-    public boolean isOpen() {
-        return sender != null && sender.isOpen() && receiver != null && receiver.isOpen();
-    }
-
-    @Override
-    public void close(final Handler<AsyncResult<Void>> closeHandler) {
-
-        Objects.requireNonNull(closeHandler);
-        LOG.info("closing registration client ...");
-        closeLinks(closeHandler);
-    }
-
-    private void createAndSendRequest(final String action, final String deviceId, final JsonObject payload,
-            final Handler<AsyncResult<RegistrationResult>> resultHandler) {
-
+    private Map<String, Object> createDeviceIdProperties(final String deviceId) {
         final Map<String, Object> properties = new HashMap<>();
         properties.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);
-        final Message request = createMessage(action, properties);
-        if (payload != null) {
-            request.setContentType("application/json; charset=utf-8");
-            request.setBody(new AmqpValue(payload.encode()));
-        }
-        sendMessage(request, resultHandler);
-    }
-
-    private void sendMessage(final Message request, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
-
-        context.runOnContext(req -> {
-            replyMap.put((String) request.getMessageId(), resultHandler);
-            sender.send(request);
-        });
-    }
-
-    private Message createMessage(final String action, final Map<String, Object> appProperties) {
-        final Message msg = ProtonHelper.message();
-        final String messageId = createMessageId();
-        msg.setApplicationProperties(new ApplicationProperties(appProperties));
-        msg.setReplyTo(registrationReplyToAddress);
-        msg.setMessageId(messageId);
-        msg.setSubject(action);
-        return msg;
-    }
-
-    private String createMessageId() {
-        return String.format("reg-client-%d", messageCounter.getAndIncrement());
+        return properties;
     }
 
     @Override
     public void register(final String deviceId, final JsonObject data, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
 
-        createAndSendRequest(ACTION_REGISTER, deviceId, data, resultHandler);
+        createAndSendRequest(ACTION_REGISTER, createDeviceIdProperties(deviceId), data, resultHandler);
     }
 
     @Override
     public void update(final String deviceId, final JsonObject data, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
 
-        createAndSendRequest(ACTION_UPDATE, deviceId, data, resultHandler);
+        createAndSendRequest(ACTION_UPDATE, createDeviceIdProperties(deviceId), data, resultHandler);
     }
 
     @Override
     public void deregister(final String deviceId, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
 
-        createAndSendRequest(ACTION_DEREGISTER, deviceId, null, resultHandler);
+        createAndSendRequest(ACTION_DEREGISTER, createDeviceIdProperties(deviceId), null, resultHandler);
     }
 
     @Override
     public void get(final String deviceId, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
 
-        createAndSendRequest(ACTION_GET, deviceId, null, resultHandler);
+        createAndSendRequest(ACTION_GET, createDeviceIdProperties(deviceId), null, resultHandler);
     }
 
     @Override
     public void assertRegistration(final String deviceId, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
 
-        createAndSendRequest(ACTION_ASSERT, deviceId, null, resultHandler);
+        createAndSendRequest(ACTION_ASSERT, createDeviceIdProperties(deviceId), null, resultHandler);
     }
 
     @Override
     public void find(final String key, final String value, final Handler<AsyncResult<RegistrationResult>> resultHandler) {
 
-        final Map<String, Object> properties = new HashMap<>();
-        properties.put(MessageHelper.APP_PROPERTY_DEVICE_ID, value);
+        final Map<String, Object> properties = createDeviceIdProperties(value);
         properties.put(APP_PROPERTY_KEY, key);
         sendMessage(createMessage(ACTION_FIND, properties), resultHandler);
     }
