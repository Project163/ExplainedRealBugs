diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 3b2032a1f..6208c5c73 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -117,7 +117,7 @@ public final class HonoClientImpl implements HonoClient {
         Map<String, Object> result = new HashMap<>();
         result.put("name", connectionFactory.getName());
         result.put("connected", isConnected());
-        result.put("Hono server", String.format("%s:%d", connectionFactory.getHost(), connectionFactory.getPort()));
+        result.put("server", String.format("%s:%d", connectionFactory.getHost(), connectionFactory.getPort()));
         result.put("#regClients", activeRegClients.size());
         result.put("senders", getSenderStatus());
         return result;
@@ -181,7 +181,7 @@ public final class HonoClientImpl implements HonoClient {
                         }
                     });
         } else {
-            LOG.debug("already trying to connect to Hono server ...");
+            LOG.debug("already trying to connect to server ...");
         }
         return this;
     }
@@ -194,7 +194,7 @@ public final class HonoClientImpl implements HonoClient {
             LOG.debug("scheduling re-connect attempt ...");
             // give Vert.x some time to clean up NetClient
             vertx.setTimer(Constants.DEFAULT_RECONNECT_INTERVAL_MILLIS, tid -> {
-                LOG.info("attempting to re-connect to Hono server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+                LOG.info("attempting to re-connect to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
                 connect(clientOptions, connectionHandler);
             });
         }
@@ -202,7 +202,7 @@ public final class HonoClientImpl implements HonoClient {
 
     private void onRemoteClose(final AsyncResult<ProtonConnection> remoteClose) {
         if (remoteClose.failed()) {
-            LOG.info("Hono server [{}:{}] closed connection with error condition: {}",
+            LOG.info("remote server [{}:{}] closed connection with error condition: {}",
                     connectionFactory.getHost(), connectionFactory.getPort(), remoteClose.cause().getMessage());
         }
         connection.close();
@@ -214,7 +214,7 @@ public final class HonoClientImpl implements HonoClient {
         if (con != connection) {
             LOG.warn("cannot handle failure of unknown connection");
         } else {
-            LOG.info("lost connection to Hono server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+            LOG.info("lost connection to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
             connection.disconnect();
             activeSenders.clear();
             activeRegClients.clear();
@@ -296,6 +296,8 @@ public final class HonoClientImpl implements HonoClient {
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
             final Handler<Void> connectionFailureHandler = connectionLost -> {
+                // remove lock so that next attempt to open a sender doesn't fail
+                senderCreationLocks.remove(key);
                 resultHandler.handle(Future.failedFuture("connection to server lost"));
             };
             creationRequests.add(connectionFailureHandler);
@@ -412,7 +414,7 @@ public final class HonoClientImpl implements HonoClient {
 
     private Future<ProtonConnection> checkConnection() {
         if (connection == null || connection.isDisconnected()) {
-            return Future.failedFuture("client is not connected to Hono (yet)");
+            return Future.failedFuture("client is not connected to server (yet)");
         } else {
             return Future.succeededFuture(connection);
         }
@@ -446,7 +448,7 @@ public final class HonoClientImpl implements HonoClient {
 
         Objects.requireNonNull(tenantId);
         if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
+            creationHandler.handle(Future.failedFuture("client is not connected to server (yet)"));
         } else {
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
@@ -493,7 +495,7 @@ public final class HonoClientImpl implements HonoClient {
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(creationHandler);
         if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
+            creationHandler.handle(Future.failedFuture("client is not connected to server (yet)"));
         } else {
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 0c23bb711..5167ee35c 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -189,6 +189,47 @@ public class HonoClientImplTest {
         disconnected.await(200);
     }
 
+    /**
+     * Verifies that all sender creation locks are cleared when the connection to the server fails.
+     * 
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testDownstreamDisconnectClearsSenderCreationLocks(final TestContext ctx) {
+
+        final ProtonConnection connectionToCreate = mock(ProtonConnection.class);
+        when(connectionToCreate.getRemoteContainer()).thenReturn("server");
+        // expect the connection factory to be invoked twice
+        // first on initial connection
+        // second on reconnect
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(connectionToCreate, 2);
+
+        // GIVEN a client connected to a server
+        final Async connected = ctx.async();
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await(200);
+
+        final Async senderCreationFailure = ctx.async();
+        // WHEN the downstream connection fails just when the client wants to open a sender link
+        client.getOrCreateSender("telemetry/tenant", creationAttemptHandler -> {
+            connectionFactory.getDisconnectHandler().handle(connectionToCreate);
+            // the creationAttempHandler will not be invoked at all
+        }, ctx.asyncAssertFailure(cause -> senderCreationFailure.complete()));
+
+        // THEN the sender creation fails,
+        senderCreationFailure.await(1000);
+        // the connection is re-established
+        connectionFactory.await(1, TimeUnit.SECONDS);
+        // and the next attempt to create a sender succeeds
+        final Async senderSupplierInvocation = ctx.async();
+        client.getOrCreateSender("telemetry/tenant", creationAttemptHandler -> {
+            senderSupplierInvocation.complete();
+            creationAttemptHandler.handle(Future.succeededFuture(mock(MessageSender.class)));
+        }, ctx.asyncAssertSuccess());
+        senderSupplierInvocation.await(1000);
+    }
+
     /**
      * Verifies that the client tries to re-establish a lost connection to a server.
      * 
