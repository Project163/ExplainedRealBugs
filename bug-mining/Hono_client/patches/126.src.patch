diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 9ef64ecdf..e3f2beeab 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -31,6 +31,8 @@ import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
+import javax.security.sasl.AuthenticationException;
+
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.cache.CacheProvider;
@@ -65,6 +67,7 @@ import io.vertx.core.Vertx;
 import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.sasl.SaslSystemException;
 
 /**
  * A helper class for creating Vert.x based clients for Hono's arbitrary APIs.
@@ -388,7 +391,11 @@ public class HonoClientImpl implements HonoClient {
                         conAttempt -> {
                             connecting.compareAndSet(true, false);
                             if (conAttempt.failed()) {
-                                reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
+                                if (isConnectionFailureEntailingReconnectAttempt(conAttempt.cause())) {
+                                    reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
+                                } else {
+                                    failConnectionAttempt(conAttempt.cause(), connectionHandler);
+                                }
                             } else {
                                 final ProtonConnection newConnection = conAttempt.result();
                                 if (shuttingDown.get()) {
@@ -497,18 +504,7 @@ public class HonoClientImpl implements HonoClient {
             log.debug("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
                     clientConfigProperties.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
             clearState();
-            if (connectionFailureCause == null) {
-                connectionHandler.handle(Future.failedFuture(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
-            } else if (connectionFailureCause instanceof SecurityException) {
-                // SASL handshake failed continuously, maybe due to wrong credentials?
-                connectionHandler.handle(Future.failedFuture(
-                        new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED, "failed to authenticate with server")));
-            } else {
-                connectionHandler.handle(Future.failedFuture(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect",
-                                connectionFailureCause)));
-            }
+            failConnectionAttempt(connectionFailureCause, connectionHandler);
 
         } else {
             if (connectionFailureCause != null) {
@@ -525,6 +521,33 @@ public class HonoClientImpl implements HonoClient {
         }
     }
 
+    private boolean isConnectionFailureEntailingReconnectAttempt(final Throwable connectionFailureCause) {
+        if (connectionFailureCause instanceof AuthenticationException
+            || (connectionFailureCause instanceof SaslSystemException && ((SaslSystemException) connectionFailureCause).isPermanent())) {
+            return false;
+        }
+        return true;
+    }
+
+    private void failConnectionAttempt(final Throwable connectionFailureCause, final Handler<AsyncResult<HonoClient>> connectionHandler) {
+        if (connectionFailureCause == null) {
+            connectionHandler.handle(Future.failedFuture(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
+        } else if (connectionFailureCause instanceof AuthenticationException) {
+            // SASL handshake failed continuously, maybe due to wrong credentials?
+            connectionHandler.handle(Future.failedFuture(
+                    new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED, "failed to authenticate with server")));
+        } else if (connectionFailureCause instanceof SaslSystemException
+                && connectionFailureCause.getMessage().contains("Could not find a suitable SASL mechanism")) { // this check will have to be changed when using a future vert.x version where an AuthenticationException is thrown in this case
+            connectionHandler.handle(Future.failedFuture(
+                    new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED, "no suitable SASL mechanism found for authentication with server")));
+        } else {
+            connectionHandler.handle(Future.failedFuture(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect",
+                            connectionFailureCause)));
+        }
+    }
+
     /**
      * {@inheritDoc}
      */
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index fafedb9e9..9a2ed1ab4 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -24,6 +24,8 @@ import static org.mockito.Mockito.when;
 import java.net.HttpURLConnection;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import javax.security.sasl.AuthenticationException;
+
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.RegistrationClient;
@@ -49,6 +51,7 @@ import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
 import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.sasl.SaslSystemException;
 
 /**
  * Test cases verifying the behavior of {@code HonoClient}.
@@ -121,20 +124,20 @@ public class HonoClientImplTest {
     }
 
     /**
-     * Verifies that the client fails with a ClientErrorException with status code 403
-     * if it cannot authenticate to the server.
+     * Verifies that the client fails with a ClientErrorException with status code 401
+     * if it cannot authenticate to the server due to wrong credentials.
      * 
      * @param ctx The vert.x test client.
      */
     @Test
-    public void testConnectFailsWithClientErrorForSecurityException(final TestContext ctx) {
+    public void testConnectFailsWithClientErrorForAuthenticationException(final TestContext ctx) {
 
         // GIVEN a client that is configured to connect
-        // to a peer using invalid credentials
+        // to a peer that always throws an AuthenticationException
         props.setReconnectAttempts(2);
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
-                .setExpectedFailingConnectionAttempts(3)
-                .failWith(new SecurityException("invalid credentials"));
+                .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
+                .failWith(new AuthenticationException("Failed to authenticate"));
         client = new HonoClientImpl(vertx, connectionFactory, props);
         final ProtonClientOptions options = new ProtonClientOptions()
                 .setConnectTimeout(10)
@@ -150,6 +153,97 @@ public class HonoClientImplTest {
         assertTrue(connectionFactory.awaitFailure());
     }
 
+    /**
+     * Verifies that the client fails with a ClientErrorException with status code 401
+     * if it cannot authenticate to the server because no suitable SASL mechanism was found.
+     * 
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testConnectFailsWithClientErrorForNoSASLMechanismException(final TestContext ctx) {
+
+        // GIVEN a client that is configured to connect
+        // to a peer that always throws a SaslSystemException (as if no credentials were given)
+        props.setReconnectAttempts(2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
+                .failWith(new SaslSystemException(true, "Could not find a suitable SASL mechanism for the remote peer using the available credentials."));
+        client = new HonoClientImpl(vertx, connectionFactory, props);
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setConnectTimeout(10)
+                .setReconnectAttempts(0)
+                .setReconnectInterval(50);
+
+        // WHEN the client tries to connect
+        client.connect(options).setHandler(ctx.asyncAssertFailure(t -> {
+            // THEN the connection attempt fails due do lack of authorization
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAUTHORIZED, ((ServiceInvocationException) t).getErrorCode());
+            ctx.assertEquals("no suitable SASL mechanism found for authentication with server", t.getMessage());
+        }));
+        // and the client has indeed tried three times in total
+        assertTrue(connectionFactory.awaitFailure());
+    }
+
+    /**
+     * Verifies that the client fails with a ServerErrorException with status code 503
+     * if it cannot authenticate to the server because of a transient error.
+     *
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testConnectFailsWithClientErrorForTransientSaslSystemException(final TestContext ctx) {
+
+        // GIVEN a client that is configured to connect
+        // to a peer that always throws a SaslSystemException with permanent=false
+        props.setReconnectAttempts(2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(3)
+                .failWith(new SaslSystemException(false, "SASL handshake failed due to a transient error"));
+        client = new HonoClientImpl(vertx, connectionFactory, props);
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setConnectTimeout(10)
+                .setReconnectAttempts(0)
+                .setReconnectInterval(50);
+
+        // WHEN the client tries to connect
+        client.connect(options).setHandler(ctx.asyncAssertFailure(t -> {
+            // THEN the connection attempt fails
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServiceInvocationException) t).getErrorCode());
+        }));
+        // and the client has indeed tried three times in total
+        assertTrue(connectionFactory.awaitFailure());
+    }
+
+    /**
+     * Verifies that the client fails with a ServerErrorException with status code 503
+     * if it cannot authenticate to the server because of a permanent error.
+     *
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testConnectFailsWithClientErrorForPermanentSaslSystemException(final TestContext ctx) {
+
+        // GIVEN a client that is configured to connect
+        // to a peer that always throws a SaslSystemException with permanent=true
+        props.setReconnectAttempts(2);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con)
+                .setExpectedFailingConnectionAttempts(1) // only one connection attempt expected here
+                .failWith(new SaslSystemException(true, "SASL handshake failed due to an unrecoverable error"));
+        client = new HonoClientImpl(vertx, connectionFactory, props);
+        final ProtonClientOptions options = new ProtonClientOptions()
+                .setConnectTimeout(10)
+                .setReconnectAttempts(0)
+                .setReconnectInterval(50);
+
+        // WHEN the client tries to connect
+        client.connect(options).setHandler(ctx.asyncAssertFailure(t -> {
+            // THEN the connection attempt fails
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServiceInvocationException) t).getErrorCode());
+        }));
+        // and the client has indeed tried three times in total
+        assertTrue(connectionFactory.awaitFailure());
+    }
+
     /**
      * Verifies that a request to create a request-response client fails the given
      * future for tracking the attempt if the client is not connected to the peer.
