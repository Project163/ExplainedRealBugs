diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java
index 4b5ebef56..97d1297c3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractConsumer.java
@@ -14,21 +14,13 @@ package org.eclipse.hono.client.impl;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
-import io.vertx.core.Future;
 import io.vertx.core.Handler;
-import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
-import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.Objects;
-import java.util.function.BiConsumer;
-
 /**
  * Abstract client for consuming messages from a Hono server.
  */
@@ -42,7 +34,7 @@ abstract class AbstractConsumer extends AbstractHonoClient implements MessageCon
     }
 
     @Override
-    public void flow(final int credits) {
+    public void flow(final int credits) throws IllegalStateException {
         receiver.flow(credits);
     }
 
@@ -51,56 +43,4 @@ abstract class AbstractConsumer extends AbstractHonoClient implements MessageCon
         closeLinks(closeHandler);
     }
 
-    static Future<ProtonReceiver> createConsumer(
-            final Context context,
-            final ClientConfigProperties clientConfig,
-            final ProtonConnection con,
-            final String tenantId,
-            final String pathSeparator,
-            final String address,
-            final ProtonQoS qos,
-            final BiConsumer<ProtonDelivery, Message> consumer) {
-
-        Objects.requireNonNull(context);
-        Objects.requireNonNull(clientConfig);
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(pathSeparator);
-        Objects.requireNonNull(address);
-        Objects.requireNonNull(qos);
-
-        final Future<ProtonReceiver> result = Future.future();
-        final String targetAddress = String.format(address, pathSeparator, tenantId);
-
-        context.runOnContext(open -> {
-            final ProtonReceiver receiver = con.createReceiver(targetAddress);
-            receiver.setAutoAccept(true);
-            receiver.setPrefetch(clientConfig.getInitialCredits());
-            receiver.setQoS(qos);
-            receiver.handler((delivery, message) -> {
-                if (consumer != null) {
-                    consumer.accept(delivery, message);
-                }
-                if (LOG.isTraceEnabled()) {
-                    int remainingCredits = receiver.getCredit() - receiver.getQueued();
-                    LOG.trace("handling message [remotely settled: {}, queued messages: {}, remaining credit: {}]",
-                            delivery.remotelySettled(), receiver.getQueued(), remainingCredits);
-                }
-            });
-            receiver.openHandler(receiverOpen -> {
-                if (receiverOpen.succeeded()) {
-                    LOG.debug("receiver [source: {}, qos: {}] open", receiver.getRemoteSource(), receiver.getRemoteQoS());
-                    if (qos.equals(ProtonQoS.AT_LEAST_ONCE) && !qos.equals(receiver.getRemoteQoS())) {
-                        LOG.info("remote container uses other QoS than requested [requested: {}, in use: {}]",
-                                qos, receiver.getRemoteQoS());
-                    }
-                    result.complete(receiver);
-                } else {
-                    result.fail(receiverOpen.cause());
-                }
-            });
-            receiver.open();
-        });
-        return result;
-    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 76228e67f..02c41ce2e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -249,8 +249,29 @@ public abstract class AbstractHonoClient {
             receiver.setAutoAccept(true);
             receiver.setQoS(qos);
             receiver.setPrefetch(clientConfig.getInitialCredits());
-            receiver.handler(messageHandler);
-            receiver.openHandler(result.completer());
+            receiver.handler((delivery, message) -> {
+                messageHandler.handle(delivery, message);
+                if (LOG.isTraceEnabled()) {
+                    int remainingCredits = receiver.getCredit() - receiver.getQueued();
+                    LOG.trace("handling message [remotely settled: {}, queued messages: {}, remaining credit: {}]", delivery.remotelySettled(), receiver.getQueued(), remainingCredits);
+                }
+            });
+            receiver.openHandler(openAttach -> {
+                if(openAttach.failed()) {
+                    result.fail(openAttach.cause());
+                    LOG.debug("receiver open attach failed [{}] by peer [{}]: {}", receiver.getRemoteSource(), con.getRemoteContainer(), openAttach.cause().getMessage());
+                }
+                else {
+                    result.complete(openAttach.result());
+                }
+            });
+            receiver.detachHandler(remoteDetached -> {
+                if (remoteDetached.succeeded()) {
+                    LOG.debug("receiver [{}] detached (with closed=false) by peer [{}]", receiver.getRemoteSource(), con.getRemoteContainer());
+                } else {
+                    LOG.debug("receiver [{}] detached (with closed=false) by peer [{}]: {}", receiver.getRemoteSource(), con.getRemoteContainer(), remoteDetached.cause().getMessage());
+                }
+            });
             receiver.closeHandler(remoteClosed -> {
                 if (remoteClosed.succeeded()) {
                     LOG.debug("receiver [{}] closed by peer [{}]", sourceAddress, con.getRemoteContainer());
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
index df5cb7bd3..bde596dec 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventConsumerImpl.java
@@ -13,14 +13,6 @@
 
 package org.eclipse.hono.client.impl;
 
-import java.util.Objects;
-import java.util.function.BiConsumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.util.Constants;
-
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
@@ -29,13 +21,21 @@ import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.EventConstants;
+
+import java.util.Objects;
+import java.util.function.BiConsumer;
 
 /**
  * A Vertx-Proton based client for consuming event messages from a Hono server.
  */
 public class EventConsumerImpl extends AbstractConsumer implements MessageConsumer {
 
-    private static final String EVENT_ADDRESS_TEMPLATE = "event%s%s";
+    private static final String EVENT_ADDRESS_TEMPLATE = EventConstants.EVENT_ENDPOINT + "%s%s";
 
     private EventConsumerImpl(final Context context, final ClientConfigProperties config, final ProtonReceiver receiver) {
         super(context, config, receiver);
@@ -91,7 +91,9 @@ public class EventConsumerImpl extends AbstractConsumer implements MessageConsum
         Objects.requireNonNull(pathSeparator);
         Objects.requireNonNull(eventConsumer);
         Objects.requireNonNull(creationHandler);
-        createConsumer(context, clientConfig, con, tenantId, pathSeparator, EVENT_ADDRESS_TEMPLATE, ProtonQoS.AT_LEAST_ONCE, eventConsumer).setHandler(created -> {
+
+        createReceiver(context, clientConfig, con, String.format(EVENT_ADDRESS_TEMPLATE, pathSeparator, tenantId),
+                ProtonQoS.AT_LEAST_ONCE, eventConsumer::accept, null).setHandler(created -> {
             if (created.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(
                         new EventConsumerImpl(context, clientConfig, created.result())));
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
index 38c2a6076..73fad01d3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetryConsumerImpl.java
@@ -12,14 +12,6 @@
 
 package org.eclipse.hono.client.impl;
 
-import java.util.Objects;
-import java.util.function.Consumer;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.util.Constants;
-
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
@@ -27,13 +19,21 @@ import io.vertx.core.Handler;
 import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.TelemetryConstants;
+
+import java.util.Objects;
+import java.util.function.Consumer;
 
 /**
  * A Vertx-Proton based client for consuming telemetry data from a Hono server.
  */
 public class TelemetryConsumerImpl extends AbstractConsumer implements MessageConsumer {
 
-    private static final String TELEMETRY_ADDRESS_TEMPLATE  = "telemetry%s%s";
+    private static final String TELEMETRY_ADDRESS_TEMPLATE  = TelemetryConstants.TELEMETRY_ENDPOINT + "%s%s";
 
     private TelemetryConsumerImpl(final Context context, final ClientConfigProperties config, final ProtonReceiver receiver) {
         super(context, config, receiver);
@@ -90,8 +90,8 @@ public class TelemetryConsumerImpl extends AbstractConsumer implements MessageCo
         Objects.requireNonNull(telemetryConsumer);
         Objects.requireNonNull(creationHandler);
 
-        createConsumer(context, clientConfig, con, tenantId, pathSeparator, TELEMETRY_ADDRESS_TEMPLATE, ProtonQoS.AT_LEAST_ONCE,
-                (protonDelivery, message) -> telemetryConsumer.accept(message)).setHandler(created -> {
+        createReceiver(context, clientConfig, con, String.format(TELEMETRY_ADDRESS_TEMPLATE, pathSeparator, tenantId), ProtonQoS.AT_LEAST_ONCE,
+                (delivery, message) -> telemetryConsumer.accept(message), null).setHandler(created -> {
                     if (created.succeeded()) {
                         creationHandler.handle(Future.succeededFuture(
                                 new TelemetryConsumerImpl(context, clientConfig, created.result())));
