diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
new file mode 100644
index 000000000..dce813461
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
@@ -0,0 +1,67 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.json.JsonObject;
+
+/**
+ * A client for accessing Hono's Device Connection API.
+ * <p>
+ * An instance of this interface is always scoped to a specific tenant.
+ * <p>
+ * See Hono's <a href="https://www.eclipse.org/hono/api/device-connection-api/">
+ * Device Connection API specification</a> for a description of the result codes returned.
+ */
+public interface DeviceConnectionClient extends RequestResponseClient {
+
+    /**
+     * Sets the given gateway as the last gateway that acted on behalf of the given device.
+     * <p>
+     * If a device connects directly instead of through a gateway, the device identifier itself is to be used as value
+     * for the <em>gatewayId</em> parameter.
+     *
+     * @param deviceId The device id.
+     * @param gatewayId The gateway id (or the device id if the last message came from the device directly).
+     * @param context The currently active OpenTracing span or {@code null} if no span is currently active.
+     *            An implementation should use this as the parent for any span it creates for tracing
+     *            the execution of this operation.
+     * @return A future indicating whether the operation succeeded or not.
+     * @throws NullPointerException if device id or gateway id is {@code null}.
+     */
+    Future<Void> setLastKnownGatewayForDevice(String deviceId, String gatewayId, SpanContext context);
+
+    /**
+     * Gets the gateway that last acted on behalf of the given device.
+     * <p>
+     * If no last known gateway has been set for the given device yet, a failed future with status <em>Not Found</em>
+     * is returned.
+     *
+     * @param deviceId The device id.
+     * @param context The currently active OpenTracing span or {@code null} if no span is currently active.
+     *            An implementation should use this as the parent for any span it creates for tracing
+     *            the execution of this operation.
+     * @return A future indicating the result of the operation.
+     *         <p>
+     *         The future will succeed if a response with status 200 has been received from the device connection service.
+     *         In that case the value of the future will contain a <em>gateway-id</em> property with the
+     *         gateway id.
+     *         <p>
+     *         In case a status other then 200 is received, the future will fail with a
+     *         {@link ServiceInvocationException} containing the (error) status code returned by the service.
+     * @throws NullPointerException if device id is {@code null}.
+     */
+    Future<JsonObject> getLastKnownGatewayForDevice(String deviceId, SpanContext context);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
new file mode 100644
index 000000000..aaeb7c1f8
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
@@ -0,0 +1,217 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.net.HttpURLConnection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.DeviceConnectionClient;
+import org.eclipse.hono.client.StatusCodeMapper;
+import org.eclipse.hono.util.CacheDirective;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.DeviceConnectionResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.buffer.Buffer;
+import io.vertx.core.json.DecodeException;
+import io.vertx.core.json.JsonObject;
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * A Vertx-Proton based client for Hono's Device Connection API.
+ *
+ */
+public class DeviceConnectionClientImpl extends AbstractRequestResponseClient<DeviceConnectionResult> implements DeviceConnectionClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DeviceConnectionClientImpl.class);
+
+    /**
+     * Creates a new client for accessing the Device Connection service.
+     * <p>
+     * The client will be ready to use after invoking {@link #createLinks()} or
+     * {@link #createLinks(Handler, Handler)} only.
+     *
+     * @param connection The connection to the Device Connection service.
+     * @param tenantId The identifier of the tenant for which the client should be created.
+     */
+    protected DeviceConnectionClientImpl(final HonoConnection connection, final String tenantId) {
+        super(connection, tenantId);
+    }
+
+    /**
+     * Creates a new client for accessing the Device Connection service.
+     *
+     * @param connection The connection to the Device Connection service.
+     * @param tenantId The identifier of the tenant for which the client should be created.
+     * @param sender The AMQP link to use for sending requests to the service.
+     * @param receiver The AMQP link to use for receiving responses from the service.
+     */
+    protected DeviceConnectionClientImpl(
+            final HonoConnection connection,
+            final String tenantId,
+            final ProtonSender sender,
+            final ProtonReceiver receiver) {
+
+        super(connection, tenantId, sender, receiver);
+    }
+
+    /**
+     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Device Connection API endpoint.
+     * 
+     * @param tenantId The tenant to upload data for.
+     * @return The target address.
+     * @throws NullPointerException if tenant is {@code null}.
+     */
+    public static final String getTargetAddress(final String tenantId) {
+        return String.format("%s/%s", DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT, Objects.requireNonNull(tenantId));
+    }
+
+    @Override
+    protected final String getName() {
+
+        return DeviceConnectionConstants.DEVICE_CONNECTION_ENDPOINT;
+    }
+
+    @Override
+    protected final String createMessageId() {
+
+        return String.format("%s-%s", DeviceConnectionConstants.MESSAGE_ID_PREFIX, UUID.randomUUID());
+    }
+
+    @Override
+    protected final DeviceConnectionResult getResult(
+            final int status,
+            final String contentType,
+            final Buffer payload,
+            final CacheDirective cacheDirective,
+            final ApplicationProperties applicationProperties) {
+
+        if (payload == null) {
+            return DeviceConnectionResult.from(status, null, null, applicationProperties);
+        } else {
+            try {
+                // ignoring given cacheDirective param here - device connection results shall not be cached
+                return DeviceConnectionResult.from(status, new JsonObject(payload), CacheDirective.noCacheDirective(), applicationProperties);
+            } catch (final DecodeException e) {
+                LOG.warn("received malformed payload from Device Connection service", e);
+                return DeviceConnectionResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR, null, null, applicationProperties);
+            }
+        }
+    }
+
+    /**
+     * Creates a new device connection client for a tenant.
+     * 
+     * @param con The connection to the server.
+     * @param tenantId The tenant to consumer events for.
+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
+     * @return A future indicating the outcome of the creation attempt.
+     * @throws NullPointerException if any of the parameters other than cache provider is {@code null}.
+     */
+    public static final Future<DeviceConnectionClient> create(
+            final HonoConnection con,
+            final String tenantId,
+            final Handler<String> senderCloseHook,
+            final Handler<String> receiverCloseHook) {
+
+        LOG.debug("creating new device connection client for [{}]", tenantId);
+        final DeviceConnectionClientImpl client = new DeviceConnectionClientImpl(con, tenantId);
+        // no response cache being set on client here - device connection results shall not be cached
+        return client.createLinks(senderCloseHook, receiverCloseHook)
+                .map(ok -> {
+                    LOG.debug("successfully created device connection client for [{}]", tenantId);
+                    return (DeviceConnectionClient) client;
+                }).recover(t -> {
+                    LOG.debug("failed to create device connection client for [{}]", tenantId, t);
+                    return Future.failedFuture(t);
+                });
+    }
+
+    private Map<String, Object> createDeviceIdProperties(final String deviceId) {
+        final Map<String, Object> properties = new HashMap<>();
+        properties.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);
+        return properties;
+    }
+
+    /**
+     * Invokes the <em>Set Last Known Gateway for Device</em> operation of Hono's
+     * <a href="https://www.eclipse.org/hono/api/device-connection-api">Device Connection API</a>
+     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
+     */
+    @Override
+    public Future<Void> setLastKnownGatewayForDevice(final String deviceId, final String gatewayId, final SpanContext context) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(gatewayId);
+
+        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
+        properties.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);
+
+        final Future<DeviceConnectionResult> resultTracker = Future.future();
+        createAndSendRequest(
+                DeviceConnectionConstants.DeviceConnectionAction.SET_LAST_GATEWAY.getSubject(),
+                properties,
+                null,
+                resultTracker,
+                null,
+                context);
+        return resultTracker.map(result -> {
+            switch (result.getStatus()) {
+            case HttpURLConnection.HTTP_NO_CONTENT:
+                return null;
+            default:
+                throw StatusCodeMapper.from(result);
+            }
+        });
+    }
+
+    /**
+     * Invokes the <em>Get Last Known Gateway for Device</em> operation of Hono's
+     * <a href="https://www.eclipse.org/hono/api/device-connection-api">Device Connection API</a>
+     * on the service represented by the <em>sender</em> and <em>receiver</em> links.
+     */
+    @Override
+    public Future<JsonObject> getLastKnownGatewayForDevice(final String deviceId, final SpanContext context) {
+        Objects.requireNonNull(deviceId);
+        final Future<DeviceConnectionResult> resultTracker = Future.future();
+
+        createAndSendRequest(
+                DeviceConnectionConstants.DeviceConnectionAction.GET_LAST_GATEWAY.getSubject(),
+                createDeviceIdProperties(deviceId),
+                null,
+                resultTracker,
+                null,
+                context);
+
+        return resultTracker.map(regResult -> {
+            switch (regResult.getStatus()) {
+            case HttpURLConnection.HTTP_OK:
+                return regResult.getPayload();
+            default:
+                throw StatusCodeMapper.from(regResult);
+            }
+        });
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
new file mode 100644
index 000000000..3f2ded1c2
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
@@ -0,0 +1,328 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import static org.eclipse.hono.client.impl.VertxMockSupport.anyHandler;
+import static org.eclipse.hono.util.Constants.DEFAULT_TENANT;
+import static org.eclipse.hono.util.DeviceConnectionConstants.DeviceConnectionAction.GET_LAST_GATEWAY;
+import static org.eclipse.hono.util.DeviceConnectionConstants.DeviceConnectionAction.SET_LAST_GATEWAY;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.CoreMatchers.startsWith;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.net.HttpURLConnection;
+
+import io.opentracing.tag.Tags;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.RequestResponseClientConfigProperties;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.util.CacheDirective;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.MessageHelper;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.Tracer.SpanBuilder;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.core.json.JsonObject;
+import io.vertx.ext.unit.Async;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
+
+
+/**
+ * Tests verifying behavior of {@link DeviceConnectionClientImpl}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class DeviceConnectionClientImplTest {
+
+    /**
+     * Time out test cases after 5 seconds.
+     */
+    @Rule
+    public Timeout globalTimeout = Timeout.seconds(5);
+
+    private Vertx vertx;
+    private ProtonSender sender;
+    private DeviceConnectionClientImpl client;
+    private Tracer tracer;
+    private Span span;
+    private HonoConnection connection;
+
+    /**
+     * Sets up the fixture.
+     */
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+
+        final SpanContext spanContext = mock(SpanContext.class);
+
+        span = mock(Span.class);
+        when(span.context()).thenReturn(spanContext);
+        final SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
+
+        tracer = mock(Tracer.class);
+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
+
+        vertx = mock(Vertx.class);
+        final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
+        sender = HonoClientUnitTestHelper.mockProtonSender();
+
+        final RequestResponseClientConfigProperties config = new RequestResponseClientConfigProperties();
+        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, config);
+        when(connection.getTracer()).thenReturn(tracer);
+
+        client = new DeviceConnectionClientImpl(connection, DEFAULT_TENANT, sender, receiver);
+    }
+
+    /**
+     * Verifies that the client retrieves the result of the <em>get last known gateway</em> operation from the
+     * Device Connection service.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testGetLastKnownGatewayForDeviceSuccess(final TestContext ctx) {
+
+        final JsonObject getLastGatewayResult = newGetLastGatewayResult("gatewayId");
+
+        // WHEN getting the last known gateway
+        final Async assertion = ctx.async();
+        client.getLastKnownGatewayForDevice("deviceId", span.context())
+                .setHandler(ctx.asyncAssertSuccess(r -> assertion.complete()));
+
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message(getLastGatewayResult.encode());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+
+        // THEN the last known gateway has been retrieved from the service
+        assertion.await();
+        // and the span is finished
+        verify(span).finish();
+    }
+
+    /**
+     * Verifies that the client handles the response of the <em>set last known gateway</em> operation from the
+     * Device Connection service.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testSetLastKnownGatewayForDeviceSuccess(final TestContext ctx) {
+
+        // WHEN setting the last known gateway
+        final Async assertion = ctx.async();
+        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.asyncAssertSuccess(r -> assertion.complete()));
+
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message response = ProtonHelper.message();
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NO_CONTENT);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+
+        // THEN the response for setting the last known gateway has been handled by the service
+        assertion.await();
+        // and the span is finished
+        verify(span).finish();
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>get last known gateway</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetLastKnownGatewayForDeviceFailsWithSendError(final TestContext ctx) {
+
+        // GIVEN a client with no credit left 
+        when(sender.sendQueueFull()).thenReturn(true);
+
+        // WHEN getting last known gateway information
+        client.getLastKnownGatewayForDevice("deviceId", span.context())
+                .setHandler(ctx.asyncAssertFailure(t -> {
+                    // THEN the invocation fails and the span is marked as erroneous
+                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>set last known gateway</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testSetLastKnownGatewayForDeviceFailsWithSendError(final TestContext ctx) {
+
+        // GIVEN a client with no credit left 
+        when(sender.sendQueueFull()).thenReturn(true);
+
+        // WHEN getting last known gateway information
+        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.asyncAssertFailure(t -> {
+                    // THEN the invocation fails and the span is marked as erroneous
+                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>get last known gateway</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetLastKnownGatewayForDeviceFailsWithRejectedRequest(final TestContext ctx) {
+
+        // GIVEN a client with no credit left
+        final ProtonDelivery update = mock(ProtonDelivery.class);
+        when(update.getRemoteState()).thenReturn(new Rejected());
+        when(update.remotelySettled()).thenReturn(true);
+        when(sender.send(any(Message.class), anyHandler())).thenAnswer(invocation -> {
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(update);
+            return mock(ProtonDelivery.class);
+        });
+
+        // WHEN getting last known gateway information
+        client.getLastKnownGatewayForDevice("deviceId", span.context())
+                .setHandler(ctx.asyncAssertFailure(t -> {
+                    ctx.assertEquals(HttpURLConnection.HTTP_BAD_REQUEST,
+                            ((ServiceInvocationException) t).getErrorCode());
+                    // THEN the invocation fails and the span is marked as erroneous
+                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>set last known gateway</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testSetLastKnownGatewayForDeviceFailsWithRejectedRequest(final TestContext ctx) {
+
+        // GIVEN a client with no credit left
+        final ProtonDelivery update = mock(ProtonDelivery.class);
+        when(update.getRemoteState()).thenReturn(new Rejected());
+        when(update.remotelySettled()).thenReturn(true);
+        when(sender.send(any(Message.class), anyHandler())).thenAnswer(invocation -> {
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(update);
+            return mock(ProtonDelivery.class);
+        });
+
+        // WHEN getting last known gateway information
+        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.asyncAssertFailure(t -> {
+                    ctx.assertEquals(HttpURLConnection.HTTP_BAD_REQUEST,
+                            ((ServiceInvocationException) t).getErrorCode());
+                    // THEN the invocation fails and the span is marked as erroneous
+                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+    }
+
+    /**
+     * Verifies that the client includes the required information in the <em>get last known gateway</em> operation
+     * request message sent to the device connection service.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetLastKnownGatewayForDeviceIncludesRequiredInformationInRequest(final TestContext ctx) {
+
+        // WHEN getting last known gateway information
+        client.getLastKnownGatewayForDevice("deviceId", span.context());
+
+        // THEN the message being sent contains the device ID in its properties
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), anyHandler());
+        final Message sentMessage = messageCaptor.getValue();
+        assertThat(MessageHelper.getDeviceId(sentMessage), is("deviceId"));
+        assertThat(sentMessage.getMessageId().toString(), startsWith(DeviceConnectionConstants.MESSAGE_ID_PREFIX));
+        assertThat(sentMessage.getSubject(), is(GET_LAST_GATEWAY.getSubject()));
+        assertNull(MessageHelper.getJsonPayload(sentMessage));
+    }
+
+    /**
+     * Verifies that the client includes the required information in the <em>set last known gateway</em> operation
+     * request message sent to the device connection service.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testSetLastKnownGatewayForDeviceIncludesRequiredInformationInRequest(final TestContext ctx) {
+
+        // WHEN getting last known gateway information
+        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context());
+
+        // THEN the message being sent contains the device ID in its properties
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), anyHandler());
+        final Message sentMessage = messageCaptor.getValue();
+        assertThat(MessageHelper.getDeviceId(sentMessage), is("deviceId"));
+        assertThat(sentMessage.getMessageId().toString(), startsWith(DeviceConnectionConstants.MESSAGE_ID_PREFIX));
+        assertThat(sentMessage.getSubject(), is(SET_LAST_GATEWAY.getSubject()));
+        assertNull(MessageHelper.getJsonPayload(sentMessage));
+    }
+
+    private JsonObject newGetLastGatewayResult(final String gatewayId) {
+        return new JsonObject().
+                put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
+    }
+}
