diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
deleted file mode 100644
index 2ee29860e..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.client.impl.CommandConsumer;
-import org.eclipse.hono.client.impl.CommandConsumerFactoryImpl;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-
-/**
- * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to
- * receive commands and send responses.
- */
-public interface CommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new factory for an existing connection.
-     *
-     * @param connection The connection to the AMQP network.
-     * @param gatewayMapper The component mapping a command device id to the corresponding gateway device id.
-     * @return The factory.
-     * @throws NullPointerException if connection or gatewayMapper is {@code null}.
-     */
-    static CommandConsumerFactory create(final HonoConnection connection, final GatewayMapper gatewayMapper) {
-        return new CommandConsumerFactoryImpl(connection, gatewayMapper);
-    }
-
-    /**
-     * Creates a command consumer for a device.
-     * <p>
-     * For each device only one command consumer may be active at any given time.
-     * It is the responsibility of the calling code to properly close a consumer
-     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
-     * method.
-     * 
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @param commandHandler The handler to invoke with every command received.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the peer's request or {@code null} if no handler should
-     *                     be invoked.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be completed with the newly created consumer once the link
-     *         has been established.
-     *         <p>
-     *         The future will be failed with
-     *         <ul>
-     *         <li>a {@link ResourceConflictException} if there already is
-     *         a command consumer active for the given device</li>
-     *         <li>a {@link ServiceInvocationException} with an error code indicating
-     *         the cause of the failure</li>
-     *         </ul>
-     * @throws NullPointerException if any of tenant, device ID or command handler are {@code null}.
-     */
-    Future<MessageConsumer> createCommandConsumer(
-            String tenantId,
-            String deviceId,
-            Handler<CommandContext> commandHandler,
-            Handler<Void> remoteCloseHandler);
-
-    /**
-     * Creates a command consumer for a device.
-     * <p>
-     * For each device only one command consumer may be active at any given time.
-     * It is the responsibility of the calling code to properly close a consumer
-     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
-     * method.
-     *
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @param gatewayId The gateway that wants to act on behalf of the device.
-     * @param commandHandler The handler to invoke with every command received.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the peer's request or {@code null} if no handler should
-     *                     be invoked. Note that all consumers with the same gateway Id
-     *                     will share the same link, so that once the link is closed,
-     *                     all corresponding closeHandlers will be invoked.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be completed with the newly created consumer once the link
-     *         has been established.
-     *         <p>
-     *         The future will be failed with
-     *         <ul>
-     *         <li>a {@link ResourceConflictException} if there already is
-     *         a command consumer active for the given device</li>
-     *         <li>a {@link ServiceInvocationException} with an error code indicating
-     *         the cause of the failure</li>
-     *         </ul>
-     * @throws NullPointerException if any of tenant, device ID, gateway ID or command handler are {@code null}.
-     */
-    Future<MessageConsumer> createCommandConsumer(
-            String tenantId,
-            String deviceId,
-            String gatewayId,
-            Handler<CommandContext> commandHandler,
-            Handler<Void> remoteCloseHandler);
-
-    /**
-     * Creates a command consumer for a device.
-     * <p>
-     * For each device only one command consumer may be active at any given time.
-     * It is the responsibility of the calling code to properly close a consumer
-     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
-     * method.
-     * <p>
-     * The underlying link for receiving the commands will be checked periodically
-     * after the given number of milliseconds. If the link is no longer active, e.g.
-     * because the underlying connection to the peer has been lost or the peer has
-     * closed the link, then this client will try to re-establish the link using the
-     * given parameters.
-     * 
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @param commandHandler The handler to invoke with every command received.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the peer's request.
-     * @param livenessCheckInterval The number of milliseconds to wait between checking
-     *                              liveness of the created link. If the check fails,
-     *                              an attempt will be made to re-establish the link.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be completed with the newly created consumer once the link
-     *         has been established.
-     *         <p>
-     *         The future will be failed with
-     *         <ul>
-     *         <li>a {@link ResourceConflictException} if there already is
-     *         a command consumer active for the given device</li>
-     *         <li>a {@link ServiceInvocationException} with an error code indicating
-     *         the cause of the failure</li>
-     *         </ul>
-     * @throws NullPointerException if tenant, device ID or command handler are {@code null}.
-     * @throws IllegalArgumentException if the checkInterval is negative.
-     */
-    Future<MessageConsumer> createCommandConsumer(
-            String tenantId,
-            String deviceId,
-            Handler<CommandContext> commandHandler,
-            Handler<Void> remoteCloseHandler,
-            long livenessCheckInterval);
-
-    /**
-     * Creates a command consumer for a device.
-     * <p>
-     * For each device only one command consumer may be active at any given time.
-     * It is the responsibility of the calling code to properly close a consumer
-     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
-     * method.
-     * <p>
-     * The underlying link for receiving the commands will be checked periodically
-     * after the given number of milliseconds. If the link is no longer active, e.g.
-     * because the underlying connection to the peer has been lost or the peer has
-     * closed the link, then this client will try to re-establish the link using the
-     * given parameters.
-     *
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @param gatewayId The gateway that wants to act on behalf of the device.
-     * @param commandHandler The handler to invoke with every command received.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the peer's request. Note that all consumers with the same gateway Id
-     *                     will share the same link, so that once the link is closed,
-     *                     all corresponding closeHandlers will be invoked.
-     * @param livenessCheckInterval The number of milliseconds to wait between checking
-     *                              liveness of the created link. If the check fails,
-     *                              an attempt will be made to re-establish the link.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will be completed with the newly created consumer once the link
-     *         has been established.
-     *         <p>
-     *         The future will be failed with
-     *         <ul>
-     *         <li>a {@link ResourceConflictException} if there already is
-     *         a command consumer active for the given device</li>
-     *         <li>a {@link ServiceInvocationException} with an error code indicating
-     *         the cause of the failure</li>
-     *         </ul>
-     * @throws NullPointerException if tenant, device ID, gateway ID or command handler are {@code null}.
-     * @throws IllegalArgumentException if the checkInterval is negative.
-     */
-    Future<MessageConsumer> createCommandConsumer(
-            String tenantId,
-            String deviceId,
-            String gatewayId,
-            Handler<CommandContext> commandHandler,
-            Handler<Void> remoteCloseHandler,
-            long livenessCheckInterval);
-
-    /**
-     * Gets a sender for sending command responses to a business application.
-     * <p>
-     * It is the responsibility of the calling code to properly close the
-     * link by invoking {@link CommandResponseSender#close(Handler)}
-     * once the sender is no longer needed anymore.
-     * 
-     * @param tenantId The ID of the tenant to send the command responses for.
-     * @param replyId The ID used to build the reply address as {@code command_response/tenantId/replyId}.
-     * @return A future that will complete with the sender once the link has been established.
-     *         The future will be failed with a {@link ServiceInvocationException} if
-     *         the link cannot be established, e.g. because this client is not connected.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    Future<CommandResponseSender> getCommandResponseSender(String tenantId, String replyId);
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java b/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
new file mode 100644
index 000000000..c0ff56592
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java
@@ -0,0 +1,110 @@
+/*******************************************************************************
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.Future;
+import io.vertx.core.json.JsonObject;
+
+/**
+ * A component for determining where a incoming command message should be targeted at when processing the message in a
+ * protocol adapter.
+ * <p>
+ * This refers to finding the <em>protocol adapter instance</em> that a device or gateway has connected to in order to
+ * receive a command message. Furthermore, it is determined to which <em>gateway</em> a command is to be mapped to or
+ * whether it will be sent to the target device directly.
+ * <p>
+ * For obtaining both information, the <em>getCommandHandlingAdapterInstances</em> operation of the Device Connection
+ * service is used. See the <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
+ * specification</a> for details on that operation. Note that a possible result of multiple entries of that operation
+ * will be reduced to just one finding here.
+ * <p>
+ * The <em>CommandTargetMapper</em> will return a gateway id as target, if there is no command consumer registered
+ * specifically for the device id of the command, but instead there is a consumer registered for a gateway that may act
+ * on behalf of the device.
+ * <p>
+ * Note that this also means that if a <em>gateway</em> has registered itself as a command consumer for a <em>specific
+ * device</em> (instead of as a consumer for commands to <em>any</em> device that the gateway may handle), that gateway
+ * won't be returned here for that device. That kind of gateway mapping will occur when processing the command at the
+ * target protocol adapter instance.
+ */
+public interface CommandTargetMapper {
+
+    /**
+     * Creates a new {@link CommandTargetMapper} using the default implementation.
+     *
+     * @param tracer The tracer instance.
+     * @return The CommandTargetMapper instance.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    static CommandTargetMapper create(final Tracer tracer) {
+        return new CommandTargetMapperImpl(tracer);
+    }
+
+    /**
+     * Initializes the CommandTargetMapper with the given components.
+     *
+     * @param registrationClientFactory The factory to create a registration client instance. Note that no
+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.
+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no
+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    void initialize(RegistrationClientFactory registrationClientFactory,
+            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);
+
+    /**
+     * Determines the target protocol adapter instance for a command directed at the given device. Also determines
+     * whether the command should be mapped to a gateway.
+     * <p>
+     * The mapping to a gateway will be done if there is no command consumer registered specifically for the given
+     * device id, but instead there is a consumer registered for a gateway that may act on behalf of the device.
+     * <p>
+     * Note that this also means that if a <em>gateway</em> has registered itself as a command consumer specifically for
+     * the given device (instead of as a consumer for commands to <em>any</em> device that the gateway may handle), that
+     * gateway won't be returned here. That kind of gateway mapping will have to occur when processing the command at
+     * the target protocol adapter instance.
+     * <p>
+     * If there are multiple command subscriptions from gateways that may act on behalf of the device and if the device
+     * hasn't communicated via any of these gateways yet, this method chooses one of the possible combinations of
+     * gateway and adapter instance where that gateway has subscribed for commands.
+     * <p>
+     * The value of the returned future is a JSON object with the fields
+     * {@link DeviceConnectionConstants#FIELD_PAYLOAD_DEVICE_ID} and
+     * {@link DeviceConnectionConstants#FIELD_ADAPTER_INSTANCE_ID} set to the determined values. If the command is not
+     * mapped to a gateway here, the {@link DeviceConnectionConstants#FIELD_PAYLOAD_DEVICE_ID} contains the given device
+     * id itself.
+     * <p>
+     * Note that {@link #initialize(RegistrationClientFactory, BasicDeviceConnectionClientFactory)} has to have been
+     * called already, otherwise a failed future is returned.
+     *
+     * @param tenantId The tenant identifier.
+     * @param deviceId The device identifier.
+     * @param context The currently active OpenTracing span context or {@code null}.
+     * @return A succeeded Future containing the JSON object with target device/gateway and adapter instance; or a
+     *         failed Future with:
+     *         <ul>
+     *         <li>a {@link ClientErrorException} with status <em>Not Found</em> if no matching adapter instance was
+     *         found</li>
+     *         <li>or a {@link ServiceInvocationException} with an error code indicating the cause of the failure</li>
+     *         </ul>
+     * @throws NullPointerException if tenantId or deviceId is {@code null}.
+     */
+    Future<JsonObject> getTargetGatewayAndAdapterInstance(String tenantId, String deviceId, SpanContext context);
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java b/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java
deleted file mode 100644
index 1689015af..000000000
--- a/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.client.impl.GatewayMapperImpl;
-
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.vertx.core.Future;
-
-/**
- * A component that maps a given device to the gateway through which data was last published for the given device.
- *
- */
-public interface GatewayMapper extends ConnectionLifecycle<HonoConnection> {
-
-    /**
-     * Creates a new {@link GatewayMapper} using the default implementation.
-     *
-     * @param registrationClientFactory The factory to create a registration client instance.
-     * @param deviceConnectionClientFactory The factory to create a device connection client instance.
-     * @param tracer The tracer instance.
-     * @return The GatewayMapper instance.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    static GatewayMapper create(
-            final RegistrationClientFactory registrationClientFactory,
-            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory,
-            final Tracer tracer) {
-
-        return new GatewayMapperImpl(registrationClientFactory, deviceConnectionClientFactory, tracer);
-    }
-
-    /**
-     * Determines the gateway device id for the given device id (if applicable).
-     * <p>
-     * The value of the returned Future can be either
-     * <ul>
-     * <li>the id of the gateway that last acted on behalf of the given device</li>
-     * <li>the 'via' gateway id of the device registration information if no last known gateway is set for the device
-     * and the 'via' entry only contains a single entry</li>
-     * <li>the given device id if the device is not configured to be accessed via a gateway</li>
-     * </ul>
-     *
-     * @param tenantId The tenant identifier.
-     * @param deviceId The device identifier.
-     * @param context The currently active OpenTracing span context or {@code null}.
-     * @return A succeeded Future containing the mapped gateway device id or the device id itself;
-     *         or a failed Future with:
-     *         <ul>
-     *         <li>a {@link ClientErrorException} with status <em>Not Found</em> if no last known gateway was set
-     *         for the device and the 'via' entry of the device registration contains more than one entry</li>
-     *         <li>a {@link ClientErrorException} with status <em>Not Found</em> if the last known gateway for the
-     *         device was not found in the 'via' entry of the device registration</li>
-     *         <li>a {@link ServiceInvocationException} with an error code indicating the cause of the failure
-     *         determining the device registration information or the mapped gateway device</li>
-     *         </ul>
-     */
-    Future<String> getMappedGatewayDevice(String tenantId, String deviceId, SpanContext context);
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
new file mode 100644
index 000000000..d3bdd99f6
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
@@ -0,0 +1,134 @@
+/*******************************************************************************
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import org.eclipse.hono.client.impl.CommandConsumer;
+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;
+
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+
+/**
+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to
+ * receive commands and send responses.
+ */
+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {
+
+    /**
+     * Creates a new factory for an existing connection.
+     *
+     * @param connection The connection to the AMQP network.
+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.
+     * @return The factory.
+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.
+     */
+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {
+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);
+    }
+
+    /**
+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.
+     *
+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and
+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done
+     *            here, that is supposed to be done by the calling method.
+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no
+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.
+     */
+    void initialize(CommandTargetMapper commandTargetMapper,
+            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);
+
+    /**
+     * Creates a command consumer for a device.
+     * <p>
+     * For each device only one command consumer may be active at any given time. Invoking this method multiple times
+     * with the same parameters will each time overwrite the previous entry.
+     * <p>
+     * It is the responsibility of the calling code to properly close a consumer
+     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
+     * method.
+     * <p>
+     * Note that {@link #initialize(CommandTargetMapper, BasicDeviceConnectionClientFactory)} has to have been called
+     * already, otherwise a failed future is returned.
+     * 
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
+     *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
+     *                       message transfer and finish the trace span associated with the {@link CommandContext}.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be completed with the newly created consumer once the link
+     *         has been established.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating
+     *         the cause of the failure.
+     * @throws NullPointerException if any of tenant, device ID or command handler are {@code null}.
+     */
+    Future<MessageConsumer> createCommandConsumer(
+            String tenantId,
+            String deviceId,
+            Handler<CommandContext> commandHandler);
+
+    /**
+     * Creates a command consumer for a device that is connected via a gateway.
+     * <p>
+     * For each device only one command consumer may be active at any given time. Invoking this method multiple times
+     * with the same parameters will each time overwrite the previous entry.
+     * <p>
+     * It is the responsibility of the calling code to properly close a consumer
+     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
+     * method.
+     * <p>
+     * Note that {@link #initialize(CommandTargetMapper, BasicDeviceConnectionClientFactory)} has to have been called
+     * already, otherwise a failed future is returned.
+     *
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @param gatewayId The gateway that wants to act on behalf of the device.
+     * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
+     *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
+     *                       message transfer and finish the trace span associated with the {@link CommandContext}.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be completed with the newly created consumer once the link
+     *         has been established.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating
+     *         the cause of the failure.
+     * @throws NullPointerException if any of tenant, device ID, gateway ID or command handler are {@code null}.
+     */
+    Future<MessageConsumer> createCommandConsumer(
+            String tenantId,
+            String deviceId,
+            String gatewayId,
+            Handler<CommandContext> commandHandler);
+
+    /**
+     * Gets a sender for sending command responses to a business application.
+     * <p>
+     * It is the responsibility of the calling code to properly close the
+     * link by invoking {@link CommandResponseSender#close(Handler)}
+     * once the sender is no longer needed anymore.
+     * 
+     * @param tenantId The ID of the tenant to send the command responses for.
+     * @param replyId The ID used to build the reply address as {@code command_response/tenantId/replyId}.
+     * @return A future that will complete with the sender once the link has been established.
+     *         The future will be failed with a {@link ServiceInvocationException} if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    Future<CommandResponseSender> getCommandResponseSender(String tenantId, String replyId);
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
new file mode 100644
index 000000000..46866a31d
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java
@@ -0,0 +1,194 @@
+/*******************************************************************************
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.auth.Device;
+import org.eclipse.hono.client.Command;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.tracing.TracingHelper;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.ResourceIdentifier;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+
+/**
+ * Handler for commands received at the protocol adapter specific address.
+ */
+public final class AdapterInstanceCommandHandler {
+
+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);
+
+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();
+    private final Tracer tracer;
+    private final String adapterInstanceId;
+
+    /**
+     * Creates a new AdapterInstanceCommandHandler instance.
+     *
+     * @param tracer The tracer instance.
+     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    public AdapterInstanceCommandHandler(final Tracer tracer, final String adapterInstanceId) {
+        this.tracer = Objects.requireNonNull(tracer);
+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);
+    }
+
+    /**
+     * Handles a received command message.
+     *
+     * @param msg The command message.
+     * @param delivery The delivery.
+     * @throws NullPointerException If msg or delivery is {@code null}.
+     */
+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {
+        Objects.requireNonNull(msg);
+        Objects.requireNonNull(delivery);
+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case
+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;
+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {
+            LOG.debug("address of command message is invalid: {}", msg.getAddress());
+            final Rejected rejected = new Rejected();
+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "invalid command target address"));
+            delivery.disposition(rejected, true);
+            return;
+        }
+        final String tenantId = resourceIdentifier.getTenantId();
+        final String originalDeviceId = resourceIdentifier.getResourceId();
+        // fetch "via" property (if set)
+        final String gatewayIdFromMessage = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);
+        final String targetDeviceId = gatewayIdFromMessage != null ? gatewayIdFromMessage : originalDeviceId;
+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, targetDeviceId);
+
+        // Adopt gateway id from command handler if set;
+        // for that kind of command handler (gateway subscribing for specific device commands), the
+        // gateway information is not stored in the device connection service ("deviceConnectionService.setCommandHandlingAdapterInstance()" doesn't have an extra gateway id parameter);
+        // and therefore not set in the delegated command message
+        final String gatewayId = commandHandler != null && commandHandler.getGatewayId() != null
+                ? commandHandler.getGatewayId()
+                : gatewayIdFromMessage;
+
+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);
+
+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);
+        final Span currentSpan = CommandConsumer.createSpan("handle command", tenantId, originalDeviceId,
+                gatewayId, tracer, spanContext);
+        currentSpan.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);
+
+        if (commandHandler != null) {
+            LOG.trace("using [{}] for received command [{}]", commandHandler, command);
+            // command.isValid() check not done here - it is to be done in the command handler
+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));
+        } else {
+            LOG.info("no command handler found for command with device id {}, gateway id {} [tenant-id: {}]",
+                    originalDeviceId, gatewayId, tenantId);
+            TracingHelper.logError(currentSpan, "no command handler found for command");
+            currentSpan.finish();
+            ProtonHelper.released(delivery, true);
+        }
+    }
+
+    /**
+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
+     *
+     * @param tenantId The tenant id.
+     * @param deviceId The identifier of the device or gateway that is the target of the commands being handled.
+     * @param gatewayId The identifier of the gateway in case the handler gets added as part of the gateway
+     *                  subscribing specifically for commands of the given device, or {@code null} otherwise.
+     *                  (A gateway subscribing for commands of all devices, that it may act on behalf of, would mean
+     *                  using a {@code null} value here and providing the gateway id in the <em>deviceId</em>
+     *                  parameter.)
+     * @param commandHandler The command handler. The handler must invoke one of the terminal methods of the passed
+     *                       in {@link CommandContext} in order to settle the command message transfer and finish
+     *                       the trace span associated with the {@link CommandContext}.
+     * @return The previous handler entry or {@code null} if there was none.
+     * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.
+     */
+    public CommandHandlerWrapper putDeviceSpecificCommandHandler(final String tenantId, final String deviceId,
+            final String gatewayId, final Handler<CommandContext> commandHandler) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(commandHandler);
+
+        final String key = getDeviceKey(tenantId, deviceId);
+        if (commandHandlers.containsKey(key)) {
+            LOG.debug("replacing existing command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
+        }
+        return commandHandlers.put(key, new CommandHandlerWrapper(tenantId, deviceId, gatewayId, commandHandler));
+    }
+
+    /**
+     * Gets a handler for the given device id.
+     * <p>
+     * When providing a gateway id as <em>deviceId</em> here, the handler is returned that handles
+     * commands for all devices that the gateway may act on behalf of, if such a handler was set before.
+     *
+     * @param tenantId The tenant id.
+     * @param deviceId The device id to get the handler for.
+     * @return The handler or {@code null}.
+     * @throws NullPointerException If tenantId or deviceId is {@code null}.
+     */
+    public CommandHandlerWrapper getDeviceSpecificCommandHandler(final String tenantId, final String deviceId) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        return commandHandlers.get(getDeviceKey(tenantId, deviceId));
+    }
+
+    /**
+     * Gets the contained command handlers.
+     *
+     * @return The command handlers.
+     */
+    public Collection<CommandHandlerWrapper> getDeviceSpecificCommandHandlers() {
+        return commandHandlers.values();
+    }
+
+    /**
+     * Removes the handler for the given device id.
+     *
+     * @param tenantId The tenant id of the handler to remove.
+     * @param deviceId The device id of the handler to remove.
+     * @return {@code true} if the handler was removed.
+     * @throws NullPointerException If tenantId or deviceId is {@code null}.
+     */
+    public boolean removeDeviceSpecificCommandHandler(final String tenantId, final String deviceId) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        final CommandHandlerWrapper removedHandler = commandHandlers.remove(getDeviceKey(tenantId, deviceId));
+        LOG.trace("Removed handler for tenant {}, device {}: {}", tenantId, deviceId, removedHandler != null);
+        return removedHandler != null;
+    }
+
+    private String getDeviceKey(final String tenantId, final String deviceId) {
+        return Device.asAddress(tenantId, deviceId);
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumer.java
index a5b620f64..71f88ac22 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -30,7 +30,7 @@ import io.vertx.proton.ProtonReceiver;
 /**
  * A wrapper around an AMQP receiver link for consuming commands.
  */
-public abstract class CommandConsumer extends AbstractConsumer {
+public class CommandConsumer extends AbstractConsumer {
 
     /**
      * Creates a consumer for a connection and a receiver link.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
deleted file mode 100644
index 2c62956da..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
+++ /dev/null
@@ -1,635 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Supplier;
-
-import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.eclipse.hono.auth.Device;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandConsumerFactory;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.CommandResponseSender;
-import org.eclipse.hono.client.ConnectionLifecycle;
-import org.eclipse.hono.client.DelegatedCommandSender;
-import org.eclipse.hono.client.GatewayMapper;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.client.ResourceConflictException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.CompositeFuture;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-
-/**
- * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to receive commands and send responses.
- * <p>
- * The <em>createCommandConsumer()</em> methods will create one tenant-scoped consumer (if not existing yet) and one
- * gateway or device specific consumer by which the command will be eventually sent to the device.
- * <p>
- * Command messages are first received on the tenant-scoped consumer address. If applicable, the device id of a received
- * command is mapped to the id of the gateway through which the device has last sent messages. Then the command message
- * is either handled by an already existing command handler for the (mapped) gateway id, or the message is sent back to
- * the downstream peer to be handled by a gateway specific consumer.
- */
-public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implements CommandConsumerFactory {
-
-    /**
-     * The minimum number of milliseconds to wait between checking a
-     * command consumer link's liveness.
-     */
-    public static final long MIN_LIVENESS_CHECK_INTERVAL_MILLIS = 2000;
-
-    /**
-     * Used for integration tests (with only a single instance of each protocol adapter):
-     * <p>
-     * System property value defining whether incoming command messages on the tenant
-     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific
-     * consumer even if there is a local handler for the command.<p>
-     * The second condition for the rerouting to take place is that the command message
-     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application
-     * property with a {@code true} value.
-     */
-    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean
-            .valueOf(System.getProperty("enableForcedCommandRerouting", "false"));
-    /**
-     * Name of the boolean command message application property with which commands are
-     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.
-     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property
-     * is set to {@code true}.
-     */
-    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = "force-command-rerouting";
-
-    /**
-     * Cache key used here is the address returned by {@link #getGatewayOrDeviceKey(String, String, String)}.
-     */
-    private final CachingClientFactory<DestinationCommandConsumer> destinationCommandConsumerFactory;
-
-    /**
-     * Cache key used here is the tenant id.
-     */
-    private final CachingClientFactory<MessageConsumer> mappingAndDelegatingCommandConsumerFactory;
-
-    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;
-    /**
-     * A mapping of the address returned by {@link #getGatewayOrDeviceKey(String, String, String)}
-     * to the object representing the liveness check for a destination command consumer.
-     */
-    private final Map<String, LivenessCheckData> destinationCommandConsumerLivenessChecks = new HashMap<>();
-
-    private final GatewayMapper gatewayMapper;
-
-    /**
-     * Creates a new factory for an existing connection.
-     * <p>
-     * Note: The connection lifecycle of the given {@link GatewayMapper} instance will be managed by this
-     * <em>CommandConsumerFactoryImpl</em> instance via the {@link ConnectionLifecycle#connect()} and
-     * {@link ConnectionLifecycle#disconnect()} methods.
-     * 
-     * @param connection The connection to the AMQP network.
-     * @param gatewayMapper The component mapping a command device id to the corresponding gateway device id.
-     * @throws NullPointerException if connection or gatewayMapper is {@code null}.
-     */
-    public CommandConsumerFactoryImpl(final HonoConnection connection, final GatewayMapper gatewayMapper) {
-        super(connection);
-        this.gatewayMapper = Objects.requireNonNull(gatewayMapper);
-        destinationCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isAlive());
-        mappingAndDelegatingCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> true);
-        delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());
-    }
-
-    @Override
-    protected void onDisconnect() {
-        destinationCommandConsumerFactory.clearState();
-        mappingAndDelegatingCommandConsumerFactory.clearState();
-    }
-
-    private String getGatewayOrDeviceKey(final String tenantId, final String deviceId, final String gatewayId) {
-        return Device.asAddress(tenantId, gatewayId != null ? gatewayId : deviceId);
-    }
-
-    private String getDeviceKey(final String tenantId, final String deviceId) {
-        return Device.asAddress(tenantId, deviceId);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(commandHandler);
-
-        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, remoteCloseHandler, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final String gatewayId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(gatewayId);
-        Objects.requireNonNull(commandHandler);
-
-        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, remoteCloseHandler, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * The interval used for creating the periodic liveness check will be the maximum
-     * of the given interval length and {@link #MIN_LIVENESS_CHECK_INTERVAL_MILLIS}.
-     */
-    @Override
-    public final Future<MessageConsumer> createCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler,
-            final long checkInterval) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(commandHandler);
-        if (checkInterval < 0) {
-            throw new IllegalArgumentException("liveness check interval must be > 0");
-        }
-
-        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, remoteCloseHandler, checkInterval);
-    }
-
-    /**
-     * {@inheritDoc}
-     * <p>
-     * The interval used for creating the periodic liveness check will be the maximum
-     * of the given interval length and {@link #MIN_LIVENESS_CHECK_INTERVAL_MILLIS}.
-     */
-    @Override
-    public final Future<MessageConsumer> createCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final String gatewayId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler,
-            final long checkInterval) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(gatewayId);
-        Objects.requireNonNull(commandHandler);
-        if (checkInterval < 0) {
-            throw new IllegalArgumentException("liveness check interval must be > 0");
-        }
-
-        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, remoteCloseHandler, checkInterval);
-    }
-
-    private Future<MessageConsumer> doCreateCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final String gatewayId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler,
-            final Long checkInterval) {
-
-        log.trace("create command consumer [tenant-id: {}, device-id: {}, gateway-id: {}]", tenantId, deviceId, gatewayId);
-
-        return connection.executeOnContext(result -> {
-
-            final String gatewayOrDeviceId = gatewayId != null ? gatewayId : deviceId;
-            final String gatewayOrDeviceKey = getGatewayOrDeviceKey(tenantId, deviceId, gatewayId);
-
-            ensureNoConflictingConsumerExists(tenantId, deviceId, gatewayId, gatewayOrDeviceKey)
-            .compose(noConflict -> {
-                final Promise<DestinationCommandConsumer> destinationCommandConsumerPromise = Promise.promise();
-                // create the gateway or device specific destination consumer
-                destinationCommandConsumerFactory.getOrCreateClient(
-                        gatewayOrDeviceKey,
-                        () -> newDestinationCommandConsumer(tenantId, gatewayOrDeviceId),
-                        destinationCommandConsumerPromise);
-
-                // create the device specific consumer to be returned by this method
-                final Future<MessageConsumer> deviceSpecificConsumerFuture = destinationCommandConsumerPromise.future()
-                        .compose(consumer -> consumer.addDeviceSpecificCommandHandler(
-                                deviceId,
-                                gatewayId,
-                                commandHandler,
-                                remoteCloseHandler))
-                        .map(ok -> new DeviceSpecificCommandConsumer(
-                                    () -> destinationCommandConsumerFactory.getClient(gatewayOrDeviceKey),
-                                    deviceId));
-
-                // create the tenant-scoped consumer that maps/delegates incoming commands to the right device-scoped handler/consumer
-                final Future<MessageConsumer> mappingAndDelegatingCommandConsumer = getOrCreateMappingAndDelegatingCommandConsumer(tenantId);
-
-                return CompositeFuture.all(deviceSpecificConsumerFuture, mappingAndDelegatingCommandConsumer)
-                        .map(ok -> {
-                            if (checkInterval != null) {
-                                final DestinationCommandConsumer destinationCommandConsumer = destinationCommandConsumerPromise.future().result();
-                                registerLivenessCheck(
-                                        tenantId,
-                                        gatewayOrDeviceId,
-                                        () -> destinationCommandConsumer.getCommandHandlers(),
-                                        checkInterval);
-                            }
-                            return deviceSpecificConsumerFuture.result();
-                        });
-            })
-            .setHandler(result);
-        });
-    }
-
-    private Future<Void> ensureNoConflictingConsumerExists(
-            final String tenantId,
-            final String deviceId,
-            final String gatewayId,
-            final String gatewayOrDeviceKey) {
-
-        final Promise<Void> result = Promise.promise();
-        final DestinationCommandConsumer commandConsumer = destinationCommandConsumerFactory.getClient(gatewayOrDeviceKey);
-        if (commandConsumer == null) {
-            result.complete();
-        } else if (!commandConsumer.isAlive()) {
-            log.debug("cannot create command consumer, existing consumer not properly closed yet [tenant: {}, device-id: {}]",
-                    tenantId, deviceId);
-            result.fail(new ResourceConflictException("message consumer already in use"));
-        } else if (commandConsumer.containsCommandHandler(deviceId)) {
-            log.debug("cannot create concurrent command consumer [tenant: {}, device-id: {}]", tenantId, deviceId);
-            result.fail(new ResourceConflictException("message consumer already in use"));
-        } else if (gatewayId != null) {
-            log.trace("gateway command consumer already exists, will add device handler to that [tenant: {}, gateway-id: {}, device-id: {}]",
-                    tenantId, gatewayId, deviceId);
-            result.complete();
-        } else {
-            log.trace("gateway command consumer with a device specific handler already exists, will add handler for all gateway devices [tenant: {}, gateway-id: {}]",
-                    tenantId, deviceId);
-            result.complete();
-        }
-        return result.future();
-    }
-
-    private Future<DestinationCommandConsumer> newDestinationCommandConsumer(
-            final String tenantId,
-            final String gatewayOrDeviceId) {
-
-        final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
-        return DestinationCommandConsumer.create(
-                connection,
-                tenantId,
-                gatewayOrDeviceId,
-                sourceAddress -> { // local close hook
-                    // stop liveness check
-                    Optional.ofNullable(destinationCommandConsumerLivenessChecks.remove(gatewayOrDeviceKey))
-                            .ifPresent(livenessCheck -> connection.getVertx().cancelTimer(livenessCheck.getTimerId()));
-                    destinationCommandConsumerFactory.removeClient(gatewayOrDeviceKey);
-                },
-                sourceAddress -> { // remote close hook
-                    destinationCommandConsumerFactory.removeClient(gatewayOrDeviceKey);
-                });
-    }
-
-    private Future<MessageConsumer> getOrCreateMappingAndDelegatingCommandConsumer(final String tenantId) {
-        Objects.requireNonNull(tenantId);
-        return connection.executeOnContext(result -> {
-            final MessageConsumer messageConsumer = mappingAndDelegatingCommandConsumerFactory.getClient(tenantId);
-            if (messageConsumer != null) {
-                result.complete(messageConsumer);
-            } else {
-                mappingAndDelegatingCommandConsumerFactory.getOrCreateClient(tenantId,
-                        () -> newMappingAndDelegatingCommandConsumer(tenantId),
-                        result);
-            }
-        });
-    }
-
-    private Future<MessageConsumer> newMappingAndDelegatingCommandConsumer(final String tenantId) {
-
-        final DelegateViaDownstreamPeerCommandHandler delegatingCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
-                (tenantIdParam, deviceIdParam) -> createDelegatedCommandSender(tenantIdParam, deviceIdParam));
-
-        final GatewayMappingCommandHandler gatewayMappingCommandHandler = new GatewayMappingCommandHandler(
-                gatewayMapper, commandContext -> { // handler following the gateway mapping
-                    final String gatewayOrDeviceId = commandContext.getCommand().getDeviceId();
-                    final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
-
-                    CommandHandlerWrapper commandHandler = null;
-                    final DestinationCommandConsumer consumer = destinationCommandConsumerFactory
-                            .getClient(gatewayOrDeviceKey);
-                    if (consumer != null) {
-                        commandHandler = consumer
-                                .getCommandHandlerOrDefault(commandContext.getCommand().getOriginalDeviceId());
-                    }
-
-                    if (commandHandler != null && isForcedCommandReroutingSet(commandContext)) { // used for integration tests
-                        log.debug("forced command rerouting is set, skip usage of local {} for {}",
-                                commandHandler, commandContext.getCommand());
-                        commandHandler = null;
-                    }
-
-                    if (commandHandler != null) {
-                        log.trace("use local {} for {}", commandHandler, commandContext.getCommand());
-                        commandHandler.handleCommand(commandContext);
-                    } else {
-                        // delegate to matching consumer via downstream peer
-                        delegatingCommandHandler.handle(commandContext);
-                    }
-                });
-
-        return MappingAndDelegatingCommandConsumer.create(
-                connection,
-                tenantId,
-                (originalMessageDelivery, message) -> {
-                    final String deviceId = message.getAddress() != null ? ResourceIdentifier.fromString(message.getAddress()).getResourceId() : null;
-                    if (deviceId == null) {
-                        log.debug("address of command message is invalid: {}", message.getAddress());
-                        final Rejected rejected = new Rejected();
-                        rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "invalid command target address"));
-                        originalMessageDelivery.disposition(rejected, true);
-                        return;
-                    }
-                    final Command command = Command.from(message, tenantId, deviceId);
-                    final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);
-                    final Span currentSpan = CommandConsumer.createSpan("delegate and send command", tenantId, deviceId, null, connection.getTracer(), spanContext);
-                    CommandConsumer.logReceivedCommandToSpan(command, currentSpan);
-                    final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);
-                    if (command.isValid()) {
-                        gatewayMappingCommandHandler.handle(commandContext);
-                    } else {
-                        // command is invalid, try to find local command handler to let it reject the command (and also report metrics for that), otherwise reject it directly
-                        gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, spanContext)
-                                .setHandler(ar -> {
-                                    final String gatewayOrDeviceId = ar.succeeded() ? ar.result() : deviceId;
-                                    final DestinationCommandConsumer consumer = destinationCommandConsumerFactory
-                                            .getClient(getDeviceKey(tenantId, gatewayOrDeviceId));
-                                    CommandHandlerWrapper commandHandler = null;
-                                    if (consumer != null) {
-                                        commandHandler = consumer.getCommandHandlerOrDefault(deviceId);
-                                    }
-                                    if (commandHandler != null) {
-                                        // let the device specific handler reject the command
-                                        commandHandler.handleCommand(commandContext);
-                                    } else {
-                                        log.debug("command message is invalid: {}", command);
-                                        commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST,
-                                                "malformed command message"));
-                                    }
-                                });
-
-                    }
-                },
-                sourceAddress -> { // local close hook
-                    mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
-                },
-                sourceAddress -> { // remote close hook
-                    mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
-                })
-                .map(c -> (MessageConsumer) c);
-    }
-
-    private boolean isForcedCommandReroutingSet(final CommandContext commandContext) {
-        if (!FORCED_COMMAND_REROUTING_ENABLED || !commandContext.getCommand().isValid()) {
-            return false;
-        }
-        final ApplicationProperties applicationProperties = commandContext.getCommand().getCommandMessage()
-                .getApplicationProperties();
-        return Boolean.TRUE.equals(MessageHelper.getApplicationProperty(applicationProperties,
-                FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY, Boolean.class));
-    }
-
-    private Future<DelegatedCommandSender> createDelegatedCommandSender(final String tenantId, final String deviceId) {
-        Objects.requireNonNull(tenantId);
-        return connection.executeOnContext(result -> {
-            delegatedCommandSenderFactory.createClient(
-                    () -> DelegatedCommandSenderImpl.create(connection, tenantId, deviceId, null), result);
-        });
-    }
-
-    private void registerLivenessCheck(final String tenantId, final String gatewayOrDeviceId,
-            final Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier, final long checkInterval) {
-        final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
-
-        destinationCommandConsumerLivenessChecks.compute(gatewayOrDeviceKey, (key, existingLivenessCheckData) -> {
-            if (existingLivenessCheckData != null) {
-                existingLivenessCheckData.setCommandHandlersSupplier(commandHandlersSupplier);
-                return existingLivenessCheckData;
-            }
-            final long effectiveCheckInterval = Math.max(MIN_LIVENESS_CHECK_INTERVAL_MILLIS, checkInterval);
-            final long timerId = connection.getVertx().setPeriodic(effectiveCheckInterval,
-                    newLivenessCheck(tenantId, gatewayOrDeviceId));
-            return new LivenessCheckData(timerId, commandHandlersSupplier);
-        });
-    }
-
-    Handler<Long> newLivenessCheck(final String tenantId, final String gatewayOrDeviceId) {
-
-        final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
-        final AtomicBoolean recreatingDestinationConsumer = new AtomicBoolean(false);
-        final AtomicBoolean recreatingMappingAndDelegatingConsumer = new AtomicBoolean(false);
-        return timerId -> {
-            final LivenessCheckData livenessCheck = destinationCommandConsumerLivenessChecks.get(gatewayOrDeviceKey);
-            if (connection.isShutdown() || livenessCheck == null) {
-                connection.getVertx().cancelTimer(timerId);
-            } else {
-                connection.isConnected().map(ok -> {
-                    if (destinationCommandConsumerFactory.getClient(gatewayOrDeviceKey) == null) {
-                        // when a connection is lost unexpectedly,
-                        // all consumers will have been removed from the cache
-                        // so we need to recreate the consumer
-                        if (recreatingDestinationConsumer.compareAndSet(false, true)) {
-                            // set a lock in order to prevent spawning multiple attempts
-                            // to re-create the consumer
-                            log.debug("trying to re-create destination command consumer [tenant: {}, device-id: {}]",
-                                    tenantId, gatewayOrDeviceId);
-                            final Promise<DestinationCommandConsumer> destinationCommandConsumerFuture = Promise.promise();
-                            destinationCommandConsumerFactory.getOrCreateClient(
-                                    gatewayOrDeviceKey,
-                                    () -> newDestinationCommandConsumer(tenantId, gatewayOrDeviceId),
-                                    destinationCommandConsumerFuture);
-                            destinationCommandConsumerFuture.future()
-                            .map(consumer -> {
-                                livenessCheck.getCommandHandlers().forEach(handler -> {
-                                    log.debug("adding {} to created destination command consumer [tenant: {}, device-id: {}]",
-                                            handler, tenantId, gatewayOrDeviceId);
-                                    consumer.addDeviceSpecificCommandHandler(handler);
-                                });
-                                livenessCheck.setCommandHandlersSupplier(() -> consumer.getCommandHandlers());
-                                recreatingDestinationConsumer.compareAndSet(true, false);
-                                return consumer;
-                            })
-                            .otherwise(t -> {
-                                log.info("failed to re-create destination command consumer [tenant: {}, device-id: {}]: {}",
-                                        tenantId, gatewayOrDeviceId, t.getMessage());
-                                return null;
-                            })
-                            .setHandler(s -> recreatingDestinationConsumer.compareAndSet(true, false));
-                        } else {
-                            log.debug("already trying to re-create destination command consumer [tenant: {}, device-id: {}], yielding ...",
-                                    tenantId, gatewayOrDeviceId);
-                        }
-                    }
-
-                    if (mappingAndDelegatingCommandConsumerFactory.getClient(tenantId) == null) {
-                        if (recreatingMappingAndDelegatingConsumer.compareAndSet(false, true)) {
-                            log.debug("trying to re-create MappingAndDelegatingCommandConsumer [tenant: {}]", tenantId);
-                            getOrCreateMappingAndDelegatingCommandConsumer(tenantId)
-                                    .map(consumer -> {
-                                        log.debug("successfully re-created MappingAndDelegatingCommandConsumer [tenant: {}]", tenantId);
-                                        return consumer;
-                                    })
-                                    .otherwise(t -> {
-                                        log.info("failed to re-create MappingAndDelegatingCommandConsumer [tenant: {}]: {}",
-                                                tenantId, t.getMessage());
-                                        return null;
-                                    })
-                                    .setHandler(s -> recreatingMappingAndDelegatingConsumer.compareAndSet(true, false));
-                        } else {
-                            log.debug("already trying to re-create MappingAndDelegatingCommandConsumer [tenant: {}], yielding ...", tenantId);
-                        }
-                    }
-                    return null;
-                });
-            }
-        };
-    }
-
-    /**
-     * {@inheritDoc}
-     * 
-     * This implementation always creates a new sender link.
-     */
-    @Override
-    public Future<CommandResponseSender> getCommandResponseSender(
-            final String tenantId,
-            final String replyId) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(replyId);
-
-        return connection.executeOnContext(result -> {
-            CommandResponseSenderImpl.create(
-                    connection,
-                    tenantId,
-                    replyId,
-                    onRemoteClose -> {})
-            .setHandler(result);
-        });
-    }
-
-    /**
-     * Only used for testing.
-     */
-    Map<String, LivenessCheckData> getDestinationCommandConsumerLivenessChecks() {
-        return destinationCommandConsumerLivenessChecks;
-    }
-
-    // ------------- Override AbstractHonoClientFactory methods to also connect/disconnect the gatewayMapper ------------
-
-    @Override
-    public Future<HonoConnection> connect() {
-        final Future<HonoConnection> amqpNetworkConnectionFuture = super.connect();
-        return CompositeFuture.all(amqpNetworkConnectionFuture, gatewayMapper.connect())
-                .map(obj -> amqpNetworkConnectionFuture.result());
-    }
-
-    @Override
-    public void disconnect() {
-        super.disconnect();
-        gatewayMapper.disconnect();
-    }
-
-    @Override
-    public void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
-        final Promise<Void> amqpNetworkDisconnectPromise = Promise.promise();
-        super.disconnect(amqpNetworkDisconnectPromise);
-        final Promise<Void> gatewayMapperDisconnectPromise = Promise.promise();
-        gatewayMapper.disconnect(gatewayMapperDisconnectPromise);
-        CompositeFuture.all(amqpNetworkDisconnectPromise.future(), gatewayMapperDisconnectPromise.future())
-                .map(obj -> amqpNetworkDisconnectPromise.future().result())
-                .setHandler(completionHandler);
-    }
-
-    /**
-     * Represents a liveness check corresponding to a destination command consumer.
-     * Contains the id of the Vert.x timer that invokes the liveness check.
-     */
-    static class LivenessCheckData {
-        private final long timerId;
-        private Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier;
-
-        LivenessCheckData(final long timerId, final Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier) {
-            this.timerId = Objects.requireNonNull(timerId);
-            this.commandHandlersSupplier = Objects.requireNonNull(commandHandlersSupplier);
-        }
-
-        /**
-         * Gets the id of the Vert.x timer that invokes the liveness check.
-         *
-         * @return The timer id.
-         */
-        public long getTimerId() {
-            return timerId;
-        }
-
-        /**
-         * Gets the command handlers to be re-registered once the liveness check has
-         * determined the command consumer has to be recreated.
-         *
-         * @return The command handlers.
-         */
-        public Collection<CommandHandlerWrapper> getCommandHandlers() {
-            return commandHandlersSupplier.get();
-        }
-
-        /**
-         * Sets the supplier that provides the command handlers to be re-registered
-         * once the liveness check has determined the command consumer has to be recreated.
-         *
-         * @param commandHandlersSupplier Provides the command handlers.
-         * @throws NullPointerException if commandHandlersSupplier is {@code null}.
-         */
-        public void setCommandHandlersSupplier(final Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier) {
-            this.commandHandlersSupplier = Objects.requireNonNull(commandHandlersSupplier);
-        }
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
index a6c019e21..750076096 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -24,32 +24,43 @@ import io.vertx.core.Handler;
  */
 public final class CommandHandlerWrapper {
 
+    private final String tenantId;
     private final String deviceId;
     private final String gatewayId;
     private final Handler<CommandContext> commandHandler;
-    private final Handler<Void> remoteCloseHandler;
 
     /**
      * Creates a new CommandHandlerWrapper.
-     * 
-     * @param deviceId The identifier of the device that is the target of the commands being handled.
-     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is
-     *                  the target of the commands being handled, or {@code null} otherwise.
+     *
+     * @param tenantId The tenant id.
+     * @param deviceId The identifier of the device or gateway that is the target of the commands being handled.
+     * @param gatewayId The identifier of the gateway in case the handler is used as part of the gateway
+     *                  subscribing specifically for commands for the given device, or {@code null} otherwise.
+     *                  (A gateway subscribing for commands for all devices, that it may act on behalf of, would mean
+     *                  using a {@code null} value here and providing the gateway id in the <em>deviceId</em>
+     *                  parameter.)
      * @param commandHandler The command handler.
-     * @param remoteCloseHandler The handler to be invoked when the command consumer is closed remotely. May be
-     *            {@code null}.
-     * @throws NullPointerException If deviceId or commandHandler is {@code null}.
+     * @throws NullPointerException If tenantId, deviceId or commandHandler is {@code null}.
      */
-    public CommandHandlerWrapper(final String deviceId, final String gatewayId,
-            final Handler<CommandContext> commandHandler, final Handler<Void> remoteCloseHandler) {
+    public CommandHandlerWrapper(final String tenantId, final String deviceId, final String gatewayId,
+                                 final Handler<CommandContext> commandHandler) {
+        this.tenantId = Objects.requireNonNull(tenantId);
         this.deviceId = Objects.requireNonNull(deviceId);
         this.gatewayId = gatewayId;
         this.commandHandler = Objects.requireNonNull(commandHandler);
-        this.remoteCloseHandler = remoteCloseHandler;
     }
 
     /**
-     * Gets the identifier of the device to handle commands for.
+     * Gets the tenant identifier.
+     *
+     * @return The identifier.
+     */
+    public String getTenantId() {
+        return tenantId;
+    }
+
+    /**
+     * Gets the identifier of the device or gateway to handle commands for.
      *
      * @return The identifier.
      */
@@ -58,7 +69,8 @@ public final class CommandHandlerWrapper {
     }
 
     /**
-     * Gets the identifier of the gateway that the command target device is connected to.
+     * Gets the identifier of the gateway in case the handler is used by a gateway having specifically subscribed for
+     * commands for the device returned by {@link #getDeviceId()}.
      *
      * @return The identifier or {@code null}.
      */
@@ -75,15 +87,6 @@ public final class CommandHandlerWrapper {
         commandHandler.handle(commandContext);
     }
 
-    /**
-     * Invokes the handler for the case that the command consumer is closed remotely.
-     */
-    public void handleRemoteClose() {
-        if (remoteCloseHandler != null) {
-            remoteCloseHandler.handle(null);
-        }
-    }
-
     @Override
     public String toString() {
         return "CommandHandlerWrapper{" +
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
new file mode 100644
index 000000000..ac6ee0000
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java
@@ -0,0 +1,176 @@
+/*******************************************************************************
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;
+import org.eclipse.hono.client.CommandTargetMapper;
+import org.eclipse.hono.client.RegistrationClientFactory;
+import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.tracing.TracingHelper;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RegistrationConstants;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.tag.Tags;
+import io.vertx.core.Future;
+import io.vertx.core.json.JsonArray;
+import io.vertx.core.json.JsonObject;
+
+/**
+ * A component for mapping an incoming command to the gateway (if applicable)
+ * and protocol adapter instance that can handle it.
+ */
+public class CommandTargetMapperImpl implements CommandTargetMapper {
+
+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);
+
+    private final Tracer tracer;
+    private final AtomicBoolean initialized = new AtomicBoolean(false);
+    private RegistrationClientFactory registrationClientFactory;
+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;
+
+    /**
+     * Creates a new GatewayMapperImpl instance.
+     *
+     * @param tracer The tracer instance.
+     * @throws NullPointerException if tracer is {@code null}.
+     */
+    public CommandTargetMapperImpl(final Tracer tracer) {
+        this.tracer = Objects.requireNonNull(tracer);
+    }
+
+    @Override
+    public void initialize(final RegistrationClientFactory registrationClientFactory,
+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {
+        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);
+        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);
+        initialized.set(true);
+    }
+
+    @Override
+    public final Future<JsonObject> getTargetGatewayAndAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {
+        if (!initialized.get()) {
+            LOG.error("not initialized");
+            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
+        }
+        final Span span = TracingHelper
+                .buildChildSpan(tracer, context, "get target gateway and adapter instance",
+                        CommandTargetMapper.class.getSimpleName())
+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)
+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)
+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)
+                .start();
+
+        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)
+                .compose(client -> client.assertRegistration(deviceId, null, span.context()))
+                .recover(t -> {
+                    LOG.debug("Error getting registration assertion", t);
+                    return Future.failedFuture(t);
+                }).compose(registrationAssertionJson -> {
+                    final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);
+                    @SuppressWarnings("unchecked")
+                    final List<String> viaGateways = viaObject instanceof JsonArray
+                            ? new ArrayList<String>(((JsonArray) viaObject).getList())
+                            : Collections.emptyList();
+                    return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
+                            .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, span.context()))
+                            .compose(resultJson -> determineTargetInstanceJson(resultJson, deviceId, viaGateways, span));
+                }).map(result -> {
+                    span.finish();
+                    return result;
+                }).recover(t -> {
+                    LOG.debug("Error getting target gateway and adapter instance", t);
+                    TracingHelper.logError(span, t);
+                    Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(t));
+                    span.finish();
+                    return Future.failedFuture(t);
+                });
+    }
+
+    private Future<JsonObject> determineTargetInstanceJson(final JsonObject adapterInstancesJson, final String deviceId,
+            final List<String> viaGateways, final Span span) {
+        final JsonArray instancesArray = adapterInstancesJson.getJsonArray(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);
+        if (instancesArray == null || instancesArray.isEmpty()) {
+            return createAndLogInternalServerErrorFuture(span, "Invalid result JSON; field '"
+                    + DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES + "' is null or empty");
+        }
+
+        final JsonObject targetInstanceObject;
+        try {
+            if (instancesArray.size() == 1) {
+                targetInstanceObject = instancesArray.getJsonObject(0);
+            } else {
+                targetInstanceObject = chooseTargetGatewayAndAdapterInstance(instancesArray);
+            }
+        } catch (final ClassCastException e) {
+            return createAndLogInternalServerErrorFuture(span, "Invalid result JSON: " + e.toString());
+        }
+        final String targetDevice = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);
+        final String targetAdapterInstance = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);
+        if (targetDevice == null || targetAdapterInstance == null) {
+            return createAndLogInternalServerErrorFuture(span, "Invalid result JSON, missing target device and/or adapter instance");
+        }
+        if (!targetDevice.equals(deviceId)) {
+            // target device is a gateway
+            if (!viaGateways.contains(targetDevice)) {
+                return createAndLogInternalServerErrorFuture(span,
+                        "Invalid result JSON, target gateway " + targetDevice + " is not in via gateways list");
+            }
+            span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, targetDevice);
+        }
+
+        final String choiceInfo = instancesArray.size() > 1 ? " chosen from " + instancesArray.size() + " entries" : "";
+        final String gatewayInfo = !targetDevice.equals(deviceId) ? " gateway '" + targetDevice + "' and" : "";
+        final String infoMsg = String.format("command target%s:%s adapter instance '%s'", choiceInfo, gatewayInfo, targetAdapterInstance);
+        LOG.debug(infoMsg);
+        span.log(infoMsg);
+
+        span.setTag(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, targetAdapterInstance);
+        return Future.succeededFuture(targetInstanceObject);
+    }
+
+    private Future<JsonObject> createAndLogInternalServerErrorFuture(final Span span, final String errorMessage) {
+        LOG.error(errorMessage);
+        TracingHelper.logError(span, errorMessage);
+        return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
+    }
+
+    /**
+     * Chooses the target gateway and adapter instance from the given list of entries.
+     * <p>
+     * This method returns first entry from the given list.
+     * <p>
+     * Subclasses may override this method in order to apply a different algorithm.
+     *
+     * @param instancesArray The JSON array containing the target gateway and adapter instance entries to choose from.
+     * @return The chosen JSON object.
+     */
+    protected JsonObject chooseTargetGatewayAndAdapterInstance(final JsonArray instancesArray) {
+        return instancesArray.getJsonObject(0);
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
deleted file mode 100644
index 2db0c8f02..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.function.BiFunction;
-
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.DelegatedCommandSender;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * Handler for command messages that delegates command handling by setting a device-specific message target address and
- * sending the message to the downstream peer.
- * <p>
- * That way, further command handling is delegated to the {@link DestinationCommandConsumer} eventually.
- */
-public class DelegateViaDownstreamPeerCommandHandler implements Handler<CommandContext> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(DelegateViaDownstreamPeerCommandHandler.class);
-
-    private final BiFunction<String, String, Future<DelegatedCommandSender>> delegatedCommandSenderSupplier;
-
-    /**
-     * Creates a new DelegateViaDownstreamPeerCommandHandler.
-     *
-     * @param delegatedCommandSenderSupplier Function to get a Future with a sender to send the delegated command via
-     *            the downstream peer. The first function parameter is the tenant id, the second is the device id.
-     *            The function is supposed to create such a sender and, if successful, succeed the returned Future
-     *            with it. If sender creation failed, a failed Future is to be returned.
-     */
-    public DelegateViaDownstreamPeerCommandHandler(final BiFunction<String, String, Future<DelegatedCommandSender>> delegatedCommandSenderSupplier) {
-        this.delegatedCommandSenderSupplier = delegatedCommandSenderSupplier;
-    }
-
-    @Override
-    public void handle(final CommandContext commandContext) {
-
-        final Command command = commandContext.getCommand();
-        final String tenantId = command.getTenant();
-        final String deviceId = command.getDeviceId();
-        LOG.trace("delegate command for device {} to matching consumer via downstream peer", deviceId);
-
-        // send message to AMQP network
-        final Future<DelegatedCommandSender> delegatedCommandSender = delegatedCommandSenderSupplier.apply(tenantId, deviceId);
-        delegatedCommandSender.setHandler(cmdSenderResult -> {
-            if (cmdSenderResult.succeeded()) {
-                final DelegatedCommandSender sender = cmdSenderResult.result();
-                sender.sendCommandMessage(command, commandContext.getTracingContext()).setHandler(sendResult -> {
-                    if (sendResult.succeeded()) {
-                        // send succeeded - handle outcome
-                        final ProtonDelivery delegatedMsgDelivery = sendResult.result();
-                        LOG.trace("command for device {} sent to downstream peer; remote state of delivery: {}",
-                                deviceId, delegatedMsgDelivery.getRemoteState());
-                        commandContext.disposition(delegatedMsgDelivery.getRemoteState());
-                    } else {
-                        // failed to send message
-                        LOG.error("failed to send command message to downstream peer: {} [tenant: {}, device: {}]",
-                                sendResult.cause().getMessage(), tenantId, deviceId);
-                        TracingHelper.logError(commandContext.getCurrentSpan(),
-                                "failed to send command message to downstream peer: " + sendResult.cause());
-                        commandContext.release();
-                    }
-                    sender.close(c -> {});
-                });
-            } else {
-                // failed to create sender
-                LOG.error("failed to create sender for sending command message to downstream peer: {} [tenant: {}, device: {}]",
-                        cmdSenderResult.cause().getMessage(), tenantId, deviceId);
-                TracingHelper.logError(commandContext.getCurrentSpan(),
-                        "failed to create sender for sending command message to downstream peer: " + cmdSenderResult.cause());
-                commandContext.release();
-            }
-        });
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
index 8d5d88a23..2d617a5dd 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -184,33 +184,30 @@ public class DelegatedCommandSenderImpl extends AbstractSender implements Delega
         Objects.requireNonNull(command);
         final String replyToAddress = command.isOneWay() ? null
                 : String.format("%s/%s/%s", command.getReplyToEndpoint(), command.getTenant(), command.getReplyToId());
-
-        final Message rawMessage = createDelegatedCommandMessage(command.getCommandMessage(), replyToAddress);
-
-        final Span span = startSpan(spanContext, rawMessage);
+        final Message delegatedCommandMessage = createDelegatedCommandMessage(command.getCommandMessage(), replyToAddress);
+        final Span span = startSpan(spanContext, delegatedCommandMessage);
         span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, command.getTenant());
         if (command.isTargetedAtGateway()) {
+            MessageHelper.addProperty(delegatedCommandMessage, MessageHelper.APP_PROPERTY_CMD_VIA, command.getDeviceId());
             span.setTag(MessageHelper.APP_PROPERTY_DEVICE_ID, command.getOriginalDeviceId());
             span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, command.getDeviceId());
         } else {
             span.setTag(MessageHelper.APP_PROPERTY_DEVICE_ID, command.getDeviceId());
         }
-        TracingHelper.injectSpanContext(connection.getTracer(), span.context(), rawMessage);
+        TracingHelper.injectSpanContext(connection.getTracer(), span.context(), delegatedCommandMessage);
 
-        return runSendAndWaitForOutcomeOnContext(rawMessage, span);
+        return runSendAndWaitForOutcomeOnContext(delegatedCommandMessage, span);
     }
 
     /**
      * Gets the AMQP <em>target</em> address to use for sending the delegated command messages to.
      *
-     * @param tenantId The tenant identifier.
-     * @param deviceId The device identifier.
+     * @param adapterInstanceId The protocol adapter instance id.
      * @return The target address.
-     * @throws NullPointerException if tenant or device id is {@code null}.
+     * @throws NullPointerException if adapterInstanceId is {@code null}.
      */
-    static String getTargetAddress(final String tenantId, final String deviceId) {
-        return String.format("%s/%s/%s", CommandConstants.INTERNAL_COMMAND_ENDPOINT, Objects.requireNonNull(tenantId),
-                Objects.requireNonNull(deviceId));
+    static String getTargetAddress(final String adapterInstanceId) {
+        return CommandConstants.INTERNAL_COMMAND_ENDPOINT + "/" + Objects.requireNonNull(adapterInstanceId);
     }
 
     private static Message createDelegatedCommandMessage(final Message originalMessage, final String replyToAddress) {
@@ -225,21 +222,20 @@ public class DelegatedCommandSenderImpl extends AbstractSender implements Delega
      * Creates a new sender for sending the delegated command messages to the AMQP network.
      *
      * @param con The connection to the AMQP network.
-     * @param tenantId The tenant identifier.
-     * @param deviceId The device identifier.
+     * @param adapterInstanceId The protocol adapter instance id.
      * @param closeHook A handler to invoke if the peer closes the link unexpectedly (may be {@code null}).
      * @return A future indicating the result of the creation attempt.
-     * @throws NullPointerException if con is {@code null}.
+     * @throws NullPointerException if con or adapterInstanceId is {@code null}.
      */
     public static Future<DelegatedCommandSender> create(
             final HonoConnection con,
-            final String tenantId,
-            final String deviceId,
+            final String adapterInstanceId,
             final Handler<String> closeHook) {
 
         Objects.requireNonNull(con);
+        Objects.requireNonNull(adapterInstanceId);
 
-        final String targetAddress = getTargetAddress(tenantId, deviceId);
+        final String targetAddress = getTargetAddress(adapterInstanceId);
         return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook)
                 .map(sender -> new DelegatedCommandSenderImpl(con, sender));
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DestinationCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/DestinationCommandConsumer.java
deleted file mode 100644
index b74060a6b..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/DestinationCommandConsumer.java
+++ /dev/null
@@ -1,350 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ResourceConflictException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonDelivery;
-import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * A wrapper around an AMQP receiver link for consuming commands directed to a gateway or device.
- * <p>
- * Includes special support for gateways:
- * If a gateway creates multiple command subscriptions for specific devices connected to it, the one
- * <em>GatewayOrDeviceSpecificCommandConsumer</em> instance created for the gateway will contain
- * multiple {@link CommandHandlerWrapper} instances containing the device-specific handlers for
- * the commands.
- * <p>
- * In a non-gateway scenario, the <em>GatewayOrDeviceSpecificCommandConsumer</em> instance will
- * just contain the one {@link CommandHandlerWrapper} instance for handling commands to the device.
- */
-public final class DestinationCommandConsumer extends CommandConsumer {
-
-    private static final Logger LOG = LoggerFactory.getLogger(DestinationCommandConsumer.class);
-
-    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();
-    private final String tenantId;
-    private final String gatewayOrDeviceId;
-    private final AtomicBoolean closedCalled = new AtomicBoolean();
-
-    private DestinationCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver,
-            final String tenantId, final String gatewayOrDeviceId) {
-        super(connection, receiver);
-        this.tenantId = tenantId;
-        this.gatewayOrDeviceId = Objects.requireNonNull(gatewayOrDeviceId);
-    }
-
-    /**
-     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
-     *
-     * @param deviceId The identifier of the device that is the target of the commands being handled.
-     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is
-     *                  the target of the commands being handled, or {@code null} otherwise.
-     * @param commandHandler The command handler.
-     * @param remoteCloseHandler The handler to be invoked when the command consumer is closed remotely. May be
-     *            {@code null}.
-     * @return A future indicating whether adding the handler was successful.
-     *         <p>
-     *         The future will be failed with a {@link ResourceConflictException}
-     *         if the consumer already contains a handler with the same device id.
-     *         <p>
-     *         Otherwise, the future will be succeeded.
-     * @throws NullPointerException If deviceId or commandHandler is {@code null}.
-     * @throws IllegalArgumentException If the device or gateway id of the given handler does
-     *                                  not match this command consumer.
-     */
-    public Future<Void> addDeviceSpecificCommandHandler(final String deviceId, final String gatewayId,
-            final Handler<CommandContext> commandHandler, final Handler<Void> remoteCloseHandler) {
-        return addDeviceSpecificCommandHandler(new CommandHandlerWrapper(deviceId, gatewayId, commandHandler, remoteCloseHandler));
-    }
-
-    /**
-     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
-     * 
-     * @param handler The consumer to add.
-     * @return A future indicating whether adding the handler was successful.
-     *         <p>
-     *         The future will be failed with a {@link ResourceConflictException}
-     *         if the consumer already contains a handler with the same device id.
-     *         <p>
-     *         Otherwise, the future will be succeeded.
-     * @throws NullPointerException If the given handler is {@code null}.
-     * @throws IllegalArgumentException If the device or gateway id of the given handler does
-     *                                  not match this command consumer.
-     */
-    public Future<Void> addDeviceSpecificCommandHandler(final CommandHandlerWrapper handler) {
-        Objects.requireNonNull(handler);
-        if (!handlerIsForConsumerGatewayOrDevice(handler.getDeviceId(), handler.getGatewayId())) {
-            LOG.error("cannot add handler with non-matching device/gateway id [consumer device id: {}, handler: {}",
-                    gatewayOrDeviceId, handler);
-            throw new IllegalArgumentException("invalid handler given");
-        }
-        if (commandHandlers.containsKey(handler.getDeviceId())) {
-            LOG.debug("cannot create concurrent command consumer [device-id: {}]", handler.getDeviceId());
-            return Future.failedFuture(new ResourceConflictException("message consumer already in use"));
-        }
-        commandHandlers.put(handler.getDeviceId(), handler);
-        return Future.succeededFuture(null);
-    }
-
-    private boolean handlerIsForConsumerGatewayOrDevice(final String handlerDeviceId, final String handlerGatewayId) {
-        if (handlerGatewayId == null) {
-            // the given handler is for commands directed directly at a device (no gateway in between)
-            // => then the handler must be for the device for which this consumer receives command messages
-            return this.gatewayOrDeviceId.equals(handlerDeviceId);
-        } else {
-            // the given handler is for commands directed at a device behind a gateway
-            // => then the given gateway must be the same as the one for which this consumer receives command messages
-            return this.gatewayOrDeviceId.equals(handlerGatewayId);
-        }
-    }
-
-    /**
-     * Checks whether the Proton receiver behind this consumer is open.
-     *
-     * @return {@code true} if this consumer is alive.
-     */
-    public boolean isAlive() {
-        return receiver.isOpen() && !closedCalled.get();
-    }
-
-    private void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {
-        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case
-        final String originalDeviceId = msg.getAddress() != null
-                ? ResourceIdentifier.fromString(msg.getAddress()).getResourceId()
-                : null;
-        if (originalDeviceId == null) {
-            LOG.debug("address of command message is invalid: {}", msg.getAddress());
-            final Rejected rejected = new Rejected();
-            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "invalid command target address"));
-            delivery.disposition(rejected, true);
-            return;
-        }
-        final Command command = Command.from(msg, tenantId, gatewayOrDeviceId);
-        // command.isValid() check not done here - it is to be done in the command handler
-        final Tracer tracer = connection.getTracer();
-        // try to extract Span context from incoming message
-        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);
-        final String gatewayId = gatewayOrDeviceId.equals(originalDeviceId) ? null : gatewayOrDeviceId;
-        final Span currentSpan = createSpan("send command", tenantId, originalDeviceId,
-                gatewayId, tracer, spanContext);
-        logReceivedCommandToSpan(command, currentSpan);
-
-        // look for a handler with the original device id first
-        final CommandHandlerWrapper commandHandler = getCommandHandlerOrDefault(originalDeviceId);
-        if (commandHandler != null) {
-            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));
-        } else {
-            // no command handler found
-            if (gatewayId != null && !containsCommandHandler(gatewayOrDeviceId) && !commandHandlers.isEmpty()) {
-                LOG.debug("no command handler found; target gateway {} is only subscribed for commands to other specific devices, not for device {} [tenant-id: {}]",
-                        gatewayId, originalDeviceId, tenantId);
-                TracingHelper.logError(currentSpan, "no command handler found; target gateway is only subscribed for commands to other specific devices");
-            } else {
-                LOG.error("no command handler found for command targeted at device {}, gateway {} [tenant-id: {}]",
-                        originalDeviceId, gatewayId, tenantId);
-                TracingHelper.logError(currentSpan, "no command handler found for command");
-            }
-            currentSpan.finish();
-            ProtonHelper.released(delivery, true);
-        }
-    }
-
-    /**
-     * Checks whether a handler exists for the given device id.
-     * 
-     * @param deviceId The device id.
-     * @return {@code true} if a handler exists.
-     */
-    public boolean containsCommandHandler(final String deviceId) {
-        return commandHandlers.containsKey(deviceId);
-    }
-
-    /**
-     * Gets a handler for either the given device id or for the device id of <em>this</em>
-     * command consumer.
-     * 
-     * @param gatewayManagedDeviceId The id of a device connected to a gateway. May be {@code null}.<p>
-     *                               In case the command, for which to return the appropriate handler, is
-     *                               directed at a gateway-managed device, the id of this device is to be
-     *                               given here. Otherwise {@code null} is to be used.<p>
-     *                               If a handler for the given device exists, it will be returned here.
-     *                               Otherwise the handler for the device id of <em>this</em> command consumer
-     *                               will be returned (if such a handler is set).
-     * @return The handler or {@code null}.
-     */
-    public CommandHandlerWrapper getCommandHandlerOrDefault(final String gatewayManagedDeviceId) {
-        if (gatewayManagedDeviceId != null && !gatewayManagedDeviceId.equals(gatewayOrDeviceId)) {
-            final CommandHandlerWrapper handler = commandHandlers.get(gatewayManagedDeviceId);
-            if (handler != null) {
-                LOG.trace("using device specific command handler for {} [consumer device-id: {}]",
-                        gatewayManagedDeviceId, gatewayOrDeviceId);
-                return handler;
-            }
-        }
-        return commandHandlers.get(gatewayOrDeviceId);
-    }
-
-    /**
-     * Gets the contained command handlers.
-     *
-     * @return The command handlers.
-     */
-    public Collection<CommandHandlerWrapper> getCommandHandlers() {
-        return commandHandlers.values();
-    }
-
-    private void onRemoteClose(final Handler<String> remoteCloseHandler, final String event) {
-        remoteCloseHandler.handle(event);
-        commandHandlers.values().forEach(handler -> {
-            handler.handleRemoteClose();
-        });
-    }
-
-    /**
-     * Removes the handler for the given device id and closes this consumer if there are
-     * no remaining handlers left.
-     *
-     * @param deviceId The device id of the handler to remove.
-     * @param resultHandler A handler that is called back with the result of the operation.
-     */
-    public void removeHandlerAndCloseConsumerIfEmpty(final String deviceId, final Handler<AsyncResult<Void>> resultHandler) {
-        final CommandHandlerWrapper removedHandler = commandHandlers.remove(deviceId);
-        LOG.trace("Removed handler for device {} on consumer {}: {}", deviceId, this.gatewayOrDeviceId, removedHandler != null);
-        if (removedHandler != null && commandHandlers.isEmpty()) {
-            LOG.trace("all command handlers removed for consumer, closing link [consumer device-id: {}, device-id of removed handler: {}]",
-                    this.gatewayOrDeviceId, deviceId);
-            closedCalled.set(true);
-            close(resultHandler);
-        } else if (resultHandler != null) {
-            resultHandler.handle(Future.succeededFuture());
-        }
-    }
-
-    /**
-     * Creates a new command consumer.
-     * <p>
-     * The handler to be invoked by the created consumer will have to be subsequently added
-     * via the {@link #addDeviceSpecificCommandHandler(String, String, Handler, Handler)} method.
-     * <p>
-     * The underlying receiver link will be created with the following properties:
-     * <ul>
-     * <li><em>auto accept</em> will be set to {@code true}</li>
-     * <li><em>pre-fetch size</em> will be set to the number of initial credits configured
-     * for the given connection.</li>
-     * </ul>
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consume commands from.
-     * @param gatewayOrDeviceId The device for which the commands should be consumed.
-     * @param localCloseHandler A handler to be invoked after the link has been closed
-     *                     at this peer's request using the {@link #close(Handler)} method.
-     *                     The handler will be invoked with the link's source address <em>after</em>
-     *                     the link has been closed but <em>before</em> the handler that has been
-     *                     passed into the <em>close</em> method is invoked.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the remote peer's request. The handler will be invoked with the
-     *                     link's source address.
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters are {@code null}.
-     */
-    public static Future<DestinationCommandConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final String gatewayOrDeviceId,
-            final Handler<String> localCloseHandler,
-            final Handler<String> remoteCloseHandler) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(gatewayOrDeviceId);
-        Objects.requireNonNull(localCloseHandler);
-        Objects.requireNonNull(remoteCloseHandler);
-
-        LOG.trace("creating new command consumer [tenant-id: {}, device-id: {}]", tenantId, gatewayOrDeviceId);
-
-        final String address = ResourceIdentifier.from(CommandConstants.INTERNAL_COMMAND_ENDPOINT, tenantId, gatewayOrDeviceId).toString();
-
-        final AtomicReference<DestinationCommandConsumer> consumerRef = new AtomicReference<>();
-
-        return con.createReceiver(
-                address,
-                ProtonQoS.AT_LEAST_ONCE,
-                (delivery, msg) -> {
-
-                    final DestinationCommandConsumer consumer = consumerRef.get();
-                    if (consumer == null) {
-                        // sender has sent message before we have sent credit
-                        LOG.error("rejecting received message received before having granted credits [tenant-id: {}, device-id: {}]",
-                                tenantId, gatewayOrDeviceId);
-                        ProtonHelper.released(delivery, true);
-                        return;
-                    }
-                    consumer.handleCommandMessage(msg, delivery);
-                },
-                con.getConfig().getInitialCredits(),
-                false, // no auto-accept
-                sourceAddress -> { // remote close hook
-                    LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed remotely",
-                            tenantId, gatewayOrDeviceId);
-                    final DestinationCommandConsumer consumer = consumerRef.get();
-                    if (consumer != null) {
-                        consumer.onRemoteClose(remoteCloseHandler, sourceAddress);
-                    }
-                }).map(receiver -> {
-                    LOG.debug("successfully created command consumer [{}]", address);
-                    final DestinationCommandConsumer consumer = new DestinationCommandConsumer(
-                            con, receiver, tenantId, gatewayOrDeviceId);
-                    consumerRef.set(consumer);
-                    consumer.setLocalCloseHandler(sourceAddress -> {
-                        LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed locally",
-                                tenantId, gatewayOrDeviceId);
-                        localCloseHandler.handle(sourceAddress);
-                    });
-                    return consumer;
-                }).recover(t -> {
-                    LOG.debug("failed to create command consumer [tenant-id: {}, device-id: {}]",
-                            tenantId, gatewayOrDeviceId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java
index 45f8ea9c9..53d08895d 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -14,11 +14,10 @@
 package org.eclipse.hono.client.impl;
 
 import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Supplier;
 
 import org.eclipse.hono.client.MessageConsumer;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
@@ -27,91 +26,43 @@ import io.vertx.core.Handler;
 /**
  * Represents the device specific command consumer used in protocol adapters.
  * <p>
- * Delegates method invocations to the supplied command consumer that wraps the actual Proton receiver.
+ * Delegates an invocation of the {@link #close(Handler)} to the action supplied in the constructor.
  */
+// TODO rename; implement a different interface instead, only providing the close(Handler) method
 public final class DeviceSpecificCommandConsumer implements MessageConsumer {
 
-    private static final Logger LOG = LoggerFactory.getLogger(DeviceSpecificCommandConsumer.class);
-
-    private final Supplier<DestinationCommandConsumer> delegateSupplier;
-    private final String deviceId;
+    private final Supplier<Future<Void>> onCloseAction;
+    private final AtomicBoolean closeCalled = new AtomicBoolean(false);
 
     /**
      * Creates a new DeviceSpecificCommandConsumer.
      *
-     * @param delegateSupplier Supplies the command consumer that wraps the actual Proton receiver.
-     * @param deviceId The device identifier.
-     * @throws NullPointerException If delegateSupplier or deviceId is {@code null}.
-     */
-    public DeviceSpecificCommandConsumer(
-            final Supplier<DestinationCommandConsumer> delegateSupplier, final String deviceId) {
-        this.delegateSupplier = Objects.requireNonNull(delegateSupplier);
-        this.deviceId = Objects.requireNonNull(deviceId);
-    }
-
-    /**
-     * Gets the current consumer delegate.
-     * <p>
-     * {@code null} may be returned here if {@link #close(Handler)} has already been invoked on this
-     * consumer (and the delegate consumer got closed as a consequence) or if the delegate consumer
-     * was remotely closed and no re-creation of the consumer (e.g. as part of a liveness check) has
-     * happened (yet).
-     *
-     * @return The consumer instance or {@code null}.
+     * @param onCloseAction The action to invoke when {@link #close(Handler)} is called.
+     * @throws NullPointerException If onCloseAction is {@code null}.
      */
-    private DestinationCommandConsumer getDelegate() {
-        return delegateSupplier.get();
+    public DeviceSpecificCommandConsumer(final Supplier<Future<Void>> onCloseAction) {
+        this.onCloseAction = Objects.requireNonNull(onCloseAction);
     }
 
-    /**
-     * {@inheritDoc}
-     * <p>
-     * Calls the appropriate close handler and closes the outer consumer instance if that contains
-     * no further handlers.
-     */
     @Override
     public void close(final Handler<AsyncResult<Void>> closeHandler) {
-        final DestinationCommandConsumer delegate = getDelegate();
-        if (delegate != null) {
-            delegate.removeHandlerAndCloseConsumerIfEmpty(deviceId, closeHandler);
-        } else {
-            LOG.debug("cannot delegate close() invocation; actual consumer not available [consumer device-id {}]",
-                    deviceId);
+        if (closeCalled.compareAndSet(false, true)) {
+            final Future<Void> onCloseActionFuture = onCloseAction.get();
             if (closeHandler != null) {
-                closeHandler.handle(Future.failedFuture("actual consumer not available"));
+                onCloseActionFuture.setHandler(closeHandler);
             }
+        } else if (closeHandler != null) {
+            closeHandler.handle(Future.succeededFuture());
         }
     }
 
-    /**
-     * {@inheritDoc}
-     * <p>
-     * Calls the corresponding method on the outer consumer instance.
-     */
     @Override
     public void flow(final int credits) throws IllegalStateException {
-        final DestinationCommandConsumer delegate = getDelegate();
-        if (delegate != null) {
-            delegate.flow(credits);
-        } else {
-            LOG.debug("cannot delegate flow() invocation; actual consumer not available [consumer device-id {}]",
-                    deviceId);
-        }
+        // no-op
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * @return The remaining credit of the outer consumer instance.
-     */
     @Override
     public int getRemainingCredit() {
-        final DestinationCommandConsumer delegate = getDelegate();
-        if (delegate == null) {
-            LOG.debug("cannot delegate getRemainingCredit() invocation; actual consumer not available [consumer device-id {}]",
-                    deviceId);
-            return 0;
-        }
-        return delegate.getRemainingCredit();
+        return -1;
     }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
deleted file mode 100644
index 0014cec42..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-import java.util.Objects;
-
-import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.ConnectionLifecycle;
-import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.GatewayMapper;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.ReconnectListener;
-import org.eclipse.hono.client.RegistrationClientFactory;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.MessageHelper;
-import org.eclipse.hono.util.RegistrationConstants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.opentracing.tag.Tags;
-import io.vertx.core.AsyncResult;
-import io.vertx.core.CompositeFuture;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-
-/**
- * A component that maps a given device to the gateway through which data was last published for the given device.
- */
-public class GatewayMapperImpl implements GatewayMapper {
-
-    private static final Logger LOG = LoggerFactory.getLogger(GatewayMapperImpl.class);
-
-    private final RegistrationClientFactory registrationClientFactory;
-    private final BasicDeviceConnectionClientFactory deviceConnectionClientFactory;
-    private final Tracer tracer;
-
-    /**
-     * Creates a new GatewayMapperImpl instance.
-     *
-     * @param registrationClientFactory The factory to create a registration client instance.
-     * @param deviceConnectionClientFactory The factory to create a device connection client instance.
-     * @param tracer The tracer instance.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    public GatewayMapperImpl(
-            final RegistrationClientFactory registrationClientFactory,
-            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory,
-            final Tracer tracer) {
-
-        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);
-        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);
-        this.tracer = Objects.requireNonNull(tracer);
-    }
-
-    @Override
-    public Future<String> getMappedGatewayDevice(final String tenantId, final String deviceId, final SpanContext context) {
-
-        final Span span = TracingHelper.buildChildSpan(tracer, context, "get mapped gateway", GatewayMapper.class.getSimpleName())
-                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)
-                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)
-                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)
-                .start();
-
-        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)
-                .compose(client -> client.assertRegistration(deviceId, null, span.context()))
-            .recover(t -> {
-                LOG.debug("Error getting registration assertion", t);
-                return Future.failedFuture(t);
-            })
-            .compose(registrationAssertionJson -> {
-                final Promise<String> mappedGatewayPromise = Promise.promise();
-                final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);
-                final JsonArray viaArray = viaObject instanceof JsonArray ? (JsonArray) viaObject : null;
-                if (viaArray != null && !viaArray.isEmpty()) {
-                    // get last-known gateway
-                    deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId).compose(client -> {
-                        return client.getLastKnownGatewayForDevice(deviceId, span.context());
-                    }).setHandler(ar -> {
-                        if (ar.succeeded()) {
-                            final JsonObject lastKnownGatewayJson = ar.result();
-                            final String mappedGatewayId = lastKnownGatewayJson.getString(DeviceConnectionConstants.FIELD_GATEWAY_ID);
-                            // check if mappedGatewayId is in 'via' gateways
-                            if (viaArray.contains(mappedGatewayId) || deviceId.equals(mappedGatewayId)) {
-                                LOG.trace("returning mapped gateway [{}] for device [{}]", mappedGatewayId, deviceId);
-                                mappedGatewayPromise.complete(mappedGatewayId);
-                            } else {
-                                LOG.debug("mapped gateway [{}] for device [{}] is not contained in device's 'via' gateways",
-                                        mappedGatewayId, deviceId);
-                                mappedGatewayPromise.fail(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,
-                                        "mapped gateway not found in gateways defined for device"));
-                            }
-                        } else {
-                            // getting the last known gateway failed
-                            if (ar.cause() instanceof ServiceInvocationException
-                                    && ((ServiceInvocationException) ar.cause()).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-                                if (viaArray.size() == 1) {
-                                    final String singleDefinedGateway = viaArray.getString(0);
-                                    LOG.trace("no last known gateway found for device [{}]; returning single defined 'via' gateway [{}]",
-                                            deviceId, singleDefinedGateway);
-                                    span.log("no last known gateway found, returning single defined 'via' gateway");
-                                    mappedGatewayPromise.complete(singleDefinedGateway);
-                                } else {
-                                    LOG.trace("no last known gateway found for device [{}] and device has multiple gateways defined", deviceId);
-                                    mappedGatewayPromise.fail(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,
-                                            "no last known gateway found"));
-                                }
-                            } else {
-                                LOG.debug("error getting last known gateway for device [{}]", deviceId, ar.cause());
-                                mappedGatewayPromise.fail(ar.cause() instanceof ServiceInvocationException ? ar.cause()
-                                        : new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
-                            }
-                        }
-                    });
-                } else {
-                    // device has an empty "via" entry => return device id itself
-                    LOG.trace("device [{}] has empty 'via' entry", deviceId);
-                    mappedGatewayPromise.complete(deviceId);
-                }
-                return mappedGatewayPromise.future()
-                        .map(result -> {
-                            span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, result);
-                            span.finish();
-                            return result;
-                        });
-            }).recover(t -> {
-                TracingHelper.logError(span, t);
-                Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(t));
-                span.finish();
-                return Future.failedFuture(t);
-            });
-    }
-
-    // ------------- ConnectionLifecycle methods ------------
-
-    @Override
-    public Future<HonoConnection> connect() {
-        final Future<HonoConnection> registrationFuture = registrationClientFactory.connect();
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            final Future<?> deviceConnectionFuture = ((ConnectionLifecycle<?>) deviceConnectionClientFactory).connect();
-            return CompositeFuture.all(registrationFuture, deviceConnectionFuture)
-                    .map(ok -> registrationFuture.result());
-        } else {
-            return registrationFuture;
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void addDisconnectListener(final DisconnectListener<HonoConnection> listener) {
-        registrationClientFactory.addDisconnectListener(listener);
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            ((ConnectionLifecycle<HonoConnection>) deviceConnectionClientFactory).addDisconnectListener(listener);
-        }
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void addReconnectListener(final ReconnectListener<HonoConnection> listener) {
-        registrationClientFactory.addReconnectListener(listener);
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            ((ConnectionLifecycle<HonoConnection>) deviceConnectionClientFactory).addReconnectListener(listener);
-        }
-    }
-
-    @Override
-    public Future<Void> isConnected() {
-        final Future<Void> registrationFuture = registrationClientFactory.isConnected();
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            final Future<Void> deviceConnectionFuture = ((ConnectionLifecycle<?>) deviceConnectionClientFactory).isConnected();
-            return CompositeFuture.all(registrationFuture, deviceConnectionFuture)
-                    .mapEmpty();
-        } else {
-            return registrationFuture;
-        }
-    }
-
-    @Override
-    public Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
-        final Future<Void> registrationFuture = registrationClientFactory.isConnected(waitForCurrentConnectAttemptTimeout);
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            final Future<?> deviceConnectionFuture = ((ConnectionLifecycle<?>) deviceConnectionClientFactory).isConnected(waitForCurrentConnectAttemptTimeout);
-            return CompositeFuture.all(registrationFuture, deviceConnectionFuture).mapEmpty();
-        } else {
-            return registrationFuture;
-        }
-    }
-
-    @Override
-    public void disconnect() {
-        registrationClientFactory.disconnect();
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            ((ConnectionLifecycle<?>) deviceConnectionClientFactory).disconnect();
-        }
-    }
-
-    @Override
-    public void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
-
-        final Promise<Void> registrationDisconnectPromise = Promise.promise();
-        final Promise<Void> deviceConnectionDisconnectPromise = Promise.promise();
-
-        registrationClientFactory.disconnect(registrationDisconnectPromise);
-
-        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
-            ((ConnectionLifecycle<?>) deviceConnectionClientFactory).disconnect(deviceConnectionDisconnectPromise);
-        } else {
-            deviceConnectionDisconnectPromise.complete();
-        }
-
-        CompositeFuture.all(registrationDisconnectPromise.future(), deviceConnectionDisconnectPromise.future())
-        .map(ok -> (Void) null)
-        .setHandler(completionHandler);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMappingCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/GatewayMappingCommandHandler.java
deleted file mode 100644
index e0831ff30..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMappingCommandHandler.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.net.HttpURLConnection;
-
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.GatewayMapper;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.Constants;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-
-/**
- * Command handler that maps commands to gateway devices (if applicable) and passes the commands to a given
- * next command handler.
- */
-public class GatewayMappingCommandHandler implements Handler<CommandContext> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(GatewayMappingCommandHandler.class);
-
-    private final GatewayMapper gatewayMapper;
-    private final Handler<CommandContext> nextCommandHandler;
-
-    /**
-     * Creates a new GatewayMappingCommandHandler instance.
-     * 
-     * @param gatewayMapper The component mapping a command device id to the corresponding gateway device id.
-     * @param nextCommandHandler The handler to invoke with the mapped command.
-     */
-    public GatewayMappingCommandHandler(final GatewayMapper gatewayMapper, final Handler<CommandContext> nextCommandHandler) {
-        this.gatewayMapper = gatewayMapper;
-        this.nextCommandHandler = nextCommandHandler;
-    }
-
-    @Override
-    public void handle(final CommandContext originalCommandContext) {
-        final Command originalCommand = originalCommandContext.getCommand();
-        if (!originalCommand.isValid()) {
-            originalCommandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "malformed command message"));
-            return;
-        }
-        final String tenantId = originalCommand.getTenant();
-        final String originalDeviceId = originalCommand.getDeviceId();
-        // determine last used gateway device id
-        LOG.trace("determine mapped gateway (if any) to use for received command [{}]", originalCommand);
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, originalDeviceId,
-                originalCommandContext.getTracingContext());
-
-        mappedGatewayDeviceFuture.setHandler(mappedGatewayResult -> {
-            if (mappedGatewayResult.succeeded()) {
-                final String mappedGatewayId = mappedGatewayResult.result();
-                final CommandContext commandContext;
-                if (mappedGatewayId.equals(originalDeviceId)) {
-                    LOG.trace("gateway mapper returned original device {}", originalDeviceId);
-                    commandContext = originalCommandContext;
-                } else {
-                    LOG.trace("determined mapped gateway {} for device {}", mappedGatewayId, originalDeviceId);
-                    originalCommandContext.getCurrentSpan().log("determined mapped gateway " + mappedGatewayId);
-                    if (!originalCommand.isOneWay()) {
-                        originalCommand.getCommandMessage().setReplyTo(String.format("%s/%s/%s",
-                                CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, originalCommand.getReplyToId()));
-                    }
-                    final Command command = Command.from(originalCommand.getCommandMessage(), tenantId, mappedGatewayId);
-                    commandContext = CommandContext.from(command, originalCommandContext.getDelivery(),
-                            originalCommandContext.getCurrentSpan());
-                }
-                nextCommandHandler.handle(commandContext);
-            } else {
-                if (mappedGatewayResult.cause() instanceof ServiceInvocationException
-                        && ((ServiceInvocationException) mappedGatewayResult.cause()).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
-                    LOG.debug("no mapped gateway set for device {}", originalDeviceId);
-                    TracingHelper.logError(originalCommandContext.getCurrentSpan(),
-                            "no mapped gateway set for device " + originalDeviceId);
-                } else {
-                    LOG.debug("error getting mapped gateway for device {}", originalDeviceId, mappedGatewayResult.cause());
-                    TracingHelper.logError(originalCommandContext.getCurrentSpan(),
-                            "error getting mapped gateway for device: " + mappedGatewayResult.cause());
-                }
-                originalCommandContext.release();
-            }
-        });
-    }
-
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandConsumer.java
deleted file mode 100644
index 5081047be..000000000
--- a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandConsumer.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import java.util.Objects;
-
-import org.eclipse.hono.client.CommandConsumerFactory;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-/**
- * A wrapper around an AMQP receiver link for consuming commands on a tenant-scoped address.
- * <p>
- * This class is used by the default {@link CommandConsumerFactory} implementation to receive commands from northbound
- * applications. The received commands will be mapped to a matching gateway and delegated to the
- * {@link DestinationCommandConsumer} if applicable.
- */
-public class MappingAndDelegatingCommandConsumer extends CommandConsumer {
-
-    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandConsumer.class);
-
-    private MappingAndDelegatingCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {
-
-        super(connection, receiver);
-    }
-
-    /**
-     * Creates a new command consumer.
-     *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consume commands from.
-     * @param messageHandler The handler to invoke for each message received.
-     * @param localCloseHandler A handler to be invoked after the link has been closed
-     *                     at this peer's request using the {@link #close(Handler)} method.
-     *                     The handler will be invoked with the link's source address <em>after</em>
-     *                     the link has been closed but <em>before</em> the handler that has been
-     *                     passed into the <em>close</em> method is invoked.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the remote peer's request. The handler will be invoked with the
-     *                     link's source address.
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters other than tracer are {@code null}.
-     */
-    public static Future<MappingAndDelegatingCommandConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final ProtonMessageHandler messageHandler,
-            final Handler<String> localCloseHandler,
-            final Handler<String> remoteCloseHandler) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(messageHandler);
-        Objects.requireNonNull(remoteCloseHandler);
-
-        LOG.trace("creating new MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId);
-
-        final String address = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
-
-        return con.createReceiver(
-                address,
-                ProtonQoS.AT_LEAST_ONCE,
-                messageHandler,
-                con.getConfig().getInitialCredits(),
-                false, // no auto-accept
-                sourceAddress -> {
-                    LOG.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed remotely", tenantId);
-                    remoteCloseHandler.handle(sourceAddress);
-                }).map(receiver -> {
-                    LOG.debug("successfully created MappingAndDelegatingCommandConsumer [{}]", address);
-                    final MappingAndDelegatingCommandConsumer consumer = new MappingAndDelegatingCommandConsumer(con, receiver);
-                    consumer.setLocalCloseHandler(sourceAddress -> {
-                        LOG.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed locally", tenantId);
-                        localCloseHandler.handle(sourceAddress);
-                    });
-                    return consumer;
-                }).recover(t -> {
-                    LOG.debug("failed to create MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId, t);
-                    return Future.failedFuture(t);
-                });
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
new file mode 100644
index 000000000..40e43438b
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
@@ -0,0 +1,286 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.net.HttpURLConnection;
+import java.util.Objects;
+
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.Command;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.client.CommandTargetMapper;
+import org.eclipse.hono.client.DelegatedCommandSender;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.tracing.TracingHelper;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.ResourceIdentifier;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.json.JsonObject;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * Handler for commands received at the tenant-specific address.
+ */
+public class MappingAndDelegatingCommandHandler {
+
+    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandHandler.class);
+
+    /**
+     * Used for integration tests (with only a single instance of each protocol adapter):
+     * <p>
+     * System property value defining whether incoming command messages on the tenant
+     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific
+     * consumer even if there is a local handler for the command.<p>
+     * The second condition for the rerouting to take place is that the command message
+     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application
+     * property with a {@code true} value.
+     */
+    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean
+            .valueOf(System.getProperty("enableForcedCommandRerouting", "false"));
+    /**
+     * Name of the boolean command message application property with which commands are
+     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.
+     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property
+     * is set to {@code true}.
+     */
+    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = "force-command-rerouting";
+
+    private final HonoConnection connection;
+    private final CommandTargetMapper commandTargetMapper;
+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;
+    private final String adapterInstanceId;
+    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;
+
+    /**
+     * Creates a new MappingAndDelegatingCommandHandler instance.
+     *
+     * @param connection The connection to the AMQP network.
+     * @param commandTargetMapper The mapper component to determine the command target.
+     * @param adapterInstanceCommandHandler The handler to delegate command handling to if the command is to be
+     *                                      handled by the local adapter instance.
+     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    public MappingAndDelegatingCommandHandler(final HonoConnection connection,
+            final CommandTargetMapper commandTargetMapper,
+            final AdapterInstanceCommandHandler adapterInstanceCommandHandler, final String adapterInstanceId) {
+        this.connection = Objects.requireNonNull(connection);
+        this.commandTargetMapper = Objects.requireNonNull(commandTargetMapper);
+        this.adapterInstanceCommandHandler = Objects.requireNonNull(adapterInstanceCommandHandler);
+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);
+
+        this.delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());
+    }
+
+    /**
+     * Determines the target gateway (if applicable) and protocol adapter instance for an incoming command
+     * and delegates the command either to the local AdapterInstanceCommandHandler or to the resulting
+     * protocol adapter instance.
+     *
+     * @param tenantId The tenant id.
+     * @param originalMessageDelivery The delivery of the command message.
+     * @param message The command message.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    public void mapAndDelegateIncomingCommandMessage(final String tenantId,
+            final ProtonDelivery originalMessageDelivery, final Message message) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(originalMessageDelivery);
+        Objects.requireNonNull(message);
+
+        // this is the place where a command message on the "command/tenant" address arrives *first*
+        final String deviceId = message.getAddress() != null ? ResourceIdentifier.fromString(message.getAddress()).getResourceId() : null;
+        if (deviceId == null) {
+            LOG.debug("address of command message is invalid: {}", message.getAddress());
+            final Rejected rejected = new Rejected();
+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "invalid command target address"));
+            originalMessageDelivery.disposition(rejected, true);
+            return;
+        }
+        final Command command = Command.from(message, tenantId, deviceId);
+        LOG.trace("received command [{}]", command);
+        if (!command.isValid()) {
+            LOG.debug("received command message is invalid: {}", command);
+        }
+        final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);
+        final Span currentSpan = CommandConsumer.createSpan("map and delegate command", tenantId, deviceId, null,
+                connection.getTracer(), spanContext);
+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);
+        final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);
+        mapAndDelegateIncomingCommand(tenantId, deviceId, commandContext);
+    }
+
+    private void mapAndDelegateIncomingCommand(final String tenantId, final String originalDeviceId,
+            final CommandContext originalCommandContext) {
+        // note that the command might be invalid here - a matching local handler to reject it (and report metrics) shall be found in that case
+        final Command originalCommand = originalCommandContext.getCommand();
+
+        // determine last used gateway device id
+        LOG.trace("determine command target gateway/adapter for [{}]", originalCommand);
+        final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId,
+                originalDeviceId, originalCommandContext.getTracingContext());
+
+        commandTargetFuture.setHandler(commandTargetResult -> {
+            if (commandTargetResult.succeeded()) {
+                final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);
+                final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);
+
+                delegateIncomingCommand(tenantId, originalDeviceId, originalCommandContext, targetDeviceId, targetAdapterInstance);
+
+            } else {
+                if (commandTargetResult.cause() instanceof ServiceInvocationException
+                        && ((ServiceInvocationException) commandTargetResult.cause()).getErrorCode() == HttpURLConnection.HTTP_NOT_FOUND) {
+                    LOG.debug("no target adapter instance found for command for device {}", originalDeviceId);
+                    TracingHelper.logError(originalCommandContext.getCurrentSpan(),
+                            "no target adapter instance found for command with device id " + originalDeviceId);
+                } else {
+                    LOG.debug("error getting target gateway and adapter instance for command with device id {}",
+                            originalDeviceId, commandTargetResult.cause());
+                    TracingHelper.logError(originalCommandContext.getCurrentSpan(),
+                            "error getting target gateway and adapter instance for command with device id " + originalDeviceId,
+                            commandTargetResult.cause());
+                }
+                originalCommandContext.release();
+            }
+        });
+    }
+
+    private void delegateIncomingCommand(final String tenantId, final String originalDeviceId,
+            final CommandContext originalCommandContext, final String targetDeviceId,
+            final String targetAdapterInstance) {
+
+        // note that the command might be invalid here - a matching local handler to reject it (and report metrics) shall be found in that case
+        final Command originalCommand = originalCommandContext.getCommand();
+        final String targetGatewayId = targetDeviceId.equals(originalDeviceId) ? null : targetDeviceId;
+
+        // if command is targeted at this adapter instance, determine the command handler
+        final CommandHandlerWrapper commandHandler = adapterInstanceId.equals(targetAdapterInstance)
+                ? adapterInstanceCommandHandler.getDeviceSpecificCommandHandler(tenantId, targetDeviceId)
+                : null;
+
+        if (adapterInstanceId.equals(targetAdapterInstance) && commandHandler == null) {
+            LOG.info("local command handler not found for target {} {} [{}]",
+                    targetDeviceId.equals(originalDeviceId) ? "device" : "gateway", targetDeviceId, originalCommand);
+            TracingHelper.logError(originalCommandContext.getCurrentSpan(),
+                    "local command handler not found for command; target device: " + targetDeviceId);
+            if (originalCommand.isValid()) {
+                originalCommandContext.release();
+            } else {
+                originalCommandContext.reject(getMalformedMessageError());
+            }
+        } else {
+            final boolean forcedCommandReroutingSet = isForcedCommandReroutingSet(originalCommandContext);
+            if (commandHandler != null && forcedCommandReroutingSet) { // used for integration tests
+                LOG.debug("forced command rerouting is set, skip usage of local {} for {}", commandHandler, originalCommand);
+            }
+            if (commandHandler != null && !forcedCommandReroutingSet) {
+                // Adopt gateway id from command handler if set;
+                // for that kind of command handler (gateway subscribing for specific device commands), the
+                // gateway information is not stored in the device connection service ("deviceConnectionService.setCommandHandlingAdapterInstance()" doesn't have an extra gateway id parameter);
+                // and therefore not set in the commandTargetMapper result
+                final String actualGatewayId = commandHandler.getGatewayId() != null
+                        ? commandHandler.getGatewayId()
+                        : targetGatewayId;
+                final CommandContext commandContext = originalCommand.isValid()
+                        ? adaptCommandContextToGatewayIfNeeded(originalCommandContext, actualGatewayId)
+                        : originalCommandContext;
+                LOG.trace("use local {} for {}", commandHandler, commandContext.getCommand());
+                commandHandler.handleCommand(commandContext);
+            } else if (originalCommand.isValid()) {
+                // delegate to matching consumer via downstream peer
+                final CommandContext commandContext = adaptCommandContextToGatewayIfNeeded(originalCommandContext, targetGatewayId);
+                delegateCommandMessageToAdapterInstance(targetAdapterInstance, commandContext);
+            } else {
+                // command message is invalid
+                originalCommandContext.reject(getMalformedMessageError());
+            }
+        }
+    }
+
+    private ErrorCondition getMalformedMessageError() {
+        return new ErrorCondition(Constants.AMQP_BAD_REQUEST, "malformed command message");
+    }
+
+    private CommandContext adaptCommandContextToGatewayIfNeeded(final CommandContext originalCommandContext, final String gatewayId) {
+        final Command originalCommand = originalCommandContext.getCommand();
+        final String tenantId = originalCommand.getTenant();
+        final String originalDeviceId = originalCommand.getDeviceId();
+
+        final CommandContext commandContext;
+        if (gatewayId == null) {
+            LOG.trace("command not mapped to gateway, use original device id {}", originalDeviceId);
+            commandContext = originalCommandContext;
+        } else {
+            LOG.trace("determined target gateway {} for device {}", gatewayId, originalDeviceId);
+            originalCommandContext.getCurrentSpan().log("determined target gateway " + gatewayId);
+            if (!originalCommand.isOneWay()) {
+                originalCommand.getCommandMessage().setReplyTo(String.format("%s/%s/%s",
+                        CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, originalCommand.getReplyToId()));
+            }
+            final Command command = Command.from(originalCommand.getCommandMessage(), tenantId, gatewayId);
+            commandContext = CommandContext.from(command, originalCommandContext.getDelivery(),
+                    originalCommandContext.getCurrentSpan());
+        }
+        return commandContext;
+    }
+
+    private void delegateCommandMessageToAdapterInstance(final String targetAdapterInstance, final CommandContext commandContext) {
+        LOG.trace("delegate command to target adapter instance '{}' [command: {}]", targetAdapterInstance, commandContext.getCommand());
+        getOrCreateDelegatedCommandSender(targetAdapterInstance)
+                .compose(sender -> sender.sendCommandMessage(commandContext.getCommand(), commandContext.getTracingContext()))
+                .setHandler(ar -> {
+                    if (ar.succeeded()) {
+                        final ProtonDelivery delegatedMsgDelivery = ar.result();
+                        LOG.trace("command [{}] sent to downstream peer; remote state of delivery: {}",
+                                commandContext.getCommand(), delegatedMsgDelivery.getRemoteState());
+                        commandContext.disposition(delegatedMsgDelivery.getRemoteState());
+                    } else {
+                        LOG.debug("failed to send command [{}] to downstream peer", commandContext.getCommand(), ar.cause());
+                        TracingHelper.logError(commandContext.getCurrentSpan(),
+                                "failed to send command message to downstream peer: " + ar.cause());
+                        commandContext.release();
+                    }
+                });
+    }
+
+    private boolean isForcedCommandReroutingSet(final CommandContext commandContext) {
+        if (!FORCED_COMMAND_REROUTING_ENABLED || !commandContext.getCommand().isValid()) {
+            return false;
+        }
+        final ApplicationProperties applicationProperties = commandContext.getCommand().getCommandMessage()
+                .getApplicationProperties();
+        return Boolean.TRUE.equals(MessageHelper.getApplicationProperty(applicationProperties,
+                FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY, Boolean.class));
+    }
+
+    private Future<DelegatedCommandSender> getOrCreateDelegatedCommandSender(final String protocolAdapterInstanceId) {
+        return connection.executeOnContext(result -> {
+            delegatedCommandSenderFactory.getOrCreateClient(protocolAdapterInstanceId,
+                    () -> DelegatedCommandSenderImpl.create(connection, protocolAdapterInstanceId, null), result);
+        });
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
new file mode 100644
index 000000000..131e0c29f
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
@@ -0,0 +1,332 @@
+/*******************************************************************************
+ * Copyright (c) 2018, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Supplier;
+
+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.client.CommandResponseSender;
+import org.eclipse.hono.client.CommandTargetMapper;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;
+import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.ResourceIdentifier;
+
+import io.vertx.core.CompositeFuture;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.eventbus.Message;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+
+/**
+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to receive commands and send responses.
+ * <p>
+ * The factory uses two kinds of consumer links to receive commands:
+ * <ul>
+ * <li>A single consumer link on an address containing the protocol adapter instance id.</li>
+ * <li>A tenant-scoped link, created (if not already existing for that tenant) when
+ * {@link #createCommandConsumer(String, String, Handler)} is invoked.</li>
+ * </ul>
+ * <p>
+ * Command messages are first received on the tenant-scoped consumer address. It is then determined whether there is
+ * a consumer and corresponding command handler for the command message's target device or one of the device's
+ * possible gateways. If found, that handler is either invoked directly, or, if it is on another protocol adapter
+ * instance, the command message is sent to that protocol adapter instance to be handled there.
+ */
+public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClientFactory implements ProtocolAdapterCommandConsumerFactory {
+
+    private static final int RECREATE_CONSUMERS_DELAY = 20;
+
+    /**
+     * Cache key used here is the tenant id.
+     */
+    private CachingClientFactory<MessageConsumer> mappingAndDelegatingCommandConsumerFactory;
+
+    private final String adapterInstanceId;
+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;
+    private final AtomicBoolean recreatingConsumers = new AtomicBoolean(false);
+    private final AtomicBoolean tryAgainRecreatingConsumers = new AtomicBoolean(false);
+
+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;
+    private MappingAndDelegatingCommandHandler mappingAndDelegatingCommandHandler;
+    private ProtonReceiver adapterSpecificConsumer;
+    private final AtomicBoolean initialized = new AtomicBoolean(false);
+
+    /**
+     * Creates a new factory for an existing connection.
+     * 
+     * @param connection The connection to the AMQP network.
+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    public ProtocolAdapterCommandConsumerFactoryImpl(final HonoConnection connection, final String adapterInstanceId) {
+        super(connection);
+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);
+
+        adapterInstanceCommandHandler = new AdapterInstanceCommandHandler(connection.getTracer(), adapterInstanceId);
+    }
+
+    @Override
+    public void initialize(final CommandTargetMapper commandTargetMapper,
+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {
+        Objects.requireNonNull(commandTargetMapper);
+        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);
+
+        mappingAndDelegatingCommandHandler = new MappingAndDelegatingCommandHandler(connection,
+                commandTargetMapper, adapterInstanceCommandHandler, adapterInstanceId);
+        mappingAndDelegatingCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> true);
+
+        connection.getVertx().eventBus().consumer(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT,
+                this::handleTenantTimeout);
+        connection.addReconnectListener(c -> recreateConsumers());
+        // trigger creation of adapter specific consumer link (with retry if failed)
+        recreateConsumers();
+        initialized.set(true);
+    }
+
+    @Override
+    protected void onDisconnect() {
+        if (adapterSpecificConsumer != null) {
+            connection.closeAndFree(adapterSpecificConsumer, v -> {});
+        }
+        mappingAndDelegatingCommandConsumerFactory.clearState();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<MessageConsumer> createCommandConsumer(final String tenantId, final String deviceId,
+            final Handler<CommandContext> commandHandler) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(commandHandler);
+        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<MessageConsumer> createCommandConsumer(final String tenantId, final String deviceId,
+            final String gatewayId, final Handler<CommandContext> commandHandler) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(gatewayId);
+        Objects.requireNonNull(commandHandler);
+        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler);
+    }
+
+    private Future<MessageConsumer> doCreateCommandConsumer(final String tenantId, final String deviceId,
+            final String gatewayId, final Handler<CommandContext> commandHandler) {
+        if (!initialized.get()) {
+            log.error("not initialized");
+            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
+        }
+        log.trace("create command consumer [tenant-id: {}, device-id: {}, gateway-id: {}]", tenantId, deviceId, gatewayId);
+        return connection.executeOnContext(result -> {
+            // create the tenant-scoped consumer ("command/<tenantId>") that maps/delegates incoming commands to the right handler/adapter-instance
+            getOrCreateMappingAndDelegatingCommandConsumer(tenantId)
+                    .compose(res -> {
+                        // register the command handler
+                        final CommandHandlerWrapper replacedHandler = adapterInstanceCommandHandler
+                                .putDeviceSpecificCommandHandler(tenantId, deviceId, gatewayId, commandHandler);
+                        if (replacedHandler != null) {
+                            // TODO find a way to provide a notification here so that potential resources associated with the replaced consumer can be freed (maybe add a commandHandlerOverwritten Handler param to createCommandConsumer())
+                        }
+                        // associate handler with this adapter instance
+                        return setCommandHandlingAdapterInstance(tenantId, deviceId);
+                    })
+                    .map(res -> {
+                        final Supplier<Future<Void>> onCloseAction = () -> removeCommandConsumer(tenantId, deviceId);
+                        return (MessageConsumer) new DeviceSpecificCommandConsumer(onCloseAction);
+                    })
+                    .setHandler(result);
+        });
+    }
+
+    private Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId) {
+        return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
+                .compose(client -> {
+                    return client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, null);
+                }).recover(thr -> {
+                    log.info("error setting command handling adapter instance [tenant: {}, device: {}]", tenantId,
+                            deviceId, thr);
+                    // handler association failed - unregister the handler
+                    adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
+                    return Future.failedFuture(thr);
+                });
+    }
+
+    private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId) {
+        log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
+        adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
+        return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
+                .compose(client -> {
+                    return client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, null);
+                }).recover(thr -> {
+                    log.info("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
+                            deviceId, thr);
+                    return Future.failedFuture(thr);
+                });
+    }
+
+    private Future<MessageConsumer> getOrCreateMappingAndDelegatingCommandConsumer(final String tenantId) {
+        final Future<MessageConsumer> messageConsumerFuture = connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    mappingAndDelegatingCommandConsumerFactory.getOrCreateClient(tenantId,
+                            () -> newMappingAndDelegatingCommandConsumer(tenantId),
+                            result);
+                }));
+        return messageConsumerFuture.recover(thr -> {
+            log.debug("failed to create mappingAndDelegatingCommandConsumer for tenant {}", tenantId, thr);
+            return Future.failedFuture(thr);
+        });
+    }
+
+    private Future<MessageConsumer> newMappingAndDelegatingCommandConsumer(final String tenantId) {
+        log.trace("creating new MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId);
+        final String address = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
+        return connection.createReceiver(
+                address,
+                ProtonQoS.AT_LEAST_ONCE,
+                (delivery, message) -> {
+                    mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(tenantId, delivery, message);
+                },
+                connection.getConfig().getInitialCredits(),
+                false, // no auto-accept
+                sourceAddress -> { // remote close hook
+                    log.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed remotely", tenantId);
+                    mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
+                    invokeRecreateConsumersWithDelay();
+                }).map(receiver -> {
+                    log.debug("successfully created MappingAndDelegatingCommandConsumer [{}]", address);
+                    final CommandConsumer consumer = new CommandConsumer(connection, receiver);
+                    consumer.setLocalCloseHandler(sourceAddress -> {
+                        log.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed locally", tenantId);
+                        mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
+                    });
+                    return (MessageConsumer) consumer;
+                }).recover(t -> {
+                    log.debug("failed to create MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId, t);
+                    return Future.failedFuture(t);
+                });
+    }
+
+    private Future<ProtonReceiver> createAdapterSpecificConsumer() {
+        log.trace("creating new adapter instance command consumer");
+        final String adapterInstanceConsumerAddress = CommandConstants.INTERNAL_COMMAND_ENDPOINT + "/"
+                + adapterInstanceId;
+        return connection.createReceiver(
+                adapterInstanceConsumerAddress,
+                ProtonQoS.AT_LEAST_ONCE,
+                (delivery, msg) -> adapterInstanceCommandHandler.handleCommandMessage(msg, delivery),
+                connection.getConfig().getInitialCredits(),
+                false, // no auto-accept
+                sourceAddress -> { // remote close hook
+                    log.debug("command receiver link closed remotely");
+                    invokeRecreateConsumersWithDelay();
+                }).map(receiver -> {
+                    log.debug("successfully created adapter specific command consumer");
+                    adapterSpecificConsumer = receiver;
+                    return receiver;
+                }).recover(t -> {
+                    log.error("failed to create adapter specific command consumer", t);
+                    return Future.failedFuture(t);
+                });
+    }
+
+    private void recreateConsumers() {
+        if (recreatingConsumers.compareAndSet(false, true)) {
+            log.debug("recreate command consumer links");
+            connection.isConnected(getDefaultConnectionCheckTimeout())
+                    .compose(res -> {
+                        @SuppressWarnings("rawtypes")
+                        final List<Future> consumerCreationFutures = new ArrayList<>();
+                        // recreate adapter specific consumer
+                        if (adapterSpecificConsumer == null || !adapterSpecificConsumer.isOpen()) {
+                            log.debug("recreate adapter specific command consumer link");
+                            consumerCreationFutures.add(createAdapterSpecificConsumer());
+                        }
+                        // recreate mappingAndDelegatingCommandConsumers
+                        adapterInstanceCommandHandler.getDeviceSpecificCommandHandlers().stream()
+                                .map(CommandHandlerWrapper::getTenantId).distinct().forEach(tenantId -> {
+                                    log.debug("recreate command consumer link for tenant {}", tenantId);
+                                    consumerCreationFutures.add(
+                                            getOrCreateMappingAndDelegatingCommandConsumer(tenantId));
+                                });
+                        return CompositeFuture.join(consumerCreationFutures);
+                    }).setHandler(ar -> {
+                        recreatingConsumers.set(false);
+                        if (tryAgainRecreatingConsumers.compareAndSet(true, false) || ar.failed()) {
+                            if (ar.succeeded()) {
+                                // tryAgainRecreatingConsumers was set - try again immediately
+                                recreateConsumers();
+                            } else {
+                                invokeRecreateConsumersWithDelay();
+                            }
+                        }
+                    });
+        } else {
+            // if recreateConsumers() was triggered by a remote link closing, that might have occurred after that link was dealt with above;
+            // therefore be sure recreateConsumers() gets called again once the current invocation has finished.
+            log.debug("already recreating consumers");
+            tryAgainRecreatingConsumers.set(true);
+        }
+    }
+
+    private void invokeRecreateConsumersWithDelay() {
+        connection.getVertx().setTimer(RECREATE_CONSUMERS_DELAY, tid -> recreateConsumers());
+    }
+
+    private void handleTenantTimeout(final Message<String> msg) {
+        final String tenantId = msg.body();
+        final MessageConsumer consumer = mappingAndDelegatingCommandConsumerFactory.getClient(tenantId);
+        if (consumer != null) {
+            log.info("timeout of tenant {}: closing and removing command consumer", tenantId);
+            consumer.close(v -> mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId));
+        }
+        adapterInstanceCommandHandler
+                .getDeviceSpecificCommandHandlers().stream().filter(handler -> handler.getTenantId().equals(tenantId))
+                .forEach(handler -> {
+                    log.info("timeout of tenant {}: removing command handler for device {}", tenantId, handler.getDeviceId());
+                    adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(handler.getTenantId(), handler.getDeviceId());
+                });
+    }
+
+    /**
+     * {@inheritDoc}
+     * 
+     * This implementation always creates a new sender link.
+     */
+    @Override
+    public Future<CommandResponseSender> getCommandResponseSender(final String tenantId, final String replyId) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(replyId);
+        return connection.executeOnContext(result -> {
+            CommandResponseSenderImpl.create(connection, tenantId, replyId, onRemoteClose -> {}).setHandler(result);
+        });
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandlerTest.java
new file mode 100644
index 000000000..6338ae95e
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandlerTest.java
@@ -0,0 +1,166 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Collections;
+
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.messaging.Released;
+import org.apache.qpid.proton.amqp.transport.DeliveryState;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.MessageHelper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.mockito.ArgumentCaptor;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+
+/**
+ * Verifies behavior of {@link AdapterInstanceCommandHandler}.
+ */
+public class AdapterInstanceCommandHandlerTest {
+
+    private AdapterInstanceCommandHandler adapterInstanceCommandHandler;
+
+    /**
+     * Sets up fixture.
+     */
+    @BeforeEach
+    public void setUp() {
+        final SpanContext spanContext = mock(SpanContext.class);
+        final Span span = mock(Span.class);
+        when(span.context()).thenReturn(spanContext);
+        final Tracer.SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
+        final Tracer tracer = mock(Tracer.class);
+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
+
+        final String adapterInstanceId = "adapterInstanceId";
+        adapterInstanceCommandHandler = new AdapterInstanceCommandHandler(tracer, adapterInstanceId);
+    }
+
+    @Test
+    void testHandleCommandMessageWithInvalidMessage() {
+        final Message msg = mock(Message.class);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        adapterInstanceCommandHandler.handleCommandMessage(msg, delivery);
+
+        final ArgumentCaptor<DeliveryState> deliveryStateCaptor = ArgumentCaptor.forClass(DeliveryState.class);
+        verify(delivery).disposition(deliveryStateCaptor.capture(), anyBoolean());
+        assertThat(deliveryStateCaptor.getValue()).isNotNull();
+        assertThat(deliveryStateCaptor.getValue()).isInstanceOf(Rejected.class);
+    }
+
+    @Test
+    void testHandleCommandMessageWithNoHandlerFound() {
+        final Message msg = mock(Message.class);
+        final String deviceId = "4711";
+        when(msg.getAddress()).thenReturn(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        adapterInstanceCommandHandler.handleCommandMessage(msg, delivery);
+
+        final ArgumentCaptor<DeliveryState> deliveryStateCaptor = ArgumentCaptor.forClass(DeliveryState.class);
+        verify(delivery).disposition(deliveryStateCaptor.capture(), anyBoolean());
+        assertThat(deliveryStateCaptor.getValue()).isNotNull();
+        assertThat(deliveryStateCaptor.getValue()).isInstanceOf(Released.class);
+    }
+
+    @Test
+    void testHandleCommandMessageWithHandlerForDevice() {
+        final String deviceId = "4711";
+        final String correlationId = "the-correlation-id";
+        final Message message = ProtonHelper.message("input data");
+        message.setAddress(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+        message.setSubject("doThis");
+        message.setCorrelationId(correlationId);
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, commandHandler);
+
+        adapterInstanceCommandHandler.handleCommandMessage(message, mock(ProtonDelivery.class));
+
+        final ArgumentCaptor<CommandContext> commandContextCaptor = ArgumentCaptor.forClass(CommandContext.class);
+        verify(commandHandler).handle(commandContextCaptor.capture());
+        assertThat(commandContextCaptor.getValue()).isNotNull();
+        assertThat(commandContextCaptor.getValue().getCommand().getDeviceId()).isEqualTo(deviceId);
+    }
+
+    @Test
+    void testHandleCommandMessageWithHandlerForGateway() {
+        final String deviceId = "4711";
+        final String gatewayId = "gw-1";
+        final String correlationId = "the-correlation-id";
+        final Message message = ProtonHelper.message("input data");
+        message.setAddress(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+        message.setSubject("doThis");
+        message.setCorrelationId(correlationId);
+        message.setApplicationProperties(
+                new ApplicationProperties(Collections.singletonMap(MessageHelper.APP_PROPERTY_CMD_VIA, gatewayId)));
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, gatewayId, null, commandHandler);
+
+        adapterInstanceCommandHandler.handleCommandMessage(message, mock(ProtonDelivery.class));
+
+        final ArgumentCaptor<CommandContext> commandContextCaptor = ArgumentCaptor.forClass(CommandContext.class);
+        verify(commandHandler).handle(commandContextCaptor.capture());
+        assertThat(commandContextCaptor.getValue()).isNotNull();
+        // assert that command is directed at the gateway
+        assertThat(commandContextCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
+        assertThat(commandContextCaptor.getValue().getCommand().getOriginalDeviceId()).isEqualTo(deviceId);
+    }
+
+    @Test
+    void testHandleCommandMessageWithHandlerForGatewayAndSpecificDevice() {
+        final String deviceId = "4711";
+        final String gatewayId = "gw-1";
+        final String correlationId = "the-correlation-id";
+        final Message message = ProtonHelper.message("input data");
+        message.setAddress(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+        message.setSubject("doThis");
+        message.setCorrelationId(correlationId);
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, gatewayId, commandHandler);
+
+        adapterInstanceCommandHandler.handleCommandMessage(message, mock(ProtonDelivery.class));
+
+        final ArgumentCaptor<CommandContext> commandContextCaptor = ArgumentCaptor.forClass(CommandContext.class);
+        verify(commandHandler).handle(commandContextCaptor.capture());
+        assertThat(commandContextCaptor.getValue()).isNotNull();
+        // assert that command is directed at the gateway
+        assertThat(commandContextCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
+        assertThat(commandContextCaptor.getValue().getCommand().getOriginalDeviceId()).isEqualTo(deviceId);
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
deleted file mode 100644
index d8c3262e3..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.doAnswer;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.net.HttpURLConnection;
-import java.util.Collections;
-import java.util.concurrent.TimeUnit;
-
-import org.apache.qpid.proton.amqp.transport.Source;
-import org.eclipse.hono.auth.Device;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.DisconnectListener;
-import org.eclipse.hono.client.GatewayMapper;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.client.ServiceInvocationException;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.ResourceIdentifier;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ExtendWith;
-import org.mockito.ArgumentCaptor;
-
-import io.vertx.core.Context;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Promise;
-import io.vertx.core.Vertx;
-import io.vertx.junit5.Timeout;
-import io.vertx.junit5.VertxExtension;
-import io.vertx.junit5.VertxTestContext;
-import io.vertx.proton.ProtonMessageHandler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
-
-
-/**
- * Verifies behavior of {@link CommandConsumerFactoryImpl}.
- *
- */
-@ExtendWith(VertxExtension.class)
-@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)
-public class CommandConsumerFactoryImplTest {
-
-    private Vertx vertx;
-    private Context context;
-    private ClientConfigProperties props;
-    private HonoConnection connection;
-    private CommandConsumerFactoryImpl commandConsumerFactory;
-    private GatewayMapper gatewayMapper;
-    private ProtonReceiver deviceSpecificCommandReceiver;
-    private ProtonReceiver gatewaySpecificCommandReceiver;
-    private ProtonReceiver tenantScopedCommandReceiver;
-    private String deviceSpecificCommandAddress;
-    private String gatewaySpecificCommandAddress;
-    private String tenantCommandAddress;
-    private String tenantId;
-    private String deviceId;
-    private String gatewayId;
-
-    /**
-     * Sets up fixture.
-     */
-    @BeforeEach
-    public void setUp() {
-
-        vertx = mock(Vertx.class);
-        context = HonoClientUnitTestHelper.mockContext(vertx);
-        when(vertx.getOrCreateContext()).thenReturn(context);
-        doAnswer(invocation -> {
-            final Handler<Void> handler = invocation.getArgument(1);
-            handler.handle(null);
-            return null;
-        }).when(vertx).setTimer(anyLong(), VertxMockSupport.anyHandler());
-
-        deviceId = "theDevice";
-        gatewayId = "theGateway";
-        tenantId = "theTenant";
-
-        props = new ClientConfigProperties();
-
-        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, props);
-        deviceSpecificCommandReceiver = mock(ProtonReceiver.class);
-        deviceSpecificCommandAddress = ResourceIdentifier.from(CommandConstants.INTERNAL_COMMAND_ENDPOINT, tenantId, deviceId).toString();
-        when(connection.createReceiver(
-                eq(deviceSpecificCommandAddress),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(deviceSpecificCommandReceiver));
-        gatewaySpecificCommandReceiver = mock(ProtonReceiver.class);
-        when(gatewaySpecificCommandReceiver.isOpen()).thenReturn(Boolean.TRUE);
-        gatewaySpecificCommandAddress = ResourceIdentifier.from(CommandConstants.INTERNAL_COMMAND_ENDPOINT, tenantId, gatewayId).toString();
-        when(connection.createReceiver(
-                eq(gatewaySpecificCommandAddress),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(gatewaySpecificCommandReceiver));
-        tenantScopedCommandReceiver = mock(ProtonReceiver.class);
-        tenantCommandAddress = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
-        when(connection.createReceiver(
-                eq(tenantCommandAddress),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(tenantScopedCommandReceiver));
-        gatewayMapper = mock(GatewayMapper.class);
-        commandConsumerFactory = new CommandConsumerFactoryImpl(connection, gatewayMapper);
-    }
-
-    /**
-     * Verifies that an attempt to open a command consumer fails if the peer
-     * rejects to open a receiver link.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateCommandConsumerFailsIfPeerRejectsLink(final VertxTestContext ctx) {
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Handler<Void> closeHandler = VertxMockSupport.mockHandler();
-        final ServerErrorException ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE);
-        when(connection.createReceiver(
-                anyString(),
-                any(ProtonQoS.class),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler()))
-        .thenReturn(Future.failedFuture(ex));
-
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, closeHandler)
-            .setHandler(ctx.failing(t -> {
-                ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
-                ctx.completeNow();
-            }));
-    }
-
-    /**
-     * Verifies that the connection successfully opens a command consumer for a
-     * tenant and device Id and opens a receiver link that is scoped to the device.
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testCreateCommandConsumerSucceeds(final VertxTestContext ctx) {
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Handler<Void> closeHandler = VertxMockSupport.mockHandler();
-
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, closeHandler)
-            .setHandler(ctx.completing());
-    }
-
-    /**
-     * Verifies that the close handler passed as an argument when creating
-     * a command consumer is invoked when the peer closes the link.
-     */
-    @Test
-    public void testCreateCommandConsumerSetsRemoteCloseHandler() {
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Handler<Void> closeHandler = VertxMockSupport.mockHandler();
-
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, closeHandler);
-        final ArgumentCaptor<Handler<String>> closeHookCaptor = VertxMockSupport.argumentCaptorHandler();
-        verify(connection).createReceiver(
-                eq(deviceSpecificCommandAddress),
-                eq(ProtonQoS.AT_LEAST_ONCE),
-                any(ProtonMessageHandler.class),
-                eq(props.getInitialCredits()),
-                eq(false),
-                closeHookCaptor.capture());
-        // invoke close hook
-        closeHookCaptor.getValue().handle(deviceSpecificCommandAddress);
-        verify(closeHandler).handle(null);
-    }
-
-    /**
-     * Verifies that the close handler passed as an argument when creating
-     * a command consumer with a gateway id is invoked when the peer closes the link.
-     */
-    @Test
-    public void testCreateCommandConsumerWithGatewaySetsRemoteCloseHandler() {
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Handler<Void> closeHandlerDeviceA = VertxMockSupport.mockHandler();
-        final Handler<Void> closeHandlerDeviceB = VertxMockSupport.mockHandler();
-
-        commandConsumerFactory.createCommandConsumer(tenantId, "deviceA", gatewayId, commandHandler, closeHandlerDeviceA);
-        commandConsumerFactory.createCommandConsumer(tenantId, "deviceB", gatewayId, commandHandler, closeHandlerDeviceB);
-        final ArgumentCaptor<Handler<String>> closeHookCaptor = VertxMockSupport.argumentCaptorHandler();
-        verify(connection).createReceiver(
-                eq(gatewaySpecificCommandAddress),
-                eq(ProtonQoS.AT_LEAST_ONCE),
-                any(ProtonMessageHandler.class),
-                eq(props.getInitialCredits()),
-                eq(false),
-                closeHookCaptor.capture());
-        // invoke close hook
-        closeHookCaptor.getValue().handle(gatewaySpecificCommandAddress);
-        verify(closeHandlerDeviceA).handle(null);
-        verify(closeHandlerDeviceB).handle(null);
-    }
-
-    /**
-     * Verifies that when a command consumer's <em>close</em> method is invoked,
-     * then
-     * <ul>
-     * <li>the underlying link is closed,</li>
-     * <li>the consumer is removed from the cache and</li>
-     * <li>the corresponding liveness check is canceled.</li>
-     * </ul>
-     *
-     * @param ctx The test context.
-     */
-    @Test
-    public void testLocalCloseRemovesCommandConsumerFromCache(final VertxTestContext ctx) {
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Source source = mock(Source.class);
-        when(source.getAddress()).thenReturn(deviceSpecificCommandAddress);
-        when(deviceSpecificCommandReceiver.getSource()).thenReturn(source);
-        when(deviceSpecificCommandReceiver.getRemoteSource()).thenReturn(source);
-        when(deviceSpecificCommandReceiver.isOpen()).thenReturn(Boolean.TRUE);
-        when(vertx.setPeriodic(anyLong(), VertxMockSupport.anyHandler())).thenReturn(10L);
-
-        // GIVEN a command consumer
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, 5000L)
-        .map(consumer -> {
-            ctx.verify(() -> verify(vertx).setPeriodic(eq(5000L), VertxMockSupport.anyHandler()));
-            // WHEN closing the link locally
-            final Promise<Void> localCloseHandler = Promise.promise();
-            consumer.close(localCloseHandler);
-            final ArgumentCaptor<Handler<Void>> closeHandler = VertxMockSupport.argumentCaptorHandler();
-            ctx.verify(() -> verify(connection).closeAndFree(eq(deviceSpecificCommandReceiver), closeHandler.capture()));
-            // and the peer sends its detach frame
-            closeHandler.getValue().handle(null);
-            return null;
-        }).map(ok -> {
-            // THEN the liveness check is canceled
-            ctx.verify(() -> verify(vertx).cancelTimer(10L));
-            // and the next attempt to create a command consumer for the same address
-            final Future<MessageConsumer> newConsumer = commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null);
-            // results in a new link to be opened
-            ctx.verify(() -> verify(connection, times(2)).createReceiver(
-                    eq(deviceSpecificCommandAddress),
-                    eq(ProtonQoS.AT_LEAST_ONCE),
-                    any(ProtonMessageHandler.class),
-                    eq(props.getInitialCredits()),
-                    eq(false),
-                    VertxMockSupport.anyHandler()));
-            return newConsumer;
-        }).setHandler(ctx.completing());
-    }
-
-    /**
-     * Verifies that a command consumer link that has been created with a check
-     * interval is re-created if the underlying connection to the peer is lost.
-     */
-    @Test
-    public void testConsumerIsRecreatedOnConnectionFailure() {
-
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Handler<Void> closeHandler = VertxMockSupport.mockHandler();
-        final Source source = mock(Source.class);
-        when(source.getAddress()).thenReturn(deviceSpecificCommandAddress);
-        when(deviceSpecificCommandReceiver.getSource()).thenReturn(source);
-        when(deviceSpecificCommandReceiver.getRemoteSource()).thenReturn(source);
-        when(vertx.setPeriodic(anyLong(), VertxMockSupport.anyHandler())).thenReturn(10L);
-        doAnswer(invocation -> {
-            final Handler<Void> handler = invocation.getArgument(1);
-            handler.handle(null);
-            return null;
-        }).when(connection).closeAndFree(any(), VertxMockSupport.anyHandler());
-
-        // GIVEN a command connection with an established command consumer
-        // which is checked periodically for liveness
-
-        // intentionally using a check interval that is smaller than the minimum
-        final long livenessCheckInterval = CommandConsumerFactoryImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS - 1;
-        final Future<MessageConsumer> commandConsumer = commandConsumerFactory.createCommandConsumer(
-                tenantId, deviceId, commandHandler, closeHandler, livenessCheckInterval);
-        assertThat(commandConsumer.isComplete()).isTrue();
-        final ArgumentCaptor<Handler<Long>> livenessCheck = VertxMockSupport.argumentCaptorHandler();
-        // the liveness check is registered with the minimum interval length
-        verify(vertx).setPeriodic(eq(CommandConsumerFactoryImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS), livenessCheck.capture());
-
-        // WHEN the command connection fails
-        @SuppressWarnings("unchecked")
-        final ArgumentCaptor<DisconnectListener<HonoConnection>> disconnectListener = ArgumentCaptor.forClass(DisconnectListener.class);
-        verify(connection).addDisconnectListener(disconnectListener.capture());
-        disconnectListener.getValue().onDisconnect(connection);
-
-        // THEN the connection is re-established
-        when(connection.isConnected()).thenReturn(Future.succeededFuture());
-        // and the liveness check re-creates the command consumer
-        livenessCheck.getValue().handle(10L);
-        verify(connection, times(2)).createReceiver(
-                eq(deviceSpecificCommandAddress),
-                eq(ProtonQoS.AT_LEAST_ONCE),
-                any(ProtonMessageHandler.class),
-                eq(props.getInitialCredits()),
-                eq(false),
-                VertxMockSupport.anyHandler());
-
-        // and when the consumer is finally closed locally
-        commandConsumer.result().close(null);
-        // then the liveness check has been canceled
-        verify(vertx).cancelTimer(10L);
-    }
-
-    /**
-     * Verifies that consecutive invocations of the liveness check created
-     * for a command consumer do not start a new re-creation attempt if another
-     * attempt is still ongoing.
-     */
-    @Test
-    public void testLivenessCheckLocksRecreationAttempt() {
-
-        // GIVEN a liveness check for a command consumer
-        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
-        final Handler<Void> remoteCloseHandler = VertxMockSupport.mockHandler();
-        final CommandHandlerWrapper commandHandlerWrapper = new CommandHandlerWrapper(deviceId, null, commandHandler,
-                remoteCloseHandler);
-        final String gatewayOrDeviceKey = Device.asAddress(tenantId, deviceId);
-        commandConsumerFactory.getDestinationCommandConsumerLivenessChecks().put(gatewayOrDeviceKey,
-                new CommandConsumerFactoryImpl.LivenessCheckData(10L, () -> Collections.singletonList(commandHandlerWrapper)));
-
-        final Handler<Long> livenessCheck = commandConsumerFactory.newLivenessCheck(tenantId, deviceId);
-        final Promise<ProtonReceiver> createdReceiver = Promise.promise();
-        when(connection.isConnected()).thenReturn(Future.succeededFuture());
-        when(connection.createReceiver(
-                eq(deviceSpecificCommandAddress),
-                eq(ProtonQoS.AT_LEAST_ONCE),
-                any(ProtonMessageHandler.class),
-                anyInt(),
-                anyBoolean(),
-                VertxMockSupport.anyHandler())).thenReturn(createdReceiver.future());
-
-        // WHEN the liveness check fires
-        livenessCheck.handle(10L);
-        // and the peer does not open the link before the check fires again
-        livenessCheck.handle(10L);
-
-        // THEN only one attempt has been made to recreate the consumer link
-        verify(connection, times(1)).createReceiver(
-                eq(deviceSpecificCommandAddress),
-                eq(ProtonQoS.AT_LEAST_ONCE),
-                any(ProtonMessageHandler.class),
-                eq(props.getInitialCredits()),
-                eq(false),
-                VertxMockSupport.anyHandler());
-
-        // and when the first attempt has finally timed out
-        createdReceiver.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));
-
-        // then the next run of the liveness check
-        livenessCheck.handle(10L);
-        // will start a new attempt to re-create the consumer link 
-        verify(connection, times(2)).createReceiver(
-                eq(deviceSpecificCommandAddress),
-                eq(ProtonQoS.AT_LEAST_ONCE),
-                any(ProtonMessageHandler.class),
-                eq(props.getInitialCredits()),
-                eq(false),
-                VertxMockSupport.anyHandler());
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
new file mode 100644
index 000000000..8213a170d
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandTargetMapperImplTest.java
@@ -0,0 +1,185 @@
+/*******************************************************************************
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Collections;
+
+import org.eclipse.hono.client.DeviceConnectionClient;
+import org.eclipse.hono.client.DeviceConnectionClientFactory;
+import org.eclipse.hono.client.RegistrationClient;
+import org.eclipse.hono.client.RegistrationClientFactory;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.RegistrationConstants;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.Future;
+import io.vertx.core.json.JsonArray;
+import io.vertx.core.json.JsonObject;
+
+/**
+ * Verifies behavior of {@link CommandTargetMapperImpl}.
+ */
+public class CommandTargetMapperImplTest {
+
+    private CommandTargetMapperImpl commandTargetMapper;
+    private RegistrationClient regClient;
+    private DeviceConnectionClient devConClient;
+    private String tenantId;
+    private String deviceId;
+    private Span span;
+
+    /**
+     * Sets up common fixture.
+     */
+    @BeforeEach
+    public void setup() {
+        final SpanContext spanContext = mock(SpanContext.class);
+        span = mock(Span.class);
+        when(span.context()).thenReturn(spanContext);
+        final Tracer.SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
+        final Tracer tracer = mock(Tracer.class);
+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
+
+        tenantId = "testTenant";
+        deviceId = "testDevice";
+        regClient = mock(RegistrationClient.class);
+        final RegistrationClientFactory registrationClientFactory = mock(RegistrationClientFactory.class);
+        when(registrationClientFactory.getOrCreateRegistrationClient(anyString()))
+                .thenReturn(Future.succeededFuture(regClient));
+
+        devConClient = mock(DeviceConnectionClient.class);
+        final DeviceConnectionClientFactory deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);
+        when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
+                .thenReturn(Future.succeededFuture(devConClient));
+        commandTargetMapper = new CommandTargetMapperImpl(tracer);
+        commandTargetMapper.initialize(registrationClientFactory, deviceConnectionClientFactory);
+    }
+
+    /**
+     * Verifies that the <em>getTargetGatewayAndAdapterInstance</em> method returns a Future with the expected result
+     * for a device for which no 'via' entry is set.
+     */
+    @Test
+    public void testGetTargetGatewayAndAdapterInstanceUsingDeviceWithNoVia() {
+        // GIVEN assertRegistration result with no 'via'
+        final JsonObject assertRegistrationResult = new JsonObject();
+        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
+
+        // and a getCommandHandlingAdapterInstances result with one object for the device
+        final String adapterInstanceId = "adapter1";
+        final JsonObject adapterInstancesResult = new JsonObject();
+        final JsonObject adapterInstanceEntry = new JsonObject();
+        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId);
+        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
+        adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, new JsonArray(Collections.singletonList(adapterInstanceEntry)));
+        when(devConClient.getCommandHandlingAdapterInstances(eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
+
+        // WHEN getTargetGatewayAndAdapterInstance() is invoked
+        final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
+
+        // THEN the returned Future is complete and contains the adapter instance entry
+        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
+        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(adapterInstanceEntry);
+        verify(span).finish();
+    }
+
+    /**
+     * Verifies that the <em>getTargetGatewayAndAdapterInstance</em> method returns a result with a gateway
+     * if that gateway is one of the device's 'via' gateways and is associated with a command handling adapter
+     * instance.
+     */
+    @Test
+    public void testGetTargetGatewayAndAdapterInstanceUsingDeviceWithMappedGateway() {
+        final String gatewayId = "testDeviceVia";
+
+        // GIVEN assertRegistration result with non-empty 'via'
+        final JsonObject assertRegistrationResult = new JsonObject();
+        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
+        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
+        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
+
+        // and a getCommandHandlingAdapterInstances result with one object for the gateway
+        final String adapterInstanceId = "adapter1";
+        final JsonObject adapterInstancesResult = new JsonObject();
+        final JsonObject adapterInstanceEntry = new JsonObject();
+        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, gatewayId);
+        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
+        adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, new JsonArray(Collections.singletonList(adapterInstanceEntry)));
+        when(devConClient.getCommandHandlingAdapterInstances(eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
+
+        // WHEN getMappedGatewayDevice() is invoked
+        final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
+
+        // THEN the returned Future is complete and contains the adapter instance entry
+        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
+        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(adapterInstanceEntry);
+        verify(span).finish();
+    }
+
+    /**
+     * Verifies that <em>getTargetGatewayAndAdapterInstance</em> method result for multiple command handling
+     * adapter instances associated with gateways in the via list of the device.
+     */
+    @Test
+    public void tesGetTargetGatewayAndAdapterInstanceUsingDeviceWithMappedGateway() {
+        final String gatewayId = "testDeviceVia";
+        final String otherGatewayId = "otherGatewayId";
+
+        // GIVEN assertRegistration result with non-empty 'via'
+        final JsonObject assertRegistrationResult = new JsonObject();
+        final JsonArray viaArray = new JsonArray();
+        viaArray.add(gatewayId);
+        viaArray.add(otherGatewayId);
+        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
+        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
+
+        // and a getCommandHandlingAdapterInstances result with 2 objects with the one with 'gatewayId' being first
+        final String adapterInstanceId = "adapter1";
+        final JsonObject adapterInstancesResult = new JsonObject();
+        final JsonObject adapterInstanceEntry = new JsonObject();
+        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, gatewayId);
+        adapterInstanceEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
+
+        final JsonObject adapterInstanceOtherEntry = new JsonObject();
+        adapterInstanceOtherEntry.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, otherGatewayId);
+        adapterInstanceOtherEntry.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, adapterInstanceId);
+
+        final JsonArray adapterInstances = new JsonArray();
+        adapterInstances.add(adapterInstanceEntry);
+        adapterInstances.add(adapterInstanceOtherEntry);
+        adapterInstancesResult.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES, adapterInstances);
+        when(devConClient.getCommandHandlingAdapterInstances(eq(deviceId), any(), any())).thenReturn(Future.succeededFuture(adapterInstancesResult));
+
+        // WHEN getMappedGatewayDevice() is invoked
+        final Future<JsonObject> mappedGatewayDeviceFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, null);
+
+        // THEN the returned Future is complete and contains the first adapter instance entry
+        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
+        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(adapterInstanceEntry);
+        verify(span).finish();
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
deleted file mode 100644
index 18a1953eb..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyBoolean;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Modified;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.messaging.Released;
-import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.DelegatedCommandSender;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.util.CommandConstants;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.vertx.core.Future;
-import io.vertx.core.Vertx;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * Verifies behavior of {@link DelegateViaDownstreamPeerCommandHandler}.
- */
-public class DelegateViaDownstreamPeerCommandHandlerTest {
-
-    private CommandContext commandContext;
-    private ProtonDelivery commandDelivery;
-    private DelegateViaDownstreamPeerCommandHandler delegateViaDownstreamPeerCommandHandler;
-    private DelegatedCommandSender delegatedCommandSender;
-
-    /**
-     * Sets up common fixture.
-     */
-    @BeforeEach
-    public void setup() {
-        final String tenantId = "testTenant";
-        final String deviceId = "testDevice";
-        final String replyTo = String.format("%s/%s/%s", CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, "the-reply-to-id");
-
-        final Message commandMessage = mock(Message.class);
-        when(commandMessage.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, tenantId, deviceId));
-        when(commandMessage.getSubject()).thenReturn("testSubject");
-        when(commandMessage.getCorrelationId()).thenReturn("testCorrelationId");
-        when(commandMessage.getReplyTo()).thenReturn(replyTo);
-        final Command command = Command.from(commandMessage, tenantId, deviceId);
-        commandDelivery = mock(ProtonDelivery.class);
-        final Span currentSpan = mock(Span.class);
-        commandContext = spy(CommandContext.from(command, commandDelivery, currentSpan));
-
-        delegateViaDownstreamPeerCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
-                (tenantIdParam, deviceIdParam) -> Future.succeededFuture(delegatedCommandSender));
-
-        final HonoConnection connection = mock(HonoConnection.class);
-        when(connection.getConfig()).thenReturn(new ClientConfigProperties());
-        final Vertx vertx = mock(Vertx.class);
-        when(connection.getVertx()).thenReturn(vertx);
-        when(vertx.setTimer(anyLong(), VertxMockSupport.anyHandler())).thenReturn(1L);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when sending the command message returns an
-     * <em>Accepted</em> delivery result.
-     */
-    @Test
-    public void testHandleWithAcceptedDeliveryResult() {
-
-        // GIVEN a message sender that returns an 'Accepted' delivery result
-        final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
-        when(protonDelivery.getRemoteState()).thenReturn(Accepted.getInstance());
-        delegatedCommandSender = mock(DelegatedCommandSender.class);
-        when(delegatedCommandSender.sendCommandMessage(any(), any())).thenReturn(Future.succeededFuture(protonDelivery));
-
-        // WHEN handle() is invoked
-        delegateViaDownstreamPeerCommandHandler.handle(commandContext);
-
-        // THEN the command context delivery is updated with the 'accepted' outcome
-        final ArgumentCaptor<DeliveryState> deliveryStateArgumentCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(commandDelivery).disposition(deliveryStateArgumentCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateArgumentCaptor.getValue()).isInstanceOf(Accepted.class);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when sending the command message returns a
-     * <em>Rejected</em> delivery result.
-     */
-    @Test
-    public void testHandleWithRejectedDeliveryResult() {
-
-        // GIVEN a message sender that returns a 'Rejected' delivery result
-        final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
-        final Rejected rejected = new Rejected();
-        final ErrorCondition error = new ErrorCondition(Symbol.valueOf("someError"), "error message");
-        rejected.setError(error);
-        when(protonDelivery.getRemoteState()).thenReturn(rejected);
-        delegatedCommandSender = mock(DelegatedCommandSender.class);
-        when(delegatedCommandSender.sendCommandMessage(any(), any())).thenReturn(Future.succeededFuture(protonDelivery));
-
-        // WHEN handle() is invoked
-        delegateViaDownstreamPeerCommandHandler.handle(commandContext);
-
-        // THEN the command context delivery is updated with the 'rejected' outcome
-        final ArgumentCaptor<DeliveryState> deliveryStateArgumentCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(commandDelivery).disposition(deliveryStateArgumentCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateArgumentCaptor.getValue()).isInstanceOf(Rejected.class);
-        assertThat(((Rejected) deliveryStateArgumentCaptor.getValue()).getError()).isEqualTo(error);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when sending the command message returns a
-     * <em>Modified</em> delivery result.
-     */
-    @Test
-    public void testHandleWithModifiedDeliveryResult() {
-
-        // GIVEN a message sender that returns a 'Modified' delivery result
-        final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
-        final Modified modified = new Modified();
-        modified.setDeliveryFailed(true);
-        modified.setUndeliverableHere(true);
-        when(protonDelivery.getRemoteState()).thenReturn(modified);
-        delegatedCommandSender = mock(DelegatedCommandSender.class);
-        when(delegatedCommandSender.sendCommandMessage(any(), any())).thenReturn(Future.succeededFuture(protonDelivery));
-
-        // WHEN handle() is invoked
-        delegateViaDownstreamPeerCommandHandler.handle(commandContext);
-
-        // THEN the command context delivery is updated with the 'modified' outcome
-        final ArgumentCaptor<DeliveryState> deliveryStateArgumentCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(commandDelivery).disposition(deliveryStateArgumentCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateArgumentCaptor.getValue()).isInstanceOf(Modified.class);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when sending the command message returns a
-     * <em>Released</em> delivery result.
-     */
-    @Test
-    public void testHandleWithReleasedDeliveryResult() {
-
-        // GIVEN a message sender that returns an 'Released' delivery result
-        final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
-        when(protonDelivery.getRemoteState()).thenReturn(Released.getInstance());
-        delegatedCommandSender = mock(DelegatedCommandSender.class);
-        when(delegatedCommandSender.sendCommandMessage(any(), any())).thenReturn(Future.succeededFuture(protonDelivery));
-
-        // WHEN handle() is invoked
-        delegateViaDownstreamPeerCommandHandler.handle(commandContext);
-
-        // THEN the command context delivery is updated with the 'released' outcome
-        final ArgumentCaptor<DeliveryState> deliveryStateArgumentCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(commandDelivery).disposition(deliveryStateArgumentCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateArgumentCaptor.getValue()).isInstanceOf(Released.class);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when sending the command message fails.
-     */
-    @Test
-    public void testHandleWithFailureToSend() {
-
-        // GIVEN a message sender that fails to send the message
-        delegatedCommandSender = mock(DelegatedCommandSender.class);
-        when(delegatedCommandSender.sendCommandMessage(any(), any())).thenReturn(Future.failedFuture("expected send failure"));
-
-        // WHEN handle() is invoked
-        delegateViaDownstreamPeerCommandHandler.handle(commandContext);
-
-        // THEN the command context delivery is updated with the 'released' outcome
-        final ArgumentCaptor<DeliveryState> deliveryStateArgumentCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(commandDelivery).disposition(deliveryStateArgumentCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateArgumentCaptor.getValue()).isInstanceOf(Released.class);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when creating the message sender fails.
-     */
-    @Test
-    public void testHandleWithFailureToCreateSender() {
-
-        // GIVEN a scenario where sender creation fails
-        delegateViaDownstreamPeerCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
-                (tenantIdParam, deviceIdParam) -> Future.failedFuture("expected sender creation failure"));
-
-        // WHEN handle() is invoked
-        delegateViaDownstreamPeerCommandHandler.handle(commandContext);
-
-        // THEN the command context delivery is updated with the 'released' outcome
-        final ArgumentCaptor<DeliveryState> deliveryStateArgumentCaptor = ArgumentCaptor.forClass(DeliveryState.class);
-        verify(commandDelivery).disposition(deliveryStateArgumentCaptor.capture(), anyBoolean());
-        assertThat(deliveryStateArgumentCaptor.getValue()).isInstanceOf(Released.class);
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/GatewayMapperImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/GatewayMapperImplTest.java
deleted file mode 100644
index c21d63228..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/GatewayMapperImplTest.java
+++ /dev/null
@@ -1,241 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.net.HttpURLConnection;
-import java.util.Collections;
-
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.DeviceConnectionClientFactory;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.RegistrationClientFactory;
-import org.eclipse.hono.client.ServerErrorException;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.RegistrationConstants;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.vertx.core.Future;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-
-/**
- * Verifies behavior of {@link GatewayMapperImpl}.
- */
-public class GatewayMapperImplTest {
-
-    private GatewayMapperImpl gatewayMapper;
-    private RegistrationClient regClient;
-    private DeviceConnectionClient devConClient;
-    private String tenantId;
-    private String deviceId;
-    private Span span;
-
-    /**
-     * Sets up common fixture.
-     */
-    @BeforeEach
-    public void setup() {
-        final SpanContext spanContext = mock(SpanContext.class);
-        span = mock(Span.class);
-        when(span.context()).thenReturn(spanContext);
-        final Tracer.SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
-        final Tracer tracer = mock(Tracer.class);
-        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
-
-        tenantId = "testTenant";
-        deviceId = "testDevice";
-        regClient = mock(RegistrationClient.class);
-        final RegistrationClientFactory registrationClientFactory = mock(RegistrationClientFactory.class);
-        when(registrationClientFactory.getOrCreateRegistrationClient(anyString()))
-                .thenReturn(Future.succeededFuture(regClient));
-
-        devConClient = mock(DeviceConnectionClient.class);
-        final DeviceConnectionClientFactory deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);
-        when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
-                .thenReturn(Future.succeededFuture(devConClient));
-        gatewayMapper = new GatewayMapperImpl(registrationClientFactory, deviceConnectionClientFactory, tracer);
-    }
-
-    /**
-     * Verifies that the <em>getMappedGatewayDevice</em> method returns a Future with the device id as result for a
-     * device for which no 'via' entry is set.
-     */
-    @Test
-    public void testGetMappedGatewayDeviceUsingDeviceWithNoVia() {
-        // GIVEN assertRegistration result with no 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, null);
-
-        // THEN the returned Future is complete and contains the deviceId
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(deviceId);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that the <em>getMappedGatewayDevice</em> method returns the gateway set in both the 'via' entry of
-     * the given device and the <em>getLastKnownGatewayForDevice</em> operation return value.
-     */
-    @Test
-    public void testGetMappedGatewayDeviceUsingDeviceWithMappedGateway() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistration result with non-empty 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a non-empty getLastKnownGatewayForDevice result
-        final JsonObject lastKnownGatewayResult = new JsonObject();
-        lastKnownGatewayResult.put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any())).thenReturn(Future.succeededFuture(lastKnownGatewayResult));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, null);
-
-        // THEN the returned Future is complete and contains the gatewayId
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(gatewayId);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that the <em>getMappedGatewayDevice</em> method returns the single gateway entry of a device's 'via'
-     * entry if no gateway is returned by the <em>getLastKnownGatewayForDevice</em> operation.
-     */
-    @Test
-    public void testGetMappedGatewayDeviceReturningSingleDefinedViaGateway() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistrationResult with a single 'via' array entry
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a 404 getLastKnownGatewayForDevice response
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any()))
-                .thenReturn(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, null);
-
-        // THEN the returned Future is complete and contains the gatewayId
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isEqualTo(gatewayId);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that the <em>getMappedGatewayDevice</em> method returns a failed Future if no gateway is returned by
-     * the <em>getLastKnownGatewayForDevice</em> operation and the device has multiple gateways defined in its 'via'
-     * entry.
-     */
-    @Test
-    public void testGetMappedGatewayDeviceFailureUsingMultiGatewayDevice() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistrationResult with 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray();
-        viaArray.add(gatewayId);
-        viaArray.add("otherGatewayId");
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a 404 getLastKnownGatewayForDevice response
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any()))
-                .thenReturn(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, null);
-
-        // THEN the returned Future is failed
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isNull();
-        assertThat(mappedGatewayDeviceFuture.cause()).isInstanceOf(ClientErrorException.class);
-        assertThat(((ClientErrorException) mappedGatewayDeviceFuture.cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_NOT_FOUND);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that the <em>getMappedGatewayDevice</em> method returns a failed Future if the gateway returned by
-     * the <em>getLastKnownGatewayForDevice</em> operation is not in the list of gateways of the device's 'via' entry.
-     */
-    @Test
-    public void testGetMappedGatewayDeviceFailureIfGatewayNotInVia() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistrationResult with 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a getLastKnownGatewayForDevice response with a different gateway
-        final JsonObject lastKnownGatewayResult = new JsonObject();
-        lastKnownGatewayResult.put(DeviceConnectionConstants.FIELD_GATEWAY_ID, "otherGatewayId");
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any())).thenReturn(Future.succeededFuture(lastKnownGatewayResult));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, null);
-
-        // THEN the returned Future is failed
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isNull();;
-        assertThat(mappedGatewayDeviceFuture.cause()).isInstanceOf(ClientErrorException.class);
-        assertThat(((ClientErrorException) mappedGatewayDeviceFuture.cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_NOT_FOUND);
-        verify(span).finish();
-    }
-
-    /**
-     * Verifies that the <em>getMappedGatewayDevice</em> method returns a failed Future if the
-     * <em>getLastKnownGatewayForDevice</em> operation failed.
-     */
-    @Test
-    public void testGetMappedGatewayDeviceFailureIfGetLastGatewayFailed() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistrationResult with 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a 500 getLastKnownGatewayForDevice response
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any()))
-                .thenReturn(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR)));
-
-        // WHEN getMappedGatewayDevice() is invoked
-        final Future<String> mappedGatewayDeviceFuture = gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, null);
-
-        // THEN the returned Future is failed
-        assertThat(mappedGatewayDeviceFuture.isComplete()).isTrue();
-        assertThat(mappedGatewayDeviceFuture.result()).isNull();;
-        assertThat(mappedGatewayDeviceFuture.cause()).isInstanceOf(ServerErrorException.class);
-        assertThat(((ServerErrorException) mappedGatewayDeviceFuture.cause()).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_INTERNAL_ERROR);
-        verify(span).finish();
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/GatewayMappingCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/GatewayMappingCommandHandlerTest.java
deleted file mode 100644
index 724239516..000000000
--- a/client/src/test/java/org/eclipse/hono/client/impl/GatewayMappingCommandHandlerTest.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client.impl;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
-import java.net.HttpURLConnection;
-import java.util.Collections;
-
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.DeviceConnectionClient;
-import org.eclipse.hono.client.DeviceConnectionClientFactory;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.RegistrationClientFactory;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.DeviceConnectionConstants;
-import org.eclipse.hono.util.RegistrationConstants;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.mockito.ArgumentCaptor;
-
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.json.JsonArray;
-import io.vertx.core.json.JsonObject;
-import io.vertx.proton.ProtonDelivery;
-
-/**
- * Verifies behavior of {@link GatewayMappingCommandHandler}.
- */
-public class GatewayMappingCommandHandlerTest {
-
-    private RegistrationClient regClient;
-    private DeviceConnectionClient devConClient;
-    private String tenantId;
-    private String deviceId;
-    private Handler<CommandContext> nextCommandHandler;
-    private GatewayMappingCommandHandler gatewayMappingCommandHandler;
-    private CommandContext commandContext;
-    private Message commandMessage;
-
-    /**
-     * Sets up common fixture.
-     */
-    @BeforeEach
-    public void setup() {
-        final SpanContext spanContext = mock(SpanContext.class);
-        final Span span = mock(Span.class);
-        when(span.context()).thenReturn(spanContext);
-        final Tracer.SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
-        final Tracer tracer = mock(Tracer.class);
-        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
-
-        tenantId = "testTenant";
-        deviceId = "testDevice";
-        regClient = mock(RegistrationClient.class);
-        final RegistrationClientFactory registrationClientFactory = mock(RegistrationClientFactory.class);
-        when(registrationClientFactory.getOrCreateRegistrationClient(anyString()))
-                .thenReturn(Future.succeededFuture(regClient));
-
-        devConClient = mock(DeviceConnectionClient.class);
-        final DeviceConnectionClientFactory deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);
-        when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
-                .thenReturn(Future.succeededFuture(devConClient));
-        final GatewayMapperImpl gatewayMapper = new GatewayMapperImpl(registrationClientFactory, deviceConnectionClientFactory, tracer);
-
-        nextCommandHandler = VertxMockSupport.mockHandler();
-        gatewayMappingCommandHandler = new GatewayMappingCommandHandler(gatewayMapper, nextCommandHandler);
-
-        commandMessage = mock(Message.class);
-        when(commandMessage.getAddress()).thenReturn(String.format("%s/%s/%s",
-                CommandConstants.COMMAND_ENDPOINT, tenantId, deviceId));
-        when(commandMessage.getSubject()).thenReturn("testSubject");
-        when(commandMessage.getCorrelationId()).thenReturn("testCorrelationId");
-        final Command command = Command.from(commandMessage, tenantId, deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        final Span currentSpan = mock(Span.class);
-        commandContext = spy(CommandContext.from(command, delivery, currentSpan));
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when called in the context of a device for which no
-     * 'via' entry is set.
-     */
-    @Test
-    public void testHandleUsingEmptyDeviceData() {
-        // GIVEN assertRegistrationResult with no 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-
-        // WHEN handle() is invoked
-        gatewayMappingCommandHandler.handle(commandContext);
-
-        // THEN the nextCommandHandler is called with the original commandContext
-        final ArgumentCaptor<CommandContext> commandContextArgumentCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(nextCommandHandler).handle(commandContextArgumentCaptor.capture());
-        assertThat(commandContextArgumentCaptor.getValue()).isEqualTo(commandContext);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when called in the context of a device for which a
-     * 'via' entry is set and for which the last known gateway is set.
-     */
-    @Test
-    public void testHandleReturningLastUsedGateway() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistration result with non-empty 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a non-empty getLastKnownGatewayForDevice result
-        final JsonObject lastKnownGatewayResult = new JsonObject();
-        lastKnownGatewayResult.put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any())).thenReturn(Future.succeededFuture(lastKnownGatewayResult));
-
-        // WHEN handle() is invoked
-        gatewayMappingCommandHandler.handle(commandContext);
-
-        // THEN the nextCommandHandler is called with an adapted commandContext (with gatewayId)
-        final ArgumentCaptor<CommandContext> commandContextArgumentCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(nextCommandHandler).handle(commandContextArgumentCaptor.capture());
-        assertThat(commandContextArgumentCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when called in the context of a device for which a
-     * 'via' entry is set and for which the last known gateway is set and where the command has a 'reply-to' value set.
-     */
-    @Test
-    public void testHandleReturningLastUsedGatewayWithCommandReplyToSet() {
-        final String gatewayId = "testDeviceVia";
-        final String replyToId = "the-reply-to-id";
-        final String replyTo = String.format("%s/%s/%s", CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT, tenantId, replyToId);
-
-        // GIVEN assertRegistration result with non-empty 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a non-empty getLastKnownGatewayForDevice result
-        final JsonObject lastKnownGatewayResult = new JsonObject();
-        lastKnownGatewayResult.put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any())).thenReturn(Future.succeededFuture(lastKnownGatewayResult));
-
-        // AND a commandMessage with reply-to set
-        when(commandMessage.getReplyTo()).thenReturn(replyTo);
-        final Command command = Command.from(commandMessage, tenantId, deviceId);
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        final Span currentSpan = mock(Span.class);
-        commandContext = spy(CommandContext.from(command, delivery, currentSpan));
-
-        // WHEN handle() is invoked
-        gatewayMappingCommandHandler.handle(commandContext);
-
-        // THEN the nextCommandHandler is called with an adapted commandContext (with gatewayId) and original reply-to id
-        final ArgumentCaptor<CommandContext> commandContextArgumentCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(nextCommandHandler).handle(commandContextArgumentCaptor.capture());
-        assertThat(commandContextArgumentCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
-        assertThat(commandContextArgumentCaptor.getValue().getCommand().getCommandMessage().getReplyTo()).isEqualTo(replyTo);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when called in the context of a device for which the
-     * 'via' entry contains one gateway and for which no last known gateway is set.
-     */
-    @Test
-    public void testHandleReturningSingleViaGateway() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistrationResult with a single 'via' array entry
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray(Collections.singletonList(gatewayId));
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a 404 getLastKnownGatewayForDevice response
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any()))
-                .thenReturn(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)));
-
-        // WHEN handle() is invoked
-        gatewayMappingCommandHandler.handle(commandContext);
-
-        // THEN the nextCommandHandler is called with an adapted commandContext (with gatewayId)
-        final ArgumentCaptor<CommandContext> commandContextArgumentCaptor = ArgumentCaptor.forClass(CommandContext.class);
-        verify(nextCommandHandler).handle(commandContextArgumentCaptor.capture());
-        assertThat(commandContextArgumentCaptor.getValue().getCommand().getDeviceId()).isEqualTo(gatewayId);
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when no mapped gateway could be determined.
-     */
-    @Test
-    public void testHandleWithNoMappedGatewayFound() {
-        final String gatewayId = "testDeviceVia";
-
-        // GIVEN assertRegistrationResult with 'via'
-        final JsonObject assertRegistrationResult = new JsonObject();
-        final JsonArray viaArray = new JsonArray();
-        viaArray.add(gatewayId);
-        viaArray.add("otherGatewayId");
-        assertRegistrationResult.put(RegistrationConstants.FIELD_VIA, viaArray);
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.succeededFuture(assertRegistrationResult));
-        // and a 404 getLastKnownGatewayForDevice response
-        when(devConClient.getLastKnownGatewayForDevice(anyString(), any()))
-                .thenReturn(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)));
-
-        // WHEN handle() is invoked
-        gatewayMappingCommandHandler.handle(commandContext);
-
-        // THEN the nextCommandHandler is not invoked and the commandContext is released
-        verifyZeroInteractions(nextCommandHandler);
-        verify(commandContext).release();
-    }
-
-    /**
-     * Verifies that the <em>handle</em> method behaves correctly when there is an exception retrieving device data.
-     */
-    @Test
-    public void testHandleWithRegistrationClientException() {
-        // GIVEN a registrationClient that returns a failed future
-        when(regClient.assertRegistration(anyString(), any(), any())).thenReturn(Future.failedFuture("expected exception"));
-
-        // WHEN handle() is invoked
-        gatewayMappingCommandHandler.handle(commandContext);
-
-        // THEN the nextCommandHandler is not invoked and the commandContext is released
-        verifyZeroInteractions(nextCommandHandler);
-        verify(commandContext).release();
-    }
-}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandlerTest.java
new file mode 100644
index 000000000..3d8bff4bd
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandlerTest.java
@@ -0,0 +1,490 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.net.HttpURLConnection;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.messaging.Released;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.Command;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.client.CommandTargetMapper;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.DeviceConnectionConstants;
+import org.eclipse.hono.util.MessageHelper;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.core.eventbus.EventBus;
+import io.vertx.core.json.JsonObject;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * Verifies behavior of {@link MappingAndDelegatingCommandHandler}.
+ */
+public class MappingAndDelegatingCommandHandlerTest {
+
+    private CommandTargetMapper commandTargetMapper;
+    private AdapterInstanceCommandHandler adapterInstanceCommandHandler;
+    private String adapterInstanceId;
+    private MappingAndDelegatingCommandHandler mappingAndDelegatingCommandHandler;
+    // sender used in the DelegatedCommandSender
+    private ProtonSender sender;
+
+    /**
+     * Sets up fixture.
+     */
+    @BeforeEach
+    public void setUp() {
+        final SpanContext spanContext = mock(SpanContext.class);
+        final Span span = mock(Span.class);
+        when(span.context()).thenReturn(spanContext);
+        final Tracer.SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
+        final Tracer tracer = mock(Tracer.class);
+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
+
+        final Vertx vertx = mock(Vertx.class);
+        final Context context = HonoClientUnitTestHelper.mockContext(vertx);
+        when(vertx.getOrCreateContext()).thenReturn(context);
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgument(1);
+            handler.handle(null);
+            return null;
+        }).when(vertx).setTimer(anyLong(), VertxMockSupport.anyHandler());
+        final EventBus eventBus = mock(EventBus.class);
+        when(vertx.eventBus()).thenReturn(eventBus);
+
+        adapterInstanceId = UUID.randomUUID().toString();
+
+        final ClientConfigProperties props = new ClientConfigProperties();
+        props.setSendMessageTimeout(0);
+        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, props);
+        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
+        sender = HonoClientUnitTestHelper.mockProtonSender();
+        when(connection.createSender(anyString(), any(), any())).thenReturn(Future.succeededFuture(sender));
+
+        adapterInstanceCommandHandler = new AdapterInstanceCommandHandler(tracer, adapterInstanceId);
+        commandTargetMapper = mock(CommandTargetMapper.class);
+
+        mappingAndDelegatingCommandHandler = new MappingAndDelegatingCommandHandler(
+                connection, commandTargetMapper, adapterInstanceCommandHandler, adapterInstanceId);
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the given command message shall get mapped to a local command handler.
+     */
+    @Test
+    public void testMapWithLocalCommandHandler() {
+        final String deviceId = "4711";
+
+        // GIVEN a registered commandHandler for the deviceId
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
+
+        // AND the deviceId commandHandler registered for the local adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
+
+        // WHEN mapping and delegating the command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the local command handler is invoked with the unchanged command message
+        assertThat(localHandlerCmdContextRef.get()).isNotNull();
+        assertThat(localHandlerCmdContextRef.get().getCommand()).isNotNull();
+        assertThat(localHandlerCmdContextRef.get().getCommand().getCommandMessage()).isEqualTo(message);
+        assertThat(localHandlerCmdContextRef.get().getCommand().isValid()).isTrue();
+        // AND the command message delivery is unchanged (that would be done by the commandHandler)
+        verify(delivery, never()).disposition(any(), anyBoolean());
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the given <em>invalid</em> command message shall get mapped to a local command handler.
+     */
+    @Test
+    public void testMapWithLocalCommandHandlerAndInvalidMessage() {
+        final String deviceId = "4711";
+
+        // GIVEN a registered commandHandler for the deviceId
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
+
+        // AND the deviceId commandHandler registered for the local adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
+
+        // WHEN mapping and delegating an invalid command message
+        final Message message = getValidCommandMessage(deviceId);
+        message.setSubject(null); // make the message invalid
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the local command handler is invoked with the unchanged command message
+        assertThat(localHandlerCmdContextRef.get()).isNotNull();
+        assertThat(localHandlerCmdContextRef.get().getCommand()).isNotNull();
+        assertThat(localHandlerCmdContextRef.get().getCommand().getCommandMessage()).isEqualTo(message);
+        assertThat(localHandlerCmdContextRef.get().getCommand().isValid()).isFalse();
+        // AND the command message delivery is unchanged (that would be done by the commandHandler)
+        verify(delivery, never()).disposition(any(), anyBoolean());
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the given command message has an invalid <em>to</em> address.
+     */
+    @Test
+    public void testMapWithMessageHavingInvalidAddress() {
+        final String deviceId = "4711";
+
+        // WHEN mapping and delegating a command message with an invalid address
+        final Message message = getValidCommandMessage(deviceId);
+        message.setAddress("invalid address");
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the disposition is REJECTED
+        verify(delivery).disposition(any(Rejected.class), eq(true));
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * no command handling adapter instance is found for the command message device.
+     */
+    @Test
+    public void testMapWithNoAdapterInstanceFound() {
+        final String deviceId = "4711";
+
+        // GIVEN no registered commandHandler for the deviceId
+        // but a deviceId commandHandler registered for the local adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
+
+        // WHEN mapping and delegating a command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the disposition is RELEASED
+        verify(delivery).disposition(any(Released.class), eq(true));
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * no command handling adapter instance is found for the command message device and the command message
+     * is invalid.
+     */
+    @Test
+    public void testMapWithNoAdapterInstanceFoundAndMessageInvalid() {
+        final String deviceId = "4711";
+
+        // GIVEN no registered commandHandler for the deviceId
+        // but a deviceId commandHandler registered for the local adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
+
+        // WHEN mapping and delegating an invalid command message
+        final Message message = getValidCommandMessage(deviceId);
+        message.setSubject(null); // make the message invalid
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the disposition is REJECTED
+        verify(delivery).disposition(any(Rejected.class), eq(true));
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the command handler is not found.
+     */
+    @Test
+    public void testMapWithCommandHandlerNotFound() {
+        final String deviceId = "4711";
+
+        // GIVEN a 'NOT_FOUND' error when looking up the adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)));
+
+        // WHEN mapping and delegating a command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the disposition is RELEASED
+        verify(delivery).disposition(any(Released.class), eq(true));
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the given command message shall get mapped to a local command handler, handling commands for a gateway.
+     */
+    @Test
+    public void testMapWithLocalCommandHandlerForGateway() {
+        final String deviceId = "4711";
+        final String gatewayId = "gw-1";
+
+        // GIVEN a registered commandHandler for the gateway
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, gatewayId, null, localHandlerCmdContextRef::set);
+
+        // AND the gatewayId commandHandler registered for the local adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(gatewayId, adapterInstanceId)));
+
+        // WHEN mapping and delegating the command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the local command handler is invoked with the command message, its device id set to the gateway
+        assertThat(localHandlerCmdContextRef.get()).isNotNull();
+        final Command command = localHandlerCmdContextRef.get().getCommand();
+        assertThat(command).isNotNull();
+        assertThat(command.isValid()).isTrue();
+        assertThat(command.getDeviceId()).isEqualTo(gatewayId);
+        assertThat(command.getOriginalDeviceId()).isEqualTo(deviceId);
+        // AND the command message delivery is unchanged (that would be done by the commandHandler)
+        verify(delivery, never()).disposition(any(), anyBoolean());
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the given command message shall get mapped to a local command handler, handling commands for the specific
+     * device for a gateway.
+     */
+    @Test
+    public void testMapWithLocalCommandHandlerForGatewayAndSpecificDevice() {
+        final String deviceId = "4711";
+        final String gatewayId = "gw-1";
+
+        // GIVEN a registered commandHandler for the deviceId and gatewayId
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, gatewayId, localHandlerCmdContextRef::set);
+
+        // AND the deviceId commandHandler registered for the local adapter instance
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, adapterInstanceId)));
+
+        // WHEN mapping and delegating the command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the local command handler is invoked with the command message, its device id set to the gateway
+        assertThat(localHandlerCmdContextRef.get()).isNotNull();
+        final Command command = localHandlerCmdContextRef.get().getCommand();
+        assertThat(command).isNotNull();
+        assertThat(command.isValid()).isTrue();
+        assertThat(command.getDeviceId()).isEqualTo(gatewayId);
+        assertThat(command.getOriginalDeviceId()).isEqualTo(deviceId);
+        // AND the command message delivery is unchanged (that would be done by the commandHandler)
+        verify(delivery, never()).disposition(any(), anyBoolean());
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the command shall get handled by another adapter instance.
+     */
+    @Test
+    public void testMapWithCommandHandlerOnAnotherInstance() {
+        final String deviceId = "4711";
+
+        // GIVEN a deviceId commandHandler registered for another adapter instance (not the local one)
+        final String otherAdapterInstance = "otherAdapterInstance";
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, otherAdapterInstance)));
+
+        // AND an ACCEPTED result when sending the command message to another adapter instance
+        final ProtonDelivery sendMsgDeliveryUpdate = mock(ProtonDelivery.class);
+        when(sendMsgDeliveryUpdate.getRemoteState()).thenReturn(new Accepted());
+        when(sendMsgDeliveryUpdate.remotelySettled()).thenReturn(true);
+        final AtomicReference<Message> delegatedMessageRef = new AtomicReference<>();
+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
+            delegatedMessageRef.set(invocation.getArgument(0));
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(sendMsgDeliveryUpdate);
+            return mock(ProtonDelivery.class);
+        });
+
+        // register local command handler - that shall not get used
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
+
+        // WHEN mapping and delegating the command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the delivery gets ACCEPTED as well
+        verify(delivery).disposition(any(Accepted.class), eq(true));
+        assertThat(localHandlerCmdContextRef.get()).isNull();
+        final Message delegatedMessage = delegatedMessageRef.get();
+        assertThat(delegatedMessage).isNotNull();
+        assertThat(delegatedMessage.getAddress()).isEqualTo(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the command shall get handled by another adapter instance, and the command message is invalid.
+     */
+    @Test
+    public void testMapWithCommandHandlerOnAnotherInstanceWithInvalidMessage() {
+        final String deviceId = "4711";
+
+        // GIVEN a deviceId commandHandler registered for another adapter instance (not the local one)
+        final String otherAdapterInstance = "otherAdapterInstance";
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, otherAdapterInstance)));
+
+        // register local command handler - that shall not get used
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
+
+        // WHEN mapping and delegating the invalid command message
+        final Message message = getValidCommandMessage(deviceId);
+        message.setSubject(null); // make the message invalid
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the delivery gets REJECTED
+        verify(delivery).disposition(any(Rejected.class), eq(true));
+        assertThat(localHandlerCmdContextRef.get()).isNull();
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the command shall get handled by another adapter instance and where sending the command message to
+     * the adapter instance fails.
+     */
+    @Test
+    public void testMapWithCommandHandlerOnAnotherInstanceWithMessageSendingFailed() {
+        final String deviceId = "4711";
+
+        // GIVEN a deviceId commandHandler registered for another adapter instance (not the local one)
+        final String otherAdapterInstance = "otherAdapterInstance";
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(deviceId, otherAdapterInstance)));
+
+        // AND an error when sending the command message to another adapter instance (no credit)
+        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
+
+        // register local command handler - that shall not get used
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, deviceId, null, localHandlerCmdContextRef::set);
+
+        // WHEN mapping and delegating the command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the delivery gets RELEASED
+        verify(delivery).disposition(any(Released.class), eq(true));
+        assertThat(localHandlerCmdContextRef.get()).isNull();
+    }
+
+    /**
+     * Verifies the behaviour of the <em>mapAndDelegateIncomingCommandMessage</em> method in a scenario where
+     * the command shall get handled by another adapter instance, the command handler being set for a gateway.
+     */
+    @Test
+    public void testMapWithCommandHandlerForGatewayOnAnotherInstance() {
+        final String deviceId = "4711";
+        final String gatewayId = "gw-1";
+
+        // GIVEN a gateway commandHandler registered for another adapter instance (not the local one)
+        final String otherAdapterInstance = "otherAdapterInstance";
+        when(commandTargetMapper.getTargetGatewayAndAdapterInstance(anyString(), anyString(), any()))
+                .thenReturn(Future.succeededFuture(createTargetAdapterInstanceJson(gatewayId, otherAdapterInstance)));
+
+        // AND an ACCEPTED result when sending the command message to another adapter instance
+        final ProtonDelivery sendMsgDeliveryUpdate = mock(ProtonDelivery.class);
+        when(sendMsgDeliveryUpdate.getRemoteState()).thenReturn(new Accepted());
+        when(sendMsgDeliveryUpdate.remotelySettled()).thenReturn(true);
+        final AtomicReference<Message> delegatedMessageRef = new AtomicReference<>();
+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
+            delegatedMessageRef.set(invocation.getArgument(0));
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(sendMsgDeliveryUpdate);
+            return mock(ProtonDelivery.class);
+        });
+
+        // register local command handler - that shall not get used
+        final AtomicReference<CommandContext> localHandlerCmdContextRef = new AtomicReference<>();
+        adapterInstanceCommandHandler.putDeviceSpecificCommandHandler(Constants.DEFAULT_TENANT, gatewayId, null, localHandlerCmdContextRef::set);
+
+        // WHEN mapping and delegating the command message
+        final Message message = getValidCommandMessage(deviceId);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        mappingAndDelegatingCommandHandler.mapAndDelegateIncomingCommandMessage(Constants.DEFAULT_TENANT, delivery, message);
+
+        // THEN the delivery gets ACCEPTED as well
+        verify(delivery).disposition(any(Accepted.class), eq(true));
+        assertThat(localHandlerCmdContextRef.get()).isNull();
+        final Message delegatedMessage = delegatedMessageRef.get();
+        assertThat(delegatedMessage).isNotNull();
+        assertThat(delegatedMessage.getAddress()).isEqualTo(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+        final String viaProperty = MessageHelper.getApplicationProperty(delegatedMessage.getApplicationProperties(),
+                MessageHelper.APP_PROPERTY_CMD_VIA, String.class);
+        assertThat(viaProperty).isEqualTo(gatewayId);
+    }
+
+    private JsonObject createTargetAdapterInstanceJson(final String deviceId, final String otherAdapterInstance) {
+        final JsonObject targetAdapterInstanceJson = new JsonObject();
+        targetAdapterInstanceJson.put(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId);
+        targetAdapterInstanceJson.put(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID, otherAdapterInstance);
+        return targetAdapterInstanceJson;
+    }
+
+    private Message getValidCommandMessage(final String deviceId) {
+        final Message message = ProtonHelper.message("input data");
+        message.setAddress(String.format("%s/%s/%s",
+                CommandConstants.COMMAND_ENDPOINT, Constants.DEFAULT_TENANT, deviceId));
+        message.setSubject("doThis");
+        message.setCorrelationId("the-correlation-id");
+        return message;
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
new file mode 100644
index 000000000..8b4ac19c0
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
@@ -0,0 +1,182 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.net.HttpURLConnection;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.client.CommandTargetMapper;
+import org.eclipse.hono.client.DeviceConnectionClient;
+import org.eclipse.hono.client.DeviceConnectionClientFactory;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.ResourceIdentifier;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.core.eventbus.EventBus;
+import io.vertx.junit5.Timeout;
+import io.vertx.junit5.VertxExtension;
+import io.vertx.junit5.VertxTestContext;
+import io.vertx.proton.ProtonMessageHandler;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+
+
+/**
+ * Verifies behavior of {@link ProtocolAdapterCommandConsumerFactoryImpl}.
+ *
+ */
+@ExtendWith(VertxExtension.class)
+@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)
+public class ProtocolAdapterCommandConsumerFactoryImplTest {
+
+    private Vertx vertx;
+    private Context context;
+    private ClientConfigProperties props;
+    private HonoConnection connection;
+    private ProtocolAdapterCommandConsumerFactoryImpl commandConsumerFactory;
+    private CommandTargetMapper commandTargetMapper;
+    private DeviceConnectionClient devConClient;
+    private ProtonReceiver adapterInstanceCommandReceiver;
+    private ProtonReceiver mappingAndDelegatingCommandReceiver;
+    private String adapterInstanceCommandConsumerAddress;
+    private String tenantCommandAddress;
+    private String tenantId;
+    private String deviceId;
+    private String gatewayId;
+    private String adapterInstanceId;
+
+    /**
+     * Sets up fixture.
+     */
+    @BeforeEach
+    public void setUp() {
+
+        vertx = mock(Vertx.class);
+        context = HonoClientUnitTestHelper.mockContext(vertx);
+        when(vertx.getOrCreateContext()).thenReturn(context);
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgument(1);
+            handler.handle(null);
+            return null;
+        }).when(vertx).setTimer(anyLong(), VertxMockSupport.anyHandler());
+        final EventBus eventBus = mock(EventBus.class);
+        when(vertx.eventBus()).thenReturn(eventBus);
+
+        deviceId = "theDevice";
+        gatewayId = "theGateway";
+        tenantId = "theTenant";
+        adapterInstanceId = UUID.randomUUID().toString();
+
+        props = new ClientConfigProperties();
+
+        connection = HonoClientUnitTestHelper.mockHonoConnection(vertx, props);
+
+        adapterInstanceCommandReceiver = mock(ProtonReceiver.class);
+        adapterInstanceCommandConsumerAddress = CommandConstants.INTERNAL_COMMAND_ENDPOINT + "/" + adapterInstanceId;
+
+        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
+        when(connection.createReceiver(
+                eq(adapterInstanceCommandConsumerAddress),
+                any(ProtonQoS.class),
+                any(ProtonMessageHandler.class),
+                anyInt(),
+                anyBoolean(),
+                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(adapterInstanceCommandReceiver));
+        mappingAndDelegatingCommandReceiver = mock(ProtonReceiver.class);
+        tenantCommandAddress = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
+        when(connection.createReceiver(
+                eq(tenantCommandAddress),
+                any(ProtonQoS.class),
+                any(ProtonMessageHandler.class),
+                anyInt(),
+                anyBoolean(),
+                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(mappingAndDelegatingCommandReceiver));
+        commandTargetMapper = mock(CommandTargetMapper.class);
+        devConClient = mock(DeviceConnectionClient.class);
+        final DeviceConnectionClientFactory deviceConnectionClientFactory = mock(DeviceConnectionClientFactory.class);
+        when(deviceConnectionClientFactory.connect()).thenReturn(Future.succeededFuture(mock(HonoConnection.class)));
+        when(deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(anyString()))
+                .thenReturn(Future.succeededFuture(devConClient));
+        when(devConClient.setCommandHandlingAdapterInstance(anyString(), anyString(), any())).thenReturn(Future.succeededFuture());
+
+        commandConsumerFactory = new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);
+        commandConsumerFactory.initialize(commandTargetMapper, deviceConnectionClientFactory);
+    }
+
+    /**
+     * Verifies that an attempt to open a command consumer fails if the peer
+     * rejects to open a receiver link.
+     *
+     * @param ctx The test context.
+     */
+    @Test
+    public void testCreateCommandConsumerFailsIfPeerRejectsLink(final VertxTestContext ctx) {
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+        final ServerErrorException ex = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE);
+        when(connection.createReceiver(
+                anyString(),
+                any(ProtonQoS.class),
+                any(ProtonMessageHandler.class),
+                anyInt(),
+                anyBoolean(),
+                VertxMockSupport.anyHandler()))
+        .thenReturn(Future.failedFuture(ex));
+
+        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler)
+            .setHandler(ctx.failing(t -> {
+                ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
+                ctx.completeNow();
+            }));
+    }
+
+    /**
+     * Verifies that the connection successfully opens a command consumer for a
+     * tenant and device Id and opens a receiver link that is scoped to the device.
+     *
+     * @param ctx The test context.
+     */
+    @Test
+    public void testCreateCommandConsumerSucceeds(final VertxTestContext ctx) {
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+
+        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler)
+            .setHandler(ctx.completing());
+    }
+
+}
