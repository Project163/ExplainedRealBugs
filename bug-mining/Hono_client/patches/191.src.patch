diff --git a/client/src/main/java/org/eclipse/hono/client/Command.java b/client/src/main/java/org/eclipse/hono/client/Command.java
index 2aed664ef..9cfa6eeac 100644
--- a/client/src/main/java/org/eclipse/hono/client/Command.java
+++ b/client/src/main/java/org/eclipse/hono/client/Command.java
@@ -282,7 +282,7 @@ public final class Command {
     public String getOriginalDeviceId() {
         if (isValid()) {
             // commands directed at the legacy control endpoint didn't have to have the message address set
-            // (and it's content didn't get checked), that's why the 'deviceId' field is used as fallback here
+            // (and its content didn't get checked), that's why the 'deviceId' field is used as fallback here
             final String addressDeviceId = message.getAddress() != null
                     ? ResourceIdentifier.fromString(message.getAddress()).getResourceId()
                     : null;
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
index 9f6dcbdf6..db04baac9 100644
--- a/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
@@ -71,6 +71,44 @@ public interface CommandConsumerFactory extends ConnectionLifecycle<HonoConnecti
             Handler<CommandContext> commandHandler,
             Handler<Void> remoteCloseHandler);
 
+    /**
+     * Creates a command consumer for a device.
+     * <p>
+     * For each device only one command consumer may be active at any given time.
+     * It is the responsibility of the calling code to properly close a consumer
+     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
+     * method.
+     *
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @param gatewayId The gateway that wants to act on behalf of the device.
+     * @param commandHandler The handler to invoke with every command received.
+     * @param remoteCloseHandler A handler to be invoked after the link has been closed
+     *                     at the peer's request or {@code null} if no handler should
+     *                     be invoked. Note that all consumers with the same gateway Id
+     *                     will share the same link, so that once the link is closed,
+     *                     all corresponding closeHandlers will be invoked.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be completed with the newly created consumer once the link
+     *         has been established.
+     *         <p>
+     *         The future will be failed with
+     *         <ul>
+     *         <li>a {@link ResourceConflictException} if there already is
+     *         a command consumer active for the given device</li>
+     *         <li>a {@link ServiceInvocationException} with an error code indicating
+     *         the cause of the failure</li>
+     *         </ul>
+     * @throws NullPointerException if any of tenant, device ID, gateway ID or command handler are {@code null}.
+     */
+    Future<MessageConsumer> createCommandConsumer(
+            String tenantId,
+            String deviceId,
+            String gatewayId,
+            Handler<CommandContext> commandHandler,
+            Handler<Void> remoteCloseHandler);
+
     /**
      * Creates a command consumer for a device.
      * <p>
@@ -115,6 +153,54 @@ public interface CommandConsumerFactory extends ConnectionLifecycle<HonoConnecti
             Handler<Void> remoteCloseHandler,
             long livenessCheckInterval);
 
+    /**
+     * Creates a command consumer for a device.
+     * <p>
+     * For each device only one command consumer may be active at any given time.
+     * It is the responsibility of the calling code to properly close a consumer
+     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}
+     * method.
+     * <p>
+     * The underlying link for receiving the commands will be checked periodically
+     * after the given number of milliseconds. If the link is no longer active, e.g.
+     * because the underlying connection to the peer has been lost or the peer has
+     * closed the link, then this client will try to re-establish the link using the
+     * given parameters.
+     *
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @param gatewayId The gateway that wants to act on behalf of the device.
+     * @param commandHandler The handler to invoke with every command received.
+     * @param remoteCloseHandler A handler to be invoked after the link has been closed
+     *                     at the peer's request. Note that all consumers with the same gateway Id
+     *                     will share the same link, so that once the link is closed,
+     *                     all corresponding closeHandlers will be invoked.
+     * @param livenessCheckInterval The number of milliseconds to wait between checking
+     *                              liveness of the created link. If the check fails,
+     *                              an attempt will be made to re-establish the link.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be completed with the newly created consumer once the link
+     *         has been established.
+     *         <p>
+     *         The future will be failed with
+     *         <ul>
+     *         <li>a {@link ResourceConflictException} if there already is
+     *         a command consumer active for the given device</li>
+     *         <li>a {@link ServiceInvocationException} with an error code indicating
+     *         the cause of the failure</li>
+     *         </ul>
+     * @throws NullPointerException if tenant, device ID, gateway ID or command handler are {@code null}.
+     * @throws IllegalArgumentException if the checkInterval is negative.
+     */
+    Future<MessageConsumer> createCommandConsumer(
+            String tenantId,
+            String deviceId,
+            String gatewayId,
+            Handler<CommandContext> commandHandler,
+            Handler<Void> remoteCloseHandler,
+            long livenessCheckInterval);
+
     /**
      * Gets a sender for sending command responses to a business application.
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
index f86e31e16..73e11987c 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
@@ -13,13 +13,16 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
 
+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.eclipse.hono.auth.Device;
@@ -35,6 +38,7 @@ import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.ResourceConflictException;
 import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.Constants;
+import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.ResourceIdentifier;
 
 import io.opentracing.Span;
@@ -49,12 +53,12 @@ import io.vertx.proton.ProtonReceiver;
  * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to receive commands and send responses.
  * <p>
  * The <em>createCommandConsumer()</em> methods will create one tenant-scoped consumer (if not existing yet) and one
- * device-specific consumer by which the command will be eventually sent to the device.
+ * gateway or device specific consumer by which the command will be eventually sent to the device.
  * <p>
  * Command messages are first received on the tenant-scoped consumer address. If applicable, the device id of a received
  * command is mapped to the id of the gateway through which the device has last sent messages. Then the command message
- * is either handled by an already existing command handler for the (mapped) device id, or the message is sent back to
- * the downstream peer to be handled by a device-specific consumer.
+ * is either handled by an already existing command handler for the (mapped) gateway id, or the message is sent back to
+ * the downstream peer to be handled by a gateway specific consumer.
  */
 public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implements CommandConsumerFactory {
 
@@ -64,21 +68,43 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
      */
     public static final long MIN_LIVENESS_CHECK_INTERVAL_MILLIS = 2000;
 
-    private final CachingClientFactory<MessageConsumer> deviceSpecificCommandConsumerFactory;
+    /**
+     * Used for integration tests (with only a single instance of each protocol adapter):
+     * <p>
+     * System property value defining whether incoming command messages on the tenant
+     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific
+     * consumer even if there is a local handler for the command.<p>
+     * The second condition for the rerouting to take place is that the command message
+     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application
+     * property with a {@code true} value.
+     */
+    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean
+            .valueOf(System.getProperty("enableForcedCommandRerouting", "false"));
+    /**
+     * Name of the boolean command message application property with which commands are
+     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.
+     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property
+     * is set to {@code true}.
+     */
+    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = "force-command-rerouting";
 
-    private final CachingClientFactory<MessageConsumer> tenantScopedCommandConsumerFactory;
+    /**
+     * Cache key used here is the address returned by {@link #getGatewayOrDeviceKey(String, String, String)}.
+     */
+    private final CachingClientFactory<DestinationCommandConsumer> destinationCommandConsumerFactory;
 
-    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;
     /**
-     * The handlers for the received command messages.
-     * The device address is used as the key, e.g. <em>DEFAULT_TENANT/4711</em>.
+     * Cache key used here is the tenant id.
      */
-    private final Map<String, Handler<CommandContext>> deviceSpecificCommandHandlers = new HashMap<>();
+    private final CachingClientFactory<MessageConsumer> mappingAndDelegatingCommandConsumerFactory;
+
+    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;
     /**
-     * A mapping of command consumer addresses to vert.x timer IDs which represent the
-     * liveness checks for the consumers.
+     * A mapping of the address returned by {@link #getGatewayOrDeviceKey(String, String, String)}
+     * to the object representing the liveness check for a destination command consumer.
      */
-    private final Map<String, Long> livenessChecks = new HashMap<>();
+    private final Map<String, LivenessCheckData> destinationCommandConsumerLivenessChecks = new HashMap<>();
+
     private final GatewayMapper gatewayMapper;
 
     /**
@@ -95,19 +121,22 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
     public CommandConsumerFactoryImpl(final HonoConnection connection, final GatewayMapper gatewayMapper) {
         super(connection);
         this.gatewayMapper = Objects.requireNonNull(gatewayMapper);
-        deviceSpecificCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> true);
-        tenantScopedCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> true);
+        destinationCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isAlive());
+        mappingAndDelegatingCommandConsumerFactory = new CachingClientFactory<>(connection.getVertx(), c -> true);
         delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());
     }
 
     @Override
     protected void onDisconnect() {
-        deviceSpecificCommandConsumerFactory.clearState();
-        tenantScopedCommandConsumerFactory.clearState();
-        deviceSpecificCommandHandlers.clear();
+        destinationCommandConsumerFactory.clearState();
+        mappingAndDelegatingCommandConsumerFactory.clearState();
     }
 
-    private String getKey(final String tenantId, final String deviceId) {
+    private String getGatewayOrDeviceKey(final String tenantId, final String deviceId, final String gatewayId) {
+        return Device.asAddress(tenantId, gatewayId != null ? gatewayId : deviceId);
+    }
+
+    private String getDeviceKey(final String tenantId, final String deviceId) {
         return Device.asAddress(tenantId, deviceId);
     }
 
@@ -125,44 +154,182 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(commandHandler);
 
+        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, remoteCloseHandler, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<MessageConsumer> createCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final String gatewayId,
+            final Handler<CommandContext> commandHandler,
+            final Handler<Void> remoteCloseHandler) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(gatewayId);
+        Objects.requireNonNull(commandHandler);
+
+        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, remoteCloseHandler, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * The interval used for creating the periodic liveness check will be the maximum
+     * of the given interval length and {@link #MIN_LIVENESS_CHECK_INTERVAL_MILLIS}.
+     */
+    @Override
+    public final Future<MessageConsumer> createCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final Handler<CommandContext> commandHandler,
+            final Handler<Void> remoteCloseHandler,
+            final long checkInterval) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(commandHandler);
+        if (checkInterval < 0) {
+            throw new IllegalArgumentException("liveness check interval must be > 0");
+        }
+
+        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, remoteCloseHandler, checkInterval);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * The interval used for creating the periodic liveness check will be the maximum
+     * of the given interval length and {@link #MIN_LIVENESS_CHECK_INTERVAL_MILLIS}.
+     */
+    @Override
+    public final Future<MessageConsumer> createCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final String gatewayId,
+            final Handler<CommandContext> commandHandler,
+            final Handler<Void> remoteCloseHandler,
+            final long checkInterval) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(gatewayId);
+        Objects.requireNonNull(commandHandler);
+        if (checkInterval < 0) {
+            throw new IllegalArgumentException("liveness check interval must be > 0");
+        }
+
+        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, remoteCloseHandler, checkInterval);
+    }
+
+    private Future<MessageConsumer> doCreateCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final String gatewayId,
+            final Handler<CommandContext> commandHandler,
+            final Handler<Void> remoteCloseHandler,
+            final Long checkInterval) {
+        log.trace("create command consumer [tenant-id: {}, device-id: {}, gateway-id: {}]", tenantId, deviceId, gatewayId);
         return connection.executeOrRunOnContext(result -> {
-            final String key = getKey(tenantId, deviceId);
-            final MessageConsumer commandConsumer = deviceSpecificCommandConsumerFactory.getClient(key);
-            if (commandConsumer != null) {
-                log.debug("cannot create concurrent command consumer [tenant: {}, device-id: {}]", tenantId, deviceId);
-                result.fail(new ResourceConflictException("message consumer already in use"));
-            } else {
-                // create the device specific consumer
-                final Future<MessageConsumer> deviceSpecificConsumerFuture = Future.future();
-                deviceSpecificCommandConsumerFactory.getOrCreateClient(
-                        key,
-                        () -> newDeviceSpecificCommandConsumer(tenantId, deviceId, commandHandler, remoteCloseHandler),
-                        deviceSpecificConsumerFuture);
-                // create the tenant-scoped consumer that delegates/maps incoming commands to the right handler/consumer
-                final Future<MessageConsumer> tenantScopedCommandConsumerFuture = getOrCreateTenantScopedCommandConsumer(tenantId);
-                CompositeFuture.all(deviceSpecificConsumerFuture, tenantScopedCommandConsumerFuture).map(res -> {
-                    deviceSpecificCommandHandlers.put(key, commandHandler);
+            final String gatewayOrDeviceId = gatewayId != null ? gatewayId : deviceId;
+            final String gatewayOrDeviceKey = getGatewayOrDeviceKey(tenantId, deviceId, gatewayId);
+
+            ensureNoConflictingConsumerExists(tenantId, deviceId, gatewayId, gatewayOrDeviceKey, result);
+
+            if (!result.isComplete()) {
+                final Future<DestinationCommandConsumer> destinationCommandConsumerFuture = Future.future();
+                // create the gateway or device specific destination consumer
+                destinationCommandConsumerFactory.getOrCreateClient(
+                        gatewayOrDeviceKey,
+                        () -> newDestinationCommandConsumer(tenantId, gatewayOrDeviceId),
+                        destinationCommandConsumerFuture);
+
+                // create the device specific consumer to be returned by this method
+                final Future<MessageConsumer> deviceSpecificConsumerFuture = destinationCommandConsumerFuture
+                        .compose(c -> {
+                            return c.addDeviceSpecificCommandHandler(deviceId, gatewayId,
+                                    commandHandler, remoteCloseHandler);
+                        }).map(c -> {
+                            return new DeviceSpecificCommandConsumer(() -> {
+                                return destinationCommandConsumerFactory.getClient(gatewayOrDeviceKey);
+                            }, deviceId);
+                        });
+
+                // create the tenant-scoped consumer that maps/delegates incoming commands to the right device-scoped handler/consumer
+                final Future<MessageConsumer> mappingAndDelegatingCommandConsumer = getOrCreateMappingAndDelegatingCommandConsumer(tenantId);
+                CompositeFuture.all(deviceSpecificConsumerFuture, mappingAndDelegatingCommandConsumer).map(res -> {
+                    if (checkInterval != null) {
+                        final DestinationCommandConsumer destinationCommandConsumer = destinationCommandConsumerFuture
+                                .result();
+                        registerLivenessCheck(tenantId, gatewayOrDeviceId,
+                                () -> destinationCommandConsumer.getCommandHandlers(), checkInterval);
+                    }
                     return deviceSpecificConsumerFuture.result();
                 }).setHandler(result);
             }
         });
     }
 
-    private Future<MessageConsumer> getOrCreateTenantScopedCommandConsumer(final String tenantId) {
+    private void ensureNoConflictingConsumerExists(final String tenantId, final String deviceId, final String gatewayId,
+            final String gatewayOrDeviceKey, final Future<MessageConsumer> result) {
+        final DestinationCommandConsumer commandConsumer = destinationCommandConsumerFactory.getClient(gatewayOrDeviceKey);
+        if (commandConsumer != null) {
+            if (!commandConsumer.isAlive()) {
+                log.debug("cannot create command consumer, existing consumer not properly closed yet [tenant: {}, device-id: {}]",
+                        tenantId, deviceId);
+                result.fail(new ResourceConflictException("message consumer already in use"));
+            } else if (commandConsumer.containsCommandHandler(deviceId)) {
+                log.debug("cannot create concurrent command consumer [tenant: {}, device-id: {}]", tenantId, deviceId);
+                result.fail(new ResourceConflictException("message consumer already in use"));
+            } else if (gatewayId != null) {
+                log.trace("gateway command consumer already exists, will add device handler to that [tenant: {}, gateway-id: {}, device-id: {}]",
+                        tenantId, gatewayId, deviceId);
+            } else {
+                log.trace("gateway command consumer with a device specific handler already exists, will add handler for all gateway devices [tenant: {}, gateway-id: {}]",
+                        tenantId, deviceId);
+            }
+        }
+    }
+
+    private Future<DestinationCommandConsumer> newDestinationCommandConsumer(
+            final String tenantId,
+            final String gatewayOrDeviceId) {
+
+        final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
+        return DestinationCommandConsumer.create(
+                connection,
+                tenantId,
+                gatewayOrDeviceId,
+                sourceAddress -> { // local close hook
+                    // stop liveness check
+                    Optional.ofNullable(destinationCommandConsumerLivenessChecks.remove(gatewayOrDeviceKey))
+                            .ifPresent(livenessCheck -> connection.getVertx().cancelTimer(livenessCheck.getTimerId()));
+                    destinationCommandConsumerFactory.removeClient(gatewayOrDeviceKey);
+                },
+                sourceAddress -> { // remote close hook
+                    destinationCommandConsumerFactory.removeClient(gatewayOrDeviceKey);
+                });
+    }
+
+    private Future<MessageConsumer> getOrCreateMappingAndDelegatingCommandConsumer(final String tenantId) {
         Objects.requireNonNull(tenantId);
         return connection.executeOrRunOnContext(result -> {
-            final MessageConsumer messageConsumer = tenantScopedCommandConsumerFactory.getClient(tenantId);
+            final MessageConsumer messageConsumer = mappingAndDelegatingCommandConsumerFactory.getClient(tenantId);
             if (messageConsumer != null) {
                 result.complete(messageConsumer);
             } else {
-                tenantScopedCommandConsumerFactory.getOrCreateClient(tenantId,
-                        () -> newTenantScopedCommandConsumer(tenantId),
+                mappingAndDelegatingCommandConsumerFactory.getOrCreateClient(tenantId,
+                        () -> newMappingAndDelegatingCommandConsumer(tenantId),
                         result);
             }
         });
     }
 
-    private Future<MessageConsumer> newTenantScopedCommandConsumer(final String tenantId) {
+    private Future<MessageConsumer> newMappingAndDelegatingCommandConsumer(final String tenantId) {
 
         final AtomicReference<ProtonReceiver> receiverRefHolder = new AtomicReference<>();
 
@@ -170,20 +337,34 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
                 (tenantIdParam, deviceIdParam) -> createDelegatedCommandSender(tenantIdParam, deviceIdParam));
 
         final GatewayMappingCommandHandler gatewayMappingCommandHandler = new GatewayMappingCommandHandler(
-                gatewayMapper, commandContext -> {
-                    final String deviceId = commandContext.getCommand().getDeviceId();
-                    final Handler<CommandContext> commandHandler = deviceSpecificCommandHandlers
-                            .get(getKey(tenantId, deviceId));
+                gatewayMapper, commandContext -> { // handler following the gateway mapping
+                    final String gatewayOrDeviceId = commandContext.getCommand().getDeviceId();
+                    final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
+
+                    CommandHandlerWrapper commandHandler = null;
+                    final DestinationCommandConsumer consumer = destinationCommandConsumerFactory
+                            .getClient(gatewayOrDeviceKey);
+                    if (consumer != null) {
+                        commandHandler = consumer
+                                .getCommandHandlerOrDefault(commandContext.getCommand().getOriginalDeviceId());
+                    }
+
+                    if (commandHandler != null && isForcedCommandReroutingSet(commandContext)) { // used for integration tests
+                        log.debug("forced command rerouting is set, skip usage of local {} for {}",
+                                commandHandler, commandContext.getCommand());
+                        commandHandler = null;
+                    }
+
                     if (commandHandler != null) {
-                        log.trace("use local command handler for device {}", deviceId);
-                        commandHandler.handle(commandContext);
+                        log.trace("use local {} for {}", commandHandler, commandContext.getCommand());
+                        commandHandler.handleCommand(commandContext);
                     } else {
                         // delegate to matching consumer via downstream peer
                         delegatingCommandHandler.handle(commandContext);
                     }
                 });
 
-        return TenantScopedCommandConsumer.create(
+        return MappingAndDelegatingCommandConsumer.create(
                 connection,
                 tenantId,
                 (originalMessageDelivery, message) -> {
@@ -203,26 +384,48 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
                     if (command.isValid()) {
                         gatewayMappingCommandHandler.handle(commandContext);
                     } else {
-                        final Handler<CommandContext> commandHandler = deviceSpecificCommandHandlers.get(getKey(tenantId, deviceId));
-                        if (commandHandler != null) {
-                            // let the device specific handler reject the command
-                            commandHandler.handle(commandContext);
-                        } else {
-                            log.debug("command message is invalid: {}", command);
-                            commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, "malformed command message"));
-                        }
+                        // command is invalid, try to find local command handler to let it reject the command (and also report metrics for that), otherwise reject it directly
+                        gatewayMapper.getMappedGatewayDevice(tenantId, deviceId, spanContext)
+                                .setHandler(ar -> {
+                                    final String gatewayOrDeviceId = ar.succeeded() ? ar.result() : deviceId;
+                                    final DestinationCommandConsumer consumer = destinationCommandConsumerFactory
+                                            .getClient(getDeviceKey(tenantId, gatewayOrDeviceId));
+                                    CommandHandlerWrapper commandHandler = null;
+                                    if (consumer != null) {
+                                        commandHandler = consumer.getCommandHandlerOrDefault(deviceId);
+                                    }
+                                    if (commandHandler != null) {
+                                        // let the device specific handler reject the command
+                                        commandHandler.handleCommand(commandContext);
+                                    } else {
+                                        log.debug("command message is invalid: {}", command);
+                                        commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST,
+                                                "malformed command message"));
+                                    }
+                                });
+
                     }
                 },
                 sourceAddress -> { // local close hook
-                    tenantScopedCommandConsumerFactory.removeClient(tenantId);
+                    mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
                 },
                 sourceAddress -> { // remote close hook
-                    tenantScopedCommandConsumerFactory.removeClient(tenantId);
+                    mappingAndDelegatingCommandConsumerFactory.removeClient(tenantId);
                 },
                 receiverRefHolder)
                 .map(c -> (MessageConsumer) c);
     }
 
+    private boolean isForcedCommandReroutingSet(final CommandContext commandContext) {
+        if (!FORCED_COMMAND_REROUTING_ENABLED || !commandContext.getCommand().isValid()) {
+            return false;
+        }
+        final ApplicationProperties applicationProperties = commandContext.getCommand().getCommandMessage()
+                .getApplicationProperties();
+        return Boolean.TRUE.equals(MessageHelper.getApplicationProperty(applicationProperties,
+                FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY, Boolean.class));
+    }
+
     private Future<DelegatedCommandSender> createDelegatedCommandSender(final String tenantId, final String deviceId) {
         Objects.requireNonNull(tenantId);
         return connection.executeOrRunOnContext(result -> {
@@ -231,100 +434,85 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
         });
     }
 
-    /**
-     * {@inheritDoc}
-     * <p>
-     * The interval used for creating the periodic liveness check will be the maximum
-     * of the given interval length and {@link #MIN_LIVENESS_CHECK_INTERVAL_MILLIS}.
-     * 
-     */
-    @Override
-    public final Future<MessageConsumer> createCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler,
-            final long checkInterval) {
+    private void registerLivenessCheck(final String tenantId, final String gatewayOrDeviceId,
+            final Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier, final long checkInterval) {
+        final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
 
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(commandHandler);
-        if (checkInterval < 0) {
-            throw new IllegalArgumentException("liveness check interval must be > 0");
-        }
-
-        return createCommandConsumer(tenantId, deviceId, commandHandler, remoteCloseHandler)
-                .map(c -> {
-
-                    final String key = getKey(tenantId, deviceId);
-                    final long effectiveCheckInterval = Math.max(MIN_LIVENESS_CHECK_INTERVAL_MILLIS, checkInterval);
-                    final long livenessCheckId = connection.getVertx().setPeriodic(
-                            effectiveCheckInterval,
-                            newLivenessCheck(tenantId, deviceId, key, commandHandler, remoteCloseHandler));
-                    livenessChecks.put(key, livenessCheckId);
-                    return c;
-                });
+        destinationCommandConsumerLivenessChecks.compute(gatewayOrDeviceKey, (key, existingLivenessCheckData) -> {
+            if (existingLivenessCheckData != null) {
+                existingLivenessCheckData.setCommandHandlersSupplier(commandHandlersSupplier);
+                return existingLivenessCheckData;
+            }
+            final long effectiveCheckInterval = Math.max(MIN_LIVENESS_CHECK_INTERVAL_MILLIS, checkInterval);
+            final long timerId = connection.getVertx().setPeriodic(effectiveCheckInterval,
+                    newLivenessCheck(tenantId, gatewayOrDeviceId));
+            return new LivenessCheckData(timerId, commandHandlersSupplier);
+        });
     }
 
-    Handler<Long> newLivenessCheck(
-            final String tenantId,
-            final String deviceId,
-            final String key,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler) {
+    Handler<Long> newLivenessCheck(final String tenantId, final String gatewayOrDeviceId) {
 
-        final AtomicBoolean recreating = new AtomicBoolean(false);
-        final AtomicBoolean recreatingTenantScopedCommandConsumer = new AtomicBoolean(false);
+        final String gatewayOrDeviceKey = getDeviceKey(tenantId, gatewayOrDeviceId);
+        final AtomicBoolean recreatingDestinationConsumer = new AtomicBoolean(false);
+        final AtomicBoolean recreatingMappingAndDelegatingConsumer = new AtomicBoolean(false);
         return timerId -> {
-            if (connection.isShutdown()) {
+            final LivenessCheckData livenessCheck = destinationCommandConsumerLivenessChecks.get(gatewayOrDeviceKey);
+            if (connection.isShutdown() || livenessCheck == null) {
                 connection.getVertx().cancelTimer(timerId);
             } else {
                 connection.isConnected().map(ok -> {
-                    if (deviceSpecificCommandConsumerFactory.getClient(key) == null) {
+                    if (destinationCommandConsumerFactory.getClient(gatewayOrDeviceKey) == null) {
                         // when a connection is lost unexpectedly,
                         // all consumers will have been removed from the cache
                         // so we need to recreate the consumer
-                        if (recreating.compareAndSet(false, true)) {
+                        if (recreatingDestinationConsumer.compareAndSet(false, true)) {
                             // set a lock in order to prevent spawning multiple attempts
                             // to re-create the consumer
-                            log.debug("trying to re-create command consumer [tenant: {}, device-id: {}]",
-                                    tenantId, deviceId);
-                            // we try to re-create the link using the original parameters
-                            // which will put the consumer into the cache again, if successful
-                            createCommandConsumer(tenantId, deviceId, commandHandler, remoteCloseHandler)
-                            .map(consumer -> {
-                                log.debug("successfully re-created command consumer [tenant: {}, device-id: {}]",
-                                        tenantId, deviceId);
+                            log.debug("trying to re-create destination command consumer [tenant: {}, device-id: {}]",
+                                    tenantId, gatewayOrDeviceId);
+                            final Future<DestinationCommandConsumer> destinationCommandConsumerFuture = Future.future();
+                            destinationCommandConsumerFactory.getOrCreateClient(
+                                    gatewayOrDeviceKey,
+                                    () -> newDestinationCommandConsumer(tenantId, gatewayOrDeviceId),
+                                    destinationCommandConsumerFuture);
+                            destinationCommandConsumerFuture.map(consumer -> {
+                                livenessCheck.getCommandHandlers().forEach(handler -> {
+                                    log.debug("adding {} to created destination command consumer [tenant: {}, device-id: {}]",
+                                            handler, tenantId, gatewayOrDeviceId);
+                                    consumer.addDeviceSpecificCommandHandler(handler);
+                                });
+                                livenessCheck.setCommandHandlersSupplier(() -> consumer.getCommandHandlers());
+                                recreatingDestinationConsumer.compareAndSet(true, false);
                                 return consumer;
                             })
                             .otherwise(t -> {
-                                log.info("failed to re-create command consumer [tenant: {}, device-id: {}]: {}",
-                                        tenantId, deviceId, t.getMessage());
+                                log.info("failed to re-create destination command consumer [tenant: {}, device-id: {}]: {}",
+                                        tenantId, gatewayOrDeviceId, t.getMessage());
                                 return null;
                             })
-                            .setHandler(s -> recreating.compareAndSet(true, false));
+                            .setHandler(s -> recreatingDestinationConsumer.compareAndSet(true, false));
                         } else {
-                            log.debug("already trying to re-create command consumer [tenant: {}, device-id: {}], yielding ...",
-                                    tenantId, deviceId);
+                            log.debug("already trying to re-create destination command consumer [tenant: {}, device-id: {}], yielding ...",
+                                    tenantId, gatewayOrDeviceId);
                         }
                     }
 
-                    if (tenantScopedCommandConsumerFactory.getClient(tenantId) == null) {
-                        if (recreatingTenantScopedCommandConsumer.compareAndSet(false, true)) {
-                            log.debug("trying to re-create tenant scoped command consumer [tenant: {}]", tenantId);
-                            getOrCreateTenantScopedCommandConsumer(tenantId)
+                    if (mappingAndDelegatingCommandConsumerFactory.getClient(tenantId) == null) {
+                        if (recreatingMappingAndDelegatingConsumer.compareAndSet(false, true)) {
+                            log.debug("trying to re-create MappingAndDelegatingCommandConsumer [tenant: {}]", tenantId);
+                            getOrCreateMappingAndDelegatingCommandConsumer(tenantId)
                                     .map(consumer -> {
-                                        log.debug("successfully re-created tenant scoped command consumer [tenant: {}]", tenantId);
+                                        log.debug("successfully re-created MappingAndDelegatingCommandConsumer [tenant: {}]", tenantId);
                                         return consumer;
                                     })
                                     .otherwise(t -> {
-                                        log.info("failed to re-create tenant scoped command consumer [tenant: {}]: {}",
+                                        log.info("failed to re-create MappingAndDelegatingCommandConsumer [tenant: {}]: {}",
                                                 tenantId, t.getMessage());
                                         return null;
                                     })
-                                    .setHandler(s -> recreatingTenantScopedCommandConsumer.compareAndSet(true, false));
+                                    .setHandler(s -> recreatingMappingAndDelegatingConsumer.compareAndSet(true, false));
                         } else {
-                            log.debug("already trying to re-create tenant scoped command consumer [tenant: {}], yielding ...", tenantId);
+                            log.debug("already trying to re-create MappingAndDelegatingCommandConsumer [tenant: {}], yielding ...", tenantId);
                         }
                     }
                     return null;
@@ -333,31 +521,6 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
         };
     }
 
-    private Future<MessageConsumer> newDeviceSpecificCommandConsumer(
-            final String tenantId,
-            final String deviceId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<Void> remoteCloseHandler) {
-
-        final String key = getKey(tenantId, deviceId);
-        return DeviceSpecificCommandConsumer.create(
-                    connection,
-                    tenantId,
-                    deviceId,
-                    commandHandler,
-                    sourceAddress -> { // local close hook
-                        // stop liveness check
-                        Optional.ofNullable(livenessChecks.remove(key)).ifPresent(connection.getVertx()::cancelTimer);
-                        deviceSpecificCommandConsumerFactory.removeClient(key);
-                        deviceSpecificCommandHandlers.remove(key);
-                    },
-                    sourceAddress -> { // remote close hook
-                        deviceSpecificCommandConsumerFactory.removeClient(key);
-                        deviceSpecificCommandHandlers.remove(key);
-                        remoteCloseHandler.handle(null);
-                    }).map(c -> (MessageConsumer) c);
-    }
-
     /**
      * {@inheritDoc}
      * 
@@ -404,6 +567,13 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
         });
     }
 
+    /**
+     * Only used for testing.
+     */
+    Map<String, LivenessCheckData> getDestinationCommandConsumerLivenessChecks() {
+        return destinationCommandConsumerLivenessChecks;
+    }
+
     // ------------- Override AbstractHonoClientFactory methods to also connect/disconnect the gatewayMapper ------------
 
     @Override
@@ -428,4 +598,48 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
         CompositeFuture.all(amqpNetworkDisconnectFuture, gatewayMapperDisconnectFuture)
                 .map(obj -> amqpNetworkDisconnectFuture.result()).setHandler(completionHandler);
     }
+
+    /**
+     * Represents a liveness check corresponding to a destination command consumer.
+     * Contains the id of the Vert.x timer that invokes the liveness check.
+     */
+    static class LivenessCheckData {
+        private final long timerId;
+        private Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier;
+
+        LivenessCheckData(final long timerId, final Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier) {
+            this.timerId = Objects.requireNonNull(timerId);
+            this.commandHandlersSupplier = Objects.requireNonNull(commandHandlersSupplier);
+        }
+
+        /**
+         * Gets the id of the Vert.x timer that invokes the liveness check.
+         *
+         * @return The timer id.
+         */
+        public long getTimerId() {
+            return timerId;
+        }
+
+        /**
+         * Gets the command handlers to be re-registered once the liveness check has
+         * determined the command consumer has to be recreated.
+         *
+         * @return The command handlers.
+         */
+        public Collection<CommandHandlerWrapper> getCommandHandlers() {
+            return commandHandlersSupplier.get();
+        }
+
+        /**
+         * Sets the supplier that provides the command handlers to be re-registered
+         * once the liveness check has determined the command consumer has to be recreated.
+         *
+         * @param commandHandlersSupplier Provides the command handlers.
+         * @throws NullPointerException if commandHandlersSupplier is {@code null}.
+         */
+        public void setCommandHandlersSupplier(final Supplier<Collection<CommandHandlerWrapper>> commandHandlersSupplier) {
+            this.commandHandlersSupplier = Objects.requireNonNull(commandHandlersSupplier);
+        }
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
new file mode 100644
index 000000000..a6c019e21
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java
@@ -0,0 +1,94 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+
+import org.eclipse.hono.client.CommandContext;
+
+import io.vertx.core.Handler;
+
+/**
+ * Wraps a command handler to be used in a command consumer.
+ */
+public final class CommandHandlerWrapper {
+
+    private final String deviceId;
+    private final String gatewayId;
+    private final Handler<CommandContext> commandHandler;
+    private final Handler<Void> remoteCloseHandler;
+
+    /**
+     * Creates a new CommandHandlerWrapper.
+     * 
+     * @param deviceId The identifier of the device that is the target of the commands being handled.
+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is
+     *                  the target of the commands being handled, or {@code null} otherwise.
+     * @param commandHandler The command handler.
+     * @param remoteCloseHandler The handler to be invoked when the command consumer is closed remotely. May be
+     *            {@code null}.
+     * @throws NullPointerException If deviceId or commandHandler is {@code null}.
+     */
+    public CommandHandlerWrapper(final String deviceId, final String gatewayId,
+            final Handler<CommandContext> commandHandler, final Handler<Void> remoteCloseHandler) {
+        this.deviceId = Objects.requireNonNull(deviceId);
+        this.gatewayId = gatewayId;
+        this.commandHandler = Objects.requireNonNull(commandHandler);
+        this.remoteCloseHandler = remoteCloseHandler;
+    }
+
+    /**
+     * Gets the identifier of the device to handle commands for.
+     *
+     * @return The identifier.
+     */
+    public String getDeviceId() {
+        return deviceId;
+    }
+
+    /**
+     * Gets the identifier of the gateway that the command target device is connected to.
+     *
+     * @return The identifier or {@code null}.
+     */
+    public String getGatewayId() {
+        return gatewayId;
+    }
+
+    /**
+     * Invokes the command handler with the given command context.
+     *
+     * @param commandContext The command context to pass on to the command handler.
+     */
+    public void handleCommand(final CommandContext commandContext) {
+        commandHandler.handle(commandContext);
+    }
+
+    /**
+     * Invokes the handler for the case that the command consumer is closed remotely.
+     */
+    public void handleRemoteClose() {
+        if (remoteCloseHandler != null) {
+            remoteCloseHandler.handle(null);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "CommandHandlerWrapper{" +
+                "deviceId='" + deviceId + '\'' +
+                ", gatewayId='" + gatewayId + '\'' +
+                '}';
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
index db00fd69e..adf8efc97 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
@@ -30,7 +30,7 @@ import io.vertx.proton.ProtonDelivery;
  * Handler for command messages that delegates command handling by setting a device-specific message target address and
  * sending the message to the downstream peer.
  * <p>
- * That way, further command handling is delegated to the {@link DeviceSpecificCommandConsumer} eventually.
+ * That way, further command handling is delegated to the {@link DestinationCommandConsumer} eventually.
  */
 public class DelegateViaDownstreamPeerCommandHandler implements Handler<CommandContext> {
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DestinationCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/DestinationCommandConsumer.java
new file mode 100644
index 000000000..be9173f07
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DestinationCommandConsumer.java
@@ -0,0 +1,330 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.Command;
+import org.eclipse.hono.client.CommandContext;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.ResourceConflictException;
+import org.eclipse.hono.tracing.TracingHelper;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.ResourceIdentifier;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+
+/**
+ * A wrapper around an AMQP receiver link for consuming commands directed to a gateway or device.
+ * <p>
+ * Includes special support for gateways:
+ * If a gateway creates multiple command subscriptions for specific devices connected to it, the one
+ * <em>GatewayOrDeviceSpecificCommandConsumer</em> instance created for the gateway will contain
+ * multiple {@link CommandHandlerWrapper} instances containing the device-specific handlers for
+ * the commands.
+ * <p>
+ * In a non-gateway scenario, the <em>GatewayOrDeviceSpecificCommandConsumer</em> instance will
+ * just contain the one {@link CommandHandlerWrapper} instance for handling commands to the device.
+ */
+public final class DestinationCommandConsumer extends CommandConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DestinationCommandConsumer.class);
+
+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();
+    private final String tenantId;
+    private final String gatewayOrDeviceId;
+    private final AtomicBoolean closedCalled = new AtomicBoolean();
+
+    private DestinationCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver,
+            final String tenantId, final String gatewayOrDeviceId) {
+        super(connection, receiver);
+        this.tenantId = tenantId;
+        this.gatewayOrDeviceId = Objects.requireNonNull(gatewayOrDeviceId);
+    }
+
+    /**
+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
+     *
+     * @param deviceId The identifier of the device that is the target of the commands being handled.
+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is
+     *                  the target of the commands being handled, or {@code null} otherwise.
+     * @param commandHandler The command handler.
+     * @param remoteCloseHandler The handler to be invoked when the command consumer is closed remotely. May be
+     *            {@code null}.
+     * @return A future indicating whether adding the handler was successful.
+     *         <p>
+     *         The future will be failed with a {@link ResourceConflictException}
+     *         if the consumer already contains a handler with the same device id.
+     *         <p>
+     *         Otherwise, the future will be succeeded.
+     * @throws NullPointerException If deviceId or commandHandler is {@code null}.
+     * @throws IllegalArgumentException If the device or gateway id of the given handler does
+     *                                  not match this command consumer.
+     */
+    public Future<Void> addDeviceSpecificCommandHandler(final String deviceId, final String gatewayId,
+            final Handler<CommandContext> commandHandler, final Handler<Void> remoteCloseHandler) {
+        return addDeviceSpecificCommandHandler(new CommandHandlerWrapper(deviceId, gatewayId, commandHandler, remoteCloseHandler));
+    }
+
+    /**
+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.
+     * 
+     * @param handler The consumer to add.
+     * @return A future indicating whether adding the handler was successful.
+     *         <p>
+     *         The future will be failed with a {@link ResourceConflictException}
+     *         if the consumer already contains a handler with the same device id.
+     *         <p>
+     *         Otherwise, the future will be succeeded.
+     * @throws NullPointerException If the given handler is {@code null}.
+     * @throws IllegalArgumentException If the device or gateway id of the given handler does
+     *                                  not match this command consumer.
+     */
+    public Future<Void> addDeviceSpecificCommandHandler(final CommandHandlerWrapper handler) {
+        Objects.requireNonNull(handler);
+        if (!handlerIsForConsumerGatewayOrDevice(handler.getDeviceId(), handler.getGatewayId())) {
+            LOG.error("cannot add handler with non-matching device/gateway id [consumer device id: {}, handler: {}",
+                    gatewayOrDeviceId, handler);
+            throw new IllegalArgumentException("invalid handler given");
+        }
+        if (commandHandlers.containsKey(handler.getDeviceId())) {
+            LOG.debug("cannot create concurrent command consumer [device-id: {}]", handler.getDeviceId());
+            return Future.failedFuture(new ResourceConflictException("message consumer already in use"));
+        }
+        commandHandlers.put(handler.getDeviceId(), handler);
+        return Future.succeededFuture(null);
+    }
+
+    private boolean handlerIsForConsumerGatewayOrDevice(final String handlerDeviceId, final String handlerGatewayId) {
+        if (handlerGatewayId == null) {
+            // the given handler is for commands directed directly at a device (no gateway in between)
+            // => then the handler must be for the device for which this consumer receives command messages
+            return this.gatewayOrDeviceId.equals(handlerDeviceId);
+        } else {
+            // the given handler is for commands directed at a device behind a gateway
+            // => then the given gateway must be the same as the one for which this consumer receives command messages
+            return this.gatewayOrDeviceId.equals(handlerGatewayId);
+        }
+    }
+
+    /**
+     * Checks whether the Proton receiver behind this consumer is open.
+     *
+     * @return {@code true} if this consumer is alive.
+     */
+    public boolean isAlive() {
+        return receiver.isOpen() && !closedCalled.get();
+    }
+
+    private void handleCommandMessage(final Message msg,  final ProtonDelivery delivery) {
+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case
+        // (the case of the address being null means that the message was sent by an application to the legacy control endpoint)
+        final String originalDeviceId = msg.getAddress() != null
+                ? ResourceIdentifier.fromString(msg.getAddress()).getResourceId()
+                : null;
+        // look for a handler with the original device id first
+        final CommandHandlerWrapper commandHandler = getCommandHandlerOrDefault(originalDeviceId);
+        if (commandHandler != null) {
+            final Command command = Command.from(msg, tenantId, gatewayOrDeviceId);
+            final Tracer tracer = connection.getTracer();
+            // try to extract Span context from incoming message
+            final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);
+            final Span currentSpan = createSpan("send command", tenantId, gatewayOrDeviceId,
+                    tracer, spanContext);
+            logReceivedCommandToSpan(command, currentSpan);
+            commandHandler.handleCommand(CommandContext.from(command, delivery, this.receiver, currentSpan));
+        } else {
+            LOG.error("no command handler found for command with device id {}, message address device id {} [tenant-id: {}]",
+                    gatewayOrDeviceId, originalDeviceId, tenantId);
+            ProtonHelper.released(delivery, true);
+        }
+    }
+
+    /**
+     * Checks whether a handler exists for the given device id.
+     * 
+     * @param deviceId The device id.
+     * @return {@code true} if a handler exists.
+     */
+    public boolean containsCommandHandler(final String deviceId) {
+        return commandHandlers.containsKey(deviceId);
+    }
+
+    /**
+     * Gets a handler for either the given device id or for the device id of <em>this</em>
+     * command consumer.
+     * 
+     * @param gatewayManagedDeviceId The id of a device connected to a gateway. May be {@code null}.<p>
+     *                               In case the command, for which to return the appropriate handler, is
+     *                               directed at a gateway-managed device, the id of this device is to be
+     *                               given here. Otherwise {@code null} is to be used.<p>
+     *                               If a handler for the given device exists, it will be returned here.
+     *                               Otherwise the handler for the device id of <em>this</em> command consumer
+     *                               will be returned (if such a handler is set).
+     * @return The handler or {@code null}.
+     */
+    public CommandHandlerWrapper getCommandHandlerOrDefault(final String gatewayManagedDeviceId) {
+        if (gatewayManagedDeviceId != null && !gatewayManagedDeviceId.equals(gatewayOrDeviceId)) {
+            final CommandHandlerWrapper handler = commandHandlers.get(gatewayManagedDeviceId);
+            if (handler != null) {
+                LOG.trace("using device specific command handler for {} [consumer device-id: {}]",
+                        gatewayManagedDeviceId, gatewayOrDeviceId);
+                return handler;
+            }
+        }
+        return commandHandlers.get(gatewayOrDeviceId);
+    }
+
+    /**
+     * Gets the contained command handlers.
+     *
+     * @return The command handlers.
+     */
+    public Collection<CommandHandlerWrapper> getCommandHandlers() {
+        return commandHandlers.values();
+    }
+
+    private void onRemoteClose(final Handler<String> remoteCloseHandler, final String event) {
+        remoteCloseHandler.handle(event);
+        commandHandlers.values().forEach(handler -> {
+            handler.handleRemoteClose();
+        });
+    }
+
+    /**
+     * Removes the handler for the given device id and closes this consumer if there are
+     * no remaining handlers left.
+     *
+     * @param deviceId The device id of the handler to remove.
+     * @param resultHandler A handler that is called back with the result of the operation.
+     */
+    public void removeHandlerAndCloseConsumerIfEmpty(final String deviceId, final Handler<AsyncResult<Void>> resultHandler) {
+        final CommandHandlerWrapper removedHandler = commandHandlers.remove(deviceId);
+        LOG.trace("Removed handler for device {} on consumer {}: {}", deviceId, this.gatewayOrDeviceId, removedHandler != null);
+        if (removedHandler != null && commandHandlers.isEmpty()) {
+            LOG.trace("all command handlers removed for consumer, closing link [consumer device-id: {}, device-id of removed handler: {}]",
+                    this.gatewayOrDeviceId, deviceId);
+            closedCalled.set(true);
+            close(resultHandler);
+        } else if (resultHandler != null) {
+            resultHandler.handle(Future.succeededFuture());
+        }
+    }
+
+    /**
+     * Creates a new command consumer.
+     * <p>
+     * The handler to be invoked by the created consumer will have to be subsequently added
+     * via the {@link #addDeviceSpecificCommandHandler(String, String, Handler, Handler)} method.
+     * <p>
+     * The underlying receiver link will be created with the following properties:
+     * <ul>
+     * <li><em>auto accept</em> will be set to {@code true}</li>
+     * <li><em>pre-fetch size</em> will be set to {@code 0} to enforce manual flow control.
+     * However, the sender will be issued one credit on link establishment.</li>
+     * </ul>
+     *
+     * @param con The connection to the server.
+     * @param tenantId The tenant to consume commands from.
+     * @param gatewayOrDeviceId The device for which the commands should be consumed.
+     * @param localCloseHandler A handler to be invoked after the link has been closed
+     *                     at this peer's request using the {@link #close(Handler)} method.
+     *                     The handler will be invoked with the link's source address <em>after</em>
+     *                     the link has been closed but <em>before</em> the handler that has been
+     *                     passed into the <em>close</em> method is invoked.
+     * @param remoteCloseHandler A handler to be invoked after the link has been closed
+     *                     at the remote peer's request. The handler will be invoked with the
+     *                     link's source address.
+     * @return A future indicating the outcome of the creation attempt.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    public static Future<DestinationCommandConsumer> create(
+            final HonoConnection con,
+            final String tenantId,
+            final String gatewayOrDeviceId,
+            final Handler<String> localCloseHandler,
+            final Handler<String> remoteCloseHandler) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(gatewayOrDeviceId);
+        Objects.requireNonNull(localCloseHandler);
+        Objects.requireNonNull(remoteCloseHandler);
+
+        LOG.trace("creating new command consumer [tenant-id: {}, device-id: {}]", tenantId, gatewayOrDeviceId);
+
+        final String address = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_LEGACY_ENDPOINT, tenantId, gatewayOrDeviceId).toString();
+
+        final AtomicReference<DestinationCommandConsumer> consumerRef = new AtomicReference<>();
+
+        return con.createReceiver(
+                address,
+                ProtonQoS.AT_LEAST_ONCE,
+                (delivery, msg) -> {
+
+                    final DestinationCommandConsumer consumer = consumerRef.get();
+                    if (consumer == null) {
+                        // sender has sent message before we have sent credit
+                        LOG.error("rejecting received message received before having granted credits [tenant-id: {}, device-id: {}]",
+                                tenantId, gatewayOrDeviceId);
+                        ProtonHelper.released(delivery, true);
+                        return;
+                    }
+                    consumer.handleCommandMessage(msg, delivery);
+                },
+                0, // no pre-fetching
+                false, // no auto-accept
+                sourceAddress -> { // remote close hook
+                    LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed remotely",
+                            tenantId, gatewayOrDeviceId);
+                    final DestinationCommandConsumer consumer = consumerRef.get();
+                    if (consumer != null) {
+                        consumer.onRemoteClose(remoteCloseHandler, sourceAddress);
+                    }
+                }).map(receiver -> {
+                    LOG.debug("successfully created command consumer [{}]", address);
+                    final DestinationCommandConsumer consumer = new DestinationCommandConsumer(
+                            con, receiver, tenantId, gatewayOrDeviceId);
+                    consumerRef.set(consumer);
+                    receiver.flow(1); // allow sender to send one command
+                    consumer.setLocalCloseHandler(sourceAddress -> {
+                        LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed locally",
+                                tenantId, gatewayOrDeviceId);
+                        localCloseHandler.handle(sourceAddress);
+                    });
+                    return consumer;
+                }).recover(t -> {
+                    LOG.debug("failed to create command consumer [tenant-id: {}, device-id: {}]",
+                            tenantId, gatewayOrDeviceId, t);
+                    return Future.failedFuture(t);
+                });
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java
index 8449db04d..45f8ea9c9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceSpecificCommandConsumer.java
@@ -14,116 +14,104 @@
 package org.eclipse.hono.client.impl;
 
 import java.util.Objects;
-import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
 
-import org.eclipse.hono.client.Command;
-import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.tracing.TracingHelper;
-import org.eclipse.hono.util.CommandConstants;
-import org.eclipse.hono.util.ResourceIdentifier;
+import org.eclipse.hono.client.MessageConsumer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.opentracing.Span;
-import io.opentracing.SpanContext;
-import io.opentracing.Tracer;
+import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
-import io.vertx.proton.ProtonQoS;
-import io.vertx.proton.ProtonReceiver;
 
 /**
- * A wrapper around an AMQP receiver link for consuming commands.
+ * Represents the device specific command consumer used in protocol adapters.
+ * <p>
+ * Delegates method invocations to the supplied command consumer that wraps the actual Proton receiver.
  */
-public class DeviceSpecificCommandConsumer extends CommandConsumer {
+public final class DeviceSpecificCommandConsumer implements MessageConsumer {
 
     private static final Logger LOG = LoggerFactory.getLogger(DeviceSpecificCommandConsumer.class);
 
-    private DeviceSpecificCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {
-        super(connection, receiver);
+    private final Supplier<DestinationCommandConsumer> delegateSupplier;
+    private final String deviceId;
+
+    /**
+     * Creates a new DeviceSpecificCommandConsumer.
+     *
+     * @param delegateSupplier Supplies the command consumer that wraps the actual Proton receiver.
+     * @param deviceId The device identifier.
+     * @throws NullPointerException If delegateSupplier or deviceId is {@code null}.
+     */
+    public DeviceSpecificCommandConsumer(
+            final Supplier<DestinationCommandConsumer> delegateSupplier, final String deviceId) {
+        this.delegateSupplier = Objects.requireNonNull(delegateSupplier);
+        this.deviceId = Objects.requireNonNull(deviceId);
     }
 
     /**
-     * Creates a new command consumer.
+     * Gets the current consumer delegate.
      * <p>
-     * The underlying receiver link will be created with the following properties:
-     * <ul>
-     * <li><em>auto accept</em> will be set to {@code true}</li>
-     * <li><em>pre-fetch size</em> will be set to {@code 0} to enforce manual flow control.
-     * However, the sender will be issued one credit on link establishment.</li>
-     * </ul>
+     * {@code null} may be returned here if {@link #close(Handler)} has already been invoked on this
+     * consumer (and the delegate consumer got closed as a consequence) or if the delegate consumer
+     * was remotely closed and no re-creation of the consumer (e.g. as part of a liveness check) has
+     * happened (yet).
      *
-     * @param con The connection to the server.
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the commands should be consumed.
-     * @param commandHandler The handler to invoke for each command received.
-     * @param localCloseHandler A handler to be invoked after the link has been closed
-     *                     at this peer's request using the {@link #close(Handler)} method.
-     *                     The handler will be invoked with the link's source address <em>after</em>
-     *                     the link has been closed but <em>before</em> the handler that has been
-     *                     passed into the <em>close</em> method is invoked.
-     * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the remote peer's request. The handler will be invoked with the
-     *                     link's source address.
-     * @return A future indicating the outcome of the creation attempt.
-     * @throws NullPointerException if any of the parameters are {@code null}.
+     * @return The consumer instance or {@code null}.
      */
-    public static final Future<DeviceSpecificCommandConsumer> create(
-            final HonoConnection con,
-            final String tenantId,
-            final String deviceId,
-            final Handler<CommandContext> commandHandler,
-            final Handler<String> localCloseHandler,
-            final Handler<String> remoteCloseHandler) {
-
-        Objects.requireNonNull(con);
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(commandHandler);
-        Objects.requireNonNull(remoteCloseHandler);
-
-        LOG.trace("creating new command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
-
-        final String address = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_LEGACY_ENDPOINT, tenantId, deviceId).toString();
+    private DestinationCommandConsumer getDelegate() {
+        return delegateSupplier.get();
+    }
 
-        final AtomicReference<ProtonReceiver> receiverRef = new AtomicReference<>();
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Calls the appropriate close handler and closes the outer consumer instance if that contains
+     * no further handlers.
+     */
+    @Override
+    public void close(final Handler<AsyncResult<Void>> closeHandler) {
+        final DestinationCommandConsumer delegate = getDelegate();
+        if (delegate != null) {
+            delegate.removeHandlerAndCloseConsumerIfEmpty(deviceId, closeHandler);
+        } else {
+            LOG.debug("cannot delegate close() invocation; actual consumer not available [consumer device-id {}]",
+                    deviceId);
+            if (closeHandler != null) {
+                closeHandler.handle(Future.failedFuture("actual consumer not available"));
+            }
+        }
+    }
 
-        return con.createReceiver(
-                address,
-                ProtonQoS.AT_LEAST_ONCE,
-                (delivery, msg) -> {
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Calls the corresponding method on the outer consumer instance.
+     */
+    @Override
+    public void flow(final int credits) throws IllegalStateException {
+        final DestinationCommandConsumer delegate = getDelegate();
+        if (delegate != null) {
+            delegate.flow(credits);
+        } else {
+            LOG.debug("cannot delegate flow() invocation; actual consumer not available [consumer device-id {}]",
+                    deviceId);
+        }
+    }
 
-                    final Command command = Command.from(msg, tenantId, deviceId);
-                    final Tracer tracer = con.getTracer();
-                    // try to extract Span context from incoming message
-                    final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);
-                    final Span currentSpan = createSpan("send command", tenantId, deviceId,
-                            tracer, spanContext);
-                    logReceivedCommandToSpan(command, currentSpan);
-                    commandHandler.handle(CommandContext.from(command, delivery, receiverRef.get(), currentSpan));
-                },
-                0, // no pre-fetching
-                false, // no auto-accept
-                sourceAddress -> {
-                    LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed remotely",
-                            tenantId, deviceId);
-                    remoteCloseHandler.handle(sourceAddress);
-                }).map(receiver -> {
-                    LOG.debug("successfully created command consumer [{}]", address);
-                    receiverRef.set(receiver);
-                    receiver.flow(1); // allow sender to send one command
-                    final DeviceSpecificCommandConsumer consumer = new DeviceSpecificCommandConsumer(con, receiver);
-                    consumer.setLocalCloseHandler(sourceAddress -> {
-                        LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed locally",
-                                tenantId, deviceId);
-                        localCloseHandler.handle(sourceAddress);
-                    });
-                    return consumer;
-                }).recover(t -> {
-                    LOG.debug("failed to create command consumer [tenant-id: {}, device-id: {}]",
-                            tenantId, deviceId, t);
-                    return Future.failedFuture(t);
-                });
+    /**
+     * {@inheritDoc}
+     *
+     * @return The remaining credit of the outer consumer instance.
+     */
+    @Override
+    public int getRemainingCredit() {
+        final DestinationCommandConsumer delegate = getDelegate();
+        if (delegate == null) {
+            LOG.debug("cannot delegate getRemainingCredit() invocation; actual consumer not available [consumer device-id {}]",
+                    deviceId);
+            return 0;
+        }
+        return delegate.getRemainingCredit();
     }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantScopedCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandConsumer.java
similarity index 76%
rename from client/src/main/java/org/eclipse/hono/client/impl/TenantScopedCommandConsumer.java
rename to client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandConsumer.java
index 4af85ad1b..e1b1ec1de 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantScopedCommandConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandConsumer.java
@@ -33,13 +33,14 @@ import io.vertx.proton.ProtonReceiver;
  * A wrapper around an AMQP receiver link for consuming commands on a tenant-scoped address.
  * <p>
  * This class is used by the default {@link CommandConsumerFactory} implementation to receive commands from northbound
- * applications.
+ * applications. The received commands will be mapped to a matching gateway and delegated to the
+ * {@link DestinationCommandConsumer} if applicable.
  */
-public class TenantScopedCommandConsumer extends CommandConsumer {
+public class MappingAndDelegatingCommandConsumer extends CommandConsumer {
 
-    private static final Logger LOG = LoggerFactory.getLogger(TenantScopedCommandConsumer.class);
+    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandConsumer.class);
 
-    private TenantScopedCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {
+    private MappingAndDelegatingCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {
 
         super(connection, receiver);
     }
@@ -62,7 +63,7 @@ public class TenantScopedCommandConsumer extends CommandConsumer {
      * @return A future indicating the outcome of the creation attempt.
      * @throws NullPointerException if any of the parameters other than tracer are {@code null}.
      */
-    public static Future<TenantScopedCommandConsumer> create(
+    public static Future<MappingAndDelegatingCommandConsumer> create(
             final HonoConnection con,
             final String tenantId,
             final ProtonMessageHandler messageHandler,
@@ -76,7 +77,7 @@ public class TenantScopedCommandConsumer extends CommandConsumer {
         Objects.requireNonNull(remoteCloseHandler);
         Objects.requireNonNull(receiverRefHolder);
 
-        LOG.trace("creating new tenant scoped command consumer [tenant-id: {}]", tenantId);
+        LOG.trace("creating new MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId);
 
         final String address = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
 
@@ -87,19 +88,19 @@ public class TenantScopedCommandConsumer extends CommandConsumer {
                 con.getConfig().getInitialCredits(),
                 false, // no auto-accept
                 sourceAddress -> {
-                    LOG.debug("command receiver link [tenant-id: {}] closed remotely", tenantId);
+                    LOG.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed remotely", tenantId);
                     remoteCloseHandler.handle(sourceAddress);
                 }).map(receiver -> {
-                    LOG.debug("successfully created tenant scoped command consumer [{}]", address);
+                    LOG.debug("successfully created MappingAndDelegatingCommandConsumer [{}]", address);
                     receiverRefHolder.set(receiver);
-                    final TenantScopedCommandConsumer consumer = new TenantScopedCommandConsumer(con, receiver);
+                    final MappingAndDelegatingCommandConsumer consumer = new MappingAndDelegatingCommandConsumer(con, receiver);
                     consumer.setLocalCloseHandler(sourceAddress -> {
-                        LOG.debug("command receiver link [tenant-id: {}] closed locally", tenantId);
+                        LOG.debug("MappingAndDelegatingCommandConsumer receiver link [tenant-id: {}] closed locally", tenantId);
                         localCloseHandler.handle(sourceAddress);
                     });
                     return consumer;
                 }).recover(t -> {
-                    LOG.debug("failed to create tenant scoped command consumer [tenant-id: {}]", tenantId, t);
+                    LOG.debug("failed to create MappingAndDelegatingCommandConsumer [tenant-id: {}]", tenantId, t);
                     return Future.failedFuture(t);
                 });
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
index 074bbf56e..52a6e7e71 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
@@ -27,8 +27,10 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.net.HttpURLConnection;
+import java.util.Collections;
 
 import org.apache.qpid.proton.amqp.transport.Source;
+import org.eclipse.hono.auth.Device;
 import org.eclipse.hono.client.CommandContext;
 import org.eclipse.hono.client.DisconnectListener;
 import org.eclipse.hono.client.GatewayMapper;
@@ -77,11 +79,14 @@ public class CommandConsumerFactoryImplTest {
     private CommandConsumerFactoryImpl commandConsumerFactory;
     private GatewayMapper gatewayMapper;
     private ProtonReceiver deviceSpecificCommandReceiver;
+    private ProtonReceiver gatewaySpecificCommandReceiver;
     private ProtonReceiver tenantScopedCommandReceiver;
     private String deviceSpecificCommandAddress;
+    private String gatewaySpecificCommandAddress;
     private String tenantCommandAddress;
     private String tenantId;
     private String deviceId;
+    private String gatewayId;
 
     /**
      * Sets up fixture.
@@ -99,6 +104,7 @@ public class CommandConsumerFactoryImplTest {
         }).when(vertx).setTimer(anyLong(), VertxMockSupport.anyHandler());
 
         deviceId = "theDevice";
+        gatewayId = "theGateway";
         tenantId = "theTenant";
 
         props = new ClientConfigProperties();
@@ -113,6 +119,16 @@ public class CommandConsumerFactoryImplTest {
                 anyInt(),
                 anyBoolean(),
                 VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(deviceSpecificCommandReceiver));
+        gatewaySpecificCommandReceiver = mock(ProtonReceiver.class);
+        when(gatewaySpecificCommandReceiver.isOpen()).thenReturn(Boolean.TRUE);
+        gatewaySpecificCommandAddress = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_LEGACY_ENDPOINT, tenantId, gatewayId).toString();
+        when(connection.createReceiver(
+                eq(gatewaySpecificCommandAddress),
+                any(ProtonQoS.class),
+                any(ProtonMessageHandler.class),
+                anyInt(),
+                anyBoolean(),
+                VertxMockSupport.anyHandler())).thenReturn(Future.succeededFuture(gatewaySpecificCommandReceiver));
         tenantScopedCommandReceiver = mock(ProtonReceiver.class);
         tenantCommandAddress = ResourceIdentifier.from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, null).toString();
         when(connection.createReceiver(
@@ -182,18 +198,48 @@ public class CommandConsumerFactoryImplTest {
         final Handler<Void> closeHandler = VertxMockSupport.mockHandler();
 
         commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, closeHandler);
-        final ArgumentCaptor<Handler<String>> captor = VertxMockSupport.argumentCaptorHandler();
+        final ArgumentCaptor<Handler<String>> closeHookCaptor = VertxMockSupport.argumentCaptorHandler();
         verify(connection).createReceiver(
                 eq(deviceSpecificCommandAddress),
                 eq(ProtonQoS.AT_LEAST_ONCE),
                 any(ProtonMessageHandler.class),
                 eq(0),
                 eq(false),
-                captor.capture());
-        captor.getValue().handle(deviceSpecificCommandAddress);
+                closeHookCaptor.capture());
+        // invoke close hook
+        closeHookCaptor.getValue().handle(deviceSpecificCommandAddress);
         verify(closeHandler).handle(null);
     }
 
+    /**
+     * Verifies that the close handler passed as an argument when creating
+     * a command consumer with a gateway id is invoked when the peer closes the link.
+     *
+     * @param ctx The test context.
+     */
+    @Test
+    public void testCreateCommandConsumerWithGatewaySetsRemoteCloseHandler(final TestContext ctx) {
+
+        final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
+        final Handler<Void> closeHandlerDeviceA = VertxMockSupport.mockHandler();
+        final Handler<Void> closeHandlerDeviceB = VertxMockSupport.mockHandler();
+
+        commandConsumerFactory.createCommandConsumer(tenantId, "deviceA", gatewayId, commandHandler, closeHandlerDeviceA);
+        commandConsumerFactory.createCommandConsumer(tenantId, "deviceB", gatewayId, commandHandler, closeHandlerDeviceB);
+        final ArgumentCaptor<Handler<String>> closeHookCaptor = VertxMockSupport.argumentCaptorHandler();
+        verify(connection).createReceiver(
+                eq(gatewaySpecificCommandAddress),
+                eq(ProtonQoS.AT_LEAST_ONCE),
+                any(ProtonMessageHandler.class),
+                eq(0),
+                eq(false),
+                closeHookCaptor.capture());
+        // invoke close hook
+        closeHookCaptor.getValue().handle(gatewaySpecificCommandAddress);
+        verify(closeHandlerDeviceA).handle(null);
+        verify(closeHandlerDeviceB).handle(null);
+    }
+
     /**
      * Verifies that when a command consumer's <em>close</em> method is invoked,
      * then
@@ -316,7 +362,13 @@ public class CommandConsumerFactoryImplTest {
         // GIVEN a liveness check for a command consumer
         final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
         final Handler<Void> remoteCloseHandler = VertxMockSupport.mockHandler();
-        final Handler<Long> livenessCheck = commandConsumerFactory.newLivenessCheck(tenantId, deviceId, "key", commandHandler, remoteCloseHandler);
+        final CommandHandlerWrapper commandHandlerWrapper = new CommandHandlerWrapper(deviceId, null, commandHandler,
+                remoteCloseHandler);
+        final String gatewayOrDeviceKey = Device.asAddress(tenantId, deviceId);
+        commandConsumerFactory.getDestinationCommandConsumerLivenessChecks().put(gatewayOrDeviceKey,
+                new CommandConsumerFactoryImpl.LivenessCheckData(10L, () -> Collections.singletonList(commandHandlerWrapper)));
+
+        final Handler<Long> livenessCheck = commandConsumerFactory.newLivenessCheck(tenantId, deviceId);
         final Future<ProtonReceiver> createdReceiver = Future.future();
         when(connection.isConnected()).thenReturn(Future.succeededFuture());
         when(connection.createReceiver(
