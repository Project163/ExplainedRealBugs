diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java b/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java
index b4a5e77f4..0551683c9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java
@@ -162,9 +162,12 @@ class CachingClientFactory<T> extends ClientFactory<T> {
             // so that we can fail the result handler passed in
             final Handler<Void> connectionFailureHandler = connectionLost -> {
                 // remove lock so that next attempt to open a sender doesn't fail
-                creationLocks.remove(key);
-                result.handle(Future.failedFuture(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service")));
+                if (creationLocks.remove(key, Boolean.TRUE)) {
+                    result.handle(Future.failedFuture(
+                            new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service")));
+                } else {
+                    log.debug("creation attempt already finished for [{}]", key);
+                }
             };
             creationRequests.add(connectionFailureHandler);
             creationLocks.put(key, Boolean.TRUE);
@@ -172,17 +175,20 @@ class CachingClientFactory<T> extends ClientFactory<T> {
 
             try {
                 clientInstanceSupplier.get().setHandler(creationAttempt -> {
-                    creationLocks.remove(key);
                     creationRequests.remove(connectionFailureHandler);
-                    if (creationAttempt.succeeded()) {
-                        final T newClient = creationAttempt.result();
-                        log.debug("successfully created new client for [{}]", key);
-                        activeClients.put(key, newClient);
-                        result.handle(Future.succeededFuture(newClient));
+                    if (creationLocks.remove(key, Boolean.TRUE)) {
+                        if (creationAttempt.succeeded()) {
+                            final T newClient = creationAttempt.result();
+                            log.debug("successfully created new client for [{}]", key);
+                            activeClients.put(key, newClient);
+                            result.handle(Future.succeededFuture(newClient));
+                        } else {
+                            log.debug("failed to create new client for [{}]", key, creationAttempt.cause());
+                            activeClients.remove(key);
+                            result.handle(Future.failedFuture(creationAttempt.cause()));
+                        }
                     } else {
-                        log.debug("failed to create new client for [{}]", key, creationAttempt.cause());
-                        activeClients.remove(key);
-                        result.handle(Future.failedFuture(creationAttempt.cause()));
+                        log.debug("creation attempt already finished for [{}]", key);
                     }
                 });
             } catch (final Exception ex) {
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
index 99b0a75c1..01f6da988 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
@@ -191,4 +191,44 @@ public class CachingClientFactoryTest {
         }));
 
     }
+
+    /**
+     * Verifies that having the factory's clearState method invoked while
+     * a request to create a client is taking place, immediately causes
+     * the request to get failed. It is also verified that a subsequent
+     * completion of the clientInstanceSupplier method used for creating
+     * the client is getting ignored.
+     *
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testGetOrCreateClientWithClearStateCalledInBetween(final VertxTestContext ctx) {
+
+        // GIVEN a factory that tries to create a client for key "tenant"
+        final CachingClientFactory<Object> factory = new CachingClientFactory<>(vertx, o -> true);
+        final Promise<Object> creationFailure = Promise.promise();
+        final Promise<Object> creationAttempt = Promise.promise();
+        factory.getOrCreateClient(
+                "tenant",
+                () -> {
+                    // WHEN the factory's state is being cleared while the client
+                    // is being created
+                    factory.clearState();
+                    // AND the client creation fails afterwards
+                    creationFailure.fail("creation failure");
+                    return creationFailure.future();
+                }, creationAttempt);
+
+        // THEN the creation request is failed with the error produced when clearing the creation attempts
+        // and the client creation failure triggered above is ignored
+        creationAttempt.future().setHandler(ctx.failing(t -> {
+            ctx.verify(() -> {
+                // make sure the creationFailure was actually completed at this point
+                assertThat(creationFailure.future().isComplete()).isTrue();
+                assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
+            });
+            ctx.completeNow();
+        }));
+    }
+
 }
