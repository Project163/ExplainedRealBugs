diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 74d24f92f..809ebf02b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -25,6 +25,9 @@ import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonMessageHandler;
+import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
 
@@ -118,7 +121,7 @@ public abstract class AbstractHonoClient {
      * @throws NullPointerException if the message passed in is null.
      * @throws IllegalArgumentException if the properties contain any value that AMQP 1.0 disallows.
      */
-    protected final void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
+    protected static final void setApplicationProperties(final Message msg, final Map<String, ?> properties) {
         if (properties != null) {
 
             // check the three types not allowed by AMQP 1.0 spec for application properties (list, map and array)
@@ -136,4 +139,100 @@ public abstract class AbstractHonoClient {
             msg.setApplicationProperties(applicationProperties);
         }
     }
+
+    /**
+     * Creates a sender link.
+     * 
+     * @param ctx The vert.x context to use for establishing the link.
+     * @param con The connection to create the link for.
+     * @param targetAddress The target address of the link.
+     * @param qos The quality of service to use for the link.
+     * @param closeHook The handler to invoke when the link is closed by the peer.
+     * @return A future for the created link. The future will be completed once the link is open.
+     *         The future will fail if the link cannot be opened.
+     */
+    protected static final Future<ProtonSender> createSender(
+            final Context ctx,
+            final ProtonConnection con,
+            final String targetAddress,
+            final ProtonQoS qos,
+            final Handler<String> closeHook) {
+
+        final Future<ProtonSender> result = Future.future();
+
+        ctx.runOnContext(create -> {
+            final ProtonSender sender = con.createSender(targetAddress);
+            sender.setQoS(qos);
+            sender.openHandler(senderOpen -> {
+                if (senderOpen.succeeded()) {
+                    LOG.debug("sender open [{}]", sender.getRemoteTarget());
+                    result.complete(senderOpen.result());
+                } else {
+                    LOG.debug("opening sender [{}] failed: {}", targetAddress, senderOpen.cause().getMessage());
+                    result.fail(senderOpen.cause());
+                }
+            });
+            sender.closeHandler(senderClosed -> {
+                if (senderClosed.succeeded()) {
+                    LOG.debug("sender [{}] closed by peer", targetAddress);
+                } else {
+                    LOG.debug("sender [{}] closed by peer: {}", targetAddress, senderClosed.cause().getMessage());
+                }
+                sender.close();
+                if (closeHook != null) {
+                    closeHook.handle(targetAddress);
+                }
+            });
+            sender.open();
+        });
+
+        return result;
+    }
+
+    /**
+     * Creates a receiver link.
+     * <p>
+     * The receiver will be created with its <em>autoAccept</em> property set to {@code true}
+     * and with its <em>prefetch</em> property being set to {@link #DEFAULT_SENDER_CREDITS}.
+     * 
+     * @param ctx The vert.x context to use for establishing the link.
+     * @param con The connection to create the link for.
+     * @param sourceAddress The address to receive messages from.
+     * @param qos The quality of service to use for the link.
+     * @param messageHandler The handler to invoke with every message received.
+     * @param closeHook The handler to invoke when the link is closed by the peer.
+     * @return A future for the created link. The future will be completed once the link is open.
+     *         The future will fail if the link cannot be opened.
+     */
+    protected static final Future<ProtonReceiver> createReceiver(
+            final Context ctx,
+            final ProtonConnection con,
+            final String sourceAddress,
+            final ProtonQoS qos,
+            final ProtonMessageHandler messageHandler,
+            final Handler<String> closeHook) {
+
+        Future<ProtonReceiver> result = Future.future();
+        ctx.runOnContext(go -> {
+            final ProtonReceiver receiver = con.createReceiver(sourceAddress);
+            receiver.setAutoAccept(true);
+            receiver.setPrefetch(DEFAULT_SENDER_CREDITS);
+            receiver.handler(messageHandler);
+            receiver.openHandler(result.completer());
+            receiver.closeHandler(remoteClosed -> {
+                if (remoteClosed.succeeded()) {
+                    LOG.debug("receiver [{}] closed by peer [{}]", sourceAddress, con.getRemoteContainer());
+                } else {
+                    LOG.debug("receiver [{}] closed by peer [{}]: {}", sourceAddress, con.getRemoteContainer(), remoteClosed.cause().getMessage());
+                }
+                receiver.close();
+                if (closeHook != null) {
+                    closeHook.handle(sourceAddress);
+                }
+            });
+            receiver.open();
+        });
+        return result;
+
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 349e57267..66695fba5 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -21,6 +21,7 @@ import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RequestResponseApiConstants;
 import org.eclipse.hono.util.RequestResponseResult;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -33,26 +34,51 @@ import java.util.concurrent.ConcurrentHashMap;
 /**
  * A Vertx-Proton based parent class for the implementation of API clients that follow the request response pattern.
  * The class is a generic that expects two classes:
- *
- * @param <C> denotes the concrete interface for the API
- * @param <R> denotes the concrete result container class of the API
- *
  * <p>
- * Both type parameter classes have their own parent and need to be subclassed.
- *
- * A subclass of this class only needs to implement some abstract helper methods (see the method descriptions) and their own
+ * Subclasses only need to implement some abstract helper methods (see the method descriptions) and their own
  * API specific methods. This allows for implementation classes that focus on the API specific code.
+ * 
+ * @param <R> The type of result this client expects the peer to return.
+ *
  */
-public abstract class AbstractRequestResponseClient<C extends RequestResponseClient, R extends RequestResponseResult<?>>
+public abstract class AbstractRequestResponseClient<R extends RequestResponseResult<?>>
         extends AbstractHonoClient implements RequestResponseClient {
 
     private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestResponseClient.class);
 
-    protected final Map<String, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
-    protected final String                               replyToAddress;
+    private final Map<String, Handler<AsyncResult<R>>> replyMap = new ConcurrentHashMap<>();
+    private final String replyToAddress;
+    private final String targetAddress;
+
+    /**
+     * Creates a request-response client.
+     * <p>
+     * The client will be ready to use after invoking {@link #createLinks(ProtonConnection)} only.
+     * 
+     * @param context The vert.x context to run message exchanges with the peer on.
+     * @param tenantId The identifier of the tenant that the client is scoped to.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    AbstractRequestResponseClient(final Context context, final String tenantId) {
+        super(context);
+        Objects.requireNonNull(tenantId);
+        this.targetAddress = String.format("%s/%s", getName(), tenantId);
+        this.replyToAddress = String.format("%s/%s/%s", getName(), tenantId, UUID.randomUUID());
+    }
 
-    private final String requestResponseAddressTemplate;
-    private final String requestResponseReplyToAddressTemplate;
+    /**
+     * Creates a request-response client for a sender and receiver link.
+     * 
+     * @param context The vert.x context to run message exchanges with the peer on.
+     * @param tenantId The identifier of the tenant that the client is scoped to.
+     * @param sender The AMQP 1.0 link to use for sending requests to the peer.
+     * @param receiver The AMQP 1.0 link to use for receiving responses from the peer.
+     */
+    AbstractRequestResponseClient(final Context context, final String tenantId, final ProtonSender sender, final ProtonReceiver receiver) {
+        this(context, tenantId);
+        this.sender = Objects.requireNonNull(sender);
+        this.receiver = Objects.requireNonNull(receiver);
+    }
 
     /**
      * Get the name of the endpoint that this client targets at.
@@ -78,64 +104,89 @@ public abstract class AbstractRequestResponseClient<C extends RequestResponseCli
     protected abstract R getResult(final int status, final String payload);
 
     /**
-     * Creates a client for a vert.x context.
-     *
-     * @param context The context to run all interactions with the server on.
-     * @param con The connection to use for interacting with the service.
-     * @param tenantId The tenant that the client will be scoped to.
-     * @param creationHandler The handler to invoke with the created client.
+     * Creates the sender and receiver links to the peer for sending requests
+     * and receiving responses.
+     * 
+     * @param con The AMQP 1.0 connection to the peer.
+     * @return A future indicating the outcome. The future will succeed if the links
+     *         have been created.
      */
-    protected AbstractRequestResponseClient(final Context context, final ProtonConnection con, final String tenantId,
-                                            final Handler<AsyncResult<C>> creationHandler) {
+    protected final Future<Void> createLinks(final ProtonConnection con) {
+        return createLinks(con, null, null);
+    }
 
-        super(context);
-        requestResponseAddressTemplate        = String.format("%s/%%s",getName());
-        requestResponseReplyToAddressTemplate = String.format("%s/%%s/%%s",getName());
-        this.replyToAddress = String.format(
-                requestResponseReplyToAddressTemplate,
-                Objects.requireNonNull(tenantId),
-                UUID.randomUUID());
-
-        final Future<ProtonSender> senderTracker = Future.future();
-        senderTracker.setHandler(r -> {
-            if (r.succeeded()) {
-                LOG.debug("request response client created");
-                this.sender = r.result();
-                creationHandler.handle(Future.succeededFuture((C) this));
+    /**
+     * Creates the sender and receiver links to the peer for sending requests
+     * and receiving responses.
+     * 
+     * @param con The AMQP 1.0 connection to the peer.
+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
+     * @return A future indicating the outcome. The future will succeed if the links
+     *         have been created.
+     */
+    protected final Future<Void> createLinks(final ProtonConnection con, final Handler<String> senderCloseHook, final Handler<String> receiverCloseHook) {
+        Future<Void> result = Future.future();
+        createReceiver(con, replyToAddress, receiverCloseHook).compose(recv -> {
+            this.receiver = recv;
+            return createSender(con, targetAddress, senderCloseHook);
+        }).setHandler(s -> {
+            if (s.succeeded()) {
+                LOG.debug("request-response client for peer [{}] created", con.getRemoteContainer());
+                this.sender = s.result();
+                result.complete();
             } else {
-                creationHandler.handle(Future.failedFuture(r.cause()));
+                result.fail(s.cause());
             }
         });
+        return result;
+    }
 
-        final Future<ProtonReceiver> receiverTracker = Future.future();
-        context.runOnContext(create -> {
-            final ProtonReceiver receiver = con.createReceiver(replyToAddress);
-            receiver
-                    .setAutoAccept(true)
-                    .setPrefetch(DEFAULT_SENDER_CREDITS)
-                    .handler((delivery, message) -> {
-                        final Handler<AsyncResult<R>> handler = replyMap.remove(message.getCorrelationId());
-                        if (handler != null) {
-                            R result = getRequestResponseResult(message);
-                            LOG.debug("received response [correlation ID: {}, status: {}]",
-                                    message.getCorrelationId(), result.getStatus());
-                            handler.handle(Future.succeededFuture(result));
-                        } else {
-                            LOG.debug("discarding unexpected response [correlation ID: {}]",
-                                    message.getCorrelationId());
-                        }
-                    }).openHandler(receiverTracker.completer())
-                    .open();
-
-            receiverTracker.compose(openReceiver -> {
-                this.receiver = openReceiver;
-                ProtonSender sender = con.createSender(String.format(requestResponseAddressTemplate, tenantId));
-                sender
-                        .setQoS(ProtonQoS.AT_LEAST_ONCE)
-                        .openHandler(senderTracker.completer())
-                        .open();
-            }, senderTracker);
-        });
+    private Future<ProtonSender> createSender(final ProtonConnection con, final String targetAddress, final Handler<String> closeHook) {
+        return AbstractHonoClient.createSender(context, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook);
+    }
+
+    private Future<ProtonReceiver> createReceiver(final ProtonConnection con, final String sourceAddress, final Handler<String> closeHook) {
+
+        return AbstractHonoClient.createReceiver(context, con, sourceAddress, ProtonQoS.AT_LEAST_ONCE, this::handleResponse, closeHook);
+    }
+
+    /**
+     * Handles a response received from the peer.
+     * <p>
+     * In particular, this method tries to correlate the message with a previous request
+     * using the message's <em>correlation-id</em> and, if successful, the delivery is <em>accepted</em>
+     * and the message is passed to the handler registered with the original request.
+     * <p>
+     * If the response cannot be correlated to a request, e.g. because the request has timed
+     * out, then the delivery is <em>released</em> and the message is silently discarded.
+     * 
+     * @param delivery The handle for accessing the message's disposition.
+     * @param message The response message.
+     */
+    protected final void handleResponse(final ProtonDelivery delivery, final Message message) {
+
+        final Handler<AsyncResult<R>> handler = replyMap.remove(message.getCorrelationId());
+        if (handler != null) {
+            R response = getRequestResponseResult(message);
+            LOG.debug("received response [reply-to: {}, action: {}, correlation ID: {}, status: {}]",
+                    replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus());
+            handler.handle(Future.succeededFuture(response));
+            ProtonHelper.accepted(delivery, true);
+        } else {
+            LOG.debug("discarding unexpected response [reply-to: {}, correlation ID: {}]",
+                    replyToAddress, message.getCorrelationId());
+            ProtonHelper.released(delivery, true);
+        }
+    }
+
+    private R getRequestResponseResult(final Message message) {
+        final String status = MessageHelper.getApplicationProperty(
+                message.getApplicationProperties(),
+                MessageHelper.APP_PROPERTY_STATUS,
+                String.class);
+        final String payload = MessageHelper.getPayload(message);
+        return getResult(Integer.valueOf(status), payload);
     }
 
     /**
@@ -148,60 +199,90 @@ public abstract class AbstractRequestResponseClient<C extends RequestResponseCli
      * @param appProperties The map containing arbitrary application properties.
      *                      Maybe null if no application properties are needed.
      * @return The Proton message constructed from the provided parameters.
+     * @throws NullPointerException if the subject is {@code null}.
      * @throws IllegalArgumentException if the application properties contain not AMQP 1.0 compatible values
      *                  (see {@link AbstractHonoClient#setApplicationProperties(Message, Map)}
      */
-    protected Message createMessage(final String subject, final Map<String, Object> appProperties) {
+    private Message createMessage(final String subject, final Map<String, Object> appProperties) {
+
+        Objects.requireNonNull(subject);
         final Message msg = ProtonHelper.message();
         final String messageId = createMessageId();
-        setApplicationProperties(msg,appProperties);
+        AbstractHonoClient.setApplicationProperties(msg, appProperties);
         msg.setReplyTo(replyToAddress);
         msg.setMessageId(messageId);
         msg.setSubject(subject);
         return msg;
     }
 
-
-    private R getRequestResponseResult(final Message message) {
-        final String status = MessageHelper.getApplicationProperty(
-                message.getApplicationProperties(),
-                MessageHelper.APP_PROPERTY_STATUS,
-                String.class);
-        final String payload = MessageHelper.getPayload(message);
-        return getResult(Integer.valueOf(status), payload);
-    }
-
-    protected final void createAndSendRequest(final String action, final JsonObject payload,
-                                        final Handler<AsyncResult<R>> resultHandler) {
-        createAndSendRequest(action,null,payload,resultHandler);
+    /**
+     * Creates a request message for a payload and sends it to the peer.
+     * <p>
+     * This method simply invokes {@link #createAndSendRequest(String, Map, JsonObject, Handler)}
+     * with {@code null} for the properties parameter.
+     * 
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param resultHandler The handler to notify about the outcome of the request.
+     * @throws NullPointerException if any of action or result handler is {@code null}.
+     */
+    protected final void createAndSendRequest(final String action, final JsonObject payload, final Handler<AsyncResult<R>> resultHandler) {
+        createAndSendRequest(action, null, payload, resultHandler);
     }
 
+    /**
+     * Creates a request message for a payload and headers and sends it to the peer.
+     * 
+     * @param action The operation that the request is supposed to trigger/invoke.
+     * @param properties The headers to include in the request message as AMQP application properties.
+     * @param payload The payload to include in the request message as a an AMQP Value section.
+     * @param resultHandler The handler to notify about the outcome of the request.
+     * @throws NullPointerException if any of action or result handler is {@code null}.
+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.
+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)
+     */
     protected final void createAndSendRequest(final String action, final Map<String, Object> properties, final JsonObject payload,
                                       final Handler<AsyncResult<R>> resultHandler) {
 
+        Objects.requireNonNull(action);
+        Objects.requireNonNull(resultHandler);
+
         final Message request = createMessage(action, properties);
         if (payload != null) {
-            request.setContentType("application/json; charset=utf-8");
+            request.setContentType(RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON);
             request.setBody(new AmqpValue(payload.encode()));
         }
-        sendMessage(request, resultHandler);
+        sendRequest(request, resultHandler);
     }
 
     /**
-     * Send the Proton message to the endpoint link and call the resultHandler later with the result object.
-     *
-     * @param request The Proton message that was fully prepared for sending.
-     * @param resultHandler The result handler to be called with the response and the status of the request.
+     * Sends a request message via this client's sender link to the peer.
+     * <p>
+     * This method first checks if the sender has credits left and if not, immediately
+     * fails the result handler.
+     * 
+     * @param request The message to send.
+     * @param resultHandler The handler to notify about the outcome of the request.
      */
-    // TODO: improve so that the available credits are checked. Wait for enough credits before sending first.
-    protected final void sendMessage(final Message request, final Handler<AsyncResult<R>> resultHandler) {
+    private final void sendRequest(final Message request, final Handler<AsyncResult<R>> resultHandler) {
 
         context.runOnContext(req -> {
-            replyMap.put((String) request.getMessageId(), resultHandler);
-            sender.send(request);
+            if (sender.getCredit() > 0) {
+                replyMap.put((String) request.getMessageId(), resultHandler);
+                sender.send(request);
+            } else {
+                LOG.debug("cannot send request to peer, no credit left for link [target: {}]", sender.getRemoteTarget().getAddress());
+                resultHandler.handle(Future.failedFuture("no credit to send request to peer"));
+            }
         });
     }
 
+    /**
+     * Checks if this client's sender and receiver links are open.
+     * 
+     * @return {@code true} if a request can be sent to and a response can be received
+     * from the peer.
+     */
     @Override
     public final boolean isOpen() {
         return sender != null && sender.isOpen() && receiver != null && receiver.isOpen();
@@ -211,7 +292,8 @@ public abstract class AbstractRequestResponseClient<C extends RequestResponseCli
     public final void close(final Handler<AsyncResult<Void>> closeHandler) {
 
         Objects.requireNonNull(closeHandler);
-        LOG.info("closing request response client ...");
+        LOG.info("closing request-response client ...");
         closeLinks(closeHandler);
     }
+
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index adcf900b8..3c8ca5bb8 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -34,10 +34,8 @@ import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
-import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonHelper;
-import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonSender;
 
 /**
@@ -163,6 +161,7 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     public final boolean send(final Message rawMessage, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
         Objects.requireNonNull(rawMessage);
         Objects.requireNonNull(dispositionHandler);
+
         if (sender.sendQueueFull()) {
             return false;
         } else {
@@ -338,51 +337,4 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
         }
     }
 
-    /**
-     * Creates a sender link.
-     * 
-     * @param ctx The vertx context to use for establishing the link.
-     * @param con The connection to create the link for.
-     * @param targetAddress The target address of the link.
-     * @param qos The quality of service to use for the link.
-     * @param closeHook The handler to invoke when the link is closed by the peer.
-     * @return A future for the created link.
-     */
-    protected static final Future<ProtonSender> createSender(
-            final Context ctx,
-            final ProtonConnection con,
-            final String targetAddress,
-            final ProtonQoS qos,
-            final Handler<String> closeHook) {
-
-        final Future<ProtonSender> result = Future.future();
-
-        ctx.runOnContext(create -> {
-            final ProtonSender sender = con.createSender(targetAddress);
-            sender.setQoS(qos);
-            sender.openHandler(senderOpen -> {
-                if (senderOpen.succeeded()) {
-                    LOG.debug("sender open [{}]", sender.getRemoteTarget());
-                    result.complete(senderOpen.result());
-                } else {
-                    LOG.debug("opening sender [{}] failed: {}", targetAddress, senderOpen.cause().getMessage());
-                    result.fail(senderOpen.cause());
-                }
-            });
-            sender.closeHandler(senderClosed -> {
-                if (senderClosed.succeeded()) {
-                    LOG.debug("sender [{}] closed", targetAddress);
-                } else {
-                    LOG.debug("sender [{}] closed: {}", targetAddress, senderClosed.cause().getMessage());
-                }
-                sender.close();
-                if (closeHook != null) {
-                    closeHook.handle(targetAddress);
-                }
-            });
-            sender.open();
-        });
-
-        return result;
-    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
index b7f6d4f79..cf14d2e4f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
@@ -17,7 +17,6 @@ import static java.net.HttpURLConnection.HTTP_OK;
 import static org.eclipse.hono.util.CredentialsConstants.OPERATION_GET;
 
 import java.io.IOException;
-import java.util.Objects;
 import java.util.UUID;
 
 import org.eclipse.hono.client.CredentialsClient;
@@ -29,6 +28,7 @@ import com.fasterxml.jackson.databind.ObjectMapper;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
+import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonConnection;
@@ -37,20 +37,18 @@ import io.vertx.proton.ProtonConnection;
  * A Vertx-Proton based client for Hono's Credentials API.
  *
  */
-public final class CredentialsClientImpl extends AbstractRequestResponseClient<CredentialsClient, CredentialsResult<CredentialsObject>> implements CredentialsClient {
+public final class CredentialsClientImpl extends AbstractRequestResponseClient<CredentialsResult<CredentialsObject>> implements CredentialsClient {
 
-    private static final String                  CREDENTIALS_NAME = "credentials";
-    private static final ObjectMapper            objectMapper = new ObjectMapper();
+    private static final ObjectMapper objectMapper = new ObjectMapper();
 
-    private CredentialsClientImpl(final Context context, final ProtonConnection con, final String tenantId,
-                                  final Handler<AsyncResult<CredentialsClient>> creationHandler) {
-        super(context, con, tenantId, creationHandler);
+    private CredentialsClientImpl(final Context context, final String tenantId) {
+        super(context, tenantId);
     }
 
     @Override
     protected String getName() {
 
-        return CREDENTIALS_NAME;
+        return CredentialsConstants.CREDENTIALS_ENDPOINT;
     }
 
     @Override
@@ -65,10 +63,10 @@ public final class CredentialsClientImpl extends AbstractRequestResponseClient<C
             if (status == HTTP_OK) {
                 return CredentialsResult.from(status, objectMapper.readValue(payload, CredentialsObject.class));
             } else {
-                return CredentialsResult.from(status, (CredentialsObject) null);
+                return CredentialsResult.from(status);
             }
         } catch (IOException e) {
-            return CredentialsResult.from(HTTP_INTERNAL_ERROR, (CredentialsObject) null);
+            return CredentialsResult.from(HTTP_INTERNAL_ERROR);
         }
     }
 
@@ -78,16 +76,27 @@ public final class CredentialsClientImpl extends AbstractRequestResponseClient<C
      * @param context The vert.x context to run all interactions with the server on.
      * @param con The AMQP connection to the server.
      * @param tenantId The tenant for which credentials are handled.
+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    public static void create(final Context context, final ProtonConnection con, final String tenantId,
-                              final Handler<AsyncResult<CredentialsClient>> creationHandler) {
-        new CredentialsClientImpl(
-                Objects.requireNonNull(context),
-                Objects.requireNonNull(con),
-                Objects.requireNonNull(tenantId),
-                Objects.requireNonNull(creationHandler));
+    public static void create(
+            final Context context,
+            final ProtonConnection con,
+            final String tenantId,
+            final Handler<String> senderCloseHook,
+            final Handler<String> receiverCloseHook,
+            final Handler<AsyncResult<CredentialsClient>> creationHandler) {
+
+        final CredentialsClientImpl client = new CredentialsClientImpl(context, tenantId);
+        client.createLinks(con, senderCloseHook, receiverCloseHook).setHandler(s -> {
+            if (s.succeeded()) {
+                creationHandler.handle(Future.succeededFuture(client));
+            } else {
+                creationHandler.handle(Future.failedFuture(s.cause()));
+            }
+        });
     }
 
     @Override
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index b3c1f8261..e4c219afb 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -90,17 +90,11 @@ public final class HonoClientImpl implements HonoClient {
         this.context = context;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#isConnected()
-     */
     @Override
     public boolean isConnected() {
         return connection != null && !connection.isDisconnected();
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getConnectionStatus()
-     */
     @Override
     public Map<String, Object> getConnectionStatus() {
 
@@ -113,9 +107,6 @@ public final class HonoClientImpl implements HonoClient {
         return result;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getSenderStatus()
-     */
     @Override
     public JsonArray getSenderStatus() {
 
@@ -234,17 +225,11 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getOrCreateTelemetrySender(java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient getOrCreateTelemetrySender(final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
         return getOrCreateTelemetrySender(tenantId, null, resultHandler);
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getOrCreateTelemetrySender(java.lang.String, java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient getOrCreateTelemetrySender(final String tenantId, final String deviceId, final Handler<AsyncResult<MessageSender>> resultHandler) {
         Objects.requireNonNull(tenantId);
@@ -255,17 +240,11 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getOrCreateEventSender(java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient getOrCreateEventSender(final String tenantId, final Handler<AsyncResult<MessageSender>> resultHandler) {
         return getOrCreateEventSender(tenantId, null, resultHandler);
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getOrCreateEventSender(java.lang.String, java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient getOrCreateEventSender(
             final String tenantId,
@@ -338,10 +317,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createTelemetryConsumer(java.lang.String, java.util.function.Consumer, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createTelemetryConsumer(
             final String tenantId,
@@ -351,9 +326,6 @@ public final class HonoClientImpl implements HonoClient {
                 creationHandler);
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createTelemetryConsumer(java.lang.String, int, java.util.function.Consumer, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createTelemetryConsumer(
             final String tenantId,
@@ -380,9 +352,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createEventConsumer(java.lang.String, int, java.util.function.Consumer, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createEventConsumer(
             final String tenantId,
@@ -393,9 +362,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createEventConsumer(java.lang.String, int, java.util.function.Consumer, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createEventConsumer(
             final String tenantId,
@@ -407,9 +373,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createEventConsumer(java.lang.String, java.util.function.BiConsumer, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createEventConsumer(
             final String tenantId,
@@ -420,9 +383,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createEventConsumer(java.lang.String, java.util.function.BiConsumer, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createEventConsumer(
             final String tenantId,
@@ -474,9 +434,6 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getOrCreateRegistrationClient(java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient getOrCreateRegistrationClient(
             final String tenantId,
@@ -492,9 +449,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createRegistrationClient(java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createRegistrationClient(
             final String tenantId,
@@ -512,23 +466,26 @@ public final class HonoClientImpl implements HonoClient {
             creationRequests.add(connectionFailureHandler);
 
             LOG.debug("creating new registration client for [{}]", tenantId);
-            RegistrationClientImpl.create(context, connection, tenantId, creationAttempt -> {
-                if (creationAttempt.succeeded()) {
-                    activeRegClients.put(tenantId, creationAttempt.result());
-                    LOG.debug("successfully created registration client for [{}]", tenantId);
-                } else {
-                    LOG.debug("failed to create registration client for [{}]", tenantId, creationAttempt.cause());
-                }
-                creationRequests.remove(connectionFailureHandler);
-                creationHandler.handle(creationAttempt);
-            });
+            RegistrationClientImpl.create(
+                    context,
+                    connection,
+                    tenantId,
+                    this::removeRegistrationClient,
+                    this::removeRegistrationClient,
+                    creationAttempt -> {
+                        if (creationAttempt.succeeded()) {
+                            activeRegClients.put(tenantId, creationAttempt.result());
+                            LOG.debug("successfully created registration client for [{}]", tenantId);
+                        } else {
+                            LOG.debug("failed to create registration client for [{}]", tenantId, creationAttempt.cause());
+                        }
+                        creationRequests.remove(connectionFailureHandler);
+                        creationHandler.handle(creationAttempt);
+                    });
         }
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#getOrCreateCredentialsClient(java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient getOrCreateCredentialsClient(final String tenantId, final Handler<AsyncResult<CredentialsClient>> resultHandler) {
         final CredentialsClient credClient = activeCredClients.get(tenantId);
@@ -541,9 +498,6 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#createCredentialsClient(java.lang.String, io.vertx.core.Handler)
-     */
     @Override
     public HonoClient createCredentialsClient(final String tenantId, final Handler<AsyncResult<CredentialsClient>> creationHandler) {
         Objects.requireNonNull(tenantId);
@@ -559,23 +513,42 @@ public final class HonoClientImpl implements HonoClient {
             creationRequests.add(connectionFailureHandler);
 
             LOG.debug("creating new credentials client for [{}]", tenantId);
-            CredentialsClientImpl.create(context, connection, tenantId, creationAttempt -> {
-                if (creationAttempt.succeeded()) {
-                    activeCredClients.put(tenantId, creationAttempt.result());
-                    LOG.debug("successfully created credentials client for [{}]", tenantId);
-                } else {
-                    LOG.debug("failed to create credentials client for [{}]", tenantId, creationAttempt.cause());
-                }
-                creationRequests.remove(connectionFailureHandler);
-                creationHandler.handle(creationAttempt);
-            });
+            CredentialsClientImpl.create(
+                    context,
+                    connection,
+                    tenantId,
+                    this::removeCredentialsClient,
+                    this::removeCredentialsClient,
+                    creationAttempt -> {
+                        if (creationAttempt.succeeded()) {
+                            activeCredClients.put(tenantId, creationAttempt.result());
+                            LOG.debug("successfully created credentials client for [{}]", tenantId);
+                        } else {
+                            LOG.debug("failed to create credentials client for [{}]", tenantId, creationAttempt.cause());
+                        }
+                        creationRequests.remove(connectionFailureHandler);
+                        creationHandler.handle(creationAttempt);
+                    });
         }
         return this;
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#shutdown()
-     */
+    private void removeCredentialsClient(final String tenantId) {
+        CredentialsClient client = activeCredClients.remove(tenantId);
+        if (client != null) {
+            client.close(s -> {});
+            LOG.debug("closed and removed credentials client for [{}]", tenantId);
+        }
+    }
+
+    private void removeRegistrationClient(final String tenantId) {
+        RegistrationClient client = activeRegClients.remove(tenantId);
+        if (client != null) {
+            client.close(s -> {});
+            LOG.debug("closed and removed registration client for [{}]", tenantId);
+        }
+    }
+
     @Override
     public void shutdown() {
         final CountDownLatch latch = new CountDownLatch(1);
@@ -595,9 +568,6 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
-    /* (non-Javadoc)
-     * @see org.eclipse.hono.client.HonoClient#shutdown(io.vertx.core.Handler)
-     */
     @Override
     public void shutdown(final Handler<AsyncResult<Void>> completionHandler) {
         shutdown = true;
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
index f34fa1a34..b0098ee5f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
@@ -16,17 +16,16 @@ import static org.eclipse.hono.util.RegistrationConstants.*;
 
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Objects;
 import java.util.UUID;
 
 import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RegistrationConstants;
 import org.eclipse.hono.util.RegistrationResult;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
+import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonConnection;
@@ -35,22 +34,17 @@ import io.vertx.proton.ProtonConnection;
  * A Vertx-Proton based client for Hono's Registration API.
  *
  */
-public final class RegistrationClientImpl extends AbstractRequestResponseClient<RegistrationClient, RegistrationResult> implements RegistrationClient {
+public final class RegistrationClientImpl extends AbstractRequestResponseClient<RegistrationResult> implements RegistrationClient {
 
-    private static final String REGISTRATION_NAME = "registration";
-    private static final Logger LOG = LoggerFactory.getLogger(RegistrationClientImpl.class);
+    private RegistrationClientImpl(final Context context, final String tenantId) {
 
-    private RegistrationClientImpl(final Context context, final ProtonConnection con, final String tenantId,
-                                   final Handler<AsyncResult<RegistrationClient>> creationHandler) {
-
-        super(context,con,tenantId,creationHandler);
+        super(context, tenantId);
     }
 
-
     @Override
     protected String getName() {
 
-        return REGISTRATION_NAME;
+        return RegistrationConstants.REGISTRATION_ENDPOINT;
     }
 
     @Override
@@ -71,17 +65,27 @@ public final class RegistrationClientImpl extends AbstractRequestResponseClient<
      * @param context The vert.x context to run all interactions with the server on.
      * @param con The AMQP connection to the server.
      * @param tenantId The tenant to consumer events for.
+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    public static void create(final Context context, final ProtonConnection con, final String tenantId,
+    public static void create(
+            final Context context,
+            final ProtonConnection con,
+            final String tenantId,
+            final Handler<String> senderCloseHook,
+            final Handler<String> receiverCloseHook,
             final Handler<AsyncResult<RegistrationClient>> creationHandler) {
 
-        new RegistrationClientImpl(
-                Objects.requireNonNull(context),
-                Objects.requireNonNull(con),
-                Objects.requireNonNull(tenantId),
-                Objects.requireNonNull(creationHandler));
+        final RegistrationClientImpl client = new RegistrationClientImpl(context, tenantId);
+        client.createLinks(con, senderCloseHook, receiverCloseHook).setHandler(s -> {
+            if (s.succeeded()) {
+                creationHandler.handle(Future.succeededFuture(client));
+            } else {
+                creationHandler.handle(Future.failedFuture(s.cause()));
+            }
+        });
     }
 
     private Map<String, Object> createDeviceIdProperties(final String deviceId) {
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
new file mode 100644
index 000000000..ed62739ba
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractRequestResponseClientTest.java
@@ -0,0 +1,186 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+
+package org.eclipse.hono.client.impl;
+
+import static org.junit.Assert.*;
+import static org.hamcrest.CoreMatchers.*;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
+
+import java.util.Collections;
+import java.util.Map;
+
+import org.apache.qpid.proton.amqp.messaging.AmqpValue;
+import org.apache.qpid.proton.amqp.transport.Target;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.util.MessageHelper;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+
+import io.vertx.core.Context;
+import io.vertx.core.Handler;
+import io.vertx.core.json.JsonObject;
+import io.vertx.ext.unit.Async;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
+
+
+/**
+ * Tests verifying behavior of {@link AbstractRequestResponseClient}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class AbstractRequestResponseClientTest {
+
+    private static final String MESSAGE_ID = "messageid";
+    private ProtonReceiver recv;
+    private ProtonSender sender;
+    private Context context;
+
+    /**
+     * Sets up the fixture.
+     */
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+        context = mock(Context.class);
+        doAnswer(invocation -> {
+            Handler<Void> handler = invocation.getArgumentAt(0, Handler.class);
+            handler.handle(null);
+            return null;
+        }).when(context).runOnContext(any(Handler.class));
+        recv = mock(ProtonReceiver.class);
+        sender = mock(ProtonSender.class);
+    }
+
+    /**
+     * Verifies that the client fails the handler for sending a request message if the link to the
+     * peer has no credit left.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testCreateAndSendRequestFailsIfNoCreditAvailable(final TestContext ctx) {
+
+        // GIVEN a request-response client with no credit left for the link to the peer service
+        Target target = mock(Target.class);
+        when(target.getAddress()).thenReturn("peer/tenant");
+        when(sender.getCredit()).thenReturn(0);
+        when(sender.getRemoteTarget()).thenReturn(target);
+        AbstractRequestResponseClient<SimpleRequestResponseResult> client = getClient("tenant", sender, recv);
+
+        // WHEN sending a request message
+        final Async sendFailure = ctx.async();
+        client.createAndSendRequest("get", null, ctx.asyncAssertFailure(s -> {
+            sendFailure.complete();
+        }));
+
+        // THEN the message is not sent and the request result handler is failed
+        sendFailure.await(100);
+        verify(sender, never()).send(any(Message.class));
+    }
+
+    /**
+     * Verifies that the client creates and sends a message based on provided headers and payload.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testCreateAndSendRequestSendsProperRequestMessage(final TestContext ctx) {
+
+        // GIVEN a request-response client with some credit for the sender link to the peer service
+        Target target = mock(Target.class);
+        when(target.getAddress()).thenReturn("peer/tenant");
+        when(sender.getCredit()).thenReturn(10);
+        when(sender.getRemoteTarget()).thenReturn(target);
+        AbstractRequestResponseClient<SimpleRequestResponseResult> client = getClient("tenant", sender, recv);
+
+        // WHEN sending a request message with some headers and payload
+        final JsonObject payload = new JsonObject().put("key", "value");
+        final Map<String, Object> props = Collections.singletonMap("test-key", "test-value");
+        client.createAndSendRequest("get", props, payload, s -> {});
+
+        // THEN the message is sent and the message being sent contains the headers as application properties
+        ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture());
+        assertThat(messageCaptor.getValue(), is(notNullValue()));
+        assertThat(messageCaptor.getValue().getBody(), is(notNullValue()));
+        assertThat(messageCaptor.getValue().getBody(), instanceOf(AmqpValue.class));
+        AmqpValue body = (AmqpValue) messageCaptor.getValue().getBody();
+        assertThat(body.getValue(), is(payload.encode()));
+        assertThat(messageCaptor.getValue().getApplicationProperties(), is(notNullValue()));
+        assertThat(messageCaptor.getValue().getApplicationProperties().getValue().get("test-key"), is("test-value"));
+    }
+
+    /**
+     * Verifies that the client passes a response message to the handler registered for the request that
+     * the response correlates with.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testHandleResponseInvokesHandlerForMatchingCorrelationId(final TestContext ctx) {
+
+        // GIVEN a request message that has been sent to a peer
+        Target target = mock(Target.class);
+        when(target.getAddress()).thenReturn("peer/tenant");
+        when(sender.getCredit()).thenReturn(10);
+        when(sender.getRemoteTarget()).thenReturn(target);
+        AbstractRequestResponseClient<SimpleRequestResponseResult> client = getClient("tenant", sender, recv);
+        final Async responseReceived = ctx.async();
+        client.createAndSendRequest("request", null, null, ctx.asyncAssertSuccess(s -> {
+            ctx.assertEquals(200, s.getStatus());
+            ctx.assertEquals("payload", s.getPayload());
+            responseReceived.complete();
+            
+        }));
+
+        // WHEN a response is received for the request
+        final Message response = ProtonHelper.message("payload");
+        response.setCorrelationId(MESSAGE_ID);
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, "200");
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        client.handleResponse(delivery, response);
+
+        // THEN the response is passed to the handler registered with the request
+        responseReceived.await(1000);
+        
+    }
+
+    private AbstractRequestResponseClient<SimpleRequestResponseResult> getClient(final String tenant, final ProtonSender sender, final ProtonReceiver receiver) {
+
+        return new AbstractRequestResponseClient<SimpleRequestResponseResult>(context, tenant, sender, receiver) {
+
+            @Override
+            protected String getName() {
+                return "peer";
+            }
+
+            @Override
+            protected String createMessageId() {
+                return MESSAGE_ID;
+            }
+
+            @Override
+            protected SimpleRequestResponseResult getResult(int status, String payload) {
+                return SimpleRequestResponseResult.from(status, payload);
+            }
+        };
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/SimpleRequestResponseResult.java b/client/src/test/java/org/eclipse/hono/client/impl/SimpleRequestResponseResult.java
new file mode 100644
index 000000000..a4e781b72
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/SimpleRequestResponseResult.java
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+
+package org.eclipse.hono.client.impl;
+
+import org.eclipse.hono.util.RequestResponseResult;
+
+
+/**
+ * A result that contains a status code and a string payload.
+ *
+ */
+public final class SimpleRequestResponseResult extends RequestResponseResult<String> {
+
+    private SimpleRequestResponseResult(final int status, final String payload) {
+        super(status, payload);
+    }
+
+    /**
+     * Creates a new instance for a status code and payload.
+     * 
+     * @param status The status code.
+     * @param payload The payload.
+     * @return The instance.
+     */
+    public static SimpleRequestResponseResult from(final int status, final String payload) {
+        return new SimpleRequestResponseResult(status, payload);
+    }
+}
