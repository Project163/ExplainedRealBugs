diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index b9125e61f..e0e602e73 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -570,21 +570,14 @@ public class HonoConnectionImpl implements HonoConnection {
                 logConnectionError(connectionFailureCause);
             }
             // apply exponential backoff with jitter
-            // determine the max delay for this reconnect attempt as 2^attempt * delayIncrement
-            final long currentMaxDelay = (long) Math.pow(2, reconnectAttempt - 1)
-                    * clientConfigProperties.getReconnectDelayIncrement();
-            final long reconnectInterval;
-            if (currentMaxDelay > clientConfigProperties.getReconnectMinDelay()) {
-                // let the actual reconnect delay be a random between the minDelay and the currentMaxDelay,
-                // capped by the overall maxDelay
-                reconnectInterval = ThreadLocalRandom.current().nextLong(clientConfigProperties.getReconnectMinDelay(),
-                        Math.min(clientConfigProperties.getReconnectMaxDelay(), currentMaxDelay));
-            } else {
-                reconnectInterval = clientConfigProperties.getReconnectMinDelay();
-            }
-            if (reconnectInterval > 0) {
-                log.trace("scheduling new connection attempt in {}ms ...", reconnectInterval);
-                vertx.setTimer(reconnectInterval, tid -> {
+            final long reconnectMaxDelay = getReconnectMaxDelay(reconnectAttempt);
+            // let the actual reconnect delay be a random between the minDelay and the current maxDelay
+            final long reconnectDelay = reconnectMaxDelay > clientConfigProperties.getReconnectMinDelay()
+                    ? ThreadLocalRandom.current().nextLong(clientConfigProperties.getReconnectMinDelay(), reconnectMaxDelay)
+                    : clientConfigProperties.getReconnectMinDelay();
+            if (reconnectDelay > 0) {
+                log.trace("scheduling new connection attempt in {}ms ...", reconnectDelay);
+                vertx.setTimer(reconnectDelay, tid -> {
                     connect(clientOptions, connectionHandler, disconnectHandler);
                 });
             } else {
@@ -593,6 +586,26 @@ public class HonoConnectionImpl implements HonoConnection {
         }
     }
 
+    /**
+     * Get the maximum delay to be applied before the given reconnect attempt.
+     *
+     * @param reconnectAttempt The reconnect attempt.
+     * @return The delay in milliseconds.
+     */
+    final long getReconnectMaxDelay(final int reconnectAttempt) {
+        if (reconnectAttempt <= 0) {
+            return 0L;
+        } else if (reconnectAttempt <= 31) {
+            // determine the max delay for this reconnect attempt as 2^attempt * delayIncrement
+            final long currentMaxDelay = (1 << (reconnectAttempt - 1)) * clientConfigProperties.getReconnectDelayIncrement();
+            return currentMaxDelay >= 0 ? Math.min(clientConfigProperties.getReconnectMaxDelay(), currentMaxDelay)
+                    : clientConfigProperties.getReconnectMaxDelay();
+        } else {
+            // higher reconnectAttempt values would result in a maxDelay of more than a year, so use the configured maxDelay
+            return clientConfigProperties.getReconnectMaxDelay();
+        }
+    }
+
     /**
      * Log the connection error.
      *
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index 3f19cf536..f5e6d5ae1 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -1022,4 +1022,26 @@ public class HonoConnectionImplTest {
                 ctx.completeNow();
             }));
     }
+
+    /**
+     * Verifies that the calculation of the maximum reconnect delay value works as expected (also for high reconnect
+     * attempt numbers).
+     */
+    @Test
+    public void testGetReconnectMaxDelay() {
+        final long reconnectMaxDelay = 20000;
+        props.setReconnectMaxDelay(reconnectMaxDelay);
+        props.setReconnectDelayIncrement(100);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+        assertThat(honoConnection.getReconnectMaxDelay(0)).isEqualTo(0);
+        assertThat(honoConnection.getReconnectMaxDelay(1)).isEqualTo(100);
+        assertThat(honoConnection.getReconnectMaxDelay(3)).isEqualTo(400);
+        assertThat(honoConnection.getReconnectMaxDelay(31)).isEqualTo(reconnectMaxDelay);
+        assertThat(honoConnection.getReconnectMaxDelay(Integer.MAX_VALUE)).isEqualTo(reconnectMaxDelay);
+
+        props.setReconnectDelayIncrement(Long.MAX_VALUE);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+        assertThat(honoConnection.getReconnectMaxDelay(31)).isEqualTo(reconnectMaxDelay);
+        assertThat(honoConnection.getReconnectMaxDelay(Integer.MAX_VALUE)).isEqualTo(reconnectMaxDelay);
+    }
 }
