diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java
new file mode 100644
index 000000000..1d9bc9058
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactory.java
@@ -0,0 +1,122 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.function.Consumer;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ConnectionLifecycle;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.impl.AmqpAdapterClientFactoryImpl;
+
+import io.vertx.core.Future;
+
+/**
+ * A Vert.x based factory for creating clients for Hono's AMQP adapter.
+ */
+public interface AmqpAdapterClientFactory extends ConnectionLifecycle<HonoConnection> {
+
+    /**
+     * Creates a new factory for an existing connection.
+     *
+     * @param connection The connection to use.
+     * @param tenantId The ID of the tenant for which the connection is authenticated.
+     * @return The factory.
+     * @throws NullPointerException if any of the parameters is {@code null}
+     */
+    static AmqpAdapterClientFactory create(final HonoConnection connection, final String tenantId) {
+        return new AmqpAdapterClientFactoryImpl(connection, tenantId);
+    }
+
+    /**
+     * Gets a client for sending telemetry data to Hono's AMQP protocol adapter.
+     * <p>
+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory
+     * instance belongs to.
+     * <p>
+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the
+     * factory to ensure that it contains a valid and open AMQP link.
+     *
+     * @return A future that will complete with the sender once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * 
+     * @see "https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/"
+     */
+    Future<TelemetrySender> getOrCreateTelemetrySender();
+
+    /**
+     * Gets a client for sending events to Hono's AMQP protocol adapter.
+     * <p>
+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory
+     * instance belongs to.
+     * <p>
+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the
+     * factory to ensure that it contains a valid and open AMQP link.
+     *
+     * @return A future that will complete with the sender once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     *
+     * @see "https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/"
+     */
+    Future<EventSender> getOrCreateEventSender();
+
+    /**
+     * Creates a client for consuming commands from Hono's AMQP protocol adapter for a specific device.
+     * <p>
+     * When implementing a (protocol) gateway, this can be used to receive commands for a specific device.
+     * <p>
+     * The command passed in to the command consumer will be settled automatically.
+     *
+     * @param deviceId The device to consume commands for.
+     * @param messageHandler The handler to invoke with every command received.
+     * @return A future that will complete with the consumer once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this factory is not connected.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     * 
+     * @see "https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/"
+     */
+    Future<MessageConsumer> createDeviceSpecificCommandConsumer(String deviceId, Consumer<Message> messageHandler);
+
+    /**
+     * Creates a client for consuming commands from Hono's AMQP protocol adapter for an authenticated device or on a
+     * (protocol) gateway for all devices on whose behalf it acts.
+     * <p>
+     * The command passed in to the command consumer will be settled automatically.
+     *
+     * @param messageHandler The handler to invoke with every command received.
+     * @return A future that will complete with the consumer once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this factory is not connected.
+     * @throws NullPointerException if any of the message handler is {@code null}.
+     * 
+     * @see "https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/"
+     */
+    Future<MessageConsumer> createCommandConsumer(Consumer<Message> messageHandler);
+
+    /**
+     * Gets a client for sending command responses to Hono's AMQP protocol adapter.
+     * <p>
+     * The client returned may be either newly created or it may be an existing client for the tenant that this factory
+     * instance belongs to.
+     * <p>
+     * <b>Do not hold a reference to the returned sender.</b> For each send operation retrieve the sender from the
+     * factory to ensure that it contains a valid and open AMQP link.
+     *
+     * @return A future that will complete with the sender once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * 
+     * @see "https://www.eclipse.org/hono/docs/dev/user-guide/amqp-adapter/"
+     */
+    Future<CommandResponder> getOrCreateCommandResponseSender();
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpSenderLink.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpSenderLink.java
new file mode 100644
index 000000000..601088ccc
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/AmqpSenderLink.java
@@ -0,0 +1,42 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Handler;
+
+/**
+ * Interface for classes that manage a Vert.x based AMQP sender link.
+ */
+public interface AmqpSenderLink {
+
+    /**
+     * Closes the AMQP link with the Hono server this sender is using.
+     * <p>
+     * The underlying AMQP connection to the server is not affected by this operation.
+     *
+     * @param closeHandler A handler that is called back with the outcome of the attempt to close the link.
+     * @throws NullPointerException if the handler is {@code null}.
+     */
+    void close(Handler<AsyncResult<Void>> closeHandler);
+
+    /**
+     * Checks if this sender is (locally) open.
+     * <p>
+     * Note that the value returned is valid during execution of the current vert.x handler only.
+     *
+     * @return {@code true} if this sender can be used to send messages to the peer.
+     */
+    boolean isOpen();
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/CommandResponder.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/CommandResponder.java
new file mode 100644
index 000000000..2a68edd0d
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/CommandResponder.java
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.ServiceInvocationException;
+
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A sender to send back the response message of a command to Hono's AMQP adapter.
+ */
+public interface CommandResponder extends AmqpSenderLink {
+
+    /**
+     * Sends a response message to a command back to the business application.
+     *
+     * @param deviceId The device ID of the device sending the response.
+     * @param targetAddress The address at which the response is expected, i.e. replyTo property of the received command
+     *            message.
+     * @param correlationId The correlation-id property of the command message.
+     * @param status The HTTP status code indicating the outcome of the command.
+     * @param payload The payload of the response. May be {@code null} since it is not required.
+     * @param contentType The contentType of the response (may be {@code null}).
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled) by the application.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the message could not be sent or
+     *         has not been accepted by the application.
+     *
+     * @throws NullPointerException if any of deviceId, targetAddress, or correlationId is {@code null}.
+     */
+    Future<ProtonDelivery> sendCommandResponse(String deviceId, String targetAddress, String correlationId, int status,
+            byte[] payload, String contentType, Map<String, ?> properties);
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/EventSender.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/EventSender.java
new file mode 100644
index 000000000..9fde058e6
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/EventSender.java
@@ -0,0 +1,58 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServerErrorException;
+
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A client for sending event messages to Hono's AMQP adapter.
+ */
+public interface EventSender extends AmqpSenderLink {
+
+    /**
+     * Sends a event message for a given device.
+     *
+     * @param deviceId The id of the device.
+     * @param payload The data to send.
+     *            <p>
+     *            The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload (may be {@code null}).
+     *            <p>
+     *            This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled) by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message could not be sent due to a
+     *         lack of credit. If an event is sent which cannot be processed by the peer the future will be failed with
+     *         either a {@code ServerErrorException} or a {@link ClientErrorException} depending on the reason for the
+     *         failure to process the message.
+     * @throws NullPointerException if any of device-id or payload is {@code null}.
+     * @throws IllegalArgumentException if the properties contain a value of type list, map or array.
+     */
+    Future<ProtonDelivery> send(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            Map<String, ?> properties);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/TelemetrySender.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/TelemetrySender.java
new file mode 100644
index 000000000..89d5c2608
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/TelemetrySender.java
@@ -0,0 +1,92 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServerErrorException;
+
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A client for sending telemetry messages to Hono's AMQP adapter.
+ */
+public interface TelemetrySender extends AmqpSenderLink {
+
+    /**
+     * Sends a telemetry message for a given device.
+     *
+     * @param deviceId The id of the device.
+     * @param payload The data to send.
+     *            <p>
+     *            The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload (may be {@code null}).
+     *            <p>
+     *            This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been sent to the peer. The delivery contained in the future
+     *         will represent the delivery state at the time the future has been succeeded, i.e. it will be locally
+     *         <em>unsettled</em> without any outcome yet.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message could not be sent due to a
+     *         lack of credit. If an event is sent which cannot be processed by the peer the future will be failed with
+     *         either a {@code ServerErrorException} or a {@link ClientErrorException} depending on the reason for the
+     *         failure to process the message.
+     * @throws NullPointerException if any of device-id or payload is {@code null}.
+     * @throws IllegalArgumentException if the properties contain a value of type list, map or array.
+     */
+    Future<ProtonDelivery> send(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            Map<String, ?> properties);
+
+    /**
+     * Sends a telemetry message for a given device and waits for the disposition indicating the outcome of the
+     * transfer.
+     *
+     * @param deviceId The id of the device.
+     * @param payload The data to send.
+     *            <p>
+     *            The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload (may be {@code null}).
+     *            <p>
+     *            This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled) by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message could not be sent due to a
+     *         lack of credit. If an event is sent which cannot be processed by the peer the future will be failed with
+     *         either a {@code ServerErrorException} or a {@link ClientErrorException} depending on the reason for the
+     *         failure to process the message.
+     * @throws NullPointerException if any of device-id or payload is {@code null}.
+     * @throws IllegalArgumentException if the properties contain a value of type list, map or array.
+     */
+    Future<ProtonDelivery> sendAndWaitForOutcome(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            Map<String, ?> properties);
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponder.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponder.java
new file mode 100644
index 000000000..9ba7f4722
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableCommandResponder.java
@@ -0,0 +1,55 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.ServiceInvocationException;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A sender to send back the response message of a command to Hono's AMQP adapter.
+ */
+public interface TraceableCommandResponder extends CommandResponder {
+
+    /**
+     * Sends a response message to a command back to the business application.
+     *
+     * @param deviceId The device ID of the device sending the response.
+     * @param targetAddress The address at which the response is expected, i.e. replyTo property of the received command
+     *            message.
+     * @param correlationId The correlation-id property of the command message.
+     * @param status The HTTP status code indicating the outcome of the command.
+     * @param payload The payload of the response. May be {@code null} since it is not required.
+     * @param contentType The contentType of the response. May be {@code null} since it is not required.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @param context The context to create the span in. If {@code null}, then the span is created without a parent.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled) by the application.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the message could not be sent or
+     *         has not been accepted by the application.
+     *
+     * @throws NullPointerException if any of deviceId, targetAddress, or correlationId is {@code null}.
+     */
+    Future<ProtonDelivery> sendCommandResponse(String deviceId, String targetAddress, String correlationId, int status,
+            byte[] payload, String contentType, Map<String, ?> properties, SpanContext context);
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableEventSender.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableEventSender.java
new file mode 100644
index 000000000..73bc30331
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableEventSender.java
@@ -0,0 +1,61 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServerErrorException;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A client for sending event messages to Hono's AMQP adapter.
+ */
+public interface TraceableEventSender extends EventSender {
+
+    /**
+     * Sends a event message for a given device.
+     *
+     * @param deviceId The id of the device.
+     * @param payload The data to send.
+     *            <p>
+     *            The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload (may be {@code null}).
+     *            <p>
+     *            This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @param context The context to create the span in. If {@code null}, then the span is created without a parent.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled) by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message could not be sent due to a
+     *         lack of credit. If an event is sent which cannot be processed by the peer the future will be failed with
+     *         either a {@code ServerErrorException} or a {@link ClientErrorException} depending on the reason for the
+     *         failure to process the message.
+     * @throws NullPointerException if any of device-id or payload is {@code null}.
+     * @throws IllegalArgumentException if the properties contain a value of type list, map or array.
+     */
+    Future<ProtonDelivery> send(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            Map<String, ?> properties,
+            SpanContext context);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableTelemetrySender.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableTelemetrySender.java
new file mode 100644
index 000000000..fffd92c98
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/TraceableTelemetrySender.java
@@ -0,0 +1,97 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.ClientErrorException;
+import org.eclipse.hono.client.ServerErrorException;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A client for sending telemetry messages to Hono's AMQP adapter.
+ */
+public interface TraceableTelemetrySender extends TelemetrySender {
+
+    /**
+     * Sends a telemetry message for a given device.
+     *
+     * @param deviceId The id of the device.
+     * @param payload The data to send.
+     *            <p>
+     *            The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload (may be {@code null}).
+     *            <p>
+     *            This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @param context The context to create the span in. If {@code null}, then the span is created without a parent.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been sent to the peer. The delivery contained in the future
+     *         will represent the delivery state at the time the future has been succeeded, i.e. it will be locally
+     *         <em>unsettled</em> without any outcome yet.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message could not be sent due to a
+     *         lack of credit. If an event is sent which cannot be processed by the peer the future will be failed with
+     *         either a {@code ServerErrorException} or a {@link ClientErrorException} depending on the reason for the
+     *         failure to process the message.
+     * @throws NullPointerException if any of device-id or payload is {@code null}.
+     * @throws IllegalArgumentException if the properties contain a value of type list, map or array.
+     */
+    Future<ProtonDelivery> send(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            Map<String, ?> properties,
+            SpanContext context);
+
+    /**
+     * Sends a telemetry message for a given device and waits for the disposition indicating the outcome of the
+     * transfer.
+     *
+     * @param deviceId The id of the device.
+     * @param payload The data to send.
+     *            <p>
+     *            The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
+     * @param contentType The content type of the payload (may be {@code null}).
+     *            <p>
+     *            This parameter will be used as the value for the message's <em>content-type</em> property.
+     * @param properties Optional application properties (may be {@code null}).
+     *            <p>
+     *            AMQP application properties that can be used for carrying data in the message other than the payload.
+     * @param context The context to create the span in. If {@code null}, then the span is created without a parent.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled) by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message could not be sent due to a
+     *         lack of credit. If an event is sent which cannot be processed by the peer the future will be failed with
+     *         either a {@code ServerErrorException} or a {@link ClientErrorException} depending on the reason for the
+     *         failure to process the message.
+     * @throws NullPointerException if any of device-id or payload is {@code null}.
+     * @throws IllegalArgumentException if the properties contain a value of type list, map or array.
+     */
+    Future<ProtonDelivery> sendAndWaitForOutcome(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            Map<String, ?> properties,
+            SpanContext context);
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumer.java
new file mode 100644
index 000000000..e9e41806b
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumer.java
@@ -0,0 +1,174 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp.internal;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.BiConsumer;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.impl.CommandConsumer;
+import org.eclipse.hono.tracing.TracingHelper;
+import org.eclipse.hono.util.CommandConstants;
+import org.eclipse.hono.util.ResourceIdentifier;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.log.Fields;
+import io.opentracing.noop.NoopTracer;
+import io.vertx.core.Future;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+
+/**
+ * A wrapper around an AMQP receiver link for consuming commands from Hono's AMQP adapter. This implementation tries to
+ * restore closed links by trying to create a new link each time the link is closed.
+ */
+public class AmqpAdapterClientCommandConsumer extends CommandConsumer {
+
+    private static final Logger LOG = LoggerFactory.getLogger(AmqpAdapterClientCommandConsumer.class);
+
+    /**
+     * Creates a consumer for a connection and a receiver link.
+     *
+     * @param connection The connection to the AMQP Messaging Network over which commands are received.
+     * @param receiver The receiver link for command messages.
+     */
+    private AmqpAdapterClientCommandConsumer(final HonoConnection connection, final ProtonReceiver receiver) {
+        super(connection, receiver);
+    }
+
+    /**
+     * Creates a new command consumer for the given device.
+     * <p>
+     * The underlying receiver link will be created with its <em>autoAccept</em> property set to {@code true} and with
+     * the connection's default pre-fetch size.
+     *
+     * @param con The connection to the server.
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the commands should be consumed.
+     * @param messageHandler The handler to invoke with every message received.
+     * @return A future indicating the outcome of the creation attempt.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    public static Future<MessageConsumer> create(
+            final HonoConnection con,
+            final String tenantId,
+            final String deviceId,
+            final BiConsumer<ProtonDelivery, Message> messageHandler) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(messageHandler);
+
+        final ResourceIdentifier address = ResourceIdentifier
+                .from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, tenantId, deviceId);
+        return createCommandConsumer(con, messageHandler, address);
+    }
+
+    /**
+     * Creates a new command consumer.
+     * <p>
+     * The underlying receiver link will be created with its <em>autoAccept</em> property set to {@code true} and with
+     * the connection's default pre-fetch size.
+     *
+     * @param con The connection to the server.
+     * @param messageHandler The handler to invoke with every message received.
+     * @return A future indicating the outcome of the creation attempt.
+     * @throws NullPointerException if any of the parameters are {@code null}.
+     */
+    public static Future<MessageConsumer> create(
+            final HonoConnection con,
+            final BiConsumer<ProtonDelivery, Message> messageHandler) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(messageHandler);
+
+        final ResourceIdentifier address = ResourceIdentifier
+                .from(CommandConstants.NORTHBOUND_COMMAND_REQUEST_ENDPOINT, null, null);
+        return createCommandConsumer(con, messageHandler, address);
+    }
+
+    private static Future<MessageConsumer> createCommandConsumer(final HonoConnection con,
+            final BiConsumer<ProtonDelivery, Message> messageHandler, final ResourceIdentifier address) {
+
+        return con.isConnected(con.getConfig().getLinkEstablishmentTimeout())
+                .compose(v -> createReceiver(con, messageHandler, address))
+                .map(rec -> {
+                    final AmqpAdapterClientCommandConsumer consumer = new AmqpAdapterClientCommandConsumer(con, rec);
+                    con.addReconnectListener(
+                            c -> createReceiver(con, messageHandler, address).onSuccess(consumer::setReceiver));
+                    return consumer;
+                });
+
+    }
+
+    private static Future<ProtonReceiver> createReceiver(final HonoConnection con,
+            final BiConsumer<ProtonDelivery, Message> messageHandler, final ResourceIdentifier address) {
+        return con.createReceiver(
+                address.toString(),
+                ProtonQoS.AT_LEAST_ONCE,
+                (protonDelivery, message) -> {
+                    traceCommand(con, address, message);
+                    messageHandler.accept(protonDelivery, message);
+                },
+                // TODO maybe this could be handled by reopening the link?
+                remote -> LOG.info("The remote [{}] closed the receiver link", remote));
+    }
+
+    private static void traceCommand(final HonoConnection con, final ResourceIdentifier address,
+            final Message message) {
+        final Tracer tracer = con.getTracer();
+        if (tracer instanceof NoopTracer) {
+            return;
+        }
+
+        // try to extract Span context from incoming message
+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, message);
+        final Span currentSpan = createSpan("receive command", address.getTenantId(),
+                address.getResourceId(), null, tracer, spanContext);
+        final Object correlationId = message.getCorrelationId();
+        if (correlationId == null || correlationId instanceof String) {
+            final Map<String, String> items = new HashMap<>(5);
+            items.put(Fields.EVENT, "received command message");
+            TracingHelper.TAG_CORRELATION_ID.set(currentSpan, ((String) correlationId));
+            items.put("to", message.getAddress());
+            items.put("reply-to", message.getReplyTo());
+            items.put("name", message.getSubject());
+            items.put("content-type", message.getContentType());
+            currentSpan.log(items);
+        } else {
+            TracingHelper.logError(currentSpan,
+                    "received invalid command message. correlation-id is not of type string.");
+        }
+    }
+
+    private void setReceiver(final ProtonReceiver protonReceiver) {
+        receiver = protonReceiver;
+    }
+
+    // visible for testing
+    ProtonReceiver getReceiver() {
+        return receiver;
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandResponseSender.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandResponseSender.java
new file mode 100644
index 000000000..f4290aec7
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandResponseSender.java
@@ -0,0 +1,134 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp.internal;
+
+import java.util.Map;
+import java.util.Objects;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.CommandResponse;
+import org.eclipse.hono.client.CommandResponseSender;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.device.amqp.CommandResponder;
+import org.eclipse.hono.client.device.amqp.TraceableCommandResponder;
+import org.eclipse.hono.client.impl.CommandResponseSenderImpl;
+import org.eclipse.hono.util.MessageHelper;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * A Vertx-Proton based client for sending response messages to commands to Hono's AMQP adapter.
+ */
+public class AmqpAdapterClientCommandResponseSender extends CommandResponseSenderImpl
+        implements CommandResponder, TraceableCommandResponder {
+
+    AmqpAdapterClientCommandResponseSender(final HonoConnection connection, final ProtonSender sender,
+            final String tenantId) {
+        super(connection, sender, tenantId, null);
+    }
+
+    /**
+     * Creates a new sender to send responses for commands back to the business application.
+     *
+     * @param con The connection to the Hono server.
+     * @param tenantId The tenant that the events will be published for.
+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
+     *            sender's target address is provided as an argument to the handler.
+     * @return A future indicating the outcome.
+     * @throws NullPointerException if con or tenantId is {@code null}.
+     */
+    public static Future<CommandResponder> createWithAnonymousLinkAddress(
+            final HonoConnection con,
+            final String tenantId,
+            final Handler<String> remoteCloseHook) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+
+        return con.createSender(null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
+                .map(sender -> new AmqpAdapterClientCommandResponseSender(con, sender, tenantId));
+    }
+
+    /**
+     * Shadowing the static factory method, which only works within a protocol adapter, a use case that is not supported
+     * by this class.
+     *
+     * @param con not used.
+     * @param tenantId not used.
+     * @param replyId not used.
+     * @param closeHook not used.
+     * @return nothing.
+     * @throws UnsupportedOperationException always.
+     */
+    public static Future<CommandResponseSender> create(
+            final HonoConnection con,
+            final String tenantId,
+            final String replyId,
+            final Handler<String> closeHook) {
+        throw new UnsupportedOperationException("This method is not supported by this class");
+    }
+
+    @Override
+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,
+            final String correlationId, final int status, final byte[] payload, final String contentType,
+            final Map<String, ?> properties) {
+        return sendCommandResponse(deviceId, targetAddress, correlationId, status, payload, contentType,
+                properties, null);
+    }
+
+    @Override
+    public Future<ProtonDelivery> sendCommandResponse(final String deviceId, final String targetAddress,
+            final String correlationId, final int status, final byte[] payload,
+            final String contentType, final Map<String, ?> properties, final SpanContext context) {
+
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(targetAddress);
+        Objects.requireNonNull(correlationId);
+
+        final Message message = ProtonHelper.message();
+        message.setAddress(targetAddress);
+        message.setCorrelationId(correlationId);
+
+        MessageHelper.setCreationTime(message);
+
+        setApplicationProperties(message, properties);
+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);
+        MessageHelper.addProperty(message, MessageHelper.APP_PROPERTY_STATUS, status);
+        MessageHelper.setPayload(message, contentType, payload);
+
+        return sendAndWaitForOutcome(message, context);
+    }
+
+    /**
+     * The method in the parent class is only intended for use by a protocol adapter to forward the command response
+     * downstream, and this use case is not supported in this class.
+     * 
+     * @param commandResponse not used.
+     * @param context not used.
+     * @return nothing.
+     * @throws UnsupportedOperationException always.
+     */
+    @Override
+    public Future<ProtonDelivery> sendCommandResponse(final CommandResponse commandResponse,
+            final SpanContext context) {
+        throw new UnsupportedOperationException("This method is not supported by this class");
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientEventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientEventSenderImpl.java
new file mode 100644
index 000000000..ee0afdf60
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientEventSenderImpl.java
@@ -0,0 +1,104 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp.internal;
+
+import java.util.Map;
+import java.util.Objects;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.DownstreamSender;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.device.amqp.EventSender;
+import org.eclipse.hono.client.device.amqp.TraceableEventSender;
+import org.eclipse.hono.client.impl.EventSenderImpl;
+import org.eclipse.hono.util.MessageHelper;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * A Vertx-Proton based client for publishing event messages to Hono's AMQP adapter.
+ */
+public class AmqpAdapterClientEventSenderImpl extends EventSenderImpl implements EventSender, TraceableEventSender {
+
+    AmqpAdapterClientEventSenderImpl(final HonoConnection con, final ProtonSender sender, final String tenantId,
+            final String targetAddress) {
+        super(con, sender, tenantId, targetAddress);
+    }
+
+    /**
+     * Creates a new sender for publishing events to Hono's AMQP adapter.
+     *
+     * @param con The connection to the Hono server.
+     * @param tenantId The tenant that the events will be published for.
+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
+     *            sender's target address is provided as an argument to the handler.
+     * @return A future indicating the outcome.
+     * @throws NullPointerException if con or tenantId is {@code null}.
+     */
+    public static Future<EventSender> createWithAnonymousLinkAddress(
+            final HonoConnection con,
+            final String tenantId,
+            final Handler<String> remoteCloseHook) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+
+        final String targetAddress = null; // anonymous relay
+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
+                .map(sender -> new AmqpAdapterClientEventSenderImpl(con, sender, tenantId, targetAddress));
+    }
+
+    /**
+     * Shadowing the static factory method, which only works within a protocol adapter, a use case that is not supported
+     * by this class.
+     *
+     * @param con not used.
+     * @param tenantId not used.
+     * @param remoteCloseHook not used.
+     * @return nothing.
+     * @throws UnsupportedOperationException always.
+     */
+    public static Future<DownstreamSender> create(
+            final HonoConnection con,
+            final String tenantId,
+            final Handler<String> remoteCloseHook) {
+        throw new UnsupportedOperationException("This method is not supported by this class");
+    }
+
+    @Override
+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,
+            final Map<String, ?> properties, final SpanContext context) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(payload);
+
+        final Message msg = ProtonHelper.message();
+        msg.setAddress(getTo(deviceId));
+        MessageHelper.setPayload(msg, contentType, payload);
+        setApplicationProperties(msg, properties);
+        MessageHelper.addDeviceId(msg, deviceId);
+        return send(msg, context);
+    }
+
+    @Override
+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,
+            final Map<String, ?> properties) {
+        return send(deviceId, payload, contentType, properties, null);
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientTelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientTelemetrySenderImpl.java
new file mode 100644
index 000000000..ee10e3b6c
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientTelemetrySenderImpl.java
@@ -0,0 +1,124 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp.internal;
+
+import java.util.Map;
+import java.util.Objects;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.DownstreamSender;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.device.amqp.TelemetrySender;
+import org.eclipse.hono.client.device.amqp.TraceableTelemetrySender;
+import org.eclipse.hono.client.impl.TelemetrySenderImpl;
+import org.eclipse.hono.util.MessageHelper;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * A Vertx-Proton based client for publishing telemetry messages to Hono's AMQP adapter.
+ */
+public class AmqpAdapterClientTelemetrySenderImpl extends TelemetrySenderImpl
+        implements TelemetrySender, TraceableTelemetrySender {
+
+    AmqpAdapterClientTelemetrySenderImpl(final HonoConnection con, final ProtonSender sender, final String tenantId,
+            final String targetAddress) {
+        super(con, sender, tenantId, targetAddress);
+    }
+
+    /**
+     * Creates a new sender for publishing telemetry data to Hono's AMQP adapter.
+     *
+     * @param con The connection to the Hono server.
+     * @param tenantId The tenant that the telemetry data will be published for.
+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
+     *            sender's target address is provided as an argument to the handler.
+     * @return A future indicating the outcome.
+     * @throws NullPointerException if con or tenantId is {@code null}.
+     */
+    public static Future<TelemetrySender> createWithAnonymousLinkAddress(
+            final HonoConnection con,
+            final String tenantId,
+            final Handler<String> remoteCloseHook) {
+
+        Objects.requireNonNull(con);
+        Objects.requireNonNull(tenantId);
+
+        final String targetAddress = null; // anonymous relay
+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
+                .map(sender -> new AmqpAdapterClientTelemetrySenderImpl(con, sender, tenantId, targetAddress));
+    }
+
+    /**
+     * Shadowing the static factory method, which only works within a protocol adapter, a use case that is not supported
+     * by this class.
+     *
+     * @param con not used.
+     * @param tenantId not used.
+     * @param remoteCloseHook not used.
+     * @return nothing.
+     * @throws UnsupportedOperationException always.
+     */
+    public static Future<DownstreamSender> create(
+            final HonoConnection con,
+            final String tenantId,
+            final Handler<String> remoteCloseHook) {
+        throw new UnsupportedOperationException("This method is not supported by this class");
+    }
+
+    @Override
+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,
+            final Map<String, ?> properties) {
+        return send(deviceId, payload, contentType, properties, null);
+    }
+
+    @Override
+    public Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType,
+            final Map<String, ?> properties, final SpanContext context) {
+        final Message msg = createMessage(deviceId, payload, contentType, properties);
+        return send(msg, context);
+    }
+
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(final String deviceId, final byte[] payload,
+            final String contentType, final Map<String, ?> properties) {
+        return sendAndWaitForOutcome(deviceId, payload, contentType, properties, null);
+    }
+
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(final String deviceId, final byte[] payload,
+            final String contentType, final Map<String, ?> properties, final SpanContext context) {
+        final Message msg = createMessage(deviceId, payload, contentType, properties);
+        return sendAndWaitForOutcome(msg, context);
+    }
+
+    private Message createMessage(final String deviceId, final byte[] payload, final String contentType,
+            final Map<String, ?> properties) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(payload);
+
+        final Message msg = ProtonHelper.message();
+        msg.setAddress(getTo(deviceId));
+        MessageHelper.setPayload(msg, contentType, payload);
+        setApplicationProperties(msg, properties);
+        MessageHelper.addDeviceId(msg, deviceId);
+        return msg;
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientFactoryImpl.java
new file mode 100644
index 000000000..c624041c6
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AmqpAdapterClientFactoryImpl.java
@@ -0,0 +1,164 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+import java.util.function.Consumer;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.device.amqp.AmqpAdapterClientFactory;
+import org.eclipse.hono.client.device.amqp.AmqpSenderLink;
+import org.eclipse.hono.client.device.amqp.CommandResponder;
+import org.eclipse.hono.client.device.amqp.EventSender;
+import org.eclipse.hono.client.device.amqp.TelemetrySender;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandConsumer;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandResponseSender;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientEventSenderImpl;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientTelemetrySenderImpl;
+import org.eclipse.hono.util.CommandConstants;
+
+import io.vertx.core.Future;
+
+/**
+ * A factory for creating clients for Hono's AMQP adapter that uses caching for the senders to ensure that they always
+ * contain a open Vert.x ProtonSender.
+ */
+public final class AmqpAdapterClientFactoryImpl extends AbstractHonoClientFactory implements AmqpAdapterClientFactory {
+
+    private final CachingClientFactory<TelemetrySender> telemetrySenderClientFactory;
+    private final CachingClientFactory<EventSender> eventSenderClientFactory;
+    private final CachingClientFactory<CommandResponder> commandResponseSenderClientFactory;
+
+    private final String tenantId;
+    private final ClientFactory<MessageConsumer> commandConsumerFactory;
+
+    /**
+     * Creates a new factory instance for an existing connection and a given tenant.
+     *
+     * @param connection The connection to use.
+     * @param tenantId The ID of the tenant to be used for the clients created by this factory.
+     * @throws NullPointerException if any of the parameters is {@code null}
+     */
+    public AmqpAdapterClientFactoryImpl(final HonoConnection connection, final String tenantId) {
+        super(connection);
+        Objects.requireNonNull(tenantId);
+
+        telemetrySenderClientFactory = new CachingClientFactory<>(connection.getVertx(), AmqpSenderLink::isOpen);
+        eventSenderClientFactory = new CachingClientFactory<>(connection.getVertx(), AmqpSenderLink::isOpen);
+        commandResponseSenderClientFactory = new CachingClientFactory<>(connection.getVertx(), AmqpSenderLink::isOpen);
+        commandConsumerFactory = new ClientFactory<>();
+
+        this.tenantId = tenantId;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onDisconnect() {
+        telemetrySenderClientFactory.clearState();
+        eventSenderClientFactory.clearState();
+        commandResponseSenderClientFactory.clearState();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<TelemetrySender> getOrCreateTelemetrySender() {
+
+        final String cacheKey = TelemetrySenderImpl.getTargetAddress(tenantId, null);
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    telemetrySenderClientFactory.getOrCreateClient(
+                            cacheKey,
+                            () -> AmqpAdapterClientTelemetrySenderImpl.createWithAnonymousLinkAddress(
+                                    connection, tenantId,
+                                    onSenderClosed -> telemetrySenderClientFactory.removeClient(cacheKey)),
+                            result);
+                }));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<EventSender> getOrCreateEventSender() {
+
+        final String cacheKey = EventSenderImpl.getTargetAddress(tenantId, null);
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    eventSenderClientFactory.getOrCreateClient(
+                            cacheKey,
+                            () -> AmqpAdapterClientEventSenderImpl.createWithAnonymousLinkAddress(
+                                    connection, tenantId,
+                                    onSenderClosed -> eventSenderClientFactory.removeClient(cacheKey)),
+                            result);
+                }));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<MessageConsumer> createDeviceSpecificCommandConsumer(final String deviceId,
+            final Consumer<Message> messageHandler) {
+
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(messageHandler);
+
+        return connection.executeOnContext(result -> commandConsumerFactory.createClient(
+                () -> AmqpAdapterClientCommandConsumer.create(
+                        connection,
+                        tenantId,
+                        deviceId,
+                        (delivery, message) -> messageHandler.accept(message)),
+                result));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<MessageConsumer> createCommandConsumer(final Consumer<Message> messageHandler) {
+
+        Objects.requireNonNull(messageHandler);
+
+        return connection.executeOnContext(result -> commandConsumerFactory.createClient(
+                () -> AmqpAdapterClientCommandConsumer.create(
+                        connection,
+                        (delivery, message) -> messageHandler.accept(message)),
+                result));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<CommandResponder> getOrCreateCommandResponseSender() {
+
+        final String cacheKey = CommandConstants.NORTHBOUND_COMMAND_RESPONSE_ENDPOINT + "/" + tenantId;
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    commandResponseSenderClientFactory.getOrCreateClient(
+                            cacheKey,
+                            () -> AmqpAdapterClientCommandResponseSender.createWithAnonymousLinkAddress(
+                                    connection, tenantId,
+                                    onSenderClosed -> commandResponseSenderClientFactory.removeClient(cacheKey)),
+                            result);
+                }));
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
index 5d3e60467..709087748 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandResponseSenderImpl.java
@@ -42,7 +42,15 @@ public class CommandResponseSenderImpl extends AbstractSender implements Command
      */
     public static final long DEFAULT_COMMAND_FLOW_LATENCY = 200L; // ms
 
-    CommandResponseSenderImpl(
+    /**
+     * Creates a command response sender instance for a given connection and proton sender.
+     *
+     * @param connection The open connection to the Hono server.
+     * @param sender The sender link to send command response messages over.
+     * @param tenantId The tenant that the messages will be published for.
+     * @param targetAddress The target address to send the messages to.
+     */
+    protected CommandResponseSenderImpl(
             final HonoConnection connection,
             final ProtonSender sender,
             final String tenantId,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index b0f3b4587..5dd404b63 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -34,9 +34,17 @@ import io.vertx.proton.ProtonSender;
 /**
  * A Vertx-Proton based client for publishing event messages to a Hono server.
  */
-public final class EventSenderImpl extends AbstractDownstreamSender {
+public class EventSenderImpl extends AbstractDownstreamSender {
 
-    EventSenderImpl(
+    /**
+     * Creates a event sender instance for a given connection and proton sender.
+     * 
+     * @param con The open connection to the Hono server.
+     * @param sender The sender link to send events over.
+     * @param tenantId The tenant that the events will be published for.
+     * @param targetAddress The target address to send the events to.
+     */
+    protected EventSenderImpl(
             final HonoConnection con,
             final ProtonSender sender,
             final String tenantId,
@@ -47,7 +55,7 @@ public final class EventSenderImpl extends AbstractDownstreamSender {
 
     /**
      * Gets the AMQP <em>target</em> address to use for sending messages to Hono's event endpoint.
-     * 
+     *
      * @param tenantId The tenant to send events for.
      * @param deviceId The device to send events for. If {@code null}, the target address can be used
      *                 to send events for arbitrary devices belonging to the tenant.
@@ -74,25 +82,25 @@ public final class EventSenderImpl extends AbstractDownstreamSender {
 
     /**
      * Creates a new sender for publishing events to a Hono server.
-     * 
+     *
      * @param con The connection to the Hono server.
      * @param tenantId The tenant that the events will be published for.
-     * @param closeHook The handler to invoke when the Hono server closes the sender. The sender's
-     *                  target address is provided as an argument to the handler.
+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
+     *            sender's target address is provided as an argument to the handler.
      * @return A future indicating the outcome.
-     * @throws NullPointerException if any of context, connection, tenant or handler is {@code null}.
+     * @throws NullPointerException if con or tenantId is {@code null}.
      */
     public static Future<DownstreamSender> create(
             final HonoConnection con,
             final String tenantId,
-            final Handler<String> closeHook) {
+            final Handler<String> remoteCloseHook) {
 
         Objects.requireNonNull(con);
         Objects.requireNonNull(tenantId);
 
         final String targetAddress = getTargetAddress(tenantId, null);
-        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook)
-        .compose(sender -> Future.succeededFuture(new EventSenderImpl(con, sender, tenantId, targetAddress)));
+        return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
+                .compose(sender -> Future.succeededFuture(new EventSenderImpl(con, sender, tenantId, targetAddress)));
     }
 
     /**
@@ -125,7 +133,7 @@ public final class EventSenderImpl extends AbstractDownstreamSender {
      * <p>
      * This method sets the message's <em>durable</em> property to {@code true} and
      * then invokes {@link #sendMessageAndWaitForOutcome(Message, Span)}.
-     * 
+     *
      * @param message The message to send.
      * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
      *              The span will be finished by this method and will contain an error log if
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index f12a09089..b134d34fa 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -40,9 +40,17 @@ import io.vertx.proton.ProtonSender;
 /**
  * A Vertx-Proton based client for uploading telemetry data to a Hono server.
  */
-public final class TelemetrySenderImpl extends AbstractDownstreamSender {
+public class TelemetrySenderImpl extends AbstractDownstreamSender {
 
-    TelemetrySenderImpl(
+    /**
+     * Creates a telemetry sender instance for a given connection and proton sender.
+     *
+     * @param con The open connection to the Hono server.
+     * @param sender The sender link to send telemetry messages over.
+     * @param tenantId The tenant that the messages will be published for.
+     * @param targetAddress The target address to send the messages to.
+     */
+    protected TelemetrySenderImpl(
             final HonoConnection con,
             final ProtonSender sender,
             final String tenantId,
@@ -53,7 +61,7 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
 
     /**
      * Gets the AMQP <em>target</em> address to use for uploading data to Hono's telemetry endpoint.
-     * 
+     *
      * @param tenantId The tenant to upload data for.
      * @param deviceId The device to upload data for. If {@code null}, the target address can be used
      *                 to upload data for arbitrary devices belonging to the tenant.
@@ -81,13 +89,13 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
 
     /**
      * Creates a new sender for publishing telemetry data to a Hono server.
-     * 
+     *
      * @param con The connection to the Hono server.
-     * @param tenantId The tenant that the telemetry data will be uploaded for.
-     * @param remoteCloseHook The handler to invoke when the Hono server closes the sender. The sender's
-     *                        target address is provided as an argument to the handler.
+     * @param tenantId The tenant that the telemetry data will be published for.
+     * @param remoteCloseHook The handler to invoke when the link is closed by the peer (may be {@code null}). The
+     *            sender's target address is provided as an argument to the handler.
      * @return A future indicating the outcome.
-     * @throws NullPointerException if any of context, connection, tenant or handler is {@code null}.
+     * @throws NullPointerException if con or tenantId is {@code null}.
      */
     public static Future<DownstreamSender> create(
             final HonoConnection con,
@@ -99,7 +107,8 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
 
         final String targetAddress = getTargetAddress(tenantId, null);
         return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook)
-        .compose(sender -> Future.succeededFuture(new TelemetrySenderImpl(con, sender, tenantId, targetAddress)));
+                .compose(sender -> Future
+                        .succeededFuture(new TelemetrySenderImpl(con, sender, tenantId, targetAddress)));
     }
 
     /**
@@ -143,7 +152,7 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
 
     /**
      * Sends an AMQP 1.0 message to the peer this client is configured for.
-     * 
+     *
      * @param message The message to send.
      * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
      *              The span will be finished by this method and will contain an error log if
@@ -177,7 +186,8 @@ public final class TelemetrySenderImpl extends AbstractDownstreamSender {
                         final ServerErrorException exception = new ServerErrorException(
                                 HttpURLConnection.HTTP_UNAVAILABLE,
                                 "waiting for delivery update timed out after " + config.getSendMessageTimeout() + "ms");
-                        logMessageSendingError("waiting for delivery update timed out for message [ID: {}, address: {}] after {}ms",
+                        logMessageSendingError(
+                                "waiting for delivery update timed out for message [ID: {}, address: {}] after {}ms",
                                 messageId, getMessageAddress(message), connection.getConfig().getSendMessageTimeout());
                         TracingHelper.logError(currentSpan, exception.getMessage());
                         Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
diff --git a/client/src/test/java/org/eclipse/hono/client/AbstractAmqpAdapterClientDownstreamSenderTestBase.java b/client/src/test/java/org/eclipse/hono/client/AbstractAmqpAdapterClientDownstreamSenderTestBase.java
new file mode 100644
index 000000000..15eb6ed8f
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/AbstractAmqpAdapterClientDownstreamSenderTestBase.java
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.Collections;
+import java.util.Map;
+
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.impl.HonoClientUnitTestHelper;
+import org.eclipse.hono.client.impl.VertxMockSupport;
+import org.eclipse.hono.util.MessageHelper;
+import org.junit.jupiter.api.BeforeEach;
+import org.mockito.ArgumentCaptor;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * Base class for tests of the downstream senders of the AMQP Adapter client.
+ *
+ */
+public abstract class AbstractAmqpAdapterClientDownstreamSenderTestBase {
+
+    protected static final String TENANT_ID = "test-tenant";
+    protected static final String DEVICE_ID = "test-device";
+    protected static final String CONTENT_TYPE = "text/plain";
+    protected static final byte[] PAYLOAD = "test-value".getBytes();
+    protected static final String TEST_PROPERTY_KEY = "test-key";
+    protected static final String TEST_PROPERTY_VALUE = "test-value";
+    protected static final Map<String, String> APPLICATION_PROPERTIES = Collections.singletonMap(TEST_PROPERTY_KEY,
+            TEST_PROPERTY_VALUE);
+
+    protected ProtonSender sender;
+    protected HonoConnection connection;
+    protected ProtonDelivery protonDelivery;
+    protected Tracer.SpanBuilder spanBuilder;
+
+    /**
+     * Sets up fixture.
+     */
+    @BeforeEach
+    public void setUp() {
+        sender = HonoClientUnitTestHelper.mockProtonSender();
+
+        protonDelivery = mock(ProtonDelivery.class);
+        when(protonDelivery.remotelySettled()).thenReturn(true);
+        final Accepted deliveryState = new Accepted();
+        when(protonDelivery.getRemoteState()).thenReturn(deliveryState);
+
+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenReturn(protonDelivery);
+
+        final Span span = mock(Span.class);
+        when(span.context()).thenReturn(mock(SpanContext.class));
+        spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
+
+        final Tracer tracer = mock(Tracer.class);
+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
+
+        connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class));
+
+        when(connection.getTracer()).thenReturn(tracer);
+        when(connection.createSender(any(), any(), any())).thenReturn(Future.succeededFuture(sender));
+
+    }
+
+    /**
+     * Updates the disposition for the {@link ProtonSender#send(Message, Handler)} operation.
+     */
+    @SuppressWarnings("unchecked")
+    protected void updateDisposition() {
+        final ArgumentCaptor<Handler<ProtonDelivery>> dispositionHandlerCaptor = ArgumentCaptor.forClass(Handler.class);
+        verify(sender).send(any(Message.class), dispositionHandlerCaptor.capture());
+        dispositionHandlerCaptor.getValue().handle(protonDelivery);
+    }
+
+    /**
+     * Executes the assertions that check that the message created by the client conforms to the expectations of the
+     * AMQP adapter.
+     *
+     * @param expectedAddress The expected target address.
+     * @return The captured message.
+     */
+    protected Message assertMessageConformsAmqpAdapterSpec(final String expectedAddress) {
+
+        final ArgumentCaptor<Message> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageArgumentCaptor.capture(), any());
+
+        final Message message = messageArgumentCaptor.getValue();
+
+        assertThat(message.getAddress()).isEqualTo(expectedAddress);
+
+        assertThat(MessageHelper.getPayloadAsString(message)).isEqualTo(new String(PAYLOAD));
+        assertThat(message.getContentType()).isEqualTo(CONTENT_TYPE);
+
+        assertThat(MessageHelper.getApplicationProperty(message.getApplicationProperties(), TEST_PROPERTY_KEY,
+                String.class)).isEqualTo(TEST_PROPERTY_VALUE);
+
+        assertThat(MessageHelper.getDeviceId(message)).isEqualTo(DEVICE_ID);
+
+        return message;
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactoryTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactoryTest.java
new file mode 100644
index 000000000..a7d5d8359
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/AmqpAdapterClientFactoryTest.java
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.impl.HonoClientUnitTestHelper;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+import io.vertx.core.Future;
+import io.vertx.core.Vertx;
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * Tests verifying behavior of {@link AmqpAdapterClientFactory}.
+ *
+ */
+public class AmqpAdapterClientFactoryTest {
+
+    private static AmqpAdapterClientFactory factory;
+
+    /**
+     * Sets up the fixture.
+     */
+    @BeforeAll
+    public static void setUp() {
+
+        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class));
+        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
+
+        final ProtonSender protonSender = HonoClientUnitTestHelper.mockProtonSender();
+        when(connection.createSender(any(), any(), any())).thenReturn(Future.succeededFuture(protonSender));
+
+        final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
+        when(connection.createReceiver(anyString(), any(), any(), any())).thenReturn(Future.succeededFuture(receiver));
+
+        factory = AmqpAdapterClientFactory.create(connection, "my-tenant");
+    }
+
+    /**
+     * Verifies that the factories create method returned an instance.
+     */
+    @Test
+    public void testCreateReturnsInstance() {
+        assertThat(factory).isNotNull();
+    }
+
+    /**
+     * Verifies that a telemetry sender instance is returned.
+     */
+    @Test
+    public void testGetOrCreateTelemetrySenderReturnsInstance() {
+        final Future<TelemetrySender> sender = factory.getOrCreateTelemetrySender();
+        assertThat(sender.succeeded());
+        assertThat(sender.result()).isNotNull();
+    }
+
+    /**
+     * Verifies that an event sender instance is returned.
+     */
+    @Test
+    public void testGetOrCreateEventSenderReturnsInstance() {
+        final Future<EventSender> sender = factory.getOrCreateEventSender();
+        assertThat(sender.succeeded());
+        assertThat(sender.result()).isNotNull();
+    }
+
+    /**
+     * Verifies that a device scoped command consumer instance is returned.
+     */
+    @Test
+    public void testCreateDeviceSpecificCommandConsumerReturnsInstance() {
+        final Future<MessageConsumer> commandConsumer = factory.createDeviceSpecificCommandConsumer("my-device", x -> {
+        });
+        assertThat(commandConsumer.succeeded());
+        assertThat(commandConsumer.result()).isNotNull();
+    }
+
+    /**
+     * Verifies that a command consumer instance is returned.
+     */
+    @Test
+    public void testCreateCommandConsumerReturnsInstance() {
+        final Future<MessageConsumer> commandConsumer = factory.createCommandConsumer(x -> {
+        });
+        assertThat(commandConsumer.succeeded());
+        assertThat(commandConsumer.result()).isNotNull();
+    }
+
+    /**
+     * Verifies that a command response sender instance is returned.
+     */
+    @Test
+    public void testGetOrCreateCommandResponseSender() {
+        final Future<CommandResponder> responseSender = factory.getOrCreateCommandResponseSender();
+        assertThat(responseSender.succeeded());
+        assertThat(responseSender.result()).isNotNull();
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java
new file mode 100644
index 000000000..3a7a04d31
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java
@@ -0,0 +1,133 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientCommandResponseSender;
+import org.eclipse.hono.util.CommandConstants;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.junit5.VertxExtension;
+import io.vertx.junit5.VertxTestContext;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * Verifies behavior of {@link CommandResponder}.
+ *
+ */
+@ExtendWith(VertxExtension.class)
+public class CommandResponderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {
+
+    private static final String ADDRESS = CommandConstants.COMMAND_RESPONSE_ENDPOINT + "/" + TENANT_ID + "/" + DEVICE_ID
+            + "/123";
+    private static final String CORRELATION_ID = "0";
+    private static final int STATUS = 200;
+
+    /**
+     * Verifies that the message created by the client conforms to the expectations of the AMQP adapter.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendCommandResponseCreatesValidMessage(final VertxTestContext ctx) {
+
+        // GIVEN a CommandResponder instance
+        final CommandResponder commandResponder = createCommandResponder();
+
+        // WHEN sending a message using the API...
+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID,
+                ADDRESS, CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);
+
+        // ...AND WHEN the disposition is updated by the peer
+        updateDisposition();
+
+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+            // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
+            ctx.verify(this::assertMessageConformsAmqpAdapterSpec);
+            ctx.completeNow();
+        }));
+    }
+
+    /**
+     * Verifies that {@link TraceableCommandResponder} uses the given SpanContext.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendCommandResponseWithTracing(final VertxTestContext ctx) {
+
+        // GIVEN a TraceableCommandResponder instance
+        final TraceableCommandResponder commandResponder = ((TraceableCommandResponder) createCommandResponder());
+
+        // WHEN sending a message using the API...
+        final SpanContext spanContext = mock(SpanContext.class);
+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID,
+                ADDRESS, CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES, spanContext);
+
+        // ...AND WHEN the disposition is updated by the peer
+        updateDisposition();
+
+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+            // THEN the given SpanContext is used
+            ctx.verify(() -> {
+                verify(spanBuilder).addReference(any(), eq(spanContext));
+                assertMessageConformsAmqpAdapterSpec();
+            });
+            ctx.completeNow();
+        }));
+    }
+
+    /**
+     * Verifies that sending the command response waits for the disposition update from the peer.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendingWaitsForDispositionUpdate(final VertxTestContext ctx) {
+
+        // GIVEN a CommandResponder instance
+        final CommandResponder commandResponder = createCommandResponder();
+
+        // WHEN sending a message using the API
+        final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID, ADDRESS,
+                CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);
+
+        deliveryFuture.setHandler(ctx.completing());
+
+        // THEN the future waits for the disposition to be updated by the peer
+        assertThat(deliveryFuture.isComplete()).isFalse();
+        updateDisposition();
+    }
+
+    private CommandResponder createCommandResponder() {
+        return AmqpAdapterClientCommandResponseSender.createWithAnonymousLinkAddress(connection, TENANT_ID, s -> {
+        }).result();
+    }
+
+    private void assertMessageConformsAmqpAdapterSpec() {
+        final Message message = assertMessageConformsAmqpAdapterSpec(ADDRESS);
+        assertThat(message.getCorrelationId()).isEqualTo(CORRELATION_ID);
+        assertThat(message.getApplicationProperties().getValue().get("status")).isEqualTo(STATUS);
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java
new file mode 100644
index 000000000..f5efbb329
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java
@@ -0,0 +1,124 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientEventSenderImpl;
+import org.eclipse.hono.util.EventConstants;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.junit5.VertxExtension;
+import io.vertx.junit5.VertxTestContext;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * Verifies behavior of {@link EventSender}.
+ *
+ */
+@ExtendWith(VertxExtension.class)
+public class EventSenderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {
+
+    private static final String ADDRESS = EventConstants.EVENT_ENDPOINT + "/" + TENANT_ID + "/" + DEVICE_ID;
+
+    /**
+     * Verifies that the message created by the client conforms to the expectations of the AMQP adapter.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendCreatesValidMessage(final VertxTestContext ctx) {
+
+        // GIVEN a EventSender instance
+        final EventSender eventSender = createEventSender();
+
+        // WHEN sending a message using the API...
+        final Future<ProtonDelivery> deliveryFuture = eventSender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE,
+                APPLICATION_PROPERTIES);
+
+        // ...AND WHEN the disposition is updated by the peer
+        updateDisposition();
+
+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+            // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
+            ctx.verify(() -> assertMessageConformsAmqpAdapterSpec(ADDRESS));
+            ctx.completeNow();
+        }));
+    }
+
+    /**
+     * Verifies that {@link TraceableEventSender} uses the given SpanContext.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendWithTracing(final VertxTestContext ctx) {
+
+        // GIVEN a EventSender instance
+        final TraceableEventSender eventSender = ((TraceableEventSender) createEventSender());
+
+        // WHEN sending a message using the API...
+        final SpanContext spanContext = mock(SpanContext.class);
+        final Future<ProtonDelivery> deliveryFuture = eventSender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE,
+                APPLICATION_PROPERTIES, spanContext);
+
+        // ...AND WHEN the disposition is updated by the peer
+        updateDisposition();
+
+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+            // THEN the given SpanContext is used
+            ctx.verify(() -> {
+                verify(spanBuilder).addReference(any(), eq(spanContext));
+                assertMessageConformsAmqpAdapterSpec(ADDRESS);
+            });
+            ctx.completeNow();
+        }));
+    }
+
+    /**
+     * Verifies that sending the message waits for the disposition update from the peer.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendWaitsForDispositionUpdate(final VertxTestContext ctx) {
+
+        // GIVEN a EventSender instance
+        final EventSender eventSender = createEventSender();
+
+        // WHEN sending a message using the API...
+        final Future<ProtonDelivery> deliveryFuture = eventSender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE,
+                APPLICATION_PROPERTIES);
+
+        deliveryFuture.setHandler(ctx.completing());
+
+        // THEN the future waits for the disposition to be updated by the peer
+        assertThat(deliveryFuture.isComplete()).isFalse();
+        updateDisposition();
+    }
+
+    private EventSender createEventSender() {
+        return AmqpAdapterClientEventSenderImpl.createWithAnonymousLinkAddress(connection, TENANT_ID, s -> {
+                }).result();
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java
new file mode 100644
index 000000000..aa234b85f
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java
@@ -0,0 +1,164 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.util.Map;
+
+import org.eclipse.hono.client.AbstractAmqpAdapterClientDownstreamSenderTestBase;
+import org.eclipse.hono.client.device.amqp.internal.AmqpAdapterClientTelemetrySenderImpl;
+import org.eclipse.hono.util.TelemetryConstants;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+import io.opentracing.SpanContext;
+import io.vertx.core.Future;
+import io.vertx.junit5.VertxExtension;
+import io.vertx.junit5.VertxTestContext;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * Verifies behavior of {@link TelemetrySender}.
+ *
+ */
+@ExtendWith(VertxExtension.class)
+public class TelemetrySenderTest extends AbstractAmqpAdapterClientDownstreamSenderTestBase {
+
+    private static final String ADDRESS = TelemetryConstants.TELEMETRY_ENDPOINT + "/" + TENANT_ID + "/" + DEVICE_ID;
+
+    /**
+     * Verifies that the message created by {@link TelemetrySender#send(String, byte[], String, Map)} conforms to the
+     * expectations of the AMQP adapter.
+     */
+    @Test
+    public void testSendCreatesValidMessage() {
+
+        // GIVEN a TelemetrySender instance
+        final TelemetrySender telemetrySender = createTelemetrySender();
+
+        // WHEN sending a message using the API
+        telemetrySender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);
+
+        // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
+        assertMessageConformsAmqpAdapterSpec(ADDRESS);
+
+    }
+
+    /**
+     * Verifies that the message created by {@link TelemetrySender#sendAndWaitForOutcome(String, byte[], String, Map)}
+     * conforms to the expectations of the AMQP adapter.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendAndWaitForOutcomeCreatesValidMessage(final VertxTestContext ctx) {
+
+        // GIVEN a TelemetrySender instance
+        final TelemetrySender telemetrySender = createTelemetrySender();
+
+        // WHEN sending a message using the API...
+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,
+                CONTENT_TYPE, APPLICATION_PROPERTIES);
+
+        // ...AND WHEN the disposition is updated by the peer
+        updateDisposition();
+
+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+            // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
+            ctx.verify(() -> assertMessageConformsAmqpAdapterSpec(ADDRESS));
+            ctx.completeNow();
+        }));
+    }
+
+    /**
+     * Verifies that the message created by {@link TelemetrySender#send(String, byte[], String, Map)} conforms to the
+     * expectations of the AMQP adapter.
+     */
+    @Test
+    public void testSendWithTracing() {
+
+        // GIVEN a TraceableTelemetrySender instance
+        final TraceableTelemetrySender telemetrySender = ((TraceableTelemetrySender) createTelemetrySender());
+
+        // WHEN sending a message using the API
+        final SpanContext spanContext = mock(SpanContext.class);
+        telemetrySender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES, spanContext);
+
+        // THEN the given SpanContext is used
+        verify(spanBuilder).addReference(any(), eq(spanContext));
+        assertMessageConformsAmqpAdapterSpec(ADDRESS);
+    }
+
+    /**
+     * Verifies that {@link TraceableTelemetrySender#sendAndWaitForOutcome(String, byte[], String, Map, SpanContext)}
+     * uses the given SpanContext.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendAndWaitForOutcomeWithTracing(final VertxTestContext ctx) {
+
+        // GIVEN a TraceableTelemetrySender instance
+        final TraceableTelemetrySender telemetrySender = ((TraceableTelemetrySender) createTelemetrySender());
+
+        // WHEN sending a message using the API...
+        final SpanContext spanContext = mock(SpanContext.class);
+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,
+                CONTENT_TYPE, APPLICATION_PROPERTIES, spanContext);
+
+        // ...AND WHEN the disposition is updated by the peer
+        updateDisposition();
+
+        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+            // THEN the given SpanContext is used
+            ctx.verify(() -> {
+                verify(spanBuilder).addReference(any(), eq(spanContext));
+                assertMessageConformsAmqpAdapterSpec(ADDRESS);
+            });
+            ctx.completeNow();
+        }));
+    }
+
+    /**
+     * Verifies that sending the message waits for the disposition update from the peer.
+     *
+     * @param ctx The test context to use for running asynchronous tests.
+     */
+    @Test
+    public void testSendAndWaitForOutcomeWaitsForDispositionUpdate(final VertxTestContext ctx) {
+
+        // GIVEN a TelemetrySender instance
+        final TelemetrySender telemetrySender = createTelemetrySender();
+
+        // WHEN sending a message using the API
+        final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,
+                CONTENT_TYPE, APPLICATION_PROPERTIES);
+
+        deliveryFuture.setHandler(ctx.completing());
+
+        // THEN the future waits for the disposition to be updated by the peer
+        assertThat(deliveryFuture.isComplete()).isFalse();
+        updateDisposition();
+    }
+
+    private TelemetrySender createTelemetrySender() {
+        return AmqpAdapterClientTelemetrySenderImpl.createWithAnonymousLinkAddress(connection, TENANT_ID, s -> {
+        }).result();
+    }
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumerTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumerTest.java
new file mode 100644
index 000000000..763a6ff1a
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/internal/AmqpAdapterClientCommandConsumerTest.java
@@ -0,0 +1,150 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.device.amqp.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.BiConsumer;
+
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.ReconnectListener;
+import org.eclipse.hono.client.impl.HonoClientUnitTestHelper;
+import org.eclipse.hono.client.impl.VertxMockSupport;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+import io.vertx.core.Future;
+import io.vertx.core.Vertx;
+import io.vertx.junit5.Timeout;
+import io.vertx.junit5.VertxExtension;
+import io.vertx.proton.ProtonMessageHandler;
+import io.vertx.proton.ProtonQoS;
+import io.vertx.proton.ProtonReceiver;
+
+/**
+ * Verifies behavior of {@link AmqpAdapterClientCommandConsumer}.
+ *
+ */
+@ExtendWith(VertxExtension.class)
+@Timeout(value = 10, timeUnit = TimeUnit.SECONDS)
+public class AmqpAdapterClientCommandConsumerTest {
+
+    private HonoConnection connection;
+    private ProtonReceiver originalReceiver;
+
+    /**
+     * Sets up fixture.
+     */
+    @BeforeEach
+    public void setUp() {
+
+        connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class));
+        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
+        originalReceiver = createNewProtonReceiver(connection);
+    }
+
+    /**
+     * Verifies that the creation of the command consumer succeeds.
+     */
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testCreateSucceeds() {
+
+        final Future<MessageConsumer> consumerFuture = AmqpAdapterClientCommandConsumer.create(connection,
+                mock(BiConsumer.class));
+
+        verify(connection).createReceiver(eq("command"), eq(ProtonQoS.AT_LEAST_ONCE), any(),
+                VertxMockSupport.anyHandler());
+
+        assertThat(consumerFuture.succeeded());
+        assertThat(consumerFuture.result()).isNotNull();
+    }
+
+    /**
+     * Verifies that the creation of the device-specific command consumer succeeds.
+     */
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testDeviceSpecificCreateSucceeds() {
+
+        final String tenantId = "testTenantId";
+        final String deviceId = "testDeviceId";
+        final Future<MessageConsumer> consumerFuture = AmqpAdapterClientCommandConsumer.create(connection, tenantId,
+                deviceId, mock(BiConsumer.class));
+
+        verify(connection).createReceiver(eq("command/" + tenantId + "/" + deviceId), eq(ProtonQoS.AT_LEAST_ONCE),
+                any(), VertxMockSupport.anyHandler());
+
+        assertThat(consumerFuture.succeeded());
+        assertThat(consumerFuture.result()).isNotNull();
+    }
+
+    /**
+     * Verifies that the proton receiver is recreated after a reconnect.
+     */
+    @Test
+    public void testReceiverIsRecreatedOnConnectionFailure() {
+
+        final AtomicReference<ReconnectListener<HonoConnection>> reconnectListener = new AtomicReference<>();
+        doAnswer(invocation -> {
+            reconnectListener.set(invocation.getArgument(0));
+            return null;
+        }).when(connection).addReconnectListener(any());
+
+        // GIVEN a connected command consumer
+        @SuppressWarnings("unchecked")
+        final Future<MessageConsumer> consumerFuture = AmqpAdapterClientCommandConsumer.create(connection,
+                mock(BiConsumer.class));
+
+        final AmqpAdapterClientCommandConsumer commandConsumer = (AmqpAdapterClientCommandConsumer) consumerFuture
+                .result();
+
+        // WHEN the connection is re-established
+        final ProtonReceiver newReceiver = createNewProtonReceiver(connection);
+
+        reconnectListener.get().onReconnect(null);
+
+        // THEN the receiver is recreated
+        verify(connection, times(2)).createReceiver(
+                eq("command"),
+                eq(ProtonQoS.AT_LEAST_ONCE),
+                any(ProtonMessageHandler.class),
+                VertxMockSupport.anyHandler());
+
+        final ProtonReceiver actual = commandConsumer.getReceiver();
+        assertThat(actual).isNotEqualTo(originalReceiver);
+        assertThat(actual).isEqualTo(newReceiver);
+
+    }
+
+    private ProtonReceiver createNewProtonReceiver(final HonoConnection honoConnectionMock) {
+        final ProtonReceiver receiver = mock(ProtonReceiver.class);
+        when(honoConnectionMock.createReceiver(any(), any(), any(), any()))
+                .thenReturn(Future.succeededFuture(receiver));
+        return receiver;
+    }
+
+}
