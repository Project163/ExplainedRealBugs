diff --git a/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java b/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
index 32fdd4d07..464e74240 100644
--- a/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
@@ -14,6 +14,7 @@
 
 package org.eclipse.hono.client;
 
+import org.eclipse.hono.cache.CacheProvider;
 import org.eclipse.hono.client.impl.CredentialsClientFactoryImpl;
 
 import io.vertx.core.Future;
@@ -32,7 +33,20 @@ public interface CredentialsClientFactory extends ConnectionLifecycle {
      * @throws NullPointerException if connection is {@code null}
      */
     static CredentialsClientFactory create(final HonoConnection connection) {
-        return new CredentialsClientFactoryImpl(connection);
+        return new CredentialsClientFactoryImpl(connection, null);
+    }
+
+    /**
+     * Creates a new factory for an existing connection.
+     *
+     * @param connection The connection to use.
+     * @param cacheProvider The cache provider to use for creating caches for credential objects
+     *                      or {@code null} if credential objects should not be cached.
+     * @return The factory.
+     * @throws NullPointerException if connection is {@code null}
+     */
+    static CredentialsClientFactory create(final HonoConnection connection, final CacheProvider cacheProvider) {
+        return new CredentialsClientFactoryImpl(connection, cacheProvider);
     }
 
     /**
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
index 43654fd46..f43f04c9b 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
@@ -16,6 +16,7 @@ package org.eclipse.hono.client.impl;
 
 import java.util.Objects;
 
+import org.eclipse.hono.cache.CacheProvider;
 import org.eclipse.hono.client.CredentialsClient;
 import org.eclipse.hono.client.CredentialsClientFactory;
 import org.eclipse.hono.client.HonoConnection;
@@ -31,15 +32,19 @@ import io.vertx.core.Future;
 public class CredentialsClientFactoryImpl extends AbstractHonoClientFactory implements CredentialsClientFactory {
 
     private final CachingClientFactory<CredentialsClient> credentialsClientFactory;
+    private final CacheProvider cacheProvider;
 
     /**
      * Creates a new factory for an existing connection.
-     * 
+     *
      * @param connection The connection to use.
+     * @param cacheProvider The cache provider to use for creating caches for credential objects
+     *                      or {@code null} if credentials objects should not be cached.
      */
-    public CredentialsClientFactoryImpl(final HonoConnection connection) {
+    public CredentialsClientFactoryImpl(final HonoConnection connection, final CacheProvider cacheProvider) {
         super(connection);
         credentialsClientFactory = new CachingClientFactory<>(c -> c.isOpen());
+        this.cacheProvider = cacheProvider;
     }
 
     /**
@@ -62,6 +67,7 @@ public class CredentialsClientFactoryImpl extends AbstractHonoClientFactory impl
             credentialsClientFactory.getOrCreateClient(
                     CredentialsClientImpl.getTargetAddress(tenantId),
                     () -> CredentialsClientImpl.create(
+                            cacheProvider,
                             connection,
                             tenantId,
                             this::removeCredentialsClient,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
index 163d3de42..b4598aba9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
@@ -18,7 +18,10 @@ import java.net.HttpURLConnection;
 import java.util.Objects;
 import java.util.UUID;
 
+import io.vertx.proton.ProtonReceiver;
+import io.vertx.proton.ProtonSender;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
+import org.eclipse.hono.cache.CacheProvider;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.CredentialsClient;
 import org.eclipse.hono.client.HonoConnection;
@@ -30,6 +33,7 @@ import org.eclipse.hono.util.CredentialsObject;
 import org.eclipse.hono.util.CredentialsResult;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RequestResponseApiConstants;
+import org.eclipse.hono.util.TriTuple;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -68,6 +72,19 @@ public class CredentialsClientImpl extends AbstractRequestResponseClient<Credent
         super(connection, tenantId);
     }
 
+    /**
+     * Creates a new client for accessing the Credentials service.
+     *
+     * @param connection The connection to Hono.
+     * @param tenantId The identifier of the tenant for which the client should be created.
+     * @param sender The AMQP link to use for sending requests to the service.
+     * @param receiver The AMQP link to use for receiving responses from the service.
+     */
+    CredentialsClientImpl(final HonoConnection connection, final String tenantId, final ProtonSender sender,
+            final ProtonReceiver receiver) {
+        super(connection, tenantId, sender, receiver);
+    }
+
     @Override
     protected final String getName() {
 
@@ -118,6 +135,8 @@ public class CredentialsClientImpl extends AbstractRequestResponseClient<Credent
     /**
      * Creates a new credentials client for a tenant.
      *
+     * @param cacheProvider The cache provider to use for creating caches for credential objects
+     *                      or {@code null} if credential objects should not be cached.
      * @param con The connection to the server.
      * @param tenantId The tenant for which credentials are handled.
      * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
@@ -126,6 +145,7 @@ public class CredentialsClientImpl extends AbstractRequestResponseClient<Credent
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
     public static final Future<CredentialsClient> create(
+            final CacheProvider cacheProvider,
             final HonoConnection con,
             final String tenantId,
             final Handler<String> senderCloseHook,
@@ -133,6 +153,9 @@ public class CredentialsClientImpl extends AbstractRequestResponseClient<Credent
 
         LOG.debug("creating new credentials client for [{}]", tenantId);
         final CredentialsClientImpl client = new CredentialsClientImpl(con, tenantId);
+        if (cacheProvider != null) {
+            client.setResponseCache(cacheProvider.getCache(CredentialsClientImpl.getTargetAddress(tenantId)));
+        }
         return client.createLinks(senderCloseHook, receiverCloseHook)
                 .map(ok -> {
                     LOG.debug("successfully created credentials client for [{}]", tenantId);
@@ -174,28 +197,35 @@ public class CredentialsClientImpl extends AbstractRequestResponseClient<Credent
 
         Objects.requireNonNull(type);
         Objects.requireNonNull(authId);
+        Objects.requireNonNull(clientContext);
 
         final Future<CredentialsResult<CredentialsObject>> responseTracker = Future.future();
         final JsonObject specification = new JsonObject()
                 .put(CredentialsConstants.FIELD_TYPE, type)
                 .put(CredentialsConstants.FIELD_AUTH_ID, authId)
                 .mergeIn(clientContext);
+        final TriTuple<CredentialsConstants.CredentialsAction, String, Integer> key = TriTuple
+                .of(CredentialsConstants.CredentialsAction.get, String.format("%s-%s", type, authId), clientContext.hashCode());
 
         final Span span = newChildSpan(spanContext, "get Credentials");
         span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, getTenantId());
         span.setTag(TAG_CREDENTIALS_TYPE, type);
         span.setTag(TAG_AUTH_ID, authId);
 
-        createAndSendRequest(
-                CredentialsConstants.CredentialsAction.get.toString(),
-                null,
-                specification.toBuffer(),
-                RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
-                responseTracker,
-                null,
-                span);
 
-        return responseTracker.recover(t -> {
+        TracingHelper.TAG_CACHE_HIT.set(span, true);
+        return getResponseFromCache(key).recover(cacheMiss -> {
+            TracingHelper.TAG_CACHE_HIT.set(span, false);
+            createAndSendRequest(
+                    CredentialsConstants.CredentialsAction.get.toString(),
+                    null,
+                    specification.toBuffer(),
+                    RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
+                    responseTracker,
+                    key,
+                    span);
+            return responseTracker;
+        }).recover(t -> {
             TracingHelper.logError(span, t);
             span.finish();
             return Future.failedFuture(t);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
new file mode 100644
index 000000000..38725a116
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
@@ -0,0 +1,278 @@
+/*******************************************************************************
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+package org.eclipse.hono.client.impl;
+
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.tag.Tags;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.core.json.JsonObject;
+import io.vertx.ext.unit.Async;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonSender;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.cache.ExpiringValueCache;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.RequestResponseClientConfigProperties;
+import org.eclipse.hono.client.ServiceInvocationException;
+import org.eclipse.hono.util.CacheDirective;
+import org.eclipse.hono.util.CredentialsConstants;
+import org.eclipse.hono.util.CredentialsObject;
+import org.eclipse.hono.util.CredentialsResult;
+import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RequestResponseApiConstants;
+import org.eclipse.hono.util.TriTuple;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.Timeout;
+import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
+
+import java.net.HttpURLConnection;
+import java.time.Duration;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+/**
+ * Tests verifying behavior of {@link CredentialsClientImpl}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class CredentialsClientImplTest {
+
+    /**
+     * Time out test cases after 5 seconds.
+     */
+    @Rule
+    public Timeout globalTimeout = Timeout.seconds(5);
+
+    private ProtonSender sender;
+    private CredentialsClientImpl client;
+    private ExpiringValueCache<Object, CredentialsResult<CredentialsObject>> cache;
+    private Tracer tracer;
+    private Span span;
+
+    /**
+     * Sets up the fixture.
+     */
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+
+        final SpanContext spanContext = mock(SpanContext.class);
+
+        span = mock(Span.class);
+        when(span.context()).thenReturn(spanContext);
+        final Tracer.SpanBuilder spanBuilder = HonoClientUnitTestHelper.mockSpanBuilder(span);
+
+        tracer = mock(Tracer.class);
+        when(tracer.buildSpan(anyString())).thenReturn(spanBuilder);
+
+        final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(mock(Vertx.class),
+                new RequestResponseClientConfigProperties());
+        when(connection.getTracer()).thenReturn(tracer);
+
+        sender = HonoClientUnitTestHelper.mockProtonSender();
+        cache = mock(ExpiringValueCache.class);
+        client = new CredentialsClientImpl(connection, "tenant", sender, HonoClientUnitTestHelper.mockProtonReceiver());
+    }
+
+    /**
+     * Verifies that the client retrieves credentials from the Device Registration service if no cache is configured.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testGetCredentialsInvokesServiceIfNoCacheConfigured(final TestContext ctx) {
+
+        final String authId = "test-auth";
+        final String credentialsType = CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD;
+        final JsonObject credentialsObject = newCredentialsResult("device", authId);
+        final Message response = ProtonHelper.message(credentialsObject.encode());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
+
+        // WHEN getting credential information information
+        final Async assertion = ctx.async();
+        client.get(credentialsType, authId).setHandler(ctx.asyncAssertSuccess(result -> assertion.complete()));
+
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        final Message sentMessage = messageCaptor.getValue();
+        client.handleResponse(delivery, response);
+
+        // THEN the credentials has been retrieved from the service
+        assertion.await();
+        // and not been put to the cache
+        verify(cache, never()).put(any(), any(CredentialsResult.class), any(Duration.class));
+        // and the span is finished
+        verify(span).finish();
+
+        assertEquals(sentMessage.getSubject(), CredentialsConstants.CredentialsAction.get.toString());
+        assertEquals(MessageHelper.getJsonPayload(sentMessage).getString(CredentialsConstants.FIELD_TYPE),
+                credentialsType);
+        assertEquals(MessageHelper.getJsonPayload(sentMessage).getString(CredentialsConstants.FIELD_AUTH_ID), authId);
+    }
+
+    /**
+     * Verifies that on a cache miss the adapter retrieves credentials information from the credentials service and puts
+     * it to the cache.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testGetCredentialsAddsResponseToCacheOnCacheMiss(final TestContext ctx) {
+
+        final String authId = "test-auth";
+        final String credentialsType = CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD;
+
+        // GIVEN an adapter with an empty cache
+        client.setResponseCache(cache);
+        final JsonObject credentialsObject = newCredentialsResult("device", authId);
+        final JsonObject clientContext = new JsonObject();
+
+        // WHEN getting credentials information
+        final Async get = ctx.async();
+        client.get(credentialsType, authId, clientContext)
+                .setHandler(ctx.asyncAssertSuccess(tenant -> get.complete()));
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        final ProtonDelivery delivery = mock(ProtonDelivery.class);
+        verify(client.sender).send(messageCaptor.capture(), any(Handler.class));
+
+        final Message response = ProtonHelper.message(credentialsObject.encode());
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
+        response.setCorrelationId(messageCaptor.getValue().getMessageId());
+        client.handleResponse(delivery, response);
+
+        // THEN the credentials result has been added to the cache.
+        get.await();
+        verify(cache).put(
+                eq(TriTuple.of(CredentialsConstants.CredentialsAction.get,
+                        String.format("%s-%s", credentialsType, authId), clientContext.hashCode())),
+                any(CredentialsResult.class), any(Duration.class));
+        // and the span is finished
+        verify(span).finish();
+    }
+
+    /**
+     * Verifies that credentials is taken from cache, if cache is configured and the cache has this credentials cached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testGetCredentialsReturnsValueFromCache(final TestContext ctx) {
+
+        final String authId = "test-auth";
+        final String credentialsType = CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD;
+
+        // GIVEN a client with a cache containing a credentials
+        client.setResponseCache(cache);
+        final JsonObject credentialsObject = newCredentialsResult("device", authId);
+        final CredentialsResult<CredentialsObject> credentialsResult = client
+                .getResult(HttpURLConnection.HTTP_OK, RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
+                        credentialsObject.toBuffer(), null, null);
+        when(cache.get(any(TriTuple.class))).thenReturn(credentialsResult);
+
+        // WHEN getting credentials
+        client.get(credentialsType, authId)
+                .setHandler(ctx.asyncAssertSuccess(result -> {
+                    // THEN the credentials is read from the cache
+                    ctx.assertEquals(credentialsResult.getPayload(), result);
+                    verify(sender, never()).send(any(Message.class), any(Handler.class));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+
+    }
+
+    /**
+     * Verifies that the client fails if the credentials service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetCredentialsFailsWithSendError(final TestContext ctx) {
+
+        // GIVEN a client with no credit left
+        when(sender.sendQueueFull()).thenReturn(true);
+
+        // WHEN getting credentials
+        client.get(CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD, "test-auth")
+                .setHandler(ctx.asyncAssertFailure(t -> {
+                    // THEN the invocation fails and the span is marked as erroneous
+                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+    }
+
+    /**
+     * Verifies that the client fails if the credentials service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testGetCredentialsFailsWithRejectedRequest(final TestContext ctx) {
+
+        // GIVEN a client with no credit left
+        final ProtonDelivery update = mock(ProtonDelivery.class);
+        when(update.getRemoteState()).thenReturn(new Rejected());
+        when(update.remotelySettled()).thenReturn(true);
+        when(sender.send(any(Message.class), any(Handler.class))).thenAnswer(invocation -> {
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(update);
+            return mock(ProtonDelivery.class);
+        });
+
+        // WHEN getting credentials
+        client.get(CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD, "test-auth")
+                .setHandler(ctx.asyncAssertFailure(t -> {
+                    ctx.assertEquals(HttpURLConnection.HTTP_BAD_REQUEST,
+                            ((ServiceInvocationException) t).getErrorCode());
+                    // THEN the invocation fails and the span is marked as erroneous
+                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                    // and the span is finished
+                    verify(span).finish();
+                }));
+    }
+
+    private JsonObject newCredentialsResult(final String deviceId, final String authId) {
+        return JsonObject.mapFrom(CredentialsObject.fromHashedPassword(
+                deviceId,
+                authId,
+                "$2a$11$gYh52ApJeJcLvKrXHkGm5.xtLf7PVJySmXrt0EvFfLjCfLdIdvoay",
+                CredentialsConstants.HASH_FUNCTION_BCRYPT,
+                null, null, null));
+    }
+}
