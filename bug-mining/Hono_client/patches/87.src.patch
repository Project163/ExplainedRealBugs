diff --git a/client/src/main/java/org/eclipse/hono/client/MessageSender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
index 7284ac5c8..741b6cc09 100644
--- a/client/src/main/java/org/eclipse/hono/client/MessageSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
@@ -122,10 +122,28 @@ public interface MessageSender {
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will be succeeded if the message has been sent to the endpoint.
-     *         The delivery contained in the future represents the delivery state at the time
-     *         the future has been succeeded, i.e. for telemetry data it will be locally
-     *         <em>unsettled</em> without any outcome yet. For events it will be locally
-     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         The delivery will be locally settled only, if the implementing class
+     *         uses <em>at most once</em> delivery semantics. Otherwise, the the delivery
+     *         will be settled locally and remotely (<em>at least once</em> semantics).
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit. It will be failed with either a
+     *         {@code ServerErrorException} or a {@link ClientErrorException}
+     *         if the message could not be processed and the implementing class uses
+     *         <em>at least once</em> delivery semantics.
+     * @throws NullPointerException if the message is {@code null}.
+     */
+    Future<ProtonDelivery> send(Message message);
+
+    /**
+     * Sends an AMQP 1.0 message to the peer and waits for the disposition indicating
+     * the outcome of the transfer.
+     * 
+     * @param message The message to send.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been accepted (and settled)
+     *         by the peer.
      *         <p>
      *         The future will be failed with a {@link ServerErrorException} if the message
      *         could not be sent due to a lack of credit.
@@ -134,7 +152,7 @@ public interface MessageSender {
      *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if the message is {@code null}.
      */
-    Future<ProtonDelivery> send(Message message);
+    Future<ProtonDelivery> sendAndWaitForOutcome(Message message);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 2b6f07c3f..7f20a24fa 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -21,12 +21,16 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.apache.qpid.proton.amqp.Binary;
+import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Data;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
@@ -49,6 +53,11 @@ import io.vertx.proton.ProtonSender;
  */
 abstract class AbstractSender extends AbstractHonoClient implements MessageSender {
 
+    /**
+     * A counter to be used for creating message IDs.
+     */
+    protected static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
+
     private static final Pattern CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
 
     /**
@@ -311,4 +320,55 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     public final boolean isRegistrationAssertionRequired() {
         return registrationAssertionRequired;
     }
+
+    /**
+     * Sends an AMQP 1.0 message to the peer this client is configured for
+     * and waits for the outcome of the transfer.
+     * 
+     * @param message The message to send.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled)
+     *         by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent or has not been accepted by the peer.
+     * @throws NullPointerException if the message is {@code null}.
+     */
+    protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message) {
+
+        Objects.requireNonNull(message);
+
+        final Future<ProtonDelivery> result = Future.future();
+        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
+        message.setMessageId(messageId);
+        sender.send(message, deliveryUpdated -> {
+            if (deliveryUpdated.remotelySettled()) {
+                if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    LOG.trace("message [ID: {}] accepted by peer", messageId);
+                    result.complete(deliveryUpdated);
+                } else if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
+                    if (rejected.getError() == null) {
+                        LOG.debug("message [message ID: {}] rejected by peer", messageId);
+                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                    } else {
+                        LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
+                                rejected.getError().getCondition(), rejected.getError().getDescription());
+                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription()));
+                    }
+                } else {
+                    LOG.debug("message [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
+                    result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                }
+            } else {
+                LOG.warn("peer did not settle message, failing delivery [new remote state: {}]", deliveryUpdated.getRemoteState());
+                result.fail(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
+            }
+        });
+        LOG.trace("sent message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
+
+        return result;
+    }
+
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index 8907d537e..fb35ddd15 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -14,16 +14,11 @@
 
 package org.eclipse.hono.client.impl;
 
-import java.net.HttpURLConnection;
 import java.util.Objects;
-import java.util.concurrent.atomic.AtomicLong;
 
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
-import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.EventConstants;
 
@@ -41,8 +36,6 @@ import io.vertx.proton.ProtonSender;
  */
 public final class EventSenderImpl extends AbstractSender {
 
-    private static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
-
     EventSenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
             final String targetAddress, final Context context) {
         super(config, sender, tenantId, targetAddress, context);
@@ -120,41 +113,47 @@ public final class EventSenderImpl extends AbstractSender {
         msg.setDurable(true);
     }
 
+    /**
+     * Sends an AMQP 1.0 message to the peer this client is configured for
+     * and waits for the outcome of the transfer.
+     * <p>
+     * This method simply invokes {@link #sendMessageAndWaitForOutcome(Message)}.
+     * 
+     * @param message The message to send.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled)
+     *         by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent or has not been accepted by the peer.
+     * @throws NullPointerException if the message is {@code null}.
+     */
     @Override
     protected Future<ProtonDelivery> sendMessage(final Message message) {
 
-        Objects.requireNonNull(message);
-
-        final Future<ProtonDelivery> result = Future.future();
-        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
-        message.setMessageId(messageId);
-        sender.send(message, deliveryUpdated -> {
-            if (deliveryUpdated.remotelySettled()) {
-                if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
-                    LOG.trace("event [message ID: {}] accepted by peer", messageId);
-                    result.complete(deliveryUpdated);
-                } else if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
-                    Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
-                    if (rejected.getError() == null) {
-                        LOG.debug("event [message ID: {}] rejected by peer", messageId);
-                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
-                    } else {
-                        LOG.debug("event [message ID: {}] rejected by peer: {}, {}", messageId,
-                                rejected.getError().getCondition(), rejected.getError().getDescription());
-                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription()));
-                    }
-                } else {
-                    LOG.debug("event [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
-                    result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
-                }
-            } else {
-                LOG.warn("peer did not settle event, failing delivery [new remote state: {}]", deliveryUpdated.getRemoteState());
-                result.fail(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
-            }
-        });
-        LOG.trace("sent event [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
-
-        return result;
+        return sendMessageAndWaitForOutcome(message);
     }
 
+    /**
+     * Sends an AMQP 1.0 message to the peer this client is configured for
+     * and waits for the outcome of the transfer.
+     * <p>
+     * This method simply invokes {@link #sendMessageAndWaitForOutcome(Message)}.
+     * 
+     * @param message The message to send.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been accepted (and settled)
+     *         by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent or has not been accepted by the peer.
+     * @throws NullPointerException if the message is {@code null}.
+     */
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(Message message) {
+
+        return sendMessageAndWaitForOutcome(message);
+    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index 2e43c826f..bfd0ca1b4 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -13,14 +13,17 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.net.HttpURLConnection;
 import java.util.Objects;
-import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.TelemetryConstants;
 
 import io.vertx.core.AsyncResult;
@@ -37,8 +40,6 @@ import io.vertx.proton.ProtonSender;
  */
 public final class TelemetrySenderImpl extends AbstractSender {
 
-    private static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
-
     TelemetrySenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
             final String targetAddress, final Context context) {
         super(config, sender, tenantId, targetAddress, context);
@@ -109,6 +110,43 @@ public final class TelemetrySenderImpl extends AbstractSender {
         }).setHandler(creationHandler);
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<ProtonDelivery> sendAndWaitForOutcome(final Message rawMessage) {
+
+        Objects.requireNonNull(rawMessage);
+
+        if (!isRegistrationAssertionRequired()) {
+            MessageHelper.getAndRemoveRegistrationAssertion(rawMessage);
+        }
+        final Future<ProtonDelivery> result = Future.future();
+        context.runOnContext(send -> {
+            if (sender.sendQueueFull()) {
+                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available"));
+            } else {
+                sendMessageAndWaitForOutcome(rawMessage).setHandler(result.completer());
+            }
+        });
+        return result;
+    }
+
+    /**
+     * Sends an AMQP 1.0 message to the peer this client is configured for.
+     * 
+     * @param message The message to send.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will succeed if the message has been sent to the peer.
+     *         The delivery contained in the future will represent the delivery
+     *         state at the time the future has been succeeded, i.e. it will be
+     *         locally <em>unsettled</em> without any outcome yet.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent.
+     * @throws NullPointerException if the message is {@code null}.
+     */
     @Override
     protected Future<ProtonDelivery> sendMessage(final Message message) {
 
@@ -132,10 +170,10 @@ public final class TelemetrySenderImpl extends AbstractSender {
                     LOG.debug("message [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
                 }
             } else {
-                LOG.warn("peer did not settle telemetry message [message ID: {}, remote state: {}]", messageId, deliveryUpdated.getRemoteState());
+                LOG.warn("peer did not settle message [message ID: {}, remote state: {}]", messageId, deliveryUpdated.getRemoteState());
             }
         });
-        LOG.trace("sent telemetry message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
+        LOG.trace("sent message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
 
         return Future.succeededFuture(result);
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
index 8509d7873..a72fbac0b 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
@@ -141,6 +141,15 @@ public class AbstractSenderTest {
                 return Future.succeededFuture(mock(ProtonDelivery.class));
             }
 
+            /**
+             * @return an incomplete future.
+             */
+            @Override
+            public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
+                protonSender.send(message);
+                return Future.future();
+            }
+
             @Override
             protected String getTo(final String deviceId) {
                 return null;
