diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 26f55c3d3..e50fce771 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -11,7 +11,10 @@
  */
 package org.eclipse.hono.client.impl;
 
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Objects;
@@ -49,6 +52,7 @@ public final class HonoClientImpl implements HonoClient {
     private final Map<String, MessageSender> activeSenders = new ConcurrentHashMap<>();
     private final Map<String, RegistrationClient> activeRegClients = new ConcurrentHashMap<>();
     private final Map<String, Boolean> senderCreationLocks = new ConcurrentHashMap<>();
+    private final List<Handler<Void>> creationRequests = new ArrayList<>();
     private final AtomicBoolean connecting = new AtomicBoolean(false);
     private ProtonClientOptions clientOptions;
     private ProtonConnection connection;
@@ -196,16 +200,30 @@ public final class HonoClientImpl implements HonoClient {
 
     private void onRemoteDisconnect(final ProtonConnection con) {
 
-        LOG.warn("lost connection to Hono server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
-        con.disconnect();
-        activeSenders.clear();
-        activeRegClients.clear();
-        if (clientOptions.getReconnectAttempts() != 0) {
-            // give Vert.x some time to clean up NetClient
-            vertx.setTimer(300, reconnect -> {
-                LOG.info("attempting to re-connect to Hono server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
-                connect(clientOptions, done -> {});
-            });
+        if (con != connection) {
+            LOG.warn("cannot handle failure of unknown connection");
+        } else {
+            LOG.warn("lost connection to Hono server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+            connection.disconnect();
+            activeSenders.clear();
+            activeRegClients.clear();
+            failAllCreationRequests();
+            connection = null;
+            if (clientOptions.getReconnectAttempts() != 0) {
+                // give Vert.x some time to clean up NetClient
+                vertx.setTimer(300, reconnect -> {
+                    LOG.info("attempting to re-connect to Hono server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+                    connect(clientOptions, done -> {});
+                });
+            }
+        }
+    }
+
+    private void failAllCreationRequests() {
+
+        for (Iterator<Handler<Void>> iter = creationRequests.iterator(); iter.hasNext(); ) {
+            iter.next().handle(null);
+            iter.remove();
         }
     }
 
@@ -264,6 +282,13 @@ public final class HonoClientImpl implements HonoClient {
             LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
             resultHandler.handle(Future.succeededFuture(sender));
         } else if (!senderCreationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
+
+            // register a handler to be notified if the underlying connection to the server fails
+            // so that we can fail the result handler passed in
+            final Handler<Void> connectionFailureHandler = connectionLost -> {
+                resultHandler.handle(Future.failedFuture("connection to server lost"));
+            };
+            creationRequests.add(connectionFailureHandler);
             senderCreationLocks.put(key, Boolean.TRUE);
             LOG.debug("creating new message sender for {}", key);
 
@@ -277,6 +302,7 @@ public final class HonoClientImpl implements HonoClient {
                     activeSenders.remove(key);
                 }
                 senderCreationLocks.remove(key);
+                creationRequests.remove(connectionFailureHandler);
                 resultHandler.handle(creationAttempt);
             });
 
@@ -312,8 +338,18 @@ public final class HonoClientImpl implements HonoClient {
             final Consumer<Message> telemetryConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
+        // register a handler to be notified if the underlying connection to the server fails
+        // so that we can fail the result handler passed in
+        final Handler<Void> connectionFailureHandler = connectionLost -> {
+            creationHandler.handle(Future.failedFuture("connection to server lost"));
+        };
+        creationRequests.add(connectionFailureHandler);
+
         Future<MessageConsumer> consumerTracker = Future.future();
-        consumerTracker.setHandler(creationHandler);
+        consumerTracker.setHandler(attempt -> {
+            creationRequests.remove(connectionFailureHandler);
+            creationHandler.handle(attempt);
+        });
         checkConnection().compose(
                 connected -> TelemetryConsumerImpl.create(context, connection, tenantId, connectionFactory.getPathSeparator(), telemetryConsumer, consumerTracker.completer()),
                 consumerTracker);
@@ -329,8 +365,18 @@ public final class HonoClientImpl implements HonoClient {
             final Consumer<Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
+        // register a handler to be notified if the underlying connection to the server fails
+        // so that we can fail the result handler passed in
+        final Handler<Void> connectionFailureHandler = connectionLost -> {
+            creationHandler.handle(Future.failedFuture("connection to server lost"));
+        };
+        creationRequests.add(connectionFailureHandler);
+
         Future<MessageConsumer> consumerTracker = Future.future();
-        consumerTracker.setHandler(creationHandler);
+        consumerTracker.setHandler(attempt -> {
+            creationRequests.remove(connectionFailureHandler);
+            creationHandler.handle(attempt);
+        });
         checkConnection().compose(
                 connected -> EventConsumerImpl.create(context, connection, tenantId, connectionFactory.getPathSeparator(), eventConsumer, consumerTracker.completer()),
                 consumerTracker);
@@ -354,11 +400,11 @@ public final class HonoClientImpl implements HonoClient {
         return this;
     }
 
-    private <T> Future<T> checkConnection() {
+    private Future<ProtonConnection> checkConnection() {
         if (connection == null || connection.isDisconnected()) {
             return Future.failedFuture("client is not connected to Hono (yet)");
         } else {
-            return Future.succeededFuture();
+            return Future.succeededFuture(connection);
         }
     }
 
@@ -392,16 +438,23 @@ public final class HonoClientImpl implements HonoClient {
         if (connection == null || connection.isDisconnected()) {
             creationHandler.handle(Future.failedFuture("client is not connected to Hono (yet)"));
         } else {
+            // register a handler to be notified if the underlying connection to the server fails
+            // so that we can fail the result handler passed in
+            final Handler<Void> connectionFailureHandler = connectionLost -> {
+                creationHandler.handle(Future.failedFuture("connection to server lost"));
+            };
+            creationRequests.add(connectionFailureHandler);
+
             LOG.debug("creating new registration client for [{}]", tenantId);
             RegistrationClientImpl.create(context, connection, tenantId, creationAttempt -> {
                 if (creationAttempt.succeeded()) {
                     activeRegClients.put(tenantId, creationAttempt.result());
                     LOG.debug("successfully created registration client for [{}]", tenantId);
-                    creationHandler.handle(Future.succeededFuture(creationAttempt.result()));
                 } else {
                     LOG.debug("failed to create registration client for [{}]", tenantId, creationAttempt.cause());
-                    creationHandler.handle(Future.failedFuture(creationAttempt.cause()));
                 }
+                creationRequests.remove(connectionFailureHandler);
+                creationHandler.handle(creationAttempt);
             });
         }
         return this;
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 35ef0fc8e..ebb242388 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -12,20 +12,30 @@
 
 package org.eclipse.hono.client.impl;
 
+import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
 
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.connection.ConnectionFactory;
+import org.eclipse.hono.util.Constants;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
+import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
+import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
 import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonClientOptions;
+import io.vertx.proton.ProtonConnection;
 
 /**
  * Test cases verifying the behavior of {@code HonoClient}.
@@ -87,4 +97,184 @@ public class HonoClientImplTest {
         // succeed first creation attempt, thus invoking result handler
         firstSenderTracker.complete(mock(MessageSender.class));
     }
+
+    /**
+     * Verifies that a request to create a message sender is failed immediately when the
+     * underlying connection to the server fails.
+     * 
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testGetOrCreateSenderFailsOnConnectionFailure(final TestContext ctx) {
+
+        // GIVEN a client that already tries to create a telemetry sender for "tenant"
+        ProtonConnection con = mock(ProtonConnection.class);
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
+        final Async connected = ctx.async();
+        final Async disconnected = ctx.async();
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await(200);
+
+        client.getOrCreateSender("telemetry/tenant", creationResultHandler -> {
+            ctx.assertFalse(disconnected.isCompleted());
+        }, ctx.asyncAssertFailure(cause -> {
+            disconnected.complete();
+        }));
+
+        // WHEN the underyling connection fails
+        connectionFactory.getDisconnectHandler().handle(con);
+
+        // THEN all creation requests are failed
+        disconnected.await(200);
+    }
+
+    /**
+     * Verifies that a request to create a telemetry consumer is failed immediately when the
+     * underlying connection to the server fails.
+     * 
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testCreateTelemetryConsumerFailsOnConnectionFailure(final TestContext ctx) {
+
+        // GIVEN a client that already tries to create a telemetry sender for "tenant"
+        ProtonConnection con = mock(ProtonConnection.class);
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
+        final Async connected = ctx.async();
+        final Async disconnected = ctx.async();
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await(200);
+
+        client.createTelemetryConsumer("tenant", msg -> {}, ctx.asyncAssertFailure(cause -> {
+            disconnected.complete();
+        }));
+
+        // WHEN the underyling connection fails
+        connectionFactory.getDisconnectHandler().handle(con);
+
+        // THEN all creation requests are failed
+        disconnected.await(200);
+    }
+
+    /**
+     * Verifies that a request to create an event consumer is failed immediately when the
+     * underlying connection to the server fails.
+     * 
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testCreateEventConsumerFailsOnConnectionFailure(final TestContext ctx) {
+
+        // GIVEN a client that already tries to create a telemetry sender for "tenant"
+        ProtonConnection con = mock(ProtonConnection.class);
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
+        final Async connected = ctx.async();
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await(200);
+
+        final Async disconnected = ctx.async();
+        client.createEventConsumer("tenant", msg -> {}, ctx.asyncAssertFailure(cause -> {
+            disconnected.complete();
+        }));
+
+        // WHEN the underyling connection fails
+        connectionFactory.getDisconnectHandler().handle(con);
+
+        // THEN all creation requests are failed
+        disconnected.await(200);
+    }
+
+    /**
+     * Verifies that the client tries to re-establish a lost connection to a server.
+     * 
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testDownstreamDisconnectTriggersReconnect(final TestContext ctx) {
+
+        final ProtonConnection connectionToCreate = mock(ProtonConnection.class);
+        when(connectionToCreate.getRemoteContainer()).thenReturn("server");
+        // expect the connection factory to be invoked twice
+        // first on initial connection
+        // second on re-connect attempt
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(connectionToCreate, 2);
+
+        // GIVEN an client connected to a server
+        final Async connected = ctx.async();
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        client.connect(new ProtonClientOptions().setReconnectAttempts(1), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await(200);
+
+        // WHEN the downstream connection fails
+        connectionFactory.getDisconnectHandler().handle(connectionToCreate);
+
+        // THEN the adapter tries to reconnect to the downstream container
+        connectionFactory.await(1, TimeUnit.SECONDS);
+        assertTrue(client.isConnected());
+    }
+
+    private class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {
+
+        private Handler<ProtonConnection> disconnectHandler;
+        private CountDownLatch expectedConnectionAttemps;
+        private ProtonConnection connectionToCreate;
+
+        public DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
+            this(conToCreate, 1);
+        }
+
+        public DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate, final int expectedConnectionAttempts) {
+            this.connectionToCreate = conToCreate;
+            this.expectedConnectionAttemps = new CountDownLatch(expectedConnectionAttempts);
+        }
+
+        @Override
+        public void connect(
+                final ProtonClientOptions options,
+                final Handler<AsyncResult<ProtonConnection>> closeHandler,
+                final Handler<ProtonConnection> disconnectHandler,
+                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+
+            expectedConnectionAttemps.countDown();
+            this.disconnectHandler = disconnectHandler;
+            connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
+        }
+
+        @Override
+        public String getName() {
+            return "client";
+        }
+
+        @Override
+        public String getHost() {
+            return "server";
+        }
+
+        @Override
+        public int getPort() {
+            return 5672;
+        }
+
+        @Override
+        public String getPathSeparator() {
+            return Constants.DEFAULT_PATH_SEPARATOR;
+        }
+
+        public Handler<ProtonConnection> getDisconnectHandler() {
+            return disconnectHandler;
+        }
+
+        public boolean await(long timeout, TimeUnit unit) {
+            try {
+                return expectedConnectionAttemps.await(timeout, unit);
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+                return false;
+            }
+        }
+    }
+
 }
