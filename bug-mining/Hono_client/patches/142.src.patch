diff --git a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
index 1f49fc18c..e77d532f0 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
@@ -71,8 +71,7 @@ import io.vertx.proton.ProtonSender;
  */
 public interface HonoConnection extends ConnectionLifecycle,
                                     ApplicationClientFactory,
-                                    CredentialsClientFactory,
-                                    RegistrationClientFactory {
+                                    CredentialsClientFactory {
 
     /**
      * Creates a new connection using the default implementation.
diff --git a/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
index 16e148bad..b23ce585d 100644
--- a/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
@@ -14,6 +14,9 @@
 
 package org.eclipse.hono.client;
 
+import org.eclipse.hono.cache.CacheProvider;
+import org.eclipse.hono.client.impl.RegistrationClientFactoryImpl;
+
 import io.vertx.core.Future;
 
 /**
@@ -22,6 +25,30 @@ import io.vertx.core.Future;
  */
 public interface RegistrationClientFactory extends ConnectionLifecycle {
 
+    /**
+     * Creates a new factory for an existing connection.
+     *
+     * @param connection The connection to use.
+     * @return The factory.
+     * @throws NullPointerException if connection is {@code null}
+     */
+    static RegistrationClientFactory create(final HonoConnection connection) {
+        return new RegistrationClientFactoryImpl(connection, null);
+    }
+
+    /**
+     * Creates a new factory for an existing connection.
+     *
+     * @param connection The connection to use.
+     * @param cacheProvider The cache provider to use for creating caches for tenant objects
+     *                      or {@code null} if tenant objects should not be cached.
+     * @return The factory.
+     * @throws NullPointerException if connection is {@code null}
+     */
+    static RegistrationClientFactory create(final HonoConnection connection, final CacheProvider cacheProvider) {
+        return new RegistrationClientFactoryImpl(connection, cacheProvider);
+    }
+
     /**
      * Gets a client for invoking operations on a service implementing Hono's <em>Device Registration</em> API.
      *
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index 6a27f5876..df12dd586 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -36,7 +36,6 @@ import javax.security.sasl.AuthenticationException;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.cache.CacheProvider;
 import org.eclipse.hono.client.AsyncCommandClient;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.CommandClient;
@@ -46,7 +45,6 @@ import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.ReconnectListener;
-import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
@@ -132,7 +130,6 @@ public class HonoConnectionImpl implements HonoConnection {
     private final Object connectionLock = new Object();
 
     private ProtonClientOptions clientOptions;
-    private CacheProvider cacheProvider;
     private AtomicInteger connectAttempts;
     private List<Symbol> offeredCapabilities = Collections.emptyList();
     private Tracer tracer = NoopTracerFactory.create();
@@ -181,16 +178,6 @@ public class HonoConnectionImpl implements HonoConnection {
         this.connectAttempts = new AtomicInteger(0);
     }
 
-    /**
-     * Sets a provider for creating cache instances to be used in Hono clients.
-     *
-     * @param cacheProvider The cache provider.
-     * @throws NullPointerException if manager is {@code null}.
-     */
-    public final void setCacheProvider(final CacheProvider cacheProvider) {
-        this.cacheProvider = Objects.requireNonNull(cacheProvider);
-    }
-
     /**
      * {@inheritDoc}
      */
@@ -884,61 +871,6 @@ public class HonoConnectionImpl implements HonoConnection {
         }
     }
 
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<RegistrationClient> getOrCreateRegistrationClient(
-            final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-
-        return getOrCreateRequestResponseClient(
-                RegistrationClientImpl.getTargetAddress(tenantId),
-                () -> newRegistrationClient(tenantId)).map(c -> (RegistrationClient) c);
-    }
-
-    /**
-     * Creates a new instance of {@link RegistrationClient} scoped for the given tenantId.
-     * <p>
-     * Custom implementation of {@link RegistrationClient} can be instantiated by overriding this method. Any such
-     * instance should be scoped to the given tenantId. Custom extension of {@link HonoConnectionImpl} must invoke
-     * {@link #removeRegistrationClient(String)} to cleanup when finished with the client.
-     *
-     * @param tenantId tenant scope for which the client is instantiated
-     * @return a future containing an instance of {@link RegistrationClient}
-     * @see RegistrationClient
-     */
-    protected Future<RequestResponseClient> newRegistrationClient(final String tenantId) {
-
-        Objects.requireNonNull(tenantId);
-
-        return checkConnected().compose(connected -> {
-
-            return RegistrationClientImpl.create(
-                    cacheProvider,
-                    this,
-                    tenantId,
-                    this::removeRegistrationClient,
-                    this::removeRegistrationClient)
-            .map(client -> (RequestResponseClient) client);
-        });
-    }
-
-    /**
-     * Removes a registration client from the list of active clients.
-     * <p>
-     * Once a client has been removed, the next invocation of the corresponding <em>getOrCreateRegistrationClient</em>
-     * method will result in a new client being created (and added to the list of active clients).
-     *
-     * @param tenantId The tenant that the client is scoped to.
-     */
-    protected final void removeRegistrationClient(final String tenantId) {
-
-        final String targetAddress = RegistrationClientImpl.getTargetAddress(tenantId);
-        removeActiveRequestResponseClient(targetAddress);
-    }
-
     /**
      * {@inheritDoc}
      */
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
new file mode 100644
index 000000000..21c507cd8
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
@@ -0,0 +1,83 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+
+import org.eclipse.hono.cache.CacheProvider;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.RegistrationClient;
+import org.eclipse.hono.client.RegistrationClientFactory;
+
+import io.vertx.core.Future;
+
+
+/**
+ * A factory for creating clients for the Hono APIs required
+ * by protocol adapters.
+ *
+ */
+public class RegistrationClientFactoryImpl extends AbstractHonoClientFactory implements RegistrationClientFactory {
+
+    private final CachingClientFactory<RegistrationClient> registrationClientFactory;
+    private final CacheProvider cacheProvider;
+
+    /**
+     * Creates a new factory for an existing connection.
+     * 
+     * @param connection The connection to use.
+     * @param cacheProvider The cache provider to use for creating caches for tenant objects
+     *                      or {@code null} if tenant objects should not be cached.
+     * @throws NullPointerException if connection is {@code null}
+     */
+    public RegistrationClientFactoryImpl(final HonoConnection connection, final CacheProvider cacheProvider) {
+        super(connection);
+        this.registrationClientFactory = new CachingClientFactory<>(c -> c.isOpen());
+        this.cacheProvider = cacheProvider;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onDisconnect() {
+        registrationClientFactory.clearState();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<RegistrationClient> getOrCreateRegistrationClient(final String tenantId) {
+
+        Objects.requireNonNull(tenantId);
+
+        return connection.executeOrRunOnContext(result -> {
+            registrationClientFactory.getOrCreateClient(
+                    RegistrationClientImpl.getTargetAddress(tenantId),
+                    () -> RegistrationClientImpl.create(
+                            cacheProvider,
+                            connection,
+                            tenantId,
+                            this::removeRegistrationClient,
+                            this::removeRegistrationClient),
+                    result);
+        });
+    }
+
+    private void removeRegistrationClient(final String tenantId) {
+        registrationClientFactory.removeClient(RegistrationClientImpl.getTargetAddress(tenantId));
+    }
+}
