diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 6e030c1de..5dbd61f62 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -21,6 +21,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.UUID;
 import java.util.function.Function;
+import java.util.function.Supplier;
 
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
@@ -481,26 +482,41 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      *
      * @param correlationId The identifier of the request to cancel.
      * @param result The result to pass to the result handler registered for the correlation ID.
+     * @return {@code true} if a request with the given identifier was found and cancelled.
      * @throws NullPointerException if any of the parameters is {@code null}.
      * @throws IllegalArgumentException if the result is succeeded.
      */
-    protected final void cancelRequest(final Object correlationId, final AsyncResult<R> result) {
-
+    protected final boolean cancelRequest(final Object correlationId, final AsyncResult<R> result) {
         Objects.requireNonNull(correlationId);
         Objects.requireNonNull(result);
 
         if (result.succeeded()) {
             throw new IllegalArgumentException("result must be failed");
-        } else {
-            final TriTuple<Handler<AsyncResult<R>>, Object, Span> handler = replyMap.remove(correlationId);
-            if (handler == null) {
-                // response has already been processed
-            } else {
-                LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
-                        linkTargetAddress, correlationId, result.cause().getMessage());
-                handler.one().handle(result);
-            }
         }
+        return cancelRequest(correlationId, result::cause);
+    }
+
+    /**
+     * Cancels an outstanding request with a given failure exception.
+     *
+     * @param correlationId The identifier of the request to cancel.
+     * @param exceptionSupplier The supplier of the failure exception.
+     * @return {@code true} if a request with the given identifier was found and cancelled.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    protected final boolean cancelRequest(final Object correlationId, final Supplier<Throwable> exceptionSupplier) {
+        Objects.requireNonNull(correlationId);
+        Objects.requireNonNull(exceptionSupplier);
+
+        return Optional.ofNullable(replyMap.remove(correlationId))
+                .map(handler -> {
+                    final Throwable throwable = exceptionSupplier.get();
+                    LOG.debug("canceling request [target: {}, correlation ID: {}]: {}",
+                            linkTargetAddress, correlationId, throwable.getMessage());
+                    handler.one().handle(Future.failedFuture(throwable));
+                    return true;
+                })
+                .orElse(false);
     }
 
     private R getRequestResponseResult(final Message message) {
@@ -928,9 +944,10 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
                 });
                 if (requestTimeoutMillis > 0) {
                     connection.getVertx().setTimer(requestTimeoutMillis, tid -> {
-                        cancelRequest(correlationId, Future.failedFuture(new ServerErrorException(
-                                HttpURLConnection.HTTP_UNAVAILABLE, "request timed out after " + requestTimeoutMillis + "ms")));
-                        sample.timeout();
+                        if (cancelRequest(correlationId, () -> new ServerErrorException(
+                                HttpURLConnection.HTTP_UNAVAILABLE, "request timed out after " + requestTimeoutMillis + "ms"))) {
+                            sample.timeout();
+                        }
                     });
                 }
                 if (LOG.isDebugEnabled()) {
