diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
index 3a6d767a1..eb7b43903 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
@@ -64,8 +64,6 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
      */
     public static final long MIN_LIVENESS_CHECK_INTERVAL_MILLIS = 2000;
 
-    private static final String RESOURCE_KEY_DELEGATED_COMMAND_SENDER = "DelegatedCommandSender";
-
     private final CachingClientFactory<MessageConsumer> deviceSpecificCommandConsumerFactory;
 
     private final CachingClientFactory<MessageConsumer> tenantScopedCommandConsumerFactory;
@@ -169,7 +167,7 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
         final AtomicReference<ProtonReceiver> receiverRefHolder = new AtomicReference<>();
 
         final DelegateViaDownstreamPeerCommandHandler delegatingCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
-                tenantIdParam -> getOrCreateDelegatedCommandSender(tenantIdParam));
+                (tenantIdParam, deviceIdParam) -> createDelegatedCommandSender(tenantIdParam, deviceIdParam));
 
         final GatewayMappingCommandHandler gatewayMappingCommandHandler = new GatewayMappingCommandHandler(
                 gatewayMapper, commandContext -> {
@@ -225,15 +223,10 @@ public class CommandConsumerFactoryImpl extends AbstractHonoClientFactory implem
                 .map(c -> (MessageConsumer) c);
     }
 
-    private Future<DelegatedCommandSender> getOrCreateDelegatedCommandSender(final String tenantId) {
+    private Future<DelegatedCommandSender> createDelegatedCommandSender(final String tenantId, final String deviceId) {
         Objects.requireNonNull(tenantId);
         return connection.executeOrRunOnContext(result -> {
-            delegatedCommandSenderFactory.getOrCreateClient(
-                    RESOURCE_KEY_DELEGATED_COMMAND_SENDER,
-                    () -> DelegatedCommandSenderImpl.create(connection,
-                            onSenderClosed -> {
-                                delegatedCommandSenderFactory.removeClient(RESOURCE_KEY_DELEGATED_COMMAND_SENDER);
-                            }),
+            delegatedCommandSenderFactory.createClient(() -> DelegatedCommandSenderImpl.create(connection, tenantId, deviceId, null), // FIXME
                     result);
         });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
index 7f0b4f8ba..db00fd69e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandler.java
@@ -13,7 +13,7 @@
 
 package org.eclipse.hono.client.impl;
 
-import java.util.function.Function;
+import java.util.function.BiFunction;
 
 import org.eclipse.hono.client.Command;
 import org.eclipse.hono.client.CommandContext;
@@ -36,17 +36,17 @@ public class DelegateViaDownstreamPeerCommandHandler implements Handler<CommandC
 
     private static final Logger LOG = LoggerFactory.getLogger(DelegateViaDownstreamPeerCommandHandler.class);
 
-    private final Function<String, Future<DelegatedCommandSender>> delegatedCommandSenderSupplier;
+    private final BiFunction<String, String, Future<DelegatedCommandSender>> delegatedCommandSenderSupplier;
 
     /**
      * Creates a new DelegateViaDownstreamPeerCommandHandler.
      *
      * @param delegatedCommandSenderSupplier Function to get a Future with a sender to send the delegated command via
-     *            the downstream peer. The function parameter is the tenant id. The function is supposed to get or
-     *            create such a sender and, if successful, succeed the returned Future with it. If sender creation
-     *            failed, a failed Future is to be returned.
+     *            the downstream peer. The first function parameter is the tenant id, the second is the device id.
+     *            The function is supposed to create such a sender and, if successful, succeed the returned Future
+     *            with it. If sender creation failed, a failed Future is to be returned.
      */
-    public DelegateViaDownstreamPeerCommandHandler(final Function<String, Future<DelegatedCommandSender>> delegatedCommandSenderSupplier) {
+    public DelegateViaDownstreamPeerCommandHandler(final BiFunction<String, String, Future<DelegatedCommandSender>> delegatedCommandSenderSupplier) {
         this.delegatedCommandSenderSupplier = delegatedCommandSenderSupplier;
     }
 
@@ -59,7 +59,7 @@ public class DelegateViaDownstreamPeerCommandHandler implements Handler<CommandC
         LOG.trace("delegate command for device {} to matching consumer via downstream peer", deviceId);
 
         // send message to AMQP network
-        final Future<DelegatedCommandSender> delegatedCommandSender = delegatedCommandSenderSupplier.apply(tenantId);
+        final Future<DelegatedCommandSender> delegatedCommandSender = delegatedCommandSenderSupplier.apply(tenantId, deviceId);
         delegatedCommandSender.setHandler(cmdSenderResult -> {
             if (cmdSenderResult.succeeded()) {
                 final DelegatedCommandSender sender = cmdSenderResult.result();
@@ -77,6 +77,7 @@ public class DelegateViaDownstreamPeerCommandHandler implements Handler<CommandC
                                 "failed to send command message to downstream peer: " + sendResult.cause());
                         commandContext.release();
                     }
+                    sender.close(c -> {});
                 });
             } else {
                 // failed to create sender
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
index 40409f1c6..013b9b199 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
@@ -219,17 +219,21 @@ public class DelegatedCommandSenderImpl extends AbstractSender implements Delega
      * Creates a new sender for sending the delegated command messages to the AMQP network.
      *
      * @param con The connection to the AMQP network.
-     * @param closeHook A handler to invoke if the peer closes the link unexpectedly.
+     * @param tenantId The tenant identifier.
+     * @param deviceId The device identifier.
+     * @param closeHook A handler to invoke if the peer closes the link unexpectedly (may be {@code null}).
      * @return A future indicating the result of the creation attempt.
      * @throws NullPointerException if con is {@code null}.
      */
     public static Future<DelegatedCommandSender> create(
             final HonoConnection con,
+            final String tenantId,
+            final String deviceId,
             final Handler<String> closeHook) {
 
         Objects.requireNonNull(con);
 
-        final String targetAddress = ""; // use anonymous relay (ie. use empty address)
+        final String targetAddress = getTargetAddress(tenantId, deviceId);
         return con.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook)
                 .map(sender -> (DelegatedCommandSender) new DelegatedCommandSenderImpl(con, sender));
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
index a63fcdfec..7f61f374e 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DelegateViaDownstreamPeerCommandHandlerTest.java
@@ -19,12 +19,12 @@ import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.mockito.Mockito.*;
 
-import io.vertx.core.Vertx;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Modified;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.messaging.Released;
+import org.apache.qpid.proton.amqp.messaging.Target;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.message.Message;
@@ -41,6 +41,7 @@ import org.mockito.ArgumentCaptor;
 import io.opentracing.Span;
 import io.opentracing.SpanContext;
 import io.vertx.core.Future;
+import io.vertx.core.Vertx;
 import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
@@ -58,6 +59,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
     private DelegatedCommandSender delegatedCommandSender;
     private String replyTo;
     private HonoConnection connection;
+    private ProtonSender protonSender;
 
     /**
      * Sets up common fixture.
@@ -79,13 +81,15 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         commandContext = spy(CommandContext.from(command, commandDelivery, receiver, currentSpan));
 
         delegateViaDownstreamPeerCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
-                tenantIdParam -> Future.succeededFuture(delegatedCommandSender));
+                (tenantIdParam, deviceIdParam) -> Future.succeededFuture(delegatedCommandSender));
 
         connection= mock(HonoConnection.class);
         when(connection.getConfig()).thenReturn(new ClientConfigProperties());
         final Vertx vertx = mock(Vertx.class);
         when(connection.getVertx()).thenReturn(vertx);
         when(vertx.setTimer(anyLong(), anyHandler())).thenReturn(1L);
+        protonSender = mock(ProtonSender.class);
+        when(protonSender.getTarget()).thenReturn(new Target());
     }
 
     /**
@@ -99,7 +103,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
         when(protonDelivery.getRemoteState()).thenReturn(Accepted.getInstance());
         // not using a DelegatedCommandSender mock here since mocking the #sendAndWaitForOutcome(Message, SpanContext) method (which has a default implementation) doesn't seem to work
-        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, protonSender) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -133,7 +137,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         final ErrorCondition error = new ErrorCondition(Symbol.valueOf("someError"), "error message");
         rejected.setError(error);
         when(protonDelivery.getRemoteState()).thenReturn(rejected);
-        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, protonSender) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -168,7 +172,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         modified.setDeliveryFailed(true);
         modified.setUndeliverableHere(true);
         when(protonDelivery.getRemoteState()).thenReturn(modified);
-        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, protonSender) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -199,7 +203,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
         // GIVEN a message sender that returns an 'Released' delivery result
         final ProtonDelivery protonDelivery = mock(ProtonDelivery.class);
         when(protonDelivery.getRemoteState()).thenReturn(Released.getInstance());
-        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, protonSender) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 assertThat(message.getAddress(),
@@ -227,7 +231,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
     public void testHandleWithFailureToSend() {
 
         // GIVEN a message sender that fails to send the message
-        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, mock(ProtonSender.class)) {
+        delegatedCommandSender = new DelegatedCommandSenderImpl(connection, protonSender) {
             @Override
             public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
                 return Future.failedFuture("expected send failure");
@@ -251,7 +255,7 @@ public class DelegateViaDownstreamPeerCommandHandlerTest {
 
         // GIVEN a scenario where sender creation fails
         delegateViaDownstreamPeerCommandHandler = new DelegateViaDownstreamPeerCommandHandler(
-                tenantIdParam -> Future.failedFuture("expected sender creation failure"));
+                (tenantIdParam, deviceIdParam) -> Future.failedFuture("expected sender creation failure"));
 
         // WHEN handle() is invoked
         delegateViaDownstreamPeerCommandHandler.handle(commandContext);
