diff --git a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
new file mode 100644
index 000000000..2217243bf
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
@@ -0,0 +1,131 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+
+import org.apache.qpid.proton.message.Message;
+
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+
+/**
+ * A factory for creating clients for Hono's north bound APIs.
+ *
+ */
+public interface ApplicationClientFactory extends ConnectionLifecycle {
+
+    /**
+     * Creates a client for consuming data from Hono's north bound <em>Telemetry API</em>.
+     *
+     * @param tenantId The tenant to consume data for.
+     * @param telemetryConsumer The handler to invoke with every message received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
+     * @return A future that will complete with the consumer once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    Future<MessageConsumer> createTelemetryConsumer(
+            String tenantId,
+            Consumer<Message> telemetryConsumer,
+            Handler<Void> closeHandler);
+
+    /**
+     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
+     * <p>
+     * The events passed in to the event consumer will be settled automatically if the consumer does not throw an
+     * exception and does not manually handle the message disposition using the passed in delivery.
+     *
+     * @param tenantId The tenant to consume events for.
+     * @param eventConsumer The handler to invoke with every event received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
+     * @return A future that will complete with the consumer once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    Future<MessageConsumer> createEventConsumer(
+            String tenantId,
+            BiConsumer<ProtonDelivery, Message> eventConsumer,
+            Handler<Void> closeHandler);
+
+    /**
+     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
+     * <p>
+     * The events passed in to the event consumer will be settled automatically if the consumer does not throw an
+     * exception.
+     *
+     * @param tenantId The tenant to consume events for.
+     * @param eventConsumer The handler to invoke with every event received.
+     * @param closeHandler The handler invoked when the peer detaches the link.
+     * @return A future that will complete with the consumer once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected.
+     * @throws NullPointerException if any of the parameters is {@code null}.
+     */
+    Future<MessageConsumer> createEventConsumer(
+            String tenantId,
+            Consumer<Message> eventConsumer,
+            Handler<Void> closeHandler);
+
+    /**
+     * Gets a client for sending commands to a device.
+     * <p>
+     * The client returned may be either newly created or it may be an existing
+     * client for the given device.
+     * <p>
+     * This method will use an implementation specific mechanism (e.g. a UUID) to create
+     * a unique reply-to address to be included in commands sent to the device. The protocol
+     * adapters need to convey an encoding of the reply-to address to the device when delivering
+     * the command. Consequently, the number of bytes transferred to the device depends on the
+     * length of the reply-to address being used. In situations where this is a major concern it
+     * might be advisable to use {@link #getOrCreateCommandClient(String, String, String)} for
+     * creating a command client and provide custom (and shorter) <em>reply-to identifier</em>
+     * to be used in the reply-to address.
+     *
+     * @param tenantId The tenant that the device belongs to.
+     * @param deviceId The device to send the commands to.
+     * @return A future that will complete with the command and control client (if successful) or
+     *         fail if the client cannot be created, e.g. because the underlying connection
+     *         is not established or if a concurrent request to create a client for the same
+     *         tenant and device is already being executed.
+     * @throws NullPointerException if the tenantId is {@code null}.
+     */
+    Future<CommandClient> getOrCreateCommandClient(String tenantId, String deviceId);
+
+    /**
+     * Gets a client for sending commands to a device.
+     * <p>
+     * The client returned may be either newly created or it may be an existing
+     * client for the given device.
+     *
+     * @param tenantId The tenant that the device belongs to.
+     * @param deviceId The device to send the commands to.
+     * @param replyId An arbitrary string which (in conjunction with the tenant and device ID) uniquely
+     *                identifies this command client.
+     *                This identifier will only be used for creating a <em>new</em> client for the device.
+     *                If this method returns an existing client for the device then the client will use
+     *                the reply-to address determined during its initial creation. In particular, this
+     *                means that if the (existing) client has originally been created using the
+     *                {@link #getOrCreateCommandClient(String, String)} method, then the reply-to address
+     *                used by the client will most likely not contain the given identifier.
+     * @return A future that will complete with the command and control client (if successful) or
+     *         fail if the client cannot be created, e.g. because the underlying connection
+     *         is not established or if a concurrent request to create a client for the same
+     *         tenant and device is already being executed.
+     * @throws NullPointerException if the tenantId is {@code null}.
+     */
+    Future<CommandClient> getOrCreateCommandClient(String tenantId, String deviceId, String replyId);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
new file mode 100644
index 000000000..94c45e863
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
@@ -0,0 +1,71 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+
+/**
+ * Provides access to the life cycle events of a connection to a Hono service.
+ *
+ */
+public interface ConnectionLifecycle {
+
+    /**
+     * Adds a listener to be notified when the connection is lost unexpectedly.
+     * 
+     * @param listener The listener to add.
+     */
+    void addDisconnectListener(DisconnectListener listener);
+
+    /**
+     * Adds a listener to be notified when the connection has been re-established after
+     * it had been lost unexpectedly.
+     * 
+     * @param listener The listener to add.
+     */
+    void addReconnectListener(ReconnectListener listener);
+
+    /**
+     * Checks whether the connection is currently established.
+     *
+     * @return A succeeded future if this connection is established.
+     *         Otherwise, the future will be failed with a
+     *         {@link ServerErrorException}.
+     */
+    Future<Void> isConnected();
+
+    /**
+     * Disconnects from the service.
+     * <p>
+     * Upon terminating the connection to the server, this method does not automatically try to reconnect
+     * to the server again.
+     *
+     */
+    void disconnect();
+
+    /**
+     * Disconnects from the service.
+     * <p>
+     * Similar to {@code #disconnect()} but takes a handler to be notified about the result
+     * of the disconnect operation. The caller can use the handler to determine if the operation succeeded or failed.
+     *
+     * @param completionHandler The handler to notify about the outcome of the operation.
+     *                          A failure could occur if this method is called in the middle of a disconnect operation.
+     * @throws NullPointerException if the completionHandler is {@code null}.
+     */
+    void disconnect(Handler<AsyncResult<Void>> completionHandler);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java b/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
new file mode 100644
index 000000000..1a7bc373a
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/CredentialsClientFactory.java
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.Future;
+
+/**
+ * A factory for creating clients for Hono's Credentials API.
+ *
+ */
+public interface CredentialsClientFactory extends ConnectionLifecycle {
+
+    /**
+     * Gets a client for interacting with Hono's <em>Credentials</em> API.
+     * <p>
+     * The client returned may be either newly created or it may be an existing
+     * client for the given tenant.
+     *
+     * @param tenantId The tenant to manage device credentials data for.
+     * @return A future that will complete with the credentials client (if successful) or fail if the client cannot be
+     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
+     *         client for the same tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
+     */
+    Future<CredentialsClient> getOrCreateCredentialsClient(String tenantId);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java b/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
new file mode 100644
index 000000000..218019d82
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/DisconnectListener.java
@@ -0,0 +1,31 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+
+/**
+ * A listener to be notified when a connection is lost unexpectedly.
+ *
+ */
+@FunctionalInterface
+public interface DisconnectListener {
+
+    /**
+     * Invoked when the connection to a Hono service is lost unexpectedly.
+     * 
+     * @param client The client representing the connection to the service.
+     */
+    void onDisconnect(HonoClient client);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/DownstreamSenderFactory.java b/client/src/main/java/org/eclipse/hono/client/DownstreamSenderFactory.java
new file mode 100644
index 000000000..ceba0b16c
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/DownstreamSenderFactory.java
@@ -0,0 +1,52 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.Future;
+
+/**
+ * A factory for creating clients for Hono's south bound Telemetry and Event APIs.
+ *
+ */
+public interface DownstreamSenderFactory extends ConnectionLifecycle {
+
+    /**
+     * Gets a client for sending data to Hono's south bound <em>Telemetry</em> API.
+     * <p>
+     * The client returned may be either newly created or it may be an existing
+     * client for the given tenant.
+     *
+     * @param tenantId The ID of the tenant to send messages for.
+     * @return A future that will complete with the sender once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
+     *         create a sender for the same tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
+     */
+    Future<MessageSender> getOrCreateTelemetrySender(String tenantId);
+
+    /**
+     * Gets a client for sending data to Hono's south bound <em>Event</em> API.
+     * <p>
+     * The client returned may be either newly created or it may be an existing
+     * client for the given tenant.
+     *
+     * @param tenantId The ID of the tenant to send messages for.
+     * @return A future that will complete with the sender once the link has been established. The future will fail if
+     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
+     *         create a sender for the same tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
+     */
+    Future<MessageSender> getOrCreateEventSender(String tenantId);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 89b7de660..c1576666e 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -13,20 +13,16 @@
 
 package org.eclipse.hono.client;
 
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-
 import org.apache.qpid.proton.amqp.Symbol;
-import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.impl.HonoClientImpl;
 import org.eclipse.hono.config.ClientConfigProperties;
+
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
 import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonDelivery;
 
 /**
  * A factory for creating clients for Hono's arbitrary APIs.
@@ -67,7 +63,12 @@ import io.vertx.proton.ProtonDelivery;
  * from the same Context or to make sure that the handlers are running on the correct Context, e.g. by using
  * the {@code Context}'s <em>runOnContext</em> method.
  */
-public interface HonoClient {
+public interface HonoClient extends ConnectionLifecycle,
+                                    DownstreamSenderFactory,
+                                    ApplicationClientFactory,
+                                    CredentialsClientFactory,
+                                    RegistrationClientFactory,
+                                    TenantClientFactory {
 
     /**
      * Checks whether this client is connected to the service.
@@ -212,218 +213,21 @@ public interface HonoClient {
             Handler<ProtonConnection> disconnectHandler);
 
     /**
-     * Disconnects the connection to the Hono server. Upon terminating the connection to the server,
-     * this method does not automatically try to reconnect to the server again. To connect to the server,
-     * an explicit call to {@code HonoClient#connect()} should be made. Unlike {@code HonoClient#shutdown()},
-     * which does not allow to connect back to the server, this method allows to connect back to the server.
-     *
+     * {@inheritDoc}
+     * 
+     * To re-connect to the server, an explicit call to {@code #connect()} should be made.
+     * Unlike {@code #shutdown()}, which does not allow to connect back to the server,
+     * this method allows to connect back to the server.
+     * <p>
      * Disconnecting from the Hono server is necessary when, for instance, the open frame of the connection contains
      * permission information from an authorization service. If after connecting to the server the permissions
      * from the service have changed, then it will be necessary to drop the connection and connect back to the server
      * to retrieve the updated permissions.
      *
      */
+    @Override
     void disconnect();
 
-    /**
-     * Similar to {@code HonoClient#disconnect()} but takes a handler to notify the caller about the result
-     * of the disconnect operation. The caller can use the handler to determine if the operation succeeded or failed.
-     *
-     * @param completionHandler The completion handler to notify about the success or failure of the operation. A failure could occur
-     * if this method is called in the middle of a disconnect operation.
-     * @throws NullPointerException if the completionHandler is {@code null}.
-     */
-    void disconnect(Handler<AsyncResult<Void>> completionHandler);
-
-    /**
-     * Gets a client for sending data to Hono's south bound <em>Telemetry</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @param tenantId The ID of the tenant to send messages for.
-     * @return A future that will complete with the sender once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
-     *         create a sender for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<MessageSender> getOrCreateTelemetrySender(String tenantId);
-
-    /**
-     * Gets a client for sending data to Hono's south bound <em>Telemetry</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given device.
-     *
-     * @param tenantId The ID of the tenant to send messages for.
-     * @param deviceId The ID of the device to send events for (may be {@code null}).
-     * @return A future that will complete with the sender once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
-     *         create a sender for the same tenant and device is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<MessageSender> getOrCreateTelemetrySender(String tenantId, String deviceId);
-
-    /**
-     * Gets a client for sending events to Hono's south bound <em>Event</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @param tenantId The ID of the tenant to send events for.
-     * @return A future that will complete with the sender once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
-     *         create a sender for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<MessageSender> getOrCreateEventSender(String tenantId);
-
-    /**
-     * Gets a client for sending events to Hono's south bound <em>Event</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given device.
-     *
-     * @param tenantId The ID of the tenant to send events for.
-     * @param deviceId The ID of the device to send events for (may be {@code null}).
-     * @return A future that will complete with the sender once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected or if a concurrent request to
-     *         create a sender for the same tenant and device is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<MessageSender> getOrCreateEventSender(String tenantId, String deviceId);
-
-    /**
-     * Creates a client for consuming data from Hono's north bound <em>Telemetry API</em>.
-     *
-     * @param tenantId The tenant to consume data for.
-     * @param telemetryConsumer The handler to invoke with every message received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createTelemetryConsumer(String tenantId, Consumer<Message> telemetryConsumer,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
-     * <p>
-     * The events passed in to the event consumer will be settled automatically if the consumer does not throw an
-     * exception.
-     *
-     * @param tenantId The tenant to consume events for.
-     * @param eventConsumer The handler to invoke with every event received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createEventConsumer(String tenantId, Consumer<Message> eventConsumer,
-            Handler<Void> closeHandler);
-
-    /**
-     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.
-     * <p>
-     * The events passed in to the event consumer will be settled automatically if the consumer does not throw an
-     * exception and does not manually handle the message disposition using the passed in delivery.
-     *
-     * @param tenantId The tenant to consume events for.
-     * @param eventConsumer The handler to invoke with every event received.
-     * @param closeHandler The handler invoked when the peer detaches the link.
-     * @return A future that will complete with the consumer once the link has been established. The future will fail if
-     *         the link cannot be established, e.g. because this client is not connected.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    Future<MessageConsumer> createEventConsumer(String tenantId, BiConsumer<ProtonDelivery, Message> eventConsumer,
-            Handler<Void> closeHandler);
-
-    /**
-     * Gets a client for invoking operations on a service implementing Hono's <em>Device Registration</em> API.
-     *
-     * @param tenantId The tenant to manage device registration data for.
-     * @return A future that will complete with the registration client (if successful) or fail if the client cannot be
-     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
-     *         client for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<RegistrationClient> getOrCreateRegistrationClient(String tenantId);
-
-    /**
-     * Gets a client for interacting with Hono's <em>Credentials</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @param tenantId The tenant to manage device credentials data for.
-     * @return A future that will complete with the credentials client (if successful) or fail if the client cannot be
-     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
-     *         client for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<CredentialsClient> getOrCreateCredentialsClient(String tenantId);
-
-    /**
-     * Gets a client for interacting with Hono's <em>Tenant</em> API.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given tenant.
-     *
-     * @return A future that will complete with the tenant client (if successful) or fail if the client cannot be
-     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
-     *         client for the same tenant is already being executed.
-     */
-    Future<TenantClient> getOrCreateTenantClient();
-
-    /**
-     * Gets a client for sending commands to a device.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given device.
-     * <p>
-     * This method will use an implementation specific mechanism (e.g. a UUID) to create
-     * a unique reply-to address to be included in commands sent to the device. The protocol
-     * adapters need to convey an encoding of the reply-to address to the device when delivering
-     * the command. Consequently, the number of bytes transferred to the device depends on the
-     * length of the reply-to address being used. In situations where this is a major concern it
-     * might be advisable to use {@link #getOrCreateCommandClient(String, String, String)} for
-     * creating a command client and provide custom (and shorter) <em>reply-to identifier</em>
-     * to be used in the reply-to address.
-     *
-     * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to send the commands to.
-     * @return A future that will complete with the command and control client (if successful) or
-     *         fail if the client cannot be created, e.g. because the underlying connection
-     *         is not established or if a concurrent request to create a client for the same
-     *         tenant and device is already being executed.
-     * @throws NullPointerException if the tenantId is {@code null}.
-     */
-    Future<CommandClient> getOrCreateCommandClient(String tenantId, String deviceId);
-
-    /**
-     * Gets a client for sending commands to a device.
-     * <p>
-     * The client returned may be either newly created or it may be an existing
-     * client for the given device.
-     *
-     * @param tenantId The tenant that the device belongs to.
-     * @param deviceId The device to send the commands to.
-     * @param replyId An arbitrary string which (in conjunction with the tenant and device ID) uniquely
-     *                identifies this command client.
-     *                This identifier will only be used for creating a <em>new</em> client for the device.
-     *                If this method returns an existing client for the device then the client will use
-     *                the reply-to address determined during its initial creation. In particular, this
-     *                means that if the (existing) client has originally been created using the
-     *                {@link #getOrCreateCommandClient(String, String)} method, then the reply-to address
-     *                used by the client will most likely not contain the given identifier.
-     * @return A future that will complete with the command and control client (if successful) or
-     *         fail if the client cannot be created, e.g. because the underlying connection
-     *         is not established or if a concurrent request to create a client for the same
-     *         tenant and device is already being executed.
-     * @throws NullPointerException if the tenantId is {@code null}.
-     */
-    Future<CommandClient> getOrCreateCommandClient(String tenantId, String deviceId, String replyId);
-
     /**
      * Closes this client's connection to the Hono server.
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java b/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
new file mode 100644
index 000000000..e5269dbf1
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/ReconnectListener.java
@@ -0,0 +1,33 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+
+/**
+ * A listener to be notified when a connection is re-established after
+ * it has been lost unexpectedly.
+ *
+ */
+@FunctionalInterface
+public interface ReconnectListener {
+
+    /**
+     * Invoked after the connection to a Hono service has been re-established
+     * after it had been lost unexpectedly.
+     * 
+     * @param client The client representing the (re-established) connection to the service.
+     */
+    void onReconnect(HonoClient client);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
new file mode 100644
index 000000000..16e148bad
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/RegistrationClientFactory.java
@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.Future;
+
+/**
+ * A factory for creating clients for Hono's Device Registration API.
+ *
+ */
+public interface RegistrationClientFactory extends ConnectionLifecycle {
+
+    /**
+     * Gets a client for invoking operations on a service implementing Hono's <em>Device Registration</em> API.
+     *
+     * @param tenantId The tenant to manage device registration data for.
+     * @return A future that will complete with the registration client (if successful) or fail if the client cannot be
+     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
+     *         client for the same tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
+     */
+    Future<RegistrationClient> getOrCreateRegistrationClient(String tenantId);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/TenantClientFactory.java b/client/src/main/java/org/eclipse/hono/client/TenantClientFactory.java
new file mode 100644
index 000000000..c02032d1f
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/TenantClientFactory.java
@@ -0,0 +1,36 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.Future;
+
+/**
+ * A factory for creating clients for Hono's Credentials API.
+ *
+ */
+public interface TenantClientFactory extends ConnectionLifecycle {
+
+    /**
+     * Gets a client for interacting with Hono's <em>Tenant</em> API.
+     * <p>
+     * The client returned may be either newly created or it may be an existing
+     * client for the given tenant.
+     *
+     * @return A future that will complete with the tenant client (if successful) or fail if the client cannot be
+     *         created, e.g. because the underlying connection is not established or if a concurrent request to create a
+     *         client for the same tenant is already being executed.
+     */
+    Future<TenantClient> getOrCreateTenantClient();
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 2790cf44e..26eecf4b3 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -39,9 +39,11 @@ import org.eclipse.hono.cache.CacheProvider;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.CommandClient;
 import org.eclipse.hono.client.CredentialsClient;
+import org.eclipse.hono.client.DisconnectListener;
 import org.eclipse.hono.client.HonoClient;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.client.ReconnectListener;
 import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.client.ServerErrorException;
@@ -114,6 +116,8 @@ public class HonoClientImpl implements HonoClient {
     private final Map<String, RequestResponseClient> activeRequestResponseClients = new HashMap<>();
     private final Map<String, Boolean> creationLocks = new HashMap<>();
     private final List<Handler<Void>> creationRequests = new ArrayList<>();
+    private final List<DisconnectListener> disconnectListeners = new ArrayList<>();
+    private final List<ReconnectListener> reconnectListeners = new ArrayList<>();
     private final AtomicBoolean connecting = new AtomicBoolean(false);
     private final AtomicBoolean shuttingDown = new AtomicBoolean(false);
     private final AtomicBoolean disconnecting = new AtomicBoolean(false);
@@ -205,6 +209,16 @@ public class HonoClientImpl implements HonoClient {
         return tracer;
     }
 
+    @Override
+    public final void addDisconnectListener(final DisconnectListener listener) {
+        disconnectListeners.add(listener);
+    }
+
+    @Override
+    public final void addReconnectListener(final ReconnectListener listener) {
+        reconnectListeners.add(listener);
+    }
+
     /**
      * Executes some code on the vert.x Context that has been used to establish the
      * connection to the peer.
@@ -460,7 +474,15 @@ public class HonoClientImpl implements HonoClient {
         if (connectionLossHandler != null) {
             connectionLossHandler.handle(failedConnection);
         } else {
-            reconnect(attempt -> {}, null);
+            reconnect(this::notifyReconnectHandlers, null);
+        }
+    }
+
+    private void notifyReconnectHandlers(final AsyncResult<HonoClient> reconnectAttempt) {
+        if (reconnectAttempt.succeeded()) {
+            for (ReconnectListener listener : reconnectListeners) {
+                listener.onReconnect(this);
+            }
         }
     }
 
@@ -474,10 +496,18 @@ public class HonoClientImpl implements HonoClient {
         activeSenders.clear();
         activeRequestResponseClients.clear();
         failAllCreationRequests();
+        notifyDisconnectHandlers();
         // make sure we make configured number of attempts to re-connect
         connectAttempts = new AtomicInteger(0);
     }
 
+    private void notifyDisconnectHandlers() {
+
+        for (DisconnectListener listener : disconnectListeners) {
+            listener.onDisconnect(this);
+        }
+    }
+
     private void failAllCreationRequests() {
 
         for (final Iterator<Handler<Void>> iter = creationRequests.iterator(); iter.hasNext();) {
@@ -556,30 +586,20 @@ public class HonoClientImpl implements HonoClient {
      */
     @Override
     public final Future<MessageSender> getOrCreateTelemetrySender(final String tenantId) {
-        return getOrCreateTelemetrySender(tenantId, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageSender> getOrCreateTelemetrySender(final String tenantId, final String deviceId) {
 
         Objects.requireNonNull(tenantId);
         return getOrCreateSender(
-                TelemetrySenderImpl.getTargetAddress(tenantId, deviceId),
-                () -> createTelemetrySender(tenantId, deviceId));
+                TelemetrySenderImpl.getTargetAddress(tenantId, null),
+                () -> createTelemetrySender(tenantId));
     }
 
-    private Future<MessageSender> createTelemetrySender(
-            final String tenantId,
-            final String deviceId) {
+    private Future<MessageSender> createTelemetrySender(final String tenantId) {
 
         return checkConnected().compose(connected -> {
             final Future<MessageSender> result = Future.future();
-            TelemetrySenderImpl.create(context, clientConfigProperties, connection, tenantId, deviceId,
+            TelemetrySenderImpl.create(context, clientConfigProperties, connection, tenantId, null,
                     onSenderClosed -> {
-                        activeSenders.remove(TelemetrySenderImpl.getTargetAddress(tenantId, deviceId));
+                        activeSenders.remove(TelemetrySenderImpl.getTargetAddress(tenantId, null));
                     },
                     result.completer(), tracer);
             return result;
@@ -591,32 +611,20 @@ public class HonoClientImpl implements HonoClient {
      */
     @Override
     public final Future<MessageSender> getOrCreateEventSender(final String tenantId) {
-        return getOrCreateEventSender(tenantId, null);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageSender> getOrCreateEventSender(
-            final String tenantId,
-            final String deviceId) {
 
         Objects.requireNonNull(tenantId);
         return getOrCreateSender(
-                EventSenderImpl.getTargetAddress(tenantId, deviceId),
-                () -> createEventSender(tenantId, deviceId));
+                EventSenderImpl.getTargetAddress(tenantId, null),
+                () -> createEventSender(tenantId));
     }
 
-    private Future<MessageSender> createEventSender(
-            final String tenantId,
-            final String deviceId) {
+    private Future<MessageSender> createEventSender(final String tenantId) {
 
         return checkConnected().compose(connected -> {
             final Future<MessageSender> result = Future.future();
-            EventSenderImpl.create(context, clientConfigProperties, connection, tenantId, deviceId,
+            EventSenderImpl.create(context, clientConfigProperties, connection, tenantId, null,
                     onSenderClosed -> {
-                        activeSenders.remove(EventSenderImpl.getTargetAddress(tenantId, deviceId));
+                        activeSenders.remove(EventSenderImpl.getTargetAddress(tenantId, null));
                     },
                     result.completer(), tracer);
             return result;
