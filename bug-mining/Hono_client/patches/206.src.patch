diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
index ceadf3542..41718b5a4 100644
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -13,6 +13,8 @@
 
 package org.eclipse.hono.client;
 
+import java.util.List;
+
 import io.opentracing.SpanContext;
 import io.vertx.core.Future;
 import io.vertx.core.json.JsonObject;
@@ -35,7 +37,7 @@ public interface DeviceConnectionClient extends RequestResponseClient {
      *
      * @param deviceId The device id.
      * @param gatewayId The gateway id (or the device id if the last message came from the device directly).
-     * @param context The currently active OpenTracing span or {@code null} if no span is currently active.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
      *            An implementation should use this as the parent for any span it creates for tracing
      *            the execution of this operation.
      * @return A future indicating whether the operation succeeded or not.
@@ -50,7 +52,7 @@ public interface DeviceConnectionClient extends RequestResponseClient {
      * is returned.
      *
      * @param deviceId The device id.
-     * @param context The currently active OpenTracing span or {@code null} if no span is currently active.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
      *            An implementation should use this as the parent for any span it creates for tracing
      *            the execution of this operation.
      * @return A future indicating the result of the operation.
@@ -64,4 +66,57 @@ public interface DeviceConnectionClient extends RequestResponseClient {
      * @throws NullPointerException if device id is {@code null}.
      */
     Future<JsonObject> getLastKnownGatewayForDevice(String deviceId, SpanContext context);
+
+    /**
+     * Sets the protocol adapter instance that handles commands for the given device.
+     *
+     * @param deviceId The device id.
+     * @param adapterInstanceId The protocol adapter instance id.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+     *            An implementation should use this as the parent for any span it creates for tracing
+     *            the execution of this operation.
+     * @return A future indicating whether the operation succeeded or not.
+     * @throws NullPointerException if device id or adapter instance id is {@code null}.
+     */
+    Future<Void> setCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);
+
+    /**
+     * Removes the mapping information that associates the given device with the given protocol adapter instance
+     * that handles commands for the given device. The mapping entry is only deleted if its value
+     * contains the given protocol adapter instance id.
+     *
+     * @param deviceId The device id.
+     * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+     *            An implementation should use this as the parent for any span it creates for tracing
+     *            the execution of this operation.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the entry was successfully removed.
+     *         Otherwise the future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException}.
+     * @throws NullPointerException if device id or adapter instance id is {@code null}.
+     */
+    Future<Void> removeCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);
+
+    /**
+     * Gets information about the adapter instances that can handle a command for the given device.
+     * <p>
+     * See Hono's <a href="https://www.eclipse.org/hono/docs/api/device-connection/">Device Connection API
+     * specification</a> for a detailed description of the method's behaviour and the returned JSON object.
+     * <p>
+     * If no adapter instances are found, the returned future is failed.
+     *
+     * @param deviceId The device id.
+     * @param viaGateways The list of gateways that may act on behalf of the given device.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+     *            Implementing classes should use this as the parent for any span they create for tracing the execution
+     *            of this operation.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         If instances were found, the future will be succeeded with a JSON object containing one or more mappings
+     *         from device id to adapter instance id. Otherwise the future will be failed with a
+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.
+     * @throws NullPointerException if any of the parameters except context is {@code null}.
+     */
+    Future<JsonObject> getCommandHandlingAdapterInstances(String deviceId, List<String> viaGateways, SpanContext context);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
index d54450b8e..0ad2b460f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -15,6 +15,7 @@ package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.UUID;
@@ -27,6 +28,7 @@ import org.eclipse.hono.util.CacheDirective;
 import org.eclipse.hono.util.DeviceConnectionConstants;
 import org.eclipse.hono.util.DeviceConnectionResult;
 import org.eclipse.hono.util.MessageHelper;
+import org.eclipse.hono.util.RequestResponseApiConstants;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -37,6 +39,7 @@ import io.vertx.core.Handler;
 import io.vertx.core.Promise;
 import io.vertx.core.buffer.Buffer;
 import io.vertx.core.json.DecodeException;
+import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
 import io.vertx.proton.ProtonReceiver;
 import io.vertx.proton.ProtonSender;
@@ -226,4 +229,89 @@ public class DeviceConnectionClientImpl extends AbstractRequestResponseClient<De
                 },
                 currentSpan);
     }
+
+    @Override
+    public Future<Void> removeCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId, final SpanContext context) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(adapterInstanceId);
+
+        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
+        properties.put(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
+
+        final Span currentSpan = newChildSpan(context, "remove command handling adapter instance");
+        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
+        createAndSendRequest(
+                DeviceConnectionConstants.DeviceConnectionAction.REMOVE_CMD_HANDLING_ADAPTER_INSTANCE.getSubject(),
+                properties,
+                null,
+                null,
+                resultTracker,
+                null,
+                currentSpan);
+        return mapResultAndFinishSpan(resultTracker.future(), result -> {
+            switch (result.getStatus()) {
+                case HttpURLConnection.HTTP_NO_CONTENT:
+                    return null;
+                default:
+                    throw StatusCodeMapper.from(result);
+            }
+        }, currentSpan);
+    }
+
+    @Override
+    public Future<Void> setCommandHandlingAdapterInstance(final String deviceId, final String adapterInstanceId, final SpanContext context) {
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(adapterInstanceId);
+
+        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
+        properties.put(MessageHelper.APP_PROPERTY_ADAPTER_INSTANCE_ID, adapterInstanceId);
+
+        final Span currentSpan = newChildSpan(context, "set command handling adapter instance");
+        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
+        createAndSendRequest(
+                DeviceConnectionConstants.DeviceConnectionAction.SET_CMD_HANDLING_ADAPTER_INSTANCE.getSubject(),
+                properties,
+                null,
+                null,
+                resultTracker,
+                null,
+                currentSpan);
+        return mapResultAndFinishSpan(resultTracker.future(), result -> {
+            switch (result.getStatus()) {
+                case HttpURLConnection.HTTP_NO_CONTENT:
+                    return null;
+                default:
+                    throw StatusCodeMapper.from(result);
+            }
+        }, currentSpan);
+    }
+
+    @Override
+    public Future<JsonObject> getCommandHandlingAdapterInstances(final String deviceId, final List<String> viaGateways, final SpanContext context) {
+        Objects.requireNonNull(deviceId);
+        final Promise<DeviceConnectionResult> resultTracker = Promise.promise();
+
+        final Map<String, Object> properties = createDeviceIdProperties(deviceId);
+        final JsonObject payload = new JsonObject();
+        payload.put(DeviceConnectionConstants.FIELD_GATEWAY_IDS, new JsonArray(viaGateways));
+
+        final Span currentSpan = newChildSpan(context, "get command handling adapter instances");
+        createAndSendRequest(
+                DeviceConnectionConstants.DeviceConnectionAction.GET_CMD_HANDLING_ADAPTER_INSTANCES.getSubject(),
+                properties,
+                payload.toBuffer(),
+                RequestResponseApiConstants.CONTENT_TYPE_APPLICATION_JSON,
+                resultTracker,
+                null,
+                currentSpan);
+        return mapResultAndFinishSpan(resultTracker.future(), result -> {
+            switch (result.getStatus()) {
+                case HttpURLConnection.HTTP_OK:
+                    return result.getPayload();
+                default:
+                    throw StatusCodeMapper.from(result);
+            }
+        }, currentSpan);
+    }
+
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
index 0fca80277..eef60a8db 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
@@ -22,6 +22,7 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.net.HttpURLConnection;
+import java.util.Collections;
 
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.message.Message;
@@ -44,6 +45,7 @@ import io.opentracing.Tracer.SpanBuilder;
 import io.opentracing.tag.Tags;
 import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
+import io.vertx.core.json.JsonArray;
 import io.vertx.core.json.JsonObject;
 import io.vertx.junit5.VertxExtension;
 import io.vertx.junit5.VertxTestContext;
@@ -94,66 +96,139 @@ public class DeviceConnectionClientImplTest {
     }
 
     /**
-     * Verifies that the client retrieves the result of the <em>get last known gateway</em> operation from the
+     * Verifies that the client retrieves the result of the <em>get-last-known-gateway</em> operation from the
      * Device Connection service.
      * 
      * @param ctx The vert.x test context.
      */
-    @SuppressWarnings("unchecked")
     @Test
     public void testGetLastKnownGatewayForDeviceSuccess(final VertxTestContext ctx) {
 
-        final JsonObject getLastGatewayResult = newGetLastGatewayResult("gatewayId");
+        final String gatewayId = "gatewayId";
+        final JsonObject getLastGatewayResult = new JsonObject().
+                put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
 
         // WHEN getting the last known gateway
         client.getLastKnownGatewayForDevice("deviceId", span.context())
                 .setHandler(ctx.succeeding(r -> {
-                    // THEN the last known gateway has been retrieved from the service and the span is finished
-                    verify(span).finish();
+                    ctx.verify(() -> {
+                        // THEN the last known gateway has been retrieved from the service and the span is finished
+                        verify(span).finish();
+                        assertThat(r.getString(DeviceConnectionConstants.FIELD_GATEWAY_ID)).isEqualTo(gatewayId);
+                    });
                     ctx.completeNow();
                 }));
 
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), any(Handler.class));
+        final Message sentMessage = verifySenderSend();
         final Message response = ProtonHelper.message(getLastGatewayResult.encode());
         MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_OK);
         MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
+        response.setCorrelationId(sentMessage.getMessageId());
+        client.handleResponse(mock(ProtonDelivery.class), response);
     }
 
     /**
-     * Verifies that the client handles the response of the <em>set last known gateway</em> operation from the
+     * Verifies that the client handles the response of the <em>set-last-known-gateway</em> operation from the
      * Device Connection service.
      *
      * @param ctx The vert.x test context.
      */
-    @SuppressWarnings("unchecked")
     @Test
     public void testSetLastKnownGatewayForDeviceSuccess(final VertxTestContext ctx) {
 
         // WHEN setting the last known gateway
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
                 .setHandler(ctx.succeeding(r -> {
-                    // THEN the response for setting the last known gateway has been handled by the service
-                    // and the span is finished
-                    verify(span).finish();
+                    ctx.verify(() -> {
+                        // THEN the response for setting the last known gateway has been handled by the service
+                        // and the span is finished
+                        verify(span).finish();
+                    });
                     ctx.completeNow();
                 }));
 
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), any(Handler.class));
-        final Message response = ProtonHelper.message();
-        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NO_CONTENT);
-        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
-        response.setCorrelationId(messageCaptor.getValue().getMessageId());
-        final ProtonDelivery delivery = mock(ProtonDelivery.class);
-        client.handleResponse(delivery, response);
+        final Message sentMessage = verifySenderSend();
+        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
+        client.handleResponse(mock(ProtonDelivery.class), response);
+    }
+
+    /**
+     * Verifies that the client handles the response of the <em>set-cmd-handling-adapter-instance</em> operation from the
+     * Device Connection service.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testSetCommandHandlingAdapterInstance(final VertxTestContext ctx) {
+
+        // WHEN setting the last known gateway
+        client.setCommandHandlingAdapterInstance("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.succeeding(r -> {
+                    ctx.verify(() -> {
+                        // THEN the response for setting the command handling adapter instance has been handled by the service
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+
+        final Message sentMessage = verifySenderSend();
+        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
+        client.handleResponse(mock(ProtonDelivery.class), response);
     }
 
     /**
-     * Verifies that a client invocation of the <em>get last known gateway</em> operation fails
+     * Verifies that the client handles the response of the <em>remove-cmd-handling-adapter-instance</em> operation from the
+     * Device Connection service.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testRemoveCommandHandlingAdapterInstance(final VertxTestContext ctx) {
+
+        // WHEN setting the last known gateway
+        client.removeCommandHandlingAdapterInstance("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.succeeding(r -> {
+                    ctx.verify(() -> {
+                        // THEN the response for setting the last known gateway has been handled by the service
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+
+        final Message sentMessage = verifySenderSend();
+        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
+        client.handleResponse(mock(ProtonDelivery.class), response);
+    }
+
+    /**
+     * Verifies that the client handles the response of the <em>get-cmd-handling-adapter-instances</em> operation from the
+     * Device Connection service.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetCommandHandlingAdapterInstances(final VertxTestContext ctx) {
+
+        // WHEN setting the last known gateway
+        client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.succeeding(r -> {
+                    ctx.verify(() -> {
+                        // THEN the response for setting the last known gateway has been handled by the service
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+
+        final Message sentMessage = verifySenderSend();
+        final Message response = createNoContentResponseMessage(sentMessage.getMessageId());
+        client.handleResponse(mock(ProtonDelivery.class), response);
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>get-last-known-gateway</em> operation fails
      * if the device connection service cannot be reached.
      *
      * @param ctx The vert.x test context.
@@ -167,16 +242,18 @@ public class DeviceConnectionClientImplTest {
         // WHEN getting last known gateway information
         client.getLastKnownGatewayForDevice("deviceId", span.context())
                 .setHandler(ctx.failing(t -> {
-                    // THEN the invocation fails and the span is marked as erroneous
-                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                    // and the span is finished
-                    verify(span).finish();
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
                     ctx.completeNow();
                 }));
     }
 
     /**
-     * Verifies that a client invocation of the <em>set last known gateway</em> operation fails
+     * Verifies that a client invocation of the <em>set-last-known-gateway</em> operation fails
      * if the device connection service cannot be reached.
      *
      * @param ctx The vert.x test context.
@@ -190,16 +267,93 @@ public class DeviceConnectionClientImplTest {
         // WHEN getting last known gateway information
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
                 .setHandler(ctx.failing(t -> {
-                    // THEN the invocation fails and the span is marked as erroneous
-                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                    // and the span is finished
-                    verify(span).finish();
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>set-cmd-handling-adapter-instance</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testSetCommandHandlingAdapterInstanceFailsWithSendError(final VertxTestContext ctx) {
+
+        // GIVEN a client with no credit left
+        when(sender.sendQueueFull()).thenReturn(true);
+
+        // WHEN getting last known gateway information
+        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
+                .setHandler(ctx.failing(t -> {
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>remove-cmd-handling-adapter-instance</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testRemoveCommandHandlingAdapterInstanceFailsWithSendError(final VertxTestContext ctx) {
+
+        // GIVEN a client with no credit left
+        when(sender.sendQueueFull()).thenReturn(true);
+
+        // WHEN getting last known gateway information
+        client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
+                .setHandler(ctx.failing(t -> {
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
                     ctx.completeNow();
                 }));
     }
 
     /**
-     * Verifies that a client invocation of the <em>get last known gateway</em> operation fails
+     * Verifies that a client invocation of the <em>get-cmd-handling-adapter-instances</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetCommandHandlingAdapterInstancesFailsWithSendError(final VertxTestContext ctx) {
+
+        // GIVEN a client with no credit left
+        when(sender.sendQueueFull()).thenReturn(true);
+
+        // WHEN getting last known gateway information
+        client.getCommandHandlingAdapterInstances("deviceId", Collections.emptyList(), span.context())
+                .setHandler(ctx.failing(t -> {
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>get-last-known-gateway</em> operation fails
      * if the device connection service cannot be reached.
      *
      * @param ctx The vert.x test context.
@@ -221,16 +375,18 @@ public class DeviceConnectionClientImplTest {
         client.getLastKnownGatewayForDevice("deviceId", span.context())
                 .setHandler(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                    // THEN the invocation fails and the span is marked as erroneous
-                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                    // and the span is finished
-                    verify(span).finish();
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
                     ctx.completeNow();
                 }));
     }
 
     /**
-     * Verifies that a client invocation of the <em>set last known gateway</em> operation fails
+     * Verifies that a client invocation of the <em>set-last-known-gateway</em> operation fails
      * if the device connection service cannot be reached.
      *
      * @param ctx The vert.x test context.
@@ -250,18 +406,119 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting last known gateway information
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
+                .setHandler(ctx.failing(t -> {
+                    ctx.verify(() -> {
+                        assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>set-cmd-handling-adapter-instance</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testSetCommandHandlingAdapterInstanceFailsWithRejectedRequest(final VertxTestContext ctx) {
+
+        // GIVEN a client with no credit left
+        final ProtonDelivery update = mock(ProtonDelivery.class);
+        when(update.getRemoteState()).thenReturn(new Rejected());
+        when(update.remotelySettled()).thenReturn(true);
+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(update);
+            return mock(ProtonDelivery.class);
+        });
+
+        // WHEN getting last known gateway information
+        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
                 .setHandler(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
-                    // THEN the invocation fails and the span is marked as erroneous
-                    verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
-                    // and the span is finished
-                    verify(span).finish();
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
                     ctx.completeNow();
                 }));
     }
 
     /**
-     * Verifies that the client includes the required information in the <em>get last known gateway</em> operation
+     * Verifies that a client invocation of the <em>remove-cmd-handling-adapter-instance</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testRemoveCommandHandlingAdapterInstanceFailsWithRejectedRequest(final VertxTestContext ctx) {
+
+        // GIVEN a client with no credit left
+        final ProtonDelivery update = mock(ProtonDelivery.class);
+        when(update.getRemoteState()).thenReturn(new Rejected());
+        when(update.remotelySettled()).thenReturn(true);
+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(update);
+            return mock(ProtonDelivery.class);
+        });
+
+        // WHEN getting last known gateway information
+        client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
+                .setHandler(ctx.failing(t -> {
+                    assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+    }
+
+    /**
+     * Verifies that a client invocation of the <em>get-cmd-handling-adapter-instances</em> operation fails
+     * if the device connection service cannot be reached.
+     *
+     * @param ctx The vert.x test context.
+     */
+    @Test
+    public void testGetCommandHandlingAdapterInstancesFailsWithRejectedRequest(final VertxTestContext ctx) {
+
+        // GIVEN a client with no credit left
+        final ProtonDelivery update = mock(ProtonDelivery.class);
+        when(update.getRemoteState()).thenReturn(new Rejected());
+        when(update.remotelySettled()).thenReturn(true);
+        when(sender.send(any(Message.class), VertxMockSupport.anyHandler())).thenAnswer(invocation -> {
+            final Handler<ProtonDelivery> dispositionHandler = invocation.getArgument(1);
+            dispositionHandler.handle(update);
+            return mock(ProtonDelivery.class);
+        });
+
+        // WHEN getting last known gateway information
+        client.getCommandHandlingAdapterInstances("deviceId", Collections.emptyList(), span.context())
+                .setHandler(ctx.failing(t -> {
+                    assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
+                    ctx.verify(() -> {
+                        // THEN the invocation fails and the span is marked as erroneous
+                        verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
+                        // and the span is finished
+                        verify(span).finish();
+                    });
+                    ctx.completeNow();
+                }));
+    }
+
+    /**
+     * Verifies that the client includes the required information in the <em>get-last-known-gateway</em> operation
      * request message sent to the device connection service.
      */
     @Test
@@ -271,9 +528,7 @@ public class DeviceConnectionClientImplTest {
         client.getLastKnownGatewayForDevice("deviceId", span.context());
 
         // THEN the message being sent contains the device ID in its properties
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message sentMessage = messageCaptor.getValue();
+        final Message sentMessage = verifySenderSend();
         assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo("deviceId");
         assertThat(sentMessage.getMessageId()).isNotNull();
         assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.GET_LAST_GATEWAY.getSubject());
@@ -281,7 +536,7 @@ public class DeviceConnectionClientImplTest {
     }
 
     /**
-     * Verifies that the client includes the required information in the <em>set last known gateway</em> operation
+     * Verifies that the client includes the required information in the <em>set-last-known-gateway</em> operation
      * request message sent to the device connection service.
      */
     @Test
@@ -291,17 +546,82 @@ public class DeviceConnectionClientImplTest {
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context());
 
         // THEN the message being sent contains the device ID in its properties
-        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
-        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
-        final Message sentMessage = messageCaptor.getValue();
+        final Message sentMessage = verifySenderSend();
         assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo("deviceId");
         assertThat(sentMessage.getMessageId()).isNotNull();
         assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.SET_LAST_GATEWAY.getSubject());
         assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
     }
 
-    private JsonObject newGetLastGatewayResult(final String gatewayId) {
-        return new JsonObject().
-                put(DeviceConnectionConstants.FIELD_GATEWAY_ID, gatewayId);
+    /**
+     * Verifies that the client includes the required information in the <em>set-cmd-handling-adapter-instance</em> operation
+     * request message sent to the device connection service.
+     */
+    @Test
+    public void testSetCommandHandlingAdapterInstanceIncludesRequiredInformationInRequest() {
+
+        // WHEN getting last known gateway information
+        client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context());
+
+        // THEN the message being sent contains the device ID in its properties
+        final Message sentMessage = verifySenderSend();
+        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo("deviceId");
+        assertThat(sentMessage.getMessageId()).isNotNull();
+        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.SET_CMD_HANDLING_ADAPTER_INSTANCE.getSubject());
+        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
+    }
+
+    /**
+     * Verifies that the client includes the required information in the <em>remove-cmd-handling-adapter-instance</em> operation
+     * request message sent to the device connection service.
+     */
+    @Test
+    public void testRemoveCommandHandlingAdapterInstanceIncludesRequiredInformationInRequest() {
+
+        // WHEN getting last known gateway information
+        client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context());
+
+        // THEN the message being sent contains the device ID in its properties
+        final Message sentMessage = verifySenderSend();
+        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo("deviceId");
+        assertThat(sentMessage.getMessageId()).isNotNull();
+        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.REMOVE_CMD_HANDLING_ADAPTER_INSTANCE.getSubject());
+        assertThat(MessageHelper.getJsonPayload(sentMessage)).isNull();
     }
+
+    /**
+     * Verifies that the client includes the required information in the <em>get-cmd-handling-adapter-instances</em> operation
+     * request message sent to the device connection service.
+     */
+    @Test
+    public void testGetCommandHandlingAdapterInstancesIncludesRequiredInformationInRequest() {
+
+        // WHEN getting last known gateway information
+        client.getCommandHandlingAdapterInstances("deviceId", Collections.singletonList("gw-1"), span.context());
+
+        // THEN the message being sent contains the device ID in its properties
+        final Message sentMessage = verifySenderSend();
+        assertThat(MessageHelper.getDeviceId(sentMessage)).isEqualTo("deviceId");
+        assertThat(sentMessage.getMessageId()).isNotNull();
+        assertThat(sentMessage.getSubject()).isEqualTo(DeviceConnectionConstants.DeviceConnectionAction.GET_CMD_HANDLING_ADAPTER_INSTANCES.getSubject());
+        final JsonObject msgJsonPayload = MessageHelper.getJsonPayload(sentMessage);
+        assertThat(msgJsonPayload).isNotNull();
+        final JsonArray gatewaysJsonArray = msgJsonPayload.getJsonArray(DeviceConnectionConstants.FIELD_GATEWAY_IDS);
+        assertThat(gatewaysJsonArray.getList().iterator().next()).isEqualTo("gw-1");
+    }
+
+    private Message createNoContentResponseMessage(final Object correlationId) {
+        final Message response = ProtonHelper.message();
+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NO_CONTENT);
+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));
+        response.setCorrelationId(correlationId);
+        return response;
+    }
+
+    private Message verifySenderSend() {
+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);
+        verify(sender).send(messageCaptor.capture(), VertxMockSupport.anyHandler());
+        return messageCaptor.getValue();
+    }
+
 }
