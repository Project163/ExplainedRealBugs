diff --git a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
index 654df67a7..042766525 100644
--- a/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java
@@ -18,6 +18,7 @@ import java.util.function.BiConsumer;
 import java.util.function.Consumer;
 
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.impl.ApplicationClientFactoryImpl;
 
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -29,6 +30,17 @@ import io.vertx.proton.ProtonDelivery;
  */
 public interface ApplicationClientFactory extends ConnectionLifecycle {
 
+    /**
+     * Creates a new factory for an existing connection.
+     *
+     * @param connection The connection to use.
+     * @return The factory.
+     * @throws NullPointerException if connection is {@code null}
+     */
+    static ApplicationClientFactory create(final HonoConnection connection) {
+        return new ApplicationClientFactoryImpl(connection);
+    }
+
     /**
      * Creates a client for consuming data from Hono's north bound <em>Telemetry API</em>.
      *
diff --git a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
index 665d52cf5..0d5ddab64 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoConnection.java
@@ -69,8 +69,7 @@ import io.vertx.proton.ProtonSender;
  * from the same Context or to make sure that the handlers are running on the correct Context, e.g. by using
  * the {@code Context}'s <em>runOnContext</em> method.
  */
-public interface HonoConnection extends ConnectionLifecycle,
-                                    ApplicationClientFactory {
+public interface HonoConnection extends ConnectionLifecycle {
 
     /**
      * Creates a new connection using the default implementation.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
new file mode 100644
index 000000000..503f9c889
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ApplicationClientFactoryImpl.java
@@ -0,0 +1,226 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+import java.util.UUID;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ApplicationClientFactory;
+import org.eclipse.hono.client.AsyncCommandClient;
+import org.eclipse.hono.client.CommandClient;
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.MessageConsumer;
+
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonDelivery;
+
+
+/**
+ * A factory for clients of Hono's north bound APIs.
+ *
+ */
+public class ApplicationClientFactoryImpl extends AbstractHonoClientFactory implements ApplicationClientFactory {
+
+    private final ClientFactory<MessageConsumer> consumerFactory;
+    private final CachingClientFactory<CommandClient> commandClientFactory;
+    private final CachingClientFactory<AsyncCommandClient> asyncCommandClientFactory;
+
+    /**
+     * Creates a new factory for an existing connection.
+     * 
+     * @param connection The connection to use.
+     */
+    public ApplicationClientFactoryImpl(final HonoConnection connection) {
+        super(connection);
+        consumerFactory = new ClientFactory<>();
+        commandClientFactory = new CachingClientFactory<>(c -> c.isOpen());
+        asyncCommandClientFactory = new CachingClientFactory<>(c -> c.isOpen());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<MessageConsumer> createTelemetryConsumer(
+            final String tenantId,
+            final Consumer<Message> messageConsumer,
+            final Handler<Void> closeHandler) {
+
+        return connection.executeOrRunOnContext(result -> {
+            consumerFactory.createClient(
+                    () -> TelemetryConsumerImpl.create(
+                            connection,
+                            tenantId,
+                            messageConsumer,
+                            closeHook -> closeHandler.handle(null)),
+                    result);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<MessageConsumer> createEventConsumer(
+            final String tenantId,
+            final Consumer<Message> eventConsumer,
+            final Handler<Void> closeHandler) {
+
+        return createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message), closeHandler);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<MessageConsumer> createEventConsumer(
+            final String tenantId,
+            final BiConsumer<ProtonDelivery, Message> messageConsumer,
+            final Handler<Void> closeHandler) {
+
+        return connection.executeOrRunOnContext(result -> {
+            consumerFactory.createClient(
+                    () -> EventConsumerImpl.create(
+                            connection,
+                            tenantId,
+                            messageConsumer,
+                            closeHook -> closeHandler.handle(null)),
+                    result);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String deviceId) {
+        return getOrCreateCommandClient(tenantId, deviceId, UUID.randomUUID().toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<CommandClient> getOrCreateCommandClient(
+            final String tenantId,
+            final String deviceId,
+            final String replyId) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(replyId);
+
+        log.debug("get or create command client for [tenantId: {}, deviceId: {}, replyId: {}]", tenantId, deviceId,
+                replyId);
+        return connection.executeOrRunOnContext(result -> {
+            final String targetAddress = CommandClientImpl.getTargetAddress(tenantId, deviceId);
+            commandClientFactory.getOrCreateClient(
+                    targetAddress,
+                    () -> CommandClientImpl.create(
+                            connection,
+                            tenantId,
+                            deviceId,
+                            replyId,
+                            s -> removeCommandClient(targetAddress),
+                            s -> removeCommandClient(targetAddress)),
+                    result);
+        });
+    }
+
+    private void removeCommandClient(final String key) {
+        commandClientFactory.removeClient(key, client -> {
+            client.close(s -> {});
+            log.debug("closed and removed client for [{}]", key);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<AsyncCommandClient> getOrCreateAsyncCommandClient(final String tenantId, final String deviceId) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+
+        return connection.executeOrRunOnContext(result -> {
+            final String targetAddress = AsyncCommandClientImpl.getTargetAddress(tenantId, deviceId);
+            asyncCommandClientFactory.getOrCreateClient(
+                    targetAddress,
+                    () -> AsyncCommandClientImpl.create(
+                            connection,
+                            tenantId,
+                            deviceId,
+                            s -> removeAsyncCommandClient(targetAddress)),
+                    result);
+        });
+    }
+
+    private void removeAsyncCommandClient(final String key) {
+        asyncCommandClientFactory.removeClient(key, client -> {
+            client.close(s -> {});
+            log.debug("closed and removed client for [{}]", key);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<MessageConsumer> createAsyncCommandResponseConsumer(
+            final String tenantId,
+            final String replyId,
+            final BiConsumer<ProtonDelivery, Message> consumer,
+            final Handler<Void> closeHandler) {
+
+        return connection.executeOrRunOnContext(result -> {
+            consumerFactory.createClient(
+                    () -> AsyncCommandResponseConsumerImpl.create(
+                            connection,
+                            tenantId,
+                            replyId,
+                            consumer,
+                            closeHook -> closeHandler.handle(null)),
+                    result);
+        });
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<MessageConsumer> createAsyncCommandResponseConsumer(
+            final String tenantId,
+            final String replyId,
+            final Consumer<Message> consumer,
+            final Handler<Void> closeHandler) {
+
+        return createAsyncCommandResponseConsumer(tenantId, replyId, (delivery, msg) -> consumer.accept(msg), closeHandler);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onDisconnect() {
+        asyncCommandClientFactory.clearState();
+        commandClientFactory.clearState();
+        consumerFactory.clearState();
+    }
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
index bb1a800fa..a80c0907f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandClientImpl.java
@@ -96,6 +96,21 @@ public class CommandClientImpl extends AbstractRequestResponseClient<BufferResul
         this.receiver = Objects.requireNonNull(receiver);
     }
 
+    /**
+     * Gets the AMQP <em>target</em> address to use for sending command requests
+     * to Hono's Command &amp; Control API endpoint.
+     * 
+     * @param tenantId The tenant that the device belongs to.
+     * @param deviceId The identifier of the device.
+     * @return The target address.
+     * @throws NullPointerException if tenant is {@code null}.
+     */
+    public static final String getTargetAddress(final String tenantId, final String deviceId) {
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        return String.format("%s/%s/%s", CommandConstants.COMMAND_ENDPOINT, tenantId, deviceId);
+    }
+
     @Override
     protected String getName() {
         return CommandConstants.COMMAND_ENDPOINT;
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index 1a40ca653..b7f58d676 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -16,44 +16,32 @@ import java.net.HttpURLConnection;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.UUID;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
 import java.util.function.Supplier;
 
 import javax.security.sasl.AuthenticationException;
 
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.message.Message;
-import org.eclipse.hono.client.AsyncCommandClient;
 import org.eclipse.hono.client.ClientErrorException;
-import org.eclipse.hono.client.CommandClient;
 import org.eclipse.hono.client.DisconnectListener;
 import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.MessageConsumer;
-import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.ReconnectListener;
-import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.HonoProtonHelper;
-import org.eclipse.hono.util.ResourceIdentifier;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.beans.factory.annotation.Autowired;
@@ -67,7 +55,6 @@ import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
 import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
-import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonLink;
 import io.vertx.proton.ProtonMessageHandler;
 import io.vertx.proton.ProtonQoS;
@@ -98,11 +85,6 @@ public class HonoConnectionImpl implements HonoConnection {
      * The configuration properties for this client.
      */
     protected final ClientConfigProperties clientConfigProperties;
-    /**
-     * The senders that can be used to send telemetry and or event messages.
-     * The target address is used as the key, e.g. <em>telemetry/DEFAULT_TENANT</em>.
-     */
-    protected final Map<String, MessageSender> activeSenders = new HashMap<>();
     /**
      * The vert.x instance to run on.
      */
@@ -117,8 +99,6 @@ public class HonoConnectionImpl implements HonoConnection {
      */
     protected volatile Context context;
 
-    private final Map<String, RequestResponseClient> activeRequestResponseClients = new HashMap<>();
-    private final Map<String, Boolean> creationLocks = new HashMap<>();
     private final List<Handler<Void>> creationRequests = new ArrayList<>();
     private final List<DisconnectListener> disconnectListeners = new ArrayList<>();
     private final List<ReconnectListener> reconnectListeners = new ArrayList<>();
@@ -500,8 +480,6 @@ public class HonoConnectionImpl implements HonoConnection {
 
         setConnection(null);
 
-        activeSenders.clear();
-        activeRequestResponseClients.clear();
         failAllCreationRequests();
         notifyDisconnectHandlers();
         // make sure we make configured number of attempts to re-connect
@@ -588,186 +566,6 @@ public class HonoConnectionImpl implements HonoConnection {
         }
     }
 
-    /**
-     * Gets an existing or creates a new message sender.
-     * <p>
-     * This method will first try to look up an already existing
-     * sender using the given key. If no sender exists yet, a new
-     * instance is created using the given factory and put to the cache.
-     * 
-     * @param key The key to cache the sender under.
-     * @param newSenderSupplier The factory to use for creating a
-     *        new sender (if necessary).
-     * @return A future indicating the outcome. The future will be
-     *         completed with the sender or failed with a
-     *         {@link ServiceInvocationException} if no sender could be
-     *         created using the factory.
-     */
-    protected Future<MessageSender> getOrCreateSender(
-            final String key,
-            final Supplier<Future<MessageSender>> newSenderSupplier) {
-
-        return executeOrRunOnContext(result -> getOrCreateSender(key, newSenderSupplier, result));
-    }
-
-    /**
-     * Builds a unique resources key for the given message sender class and target address for caching.
-     *
-     * @param senderClass The class of the sender.
-     * @param targetAddress The target address of the sender.
-     * @return A key to cache the sender.
-     */
-    private static String getResourcesKeyForSender(final Class<?> senderClass, final String targetAddress) {
-        return senderClass.getSimpleName() + '#' + targetAddress;
-    }
-
-    private void getOrCreateSender(
-            final String key,
-            final Supplier<Future<MessageSender>> newSenderSupplier,
-            final Future<MessageSender> result) {
-
-        final MessageSender sender = activeSenders.get(key);
-        if (sender != null && sender.isOpen()) {
-            log.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
-            result.tryComplete(sender);
-        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
-            // register a handler to be notified if the underlying connection to the server fails
-            // so that we can fail the result handler passed in
-            final Handler<Void> connectionFailureHandler = connectionLost -> {
-                // remove lock so that next attempt to open a sender doesn't fail
-                creationLocks.remove(key);
-                result.tryFail(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-            };
-            creationRequests.add(connectionFailureHandler);
-            creationLocks.put(key, Boolean.TRUE);
-            log.debug("creating new message sender for {}", key);
-
-            newSenderSupplier.get().setHandler(creationAttempt -> {
-                creationLocks.remove(key);
-                creationRequests.remove(connectionFailureHandler);
-                if (creationAttempt.succeeded()) {
-                    final MessageSender newSender = creationAttempt.result();
-                    log.debug("successfully created new message sender for {}", key);
-                    activeSenders.put(key, newSender);
-                    result.complete(newSender);
-                } else {
-                    log.debug("failed to create new message sender for {}", key, creationAttempt.cause());
-                    activeSenders.remove(key);
-                    result.tryFail(creationAttempt.cause());
-                }
-            });
-
-        } else {
-            log.debug("already trying to create a message sender for {}", key);
-            result.tryFail(new ServerErrorException(
-                    HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createTelemetryConsumer(
-            final String tenantId,
-            final Consumer<Message> messageConsumer,
-            final Handler<Void> closeHandler) {
-
-        return createConsumer(
-                tenantId,
-                () -> newTelemetryConsumer(tenantId, messageConsumer, closeHandler));
-    }
-
-    private Future<MessageConsumer> newTelemetryConsumer(
-            final String tenantId,
-            final Consumer<Message> messageConsumer,
-            final Handler<Void> closeHandler) {
-
-        return checkConnected().compose(con -> 
-            TelemetryConsumerImpl.create(this, tenantId, messageConsumer, closeHook -> closeHandler.handle(null))
-        );
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createEventConsumer(
-            final String tenantId,
-            final Consumer<Message> eventConsumer,
-            final Handler<Void> closeHandler) {
-
-        return createEventConsumer(tenantId, (delivery, message) -> eventConsumer.accept(message), closeHandler);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createEventConsumer(
-            final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> messageConsumer,
-            final Handler<Void> closeHandler) {
-
-        return createConsumer(
-                tenantId,
-                () -> newEventConsumer(tenantId, messageConsumer, closeHandler));
-    }
-
-    private Future<MessageConsumer> newEventConsumer(
-            final String tenantId,
-            final BiConsumer<ProtonDelivery, Message> messageConsumer,
-            final Handler<Void> closeHandler) {
-
-        return checkConnected().compose(con -> 
-            EventConsumerImpl.create(this, tenantId, messageConsumer, closeHook -> closeHandler.handle(null))
-        );
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createAsyncCommandResponseConsumer(
-            final String tenantId, final String replyId,
-            final Consumer<Message> consumer,
-            final Handler<Void> closeHandler) {
-
-        return createAsyncCommandResponseConsumer(tenantId, replyId,
-                (delivery, message) -> consumer.accept(message), closeHandler);
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public final Future<MessageConsumer> createAsyncCommandResponseConsumer(
-            final String tenantId, final String replyId,
-            final BiConsumer<ProtonDelivery, Message> consumer,
-            final Handler<Void> closeHandler) {
-
-        return createConsumer(
-                tenantId,
-                () -> newAsyncCommandResponseConsumer(tenantId, replyId, consumer, closeHandler));
-    }
-
-    private Future<MessageConsumer> newAsyncCommandResponseConsumer(
-            final String tenantId,
-            final String replyId,
-            final BiConsumer<ProtonDelivery, Message> messageConsumer,
-            final Handler<Void> closeHandler) {
-
-        return checkConnected().compose(con -> {
-            return AsyncCommandResponseConsumerImpl.create(
-                    this,
-                    tenantId,
-                    replyId,
-                    messageConsumer,
-                    closeHook -> closeHandler.handle(null));
-        });
-    }
-
     /**
      * Creates a new message consumer for a tenant.
      * 
@@ -809,139 +607,6 @@ public class HonoConnectionImpl implements HonoConnection {
         });
     }
 
-    private void removeActiveRequestResponseClient(final String targetAddress) {
-
-        final RequestResponseClient client = activeRequestResponseClients.remove(targetAddress);
-        if (client != null) {
-            client.close(s -> {
-            });
-            log.debug("closed and removed client for [{}]", targetAddress);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String deviceId) {
-        return getOrCreateCommandClient(tenantId, deviceId, UUID.randomUUID().toString());
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Future<CommandClient> getOrCreateCommandClient(final String tenantId, final String deviceId,
-            final String replyId) {
-
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-        Objects.requireNonNull(replyId);
-
-        log.debug("get or create command client for [tenantId: {}, deviceId: {}, replyId: {}]", tenantId, deviceId,
-                replyId);
-        return getOrCreateRequestResponseClient(
-                ResourceIdentifier.from(CommandConstants.COMMAND_ENDPOINT, tenantId, deviceId).toString(),
-                () -> newCommandClient(tenantId, deviceId, replyId)).map(c -> (CommandClient) c);
-    }
-
-    private Future<RequestResponseClient> newCommandClient(final String tenantId, final String deviceId,
-            final String replyId) {
-        return checkConnected().compose(connected -> {
-            return CommandClientImpl.create(
-                    this,
-                    tenantId,
-                    deviceId,
-                    replyId,
-                    this::removeActiveRequestResponseClient,
-                    this::removeActiveRequestResponseClient)
-             .map(client -> (RequestResponseClient) client);
-        });
-    }
-
-    @Override
-    public Future<AsyncCommandClient> getOrCreateAsyncCommandClient(final String tenantId, final String deviceId) {
-        Objects.requireNonNull(tenantId);
-        Objects.requireNonNull(deviceId);
-
-        return getOrCreateSender(
-                getResourcesKeyForSender(AsyncCommandClientImpl.class, AsyncCommandClientImpl.getTargetAddress(tenantId,
-                        deviceId)),
-                () -> newAsyncCommandClient(tenantId, deviceId)).map(client -> (AsyncCommandClient) client);
-    }
-
-    private Future<MessageSender> newAsyncCommandClient(final String tenantId, final String deviceId) {
-        return checkConnected().compose(connected -> {
-            return AsyncCommandClientImpl.create(
-                    this,
-                    tenantId,
-                    deviceId,
-                    onSenderClosed -> {
-                        activeSenders.remove(getResourcesKeyForSender(AsyncCommandClientImpl.class,
-                                AsyncCommandClientImpl.getTargetAddress(tenantId,
-                                        deviceId)));
-                    })
-             .map(client -> (MessageSender) client);
-        });
-    }
-
-    /**
-     * Gets an existing or creates a new request-response client for a particular service.
-     *
-     * @param key The key to look-up the client by.
-     * @param clientSupplier A consumer for an attempt to create a new client.
-     * @return A future indicating the outcome of the operation.
-     */
-    protected Future<RequestResponseClient> getOrCreateRequestResponseClient(
-            final String key,
-            final Supplier<Future<RequestResponseClient>> clientSupplier) {
-
-        return executeOrRunOnContext(result -> getOrCreateRequestResponseClient(key, clientSupplier, result));
-    }
-
-    private void getOrCreateRequestResponseClient(
-            final String key,
-            final Supplier<Future<RequestResponseClient>> clientSupplier,
-            final Future<RequestResponseClient> result) {
-
-        final RequestResponseClient client = activeRequestResponseClients.get(key);
-        if (client != null && client.isOpen()) {
-            log.debug("reusing existing client [target: {}]", key);
-            result.complete(client);
-        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
-
-            // register a handler to be notified if the underlying connection to the server fails
-            // so that we can fail the result handler passed in
-            final Handler<Void> connectionFailureHandler = connectionLost -> {
-                // remove lock so that next attempt to open a sender doesn't fail
-                creationLocks.remove(key);
-                result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-            };
-            creationRequests.add(connectionFailureHandler);
-            creationLocks.put(key, Boolean.TRUE);
-            log.debug("creating new client [target: {}]", key);
-
-            clientSupplier.get().setHandler(creationAttempt -> {
-                if (creationAttempt.succeeded()) {
-                    log.debug("successfully created new client [target: {}]", key);
-                    activeRequestResponseClients.put(key, creationAttempt.result());
-                    result.tryComplete(creationAttempt.result());
-                } else {
-                    log.debug("failed to create new client [target: {}]", key, creationAttempt.cause());
-                    activeRequestResponseClients.remove(key);
-                    result.tryFail(creationAttempt.cause());
-                }
-                creationLocks.remove(key);
-                creationRequests.remove(connectionFailureHandler);
-            });
-
-        } else {
-            log.debug("already trying to create a client [target: {}]", key);
-            result.fail(new ServerErrorException(
-                    HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
-        }
-    }
-
     /**
      * {@inheritDoc}
      * 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
index d145638ef..b28e3c885 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
@@ -34,6 +34,29 @@ import io.vertx.ext.unit.junit.VertxUnitRunner;
 @RunWith(VertxUnitRunner.class)
 public class CachingClientFactoryTest {
 
+    /**
+     * Verifies that a request to create a client fails if the given
+     * supplier fails.
+     * 
+     * @param ctx The helper to use for running async tests.
+     */
+    @Test
+    public void testGetOrCreateClientFailsIfSupplierFails(final TestContext ctx) {
+
+        // GIVEN a factory
+        final CachingClientFactory<Object> factory = new CachingClientFactory<>(o -> true);
+        // WHEN creating a client instance and the supplier returns a failed future
+        factory.getOrCreateClient(
+                "bumlux",
+                () -> Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE)),
+                ctx.asyncAssertFailure(t -> {
+                    // THEN the creation fails with the exception conveyed by the supplier
+                    ctx.assertEquals(
+                            HttpURLConnection.HTTP_UNAVAILABLE,
+                            ((ServerErrorException) t).getErrorCode());
+                }));
+    }
+
     /**
      * Verifies that a concurrent request to create a client fails the given
      * future for tracking the attempt.
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index 15c01435e..23e57dd7c 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -39,9 +39,6 @@ import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.amqp.transport.Source;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.HonoConnection;
-import org.eclipse.hono.client.MessageSender;
-import org.eclipse.hono.client.RegistrationClient;
-import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
@@ -247,146 +244,6 @@ public class HonoConnectionImplTest {
         assertTrue(connectionFactory.awaitFailure());
     }
 
-    /**
-     * Verifies that a request to create a request-response client fails the given
-     * future for tracking the attempt if the client is not connected to the peer.
-     * 
-     * @param ctx The helper to use for running async tests.
-     */
-    @Test
-    public void testGetOrCreateRequestResponseClientFailsWhenNotConnected(final TestContext ctx) {
-
-        honoConnection.getOrCreateRequestResponseClient("the-key", () -> Future.succeededFuture(mock(RequestResponseClient.class)))
-        .setHandler(ctx.asyncAssertFailure(t -> {
-            ctx.assertTrue(t instanceof ServerErrorException);
-        }));
-    }
-
-    /**
-     * Verifies that a concurrent request to create a request-response client fails the given
-     * future for tracking the attempt.
-     * 
-     * @param ctx The helper to use for running async tests.
-     */
-    @Test
-    public void testGetOrCreateRequestResponseClientFailsIfInvokedConcurrently(final TestContext ctx) {
-
-        // GIVEN a client that already tries to create a registration client for "tenant"
-        final Async connected = ctx.async();
-        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
-
-        honoConnection.getOrCreateRequestResponseClient(
-                "registration/tenant",
-                () -> Future.future());
-
-        // WHEN an additional, concurrent attempt is made to create a client for "tenant"
-        honoConnection.getOrCreateRequestResponseClient(
-                "registration/tenant",
-                () -> {
-                    ctx.fail("should not create concurrent client");
-                    return Future.succeededFuture(mock(RegistrationClient.class));
-                }).setHandler(ctx.asyncAssertFailure(t -> {
-                    // THEN the concurrent attempt fails without any attempt being made to create another client
-                    ctx.assertTrue(ServerErrorException.class.isInstance(t));
-                }));
-    }
-
-    /**
-     * Verifies that a request to create a request-response client is failed immediately when the
-     * underlying connection to the server fails.
-     * 
-     * @param ctx The Vertx test context.
-     */
-    @Test
-    public void testGetOrCreateRequestResponseClientFailsOnConnectionFailure(final TestContext ctx) {
-
-        // GIVEN a client that tries to create a registration client for "tenant"
-        final Async connected = ctx.async();
-        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
-
-        final Async creationFailure = ctx.async();
-        final Async supplierInvocation = ctx.async();
-
-        honoConnection.getOrCreateRequestResponseClient(
-                "registration/tenant",
-                () -> {
-                    ctx.assertFalse(creationFailure.isCompleted());
-                    supplierInvocation.complete();
-                    return Future.future();
-                }).setHandler(ctx.asyncAssertFailure(cause -> creationFailure.complete()));
-
-        // WHEN the underlying connection fails
-        supplierInvocation.await();
-        connectionFactory.getDisconnectHandler().handle(con);
-
-        // THEN all creation requests are failed
-        creationFailure.await();
-    }
-
-    /**
-     * Verifies that a concurrent request to create a sender fails the given future for tracking the attempt.
-     * 
-     * @param ctx The helper to use for running async tests.
-     */
-    @Test
-    public void testGetOrCreateTelemetrySenderFailsIfInvokedConcurrently(final TestContext ctx) {
-
-        // GIVEN a client that already tries to create a telemetry sender for "tenant"
-        final Async connected = ctx.async();
-        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
-
-        honoConnection.getOrCreateSender("telemetry/tenant", () -> Future.future());
-
-        // WHEN an additional, concurrent attempt is made to create a telemetry sender for "tenant"
-        honoConnection.getOrCreateSender(
-                "telemetry/tenant",
-                () -> {
-                    ctx.fail("should not create concurrent client");
-                    return Future.succeededFuture(mock(MessageSender.class));
-                }).setHandler(ctx.asyncAssertFailure(t -> {
-                    // THEN the concurrent attempt fails without any attempt being made to create another sender
-                    ctx.assertTrue(ServerErrorException.class.isInstance(t));
-                }));
-    }
-
-    /**
-     * Verifies that a request to create a message sender is failed immediately when the
-     * underlying connection to the server fails.
-     * 
-     * @param ctx The Vertx test context.
-     */
-    @Test
-    public void testGetOrCreateSenderFailsOnConnectionFailure(final TestContext ctx) {
-
-        // GIVEN a client that tries to create a telemetry sender for "tenant"
-        final Async connected = ctx.async();
-        honoConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
-
-        final Async disconnected = ctx.async();
-        final Async supplierInvocation = ctx.async();
-
-        honoConnection.getOrCreateSender(
-                "telemetry/tenant",
-                () -> {
-                    ctx.assertFalse(disconnected.isCompleted());
-                    supplierInvocation.complete();
-                    return Future.future();
-                }).setHandler(ctx.asyncAssertFailure(cause -> {
-                    disconnected.complete();
-                }));
-
-        // WHEN the underlying connection fails
-        supplierInvocation.await();
-        connectionFactory.getDisconnectHandler().handle(con);
-
-        // THEN all creation requests are failed
-        disconnected.await();
-    }
-
     /**
      * Verifies that a request to create a consumer is failed immediately when the
      * underlying connection to the server fails.
@@ -421,41 +278,6 @@ public class HonoConnectionImplTest {
         creationFailure.await();
     }
 
-    /**
-     * Verifies that all sender creation locks are cleared when the connection to the server fails.
-     * 
-     * @param ctx The Vertx test context.
-     */
-    @Test
-    public void testDownstreamDisconnectClearsSenderCreationLocks(final TestContext ctx) {
-
-        // GIVEN a client connected to a peer
-        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
-        final ProtonClientOptions options = new ProtonClientOptions()
-                .setReconnectInterval(50)
-                .setReconnectAttempts(0);
-        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        honoConnection.connect(options).setHandler(ctx.asyncAssertSuccess());
-        assertTrue(connectionFactory.await());
-        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
-
-        // WHEN the downstream connection fails just when the client wants to open a sender link
-        final Async senderCreationFailure = ctx.async();
-        honoConnection.getOrCreateSender("telemetry/tenant", () -> {
-            connectionFactory.getDisconnectHandler().handle(con);
-            return Future.future();
-        }).setHandler(ctx.asyncAssertFailure(cause -> senderCreationFailure.complete()));
-
-        // THEN the sender creation fails,
-        senderCreationFailure.await();
-        // the connection is re-established
-        assertTrue(connectionFactory.await());
-        // and the next attempt to create a sender succeeds
-        honoConnection.getOrCreateSender(
-                "telemetry/tenant",
-                () -> Future.succeededFuture(mock(MessageSender.class))).setHandler(ctx.asyncAssertSuccess());
-    }
-
     /**
      * Verifies that the client tries to re-establish a lost connection to a server.
      * 
