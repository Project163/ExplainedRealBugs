diff --git a/client/pom.xml b/client/pom.xml
index adce80640..dd9c7480a 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -27,16 +27,17 @@
 
   <dependencies>
     <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>hono-api</artifactId>
+      <groupId>org.slf4j</groupId>
+      <artifactId>slf4j-api</artifactId>
     </dependency>
     <dependency>
-      <groupId>com.rabbitmq</groupId>
-      <artifactId>amqp-client</artifactId>
+      <groupId>org.eclipse.hono</groupId>
+      <artifactId>vertx-proton</artifactId>
     </dependency>
     <dependency>
-      <groupId>ch.qos.logback</groupId>
-      <artifactId>logback-classic</artifactId>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
     </dependency>
   </dependencies>
 
diff --git a/client/src/main/java/org/eclipse/hono/client/AmqpConnectionConfig.java b/client/src/main/java/org/eclipse/hono/client/AmqpConnectionConfig.java
deleted file mode 100644
index 5c1aed4a5..000000000
--- a/client/src/main/java/org/eclipse/hono/client/AmqpConnectionConfig.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/**
- * Copyright (c) 2016 Bosch Software Innovations GmbH.
- *
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Bosch Software Innovations GmbH - initial API and implementation and initial documentation
- */
-package org.eclipse.hono.client;
-
-import static java.util.Objects.requireNonNull;
-
-import org.eclipse.hono.client.api.ConnectionConfig;
-
-public class AmqpConnectionConfig implements ConnectionConfig {
-    private static final String AMQP_PREFIX = "amqp://";
-    private final String        uri;
-
-    public AmqpConnectionConfig(final String uri) {
-        requireNonNull(uri, "AMQP uri must not be null");
-        if (!uri.toLowerCase().startsWith(AMQP_PREFIX)) {
-            throw new IllegalArgumentException("AMQP uri must begin with \"amqp://\"");
-        } else {
-            this.uri = uri;
-        }
-    }
-
-    public AmqpConnectionConfig(final String host, final String port) {
-        this(host, port, null, null, null);
-    }
-
-    public AmqpConnectionConfig(final String host, final String port, final String username, final String password,
-            final String vhost) {
-        this.uri = createConnectionUri(requireNonNull(host, "amqp host must be specified."),
-                requireNonNull(port, "amqp port must be specified."),
-                username,
-                password,
-                vhost);
-    }
-
-    private String createConnectionUri(final String host, final String port, final String username,
-            final String password, final String vhost) {
-        final StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.append(AmqpConnectionConfig.AMQP_PREFIX);
-        if (username != null && password != null) {
-            stringBuilder.append(username).append(":").append(password).append("@");
-        }
-        stringBuilder.append(host).append(":").append(port);
-        if (vhost != null) {
-            stringBuilder.append("/").append(vhost);
-        }
-        return stringBuilder.toString();
-    }
-
-    @Override
-    public String getConnectionUri() {
-        return uri;
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/AmqpConnectionManager.java b/client/src/main/java/org/eclipse/hono/client/AmqpConnectionManager.java
deleted file mode 100644
index 933a1d424..000000000
--- a/client/src/main/java/org/eclipse/hono/client/AmqpConnectionManager.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Copyright (c) 2016 Bosch Software Innovations GmbH.
- *
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Bosch Software Innovations GmbH - initial API and implementation and initial documentation
- */
-package org.eclipse.hono.client;
-
-import java.io.IOException;
-
-import org.eclipse.hono.client.api.ConnectionManager;
-
-import com.rabbitmq.client.Channel;
-
-public interface AmqpConnectionManager extends ConnectionManager {
-    Channel getChannel() throws IOException;
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/AmqpConnectionManagerImpl.java b/client/src/main/java/org/eclipse/hono/client/AmqpConnectionManagerImpl.java
deleted file mode 100644
index 5be6a3a43..000000000
--- a/client/src/main/java/org/eclipse/hono/client/AmqpConnectionManagerImpl.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Copyright (c) 2016 Bosch Software Innovations GmbH.
- *
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Bosch Software Innovations GmbH - initial API and implementation and initial documentation
- */
-package org.eclipse.hono.client;
-
-import java.io.IOException;
-import java.net.URISyntaxException;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
-import java.util.concurrent.TimeoutException;
-
-import org.eclipse.hono.client.api.ConnectionConfig;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.rabbitmq.client.Channel;
-import com.rabbitmq.client.Connection;
-import com.rabbitmq.client.ConnectionFactory;
-import com.rabbitmq.client.impl.DefaultExceptionHandler;
-
-public class AmqpConnectionManagerImpl implements AmqpConnectionManager {
-    private static Connection   connection;
-
-    private static final Object SYNC   = new Object();
-    private static final Logger LOGGER = LoggerFactory.getLogger(AmqpConnectionManagerImpl.class);
-
-    @Override
-    public void connect(final ConnectionConfig connectionConfig)
-            throws URISyntaxException, IOException, TimeoutException, NoSuchAlgorithmException, KeyManagementException {
-        synchronized (AmqpConnectionManagerImpl.SYNC) {
-            if (AmqpConnectionManagerImpl.connection == null) {
-                AmqpConnectionManagerImpl.connection = createConnection(connectionConfig);
-            }
-        }
-    }
-
-    @Override
-    public void disconnect() throws IOException {
-        synchronized (AmqpConnectionManagerImpl.SYNC) {
-            AmqpConnectionManagerImpl.connection.close();
-        }
-    }
-
-    @Override
-    public Channel getChannel() throws IOException {
-        if (AmqpConnectionManagerImpl.connection == null) {
-            AmqpConnectionManagerImpl.LOGGER.error("Connection doesn't established jet");
-            return null;
-        } else {
-            return AmqpConnectionManagerImpl.connection.createChannel();
-        }
-    }
-
-    private Connection createConnection(final ConnectionConfig connectionConfig)
-            throws NoSuchAlgorithmException, KeyManagementException, URISyntaxException, IOException, TimeoutException {
-        final ConnectionFactory factory = new ConnectionFactory();
-        final String amqpUri = connectionConfig.getConnectionUri();
-        AmqpConnectionManagerImpl.LOGGER.info("Connecting to " + amqpUri);
-        factory.setUri(amqpUri);
-        factory.setAutomaticRecoveryEnabled(true);
-        factory.setExceptionHandler(new DefaultExceptionHandler());
-        return factory.newConnection();
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/AmqpConnectorClient.java b/client/src/main/java/org/eclipse/hono/client/AmqpConnectorClient.java
deleted file mode 100644
index e29d60621..000000000
--- a/client/src/main/java/org/eclipse/hono/client/AmqpConnectorClient.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/**
- * Copyright (c) 2016 Bosch Software Innovations GmbH.
- *
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Bosch Software Innovations GmbH - initial API and implementation and initial documentation
- */
-package org.eclipse.hono.client;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Collections.emptyMap;
-import static java.util.Objects.requireNonNull;
-import static java.util.Optional.ofNullable;
-
-import java.io.IOException;
-import java.net.URISyntaxException;
-import java.nio.ByteBuffer;
-import java.security.KeyManagementException;
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.TimeoutException;
-import java.util.function.Consumer;
-import java.util.stream.Collectors;
-
-import org.eclipse.hono.client.api.ConnectionConfig;
-import org.eclipse.hono.client.api.ConnectorClient;
-import org.eclipse.hono.client.api.model.Message;
-import org.eclipse.hono.client.api.model.TopicAcl;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.rabbitmq.client.AMQP;
-import com.rabbitmq.client.Channel;
-import com.rabbitmq.client.DefaultConsumer;
-import com.rabbitmq.client.Envelope;
-
-public class AmqpConnectorClient implements ConnectorClient
-{
-   private static final Logger LOGGER = LoggerFactory.getLogger(AmqpConnectorClient.class);
-   public static final String OUT = "out";
-   public static final String IN = "in";
-   public static final String MESSAGE = "message";
-   public static final String REGISTER_TOPIC = "registerTopic";
-   public static final String TOPIC_HEADER = "topic";
-   public static final String SUBJECT_HEADER = "subject";
-
-   private final ConcurrentMap<String, Collection<Consumer<Message>>> consumers = new ConcurrentHashMap<>();
-   private final String clientId;
-   private final ConnectionConfig connectionConfig;
-   private final AmqpConnectionManagerImpl connectionManager;
-   private Channel channel;
-   private String consumerTag;
-
-   public AmqpConnectorClient(final String clientId, final ConnectionConfig connectionConfig) throws Exception
-   {
-      requireNonNull(connectionConfig);
-      requireNonNull(clientId);
-      this.clientId = clientId;
-      this.connectionConfig = connectionConfig;
-      connectionManager = new AmqpConnectionManagerImpl();
-   }
-
-   public void connect()
-      throws IOException, TimeoutException, NoSuchAlgorithmException, KeyManagementException, URISyntaxException
-   {
-      connectionManager.connect(connectionConfig);
-      LOGGER.info("connection established.");
-      declareBindQueue();
-   }
-
-   private void declareBindQueue() throws IOException
-   {
-      channel = connectionManager.getChannel();
-      channel.queueDeclare(clientId, true, false, false, emptyMap());
-      LOGGER.info("declared a queue with subject " + clientId);
-      channel.queueBind(clientId, OUT, clientId);
-      LOGGER.info("bind queue to routingkey " + clientId);
-      consumerTag = channel.basicConsume(clientId, new DefaultConsumer(channel)
-      {
-         @Override
-         public void handleDelivery(final String consumerTag, final Envelope envelope,
-            final AMQP.BasicProperties properties, final byte[] body) throws IOException
-         {
-            final String routingKey = envelope.getRoutingKey();
-            getChannel().basicAck(envelope.getDeliveryTag(), false);
-            final String topic = properties.getHeaders().get(TOPIC_HEADER).toString();
-            LOGGER.debug("{} received message for topic '{}'", routingKey, topic);
-            delegateToTopicConsumer(properties, body, topic);
-         }
-      });
-   }
-
-   private void delegateToTopicConsumer(final AMQP.BasicProperties properties, final byte[] body, final String topic)
-      throws IOException
-   {
-      final Map<String, String> headers =
-         properties.getHeaders().entrySet().stream().filter(e -> e.getValue() instanceof String)
-            .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().toString()));
-      final AmqpMessage message = new AmqpMessage(topic, headers, ByteBuffer.wrap(body));
-      ofNullable(consumers.get(topic)).ifPresent(consumerList -> consumerList.forEach(c -> c.accept(message)));
-   }
-
-   public void disconnect() throws IOException, TimeoutException
-   {
-      channel.basicCancel(consumerTag);
-      channel.close();
-      connectionManager.disconnect();
-   }
-
-   @Override
-   public void registerTopic(final String clientId, final String topic, final TopicAcl topicAcl) throws IOException
-   {
-      final Map<String, Object> headers = new HashMap<>();
-      headers.put(SUBJECT_HEADER, clientId);
-      headers.put(TOPIC_HEADER, topic);
-      final AMQP.BasicProperties props = new AMQP.BasicProperties().builder().headers(headers).build();
-      channel.basicPublish(IN, REGISTER_TOPIC, true, props, topicAcl.toBytes());
-   }
-
-   @Override
-   public void deregisterTopic(final String clientId)
-   {
-      // todo client to remove topic in backend.
-   }
-
-   public void sendMessage(final String topic, final Map<String, String> customHeaders, final ByteBuffer payload)
-      throws IOException
-   {
-      final Map<String, Object> headers = new HashMap<>();
-      headers.putAll(customHeaders);
-      headers.put(TOPIC_HEADER, topic);
-      headers.put(SUBJECT_HEADER, clientId);
-      final AMQP.BasicProperties props = new AMQP.BasicProperties().builder().headers(headers).build();
-      channel.basicPublish(IN, MESSAGE, props, payload.array());
-      LOGGER.debug("Sent message for topic {}: {}", topic, UTF_8.decode(payload).toString());
-   }
-
-   @Override
-   public void subscriptionForTopic(final String topic, final Consumer<Message> handler) throws IOException
-   {
-      requireNonNull(topic);
-      this.consumers.computeIfAbsent(topic, t -> new ArrayList<>()).add(handler);
-   }
-
-   @Override
-   public void desubscriptionForTopic(final String topic) throws IOException
-   {
-      //todo client to delete topic from backend
-      this.consumers.remove(topic);
-   }
-}
-
diff --git a/client/src/main/java/org/eclipse/hono/client/AmqpMessage.java b/client/src/main/java/org/eclipse/hono/client/AmqpMessage.java
deleted file mode 100644
index 3e11e7f1f..000000000
--- a/client/src/main/java/org/eclipse/hono/client/AmqpMessage.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) 2016 Bosch Software Innovations GmbH.
- *
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *    Bosch Software Innovations GmbH - initial API and implementation and initial documentation
- */
-package org.eclipse.hono.client;
-
-import java.nio.ByteBuffer;
-import java.util.Collections;
-import java.util.Map;
-
-import org.eclipse.hono.client.api.model.Message;
-
-public class AmqpMessage implements Message {
-    private final String              topic;
-    private final Map<String, String> headers;
-    private final ByteBuffer          payload;
-
-    public AmqpMessage(final String topic, final Map<String, String> headers, final ByteBuffer payload) {
-        this.topic = topic;
-        this.headers = headers;
-        this.payload = payload;
-    }
-
-    @Override
-    public String getTopic() {
-        return topic;
-    }
-
-    @Override
-    public Map<String, String> getHeaders() {
-        return Collections.unmodifiableMap(headers);
-    }
-
-    @Override
-    public ByteBuffer getPayload() {
-        return payload.asReadOnlyBuffer();
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/TelemetryClient.java b/client/src/main/java/org/eclipse/hono/client/TelemetryClient.java
new file mode 100644
index 000000000..d14d499d0
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/TelemetryClient.java
@@ -0,0 +1,177 @@
+/**
+ * Copyright (c) 2016 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+package org.eclipse.hono.client;
+
+import java.nio.ByteBuffer;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Consumer;
+
+import javax.annotation.PreDestroy;
+
+import org.apache.qpid.proton.amqp.messaging.AmqpValue;
+import org.apache.qpid.proton.amqp.messaging.Data;
+import org.apache.qpid.proton.amqp.messaging.Section;
+import org.apache.qpid.proton.message.Message;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Vertx;
+import io.vertx.proton.ProtonClient;
+import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * A sample client for uploading and retrieving telemetry data to/from Hono.
+ */
+public class TelemetryClient {
+
+    private static final Logger LOG = LoggerFactory.getLogger(TelemetryClient.class);
+    public static final String SENDER_TARGET_ADDRESS = "telemetry/%s";
+    public static final String RECEIVER_SOURCE_ADDRESS = "telemetry/%s";
+    public static final String SENDER_TO_PROPERTY = "telemetry/%s/%s";
+    public static final int DEFAULT_RECEIVER_CREDITS = 20;
+
+    private final Vertx                               vertx;
+    private final CompletableFuture<ProtonConnection> connection;
+    private volatile ProtonSender                        honoSender;
+    private final AtomicLong messageTagCounter = new AtomicLong();
+    private final String host;
+    private final int    port;
+    private final String tenantId;
+
+    public TelemetryClient(final String host, final int port, final String tenantId) {
+        this.host = host;
+        this.port = port;
+        this.tenantId = tenantId;
+        vertx = Vertx.vertx();
+        connection = new CompletableFuture<>();
+        connection.whenComplete((o,t) -> {
+            if (t != null)
+            {
+                LOG.info("Connection to Hono ({}:{}) failed.", host, port, t);
+            }
+        });
+        connectToHono();
+    }
+
+    private void connectToHono() {
+        final ProtonClient client = ProtonClient.create(vertx);
+        client.connect(host, port, conAttempt -> {
+            if (conAttempt.succeeded()) {
+                LOG.debug("connected to Hono server [{}:{}]", host, port);
+                conAttempt.result()
+                        .openHandler(conOpen -> {
+                            if (conOpen.succeeded()) {
+                                connection.complete(conOpen.result());
+                            } else {
+                                connection.completeExceptionally(conOpen.cause());
+                            }
+                        })
+                        .closeHandler(loggingHandler("connection closed"))
+                        .open();
+            } else {
+                connection.completeExceptionally(conAttempt.cause());
+            }
+        });
+    }
+
+    public Future<Void> createSender() throws Exception {
+        final Future<Void> future = Future.future();
+        connection.thenAccept(connection ->
+        {
+            final String address = String.format(SENDER_TARGET_ADDRESS, tenantId);
+            final ProtonSender sender = connection.createSender(address);
+            sender.openHandler(senderOpen -> {
+                if (senderOpen.succeeded()) {
+                    honoSender = senderOpen.result();
+                    LOG.info("sender open to [{}]", honoSender.getRemoteTarget());
+                    future.complete();
+                } else {
+                    future.fail(new IllegalStateException("cannot open sender for telemetry data", senderOpen.cause()));
+                }
+            }).closeHandler(loggingHandler("sender closed")).open();
+        });
+        return future;
+    }
+
+    public Future<Void> createReceiver(final Consumer<String> consumer) throws Exception {
+        final Future<Void> future = Future.future();
+        connection.thenAccept(connection ->
+        {
+            final String address = String.format(RECEIVER_SOURCE_ADDRESS, tenantId);
+            LOG.info("creating receiver at [{}]", address);
+            connection.createReceiver(address)
+                    .openHandler(recOpen -> {
+                        if (recOpen.succeeded()) {
+                            LOG.info("reading telemetry data for tenant [{}]", tenantId);
+                            future.complete();
+                        } else {
+                            LOG.info("reading telemetry data for tenant [{}] failed", tenantId, recOpen.cause());
+                            future.fail(recOpen.cause());
+                        }
+                    })
+                    .closeHandler(loggingHandler("receiver closed"))
+                    .handler((delivery, msg) -> {
+                        final Section section = msg.getBody();
+                        String content = null;
+                        if (section == null) {
+                            content = "empty";
+                        } else if (section instanceof Data) {
+                            content = ((Data) section).toString();
+                        } else if (section instanceof AmqpValue) {
+                            content = ((AmqpValue) section).toString();
+                        }
+                        consumer.accept(content);
+                        ProtonHelper.accepted(delivery, true);
+                    }).flow(DEFAULT_RECEIVER_CREDITS).open();
+        });
+        return future;
+    }
+
+    public void send(final String deviceId, final String body)
+    {
+        if (honoSender != null) {
+            final ByteBuffer b = ByteBuffer.allocate(8);
+            b.putLong(messageTagCounter.getAndIncrement());
+            b.flip();
+            final String address = String.format(SENDER_TO_PROPERTY, tenantId, deviceId);
+            final Message msg = ProtonHelper.message(address, body);
+            honoSender.send(b.array(), msg);
+            b.clear();
+        }
+        else {
+            LOG.info("Create sender first..");
+        }
+    }
+
+    @PreDestroy
+    public void shutdown() {
+        connection.thenAccept(ProtonConnection::close);
+        vertx.close();
+    }
+
+    private <T> Handler<AsyncResult<T>> loggingHandler(final String label)
+    {
+        return result -> {
+            if (result.succeeded()) {
+                LOG.info("{} [{}]", label, tenantId);
+            } else {
+                LOG.info("{} [{}]", label, tenantId, result.cause());
+            }
+        };
+    }
+}
