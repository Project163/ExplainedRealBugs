diff --git a/client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java b/client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java
index 5f652d558..ba18148d2 100644
--- a/client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/AuthenticationServerClient.java
@@ -101,7 +101,7 @@ public final class AuthenticationServerClient {
 
         connectAttempt.future()
         .compose(openCon -> getToken(openCon))
-        .setHandler(s -> {
+        .onComplete(s -> {
             if (s.succeeded()) {
                 authenticationResultHandler.handle(Future.succeededFuture(s.result()));
             } else {
@@ -165,7 +165,7 @@ public final class AuthenticationServerClient {
         };
 
         openReceiver(openCon, messageHandler)
-        .setHandler(attempt -> {
+        .onComplete(attempt -> {
             if (attempt.succeeded()) {
                 vertx.setTimer(5000, tid -> {
                     result.tryFail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 892dc379a..cc338029f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -166,7 +166,7 @@ public abstract class AbstractSender extends AbstractHonoClient implements Messa
                 span.finish();
                 result.fail(e);
             } else {
-                sendMessage(rawMessage, span).setHandler(result);
+                sendMessage(rawMessage, span).onComplete(result);
             }
         });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java b/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java
index 0551683c9..5afd57fb9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CachingClientFactory.java
@@ -174,7 +174,7 @@ class CachingClientFactory<T> extends ClientFactory<T> {
             log.debug("creating new client for [{}]", key);
 
             try {
-                clientInstanceSupplier.get().setHandler(creationAttempt -> {
+                clientInstanceSupplier.get().onComplete(creationAttempt -> {
                     creationRequests.remove(connectionFailureHandler);
                     if (creationLocks.remove(key, Boolean.TRUE)) {
                         if (creationAttempt.succeeded()) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ClientFactory.java b/client/src/main/java/org/eclipse/hono/client/impl/ClientFactory.java
index 7fdb7a9ff..f44ec749a 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ClientFactory.java
@@ -93,7 +93,7 @@ class ClientFactory<T> {
             };
             creationRequests.add(connectionFailureHandler);
 
-            clientSupplier.get().setHandler(attempt -> {
+            clientSupplier.get().onComplete(attempt -> {
                 creationRequests.remove(connectionFailureHandler);
                 result.handle(attempt);
             });
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
index fedecfabb..ff6f50e9e 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
@@ -164,7 +164,7 @@ public final class DeferredConnectionCheckHandler {
 
         ExpiringConnectionCheckPromise(final Handler<AsyncResult<Void>> connectionCheckResultHandler) {
             this.promise = Promise.promise();
-            promise.future().setHandler(connectionCheckResultHandler);
+            promise.future().onComplete(connectionCheckResultHandler);
         }
 
         /**
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
index 3a810c585..f15931165 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java
@@ -91,7 +91,7 @@ public class DelegatedCommandSenderImpl extends AbstractSender implements Delega
                 span.finish();
                 result.fail(e);
             } else {
-                sendMessageAndWaitForOutcome(rawMessage, span).setHandler(result);
+                sendMessageAndWaitForOutcome(rawMessage, span).onComplete(result);
             }
         });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index b312d4247..6b3df28fc 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -801,7 +801,7 @@ public class HonoConnectionImpl implements HonoConnection {
                             }
                         });
                 return senderPromise.future();
-            }).setHandler(result);
+            }).onComplete(result);
         });
     }
 
@@ -908,7 +908,7 @@ public class HonoConnectionImpl implements HonoConnection {
                             }
                         });
                 return receiverPromise.future();
-            }).setHandler(result);
+            }).onComplete(result);
         });
     }
 
@@ -1115,7 +1115,7 @@ public class HonoConnectionImpl implements HonoConnection {
                             connectionFactory.getPort(),
                             connectionFactory.getServerRole());
                     connectionToClose.close();
-                }).setHandler(handler);
+                }).onComplete(handler);
             } else {
                 log.info("connection to server [{}:{}, role: {}] already closed",
                         connectionFactory.getHost(),
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
index 40e43438b..4f3987983 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java
@@ -143,7 +143,7 @@ public class MappingAndDelegatingCommandHandler {
         final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId,
                 originalDeviceId, originalCommandContext.getTracingContext());
 
-        commandTargetFuture.setHandler(commandTargetResult -> {
+        commandTargetFuture.onComplete(commandTargetResult -> {
             if (commandTargetResult.succeeded()) {
                 final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);
                 final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);
@@ -251,7 +251,7 @@ public class MappingAndDelegatingCommandHandler {
         LOG.trace("delegate command to target adapter instance '{}' [command: {}]", targetAdapterInstance, commandContext.getCommand());
         getOrCreateDelegatedCommandSender(targetAdapterInstance)
                 .compose(sender -> sender.sendCommandMessage(commandContext.getCommand(), commandContext.getTracingContext()))
-                .setHandler(ar -> {
+                .onComplete(ar -> {
                     if (ar.succeeded()) {
                         final ProtonDelivery delegatedMsgDelivery = ar.result();
                         LOG.trace("command [{}] sent to downstream peer; remote state of delivery: {}",
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
index 2b34f9c8c..9c32b7cb9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
@@ -176,7 +176,7 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                                 onCloseSpanContext);
                         return (ProtocolAdapterCommandConsumer) new ProtocolAdapterCommandConsumerImpl(onCloseAction);
                     })
-                    .setHandler(result);
+                    .onComplete(result);
         });
     }
 
@@ -295,7 +295,7 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                                             getOrCreateMappingAndDelegatingCommandConsumer(tenantId));
                                 });
                         return CompositeFuture.join(consumerCreationFutures);
-                    }).setHandler(ar -> {
+                    }).onComplete(ar -> {
                         recreatingConsumers.set(false);
                         if (tryAgainRecreatingConsumers.compareAndSet(true, false) || ar.failed()) {
                             if (ar.succeeded()) {
@@ -343,7 +343,7 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(replyId);
         return connection.executeOnContext(result -> {
-            CommandResponseSenderImpl.create(connection, tenantId, replyId, onRemoteClose -> {}).setHandler(result);
+            CommandResponseSenderImpl.create(connection, tenantId, replyId, onRemoteClose -> {}).onComplete(result);
         });
     }
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index c0154b3a9..77dc59747 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -144,7 +144,7 @@ public class TelemetrySenderImpl extends AbstractDownstreamSender {
                 span.finish();
                 result.fail(e);
             } else {
-                sendMessageAndWaitForOutcome(rawMessage, span).setHandler(result);
+                sendMessageAndWaitForOutcome(rawMessage, span).onComplete(result);
             }
         });
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java
index 3a7a04d31..75de89084 100644
--- a/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/CommandResponderTest.java
@@ -62,7 +62,7 @@ public class CommandResponderTest extends AbstractAmqpAdapterClientDownstreamSen
         // ...AND WHEN the disposition is updated by the peer
         updateDisposition();
 
-        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+        deliveryFuture.onComplete(ctx.succeeding(delivery -> {
             // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
             ctx.verify(this::assertMessageConformsAmqpAdapterSpec);
             ctx.completeNow();
@@ -88,7 +88,7 @@ public class CommandResponderTest extends AbstractAmqpAdapterClientDownstreamSen
         // ...AND WHEN the disposition is updated by the peer
         updateDisposition();
 
-        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+        deliveryFuture.onComplete(ctx.succeeding(delivery -> {
             // THEN the given SpanContext is used
             ctx.verify(() -> {
                 verify(spanBuilder).addReference(any(), eq(spanContext));
@@ -113,7 +113,7 @@ public class CommandResponderTest extends AbstractAmqpAdapterClientDownstreamSen
         final Future<ProtonDelivery> deliveryFuture = commandResponder.sendCommandResponse(DEVICE_ID, ADDRESS,
                 CORRELATION_ID, STATUS, PAYLOAD, CONTENT_TYPE, APPLICATION_PROPERTIES);
 
-        deliveryFuture.setHandler(ctx.completing());
+        deliveryFuture.onComplete(ctx.completing());
 
         // THEN the future waits for the disposition to be updated by the peer
         assertThat(deliveryFuture.isComplete()).isFalse();
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java
index f5efbb329..f33c262ff 100644
--- a/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/EventSenderTest.java
@@ -58,7 +58,7 @@ public class EventSenderTest extends AbstractAmqpAdapterClientDownstreamSenderTe
         // ...AND WHEN the disposition is updated by the peer
         updateDisposition();
 
-        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+        deliveryFuture.onComplete(ctx.succeeding(delivery -> {
             // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
             ctx.verify(() -> assertMessageConformsAmqpAdapterSpec(ADDRESS));
             ctx.completeNow();
@@ -84,7 +84,7 @@ public class EventSenderTest extends AbstractAmqpAdapterClientDownstreamSenderTe
         // ...AND WHEN the disposition is updated by the peer
         updateDisposition();
 
-        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+        deliveryFuture.onComplete(ctx.succeeding(delivery -> {
             // THEN the given SpanContext is used
             ctx.verify(() -> {
                 verify(spanBuilder).addReference(any(), eq(spanContext));
@@ -109,7 +109,7 @@ public class EventSenderTest extends AbstractAmqpAdapterClientDownstreamSenderTe
         final Future<ProtonDelivery> deliveryFuture = eventSender.send(DEVICE_ID, PAYLOAD, CONTENT_TYPE,
                 APPLICATION_PROPERTIES);
 
-        deliveryFuture.setHandler(ctx.completing());
+        deliveryFuture.onComplete(ctx.completing());
 
         // THEN the future waits for the disposition to be updated by the peer
         assertThat(deliveryFuture.isComplete()).isFalse();
diff --git a/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java b/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java
index aa234b85f..3941e7ebd 100644
--- a/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/device/amqp/TelemetrySenderTest.java
@@ -79,7 +79,7 @@ public class TelemetrySenderTest extends AbstractAmqpAdapterClientDownstreamSend
         // ...AND WHEN the disposition is updated by the peer
         updateDisposition();
 
-        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+        deliveryFuture.onComplete(ctx.succeeding(delivery -> {
             // THEN the AMQP message conforms to the expectations of the AMQP protocol adapter
             ctx.verify(() -> assertMessageConformsAmqpAdapterSpec(ADDRESS));
             ctx.completeNow();
@@ -125,7 +125,7 @@ public class TelemetrySenderTest extends AbstractAmqpAdapterClientDownstreamSend
         // ...AND WHEN the disposition is updated by the peer
         updateDisposition();
 
-        deliveryFuture.setHandler(ctx.succeeding(delivery -> {
+        deliveryFuture.onComplete(ctx.succeeding(delivery -> {
             // THEN the given SpanContext is used
             ctx.verify(() -> {
                 verify(spanBuilder).addReference(any(), eq(spanContext));
@@ -150,7 +150,7 @@ public class TelemetrySenderTest extends AbstractAmqpAdapterClientDownstreamSend
         final Future<ProtonDelivery> deliveryFuture = telemetrySender.sendAndWaitForOutcome(DEVICE_ID, PAYLOAD,
                 CONTENT_TYPE, APPLICATION_PROPERTIES);
 
-        deliveryFuture.setHandler(ctx.completing());
+        deliveryFuture.onComplete(ctx.completing());
 
         // THEN the future waits for the disposition to be updated by the peer
         assertThat(deliveryFuture.isComplete()).isFalse();
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java
index 168d3d73c..861366a48 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java
@@ -67,7 +67,7 @@ public abstract class AbstractTenantTimeoutRelatedClientFactoryTest<T> {
 
         // GIVEN a client factory that manages a client with a tenant-scoped link
         final HonoConnection connection = createConnection();
-        getClientFuture(connection, tenantId).setHandler(ctx.succeeding(r -> {
+        getClientFuture(connection, tenantId).onComplete(ctx.succeeding(r -> {
 
             // WHEN a tenant timeout event occurs for this tenant
             connection.getVertx().eventBus().publish(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT, tenantId);
@@ -93,7 +93,7 @@ public abstract class AbstractTenantTimeoutRelatedClientFactoryTest<T> {
 
         // GIVEN a client factory that manages a client with a tenant-scoped link
         final HonoConnection connection = createConnection();
-        getClientFuture(connection, tenantId).setHandler(ctx.succeeding(r -> {
+        getClientFuture(connection, tenantId).onComplete(ctx.succeeding(r -> {
 
             // WHEN a tenant timeout event occurs for another tenant
             connection.getVertx().eventBus().publish(Constants.EVENT_BUS_ADDRESS_TENANT_TIMED_OUT, otherTenant);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
index 01f6da988..10ff04424 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CachingClientFactoryTest.java
@@ -182,7 +182,7 @@ public class CachingClientFactoryTest {
 
 
         // THEN all creation requests are failed
-        creationAttempt.future().setHandler(ctx.failing(t -> {
+        creationAttempt.future().onComplete(ctx.failing(t -> {
             // and the next request to create a client for the same key succeeds
             factory.getOrCreateClient(
                     "tenant",
@@ -221,7 +221,7 @@ public class CachingClientFactoryTest {
 
         // THEN the creation request is failed with the error produced when clearing the creation attempts
         // and the client creation failure triggered above is ignored
-        creationAttempt.future().setHandler(ctx.failing(t -> {
+        creationAttempt.future().onComplete(ctx.failing(t -> {
             ctx.verify(() -> {
                 // make sure the creationFailure was actually completed at this point
                 assertThat(creationFailure.future().isComplete()).isTrue();
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
index 6ee16fff5..86850439f 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CredentialsClientImplTest.java
@@ -121,7 +121,7 @@ public class CredentialsClientImplTest {
         final ProtonDelivery delivery = mock(ProtonDelivery.class);
         final Message sentMessage = messageCaptor.getValue();
 
-        getFuture.setHandler(ctx.succeeding(credentials -> {
+        getFuture.onComplete(ctx.succeeding(credentials -> {
             ctx.verify(() -> {
                 // THEN the credentials has been retrieved from the service
                 assertNotNull(credentials);
@@ -162,7 +162,7 @@ public class CredentialsClientImplTest {
 
         // WHEN getting credentials information
         client.get(credentialsType, authId, clientContext)
-                .setHandler(ctx.succeeding(credentials -> {
+                .onComplete(ctx.succeeding(credentials -> {
                     ctx.verify(() -> {
                         assertNotNull(credentials);
                         assertEquals("device", credentials.getDeviceId());
@@ -209,7 +209,7 @@ public class CredentialsClientImplTest {
 
         // WHEN getting credentials
         client.get(credentialsType, authId)
-                .setHandler(ctx.succeeding(result -> {
+                .onComplete(ctx.succeeding(result -> {
                     // THEN the credentials is read from the cache
                     assertEquals(credentialsResult.getPayload(), result);
                     verify(sender, never()).send(any(Message.class), VertxMockSupport.anyHandler());
@@ -233,7 +233,7 @@ public class CredentialsClientImplTest {
 
         // WHEN getting credentials
         client.get(CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD, "test-auth")
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     // THEN the invocation fails and the span is marked as erroneous
                     verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
                     // and the span is finished
@@ -262,7 +262,7 @@ public class CredentialsClientImplTest {
 
         // WHEN getting credentials
         client.get(CredentialsConstants.SECRETS_TYPE_HASHED_PASSWORD, "test-auth")
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     assertEquals(HttpURLConnection.HTTP_BAD_REQUEST,
                             ((ServiceInvocationException) t).getErrorCode());
                     // THEN the invocation fails and the span is marked as erroneous
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
index aec6669ce..0fed457ca 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java
@@ -108,7 +108,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting the last known gateway
         client.getLastKnownGatewayForDevice("deviceId", span.context())
-                .setHandler(ctx.succeeding(resultJson -> {
+                .onComplete(ctx.succeeding(resultJson -> {
                     ctx.verify(() -> {
                         // THEN the last known gateway has been retrieved from the service and the span is finished
                         assertThat(resultJson).isNotNull();
@@ -138,7 +138,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN setting the last known gateway
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
-                .setHandler(ctx.succeeding(r -> {
+                .onComplete(ctx.succeeding(r -> {
                     ctx.verify(() -> {
                         // THEN the response has been handled and the span is finished
                         verify(span).finish();
@@ -162,7 +162,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN setting the command handling adapter instance
         client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, false, span.context())
-                .setHandler(ctx.succeeding(r -> {
+                .onComplete(ctx.succeeding(r -> {
                     ctx.verify(() -> {
                         // THEN the response has been handled and the span is finished
                         verify(span).finish();
@@ -186,7 +186,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN removing the command handling adapter instance
         client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
-                .setHandler(ctx.succeeding(result -> {
+                .onComplete(ctx.succeeding(result -> {
                     ctx.verify(() -> {
                         // THEN the response has been handled and the span is finished
                         assertThat(result).isTrue();
@@ -221,7 +221,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting the command handling adapter instances
         client.getCommandHandlingAdapterInstances(deviceId, Collections.emptyList(), span.context())
-                .setHandler(ctx.succeeding(resultJson -> {
+                .onComplete(ctx.succeeding(resultJson -> {
                     ctx.verify(() -> {
                         // THEN the response has been handled and the span is finished
                         assertThat(resultJson).isEqualTo(adapterInstancesResult);
@@ -253,7 +253,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting last known gateway information
         client.getLastKnownGatewayForDevice("deviceId", span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
                         verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
@@ -278,7 +278,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN setting last known gateway information
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
                         verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
@@ -303,7 +303,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN setting the command handling adapter instance
         client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, false, span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
                         verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
@@ -328,7 +328,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN removing the command handling adapter instance
         client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
                         verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
@@ -350,7 +350,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN removing the command handling adapter instance
         client.removeCommandHandlingAdapterInstance("deviceId", "gatewayId", span.context())
-                .setHandler(ctx.succeeding(removed -> {
+                .onComplete(ctx.succeeding(removed -> {
                     ctx.verify(() -> {
                         // THEN the response has been handled and the span is finished
                         assertThat(removed).isFalse();
@@ -381,7 +381,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting the command handling adapter instances
         client.getCommandHandlingAdapterInstances("deviceId", Collections.emptyList(), span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
                         verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
@@ -413,7 +413,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting last known gateway information
         client.getLastKnownGatewayForDevice("deviceId", span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
@@ -446,7 +446,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN setting last known gateway information
         client.setLastKnownGatewayForDevice("deviceId", "gatewayId", span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     ctx.verify(() -> {
                         assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
                         // THEN the invocation fails and the span is marked as erroneous
@@ -479,7 +479,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN setting the command handling adapter instance
         client.setCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", null, false, span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
@@ -512,7 +512,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN removing the command handling adapter instance
         client.removeCommandHandlingAdapterInstance("deviceId", "adapterInstanceId", span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
@@ -545,7 +545,7 @@ public class DeviceConnectionClientImplTest {
 
         // WHEN getting the command handling adapter instances
         client.getCommandHandlingAdapterInstances("deviceId", Collections.emptyList(), span.context())
-                .setHandler(ctx.failing(t -> {
+                .onComplete(ctx.failing(t -> {
                     assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_BAD_REQUEST);
                     ctx.verify(() -> {
                         // THEN the invocation fails and the span is marked as erroneous
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
index 56edcd92b..475de8316 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
@@ -91,7 +91,7 @@ public class DownstreamSenderFactoryImplTest {
         assertThat(result.isComplete()).isFalse();
 
         // WHEN an additional, concurrent attempt is made to create a telemetry sender for "tenant"
-        factory.getOrCreateTelemetrySender("telemetry/tenant").setHandler(ctx.failing(t -> {
+        factory.getOrCreateTelemetrySender("telemetry/tenant").onComplete(ctx.failing(t -> {
             // THEN the concurrent attempt fails after having done the default number of retries.
             ctx.verify(() -> {
                 assertThat(t).isInstanceOf(ServerErrorException.class);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
index c31a317af..f02487636 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
@@ -96,7 +96,7 @@ public class EventConsumerImplTest {
                 eventConsumer,
                 remoteDetach -> {})
 
-            .setHandler(ctx.succeeding(c -> {
+            .onComplete(ctx.succeeding(c -> {
 
                 final ArgumentCaptor<ProtonMessageHandler> messageHandler = ArgumentCaptor.forClass(ProtonMessageHandler.class);
                 ctx.verify(() -> verify(connection).createReceiver(
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index 0012e0ae0..be92ad757 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -125,7 +125,7 @@ public class HonoConnectionImplTest {
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.failing(t -> {
+        honoConnection.connect().onComplete(ctx.failing(t -> {
             // THEN the connection attempt fails
             ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
         }));
@@ -156,7 +156,7 @@ public class HonoConnectionImplTest {
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.failing(t -> {
+        honoConnection.connect().onComplete(ctx.failing(t -> {
             // THEN the connection attempt fails
             ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
         }));
@@ -190,7 +190,7 @@ public class HonoConnectionImplTest {
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.failing(t -> {
+        honoConnection.connect().onComplete(ctx.failing(t -> {
             // THEN the connection attempt fails
             ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
         }));
@@ -214,7 +214,7 @@ public class HonoConnectionImplTest {
         final ProtonClientOptions options = new ProtonClientOptions()
                 .setReconnectAttempts(0);
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
-        honoConnection.connect(options).setHandler(ctx.succeeding());
+        honoConnection.connect(options).onComplete(ctx.succeeding());
         ctx.verify(() -> assertThat(connectionFactory.await()).isTrue());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
@@ -250,7 +250,7 @@ public class HonoConnectionImplTest {
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN trying to connect
-        honoConnection.connect().setHandler(ctx.succeeding());
+        honoConnection.connect().onComplete(ctx.succeeding());
 
         ctx.verify(() -> {
             // THEN the client fails twice to connect
@@ -277,10 +277,10 @@ public class HonoConnectionImplTest {
         final DisconnectListener<HonoConnection> disconnectListener = mock(DisconnectListener.class);
         honoConnection.addDisconnectListener(disconnectListener);
         honoConnection.connect(new ProtonClientOptions().setReconnectAttempts(1))
-            .setHandler(connected);
+            .onComplete(connected);
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
-        connected.future().setHandler(ctx.succeeding(c -> {
+        connected.future().onComplete(ctx.succeeding(c -> {
             // WHEN the peer closes the connection
             connectionFactory.getCloseHandler().handle(Future.failedFuture("shutting down for maintenance"));
 
@@ -312,7 +312,7 @@ public class HonoConnectionImplTest {
             // WHEN the client tries to reconnect before shut down is complete
             return honoConnection.connect();
         })
-        .setHandler(ctx.failing(cause -> {
+        .onComplete(ctx.failing(cause -> {
             // THEN the connection attempt fails
             ctx.verify(() -> assertThat(((ClientErrorException) cause).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_CONFLICT));
             ctx.completeNow();
@@ -344,7 +344,7 @@ public class HonoConnectionImplTest {
                 return honoConnection.connect(new ProtonClientOptions());
             })
             // THEN the connection succeeds
-            .setHandler(ctx.completing());
+            .onComplete(ctx.completing());
     }
 
     /**
@@ -396,7 +396,7 @@ public class HonoConnectionImplTest {
         honoConnection.connect()
                 // THEN the "isConnected" futures succeed
                 .compose(v -> CompositeFuture.all(isConnected1FutureRef.get(), isConnected2FutureRef.get()))
-                .setHandler(ctx.succeeding());
+                .onComplete(ctx.succeeding());
 
         ctx.verify(() -> {
             // and the client fails twice to connect
@@ -450,7 +450,7 @@ public class HonoConnectionImplTest {
         honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
 
         // WHEN the client tries to connect
-        honoConnection.connect().setHandler(ctx.failing(t -> {
+        honoConnection.connect().onComplete(ctx.failing(t -> {
             ctx.verify(() -> {
                 // THEN the connection attempt fails and the "isConnected" futures fail as well
                 assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
@@ -492,7 +492,7 @@ public class HonoConnectionImplTest {
         }).when(factory).connect(any(), any(), any(), anyString(), VertxMockSupport.anyHandler(),
                 VertxMockSupport.anyHandler(), VertxMockSupport.anyHandler());
         honoConnection = new HonoConnectionImpl(vertx, factory, props);
-        honoConnection.connect().setHandler(ctx.failing(cause -> {
+        honoConnection.connect().onComplete(ctx.failing(cause -> {
                     // THEN three attempts have been made to connect
                     ctx.verify(() -> assertThat(connectAttempts.get()).isEqualTo(3));
                     ctx.completeNow();
@@ -555,7 +555,7 @@ public class HonoConnectionImplTest {
 
                 return r;
             })
-            .setHandler(ctx.succeeding(recv -> {
+            .onComplete(ctx.succeeding(recv -> {
 
                 // WHEN the peer sends a detach frame
                 handlerCaptor.accept(receiver, captor);
@@ -636,7 +636,7 @@ public class HonoConnectionImplTest {
             });
             return r;
         })
-        .setHandler(ctx.failing(t -> {
+        .onComplete(ctx.failing(t -> {
             ctx.verify(() -> {
                 // THEN link establishment is failed after the configured amount of time
                 verify(vertx).setTimer(eq(props.getLinkEstablishmentTimeout()), VertxMockSupport.anyHandler());
@@ -667,7 +667,7 @@ public class HonoConnectionImplTest {
         honoConnection.connect()
             .compose(c -> honoConnection.createReceiver(
                 "source", ProtonQoS.AT_LEAST_ONCE, (delivery, msg) -> {}, remoteCloseHook))
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> {
                     assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
                     verify(receiver).open();
@@ -717,7 +717,7 @@ public class HonoConnectionImplTest {
                 return result;
             })
             // THEN the attempt is failed
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
                 ctx.completeNow();
             }));
@@ -787,7 +787,7 @@ public class HonoConnectionImplTest {
                 });
                 return s;
             })
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> {
                     assertThat(failureAssertion.test(t)).isTrue();
                     verify(remoteCloseHook, never()).handle(anyString());
@@ -815,7 +815,7 @@ public class HonoConnectionImplTest {
         honoConnection.connect()
             .compose(c -> honoConnection.createSender(
                 "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> {
                     assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE);
                     verify(sender).open();
@@ -843,7 +843,7 @@ public class HonoConnectionImplTest {
         honoConnection.connect()
             .compose(c -> honoConnection.createSender(
                 null, ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> {
                     // THEN the attempt fails
                     assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_NOT_IMPLEMENTED);
@@ -886,7 +886,7 @@ public class HonoConnectionImplTest {
                 });
                 return s;
             })
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> {
 
                     // THEN the link does not get established
@@ -923,7 +923,7 @@ public class HonoConnectionImplTest {
         honoConnection.connect()
             .compose(c -> honoConnection.createSender(
                 "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .setHandler(ctx.succeeding(s -> {
+            .onComplete(ctx.succeeding(s -> {
                     ctx.verify(() -> {
                         assertThat(s).isEqualTo(sender);
                         // sendQueueDrainHandler gets unset
@@ -968,7 +968,7 @@ public class HonoConnectionImplTest {
         honoConnection.connect()
             .compose(c -> honoConnection.createSender(
                 "target", ProtonQoS.AT_LEAST_ONCE, remoteCloseHook))
-            .setHandler(ctx.succeeding(s -> {
+            .onComplete(ctx.succeeding(s -> {
                     ctx.verify(() -> {
                         assertThat(s).isEqualTo(sender);
                         // sendQueueDrainHandler gets unset
@@ -1017,7 +1017,7 @@ public class HonoConnectionImplTest {
                 return result;
             })
             // THEN the attempt is failed
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> assertThat(((ServerErrorException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
                 ctx.completeNow();
             }));
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
index 309b515a9..ca0add7c1 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
@@ -165,7 +165,7 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
         .thenReturn(Future.failedFuture(ex));
 
         commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
-            .setHandler(ctx.failing(t -> {
+            .onComplete(ctx.failing(t -> {
                 ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
                 ctx.completeNow();
             }));
@@ -183,7 +183,7 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
         final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
 
         commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null, null)
-            .setHandler(ctx.succeeding(c -> {
+            .onComplete(ctx.succeeding(c -> {
                 ctx.verify(() -> {
                     verify(connection).createReceiver(eq(tenantCommandAddress), eq(ProtonQoS.AT_LEAST_ONCE), any(), anyInt(),
                             eq(false), any());
@@ -207,7 +207,7 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
         final Duration lifespan = Duration.ofSeconds(10);
         final Future<ProtocolAdapterCommandConsumer> commandConsumerFuture = commandConsumerFactory.createCommandConsumer(tenantId,
                 deviceId, commandHandler, lifespan, null);
-        commandConsumerFuture.setHandler(ctx.succeeding(consumer -> {
+        commandConsumerFuture.onComplete(ctx.succeeding(consumer -> {
             ctx.verify(() -> {
                 verify(connection).createReceiver(eq(tenantCommandAddress), eq(ProtonQoS.AT_LEAST_ONCE), any(), anyInt(),
                         eq(false), any());
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
index ce1d13e28..e615af3c5 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/RegistrationClientImplTest.java
@@ -112,7 +112,7 @@ public class RegistrationClientImplTest {
         client.setResponseCache(cache);
 
         // WHEN getting registration information
-        client.assertRegistration("myDevice").setHandler(ctx.succeeding(result -> {
+        client.assertRegistration("myDevice").onComplete(ctx.succeeding(result -> {
             ctx.verify(() -> {
                 // THEN the registration information has been added to the cache
                 assertThat(result).isEqualTo(registrationAssertion);
@@ -151,7 +151,7 @@ public class RegistrationClientImplTest {
         MessageHelper.setPayload(response, MessageHelper.CONTENT_TYPE_APPLICATION_JSON, registrationAssertion.toBuffer());
 
         // WHEN getting registration information
-        client.assertRegistration("device").setHandler(ctx.succeeding(result -> {
+        client.assertRegistration("device").onComplete(ctx.succeeding(result -> {
             ctx.verify(() -> {
                 // THEN the registration information has been retrieved from the service
                 assertThat(result).isEqualTo(registrationAssertion);
@@ -186,7 +186,7 @@ public class RegistrationClientImplTest {
         when(cache.get(eq(TriTuple.of("assert", "device", "gateway")))).thenReturn(regResult);
 
         // WHEN getting registration information
-        client.assertRegistration("device", "gateway").setHandler(ctx.succeeding(result -> {
+        client.assertRegistration("device", "gateway").onComplete(ctx.succeeding(result -> {
             // THEN the registration information is read from the cache
             assertEquals(registrationAssertion, result);
             // and no request message is sent to the service
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
index 30eea9ed4..10977ba9d 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/TenantClientImplTest.java
@@ -121,7 +121,7 @@ public class TenantClientImplTest {
         final JsonObject tenantResult = newTenantResult("tenant");
 
         // WHEN getting tenant information by ID
-        client.get("tenant").setHandler(ctx.succeeding(tenant -> {
+        client.get("tenant").onComplete(ctx.succeeding(tenant -> {
             ctx.verify(() -> {
                 // THEN the registration information has been retrieved from the service
                 assertThat(tenant).isNotNull();
@@ -160,7 +160,7 @@ public class TenantClientImplTest {
         final JsonObject tenantResult = newTenantResult("tenant");
 
         // WHEN getting tenant information
-        client.get("tenant").setHandler(ctx.succeeding(tenant -> {
+        client.get("tenant").onComplete(ctx.succeeding(tenant -> {
             ctx.verify(() -> {
                 // THEN the tenant result has been added to the cache
                 assertThat(tenant).isNotNull();
@@ -202,7 +202,7 @@ public class TenantClientImplTest {
         when(cache.get(any(TriTuple.class))).thenReturn(tenantResult);
 
         // WHEN getting tenant information
-        client.get("tenant").setHandler(ctx.succeeding(result -> {
+        client.get("tenant").onComplete(ctx.succeeding(result -> {
             // THEN the tenant information is read from the cache
             assertEquals(tenantResult.getPayload(), result);
             // and no request message is sent to the service
@@ -225,7 +225,7 @@ public class TenantClientImplTest {
         when(sender.sendQueueFull()).thenReturn(true);
 
         // WHEN getting tenant information
-        client.get("tenant").setHandler(ctx.failing(t -> {
+        client.get("tenant").onComplete(ctx.failing(t -> {
             // THEN the invocation fails and the span is marked as erroneous
             verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
             // and the span is finished
@@ -253,7 +253,7 @@ public class TenantClientImplTest {
         });
 
         // WHEN getting tenant information
-        client.get("tenant").setHandler(ctx.failing(t -> {
+        client.get("tenant").onComplete(ctx.failing(t -> {
             assertEquals(HttpURLConnection.HTTP_BAD_REQUEST, ((ServiceInvocationException) t).getErrorCode());
             // THEN the invocation fails and the span is marked as erroneous
             verify(span).setTag(eq(Tags.ERROR.getKey()), eq(Boolean.TRUE));
