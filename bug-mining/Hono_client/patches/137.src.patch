diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConnection.java b/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
deleted file mode 100644
index d6fef0f40..000000000
--- a/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*******************************************************************************
- * Copyright (c) 2018, 2019 Contributors to the Eclipse Foundation
- *
- * See the NOTICE file(s) distributed with this work for additional
- * information regarding copyright ownership.
- *
- * This program and the accompanying materials are made available under the
- * terms of the Eclipse Public License 2.0 which is available at
- * http://www.eclipse.org/legal/epl-2.0
- *
- * SPDX-License-Identifier: EPL-2.0
- *******************************************************************************/
-
-package org.eclipse.hono.client;
-
-import org.eclipse.hono.client.impl.CommandConnectionImpl;
-import org.eclipse.hono.config.ClientConfigProperties;
-
-import io.vertx.core.Future;
-import io.vertx.core.Handler;
-import io.vertx.core.Vertx;
-
-/**
- * A bidirectional connection between a <em>Protocol Adapter</em> and the
- * <em>AMQP 1.0 Messaging Network</em> to receive commands and send
- * responses.
- */
-public interface CommandConnection extends HonoClient, CommandConsumerFactory {
-
-    /**
-     * Closes the command consumer for a given device.
-     *
-     * @param tenantId The tenant to consume commands from.
-     * @param deviceId The device for which the consumer will be created.
-     * @return A future indicating the outcome of the operation.
-     * @throws NullPointerException if tenantId or deviceId are {@code null}.
-     * @deprecated This method will be removed in Hono 1.0. Use {@link CommandConsumer#close(Handler)} instead.
-     */
-    @Deprecated
-    Future<Void> closeCommandConsumer(String tenantId, String deviceId);
-
-    /**
-     * Creates a new client for a set of configuration properties.
-     *
-     * @param vertx The Vert.x instance to execute the client on, if {@code null} a new Vert.x instance is used.
-     * @param clientConfigProperties The configuration properties to use.
-     *
-     * @return CommandConnection The client that was created.
-     * @throws NullPointerException if clientConfigProperties is {@code null}
-     */
-    static CommandConnection newConnection(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
-        return new CommandConnectionImpl(vertx, clientConfigProperties);
-    }
-}
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
index 7cf92e5de..05cf41d67 100644
--- a/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/CommandConsumerFactory.java
@@ -100,6 +100,18 @@ public interface CommandConsumerFactory extends ConnectionLifecycle {
             Handler<Void> remoteCloseHandler,
             long livenessCheckInterval);
 
+    /**
+     * Closes the command consumer for a given device.
+     *
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @return A future indicating the outcome of the operation.
+     * @throws NullPointerException if tenantId or deviceId are {@code null}.
+     * @deprecated This method will be removed in Hono 1.0. Use {@link CommandConsumer#close(Handler)} instead.
+     */
+    @Deprecated
+    Future<Void> closeCommandConsumer(String tenantId, String deviceId);
+
     /**
      * Gets a sender for sending command responses to a business application.
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
index 94c45e863..6e5376631 100644
--- a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
+++ b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
@@ -19,11 +19,26 @@ import io.vertx.core.Future;
 import io.vertx.core.Handler;
 
 /**
- * Provides access to the life cycle events of a connection to a Hono service.
+ * Provides access to the life cycle of a connection to a Hono service.
  *
  */
 public interface ConnectionLifecycle {
 
+    /**
+     * Establishes the underlying AMQP connection to the service.
+     *
+     * @return A future that will be completed with the established connection.
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         connection cannot be established, e.g. because
+     *         <ul>
+     *         <li>authentication failed, or</li>
+     *         <li>the connection has been shut down before the connection could be
+     *         established.</li>
+     *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
+     *         </ul>
+     */
+    Future<HonoClient> connect();
+
     /**
      * Adds a listener to be notified when the connection is lost unexpectedly.
      * 
diff --git a/client/src/main/java/org/eclipse/hono/client/HonoClient.java b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
index 42501d239..3d3b7ebd6 100644
--- a/client/src/main/java/org/eclipse/hono/client/HonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/HonoClient.java
@@ -86,8 +86,9 @@ public interface HonoClient extends ConnectionLifecycle,
     }
 
     /**
-     * Connects to the Hono server using default TCP client options.
-     * <p>
+     * {@inheritDoc}
+     *
+     * The connection will be established using default options.
      * With the default options a client will try three times to establish a TCP connection to the peer
      * before giving up. Each attempt will be canceled after 200ms and the client will wait 500ms
      * before making the next attempt. Note that each connection attempt is made using the same IP
@@ -115,6 +116,7 @@ public interface HonoClient extends ConnectionLifecycle,
      *         <li>the maximum number of (unsuccessful) connection attempts have been made.</li>
      *         </ul>
      */
+    @Override
     Future<HonoClient> connect();
 
     /**
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
similarity index 95%
rename from client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
rename to client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
index 7ac004c28..bbb754e3f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2018, 2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -20,8 +20,8 @@ import java.util.Optional;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.eclipse.hono.auth.Device;
-import org.eclipse.hono.client.CommandConnection;
 import org.eclipse.hono.client.CommandConsumer;
+import org.eclipse.hono.client.CommandConsumerFactory;
 import org.eclipse.hono.client.CommandContext;
 import org.eclipse.hono.client.CommandResponseSender;
 import org.eclipse.hono.client.MessageConsumer;
@@ -36,7 +36,7 @@ import io.vertx.core.Vertx;
 /**
  * Implements a connection between an Adapter and the AMQP 1.0 network to receive commands and send a response.
  */
-public class CommandConnectionImpl extends HonoClientImpl implements CommandConnection {
+public class CommandConsumerFactoryImpl extends HonoClientImpl implements CommandConsumerFactory {
 
     /**
      * The minimum number of milliseconds to wait between checking a
@@ -65,7 +65,7 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
      * @param clientConfigProperties The configuration properties to use.
      * @throws NullPointerException if clientConfigProperties is {@code null}
      */
-    public CommandConnectionImpl(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
+    public CommandConsumerFactoryImpl(final Vertx vertx, final ClientConfigProperties clientConfigProperties) {
         super(vertx, clientConfigProperties);
     }
 
@@ -80,7 +80,7 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
      * @param clientConfigProperties The configuration properties to use.
      * @throws NullPointerException if clientConfigProperties is {@code null}
      */
-    public CommandConnectionImpl(final Vertx vertx, final ConnectionFactory connectionFactory, final ClientConfigProperties clientConfigProperties) {
+    public CommandConsumerFactoryImpl(final Vertx vertx, final ConnectionFactory connectionFactory, final ClientConfigProperties clientConfigProperties) {
         super(vertx, connectionFactory, clientConfigProperties);
     }
 
@@ -235,6 +235,7 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
     /**
      * {@inheritDoc}
      */
+    @Deprecated
     @Override
     public Future<Void> closeCommandConsumer(final String tenantId, final String deviceId) {
 
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
similarity index 88%
rename from client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
rename to client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
index 85b82a629..d0d163aaf 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandConsumerFactoryImplTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -48,17 +48,16 @@ import io.vertx.core.Vertx;
 import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
-import io.vertx.proton.ProtonClientOptions;
 import io.vertx.proton.ProtonConnection;
 import io.vertx.proton.ProtonReceiver;
 
 
 /**
- * Verifies behavior of {@link CommandConnectionImpl}.
+ * Verifies behavior of {@link CommandConsumerFactoryImpl}.
  *
  */
 @RunWith(VertxUnitRunner.class)
-public class CommandConnectionImplTest {
+public class CommandConsumerFactoryImplTest {
 
     /**
      * Global timeout for each test case.
@@ -71,7 +70,7 @@ public class CommandConnectionImplTest {
     private ClientConfigProperties props;
     private ProtonConnection con;
 
-    private CommandConnectionImpl commandConnection;
+    private CommandConsumerFactoryImpl factory;
     private DisconnectHandlerProvidingConnectionFactory connectionFactory;
     private ProtonReceiver receiver;
 
@@ -98,7 +97,7 @@ public class CommandConnectionImplTest {
         when(con.createReceiver(anyString())).thenReturn(receiver);
 
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
-        commandConnection = new CommandConnectionImpl(vertx, connectionFactory, props);
+        factory = new CommandConsumerFactoryImpl(vertx, connectionFactory, props);
     }
 
     /**
@@ -117,10 +116,10 @@ public class CommandConnectionImplTest {
         when(source.getAddress()).thenReturn(null);
         when(receiver.getRemoteSource()).thenReturn(source);
 
-        commandConnection.connect(new ProtonClientOptions())
+        factory.connect()
             .compose(c -> {
                 final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
-                final Future<MessageConsumer> consumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
+                final Future<MessageConsumer> consumer = factory.createCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
                 verify(con).createReceiver("control/theTenant/theDevice");
                 verify(receiver).openHandler(linkOpenHandler.capture());
                 verify(receiver).open();
@@ -149,10 +148,10 @@ public class CommandConnectionImplTest {
         when(receiver.getSource()).thenReturn(source);
         when(receiver.getRemoteSource()).thenReturn(source);
 
-        commandConnection.connect(new ProtonClientOptions())
+        factory.connect()
             .compose(c -> {
                 final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
-                final Future<MessageConsumer> consumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
+                final Future<MessageConsumer> consumer = factory.createCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
                 verify(con).createReceiver(address);
                 verify(receiver).openHandler(linkOpenHandler.capture());
                 verify(receiver).open();
@@ -181,9 +180,9 @@ public class CommandConnectionImplTest {
 
         // GIVEN a command consumer for which a close handler
         // has been registered
-        commandConnection.connect(new ProtonClientOptions())
+        factory.connect()
             .compose(c -> {
-                final Future<MessageConsumer> consumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
+                final Future<MessageConsumer> consumer = factory.createCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
                 verify(con).createReceiver(address);
                 final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
                 verify(receiver).openHandler(linkOpenHandler.capture());
@@ -225,9 +224,9 @@ public class CommandConnectionImplTest {
         when(vertx.setPeriodic(anyLong(), any(Handler.class))).thenReturn(10L);
 
         // GIVEN a command consumer
-        commandConnection.connect(new ProtonClientOptions())
+        factory.connect()
             .compose(client -> {
-                final Future<MessageConsumer> consumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, null, 5000L);
+                final Future<MessageConsumer> consumer = factory.createCommandConsumer("theTenant", "theDevice", commandHandler, null, 5000L);
                 verify(con).createReceiver(address);
                 final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
                 verify(receiver).closeHandler(any(Handler.class));
@@ -251,7 +250,7 @@ public class CommandConnectionImplTest {
                 // THEN the liveness check is canceled
                 verify(vertx).cancelTimer(10L);
                 // and the next attempt to create a command consumer for the same address
-                final Future<MessageConsumer> newConsumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, null);
+                final Future<MessageConsumer> newConsumer = factory.createCommandConsumer("theTenant", "theDevice", commandHandler, null);
                 // results in a new link to be opened
                 verify(con, times(2)).createReceiver(address);
                 final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
@@ -282,14 +281,14 @@ public class CommandConnectionImplTest {
 
         // GIVEN a command connection with an established command consumer
         // which is checked periodically for liveness
-        commandConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess());
+        factory.connect().setHandler(ctx.asyncAssertSuccess());
         assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
         // intentionally using a check interval that is smaller than the minimum
-        final long livenessCheckInterval = CommandConnectionImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS - 1;
+        final long livenessCheckInterval = CommandConsumerFactoryImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS - 1;
         final Async consumerCreation = ctx.async();
-        final Future<MessageConsumer> commandConsumer = commandConnection.createCommandConsumer(
+        final Future<MessageConsumer> commandConsumer = factory.createCommandConsumer(
                 "theTenant", "theDevice", commandHandler, closeHandler, eq(livenessCheckInterval));
         commandConsumer.setHandler(ctx.asyncAssertSuccess(ok -> consumerCreation.complete()));
         verify(con).createReceiver(address);
@@ -299,7 +298,7 @@ public class CommandConnectionImplTest {
         linkOpenHandler.getValue().handle(Future.succeededFuture(receiver));
         final ArgumentCaptor<Handler<Long>> livenessCheck = ArgumentCaptor.forClass(Handler.class);
         // the liveness check is registered with the minimum interval length
-        verify(vertx).setPeriodic(eq(CommandConnectionImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS), livenessCheck.capture());
+        verify(vertx).setPeriodic(eq(CommandConsumerFactoryImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS), livenessCheck.capture());
         consumerCreation.await();
 
         // WHEN the command connection fails
@@ -343,11 +342,11 @@ public class CommandConnectionImplTest {
         final Handler<Void> remoteCloseHandler = mock(Handler.class);
 
         // GIVEN an established command connection
-        commandConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess());
+        factory.connect().setHandler(ctx.asyncAssertSuccess());
         assertTrue(connectionFactory.await());
         connectionFactory.setExpectedSucceedingConnectionAttempts(1);
 
-        final Handler<Long> livenessCheck = commandConnection.newLivenessCheck("theTenant", "theDevice", "key", commandHandler, remoteCloseHandler);
+        final Handler<Long> livenessCheck = factory.newLivenessCheck("theTenant", "theDevice", "key", commandHandler, remoteCloseHandler);
 
         // WHEN the liveness check fires
         livenessCheck.handle(10L);
