diff --git a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
index d3bdd99f6..b181cc1cb 100644
--- a/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java
@@ -16,6 +16,7 @@ package org.eclipse.hono.client;
 import org.eclipse.hono.client.impl.CommandConsumer;
 import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;
 
+import io.opentracing.SpanContext;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 
@@ -67,6 +68,9 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
      * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
      *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
      *                       message transfer and finish the trace span associated with the {@link CommandContext}.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+     *                An implementation should use this as the parent for any span it creates for tracing
+     *                the execution of this operation.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will be completed with the newly created consumer once the link
@@ -74,12 +78,13 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating
      *         the cause of the failure.
-     * @throws NullPointerException if any of tenant, device ID or command handler are {@code null}.
+     * @throws NullPointerException if any of tenant, device ID or command handler is {@code null}.
      */
     Future<MessageConsumer> createCommandConsumer(
             String tenantId,
             String deviceId,
-            Handler<CommandContext> commandHandler);
+            Handler<CommandContext> commandHandler,
+            SpanContext context);
 
     /**
      * Creates a command consumer for a device that is connected via a gateway.
@@ -100,6 +105,9 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
      * @param commandHandler The handler to invoke with every command received. The handler must invoke one of the
      *                       terminal methods of the passed in {@link CommandContext} in order to settle the command
      *                       message transfer and finish the trace span associated with the {@link CommandContext}.
+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.
+     *                An implementation should use this as the parent for any span it creates for tracing
+     *                the execution of this operation.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will be completed with the newly created consumer once the link
@@ -107,13 +115,14 @@ public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecyc
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating
      *         the cause of the failure.
-     * @throws NullPointerException if any of tenant, device ID, gateway ID or command handler are {@code null}.
+     * @throws NullPointerException if any of tenant, device ID, gateway ID or command handler is {@code null}.
      */
     Future<MessageConsumer> createCommandConsumer(
             String tenantId,
             String deviceId,
             String gatewayId,
-            Handler<CommandContext> commandHandler);
+            Handler<CommandContext> commandHandler,
+            SpanContext context);
 
     /**
      * Gets a sender for sending command responses to a business application.
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
index 131e0c29f..094c7066c 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java
@@ -32,6 +32,7 @@ import org.eclipse.hono.util.CommandConstants;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.ResourceIdentifier;
 
+import io.opentracing.SpanContext;
 import io.vertx.core.CompositeFuture;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -46,7 +47,7 @@ import io.vertx.proton.ProtonReceiver;
  * <ul>
  * <li>A single consumer link on an address containing the protocol adapter instance id.</li>
  * <li>A tenant-scoped link, created (if not already existing for that tenant) when
- * {@link #createCommandConsumer(String, String, Handler)} is invoked.</li>
+ * {@link #createCommandConsumer(String, String, Handler, SpanContext)} is invoked.</li>
  * </ul>
  * <p>
  * Command messages are first received on the tenant-scoped consumer address. It is then determined whether there is
@@ -118,11 +119,11 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
      */
     @Override
     public final Future<MessageConsumer> createCommandConsumer(final String tenantId, final String deviceId,
-            final Handler<CommandContext> commandHandler) {
+            final Handler<CommandContext> commandHandler, final SpanContext context) {
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(commandHandler);
-        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler);
+        return doCreateCommandConsumer(tenantId, deviceId, null, commandHandler, context);
     }
 
     /**
@@ -130,16 +131,16 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
      */
     @Override
     public final Future<MessageConsumer> createCommandConsumer(final String tenantId, final String deviceId,
-            final String gatewayId, final Handler<CommandContext> commandHandler) {
+            final String gatewayId, final Handler<CommandContext> commandHandler, final SpanContext context) {
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(gatewayId);
         Objects.requireNonNull(commandHandler);
-        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler);
+        return doCreateCommandConsumer(tenantId, deviceId, gatewayId, commandHandler, context);
     }
 
     private Future<MessageConsumer> doCreateCommandConsumer(final String tenantId, final String deviceId,
-            final String gatewayId, final Handler<CommandContext> commandHandler) {
+            final String gatewayId, final Handler<CommandContext> commandHandler, final SpanContext context) {
         if (!initialized.get()) {
             log.error("not initialized");
             return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
@@ -156,20 +157,20 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                             // TODO find a way to provide a notification here so that potential resources associated with the replaced consumer can be freed (maybe add a commandHandlerOverwritten Handler param to createCommandConsumer())
                         }
                         // associate handler with this adapter instance
-                        return setCommandHandlingAdapterInstance(tenantId, deviceId);
+                        return setCommandHandlingAdapterInstance(tenantId, deviceId, context);
                     })
                     .map(res -> {
-                        final Supplier<Future<Void>> onCloseAction = () -> removeCommandConsumer(tenantId, deviceId);
+                        final Supplier<Future<Void>> onCloseAction = () -> removeCommandConsumer(tenantId, deviceId, context);
                         return (MessageConsumer) new DeviceSpecificCommandConsumer(onCloseAction);
                     })
                     .setHandler(result);
         });
     }
 
-    private Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId) {
+    private Future<Void> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {
         return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
                 .compose(client -> {
-                    return client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, null);
+                    return client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, context);
                 }).recover(thr -> {
                     log.info("error setting command handling adapter instance [tenant: {}, device: {}]", tenantId,
                             deviceId, thr);
@@ -179,12 +180,12 @@ public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClien
                 });
     }
 
-    private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId) {
+    private Future<Void> removeCommandConsumer(final String tenantId, final String deviceId, final SpanContext context) {
         log.trace("remove command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId);
         adapterInstanceCommandHandler.removeDeviceSpecificCommandHandler(tenantId, deviceId);
         return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)
                 .compose(client -> {
-                    return client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, null);
+                    return client.removeCommandHandlingAdapterInstance(deviceId, adapterInstanceId, context);
                 }).recover(thr -> {
                     log.info("error removing command handling adapter instance [tenant: {}, device: {}]", tenantId,
                             deviceId, thr);
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
index 8b4ac19c0..01afdbdfe 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImplTest.java
@@ -157,7 +157,7 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
                 VertxMockSupport.anyHandler()))
         .thenReturn(Future.failedFuture(ex));
 
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler)
+        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null)
             .setHandler(ctx.failing(t -> {
                 ctx.verify(() -> assertThat(((ServiceInvocationException) t).getErrorCode()).isEqualTo(HttpURLConnection.HTTP_UNAVAILABLE));
                 ctx.completeNow();
@@ -175,7 +175,7 @@ public class ProtocolAdapterCommandConsumerFactoryImplTest {
 
         final Handler<CommandContext> commandHandler = VertxMockSupport.mockHandler();
 
-        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler)
+        commandConsumerFactory.createCommandConsumer(tenantId, deviceId, commandHandler, null)
             .setHandler(ctx.completing());
     }
 
