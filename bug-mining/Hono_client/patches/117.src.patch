diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConnection.java b/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
index 1fe666f64..f8c038d69 100644
--- a/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
+++ b/client/src/main/java/org/eclipse/hono/client/CommandConnection.java
@@ -40,7 +40,8 @@ public interface CommandConnection extends HonoClient {
      * @param deviceId The device for which the consumer will be created.
      * @param commandHandler The handler to invoke with every command received.
      * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     at the peer's request.
+     *                     at the peer's request or {@code null} if no handler should
+     *                     be invoked.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will be completed with the newly created consumer once the link
@@ -53,7 +54,7 @@ public interface CommandConnection extends HonoClient {
      *         <li>a {@link ServiceInvocationException} with an error code indicating
      *         the cause of the failure</li>
      *         </ul>
-     * @throws NullPointerException if any of tenant, device ID or message consumer are {@code null}.
+     * @throws NullPointerException if any of tenant, device ID or command handler are {@code null}.
      */
     Future<MessageConsumer> createCommandConsumer(
             String tenantId,
@@ -61,6 +62,52 @@ public interface CommandConnection extends HonoClient {
             Handler<CommandContext> commandHandler,
             Handler<Void> remoteCloseHandler);
 
+    /**
+     * Creates a command consumer for a device.
+     * <p>
+     * For each device only one command consumer may be active at any given time.
+     * It is the responsibility of the calling code to properly close a consumer
+     * once it is no longer needed. The preferred way of doing so is to invoke the
+     * instance's {@link CommandConsumer#close(Handler)} method. Alternatively, if
+     * no reference to the instance is held, the {@link #closeCommandConsumer(String, String)}
+     * method can be used instead.
+     * <p>
+     * The underlying link for receiving the commands will be checked periodically
+     * after the given number of milliseconds. If the link is no longer active, e.g.
+     * because the underlying connection to the peer has been lost or the peer has
+     * closed the link, then this client will try to re-establish the link using the
+     * given parameters.
+     * 
+     * @param tenantId The tenant to consume commands from.
+     * @param deviceId The device for which the consumer will be created.
+     * @param commandHandler The handler to invoke with every command received.
+     * @param remoteCloseHandler A handler to be invoked after the link has been closed
+     *                     at the peer's request.
+     * @param livenessCheckInterval The number of milliseconds to wait between checking
+     *                              liveness of the created link. If the check fails,
+     *                              an attempt will be made to re-establish the link.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be completed with the newly created consumer once the link
+     *         has been established.
+     *         <p>
+     *         The future will be failed with
+     *         <ul>
+     *         <li>a {@link ResourceConflictException} if there already is
+     *         a command consumer active for the given device</li>
+     *         <li>a {@link ServiceInvocationException} with an error code indicating
+     *         the cause of the failure</li>
+     *         </ul>
+     * @throws NullPointerException if tenant, device ID or command handler are {@code null}.
+     * @throws IllegalArgumentException if the checkInterval is negative.
+     */
+    Future<MessageConsumer> createCommandConsumer(
+            String tenantId,
+            String deviceId,
+            Handler<CommandContext> commandHandler,
+            Handler<Void> remoteCloseHandler,
+            long livenessCheckInterval);
+
     /**
      * Closes the command consumer for a given device.
      *
diff --git a/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java b/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java
index cfeca8f1c..cf7cb3258 100644
--- a/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java
+++ b/client/src/main/java/org/eclipse/hono/client/CommandConsumer.java
@@ -80,7 +80,7 @@ public class CommandConsumer extends AbstractConsumer {
      *                     the link has been closed but <em>before</em> the handler that has been
      *                     passed into the <em>close</em> method is invoked.
      * @param remoteCloseHandler A handler to be invoked after the link has been closed
-     *                     on the remote peer's request. The handler will be invoked with the
+     *                     at the remote peer's request. The handler will be invoked with the
      *                     link's source address.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
      * @param tracer The tracer to use for tracking the processing of received
@@ -155,7 +155,11 @@ public class CommandConsumer extends AbstractConsumer {
                         currentSpan.finish();
                     }
                 },
-                remoteCloseHandler).setHandler(s -> {
+                sourceAddress -> {
+                    LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed remotely",
+                            tenantId, deviceId);
+                    remoteCloseHandler.handle(sourceAddress);
+                }).setHandler(s -> {
 
                     if (s.succeeded()) {
                         final ProtonReceiver receiver = s.result();
@@ -163,7 +167,11 @@ public class CommandConsumer extends AbstractConsumer {
                         receiverRef.set(receiver);
                         receiver.flow(1); // allow sender to send one command
                         final CommandConsumer consumer = new CommandConsumer(context, props, receiver, tracer);
-                        consumer.setLocalCloseHandler(localCloseHandler);
+                        consumer.setLocalCloseHandler(sourceAddress -> {
+                            LOG.debug("command receiver link [tenant-id: {}, device-id: {}] closed locally",
+                                    tenantId, deviceId);
+                            localCloseHandler.handle(sourceAddress);
+                        });
                         creationHandler.handle(Future.succeededFuture(consumer));
                     } else {
                         LOG.debug("failed to create command consumer [tenant-id: {}, device-id: {}]", tenantId, deviceId, s.cause());
diff --git a/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java b/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java
index 66cb339c3..16feafb92 100644
--- a/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/StatusCodeMapper.java
@@ -100,6 +100,8 @@ public abstract class StatusCodeMapper {
             return new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, error.getDescription());
         } else if (AmqpError.UNAUTHORIZED_ACCESS.equals(error.getCondition())) {
             return new ClientErrorException(HttpURLConnection.HTTP_FORBIDDEN, error.getDescription());
+        } else if (AmqpError.INTERNAL_ERROR.equals(error.getCondition())) {
+            return new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR, error.getDescription());
         } else {
             return new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, error.getDescription());
         }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 6339d5f29..f744d2a0d 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -366,7 +366,7 @@ public abstract class AbstractHonoClient {
      * @param sourceAddress The address to receive messages from.
      * @param qos The quality of service to use for the link.
      * @param messageHandler The handler to invoke with every message received.
-     * @param closeHook The handler to invoke when the link is closed by the peer (may be {@code null}).
+     * @param remoteCloseHook The handler to invoke when the link is closed at the peer's request (may be {@code null}).
      * @return A future for the created link. The future will be completed once the link is open.
      *         The future will fail with a {@link ServiceInvocationException} if the link cannot be opened.
      * @throws NullPointerException if any of the arguments other than close hook is {@code null}.
@@ -378,7 +378,7 @@ public abstract class AbstractHonoClient {
             final String sourceAddress,
             final ProtonQoS qos,
             final ProtonMessageHandler messageHandler,
-            final Handler<String> closeHook) {
+            final Handler<String> remoteCloseHook) {
 
         Objects.requireNonNull(ctx);
         Objects.requireNonNull(clientConfig);
@@ -429,8 +429,8 @@ public abstract class AbstractHonoClient {
                     result.tryFail(new ServerErrorException(HttpsURLConnection.HTTP_UNAVAILABLE));
                 }
             });
-            HonoProtonHelper.setDetachHandler(receiver, remoteDetached -> onRemoteDetach(receiver, con.getRemoteContainer(), false, closeHook));
-            HonoProtonHelper.setCloseHandler(receiver, remoteClosed -> onRemoteDetach(receiver, con.getRemoteContainer(), true, closeHook));
+            HonoProtonHelper.setDetachHandler(receiver, remoteDetached -> onRemoteDetach(receiver, con.getRemoteContainer(), false, remoteCloseHook));
+            HonoProtonHelper.setCloseHandler(receiver, remoteClosed -> onRemoteDetach(receiver, con.getRemoteContainer(), true, remoteCloseHook));
             receiver.open();
             ctx.owner().setTimer(clientConfig.getLinkEstablishmentTimeout(), tid -> onTimeOut(receiver, clientConfig, result));
         });
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
index 8695d438e..68b2111c5 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
@@ -17,6 +17,7 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.eclipse.hono.auth.Device;
 import org.eclipse.hono.client.CommandConnection;
@@ -37,11 +38,22 @@ import io.vertx.core.Vertx;
  */
 public class CommandConnectionImpl extends HonoClientImpl implements CommandConnection {
 
+    /**
+     * The minimum number of milliseconds to wait between checking a
+     * command consumer link's liveness.
+     */
+    public static final long MIN_LIVENESS_CHECK_INTERVAL_MILLIS = 2000;
+
     /**
      * The consumers that can be used to receive command messages.
      * The device, which belongs to a tenant is used as the key, e.g. <em>DEFAULT_TENANT/4711</em>.
      */
-    private final Map<String, MessageConsumer> commandReceivers = new HashMap<>();
+    private final Map<String, MessageConsumer> commandConsumers = new HashMap<>();
+    /**
+     * A mapping of command consumer addresses to vert.x timer IDs which represent the
+     * liveness checks for the consumers.
+     */
+    private final Map<String, Long> livenessChecks = new HashMap<>();
 
     /**
      * Creates a new client for a set of configuration properties.
@@ -78,7 +90,7 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
     @Override
     protected void clearState() {
         super.clearState();
-        commandReceivers.clear();
+        commandConsumers.clear();
     }
 
     /**
@@ -96,7 +108,7 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
 
         return executeOrRunOnContext(result -> {
             final String key = Device.asAddress(tenantId, deviceId);
-            final MessageConsumer messageConsumer = commandReceivers.get(key);
+            final MessageConsumer messageConsumer = commandConsumers.get(key);
             if (messageConsumer != null) {
                 log.debug("cannot create concurrent command consumer [tenant: {}, device-id: {}]", tenantId, deviceId);
                 result.fail(new ResourceConflictException("message consumer already in use"));
@@ -105,7 +117,7 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
                         tenantId,
                         () -> newCommandConsumer(tenantId, deviceId, commandConsumer, remoteCloseHandler))
                 .map(consumer -> {
-                    commandReceivers.put(key, consumer);
+                    commandConsumers.put(key, consumer);
                     return consumer;
                 })
                 .setHandler(result);
@@ -113,6 +125,80 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
         });
     }
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * The interval used for creating the periodic liveness check will be the maximum
+     * of the given interval length and {@link #MIN_LIVENESS_CHECK_INTERVAL_MILLIS}.
+     * 
+     */
+    public final Future<MessageConsumer> createCommandConsumer(
+            final String tenantId,
+            final String deviceId,
+            final Handler<CommandContext> commandConsumer,
+            final Handler<Void> remoteCloseHandler,
+            final long checkInterval) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(commandConsumer);
+        if (checkInterval < 0) {
+            throw new IllegalArgumentException("liveness check interval must be > 0");
+        }
+
+        return createCommandConsumer(tenantId, deviceId, commandConsumer, remoteCloseHandler).map(c -> {
+
+            final String key = Device.asAddress(tenantId, deviceId);
+            final long effectiveCheckInterval = Math.max(MIN_LIVENESS_CHECK_INTERVAL_MILLIS, checkInterval);
+            final long livenessCheckId = vertx.setPeriodic(
+                    effectiveCheckInterval,
+                    newLivenessCheck(tenantId, deviceId, key, commandConsumer, remoteCloseHandler));
+            livenessChecks.put(key, livenessCheckId);
+            return c;
+        });
+    }
+
+    Handler<Long> newLivenessCheck(
+            final String tenantId,
+            final String deviceId,
+            final String key,
+            final Handler<CommandContext> commandConsumer,
+            final Handler<Void> remoteCloseHandler) {
+
+        final AtomicBoolean recreating = new AtomicBoolean(false);
+        return timerId -> {
+            if (isShutdown()) {
+                vertx.cancelTimer(timerId);
+            } else if (isConnectedInternal() && !commandConsumers.containsKey(key)) {
+                // when a connection is lost unexpectedly,
+                // all consumers will be removed from the cache
+                if (recreating.compareAndSet(false, true)) {
+                    // set a lock in order to prevent spawning multiple attempts
+                    // to re-create the consumer
+                    log.debug("trying to re-create command consumer [tenant: {}, device-id: {}]",
+                            tenantId, deviceId);
+                    // we try to re-create the link using the original parameters
+                    // which will put the consumer into the cache again, if successful
+                    createCommandConsumer(tenantId, deviceId, commandConsumer, remoteCloseHandler)
+                    .map(consumer -> {
+                        log.debug("successfully re-created command consumer [tenant: {}, device-id: {}]",
+                                tenantId, deviceId);
+                        return consumer;
+                    })
+                    .otherwise(t -> {
+                        log.info("failed to re-create command consumer [tenant: {}, device-id: {}]: {}",
+                                tenantId, deviceId, t.getMessage());
+                        return null;
+                    })
+                    .setHandler(s -> recreating.compareAndSet(true, false));
+                } else {
+                    log.debug("already trying to re-create command consumer [tenant: {}, device-id: {}], yielding ...",
+                            tenantId, deviceId);
+                }
+            }
+        };
+    }
+
     private Future<MessageConsumer> newCommandConsumer(
             final String tenantId,
             final String deviceId,
@@ -129,11 +215,13 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
                     tenantId,
                     deviceId,
                     commandConsumer,
-                    sourceAddress -> {
-                        commandReceivers.remove(key);
+                    sourceAddress -> { // local close hook
+                        // stop liveness check
+                        Optional.ofNullable(livenessChecks.remove(key)).ifPresent(vertx::cancelTimer);
+                        commandConsumers.remove(key);
                     },
-                    sourceAddress -> {
-                        commandReceivers.remove(key);
+                    sourceAddress -> { // remote close hook
+                        commandConsumers.remove(key);
                         remoteCloseHandler.handle(null);
                     },
                     result,
@@ -152,7 +240,10 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
 
         return executeOrRunOnContext(result -> {
             final String deviceAddress = Device.asAddress(tenantId, deviceId);
-            Optional.ofNullable(commandReceivers.remove(deviceAddress)).ifPresent(consumer -> {
+            // stop liveness check
+            Optional.ofNullable(livenessChecks.remove(deviceAddress)).ifPresent(vertx::cancelTimer);
+            // close and remove link from cache 
+            Optional.ofNullable(commandConsumers.remove(deviceAddress)).ifPresent(consumer -> {
                 consumer.close(result);
             });
         });
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 1b8d754bd..9d849149f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -95,6 +95,10 @@ public class HonoClientImpl implements HonoClient {
      * The target address is used as the key, e.g. <em>telemetry/DEFAULT_TENANT</em>.
      */
     protected final Map<String, MessageSender> activeSenders = new HashMap<>();
+    /**
+     * The vert.x instance to run on.
+     */
+    protected final Vertx vertx;
 
     /**
      * The AMQP connection to the peer.
@@ -112,7 +116,6 @@ public class HonoClientImpl implements HonoClient {
     private final AtomicBoolean shuttingDown = new AtomicBoolean(false);
     private final AtomicBoolean disconnecting = new AtomicBoolean(false);
     private final ConnectionFactory connectionFactory;
-    private final Vertx vertx;
     private final Object connectionLock = new Object();
 
     private ProtonClientOptions clientOptions;
@@ -252,10 +255,29 @@ public class HonoClientImpl implements HonoClient {
         }
     }
 
-    private boolean isConnectedInternal() {
+    /**
+     * Checks if this client is currently connected to the server.
+     * <p>
+     * Note that the result returned by this method is only meaningful
+     * if running on the vert.x event loop context that this client has been
+     * created on.
+     * 
+     * @return {@code true} if the connection is established.
+     */
+    protected boolean isConnectedInternal() {
         return connection != null && !connection.isDisconnected();
     }
 
+    /**
+     * Checks if this client is shut down.
+     * 
+     * @return {@code true} if this client is shut down already or is
+     *         in the process of shutting down.
+     */
+    protected final boolean isShutdown() {
+        return shuttingDown.get();
+    }
+
     /**
      * Sets the connection used to interact with the Hono server.
      *
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
index 038944445..63e4f7dbe 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
@@ -13,8 +13,12 @@
 
 package org.eclipse.hono.client.impl;
 
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Mockito.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
@@ -22,8 +26,9 @@ import static org.mockito.Mockito.when;
 
 import java.net.HttpURLConnection;
 
+import org.apache.qpid.proton.amqp.transport.AmqpError;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.amqp.transport.Source;
-import org.eclipse.hono.client.CommandConnection;
 import org.eclipse.hono.client.CommandContext;
 import org.eclipse.hono.client.MessageConsumer;
 import org.eclipse.hono.client.ServiceInvocationException;
@@ -40,6 +45,7 @@ import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
+import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
 import io.vertx.proton.ProtonClientOptions;
@@ -65,19 +71,25 @@ public class CommandConnectionImplTest {
     private ClientConfigProperties props;
     private ProtonConnection con;
 
-    private CommandConnection commandConnection;
+    private CommandConnectionImpl commandConnection;
     private DisconnectHandlerProvidingConnectionFactory connectionFactory;
     private ProtonReceiver receiver;
 
     /**
      * Sets up fixture.
      */
+    @SuppressWarnings("unchecked")
     @Before
     public void setUp() {
 
         vertx = mock(Vertx.class);
         context = HonoClientUnitTestHelper.mockContext(vertx);
         when(vertx.getOrCreateContext()).thenReturn(context);
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgument(1);
+            handler.handle(null);
+            return null;
+        }).when(vertx).setTimer(anyLong(), any(Handler.class));
 
         props = new ClientConfigProperties();
 
@@ -120,9 +132,8 @@ public class CommandConnectionImplTest {
     }
 
     /**
-     * Verifies that an attempt to open a command consumer for a
-     * tenant and device Id succeeds if the peer agrees to open a
-     * corresponding receiver link that is scoped to the device.
+     * Verifies that the connection successfully opens a command consumer for a
+     * tenant and device Id and opens a receiver link that is scoped to the device.
      *
      * @param ctx The test context.
      */
@@ -135,6 +146,7 @@ public class CommandConnectionImplTest {
         final Handler<Void> closeHandler = mock(Handler.class);
         final Source source = mock(Source.class);
         when(source.getAddress()).thenReturn(address);
+        when(receiver.getSource()).thenReturn(source);
         when(receiver.getRemoteSource()).thenReturn(source);
 
         commandConnection.connect(new ProtonClientOptions())
@@ -190,9 +202,13 @@ public class CommandConnectionImplTest {
     }
 
     /**
-     * Verifies that a command consumer's underlying link is closed
-     * and the consumer is removed from the cache when its
-     * <em>close</em> method is invoked.
+     * Verifies that a command consumer's <em>close</em> method is invoked,
+     * then
+     * <ul>
+     * <li>the underlying link is closed,</li>
+     * <li>the consumer is removed from the cache and</li>
+     * <li>the corresponding liveness check is canceled.</li>
+     * </ul>
      *
      * @param ctx The test context.
      */
@@ -206,11 +222,12 @@ public class CommandConnectionImplTest {
         when(source.getAddress()).thenReturn(address);
         when(receiver.getSource()).thenReturn(source);
         when(receiver.getRemoteSource()).thenReturn(source);
+        when(vertx.setPeriodic(anyLong(), any(Handler.class))).thenReturn(10L);
 
         // GIVEN a command consumer
         commandConnection.connect(new ProtonClientOptions())
             .compose(client -> {
-                final Future<MessageConsumer> consumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, null);
+                final Future<MessageConsumer> consumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, null, 5000L);
                 verify(con).createReceiver(address);
                 final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
                 verify(receiver).closeHandler(any(Handler.class));
@@ -218,6 +235,7 @@ public class CommandConnectionImplTest {
                 verify(receiver).open();
                 linkOpenHandler.getValue().handle(Future.succeededFuture(receiver));
                 when(receiver.isOpen()).thenReturn(Boolean.TRUE);
+                verify(vertx).setPeriodic(eq(5000L), any(Handler.class));
                 return consumer;
             }).map(consumer -> {
                 // WHEN closing the link locally
@@ -228,9 +246,11 @@ public class CommandConnectionImplTest {
                 verify(receiver).close();
                 // and the peer sends its detach frame
                 closeHandler.getValue().handle(Future.succeededFuture(receiver));
-                return localCloseHandler;
+                return null;
             }).map(ok -> {
-                // THEN the next attempt to create a command consumer for the same address
+                // THEN the liveness check is canceled
+                verify(vertx).cancelTimer(10L);
+                // and the next attempt to create a command consumer for the same address
                 final Future<MessageConsumer> newConsumer = commandConnection.createCommandConsumer("theTenant", "theDevice", commandHandler, null);
                 // results in a new link to be opened
                 verify(con, times(2)).createReceiver(address);
@@ -240,4 +260,112 @@ public class CommandConnectionImplTest {
                 return newConsumer;
             }).setHandler(ctx.asyncAssertSuccess());
     }
+
+    /**
+     * Verifies that a command consumer link that has been created with a check
+     * interval is re-created if the underlying connection to the peer is lost.
+     *
+     * @param ctx The test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testConsumerIsRecreatedOnConnectionFailure(final TestContext ctx) {
+
+        final String address = "control/theTenant/theDevice";
+        final Handler<CommandContext> commandHandler = mock(Handler.class);
+        final Handler<Void> closeHandler = mock(Handler.class);
+        final Source source = mock(Source.class);
+        when(source.getAddress()).thenReturn(address);
+        when(receiver.getSource()).thenReturn(source);
+        when(receiver.getRemoteSource()).thenReturn(source);
+        when(vertx.setPeriodic(anyLong(), any(Handler.class))).thenReturn(10L);
+
+        // GIVEN a command connection with an established command consumer
+        // which is checked periodically for liveness
+        commandConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess());
+        assertTrue(connectionFactory.await());
+        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
+
+        // intentionally using a check interval that is smaller than the minimum
+        final long livenessCheckInterval = CommandConnectionImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS - 1;
+        final Async consumerCreation = ctx.async();
+        final Future<MessageConsumer> commandConsumer = commandConnection.createCommandConsumer(
+                "theTenant", "theDevice", commandHandler, closeHandler, eq(livenessCheckInterval));
+        commandConsumer.setHandler(ctx.asyncAssertSuccess(ok -> consumerCreation.complete()));
+        verify(con).createReceiver(address);
+        final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
+        verify(receiver).openHandler(linkOpenHandler.capture());
+        verify(receiver).open();
+        linkOpenHandler.getValue().handle(Future.succeededFuture(receiver));
+        final ArgumentCaptor<Handler<Long>> livenessCheck = ArgumentCaptor.forClass(Handler.class);
+        // the liveness check is registered with the minimum interval length
+        verify(vertx).setPeriodic(eq(CommandConnectionImpl.MIN_LIVENESS_CHECK_INTERVAL_MILLIS), livenessCheck.capture());
+        consumerCreation.await();
+
+        // WHEN the command connection fails
+        connectionFactory.getDisconnectHandler().handle(con);
+
+        // THEN the connection is re-established
+        assertTrue(connectionFactory.await());
+        // and the liveness check re-creates the command consumer
+        final Async consumerRecreation = ctx.async();
+        when(receiver.open()).thenAnswer(invocation -> {
+            consumerRecreation.complete();
+            return receiver;
+        });
+        livenessCheck.getValue().handle(10L);
+        verify(con, times(2)).createReceiver(address);
+        verify(receiver, times(2)).openHandler(any(Handler.class));
+        verify(receiver, times(2)).open();
+        consumerRecreation.await();
+
+        // and when the consumer is finally closed
+        final Future<Void> localCloseHandler = mock(Future.class);
+        commandConsumer.result().close(localCloseHandler);
+        // then the liveness check has been canceled
+        verify(vertx).cancelTimer(10L);
+    }
+
+    /**
+     * Verifies that consecutive invocations of the liveness check created
+     * for a command consumer do not start a new re-creation attempt if another
+     * attempt is still ongoing.
+     *
+     * @param ctx The test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testLivenessCheckLocksRecreationAttempt(final TestContext ctx) {
+
+        // GIVEN a liveness check for a command consumer
+        final String address = "control/theTenant/theDevice";
+        final Handler<CommandContext> commandHandler = mock(Handler.class);
+        final Handler<Void> remoteCloseHandler = mock(Handler.class);
+
+        // GIVEN an established command connection
+        commandConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess());
+        assertTrue(connectionFactory.await());
+        connectionFactory.setExpectedSucceedingConnectionAttempts(1);
+
+        final Handler<Long> livenessCheck = commandConnection.newLivenessCheck("theTenant", "theDevice", "key", commandHandler, remoteCloseHandler);
+
+        // WHEN the liveness check fires
+        livenessCheck.handle(10L);
+        // and the peer does not open the link before the check fires again
+        livenessCheck.handle(10L);
+
+        // THEN only one attempt has been made to recreate the consumer link
+        verify(con, times(1)).createReceiver(address);
+
+        // and when the first attempt has finally timed out
+        when(receiver.getRemoteCondition()).thenReturn(new ErrorCondition(AmqpError.INTERNAL_ERROR, "internal error"));
+        final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
+        verify(receiver).openHandler(linkOpenHandler.capture());
+        linkOpenHandler.getValue().handle(Future.failedFuture("internal error"));
+
+        // then the next run of the liveness check
+        livenessCheck.handle(10L);
+        // will start a new attempt to re-create the consumer link 
+        verify(con, times(2)).createReceiver(address);
+    }
 }
