diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index 19eeb7e30..4847965b2 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -24,6 +24,7 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
 import javax.net.ssl.SSLException;
 import javax.security.sasl.AuthenticationException;
@@ -109,6 +110,12 @@ public class HonoConnectionImpl implements HonoConnection {
     private final AtomicBoolean disconnecting = new AtomicBoolean(false);
     private final ConnectionFactory connectionFactory;
     private final Object connectionLock = new Object();
+    /**
+     * Reference to a list of promises created in {@link #checkConnected(Handler)}, waiting to be completed
+     * in a concurrent {@link #connect()} invocation. When {@link #connect()} is finished, the reference
+     * value will be set back to {@code null}.
+     */
+    private final AtomicReference<List<Promise<Void>>> checkConnectedPromises = new AtomicReference<>();
 
     private ProtonClientOptions clientOptions;
     private AtomicInteger connectAttempts;
@@ -258,6 +265,9 @@ public class HonoConnectionImpl implements HonoConnection {
 
     /**
      * {@inheritDoc}
+     * <p>
+     * If a connection attempt is currently in progress, the returned future is completed
+     * with the outcome of the connection attempt.
      */
     @Override
     public final Future<Void> isConnected() {
@@ -266,6 +276,9 @@ public class HonoConnectionImpl implements HonoConnection {
 
     /**
      * Checks if this client is currently connected to the server.
+     * <p>
+     * If a connection attempt is currently in progress, the returned future is completed
+     * with the outcome of the connection attempt.
      *
      * @return A succeeded future if this client is connected.
      */
@@ -278,12 +291,47 @@ public class HonoConnectionImpl implements HonoConnection {
     private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {
         if (isConnectedInternal()) {
             resultHandler.handle(Future.succeededFuture());
+        } else if (connecting.get()) {
+            // connect attempt in progress - let its completion complete the resultHandler here
+            log.debug("connection attempt to server [{}:{}] in progress, connection check will be completed with its result",
+                    connectionFactory.getHost(), connectionFactory.getPort());
+            final Promise<Void> promiseToAdd = Promise.promise();
+            promiseToAdd.future().setHandler(resultHandler);
+            // atomically add the promise to checkConnectedPromises - but only if checkConnectedPromises hasn't been cleared already
+            final List<Promise<Void>> newCheckConnectedPromises = checkConnectedPromises
+                    .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {
+                        // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required
+                        if (existing == null) {
+                            return null;
+                        }
+                        final List<Promise<Void>> promises = new ArrayList<>(existing.size() + 1);
+                        promises.addAll(existing);
+                        promises.add(toAdd.get(0));
+                        return promises;
+                    });
+            if (newCheckConnectedPromises == null) {
+                // checkConnectedPromises wasn't updated with our promiseToAdd because the checkConnectedPromises were cleared in between
+                resultHandler.handle(Future.failedFuture(
+                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
+            }
         } else {
             resultHandler.handle(Future.failedFuture(
                     new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
         }
     }
 
+    private void removeAndCompleteCheckConnectedPromises(final AsyncResult<HonoConnection> connectionResult) {
+        final List<Promise<Void>> promises = checkConnectedPromises.getAndSet(null);
+        if (promises != null) {
+            final Context ctx = vertx.getOrCreateContext();
+            if (connectionResult.succeeded()) {
+                promises.forEach(promise -> ctx.runOnContext(v -> promise.complete()));
+            } else {
+                promises.forEach(promise -> ctx.runOnContext(v -> promise.fail(connectionResult.cause())));
+            }
+        }
+    }
+
     /**
      * Checks if this client is currently connected to the server.
      * <p>
@@ -370,6 +418,11 @@ public class HonoConnectionImpl implements HonoConnection {
             final Handler<AsyncResult<HonoConnection>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
 
+        // make sure concurrently created checkConnected() promises get completed along with the given connectionHandler
+        final Handler<AsyncResult<HonoConnection>> wrappedConnectionHandler = connectionHandler instanceof ConnectMethodConnectionHandler
+                ? connectionHandler
+                : new ConnectMethodConnectionHandler(connectionHandler, this::removeAndCompleteCheckConnectedPromises);
+
         context = vertx.getOrCreateContext();
         log.trace("running on vert.x context [event-loop context: {}]", context.isEventLoopContext());
 
@@ -380,8 +433,9 @@ public class HonoConnectionImpl implements HonoConnection {
             if (isConnectedInternal()) {
                 log.debug("already connected to server [{}:{}]", connectionFactory.getHost(),
                         connectionFactory.getPort());
-                connectionHandler.handle(Future.succeededFuture(this));
+                wrappedConnectionHandler.handle(Future.succeededFuture(this));
             } else if (connecting.compareAndSet(false, true)) {
+                checkConnectedPromises.compareAndSet(null, Collections.emptyList());
 
                 log.debug("starting attempt [#{}] to connect to server [{}:{}]",
                         connectAttempts.get() + 1, connectionFactory.getHost(), connectionFactory.getPort());
@@ -394,7 +448,7 @@ public class HonoConnectionImpl implements HonoConnection {
                         conAttempt -> {
                             connecting.compareAndSet(true, false);
                             if (conAttempt.failed()) {
-                                reconnect(conAttempt.cause(), connectionHandler, disconnectHandler);
+                                reconnect(conAttempt.cause(), wrappedConnectionHandler, disconnectHandler);
                             } else {
                                 final ProtonConnection newConnection = conAttempt.result();
                                 if (shuttingDown.get()) {
@@ -405,18 +459,18 @@ public class HonoConnectionImpl implements HonoConnection {
                                     newConnection.close();
                                     // make sure we try to re-connect as often as we tried to connect initially
                                     connectAttempts = new AtomicInteger(0);
-                                    connectionHandler.handle(Future.failedFuture(
+                                    wrappedConnectionHandler.handle(Future.failedFuture(
                                             new ClientErrorException(HttpURLConnection.HTTP_CONFLICT,
                                                     "client is already shut down")));
                                 } else {
                                     setConnection(newConnection);
-                                    connectionHandler.handle(Future.succeededFuture(this));
+                                    wrappedConnectionHandler.handle(Future.succeededFuture(this));
                                 }
                             }
                         });
             } else {
                 log.debug("already trying to connect to server ...");
-                connectionHandler.handle(Future.failedFuture(
+                wrappedConnectionHandler.handle(Future.failedFuture(
                         new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already connecting to server")));
             }
         });
@@ -503,7 +557,9 @@ public class HonoConnectionImpl implements HonoConnection {
         if (shuttingDown.get()) {
             // no need to try to re-connect
             log.info("client is shutting down, giving up attempt to connect");
-            connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
+            final ClientErrorException ex = new ClientErrorException(
+                    HttpURLConnection.HTTP_CONFLICT, "client is already shut down");
+            connectionHandler.handle(Future.failedFuture(ex));
             return;
         }
         final int reconnectAttempt = connectAttempts.getAndIncrement();
@@ -567,26 +623,25 @@ public class HonoConnectionImpl implements HonoConnection {
         log.info("stopping connection attempt to server [host: {}, port: {}] due to terminal error",
                 connectionFactory.getHost(), connectionFactory.getPort(), connectionFailureCause);
 
+        final ServiceInvocationException serviceInvocationException;
         if (connectionFailureCause == null) {
-            connectionHandler.handle(Future.failedFuture(
-                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect")));
+            serviceInvocationException = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
+                    "failed to connect");
         } else if (connectionFailureCause instanceof AuthenticationException) {
             // wrong credentials?
-            connectionHandler.handle(Future.failedFuture(
-                    new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED, "failed to authenticate with server")));
+            serviceInvocationException = new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED,
+                    "failed to authenticate with server");
         } else if (connectionFailureCause instanceof MechanismMismatchException) {
-            connectionHandler.handle(Future.failedFuture(
-                    new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED, "no suitable SASL mechanism found for authentication with server")));
+            serviceInvocationException = new ClientErrorException(HttpURLConnection.HTTP_UNAUTHORIZED,
+                    "no suitable SASL mechanism found for authentication with server");
         } else if (connectionFailureCause instanceof SSLException) {
-            connectionHandler.handle(Future.failedFuture(
-                    new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST,
-                            "TLS handshake with server failed: " + connectionFailureCause.getMessage(),
-                            connectionFailureCause)));
+            serviceInvocationException = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST,
+                    "TLS handshake with server failed: " + connectionFailureCause.getMessage(), connectionFailureCause);
         } else {
-            connectionHandler.handle(Future.failedFuture(
-                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "failed to connect",
-                            connectionFailureCause)));
+            serviceInvocationException = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE,
+                    "failed to connect", connectionFailureCause);
         }
+        connectionHandler.handle(Future.failedFuture(serviceInvocationException));
     }
 
     /**
@@ -992,4 +1047,25 @@ public class HonoConnectionImpl implements HonoConnection {
             }
         }
     }
+
+    /**
+     * Wrapped connection handler used in the {@link #connect()} method. Allows adding an additional handler.
+     */
+    private static class ConnectMethodConnectionHandler implements Handler<AsyncResult<HonoConnection>> {
+
+        private final Handler<AsyncResult<HonoConnection>> connectionHandler;
+        private final Handler<AsyncResult<HonoConnection>> additionalHandler;
+
+        ConnectMethodConnectionHandler(final Handler<AsyncResult<HonoConnection>> connectionHandler,
+                final Handler<AsyncResult<HonoConnection>> additionalHandler) {
+            this.connectionHandler = connectionHandler;
+            this.additionalHandler = additionalHandler;
+        }
+
+        @Override
+        public void handle(final AsyncResult<HonoConnection> event) {
+            connectionHandler.handle(event);
+            additionalHandler.handle(event);
+        }
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index d621cbc61..ab291b0d2 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -28,7 +28,9 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import java.net.HttpURLConnection;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BiConsumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -55,6 +57,7 @@ import org.mockito.AdditionalAnswers;
 import org.mockito.ArgumentCaptor;
 
 import io.vertx.core.AsyncResult;
+import io.vertx.core.CompositeFuture;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -339,6 +342,105 @@ public class HonoConnectionImplTest {
         }));
     }
 
+    /**
+     * Verifies that {@link HonoConnectionImpl#checkConnected()} only completes once a concurrent
+     * connection attempt (which eventually succeeds here) is finished.
+     *
+     * @param ctx The test execution context.
+     */
+    @Test
+    public void testCheckConnectedSucceedsAfterConcurrentReconnectSucceeded(final TestContext ctx) {
+
+        final AtomicBoolean checkConnectedInvocationsDone = new AtomicBoolean(false);
+        final AtomicReference<Future<Void>> checkConnected1FutureRef = new AtomicReference<>();
+        final AtomicReference<Future<Void>> checkConnected2FutureRef = new AtomicReference<>();
+        // GIVEN a client that is configured to connect to a peer
+        // to which the connection can be established on the third attempt only
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
+            @Override
+            public void connect(final ProtonClientOptions options, final String username, final String password,
+                                final Handler<AsyncResult<ProtonConnection>> closeHandler,
+                                final Handler<ProtonConnection> disconnectHandler,
+                                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+                // and GIVEN "checkConnected" invocations done while the "connect" invocation is still in progress
+                if (checkConnectedInvocationsDone.compareAndSet(false, true)) {
+                    checkConnected1FutureRef.set(honoConnection.checkConnected());
+                    checkConnected2FutureRef.set(honoConnection.checkConnected());
+                    // assert "checkConnected" invocations have not completed yet
+                    ctx.assertFalse(checkConnected1FutureRef.get().isComplete());
+                    ctx.assertFalse(checkConnected2FutureRef.get().isComplete());
+                }
+                super.connect(options, username, password, closeHandler, disconnectHandler, connectionResultHandler);
+            }
+        };
+        connectionFactory.setExpectedFailingConnectionAttempts(2);
+        props.setReconnectAttempts(2);
+        props.setConnectTimeout(10);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+
+        // WHEN trying to connect
+        honoConnection.connect()
+                // THEN the "checkConnected" futures succeed
+                .compose(v -> CompositeFuture.all(checkConnected1FutureRef.get(), checkConnected2FutureRef.get()))
+                .setHandler(ctx.asyncAssertSuccess());
+
+        // and the client fails twice to connect
+        assertTrue(connectionFactory.awaitFailure());
+        // and succeeds to connect on the third attempt
+        assertTrue(connectionFactory.await());
+    }
+
+    /**
+     * Verifies that {@link HonoConnectionImpl#checkConnected()} only completes once a concurrent
+     * connection attempt (which eventually fails here) is finished.
+     *
+     * @param ctx The vert.x test client.
+     */
+    @Test
+    public void testCheckConnectedFailsAfterConcurrentReconnectFailed(final TestContext ctx) {
+
+        final AtomicBoolean checkConnectedInvocationsDone = new AtomicBoolean(false);
+        final AtomicReference<Future<Void>> checkConnected1FutureRef = new AtomicReference<>();
+        final AtomicReference<Future<Void>> checkConnected2FutureRef = new AtomicReference<>();
+        // GIVEN a client that is configured to connect to a peer
+        // to which the connection can be established on the third attempt only
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
+            @Override
+            public void connect(final ProtonClientOptions options, final String username, final String password,
+                                final Handler<AsyncResult<ProtonConnection>> closeHandler,
+                                final Handler<ProtonConnection> disconnectHandler,
+                                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+                // and GIVEN "checkConnected" invocations done while the "connect" invocation is still in progress
+                if (checkConnectedInvocationsDone.compareAndSet(false, true)) {
+                    checkConnected1FutureRef.set(honoConnection.checkConnected());
+                    checkConnected2FutureRef.set(honoConnection.checkConnected());
+                    // assert "checkConnected" invocations have not completed yet
+                    ctx.assertFalse(checkConnected1FutureRef.get().isComplete());
+                    ctx.assertFalse(checkConnected2FutureRef.get().isComplete());
+                }
+                super.connect(options, username, password, closeHandler, disconnectHandler, connectionResultHandler);
+            }
+        };
+        connectionFactory.setExpectedFailingConnectionAttempts(3);
+        props.setReconnectAttempts(2);
+        props.setConnectTimeout(10);
+        honoConnection = new HonoConnectionImpl(vertx, connectionFactory, props);
+
+        // WHEN the client tries to connect
+        honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
+            // THEN the connection attempt fails and the "checkConnected" futures fail as well
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) t).getErrorCode());
+
+            ctx.assertTrue(checkConnected1FutureRef.get().failed());
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) checkConnected1FutureRef.get().cause()).getErrorCode());
+
+            ctx.assertTrue(checkConnected2FutureRef.get().failed());
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) checkConnected2FutureRef.get().cause()).getErrorCode());
+        }));
+        // and the client has indeed tried three times in total before giving up
+        assertTrue(connectionFactory.awaitFailure());
+    }
+
     /**
      * Verifies that the client does not try to re-connect to a server instance if the client was shutdown.
      * 
