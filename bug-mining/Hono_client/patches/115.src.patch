diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
index f2a1afcfd..446aceebe 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CommandConnectionImpl.java
@@ -88,8 +88,14 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
             final String deviceId,
             final Handler<CommandContext> commandConsumer,
             final Handler<Void> closeHandler) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(deviceId);
+        Objects.requireNonNull(commandConsumer);
+
         final MessageConsumer messageConsumer = commandReceivers.get(Device.asAddress(tenantId, deviceId));
         if (messageConsumer != null) {
+            log.debug("reusing existing command consumer [tenant: {}, device-id: {}]", tenantId, deviceId);
             return Future.succeededFuture(messageConsumer);
         } else {
             return createConsumer(
@@ -107,15 +113,11 @@ public class CommandConnectionImpl extends HonoClientImpl implements CommandConn
         return checkConnected().compose(con -> {
             final Future<MessageConsumer> result = Future.future();
             CommandConsumer.create(context, clientConfigProperties, connection, tenantId, deviceId,
-                    commandConsumer, closeHook -> {
-                        closeCommandConsumer(tenantId, deviceId);
-                    }, creation -> {
-                        if (creation.succeeded()) {
-                            commandReceivers.put(Device.asAddress(tenantId, deviceId), creation.result());
-                        }
-                        result.complete(creation.result());
-                    }, getTracer());
-            return result;
+                    commandConsumer, remoteClose -> closeCommandConsumer(tenantId, deviceId), result, getTracer());
+            return result.map(consumer -> {
+                commandReceivers.put(Device.asAddress(tenantId, deviceId), consumer);
+                return consumer;
+            });
         });
     }
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 4a2d07a3d..c803b1e97 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -82,8 +82,10 @@ import io.vertx.proton.ProtonDelivery;
  */
 public class HonoClientImpl implements HonoClient {
 
-    private static final Logger LOG = LoggerFactory.getLogger(HonoClientImpl.class);
-
+    /**
+     * A logger to be shared with subclasses.
+     */
+    protected final Logger log = LoggerFactory.getLogger(HonoClientImpl.class);
     /**
      * The configuration properties for this client.
      */
@@ -184,7 +186,7 @@ public class HonoClientImpl implements HonoClient {
      */
     @Autowired(required = false)
     public final void setTracer(final Tracer opentracingTracer) {
-        LOG.info("using OpenTracing implementation [{}]", opentracingTracer.getClass().getName());
+        log.info("using OpenTracing implementation [{}]", opentracingTracer.getClass().getName());
         this.tracer = Objects.requireNonNull(opentracingTracer);
     }
 
@@ -342,14 +344,14 @@ public class HonoClientImpl implements HonoClient {
             final Handler<ProtonConnection> disconnectHandler) {
 
         context = vertx.getOrCreateContext();
-        LOG.trace("running on vert.x context [event-loop context: {}]", context.isEventLoopContext());
+        log.trace("running on vert.x context [event-loop context: {}]", context.isEventLoopContext());
 
         // context cannot be null thus it is safe to
         // ignore the Future returned by executeOrRunContext
         executeOrRunOnContext(ignore -> {
 
             if (isConnectedInternal()) {
-                LOG.debug("already connected to server [{}:{}]", connectionFactory.getHost(),
+                log.debug("already connected to server [{}:{}]", connectionFactory.getHost(),
                         connectionFactory.getPort());
                 connectionHandler.handle(Future.succeededFuture(this));
             } else if (connecting.compareAndSet(false, true)) {
@@ -365,7 +367,7 @@ public class HonoClientImpl implements HonoClient {
                     clientOptions = options;
                 }
 
-                LOG.debug("starting attempt [#{}] to connect to server [{}:{}]",
+                log.debug("starting attempt [#{}] to connect to server [{}:{}]",
                         connectAttempts.get() + 1, connectionFactory.getHost(), connectionFactory.getPort());
                 connectionFactory.connect(
                         clientOptions,
@@ -395,7 +397,7 @@ public class HonoClientImpl implements HonoClient {
                             }
                         });
             } else {
-                LOG.debug("already trying to connect to server ...");
+                log.debug("already trying to connect to server ...");
                 connectionHandler.handle(Future.failedFuture(
                         new ClientErrorException(HttpURLConnection.HTTP_CONFLICT, "already connecting to server")));
             }
@@ -406,10 +408,10 @@ public class HonoClientImpl implements HonoClient {
             final Handler<ProtonConnection> connectionLossHandler) {
 
         if (remoteClose.failed()) {
-            LOG.info("remote server [{}:{}] closed connection with error condition: {}",
+            log.info("remote server [{}:{}] closed connection with error condition: {}",
                     connectionFactory.getHost(), connectionFactory.getPort(), remoteClose.cause().getMessage());
         } else {
-            LOG.info("remote server [{}:{}] closed connection", connectionFactory.getHost(),
+            log.info("remote server [{}:{}] closed connection", connectionFactory.getHost(),
                     connectionFactory.getPort());
         }
         connection.disconnectHandler(null);
@@ -420,9 +422,9 @@ public class HonoClientImpl implements HonoClient {
     private void onRemoteDisconnect(final ProtonConnection con, final Handler<ProtonConnection> connectionLossHandler) {
 
         if (con != connection) {
-            LOG.warn("cannot handle failure of unknown connection");
+            log.warn("cannot handle failure of unknown connection");
         } else {
-            LOG.debug("lost connection to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+            log.debug("lost connection to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
             handleConnectionLoss(connectionLossHandler);
         }
     }
@@ -479,7 +481,7 @@ public class HonoClientImpl implements HonoClient {
             // no need to try to re-connect
             connectionHandler.handle(Future.failedFuture(new IllegalStateException("client is shut down")));
         } else if (clientConfigProperties.getReconnectAttempts() - connectAttempts.getAndIncrement() == 0) {
-            LOG.debug("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
+            log.debug("max number of attempts [{}] to re-connect to peer [{}:{}] have been made, giving up",
                     clientConfigProperties.getReconnectAttempts(), connectionFactory.getHost(), connectionFactory.getPort());
             clearState();
             if (connectionFailureCause == null) {
@@ -497,9 +499,9 @@ public class HonoClientImpl implements HonoClient {
 
         } else {
             if (connectionFailureCause != null) {
-                LOG.debug("connection attempt failed", connectionFailureCause);
+                log.debug("connection attempt failed", connectionFailureCause);
             }
-            LOG.trace("scheduling new connection attempt in {}ms ...", clientOptions.getReconnectInterval());
+            log.trace("scheduling new connection attempt in {}ms ...", clientOptions.getReconnectInterval());
             // give Vert.x some time to clean up NetClient
             vertx.setTimer(clientOptions.getReconnectInterval(), tid -> {
                 connect(clientOptions, connectionHandler, disconnectHandler);
@@ -608,7 +610,7 @@ public class HonoClientImpl implements HonoClient {
 
         final MessageSender sender = activeSenders.get(key);
         if (sender != null && sender.isOpen()) {
-            LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
+            log.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
             result.tryComplete(sender);
         } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
             // register a handler to be notified if the underlying connection to the server fails
@@ -621,25 +623,25 @@ public class HonoClientImpl implements HonoClient {
             };
             creationRequests.add(connectionFailureHandler);
             creationLocks.put(key, Boolean.TRUE);
-            LOG.debug("creating new message sender for {}", key);
+            log.debug("creating new message sender for {}", key);
 
             newSenderSupplier.get().setHandler(creationAttempt -> {
                 creationLocks.remove(key);
                 creationRequests.remove(connectionFailureHandler);
                 if (creationAttempt.succeeded()) {
                     final MessageSender newSender = creationAttempt.result();
-                    LOG.debug("successfully created new message sender for {}", key);
+                    log.debug("successfully created new message sender for {}", key);
                     activeSenders.put(key, newSender);
                     result.complete(newSender);
                 } else {
-                    LOG.debug("failed to create new message sender for {}", key, creationAttempt.cause());
+                    log.debug("failed to create new message sender for {}", key, creationAttempt.cause());
                     activeSenders.remove(key);
                     result.tryFail(creationAttempt.cause());
                 }
             });
 
         } else {
-            LOG.debug("already trying to create a message sender for {}", key);
+            log.debug("already trying to create a message sender for {}", key);
             result.tryFail(new ServerErrorException(
                     HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
         }
@@ -815,7 +817,7 @@ public class HonoClientImpl implements HonoClient {
         if (client != null) {
             client.close(s -> {
             });
-            LOG.debug("closed and removed client for [{}]", targetAddress);
+            log.debug("closed and removed client for [{}]", targetAddress);
         }
     }
 
@@ -957,7 +959,7 @@ public class HonoClientImpl implements HonoClient {
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(replyId);
 
-        LOG.debug("get or create command client for [tenantId: {}, deviceId: {}, replyId: {}]", tenantId, deviceId,
+        log.debug("get or create command client for [tenantId: {}, deviceId: {}, replyId: {}]", tenantId, deviceId,
                 replyId);
         return getOrCreateRequestResponseClient(
                 ResourceIdentifier.from(CommandConstants.COMMAND_ENDPOINT, tenantId, deviceId).toString(),
@@ -1001,7 +1003,7 @@ public class HonoClientImpl implements HonoClient {
 
         final RequestResponseClient client = activeRequestResponseClients.get(key);
         if (client != null && client.isOpen()) {
-            LOG.debug("reusing existing client [target: {}]", key);
+            log.debug("reusing existing client [target: {}]", key);
             result.complete(client);
         } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
 
@@ -1014,15 +1016,15 @@ public class HonoClientImpl implements HonoClient {
             };
             creationRequests.add(connectionFailureHandler);
             creationLocks.put(key, Boolean.TRUE);
-            LOG.debug("creating new client [target: {}]", key);
+            log.debug("creating new client [target: {}]", key);
 
             clientSupplier.get().setHandler(creationAttempt -> {
                 if (creationAttempt.succeeded()) {
-                    LOG.debug("successfully created new client [target: {}]", key);
+                    log.debug("successfully created new client [target: {}]", key);
                     activeRequestResponseClients.put(key, creationAttempt.result());
                     result.tryComplete(creationAttempt.result());
                 } else {
-                    LOG.debug("failed to create new client [target: {}]", key, creationAttempt.cause());
+                    log.debug("failed to create new client [target: {}]", key, creationAttempt.cause());
                     activeRequestResponseClients.remove(key);
                     result.tryFail(creationAttempt.cause());
                 }
@@ -1031,7 +1033,7 @@ public class HonoClientImpl implements HonoClient {
             });
 
         } else {
-            LOG.debug("already trying to create a client [target: {}]", key);
+            log.debug("already trying to create a client [target: {}]", key);
             result.fail(new ServerErrorException(
                     HttpURLConnection.HTTP_UNAVAILABLE, "no connection to service"));
         }
@@ -1048,12 +1050,12 @@ public class HonoClientImpl implements HonoClient {
             if (done.succeeded()) {
                 latch.countDown();
             } else {
-                LOG.error("could not close connection to server", done.cause());
+                log.error("could not close connection to server", done.cause());
             }
         });
         try {
             if (!latch.await(5, TimeUnit.SECONDS)) {
-                LOG.error("shutdown of client timed out after 5 seconds");
+                log.error("shutdown of client timed out after 5 seconds");
             }
         } catch (final InterruptedException e) {
             Thread.currentThread().interrupt();
@@ -1082,15 +1084,15 @@ public class HonoClientImpl implements HonoClient {
         final CountDownLatch countDown = new CountDownLatch(1);
         disconnect(disconnectResult -> {
             if (disconnectResult.succeeded()) {
-                LOG.info("successfully disconnected from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+                log.info("successfully disconnected from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
                 countDown.countDown();
             } else {
-                LOG.error("could not disconnect from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
+                log.error("could not disconnect from the server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
             }
         });
         try {
             if (!countDown.await(5, TimeUnit.SECONDS)) {
-                LOG.error("Disconnecting from the server [{}:{}] timed out after 5 seconds",
+                log.error("Disconnecting from the server [{}:{}] timed out after 5 seconds",
                         connectionFactory.getHost(), connectionFactory.getPort());
             }
         } catch (final InterruptedException e) {
@@ -1128,15 +1130,15 @@ public class HonoClientImpl implements HonoClient {
         synchronized (connectionLock) {
             if (isConnectedInternal()) {
                 executeOrRunOnContext(r -> {
-                    LOG.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
+                    log.info("closing connection to server [{}:{}]...", connectionFactory.getHost(), connectionFactory.getPort());
                     final ProtonConnection connectionToClose = connection;
                     connectionToClose.disconnectHandler(null); // make sure we are not trying to re-connect
                     connectionToClose.closeHandler(closedCon -> {
                         if (closedCon.succeeded()) {
-                            LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
+                            log.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
                                     connectionFactory.getPort());
                         } else {
-                            LOG.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
+                            log.info("closed connection to server [{}:{}]", connectionFactory.getHost(),
                                     connectionFactory.getPort(), closedCon.cause());
                         }
                         connectionToClose.disconnect();
@@ -1146,7 +1148,7 @@ public class HonoClientImpl implements HonoClient {
                     r.complete();
                 }).setHandler(handler);
             } else {
-                LOG.info("connection to server [{}:{}] already closed", connectionFactory.getHost(), connectionFactory.getPort());
+                log.info("connection to server [{}:{}] already closed", connectionFactory.getHost(), connectionFactory.getPort());
                 handler.handle(Future.succeededFuture());
             }
         }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
index 10e7d017d..9423f5aa6 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/CommandConnectionImplTest.java
@@ -13,37 +13,33 @@
 
 package org.eclipse.hono.client.impl;
 
-import static org.junit.Assert.assertNotNull;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.contains;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import java.util.Objects;
+import java.net.HttpURLConnection;
 
-import org.apache.qpid.proton.engine.impl.RecordImpl;
-import org.eclipse.hono.client.MessageConsumer;
+import org.apache.qpid.proton.amqp.transport.Source;
 import org.eclipse.hono.client.CommandConnection;
 import org.eclipse.hono.client.CommandContext;
-import org.eclipse.hono.auth.Device;
+import org.eclipse.hono.client.MessageConsumer;
+import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.util.Constants;
 import org.junit.Before;
-import org.junit.BeforeClass;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentCaptor;
 
 import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
-import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
 import io.vertx.ext.unit.junit.VertxUnitRunner;
 import io.vertx.proton.ProtonClientOptions;
@@ -64,128 +60,99 @@ public class CommandConnectionImplTest {
     @Rule
     public Timeout timeout = Timeout.seconds(3);
 
-    private static Vertx vertx;
+    private Vertx vertx;
+    private Context context;
     private ClientConfigProperties props;
     private ProtonConnection con;
 
     private CommandConnection commandConnection;
-    private ConnectionFactory connectionFactory;
+    private DisconnectHandlerProvidingConnectionFactory connectionFactory;
     private ProtonReceiver receiver;
 
-    /**
-     * Sets up vertx.
-     */
-    @BeforeClass
-    public static void setUpVertx() {
-        vertx = Vertx.vertx();
-    }
-
     /**
      * Sets up fixture.
      */
+    @SuppressWarnings("unchecked")
     @Before
     public void setUp() {
+
+        vertx = mock(Vertx.class);
+        context = mock(Context.class);
+        when(vertx.getOrCreateContext()).thenReturn(context);
+        when(context.owner()).thenReturn(vertx);
+        doAnswer(invocation -> {
+            final Handler<Void> handler = invocation.getArgument(0);
+            handler.handle(null);
+            return null;
+        }).when(context).runOnContext(any(Handler.class));
+
         props = new ClientConfigProperties();
 
         receiver = mock(ProtonReceiver.class);
-        when(receiver.attachments()).thenReturn(new RecordImpl());
-        doAnswer(invocationOnMock -> {
-            final Handler<AsyncResult<ProtonReceiver>> receiverHandler = invocationOnMock.getArgument(0);
-            receiverHandler.handle(Future.succeededFuture(receiver));
-            return receiver;
-        }).when(receiver).openHandler(any(Handler.class));
-
         con = mock(ProtonConnection.class);
-        when(con.isDisconnected()).thenReturn(Boolean.FALSE);
         when(con.createReceiver(anyString())).thenReturn(receiver);
 
-        connectionFactory = new ConnectionResultHandlerProvidingConnectionFactory(con);
+        connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
         commandConnection = new CommandConnectionImpl(vertx, connectionFactory, props);
     }
 
     /**
-     * Verifies that a command consumer can be created for a tenant and deviceId and opens a receiver link
-     * that is scoped to the device.
+     * Verifies that an attempt to open a command consumer fails if the peer
+     * rejects to open a receiver link.
      *
      * @param ctx The test context.
      */
+    @SuppressWarnings("unchecked")
     @Test
-    public void testCreateCommandConsumerSucceedsAndOpensReceiverLink(final TestContext ctx) {
+    public void testCreateCommandConsumerFailsIfPeerRejectsLink(final TestContext ctx) {
 
         final Handler<CommandContext> commandHandler = mock(Handler.class);
         final Handler<Void> closeHandler = mock(Handler.class);
-
-        final Async connected = ctx.async();
-
-        commandConnection.connect(new ProtonClientOptions()).setHandler(ctx.asyncAssertSuccess(ok -> connected.complete()));
-        connected.await();
-
-        final Future<MessageConsumer> messageConsumerFuture =
-                commandConnection.getOrCreateCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
-        assertNotNull(messageConsumerFuture);
-
-        final Async consumerCreated = ctx.async();
-        messageConsumerFuture.setHandler(ctx.asyncAssertSuccess(ok ->
-                consumerCreated.complete()));
-        consumerCreated.await();
-
-        verify(receiver).open();
-        verify(con).createReceiver(contains(Device.asAddress("theTenant", "theDevice")));
+        final Source source = mock(Source.class);
+        when(source.getAddress()).thenReturn(null);
+        when(receiver.getRemoteSource()).thenReturn(source);
+
+        commandConnection.connect(new ProtonClientOptions())
+            .compose(c -> {
+                final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
+                final Future<MessageConsumer> consumer = commandConnection.getOrCreateCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
+                verify(con).createReceiver("control/theTenant/theDevice");
+                verify(receiver).openHandler(linkOpenHandler.capture());
+                verify(receiver).open();
+                linkOpenHandler.getValue().handle(Future.succeededFuture());
+                return consumer;
+            }).setHandler(ctx.asyncAssertFailure(t -> {
+                ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServiceInvocationException) t).getErrorCode());
+            }));
     }
 
-
     /**
-     * A connection factory that provides access to the connection result handler registered with
-     * a connection passed to the factory.
+     * Verifies that an attempt to open a command consumer for a
+     * tenant and device Id succeeds if the peer agrees to open a
+     * corresponding receiver link that is scoped to the device.
+     *
+     * @param ctx The test context.
      */
-    private static class ConnectionResultHandlerProvidingConnectionFactory implements ConnectionFactory {
-
-        private final ProtonConnection connectionToCreate;
-
-        ConnectionResultHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
-            this.connectionToCreate = Objects.requireNonNull(conToCreate);
-        }
-
-        @Override
-        public void connect(
-                final ProtonClientOptions options,
-                final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                final Handler<ProtonConnection> disconnectHandler,
-                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-            connect(options, null, null, closeHandler, disconnectHandler, connectionResultHandler);
-        }
-
-        @Override
-        public void connect(
-                final ProtonClientOptions options,
-                final String username,
-                final String password,
-                final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                final Handler<ProtonConnection> disconnectHandler,
-                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-
-            connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
-        }
-
-        @Override
-        public String getName() {
-            return "client";
-        }
-
-        @Override
-        public String getHost() {
-            return "server";
-        }
-
-        @Override
-        public int getPort() {
-            return Constants.PORT_AMQP;
-        }
-
-        @Override
-        public String getPathSeparator() {
-            return Constants.DEFAULT_PATH_SEPARATOR;
-        }
-    }
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testCreateCommandConsumerSucceeds(final TestContext ctx) {
 
+        final String address = "control/theTenant/theDevice";
+        final Handler<CommandContext> commandHandler = mock(Handler.class);
+        final Handler<Void> closeHandler = mock(Handler.class);
+        final Source source = mock(Source.class);
+        when(source.getAddress()).thenReturn(address);
+        when(receiver.getRemoteSource()).thenReturn(source);
+
+        commandConnection.connect(new ProtonClientOptions())
+            .compose(c -> {
+                final ArgumentCaptor<Handler<AsyncResult<ProtonReceiver>>> linkOpenHandler = ArgumentCaptor.forClass(Handler.class);
+                final Future<MessageConsumer> consumer = commandConnection.getOrCreateCommandConsumer("theTenant", "theDevice", commandHandler, closeHandler);
+                verify(con).createReceiver(address);
+                verify(receiver).openHandler(linkOpenHandler.capture());
+                verify(receiver).open();
+                linkOpenHandler.getValue().handle(Future.succeededFuture(receiver));
+                return consumer;
+            }).setHandler(ctx.asyncAssertSuccess());
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DisconnectHandlerProvidingConnectionFactory.java b/client/src/test/java/org/eclipse/hono/client/impl/DisconnectHandlerProvidingConnectionFactory.java
new file mode 100644
index 000000000..2b735d771
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DisconnectHandlerProvidingConnectionFactory.java
@@ -0,0 +1,187 @@
+/**
+ * Copyright (c) 2018 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client.impl;
+
+import java.util.Objects;
+import java.util.concurrent.CountDownLatch;
+
+import org.eclipse.hono.connection.ConnectionFactory;
+import org.eclipse.hono.util.Constants;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.proton.ProtonClientOptions;
+import io.vertx.proton.ProtonConnection;
+
+/**
+ * A connection factory that provides access to the disconnect handler registered with
+ * a connection created by the factory.
+ *
+ */
+public class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {
+
+    private final ProtonConnection connectionToCreate;
+
+    private Handler<ProtonConnection> disconnectHandler;
+    private Handler<AsyncResult<ProtonConnection>> closeHandler;
+    private CountDownLatch expectedSucceedingConnectionAttempts;
+    private CountDownLatch expectedFailingConnectionAttempts;
+    private Throwable causeForFailure;
+
+    DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
+        this.connectionToCreate = Objects.requireNonNull(conToCreate);
+        failWith(new IllegalStateException("connection refused"));
+        setExpectedFailingConnectionAttempts(0);
+        setExpectedSucceedingConnectionAttempts(1);
+    }
+
+    @Override
+    public void connect(
+            final ProtonClientOptions options,
+            final Handler<AsyncResult<ProtonConnection>> closeHandler,
+            final Handler<ProtonConnection> disconnectHandler,
+            final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+        connect(options, null, null, closeHandler, disconnectHandler, connectionResultHandler);
+    }
+
+    @Override
+    public void connect(
+            final ProtonClientOptions options,
+            final String username,
+            final String password,
+            final Handler<AsyncResult<ProtonConnection>> closeHandler,
+            final Handler<ProtonConnection> disconnectHandler,
+            final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
+
+        this.closeHandler = closeHandler;
+        this.disconnectHandler = disconnectHandler;
+        if (expectedFailingConnectionAttempts.getCount() > 0) {
+            connectionResultHandler.handle(Future.failedFuture(causeForFailure));
+            expectedFailingConnectionAttempts.countDown();
+        } else {
+            connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
+            expectedSucceedingConnectionAttempts.countDown();
+        }
+    }
+
+    @Override
+    public String getName() {
+        return "client";
+    }
+
+    @Override
+    public String getHost() {
+        return "server";
+    }
+
+    @Override
+    public int getPort() {
+        return Constants.PORT_AMQP;
+    }
+
+    @Override
+    public String getPathSeparator() {
+        return Constants.DEFAULT_PATH_SEPARATOR;
+    }
+
+    /**
+     * Gets the disconnect handler which will be invoked on loss of
+     * connection.
+     * 
+     * @return The handler.
+     */
+    public Handler<ProtonConnection> getDisconnectHandler() {
+        return disconnectHandler;
+    }
+
+    /**
+     * Gets the handler which will be invoked when the peer closes
+     * the connection.
+     * 
+     * @return The handler.
+     */
+    public Handler<AsyncResult<ProtonConnection>> getCloseHandler() {
+        return closeHandler;
+    }
+
+    /**
+     * Sets the number of connection attempts that this factory should fail
+     * before succeeding.
+     * 
+     * @param attempts The number of attempts.
+     * @return This factory for command chaining.
+     * @see #awaitFailure()
+     */
+    public DisconnectHandlerProvidingConnectionFactory setExpectedFailingConnectionAttempts(final int attempts) {
+        expectedFailingConnectionAttempts = new CountDownLatch(attempts);
+        return this;
+    }
+
+    /**
+     * Sets the number of successful invocations of the connect method that this factory should expect.
+     * 
+     * @param attempts The number of attempts.
+     * @return This factory for command chaining.
+     * @see #await()
+     */
+    public DisconnectHandlerProvidingConnectionFactory setExpectedSucceedingConnectionAttempts(final int attempts) {
+        expectedSucceedingConnectionAttempts = new CountDownLatch(attempts);
+        return this;
+    }
+
+    /**
+     * Sets the root cause that this factory should fail connection attempts with.
+     * 
+     * @param cause The root cause.
+     * @return This factory for command chaining.
+     */
+    public DisconnectHandlerProvidingConnectionFactory failWith(final Throwable cause) {
+        this.causeForFailure = Objects.requireNonNull(cause);
+        return this;
+    }
+
+    /**
+     * Waits for the expected number of succeeding connection attempts to
+     * occur.
+     * 
+     * @return {@code true} if the expected number of attempts have succeeded.
+     */
+    public boolean await() {
+        try {
+            expectedSucceedingConnectionAttempts.await();
+            return true;
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            return false;
+        }
+    }
+
+    /**
+     * Waits for the expected number of failing connection attempts to
+     * occur.
+     *  
+     * @return {@code true} if the expected number of attempts have failed.
+     */
+    public boolean awaitFailure() {
+        try {
+            expectedFailingConnectionAttempts.await();
+            return true;
+        } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            return false;
+        }
+    }
+}
\ No newline at end of file
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index f07c95688..79b795a67 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -17,8 +17,6 @@ import static org.junit.Assert.assertTrue;
 import static org.mockito.Mockito.*;
 
 import java.net.HttpURLConnection;
-import java.util.Objects;
-import java.util.concurrent.CountDownLatch;
 
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
@@ -27,8 +25,6 @@ import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
-import org.eclipse.hono.connection.ConnectionFactory;
-import org.eclipse.hono.util.Constants;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.BeforeClass;
@@ -37,9 +33,7 @@ import org.junit.Test;
 import org.junit.rules.Timeout;
 import org.junit.runner.RunWith;
 
-import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
-import io.vertx.core.Handler;
 import io.vertx.core.Vertx;
 import io.vertx.ext.unit.Async;
 import io.vertx.ext.unit.TestContext;
@@ -532,131 +526,4 @@ public class HonoClientImplTest {
         // THEN reconnect gets stopped, i.e. connection fails
         connectionHandlerInvocation.await();
     }
-
-    /**
-     * A connection factory that provides access to the disconnect handler registered with
-     * a connection created by the factory.
-     *
-     */
-    private static class DisconnectHandlerProvidingConnectionFactory implements ConnectionFactory {
-
-        private final ProtonConnection connectionToCreate;
-
-        private Handler<ProtonConnection> disconnectHandler;
-        private Handler<AsyncResult<ProtonConnection>> closeHandler;
-        private CountDownLatch expectedSucceedingConnectionAttempts;
-        private CountDownLatch expectedFailingConnectionAttempts;
-        private Throwable causeForFailure;
-
-        DisconnectHandlerProvidingConnectionFactory(final ProtonConnection conToCreate) {
-            this.connectionToCreate = Objects.requireNonNull(conToCreate);
-            failWith(new IllegalStateException("connection refused"));
-            setExpectedFailingConnectionAttempts(0);
-            setExpectedSucceedingConnectionAttempts(1);
-        }
-
-        @Override
-        public void connect(
-                final ProtonClientOptions options,
-                final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                final Handler<ProtonConnection> disconnectHandler,
-                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-            connect(options, null, null, closeHandler, disconnectHandler, connectionResultHandler);
-        }
-
-        @Override
-        public void connect(
-                final ProtonClientOptions options,
-                final String username,
-                final String password,
-                final Handler<AsyncResult<ProtonConnection>> closeHandler,
-                final Handler<ProtonConnection> disconnectHandler,
-                final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-
-            this.closeHandler = closeHandler;
-            this.disconnectHandler = disconnectHandler;
-            if (expectedFailingConnectionAttempts.getCount() > 0) {
-                connectionResultHandler.handle(Future.failedFuture(causeForFailure));
-                expectedFailingConnectionAttempts.countDown();
-            } else {
-                connectionResultHandler.handle(Future.succeededFuture(connectionToCreate));
-                expectedSucceedingConnectionAttempts.countDown();
-            }
-        }
-
-        @Override
-        public String getName() {
-            return "client";
-        }
-
-        @Override
-        public String getHost() {
-            return "server";
-        }
-
-        @Override
-        public int getPort() {
-            return Constants.PORT_AMQP;
-        }
-
-        @Override
-        public String getPathSeparator() {
-            return Constants.DEFAULT_PATH_SEPARATOR;
-        }
-
-        public Handler<ProtonConnection> getDisconnectHandler() {
-            return disconnectHandler;
-        }
-
-        public Handler<AsyncResult<ProtonConnection>> getCloseHandler() {
-            return closeHandler;
-        }
-
-        public DisconnectHandlerProvidingConnectionFactory setExpectedFailingConnectionAttempts(final int attempts) {
-            expectedFailingConnectionAttempts = new CountDownLatch(attempts);
-            return this;
-        }
-
-        public DisconnectHandlerProvidingConnectionFactory setExpectedSucceedingConnectionAttempts(final int attempts) {
-            expectedSucceedingConnectionAttempts = new CountDownLatch(attempts);
-            return this;
-        }
-
-        public DisconnectHandlerProvidingConnectionFactory failWith(final Throwable cause) {
-            this.causeForFailure = Objects.requireNonNull(cause);
-            return this;
-        }
-
-        /**
-         * Waits for the expected number of succeeding connection attempts to
-         * occur.
-         * 
-         * @return {@code true} if the expected number of attempts have succeeded.
-         */
-        public boolean await() {
-            try {
-                expectedSucceedingConnectionAttempts.await();
-                return true;
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-                return false;
-            }
-        }
-
-        /**
-         * Waits for the expected number of failing connection attempts to
-         * occur.
-         *  
-         * @return {@code true} if the expected number of attempts have failed.
-         */
-        public boolean awaitFailure() {
-            try {
-                expectedFailingConnectionAttempts.await();
-                return true;
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-                return false;
-            }
-        }
-    }
 }
