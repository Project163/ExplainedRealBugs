diff --git a/client/src/main/java/org/eclipse/hono/client/BasicDeviceConnectionClientFactory.java b/client/src/main/java/org/eclipse/hono/client/BasicDeviceConnectionClientFactory.java
new file mode 100644
index 000000000..f1ed197b6
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/BasicDeviceConnectionClientFactory.java
@@ -0,0 +1,35 @@
+/**
+ * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ */
+
+
+package org.eclipse.hono.client;
+
+import io.vertx.core.Future;
+
+/**
+ * A factory for creating clients for Hono's Device Connection API.
+ *
+ */
+public interface BasicDeviceConnectionClientFactory {
+
+    /**
+     * Gets a client for invoking operations on a service implementing Hono's <em>Device Connection</em> API.
+     *
+     * @param tenantId The tenant to manage device connection data for.
+     * @return A future that will complete with the device connection client (if successful) or fail if the client
+     *         cannot be created, e.g. because the underlying connection is not established or if a concurrent
+     *         request to create a client for the same tenant is already being executed.
+     * @throws NullPointerException if the tenant is {@code null}.
+     */
+    Future<DeviceConnectionClient> getOrCreateDeviceConnectionClient(String tenantId);
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java
index 56e6c92ec..be3dc403a 100644
--- a/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/DeviceConnectionClientFactory.java
@@ -16,13 +16,11 @@ package org.eclipse.hono.client;
 
 import org.eclipse.hono.client.impl.DeviceConnectionClientFactoryImpl;
 
-import io.vertx.core.Future;
-
 /**
  * A factory for creating clients for Hono's Device Connection API.
  *
  */
-public interface DeviceConnectionClientFactory extends ConnectionLifecycle<HonoConnection> {
+public interface DeviceConnectionClientFactory extends BasicDeviceConnectionClientFactory, ConnectionLifecycle<HonoConnection> {
 
     /**
      * Creates a new factory for an existing connection.
@@ -34,15 +32,4 @@ public interface DeviceConnectionClientFactory extends ConnectionLifecycle<HonoC
     static DeviceConnectionClientFactory create(final HonoConnection connection) {
         return new DeviceConnectionClientFactoryImpl(connection);
     }
-
-    /**
-     * Gets a client for invoking operations on a service implementing Hono's <em>Device Connection</em> API.
-     *
-     * @param tenantId The tenant to manage device connection data for.
-     * @return A future that will complete with the device connection client (if successful) or fail if the client
-     *         cannot be created, e.g. because the underlying connection is not established or if a concurrent
-     *         request to create a client for the same tenant is already being executed.
-     * @throws NullPointerException if the tenant is {@code null}.
-     */
-    Future<DeviceConnectionClient> getOrCreateDeviceConnectionClient(String tenantId);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java b/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java
index 7a2e4fa85..1689015af 100644
--- a/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/GatewayMapper.java
@@ -34,8 +34,11 @@ public interface GatewayMapper extends ConnectionLifecycle<HonoConnection> {
      * @return The GatewayMapper instance.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    static GatewayMapper create(final RegistrationClientFactory registrationClientFactory,
-            final DeviceConnectionClientFactory deviceConnectionClientFactory, final Tracer tracer) {
+    static GatewayMapper create(
+            final RegistrationClientFactory registrationClientFactory,
+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory,
+            final Tracer tracer) {
+
         return new GatewayMapperImpl(registrationClientFactory, deviceConnectionClientFactory, tracer);
     }
 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
index e622db1b0..bb77b6e75 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
@@ -16,9 +16,9 @@ package org.eclipse.hono.client.impl;
 import java.net.HttpURLConnection;
 import java.util.Objects;
 
+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.ConnectionLifecycle;
-import org.eclipse.hono.client.DeviceConnectionClientFactory;
 import org.eclipse.hono.client.DisconnectListener;
 import org.eclipse.hono.client.GatewayMapper;
 import org.eclipse.hono.client.HonoConnection;
@@ -48,12 +48,12 @@ import io.vertx.core.json.JsonObject;
 /**
  * A component that maps a given device to the gateway through which data was last published for the given device.
  */
-public class GatewayMapperImpl implements GatewayMapper, ConnectionLifecycle<HonoConnection> {
+public class GatewayMapperImpl implements GatewayMapper {
 
     private static final Logger LOG = LoggerFactory.getLogger(GatewayMapperImpl.class);
 
     private final RegistrationClientFactory registrationClientFactory;
-    private final DeviceConnectionClientFactory deviceConnectionClientFactory;
+    private final BasicDeviceConnectionClientFactory deviceConnectionClientFactory;
     private final Tracer tracer;
 
     /**
@@ -64,8 +64,11 @@ public class GatewayMapperImpl implements GatewayMapper, ConnectionLifecycle<Hon
      * @param tracer The tracer instance.
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
-    public GatewayMapperImpl(final RegistrationClientFactory registrationClientFactory,
-            final DeviceConnectionClientFactory deviceConnectionClientFactory, final Tracer tracer) {
+    public GatewayMapperImpl(
+            final RegistrationClientFactory registrationClientFactory,
+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory,
+            final Tracer tracer) {
+
         this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);
         this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);
         this.tracer = Objects.requireNonNull(tracer);
@@ -156,50 +159,80 @@ public class GatewayMapperImpl implements GatewayMapper, ConnectionLifecycle<Hon
     @Override
     public Future<HonoConnection> connect() {
         final Future<HonoConnection> registrationFuture = registrationClientFactory.connect();
-        final Future<HonoConnection> deviceConnectionFuture = deviceConnectionClientFactory.connect();
-        return CompositeFuture.all(registrationFuture, deviceConnectionFuture).map(cf -> deviceConnectionFuture.result());
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            final Future<?> deviceConnectionFuture = ((ConnectionLifecycle<?>) deviceConnectionClientFactory).connect();
+            return CompositeFuture.all(registrationFuture, deviceConnectionFuture)
+                    .map(ok -> registrationFuture.result());
+        } else {
+            return registrationFuture;
+        }
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public void addDisconnectListener(final DisconnectListener<HonoConnection> listener) {
         registrationClientFactory.addDisconnectListener(listener);
-        deviceConnectionClientFactory.addDisconnectListener(listener);
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            ((ConnectionLifecycle<HonoConnection>) deviceConnectionClientFactory).addDisconnectListener(listener);
+        }
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public void addReconnectListener(final ReconnectListener<HonoConnection> listener) {
         registrationClientFactory.addReconnectListener(listener);
-        deviceConnectionClientFactory.addReconnectListener(listener);
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            ((ConnectionLifecycle<HonoConnection>) deviceConnectionClientFactory).addReconnectListener(listener);
+        }
     }
 
     @Override
     public Future<Void> isConnected() {
         final Future<Void> registrationFuture = registrationClientFactory.isConnected();
-        final Future<Void> deviceConnectionFuture = deviceConnectionClientFactory.isConnected();
-        return CompositeFuture.all(registrationFuture, deviceConnectionFuture).mapEmpty();
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            final Future<Void> deviceConnectionFuture = ((ConnectionLifecycle<?>) deviceConnectionClientFactory).isConnected();
+            return CompositeFuture.all(registrationFuture, deviceConnectionFuture)
+                    .mapEmpty();
+        } else {
+            return registrationFuture;
+        }
     }
 
     @Override
     public Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
         final Future<Void> registrationFuture = registrationClientFactory.isConnected(waitForCurrentConnectAttemptTimeout);
-        final Future<Void> deviceConnectionFuture = deviceConnectionClientFactory.isConnected(waitForCurrentConnectAttemptTimeout);
-        return CompositeFuture.all(registrationFuture, deviceConnectionFuture).mapEmpty();
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            final Future<?> deviceConnectionFuture = ((ConnectionLifecycle<?>) deviceConnectionClientFactory).isConnected(waitForCurrentConnectAttemptTimeout);
+            return CompositeFuture.all(registrationFuture, deviceConnectionFuture).mapEmpty();
+        } else {
+            return registrationFuture;
+        }
     }
 
     @Override
     public void disconnect() {
         registrationClientFactory.disconnect();
-        deviceConnectionClientFactory.disconnect();
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            ((ConnectionLifecycle<?>) deviceConnectionClientFactory).disconnect();
+        }
     }
 
     @Override
     public void disconnect(final Handler<AsyncResult<Void>> completionHandler) {
 
         final Promise<Void> registrationDisconnectPromise = Promise.promise();
-        registrationClientFactory.disconnect(registrationDisconnectPromise);
         final Promise<Void> deviceConnectionDisconnectPromise = Promise.promise();
-        deviceConnectionClientFactory.disconnect(deviceConnectionDisconnectPromise);
+
+        registrationClientFactory.disconnect(registrationDisconnectPromise);
+
+        if (deviceConnectionClientFactory instanceof ConnectionLifecycle) {
+            ((ConnectionLifecycle<?>) deviceConnectionClientFactory).disconnect(deviceConnectionDisconnectPromise);
+        } else {
+            deviceConnectionDisconnectPromise.complete();
+        }
+
         CompositeFuture.all(registrationDisconnectPromise.future(), deviceConnectionDisconnectPromise.future())
-                .map(obj -> deviceConnectionDisconnectPromise.future().result()).setHandler(completionHandler);
+        .map(ok -> (Void) null)
+        .setHandler(completionHandler);
     }
 }
