diff --git a/client/pom.xml b/client/pom.xml
index 9eccda9aa..a3cbdf9c7 100644
--- a/client/pom.xml
+++ b/client/pom.xml
@@ -78,6 +78,10 @@
       <artifactId>vertx-codegen</artifactId>
       <classifier>processor</classifier>
     </dependency>
+    <dependency>
+      <groupId>io.opentracing</groupId>
+      <artifactId>opentracing-noop</artifactId>
+    </dependency>
   </dependencies>
 
   <build>
@@ -100,6 +104,17 @@
             <Include-Resource>
               META-INF=${project.build.outputDirectory}/META-INF
             </Include-Resource>
+            <!--
+              The OpenTracing Noop artifact is not a bundle, so we inline
+              and export its packages.
+            -->
+            <Export-Package>
+              io.opentracing.noop;version=${opentracing.version},
+              {local-packages}
+            </Export-Package>
+            <Embed-Dependency>
+              opentracing-noop;inline=true,
+            </Embed-Dependency>
           </instructions>
         </configuration>
       </plugin>
diff --git a/client/src/main/java/org/eclipse/hono/client/MessageSender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
index d3525c846..080538197 100644
--- a/client/src/main/java/org/eclipse/hono/client/MessageSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
@@ -8,7 +8,7 @@
  *
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
- *
+ *    Bosch Software Innovations GmbH - add Open Tracing support
  */
 
 package org.eclipse.hono.client;
@@ -17,6 +17,7 @@ import java.util.Map;
 
 import org.apache.qpid.proton.message.Message;
 
+import io.opentracing.SpanContext;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -135,6 +136,34 @@ public interface MessageSender {
      */
     Future<ProtonDelivery> send(Message message);
 
+    /**
+     * Sends an AMQP 1.0 message to the endpoint configured for this client.
+     * <p>
+     * This default implementation simply returns the result of {@link #send(Message)}.
+     * 
+     * @param message The message to send.
+     * @param context The currently active OpenTracing span. An implementation
+     *         should use this as the parent for any span it creates for tracing
+     *         the execution of this operation.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
+     * @throws NullPointerException if message is {@code null}.
+     */
+    default Future<ProtonDelivery> send(Message message, SpanContext context) {
+        return send(message);
+    }
+
     /**
      * Sends an AMQP 1.0 message to the peer and waits for the disposition indicating
      * the outcome of the transfer.
@@ -154,6 +183,32 @@ public interface MessageSender {
      */
     Future<ProtonDelivery> sendAndWaitForOutcome(Message message);
 
+    /**
+     * Sends an AMQP 1.0 message to the peer and waits for the disposition indicating
+     * the outcome of the transfer.
+     * <p>
+     * This default implementation simply returns the result of {@link #sendAndWaitForOutcome(Message)}.
+     * 
+     * @param message The message to send.
+     * @param context The currently active OpenTracing span. An implementation
+     *         should use this as the parent for any span it creates for tracing
+     *         the execution of this operation.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been accepted (and settled)
+     *         by the peer.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
+     * @throws NullPointerException if message is {@code null}.
+     */
+    default Future<ProtonDelivery> sendAndWaitForOutcome(Message message, SpanContext context) {
+        return sendAndWaitForOutcome(message);
+    }
+
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      * 
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index fbc739ebc..9bd781938 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -9,6 +9,7 @@
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
  *    Red Hat Inc
+ *    Bosch Software Innovations GmbH - add Open Tracing support
  */
 
 package org.eclipse.hono.client.impl;
@@ -19,6 +20,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Optional;
 
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
@@ -28,9 +30,16 @@ import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.client.StatusCodeMapper;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.tracing.TracingHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.opentracing.References;
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.noop.NoopTracerFactory;
+import io.opentracing.tag.Tags;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
@@ -77,6 +86,11 @@ public abstract class AbstractHonoClient {
      * The capabilities offered by the peer.
      */
     protected List<Symbol> offeredCapabilities = Collections.emptyList();
+    /**
+     * The <em>OpenTracing</em> tracer to use for tracking request processing
+     * across process boundaries.
+     */
+    protected Tracer tracer;
 
     /**
      * Creates a client for a vert.x context.
@@ -86,8 +100,93 @@ public abstract class AbstractHonoClient {
      * @throws NullPointerException if any of the parameters is {@code null}.
      */
     protected AbstractHonoClient(final Context context, final ClientConfigProperties config) {
+        this(context, config, null);
+    }
+
+    /**
+     * Creates a client for a vert.x context.
+     * 
+     * @param context The context to run all interactions with the server on.
+     * @param config The configuration properties to use.
+     * @param tracer The tracer to use for tracking request processing
+     *               across process boundaries.
+     * @throws NullPointerException if context or config are {@code null}.
+     */
+    protected AbstractHonoClient(final Context context, final ClientConfigProperties config, final Tracer tracer) {
         this.context = Objects.requireNonNull(context);
         this.config = Objects.requireNonNull(config);
+        this.tracer = Optional.ofNullable(tracer).orElse(NoopTracerFactory.create());
+    }
+
+    /**
+     * Marks an <em>OpenTracing</em> span as erroneous and logs an exception.
+     * <p>
+     * This method does <em>not</em> finish the span.
+     * 
+     * @param span The span to mark.
+     * @param error The exception that has occurred. If the exception is a
+     *              {@link ServiceInvocationException} then a {@link Tags#HTTP_STATUS}
+     *              tag is added containing the exception's error code property value.
+     * @throws NullPointerException if error is {@code null}.
+     */
+    protected final void logError(final Span span, final Throwable error) {
+        if (span != null) {
+            if (ServiceInvocationException.class.isInstance(error)) {
+                final ServiceInvocationException e = (ServiceInvocationException) error;
+                Tags.HTTP_STATUS.set(span, e.getErrorCode());
+            }
+            TracingHelper.logError(span, error);
+        }
+    }
+
+    /**
+     * Creates a new <em>OpenTracing</em> span for tracing the execution of a service invocation.
+     * <p>
+     * The returned span will already contain the following tags:
+     * <ul>
+     * <li>{@link Tags#COMPONENT} - set to <em>hono-client</em></li>
+     * <li>{@link Tags#PEER_HOSTNAME} - set to {@link ClientConfigProperties#getHost()}</li>
+     * <li>{@link Tags#PEER_PORT} - set to {@link ClientConfigProperties#getPort()}</li>
+     * </ul>
+     * 
+     * @param parent The existing span. If not {@code null} then the new span will have a
+     *                     {@link References#CHILD_OF} reference to the existing span.
+     * @param operationName The operation name that the span should be created for.
+     * @return The new span.
+     */
+    protected final Span newChildSpan(final SpanContext parent, final String operationName) {
+
+        return newSpan(parent, References.CHILD_OF, operationName);
+    }
+
+    /**
+     * Creates a new <em>OpenTracing</em> span for tracing the execution of a service invocation.
+     * <p>
+     * The returned span will already contain the following tags:
+     * <ul>
+     * <li>{@link Tags#COMPONENT} - set to <em>hono-client</em></li>
+     * <li>{@link Tags#PEER_HOSTNAME} - set to {@link ClientConfigProperties#getHost()}</li>
+     * <li>{@link Tags#PEER_PORT} - set to {@link ClientConfigProperties#getPort()}</li>
+     * </ul>
+     * 
+     * @param parent The existing span. If not {@code null} then the new span will have a
+     *                     {@link References#FOLLOWS_FROM} reference to the existing span.
+     * @param operationName The operation name that the span should be created for.
+     * @return The new span.
+     */
+    protected final Span newFollowingSpan(final SpanContext parent, final String operationName) {
+
+        return newSpan(parent, References.FOLLOWS_FROM, operationName);
+    }
+
+    private Span newSpan(final SpanContext parent, final String referenceType, final String operationName) {
+
+        return tracer.buildSpan(operationName)
+                    .addReference(referenceType, parent)
+                    .withTag(Tags.COMPONENT.getKey(), "hono-client")
+                    .withTag(Tags.PEER_HOSTNAME.getKey(), config.getHost())
+                    .withTag(Tags.PEER_PORT.getKey(), config.getPort())
+                    .start();
     }
 
     /**
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index c7bcd1104..bb34d97b8 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -8,7 +8,7 @@
  *
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
- *
+ *    Bosch Software Innovations GmbH - add Open Tracing support
  */
 
 package org.eclipse.hono.client.impl;
@@ -29,27 +29,36 @@ import org.apache.qpid.proton.amqp.Binary;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Data;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.tracing.MessageAnnotationsInjectAdapter;
+import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.Constants;
 import org.eclipse.hono.util.MessageHelper;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.propagation.Format;
+import io.opentracing.tag.Tags;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonHelper;
+import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonSender;
 
 /**
- * A Vertx-Proton based client for publishing messages to a Hono server.
+ * A Vertx-Proton based client for publishing messages to Hono.
  */
 abstract public class AbstractSender extends AbstractHonoClient implements MessageSender {
 
@@ -87,15 +96,17 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      *           that this sender is used to send downstream.
      * @param targetAddress The target address to send the messages to.
      * @param context The vert.x context to use for sending the messages.
+     * @param tracer The tracer to use.
      */
     protected AbstractSender(
             final ClientConfigProperties config,
             final ProtonSender sender,
             final String tenantId,
             final String targetAddress,
-            final Context context) {
+            final Context context,
+            final Tracer tracer) {
 
-        super(context, config);
+        super(context, config, tracer);
         this.sender = Objects.requireNonNull(sender);
         this.tenantId = Objects.requireNonNull(tenantId);
         this.targetAddress = targetAddress;
@@ -158,7 +169,8 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
         if (capacityAvailableHandler == null) {
             final Future<ProtonDelivery> result = Future.future();
             context.runOnContext(send -> {
-                sendMessage(rawMessage).setHandler(result.completer());
+                final Span currentSpan = startSpan(rawMessage);
+                sendMessage(rawMessage, currentSpan).setHandler(result.completer());
             });
             return result;
         } else if (this.drainHandler != null) {
@@ -166,7 +178,8 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
         } else if (sender.isOpen()) {
             final Future<ProtonDelivery> result = Future.future();
             context.runOnContext(send -> {
-                sendMessage(rawMessage).setHandler(result.completer());
+                final Span currentSpan = startSpan(rawMessage);
+                sendMessage(rawMessage, currentSpan).setHandler(result.completer());
                 if (sender.sendQueueFull()) {
                     sendQueueDrainHandler(capacityAvailableHandler);
                 } else {
@@ -182,17 +195,33 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
     @Override
     public final Future<ProtonDelivery> send(final Message rawMessage) {
 
+        return send(rawMessage, (SpanContext) null);
+    }
+
+    @Override
+    public final Future<ProtonDelivery> send(final Message rawMessage, final SpanContext parent) {
+
         Objects.requireNonNull(rawMessage);
 
         if (!isRegistrationAssertionRequired()) {
             MessageHelper.getAndRemoveRegistrationAssertion(rawMessage);
         }
+
+        final Span span = startSpan(parent, rawMessage);
+        Tags.MESSAGE_BUS_DESTINATION.set(span, targetAddress);
+        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
+        span.setTag(MessageHelper.APP_PROPERTY_DEVICE_ID, MessageHelper.getDeviceId(rawMessage));
+        tracer.inject(span.context(), Format.Builtin.TEXT_MAP, new MessageAnnotationsInjectAdapter(rawMessage));
+
         final Future<ProtonDelivery> result = Future.future();
         context.runOnContext(send -> {
             if (sender.sendQueueFull()) {
-                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available"));
+                final ServiceInvocationException e = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available");
+                logError(span, e);
+                span.finish();
+                result.fail(e);
             } else {
-                sendMessage(rawMessage).setHandler(result.completer());
+                sendMessage(rawMessage, span).setHandler(result.completer());
             }
         });
         return result;
@@ -280,6 +309,9 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      * the Hono API this client interacts with.
      * 
      * @param message The message to send.
+     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
+     *              The span will be finished by this method and will contain an error log if
+     *              the message has not been accepted by the peer.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will be succeeded if the message has been sent to the endpoint.
@@ -290,9 +322,32 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} if the
      *         message could not be sent.
-     * @throws NullPointerException if the message is {@code null}.
+     * @throws NullPointerException if any of the parameters are {@code null}.
      */
-    protected abstract Future<ProtonDelivery> sendMessage(Message message);
+    protected abstract Future<ProtonDelivery> sendMessage(Message message, Span currentSpan);
+
+    /**
+     * Creates and starts a new OpenTracing {@code Span} for a message to be sent.
+     * 
+     * @param message The message to create the span for.
+     * @return The started span.
+     * @throws NullPointerException if message is {@code null}.
+     */
+    protected final Span startSpan(final Message message) {
+        return startSpan(null, message);
+    }
+
+    /**
+     * Creates and starts a new OpenTracing {@code Span} for a message to be sent
+     * in an existing context.
+     * 
+     * @param context The context to create the span in. If {@code null}, then
+     *                  the span is created without a parent.
+     * @param message The message to create the span for.
+     * @return The started span.
+     * @throws NullPointerException if message is {@code null}.
+     */
+    protected abstract Span startSpan(SpanContext context, Message message);
 
     /**
      * Gets the value of the <em>to</em> property to be used for messages produced by this sender.
@@ -345,6 +400,9 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      * and waits for the outcome of the transfer.
      * 
      * @param message The message to send.
+     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
+     *              The span will be finished by this method and will contain an error log if
+     *              the message has not been accepted by the peer.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will succeed if the message has been accepted (and settled)
@@ -354,40 +412,61 @@ abstract public class AbstractSender extends AbstractHonoClient implements Messa
      *         message could not be sent or has not been accepted by the peer.
      * @throws NullPointerException if the message is {@code null}.
      */
-    protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message) {
+    protected Future<ProtonDelivery> sendMessageAndWaitForOutcome(final Message message, final Span currentSpan) {
 
         Objects.requireNonNull(message);
 
         final Future<ProtonDelivery> result = Future.future();
         final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
         message.setMessageId(messageId);
+        TracingHelper.TAG_MESSAGE_ID.set(currentSpan, messageId);
+        TracingHelper.TAG_CREDIT.set(currentSpan, sender.getCredit());
+        TracingHelper.TAG_QOS.set(currentSpan, ProtonQoS.AT_LEAST_ONCE.toString());
         sender.send(message, deliveryUpdated -> {
+            final DeliveryState remoteState = deliveryUpdated.getRemoteState();
+            TracingHelper.TAG_REMOTE_STATE.set(currentSpan, remoteState.getClass().getSimpleName());
             if (deliveryUpdated.remotelySettled()) {
-                if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
-                    LOG.trace("message [ID: {}] accepted by peer", messageId);
+                if (Accepted.class.isInstance(remoteState)) {
                     result.complete(deliveryUpdated);
-                } else if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
-                    final Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
-                    if (rejected.getError() == null) {
-                        LOG.debug("message [message ID: {}] rejected by peer", messageId);
-                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                } else {
+                    ServiceInvocationException e = null;
+                    if (Rejected.class.isInstance(remoteState)) {
+                        final Rejected rejected = (Rejected) remoteState;
+                        if (rejected.getError() == null) {
+                            LOG.debug("message [message ID: {}] rejected by peer", messageId);
+                            e = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST);
+                        } else {
+                            LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
+                                    rejected.getError().getCondition(), rejected.getError().getDescription());
+                            e = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription());
+                        }
                     } else {
-                        LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
-                                rejected.getError().getCondition(), rejected.getError().getDescription());
-                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription()));
+                        LOG.debug("message [message ID: {}] not accepted by peer: {}", messageId, remoteState);
+                        e = new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST);
                     }
-                } else {
-                    LOG.debug("message [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
-                    result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                    result.fail(e);
                 }
             } else {
-                LOG.warn("peer did not settle message, failing delivery [new remote state: {}]", deliveryUpdated.getRemoteState());
-                result.fail(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
+                LOG.debug("peer did not settle message [message ID: {}, remote state: {}], failing delivery",
+                        messageId, remoteState.getClass().getSimpleName());
+                final ServiceInvocationException e = new ServerErrorException(
+                        HttpURLConnection.HTTP_INTERNAL_ERROR,
+                        "peer did not settle message, failing delivery");
+                result.fail(e);
             }
         });
         LOG.trace("sent message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
 
-        return result;
+        return result.map(delivery -> {
+            LOG.trace("message [ID: {}] accepted by peer", messageId);
+            Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
+            currentSpan.finish();
+            return delivery;
+        }).recover(t -> {
+            TracingHelper.logError(currentSpan, t);
+            currentSpan.finish();
+            return Future.failedFuture(t);
+        });
     }
 
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index 48a49778f..aa0e97179 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -9,7 +9,7 @@
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
  *    Red Hat Inc
- *
+ *    Bosch Software Innovations GmbH - add Open Tracing support
  */
 
 package org.eclipse.hono.client.impl;
@@ -22,6 +22,10 @@ import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.EventConstants;
 
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.tag.Tags;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
@@ -38,7 +42,12 @@ public final class EventSenderImpl extends AbstractSender {
 
     EventSenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
             final String targetAddress, final Context context) {
-        super(config, sender, tenantId, targetAddress, context);
+        this(config, sender, tenantId, targetAddress, context, null);
+    }
+
+    EventSenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
+            final String targetAddress, final Context context, final Tracer tracer) {
+        super(config, sender, tenantId, targetAddress, context, tracer);
     }
 
     /**
@@ -81,8 +90,9 @@ public final class EventSenderImpl extends AbstractSender {
      * @param closeHook The handler to invoke when the Hono server closes the sender. The sender's
      *                  target address is provided as an argument to the handler.
      * @param creationHandler The handler to invoke with the result of the creation attempt.
+     * @param tracer The <em>OpenTracing</em> {@code Tracer} to keep track of the messages sent
+     *               by the sender returned.
      * @throws NullPointerException if any of context, connection, tenant or handler is {@code null}.
-     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     public static void create(
             final Context context,
@@ -91,7 +101,8 @@ public final class EventSenderImpl extends AbstractSender {
             final String tenantId,
             final String deviceId,
             final Handler<String> closeHook,
-            final Handler<AsyncResult<MessageSender>> creationHandler) {
+            final Handler<AsyncResult<MessageSender>> creationHandler,
+            final Tracer tracer) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(con);
@@ -101,26 +112,15 @@ public final class EventSenderImpl extends AbstractSender {
         final String targetAddress = getTargetAddress(tenantId, deviceId);
         createSender(context, clientConfig, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook).compose(sender -> {
             return Future.<MessageSender> succeededFuture(
-                    new EventSenderImpl(clientConfig, sender, tenantId, targetAddress, context));
+                    new EventSenderImpl(clientConfig, sender, tenantId, targetAddress, context, tracer));
         }).setHandler(creationHandler);
     }
 
     /**
-     * Sends an AMQP 1.0 message to the peer that this client is configured for
-     * and waits for the outcome of the transfer.
+     * {@inheritDoc}
      * <p>
      * This method simply invokes {@link #send(Message)} because events are
      * always sent with at least once delivery semantics.
-     * 
-     * @param message The message to send.
-     * @return A future indicating the outcome of the operation.
-     *         <p>
-     *         The future will succeed if the message has been accepted (and settled)
-     *         by the peer.
-     *         <p>
-     *         The future will be failed with a {@link ServiceInvocationException} if the
-     *         message could not be sent or has not been accepted by the peer.
-     * @throws NullPointerException if the message is {@code null}.
      */
     @Override
     public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message) {
@@ -128,6 +128,18 @@ public final class EventSenderImpl extends AbstractSender {
         return send(message);
     }
 
+    /**
+     * {@inheritDoc}
+     * <p>
+     * This method simply invokes {@link #send(Message, SpanContext)} because events are
+     * always sent with at least once delivery semantics.
+     */
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext parent) {
+
+        return send(message, parent);
+    }
+
     /**
      * Sets the <em>durable</em> message property to {@code true}.
      */
@@ -140,9 +152,12 @@ public final class EventSenderImpl extends AbstractSender {
      * Sends an AMQP 1.0 message to the peer this client is configured for
      * and waits for the outcome of the transfer.
      * <p>
-     * This method simply invokes {@link #sendMessageAndWaitForOutcome(Message)}.
+     * This method simply invokes {@link #sendMessageAndWaitForOutcome(Message, Span)}.
      * 
      * @param message The message to send.
+     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
+     *              The span will be finished by this method and will contain an error log if
+     *              the message has not been accepted by the peer.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will succeed if the message has been accepted (and settled)
@@ -150,11 +165,23 @@ public final class EventSenderImpl extends AbstractSender {
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} if the
      *         message could not be sent or has not been accepted by the peer.
-     * @throws NullPointerException if the message is {@code null}.
+     * @throws NullPointerException if any of the parameters are {@code null}.
      */
     @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message) {
+    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
+
+        return sendMessageAndWaitForOutcome(message, currentSpan);
+    }
 
-        return sendMessageAndWaitForOutcome(message);
+    @Override
+    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
+
+        if (tracer == null) {
+            throw new IllegalStateException("no tracer configured");
+        } else {
+            final Span span = newChildSpan(parent, "forward Event");
+            Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
+            return span;
+        }
     }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 4db2fc820..5595d06df 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -52,6 +52,9 @@ import org.eclipse.hono.util.ResourceIdentifier;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import io.opentracing.Tracer;
+import io.opentracing.noop.NoopTracerFactory;
+
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
@@ -101,6 +104,7 @@ public class HonoClientImpl implements HonoClient {
     private CacheProvider cacheProvider;
     private AtomicInteger connectAttempts;
     private List<Symbol> offeredCapabilities = Collections.emptyList();
+    private Tracer tracer = NoopTracerFactory.create();
 
     /**
      * Creates a new client for a set of configuration properties.
@@ -157,6 +161,20 @@ public class HonoClientImpl implements HonoClient {
         this.cacheProvider = Objects.requireNonNull(cacheProvider);
     }
 
+    /**
+     * Sets the OpenTracing {@code Tracer} to use for tracing messages
+     * published by devices across Hono's components.
+     * <p>
+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will
+     * be used.
+     * 
+     * @param opentracingTracer The tracer.
+     */
+    public final void setTracer(final Tracer opentracingTracer) {
+        LOG.info("using OpenTracing implementation [{}]", opentracingTracer.getClass().getName());
+        this.tracer = Objects.requireNonNull(opentracingTracer);
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -468,7 +486,7 @@ public class HonoClientImpl implements HonoClient {
                     onSenderClosed -> {
                         activeSenders.remove(TelemetrySenderImpl.getTargetAddress(tenantId, deviceId));
                     },
-                    result.completer());
+                    result.completer(), tracer);
             return result;
         });
     }
@@ -505,7 +523,7 @@ public class HonoClientImpl implements HonoClient {
                     onSenderClosed -> {
                         activeSenders.remove(EventSenderImpl.getTargetAddress(tenantId, deviceId));
                     },
-                    result.completer());
+                    result.completer(), tracer);
             return result;
         });
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index 55751a4a8..0a879f601 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -9,23 +9,35 @@
  * Contributors:
  *    Bosch Software Innovations GmbH - initial creation
  *    Red Hat Inc
+ *    Bosch Software Innovations GmbH - add Open tracing support
  */
 
 package org.eclipse.hono.client.impl;
 
 import java.net.HttpURLConnection;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Objects;
 
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.tracing.MessageAnnotationsInjectAdapter;
+import org.eclipse.hono.tracing.TracingHelper;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.TelemetryConstants;
 
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
+import io.opentracing.Tracer;
+import io.opentracing.log.Fields;
+import io.opentracing.propagation.Format;
+import io.opentracing.tag.Tags;
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
@@ -42,7 +54,12 @@ public final class TelemetrySenderImpl extends AbstractSender {
 
     TelemetrySenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
             final String targetAddress, final Context context) {
-        super(config, sender, tenantId, targetAddress, context);
+        this(config, sender, tenantId, targetAddress, context, null);
+    }
+
+    TelemetrySenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
+            final String targetAddress, final Context context, final Tracer tracer) {
+        super(config, sender, tenantId, targetAddress, context, tracer);
     }
 
     /**
@@ -86,8 +103,9 @@ public final class TelemetrySenderImpl extends AbstractSender {
      * @param closeHook The handler to invoke when the Hono server closes the sender. The sender's
      *                  target address is provided as an argument to the handler.
      * @param creationHandler The handler to invoke with the result of the creation attempt.
+     * @param tracer The <em>OpenTracing</em> {@code Tracer} to keep track of the messages sent
+     *               by the sender returned.
      * @throws NullPointerException if any of context, connection, tenant or handler is {@code null}.
-     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     public static void create(
             final Context context,
@@ -96,7 +114,8 @@ public final class TelemetrySenderImpl extends AbstractSender {
             final String tenantId,
             final String deviceId,
             final Handler<String> closeHook,
-            final Handler<AsyncResult<MessageSender>> creationHandler) {
+            final Handler<AsyncResult<MessageSender>> creationHandler,
+            final Tracer tracer) {
 
         Objects.requireNonNull(context);
         Objects.requireNonNull(con);
@@ -106,7 +125,7 @@ public final class TelemetrySenderImpl extends AbstractSender {
         final String targetAddress = getTargetAddress(tenantId, deviceId);
         createSender(context, clientConfig, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook).compose(sender -> {
             return Future.<MessageSender> succeededFuture(
-                    new TelemetrySenderImpl(clientConfig, sender, tenantId, targetAddress, context));
+                    new TelemetrySenderImpl(clientConfig, sender, tenantId, targetAddress, context, tracer));
         }).setHandler(creationHandler);
     }
 
@@ -116,17 +135,37 @@ public final class TelemetrySenderImpl extends AbstractSender {
     @Override
     public Future<ProtonDelivery> sendAndWaitForOutcome(final Message rawMessage) {
 
+        return sendAndWaitForOutcome(rawMessage, null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Future<ProtonDelivery> sendAndWaitForOutcome(final Message rawMessage, final SpanContext parent) {
+
         Objects.requireNonNull(rawMessage);
 
+        // we create a child span (instead of a following span) because we depend
+        // on the outcome of the sending operation
+        final Span span = startChildSpan(parent, rawMessage);
+        Tags.MESSAGE_BUS_DESTINATION.set(span, targetAddress);
+        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);
+        span.setTag(MessageHelper.APP_PROPERTY_DEVICE_ID, MessageHelper.getDeviceId(rawMessage));
+        tracer.inject(span.context(), Format.Builtin.TEXT_MAP, new MessageAnnotationsInjectAdapter(rawMessage));
+
         if (!isRegistrationAssertionRequired()) {
             MessageHelper.getAndRemoveRegistrationAssertion(rawMessage);
         }
         final Future<ProtonDelivery> result = Future.future();
         context.runOnContext(send -> {
             if (sender.sendQueueFull()) {
-                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available"));
+                final ServiceInvocationException e = new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available");
+                logError(span, e);
+                span.finish();
+                result.fail(e);
             } else {
-                sendMessageAndWaitForOutcome(rawMessage).setHandler(result.completer());
+                sendMessageAndWaitForOutcome(rawMessage, span).setHandler(result.completer());
             }
         });
         return result;
@@ -136,6 +175,9 @@ public final class TelemetrySenderImpl extends AbstractSender {
      * Sends an AMQP 1.0 message to the peer this client is configured for.
      * 
      * @param message The message to send.
+     * @param currentSpan The <em>OpenTracing</em> span used to trace the sending of the message.
+     *              The span will be finished by this method and will contain an error log if
+     *              the message has not been accepted by the peer.
      * @return A future indicating the outcome of the operation.
      *         <p>
      *         The future will succeed if the message has been sent to the peer.
@@ -145,36 +187,79 @@ public final class TelemetrySenderImpl extends AbstractSender {
      *         <p>
      *         The future will be failed with a {@link ServiceInvocationException} if the
      *         message could not be sent.
-     * @throws NullPointerException if the message is {@code null}.
+     * @throws NullPointerException if any of the parameters are {@code null}.
      */
     @Override
-    protected Future<ProtonDelivery> sendMessage(final Message message) {
+    protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
 
         Objects.requireNonNull(message);
+        Objects.requireNonNull(currentSpan);
 
         final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
         message.setMessageId(messageId);
+        TracingHelper.TAG_MESSAGE_ID.set(currentSpan, messageId);
+        TracingHelper.TAG_CREDIT.set(currentSpan, sender.getCredit());
+        TracingHelper.TAG_QOS.set(currentSpan, ProtonQoS.AT_LEAST_ONCE.toString());
         final ProtonDelivery result = sender.send(message, deliveryUpdated -> {
+            final DeliveryState remoteState = deliveryUpdated.getRemoteState();
+            TracingHelper.TAG_REMOTE_STATE.set(currentSpan, remoteState.getClass().getSimpleName());
             if (deliveryUpdated.remotelySettled()) {
-                if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
+                if (Accepted.class.isInstance(remoteState)) {
                     LOG.trace("message [message ID: {}] accepted by peer", messageId);
-                } else if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
-                    final Rejected remoteState = (Rejected) deliveryUpdated.getRemoteState();
-                    if (remoteState.getError() == null) {
-                        LOG.debug("message [message ID: {}] rejected by peer", messageId);
+                    Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_ACCEPTED);
+                } else {
+                    final Map<String, Object> events = new HashMap<>();
+                    if (Rejected.class.isInstance(remoteState)) {
+                        final Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
+                        Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_BAD_REQUEST);
+                        if (rejected.getError() == null) {
+                            LOG.debug("message [message ID: {}] rejected by peer", messageId);
+                        } else {
+                            LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
+                                    rejected.getError().getCondition(), rejected.getError().getDescription());
+                            events.put(Fields.MESSAGE, rejected.getError().getDescription());
+                        }
                     } else {
-                        LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
-                                remoteState.getError().getCondition(), remoteState.getError().getDescription());
+                        LOG.debug("message [message ID: {}] not accepted by peer: {}",
+                                messageId, remoteState.getClass().getSimpleName());
+                        Tags.HTTP_STATUS.set(currentSpan, HttpURLConnection.HTTP_UNAVAILABLE);
                     }
-                } else {
-                    LOG.debug("message [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
+                    TracingHelper.logError(currentSpan, events);
                 }
             } else {
-                LOG.warn("peer did not settle message [message ID: {}, remote state: {}]", messageId, deliveryUpdated.getRemoteState());
+                LOG.warn("peer did not settle message [message ID: {}, remote state: {}]",
+                        messageId, remoteState.getClass().getSimpleName());
+                TracingHelper.logError(currentSpan, new ServerErrorException(
+                        HttpURLConnection.HTTP_INTERNAL_ERROR,
+                        "peer did not settle message, failing delivery"));
             }
+            currentSpan.finish();
         });
         LOG.trace("sent message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
 
         return Future.succeededFuture(result);
     }
+
+    @Override
+    protected Span startSpan(final SpanContext parent, final Message rawMessage) {
+
+        if (tracer == null) {
+            throw new IllegalStateException("no tracer configured");
+        } else {
+            final Span span = newFollowingSpan(parent, "forward Telemetry data");
+            Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
+            return span;
+        }
+    }
+
+    private Span startChildSpan(final SpanContext parent, final Message rawMessage) {
+
+        if (tracer == null) {
+            throw new IllegalStateException("no tracer configured");
+        } else {
+            final Span span = newChildSpan(parent, "forward Telemetry data");
+            Tags.SPAN_KIND.set(span, Tags.SPAN_KIND_PRODUCER);
+            return span;
+        }
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
index a72fbac0b..00b2eaaee 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractSenderTest.java
@@ -26,6 +26,8 @@ import org.junit.Before;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
 
+import io.opentracing.Span;
+import io.opentracing.SpanContext;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
@@ -128,7 +130,8 @@ public class AbstractSenderTest {
                 protonSender,
                 tenantId,
                 targetAddress,
-                context) {
+                context,
+                null) {
 
             @Override
             public String getEndpoint() {
@@ -136,7 +139,7 @@ public class AbstractSenderTest {
             }
 
             @Override
-            protected Future<ProtonDelivery> sendMessage(final Message message) {
+            protected Future<ProtonDelivery> sendMessage(final Message message, final Span currentSpan) {
                 protonSender.send(message);
                 return Future.succeededFuture(mock(ProtonDelivery.class));
             }
@@ -150,10 +153,21 @@ public class AbstractSenderTest {
                 return Future.future();
             }
 
+            @Override
+            public Future<ProtonDelivery> sendAndWaitForOutcome(final Message message, final SpanContext context) {
+                protonSender.send(message);
+                return null;
+            }
+
             @Override
             protected String getTo(final String deviceId) {
                 return null;
             }
+
+            @Override
+            protected Span startSpan(final SpanContext context, final Message rawMessage) {
+                return mock(Span.class);
+            }
         };
     }
 }
