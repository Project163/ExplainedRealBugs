diff --git a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
index ddd240f40..5b609725f 100644
--- a/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
+++ b/client/src/main/java/org/eclipse/hono/client/ConnectionLifecycle.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -64,6 +64,25 @@ public interface ConnectionLifecycle<T> {
      */
     Future<Void> isConnected();
 
+    /**
+     * Checks whether the connection is currently established.
+     * <p>
+     * If a connection attempt is currently in progress, the returned future is completed
+     * with the outcome of the connection attempt. If the connection attempt (including
+     * potential reconnect attempts) isn't finished after the given timeout, the returned
+     * future is failed.
+     * <p>
+     * This default implementation simply returns {@link #isConnected()}.
+     *
+     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for
+     *                                            an ongoing connection attempt to finish.
+     * @return A succeeded future if this connection is established.
+     *         Otherwise, the future will be failed with a {@link ServerErrorException}.
+     */
+    default Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
+        return isConnected();
+    }
+
     /**
      * Disconnects from the service.
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClientFactory.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClientFactory.java
index 3881969e1..3377464bd 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClientFactory.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClientFactory.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -21,6 +21,7 @@ import org.eclipse.hono.client.DisconnectListener;
 import org.eclipse.hono.client.HonoConnection;
 import org.eclipse.hono.client.ReconnectListener;
 import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.config.ClientConfigProperties;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -95,6 +96,37 @@ abstract class AbstractHonoClientFactory implements ConnectionLifecycle<HonoConn
         return connection.isConnected();
     }
 
+    /**
+     * Checks whether this client is connected to the service.
+     * <p>
+     * If a connection attempt is currently in progress, the returned future is completed
+     * with the outcome of the connection attempt. If the connection attempt (including
+     * potential reconnect attempts) isn't finished after the given timeout, the returned
+     * future is failed.
+     * <p>
+     * Simply delegates to {@link HonoConnection#isConnected(long)}.
+     * 
+     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for
+     *                                            an ongoing connection attempt to finish.
+     * @return A succeeded future if this factory is connected.
+     *         Otherwise, the future will be failed with a {@link ServerErrorException}.
+     */
+    @Override
+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
+        return connection.isConnected(waitForCurrentConnectAttemptTimeout);
+    }
+
+    /**
+     * Gets the default timeout used when checking whether this client is connected to the service.
+     * <p>
+     * The value returned here is the {@link ClientConfigProperties#getLinkEstablishmentTimeout()}.
+     *
+     * @return The timeout value in milliseconds.
+     */
+    public final long getDefaultConnectionCheckTimeout() {
+        return connection.getConfig().getLinkEstablishmentTimeout();
+    }
+
     /**
      * {@inheritDoc}
      * <p>
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java b/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java
index 8045468a6..7368aef50 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/ConnectionLifecycleWrapper.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -60,6 +60,11 @@ public abstract class ConnectionLifecycleWrapper<T> implements ConnectionLifecyc
         return delegate.isConnected();
     }
 
+    @Override
+    public Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
+        return delegate.isConnected(waitForCurrentConnectAttemptTimeout);
+    }
+
     @Override
     public void disconnect() {
         delegate.disconnect();
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
index dbda98a9f..96bac968c 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -67,17 +67,18 @@ public class CredentialsClientFactoryImpl extends AbstractHonoClientFactory impl
             final String tenantId) {
 
         Objects.requireNonNull(tenantId);
-        return connection.executeOnContext(result -> {
-            credentialsClientFactory.getOrCreateClient(
-                    CredentialsClientImpl.getTargetAddress(tenantId),
-                    () -> CredentialsClientImpl.create(
-                            cacheProvider,
-                            connection,
-                            tenantId,
-                            this::removeCredentialsClient,
-                            this::removeCredentialsClient),
-                    result);
-        });
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    credentialsClientFactory.getOrCreateClient(
+                            CredentialsClientImpl.getTargetAddress(tenantId),
+                            () -> CredentialsClientImpl.create(
+                                    cacheProvider,
+                                    connection,
+                                    tenantId,
+                                    this::removeCredentialsClient,
+                                    this::removeCredentialsClient),
+                            result);
+                }));
     }
 
     private void removeCredentialsClient(final String tenantId) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java b/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
new file mode 100644
index 000000000..fedecfabb
--- /dev/null
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java
@@ -0,0 +1,205 @@
+/*******************************************************************************
+ * Copyright (c) 2020 Contributors to the Eclipse Foundation
+ *
+ * See the NOTICE file(s) distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *******************************************************************************/
+
+package org.eclipse.hono.client.impl;
+
+import java.net.HttpURLConnection;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+
+import org.eclipse.hono.client.HonoConnection;
+import org.eclipse.hono.client.ServerErrorException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import io.vertx.core.AsyncResult;
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.core.Promise;
+import io.vertx.core.Vertx;
+
+/**
+ * Handles connection checks that should be completed only when a concurrent connection attempt has finished
+ * (or when a timeout period has elapsed).
+ */
+public final class DeferredConnectionCheckHandler {
+
+    private static final Logger LOG = LoggerFactory.getLogger(DeferredConnectionCheckHandler.class);
+
+    /**
+     * While a (re)connection attempt is ongoing, this field references a list of the connection check promises
+     * that are to be completed after connection success/failure or a timeout.
+     * <p>
+     * When the (re)connection attempt is finished, the reference value is set back to {@code null}.
+     */
+    private final AtomicReference<List<ExpiringConnectionCheckPromise>> connectionCheckPromises = new AtomicReference<>();
+    private final Vertx vertx;
+
+    /**
+     * Creates a new DeferredConnectionCheckHandler.
+     *
+     * @param vertx The Vert.x instance to run expiration timers with.
+     */
+    public DeferredConnectionCheckHandler(final Vertx vertx) {
+        this.vertx = vertx;
+    }
+
+    /**
+     * Checks whether a (re)connection attempt is currently in progress.
+     *
+     * @return {@code true} if an attempt is in progress.
+     */
+    public boolean isConnectionAttemptInProgress() {
+        return connectionCheckPromises.get() != null;
+    }
+
+    /**
+     * Signals a (re)connection attempt to be currently in progress.
+     */
+    public void setConnectionAttemptInProgress() {
+        connectionCheckPromises.compareAndSet(null, Collections.emptyList());
+    }
+
+    /**
+     * Marks an ongoing connection attempt as finished, providing the connection result.
+     * <p>
+     * This causes any accumulated connection checks to be completed.
+     *
+     * @param connectionResult The result of the connection attempt.
+     */
+    public void setConnectionAttemptFinished(final AsyncResult<HonoConnection> connectionResult) {
+        final List<ExpiringConnectionCheckPromise> promises = connectionCheckPromises.getAndSet(null);
+        if (promises != null && !promises.isEmpty()) {
+            LOG.trace("completing {} accumulated connection checks", promises.size());
+            final Context ctx = vertx.getOrCreateContext();
+            promises.forEach(promise -> ctx.runOnContext(v -> promise.tryCompleteAndCancelTimer(connectionResult)));
+        }
+    }
+
+    /**
+     * Adds a connection check, represented by the handler to be invoked with the connection check result.
+     * <p>
+     * If a connection attempt is in progress, the given handler is completed once the attempt is finished or once the
+     * given timout value has elapsed.
+     * <p>
+     * If no connection attempt is currently in progress, this method just returns {@code false}.
+     *
+     * @param resultHandler The handler to be invoked with the connection check result.
+     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for
+     *                                            an ongoing connection attempt to finish.
+     * @return {@code true} if the check was successfully added, or {@code false} if no connection attempt is currently
+     *         in progress.
+     * @throws IllegalArgumentException If the given timeout value is &lt; 1.
+     */
+    public boolean addConnectionCheck(final Handler<AsyncResult<Void>> resultHandler,
+            final long waitForCurrentConnectAttemptTimeout) {
+        if (waitForCurrentConnectAttemptTimeout <= 0) {
+            throw new IllegalArgumentException("timeout must be greater 0");
+        }
+        if (!isConnectionAttemptInProgress()) {
+            return false;
+        }
+        final ExpiringConnectionCheckPromise promiseToAdd = new ExpiringConnectionCheckPromise(resultHandler);
+        if (!addToConnectionCheckPromises(promiseToAdd)) {
+            // connectionCheckPromises has been cleared in between
+            return false;
+        }
+        // promise added to list, now use a timer to ensure that we wait no more than the given timeout
+        promiseToAdd.startExpirationTimer(waitForCurrentConnectAttemptTimeout,
+                (v) -> removeFromConnectionCheckPromises(promiseToAdd)); // cleanup after expiration; not strictly necessary but keeps the list from growing if (re)connection attempts don't get finished for a long time
+        return true;
+    }
+
+
+    private boolean addToConnectionCheckPromises(final ExpiringConnectionCheckPromise promiseToAdd) {
+        // atomically add to connectionCheckPromises - but only if connectionCheckPromises hasn't been set to null in between
+        final List<ExpiringConnectionCheckPromise> newPromises = connectionCheckPromises
+                .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {
+                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required
+                    if (existing == null) {
+                        return null;
+                    }
+                    final List<ExpiringConnectionCheckPromise> promises = new ArrayList<>(existing.size() + 1);
+                    promises.addAll(existing);
+                    promises.add(toAdd.get(0));
+                    return promises;
+                });
+        return newPromises != null;
+    }
+
+    private void removeFromConnectionCheckPromises(final ExpiringConnectionCheckPromise promiseToRemove) {
+        connectionCheckPromises
+                .accumulateAndGet(Collections.singletonList(promiseToRemove), (existing, toRemove) -> {
+                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required
+                    if (existing == null) {
+                        return null;
+                    }
+                    final List<ExpiringConnectionCheckPromise> promises = new ArrayList<>(existing);
+                    promises.remove(toRemove.get(0));
+                    return promises;
+                });
+    }
+
+    /**
+     * Wrapped promise with an expiration mechanism, failing the promise after a given time if it has not been
+     * completed yet.
+     */
+    private class ExpiringConnectionCheckPromise {
+        private final Promise<Void> promise;
+        private Long timerId;
+
+        ExpiringConnectionCheckPromise(final Handler<AsyncResult<Void>> connectionCheckResultHandler) {
+            this.promise = Promise.promise();
+            promise.future().setHandler(connectionCheckResultHandler);
+        }
+
+        /**
+         * Starts a timer so that after the given timeout value, this promise shall get failed if not completed already.
+         *
+         * @param timeout The number of milliseconds to use for the timer.
+         * @param postExpirationOperation The operation to run after this promise got failed as part of a timeout.
+         */
+        public void startExpirationTimer(final long timeout, final Consumer<Void> postExpirationOperation) {
+            timerId = vertx.setTimer(timeout, id -> {
+                LOG.debug("canceling connection check after {}ms", timeout);
+                timerId = null;
+                tryCompleteAndCancelTimer(Future.failedFuture(
+                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
+                if (postExpirationOperation != null) {
+                    postExpirationOperation.accept(null);
+                }
+            });
+        }
+
+        /**
+         * Completes this promise with the given result and stops the expiration timer.
+         *
+         * @param connectionResult The connection result to complete this promise with.
+         */
+        public void tryCompleteAndCancelTimer(final AsyncResult<HonoConnection> connectionResult) {
+            if (timerId != null) {
+                vertx.cancelTimer(timerId);
+            }
+            if (connectionResult.succeeded()) {
+                promise.tryComplete();
+            } else {
+                promise.tryFail(connectionResult.cause());
+            }
+        }
+    }
+
+}
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java
index d4f30a954..91f80d753 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DeviceConnectionClientFactoryImpl.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -62,17 +62,17 @@ public class DeviceConnectionClientFactoryImpl extends AbstractHonoClientFactory
     public final Future<DeviceConnectionClient> getOrCreateDeviceConnectionClient(final String tenantId) {
 
         Objects.requireNonNull(tenantId);
-
-        return connection.executeOnContext(result -> {
-            deviceConnectionClientFactory.getOrCreateClient(
-                    DeviceConnectionClientImpl.getTargetAddress(tenantId),
-                    () -> DeviceConnectionClientImpl.create(
-                            connection,
-                            tenantId,
-                            this::removeDeviceConnectionClient,
-                            this::removeDeviceConnectionClient),
-                    result);
-        });
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    deviceConnectionClientFactory.getOrCreateClient(
+                            DeviceConnectionClientImpl.getTargetAddress(tenantId),
+                            () -> DeviceConnectionClientImpl.create(
+                                    connection,
+                                    tenantId,
+                                    this::removeDeviceConnectionClient,
+                                    this::removeDeviceConnectionClient),
+                            result);
+                }));
     }
 
     private void removeDeviceConnectionClient(final String tenantId) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java
index a52e66461..1d3f76e73 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImpl.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -58,15 +58,16 @@ public class DownstreamSenderFactoryImpl extends AbstractHonoClientFactory imple
     public final Future<DownstreamSender> getOrCreateTelemetrySender(final String tenantId) {
 
         Objects.requireNonNull(tenantId);
-        return connection.executeOnContext(result -> {
-            clientFactory.getOrCreateClient(
-                    TelemetrySenderImpl.getTargetAddress(tenantId, null),
-                    () -> TelemetrySenderImpl.create(connection, tenantId,
-                            onSenderClosed -> {
-                                clientFactory.removeClient(TelemetrySenderImpl.getTargetAddress(tenantId, null));
-                            }),
-                    result);
-        });
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    clientFactory.getOrCreateClient(
+                            TelemetrySenderImpl.getTargetAddress(tenantId, null),
+                            () -> TelemetrySenderImpl.create(connection, tenantId,
+                                    onSenderClosed -> {
+                                        clientFactory.removeClient(TelemetrySenderImpl.getTargetAddress(tenantId, null));
+                                    }),
+                            result);
+                }));
     }
 
     /**
@@ -76,15 +77,16 @@ public class DownstreamSenderFactoryImpl extends AbstractHonoClientFactory imple
     public final Future<DownstreamSender> getOrCreateEventSender(final String tenantId) {
 
         Objects.requireNonNull(tenantId);
-        return connection.executeOnContext(result -> {
-            clientFactory.getOrCreateClient(
-                    EventSenderImpl.getTargetAddress(tenantId, null),
-                    () -> EventSenderImpl.create(connection, tenantId,
-                            onSenderClosed -> {
-                                clientFactory.removeClient(EventSenderImpl.getTargetAddress(tenantId, null));
-                            }),
-                    result);
-        });
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    clientFactory.getOrCreateClient(
+                            EventSenderImpl.getTargetAddress(tenantId, null),
+                            () -> EventSenderImpl.create(connection, tenantId,
+                                    onSenderClosed -> {
+                                        clientFactory.removeClient(EventSenderImpl.getTargetAddress(tenantId, null));
+                                    }),
+                            result);
+                }));
     }
 
     private void handleTenantTimeout(final Message<String> msg) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
index 9895eb634..e622db1b0 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/GatewayMapperImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -179,6 +179,13 @@ public class GatewayMapperImpl implements GatewayMapper, ConnectionLifecycle<Hon
         return CompositeFuture.all(registrationFuture, deviceConnectionFuture).mapEmpty();
     }
 
+    @Override
+    public Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
+        final Future<Void> registrationFuture = registrationClientFactory.isConnected(waitForCurrentConnectAttemptTimeout);
+        final Future<Void> deviceConnectionFuture = deviceConnectionClientFactory.isConnected(waitForCurrentConnectAttemptTimeout);
+        return CompositeFuture.all(registrationFuture, deviceConnectionFuture).mapEmpty();
+    }
+
     @Override
     public void disconnect() {
         registrationClientFactory.disconnect();
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
index f88fef24d..120236e3a 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -24,7 +24,6 @@ import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 
 import javax.net.ssl.SSLException;
 import javax.security.sasl.AuthenticationException;
@@ -110,12 +109,8 @@ public class HonoConnectionImpl implements HonoConnection {
     private final AtomicBoolean disconnecting = new AtomicBoolean(false);
     private final ConnectionFactory connectionFactory;
     private final Object connectionLock = new Object();
-    /**
-     * Reference to a list of promises created in {@link #checkConnected(Handler)}, waiting to be completed
-     * in a concurrent {@link #connect()} invocation. When {@link #connect()} is finished, the reference
-     * value will be set back to {@code null}.
-     */
-    private final AtomicReference<List<Promise<Void>>> checkConnectedPromises = new AtomicReference<>();
+
+    private final DeferredConnectionCheckHandler deferredConnectionCheckHandler;
 
     private ProtonClientOptions clientOptions;
     private AtomicInteger connectAttempts;
@@ -157,6 +152,7 @@ public class HonoConnectionImpl implements HonoConnection {
         } else {
             this.vertx = Vertx.vertx();
         }
+        deferredConnectionCheckHandler = new DeferredConnectionCheckHandler(vertx);
         if (connectionFactory != null) {
             this.connectionFactory = connectionFactory;
         } else {
@@ -231,7 +227,7 @@ public class HonoConnectionImpl implements HonoConnection {
     public final <T> Future<T> executeOnContext(final Handler<Promise<T>> codeToRun) {
 
         if (context == null) {
-            // this means that the connection to the peer is not established (yet)
+            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
             return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
         } else {
             return HonoProtonHelper.executeOnContext(context, codeToRun);
@@ -256,7 +252,7 @@ public class HonoConnectionImpl implements HonoConnection {
     public final <T> Future<T> executeOrRunOnContext(final Handler<Future<T>> codeToRun) {
 
         if (context == null) {
-            // this means that the connection to the peer is not established (yet)
+            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
             return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected"));
         } else {
             return HonoProtonHelper.executeOrRunOnContext(context, codeToRun);
@@ -265,9 +261,6 @@ public class HonoConnectionImpl implements HonoConnection {
 
     /**
      * {@inheritDoc}
-     * <p>
-     * If a connection attempt is currently in progress, the returned future is completed
-     * with the outcome of the connection attempt.
      */
     @Override
     public final Future<Void> isConnected() {
@@ -276,9 +269,6 @@ public class HonoConnectionImpl implements HonoConnection {
 
     /**
      * Checks if this client is currently connected to the server.
-     * <p>
-     * If a connection attempt is currently in progress, the returned future is completed
-     * with the outcome of the connection attempt.
      *
      * @return A succeeded future if this client is connected.
      */
@@ -291,44 +281,36 @@ public class HonoConnectionImpl implements HonoConnection {
     private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {
         if (isConnectedInternal()) {
             resultHandler.handle(Future.succeededFuture());
-        } else if (connecting.get()) {
-            // connect attempt in progress - let its completion complete the resultHandler here
-            log.debug("connection attempt to server [{}:{}] in progress, connection check will be completed with its result",
-                    connectionFactory.getHost(), connectionFactory.getPort());
-            final Promise<Void> promiseToAdd = Promise.promise();
-            promiseToAdd.future().setHandler(resultHandler);
-            // atomically add the promise to checkConnectedPromises - but only if checkConnectedPromises hasn't been cleared already
-            final List<Promise<Void>> newCheckConnectedPromises = checkConnectedPromises
-                    .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {
-                        // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required
-                        if (existing == null) {
-                            return null;
-                        }
-                        final List<Promise<Void>> promises = new ArrayList<>(existing.size() + 1);
-                        promises.addAll(existing);
-                        promises.add(toAdd.get(0));
-                        return promises;
-                    });
-            if (newCheckConnectedPromises == null) {
-                // checkConnectedPromises wasn't updated with our promiseToAdd because the checkConnectedPromises were cleared in between
-                resultHandler.handle(Future.failedFuture(
-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
-            }
         } else {
             resultHandler.handle(Future.failedFuture(
                     new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
         }
     }
 
-    private void removeAndCompleteCheckConnectedPromises(final AsyncResult<HonoConnection> connectionResult) {
-        final List<Promise<Void>> promises = checkConnectedPromises.getAndSet(null);
-        if (promises != null) {
-            final Context ctx = vertx.getOrCreateContext();
-            if (connectionResult.succeeded()) {
-                promises.forEach(promise -> ctx.runOnContext(v -> promise.complete()));
-            } else {
-                promises.forEach(promise -> ctx.runOnContext(v -> promise.fail(connectionResult.cause())));
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {
+        return executeOnContext(result -> checkConnected(result, waitForCurrentConnectAttemptTimeout));
+    }
+
+    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler, final long waitForCurrentConnectAttemptTimeout) {
+        if (isConnectedInternal()) {
+            resultHandler.handle(Future.succeededFuture());
+        } else if (waitForCurrentConnectAttemptTimeout > 0 && deferredConnectionCheckHandler.isConnectionAttemptInProgress()) {
+            // connect attempt in progress - let its completion complete the resultHandler here
+            log.debug("connection attempt to server [{}:{}] in progress, connection check will be completed with its result",
+                    connectionFactory.getHost(), connectionFactory.getPort());
+            final boolean added = deferredConnectionCheckHandler.addConnectionCheck(resultHandler,
+                    waitForCurrentConnectAttemptTimeout);
+            if (!added) {
+                // connection attempt was finished in between
+                checkConnected(resultHandler);
             }
+        } else {
+            resultHandler.handle(Future.failedFuture(
+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "not connected")));
         }
     }
 
@@ -418,10 +400,10 @@ public class HonoConnectionImpl implements HonoConnection {
             final Handler<AsyncResult<HonoConnection>> connectionHandler,
             final Handler<ProtonConnection> disconnectHandler) {
 
-        // make sure concurrently created checkConnected() promises get completed along with the given connectionHandler
+        // make sure concurrently invoked connection checks get completed along with the given connectionHandler
         final Handler<AsyncResult<HonoConnection>> wrappedConnectionHandler = connectionHandler instanceof ConnectMethodConnectionHandler
                 ? connectionHandler
-                : new ConnectMethodConnectionHandler(connectionHandler, this::removeAndCompleteCheckConnectedPromises);
+                : new ConnectMethodConnectionHandler(connectionHandler, deferredConnectionCheckHandler::setConnectionAttemptFinished);
 
         context = vertx.getOrCreateContext();
         log.trace("running on vert.x context [event-loop context: {}]", context.isEventLoopContext());
@@ -435,7 +417,7 @@ public class HonoConnectionImpl implements HonoConnection {
                         connectionFactory.getPort());
                 wrappedConnectionHandler.handle(Future.succeededFuture(this));
             } else if (connecting.compareAndSet(false, true)) {
-                checkConnectedPromises.compareAndSet(null, Collections.emptyList());
+                deferredConnectionCheckHandler.setConnectionAttemptInProgress();
 
                 log.debug("starting attempt [#{}] to connect to server [{}:{}]",
                         connectAttempts.get() + 1, connectionFactory.getHost(), connectionFactory.getPort());
@@ -573,6 +555,7 @@ public class HonoConnectionImpl implements HonoConnection {
             failConnectionAttempt(connectionFailureCause, connectionHandler);
 
         } else {
+            deferredConnectionCheckHandler.setConnectionAttemptInProgress();
             if (connectionFailureCause != null) {
                 logConnectionError(connectionFailureCause);
             }
@@ -663,7 +646,7 @@ public class HonoConnectionImpl implements HonoConnection {
             final Handler<Void> closeHandler) {
 
         if (context == null) {
-            // this means that the connection to the peer is not established (yet)
+            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
             closeHandler.handle(null);
         } else {
             HonoProtonHelper.closeAndFree(context, link, closeHandler);
@@ -683,7 +666,7 @@ public class HonoConnectionImpl implements HonoConnection {
             final Handler<Void> closeHandler) {
 
         if (context == null) {
-            // this means that the connection to the peer is not established (yet)
+            // this means that the connection to the peer is not established (yet) and no (re)connect attempt is in progress
             closeHandler.handle(null);
         } else {
             HonoProtonHelper.closeAndFree(context, link, detachTimeOut, closeHandler);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
index 705391652..7b262b6bf 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientFactoryImpl.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -68,17 +68,18 @@ public class RegistrationClientFactoryImpl extends AbstractHonoClientFactory imp
 
         Objects.requireNonNull(tenantId);
 
-        return connection.executeOnContext(result -> {
-            registrationClientFactory.getOrCreateClient(
-                    RegistrationClientImpl.getTargetAddress(tenantId),
-                    () -> RegistrationClientImpl.create(
-                            cacheProvider,
-                            connection,
-                            tenantId,
-                            this::removeRegistrationClient,
-                            this::removeRegistrationClient),
-                    result);
-        });
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    registrationClientFactory.getOrCreateClient(
+                            RegistrationClientImpl.getTargetAddress(tenantId),
+                            () -> RegistrationClientImpl.create(
+                                    cacheProvider,
+                                    connection,
+                                    tenantId,
+                                    this::removeRegistrationClient,
+                                    this::removeRegistrationClient),
+                            result);
+                }));
     }
 
     private void removeRegistrationClient(final String tenantId) {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java
index 01f67c632..359db0811 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TenantClientFactoryImpl.java
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -59,16 +59,17 @@ public class TenantClientFactoryImpl extends AbstractHonoClientFactory implement
     @Override
     public Future<TenantClient> getOrCreateTenantClient() {
 
-        return connection.executeOnContext(result -> {
-            tenantClientFactory.getOrCreateClient(
-                    TenantClientImpl.getTargetAddress(),
-                    () -> TenantClientImpl.create(
-                            cacheProvider,
-                            connection,
-                            this::removeTenantClient,
-                            this::removeTenantClient),
-                    result);
-        });
+        return connection.isConnected(getDefaultConnectionCheckTimeout())
+                .compose(v -> connection.executeOnContext(result -> {
+                    tenantClientFactory.getOrCreateClient(
+                            TenantClientImpl.getTargetAddress(),
+                            () -> TenantClientImpl.create(
+                                    cacheProvider,
+                                    connection,
+                                    this::removeTenantClient,
+                                    this::removeTenantClient),
+                            result);
+                }));
     }
 
     private void removeTenantClient(final String tenantId) {
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java b/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java
index bfb106d9a..38e065439 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/AbstractTenantTimeoutRelatedClientFactoryTest.java
@@ -14,6 +14,7 @@
 package org.eclipse.hono.client.impl;
 
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.verify;
@@ -113,6 +114,9 @@ public abstract class AbstractTenantTimeoutRelatedClientFactoryTest<T> {
         final HonoConnection connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);
         when(connection.getVertx()).thenReturn(vertx);
 
+        when(connection.isConnected()).thenReturn(Future.succeededFuture());
+        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
+
         final ProtonReceiver receiver = HonoClientUnitTestHelper.mockProtonReceiver();
         when(connection.createReceiver(anyString(), any(), any(), any())).thenReturn(Future.succeededFuture(receiver));
         final ProtonSender sender = HonoClientUnitTestHelper.mockProtonSender();
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
index fa4506b80..6f1f52f00 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/DownstreamSenderFactoryImplTest.java
@@ -69,6 +69,8 @@ public class DownstreamSenderFactoryImplTest {
             return 1L;
         });
         connection = HonoClientUnitTestHelper.mockHonoConnection(vertx);
+        when(connection.isConnected()).thenReturn(Future.succeededFuture());
+        when(connection.isConnected(anyLong())).thenReturn(Future.succeededFuture());
         when(vertx.eventBus()).thenReturn(mock(EventBus.class));
         factory = new DownstreamSenderFactoryImpl(connection);
     }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
index ab291b0d2..d2f9ab55b 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoConnectionImplTest.java
@@ -1,5 +1,5 @@
 /*******************************************************************************
- * Copyright (c) 2016, 2019 Contributors to the Eclipse Foundation
+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation
  *
  * See the NOTICE file(s) distributed with this work for additional
  * information regarding copyright ownership.
@@ -343,17 +343,21 @@ public class HonoConnectionImplTest {
     }
 
     /**
-     * Verifies that {@link HonoConnectionImpl#checkConnected()} only completes once a concurrent
+     * Verifies that {@link HonoConnectionImpl#isConnected(long)} only completes once a concurrent
      * connection attempt (which eventually succeeds here) is finished.
      *
      * @param ctx The test execution context.
      */
     @Test
-    public void testCheckConnectedSucceedsAfterConcurrentReconnectSucceeded(final TestContext ctx) {
-
-        final AtomicBoolean checkConnectedInvocationsDone = new AtomicBoolean(false);
-        final AtomicReference<Future<Void>> checkConnected1FutureRef = new AtomicReference<>();
-        final AtomicReference<Future<Void>> checkConnected2FutureRef = new AtomicReference<>();
+    public void testIsConnectedWithTimeoutSucceedsAfterConcurrentReconnectSucceeded(final TestContext ctx) {
+
+        final long isConnectedTimeout = 44444L;
+        // let the vertx timer for the isConnectedTimeout do nothing
+        when(vertx.setTimer(eq(isConnectedTimeout), any(Handler.class))).thenAnswer(invocation -> 0L);
+        final AtomicBoolean isConnectedInvocationsDone = new AtomicBoolean(false);
+        final AtomicReference<Future<Void>> isConnected1FutureRef = new AtomicReference<>();
+        final AtomicReference<Future<Void>> isConnectedTimeoutForcedFutureRef = new AtomicReference<>();
+        final AtomicReference<Future<Void>> isConnected2FutureRef = new AtomicReference<>();
         // GIVEN a client that is configured to connect to a peer
         // to which the connection can be established on the third attempt only
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
@@ -362,13 +366,15 @@ public class HonoConnectionImplTest {
                                 final Handler<AsyncResult<ProtonConnection>> closeHandler,
                                 final Handler<ProtonConnection> disconnectHandler,
                                 final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                // and GIVEN "checkConnected" invocations done while the "connect" invocation is still in progress
-                if (checkConnectedInvocationsDone.compareAndSet(false, true)) {
-                    checkConnected1FutureRef.set(honoConnection.checkConnected());
-                    checkConnected2FutureRef.set(honoConnection.checkConnected());
-                    // assert "checkConnected" invocations have not completed yet
-                    ctx.assertFalse(checkConnected1FutureRef.get().isComplete());
-                    ctx.assertFalse(checkConnected2FutureRef.get().isComplete());
+                // and GIVEN "isConnected" invocations done while the "connect" invocation is still in progress
+                if (isConnectedInvocationsDone.compareAndSet(false, true)) {
+                    isConnected1FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
+                    isConnectedTimeoutForcedFutureRef.set(honoConnection.isConnected(1L));
+                    isConnected2FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
+                    // assert "isConnected" invocations have not completed yet, apart from the one with the forced timeout
+                    ctx.assertFalse(isConnected1FutureRef.get().isComplete());
+                    ctx.assertTrue(isConnectedTimeoutForcedFutureRef.get().failed());
+                    ctx.assertFalse(isConnected2FutureRef.get().isComplete());
                 }
                 super.connect(options, username, password, closeHandler, disconnectHandler, connectionResultHandler);
             }
@@ -380,8 +386,8 @@ public class HonoConnectionImplTest {
 
         // WHEN trying to connect
         honoConnection.connect()
-                // THEN the "checkConnected" futures succeed
-                .compose(v -> CompositeFuture.all(checkConnected1FutureRef.get(), checkConnected2FutureRef.get()))
+                // THEN the "isConnected" futures succeed
+                .compose(v -> CompositeFuture.all(isConnected1FutureRef.get(), isConnected2FutureRef.get()))
                 .setHandler(ctx.asyncAssertSuccess());
 
         // and the client fails twice to connect
@@ -391,17 +397,20 @@ public class HonoConnectionImplTest {
     }
 
     /**
-     * Verifies that {@link HonoConnectionImpl#checkConnected()} only completes once a concurrent
+     * Verifies that {@link HonoConnectionImpl#isConnected(long)} only completes once a concurrent
      * connection attempt (which eventually fails here) is finished.
      *
      * @param ctx The vert.x test client.
      */
     @Test
-    public void testCheckConnectedFailsAfterConcurrentReconnectFailed(final TestContext ctx) {
-
-        final AtomicBoolean checkConnectedInvocationsDone = new AtomicBoolean(false);
-        final AtomicReference<Future<Void>> checkConnected1FutureRef = new AtomicReference<>();
-        final AtomicReference<Future<Void>> checkConnected2FutureRef = new AtomicReference<>();
+    public void testIsConnectedWithTimeoutFailsAfterConcurrentReconnectFailed(final TestContext ctx) {
+
+        final long isConnectedTimeout = 44444L;
+        // let the vertx timer for the isConnectedTimeout do nothing
+        when(vertx.setTimer(eq(isConnectedTimeout), any(Handler.class))).thenAnswer(invocation -> 0L);
+        final AtomicBoolean isConnectedInvocationsDone = new AtomicBoolean(false);
+        final AtomicReference<Future<Void>> isConnected1FutureRef = new AtomicReference<>();
+        final AtomicReference<Future<Void>> isConnected2FutureRef = new AtomicReference<>();
         // GIVEN a client that is configured to connect to a peer
         // to which the connection can be established on the third attempt only
         connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con) {
@@ -410,13 +419,13 @@ public class HonoConnectionImplTest {
                                 final Handler<AsyncResult<ProtonConnection>> closeHandler,
                                 final Handler<ProtonConnection> disconnectHandler,
                                 final Handler<AsyncResult<ProtonConnection>> connectionResultHandler) {
-                // and GIVEN "checkConnected" invocations done while the "connect" invocation is still in progress
-                if (checkConnectedInvocationsDone.compareAndSet(false, true)) {
-                    checkConnected1FutureRef.set(honoConnection.checkConnected());
-                    checkConnected2FutureRef.set(honoConnection.checkConnected());
-                    // assert "checkConnected" invocations have not completed yet
-                    ctx.assertFalse(checkConnected1FutureRef.get().isComplete());
-                    ctx.assertFalse(checkConnected2FutureRef.get().isComplete());
+                // and GIVEN "isConnected" invocations done while the "connect" invocation is still in progress
+                if (isConnectedInvocationsDone.compareAndSet(false, true)) {
+                    isConnected1FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
+                    isConnected2FutureRef.set(honoConnection.isConnected(isConnectedTimeout));
+                    // assert "isConnected" invocations have not completed yet
+                    ctx.assertFalse(isConnected1FutureRef.get().isComplete());
+                    ctx.assertFalse(isConnected2FutureRef.get().isComplete());
                 }
                 super.connect(options, username, password, closeHandler, disconnectHandler, connectionResultHandler);
             }
@@ -428,14 +437,14 @@ public class HonoConnectionImplTest {
 
         // WHEN the client tries to connect
         honoConnection.connect().setHandler(ctx.asyncAssertFailure(t -> {
-            // THEN the connection attempt fails and the "checkConnected" futures fail as well
+            // THEN the connection attempt fails and the "isConnected" futures fail as well
             ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) t).getErrorCode());
 
-            ctx.assertTrue(checkConnected1FutureRef.get().failed());
-            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) checkConnected1FutureRef.get().cause()).getErrorCode());
+            ctx.assertTrue(isConnected1FutureRef.get().failed());
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) isConnected1FutureRef.get().cause()).getErrorCode());
 
-            ctx.assertTrue(checkConnected2FutureRef.get().failed());
-            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) checkConnected2FutureRef.get().cause()).getErrorCode());
+            ctx.assertTrue(isConnected2FutureRef.get().failed());
+            ctx.assertEquals(HttpURLConnection.HTTP_UNAVAILABLE, ((ServerErrorException) isConnected2FutureRef.get().cause()).getErrorCode());
         }));
         // and the client has indeed tried three times in total before giving up
         assertTrue(connectionFactory.awaitFailure());
