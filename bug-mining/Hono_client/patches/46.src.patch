diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
index 20225eac0..4e38f9cb9 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClient.java
@@ -39,11 +39,6 @@ import io.vertx.proton.ProtonSender;
  */
 public abstract class AbstractHonoClient {
 
-    /**
-     * The number of credits to flow to senders by default.
-     */
-    protected static final int DEFAULT_SENDER_CREDITS = 1000;
-
     private static final Logger LOG = LoggerFactory.getLogger(AbstractHonoClient.class);
 
     /**
@@ -147,15 +142,18 @@ public abstract class AbstractHonoClient {
      * @param con The connection to create the link for.
      * @param targetAddress The target address of the link.
      * @param qos The quality of service to use for the link.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.
      * @param closeHook The handler to invoke when the link is closed by the peer.
      * @return A future for the created link. The future will be completed once the link is open.
      *         The future will fail if the link cannot be opened.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     protected static final Future<ProtonSender> createSender(
             final Context ctx,
             final ProtonConnection con,
             final String targetAddress,
             final ProtonQoS qos,
+            final long waitForInitialCredits,
             final Handler<String> closeHook) {
 
         final Future<ProtonSender> result = Future.future();
@@ -166,14 +164,14 @@ public abstract class AbstractHonoClient {
             sender.openHandler(senderOpen -> {
                 if (senderOpen.succeeded()) {
                     LOG.info("sender open [{}] sendQueueFull [{}]", sender.getRemoteTarget(), sender.sendQueueFull());
-                    // wait on credits a little time, if not already given TODO: configurable waiting time
+                    // wait on credits a little time, if not already given
                     if (sender.sendQueueFull()) {
-                        ctx.owner().setTimer(10, timerID -> {
-                            LOG.info("waited 10ms on credits [{}]", sender.getCredit());
-                            result.complete(senderOpen.result());
+                        ctx.owner().setTimer(waitForInitialCredits, timerID -> {
+                            LOG.info("waited [{}] ms on credits [{}]", waitForInitialCredits, sender.getCredit());
+                            result.complete(sender);
                         });
                     } else {
-                        result.complete(senderOpen.result());
+                        result.complete(sender);
                     }
                 } else {
                     LOG.debug("opening sender [{}] failed: {}", targetAddress, senderOpen.cause().getMessage());
@@ -200,23 +198,25 @@ public abstract class AbstractHonoClient {
     /**
      * Creates a receiver link.
      * <p>
-     * The receiver will be created with its <em>autoAccept</em> property set to {@code true}
-     * and with its <em>prefetch</em> property being set to {@link #DEFAULT_SENDER_CREDITS}.
-     * 
+     * The receiver will be created with its <em>autoAccept</em> property set to {@code true}.
+     *
      * @param ctx The vert.x context to use for establishing the link.
      * @param con The connection to create the link for.
      * @param sourceAddress The address to receive messages from.
      * @param qos The quality of service to use for the link.
+     * @param prefetchCredits Number of credits, given initially from receiver to sender.
      * @param messageHandler The handler to invoke with every message received.
      * @param closeHook The handler to invoke when the link is closed by the peer.
      * @return A future for the created link. The future will be completed once the link is open.
      *         The future will fail if the link cannot be opened.
+     * @throws IllegalArgumentException if prefetchCredits is {@code < 0}.
      */
     protected static final Future<ProtonReceiver> createReceiver(
             final Context ctx,
             final ProtonConnection con,
             final String sourceAddress,
             final ProtonQoS qos,
+            final int prefetchCredits,
             final ProtonMessageHandler messageHandler,
             final Handler<String> closeHook) {
 
@@ -224,7 +224,8 @@ public abstract class AbstractHonoClient {
         ctx.runOnContext(go -> {
             final ProtonReceiver receiver = con.createReceiver(sourceAddress);
             receiver.setAutoAccept(true);
-            receiver.setPrefetch(DEFAULT_SENDER_CREDITS);
+            receiver.setQoS(qos);
+            receiver.setPrefetch(prefetchCredits);
             receiver.handler(messageHandler);
             receiver.openHandler(result.completer());
             receiver.closeHandler(remoteClosed -> {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
index 92e08acc4..5eaec1549 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractRequestResponseClient.java
@@ -62,7 +62,7 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
     /**
      * Creates a request-response client.
      * <p>
-     * The client will be ready to use after invoking {@link #createLinks(ProtonConnection)} only.
+     * The client will be ready to use after invoking {@link #createLinks(ProtonConnection, int, long)} only.
      * 
      * @param context The vert.x context to run message exchanges with the peer on.
      * @param tenantId The identifier of the tenant that the client is scoped to.
@@ -142,11 +142,15 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * and receiving responses.
      * 
      * @param con The AMQP 1.0 connection to the peer.
+     * @param receiverPrefetchCredits Number of credits, given initially from receiver to sender.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.
      * @return A future indicating the outcome. The future will succeed if the links
      *         have been created.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
+     * @throws IllegalArgumentException if receiverPrefetchCredits is {@code < 0}.
      */
-    protected final Future<Void> createLinks(final ProtonConnection con) {
-        return createLinks(con, null, null);
+    protected final Future<Void> createLinks(final ProtonConnection con, final int receiverPrefetchCredits, final long waitForInitialCredits) {
+        return createLinks(con, receiverPrefetchCredits, waitForInitialCredits, null, null);
     }
 
     /**
@@ -154,16 +158,21 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
      * and receiving responses.
      * 
      * @param con The AMQP 1.0 connection to the peer.
+     * @param receiverPrefetchCredits Number of credits, given initially from receiver to sender.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.
      * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
      * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
      * @return A future indicating the outcome. The future will succeed if the links
      *         have been created.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
+     * @throws IllegalArgumentException if receiverPrefetchCredits is {@code < 0}.
      */
-    protected final Future<Void> createLinks(final ProtonConnection con, final Handler<String> senderCloseHook, final Handler<String> receiverCloseHook) {
+    protected final Future<Void> createLinks(final ProtonConnection con, final int receiverPrefetchCredits, final long waitForInitialCredits,
+                                             final Handler<String> senderCloseHook, final Handler<String> receiverCloseHook) {
         Future<Void> result = Future.future();
-        createReceiver(con, replyToAddress, receiverCloseHook).compose(recv -> {
+        createReceiver(con, replyToAddress, receiverPrefetchCredits, receiverCloseHook).compose(recv -> {
             this.receiver = recv;
-            return createSender(con, targetAddress, senderCloseHook);
+            return createSender(con, targetAddress, waitForInitialCredits, senderCloseHook);
         }).setHandler(s -> {
             if (s.succeeded()) {
                 LOG.debug("request-response client for peer [{}] created", con.getRemoteContainer());
@@ -176,13 +185,14 @@ public abstract class AbstractRequestResponseClient<R extends RequestResponseRes
         return result;
     }
 
-    private Future<ProtonSender> createSender(final ProtonConnection con, final String targetAddress, final Handler<String> closeHook) {
-        return AbstractHonoClient.createSender(context, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook);
+    private Future<ProtonSender> createSender(final ProtonConnection con, final String targetAddress, final long waitForInitialCredits, final Handler<String> closeHook) {
+
+        return AbstractHonoClient.createSender(context, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, waitForInitialCredits, closeHook);
     }
 
-    private Future<ProtonReceiver> createReceiver(final ProtonConnection con, final String sourceAddress, final Handler<String> closeHook) {
+    private Future<ProtonReceiver> createReceiver(final ProtonConnection con, final String sourceAddress, int prefetchCredits, final Handler<String> closeHook) {
 
-        return AbstractHonoClient.createReceiver(context, con, sourceAddress, ProtonQoS.AT_LEAST_ONCE, this::handleResponse, closeHook);
+        return AbstractHonoClient.createReceiver(context, con, sourceAddress, ProtonQoS.AT_LEAST_ONCE, prefetchCredits, this::handleResponse, closeHook);
     }
 
     /**
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
index cf14d2e4f..178e67081 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
@@ -76,21 +76,27 @@ public final class CredentialsClientImpl extends AbstractRequestResponseClient<C
      * @param context The vert.x context to run all interactions with the server on.
      * @param con The AMQP connection to the server.
      * @param tenantId The tenant for which credentials are handled.
+     * @param receiverPrefetchCredits Number of credits, given initially from receiver to sender.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.
      * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
      * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
      * @throws NullPointerException if any of the parameters is {@code null}.
+     * @throws IllegalArgumentException if receiverPrefetchCredits is {@code < 0}.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     public static void create(
             final Context context,
             final ProtonConnection con,
             final String tenantId,
+            final int receiverPrefetchCredits,
+            final long waitForInitialCredits,
             final Handler<String> senderCloseHook,
             final Handler<String> receiverCloseHook,
             final Handler<AsyncResult<CredentialsClient>> creationHandler) {
 
         final CredentialsClientImpl client = new CredentialsClientImpl(context, tenantId);
-        client.createLinks(con, senderCloseHook, receiverCloseHook).setHandler(s -> {
+        client.createLinks(con, receiverPrefetchCredits, waitForInitialCredits, senderCloseHook, receiverCloseHook).setHandler(s -> {
             if (s.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(client));
             } else {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index 0c4195ddb..1135ba5cd 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -74,16 +74,19 @@ public final class EventSenderImpl extends AbstractSender {
      * @param deviceId The device that the events will be published for or {@code null}
      *                 if the events are going to be be produced by arbitrary devices of the
      *                 tenant.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.
      * @param closeHook The handler to invoke when the Hono server closes the sender. The sender's
      *                  target address is provided as an argument to the handler.
      * @param creationHandler The handler to invoke with the result of the creation attempt.
      * @throws NullPointerException if any of context, connection, tenant or handler is {@code null}.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     public static void create(
             final Context context,
             final ProtonConnection con,
             final String tenantId,
             final String deviceId,
+            final long waitForInitialCredits,
             final Handler<String> closeHook,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
@@ -93,7 +96,7 @@ public final class EventSenderImpl extends AbstractSender {
         Objects.requireNonNull(creationHandler);
 
         final String targetAddress = getTargetAddress(tenantId, deviceId);
-        createSender(context, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook).setHandler(created -> {
+        createSender(context, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, waitForInitialCredits, closeHook).setHandler(created -> {
             if (created.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(
                         new EventSenderImpl(created.result(), tenantId, targetAddress, context, closeHook)));
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index e4c219afb..d9aa2df0f 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -22,6 +22,7 @@ import java.util.function.Consumer;
 
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.*;
+import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.connection.ConnectionFactory;
 import org.eclipse.hono.util.Constants;
 import org.slf4j.Logger;
@@ -47,6 +48,7 @@ public final class HonoClientImpl implements HonoClient {
     private final List<Handler<Void>> creationRequests = new ArrayList<>();
     private final AtomicBoolean connecting = new AtomicBoolean(false);
     private final ConnectionFactory connectionFactory;
+    private final ClientConfigProperties clientConfigProperties;
     private final Vertx vertx;
     private volatile boolean shutdown = false;
     private ProtonClientOptions clientOptions;
@@ -55,24 +57,36 @@ public final class HonoClientImpl implements HonoClient {
 
     /**
      * Creates a new client for a set of configuration properties.
-     * 
+     *
      * @param vertx The Vert.x instance to execute the client on, if {@code null} a new Vert.x instance is used.
      * @param connectionFactory The factory to use for creating an AMQP connection to the Hono server.
+     * @param clientConfigProperties The config properties to use (beside the connection properties)
      */
-    public HonoClientImpl(final Vertx vertx, final ConnectionFactory connectionFactory) {
+    public HonoClientImpl(final Vertx vertx, final ConnectionFactory connectionFactory, final ClientConfigProperties clientConfigProperties) {
         if (vertx != null) {
             this.vertx = vertx;
         } else {
             this.vertx = Vertx.vertx();
         }
         this.connectionFactory = connectionFactory;
+        this.clientConfigProperties = clientConfigProperties;
+    }
+
+    /**
+     * Creates a new client for a set of configuration properties.
+     *
+     * @param vertx The Vert.x instance to execute the client on, if {@code null} a new Vert.x instance is used.
+     * @param connectionFactory The factory to use for creating an AMQP connection to the Hono server.
+     */
+    public HonoClientImpl(final Vertx vertx, final ConnectionFactory connectionFactory) {
+        this(vertx, connectionFactory, new ClientConfigProperties());
     }
 
     /**
      * Sets the connection to the Hono server.
      * <p>
      * This method is mostly useful to inject a (mock) connection when running tests.
-     * 
+     *
      * @param connection The connection to use.
      */
     void setConnection(final ProtonConnection connection) {
@@ -83,7 +97,7 @@ public final class HonoClientImpl implements HonoClient {
      * Sets the vertx context to run all interactions with the Hono server on.
      * <p>
      * This method is mostly useful to inject a (mock) context when running tests.
-     * 
+     *
      * @param context The context to use.
      */
     void setContext(final Context context) {
@@ -235,7 +249,7 @@ public final class HonoClientImpl implements HonoClient {
         Objects.requireNonNull(tenantId);
         getOrCreateSender(
                 TelemetrySenderImpl.getTargetAddress(tenantId, deviceId),
-                (creationResult) -> createTelemetrySender(tenantId, deviceId, creationResult),
+                (creationResult) -> createTelemetrySender(tenantId, deviceId, clientConfigProperties.getWaitMillisForInitialCredits(), creationResult),
                 resultHandler);
         return this;
     }
@@ -255,7 +269,7 @@ public final class HonoClientImpl implements HonoClient {
         Objects.requireNonNull(resultHandler);
         getOrCreateSender(
                 EventSenderImpl.getTargetAddress(tenantId, deviceId),
-                (creationResult) -> createEventSender(tenantId, deviceId, creationResult),
+                (creationResult) -> createEventSender(tenantId, deviceId, clientConfigProperties.getWaitMillisForInitialCredits(), creationResult),
                 resultHandler);
         return this;
     }
@@ -303,12 +317,13 @@ public final class HonoClientImpl implements HonoClient {
     private HonoClient createTelemetrySender(
             final String tenantId,
             final String deviceId,
+            final long waitForInitialCredits,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         Future<MessageSender> senderTracker = Future.future();
         senderTracker.setHandler(creationHandler);
         checkConnection().compose(
-                connected -> TelemetrySenderImpl.create(context, connection, tenantId, deviceId,
+                connected -> TelemetrySenderImpl.create(context, connection, tenantId, deviceId, waitForInitialCredits,
                         onSenderClosed -> {
                             activeSenders.remove(TelemetrySenderImpl.getTargetAddress(tenantId, deviceId));
                         },
@@ -322,7 +337,7 @@ public final class HonoClientImpl implements HonoClient {
             final String tenantId,
             final Consumer<Message> telemetryConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
-        return createTelemetryConsumer(tenantId, AbstractHonoClient.DEFAULT_SENDER_CREDITS, telemetryConsumer,
+        return createTelemetryConsumer(tenantId, clientConfigProperties.getInitialCredits(), telemetryConsumer,
                 creationHandler);
     }
 
@@ -358,7 +373,7 @@ public final class HonoClientImpl implements HonoClient {
             final Consumer<Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
-        createEventConsumer(tenantId, AbstractHonoClient.DEFAULT_SENDER_CREDITS, (delivery, message) -> eventConsumer.accept(message), creationHandler);
+        createEventConsumer(tenantId, clientConfigProperties.getInitialCredits(), (delivery, message) -> eventConsumer.accept(message), creationHandler);
         return this;
     }
 
@@ -379,7 +394,7 @@ public final class HonoClientImpl implements HonoClient {
             final BiConsumer<ProtonDelivery, Message> eventConsumer,
             final Handler<AsyncResult<MessageConsumer>> creationHandler) {
 
-        createEventConsumer(tenantId, AbstractHonoClient.DEFAULT_SENDER_CREDITS, eventConsumer, creationHandler);
+        createEventConsumer(tenantId, clientConfigProperties.getInitialCredits(), eventConsumer, creationHandler);
         return this;
     }
 
@@ -412,12 +427,13 @@ public final class HonoClientImpl implements HonoClient {
     private HonoClient createEventSender(
             final String tenantId,
             final String deviceId,
+            final long waitForInitialCredits,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
         Future<MessageSender> senderTracker = Future.future();
         senderTracker.setHandler(creationHandler);
         checkConnection().compose(
-                connected -> EventSenderImpl.create(context, connection, tenantId, deviceId,
+                connected -> EventSenderImpl.create(context, connection, tenantId, deviceId, waitForInitialCredits,
                         onSenderClosed -> {
                             activeSenders.remove(EventSenderImpl.getTargetAddress(tenantId, deviceId));
                         },
@@ -470,11 +486,15 @@ public final class HonoClientImpl implements HonoClient {
                     context,
                     connection,
                     tenantId,
+                    clientConfigProperties.getInitialCredits(),
+                    clientConfigProperties.getWaitMillisForInitialCredits(),
                     this::removeRegistrationClient,
                     this::removeRegistrationClient,
                     creationAttempt -> {
                         if (creationAttempt.succeeded()) {
-                            activeRegClients.put(tenantId, creationAttempt.result());
+                            RegistrationClient registrationClient = creationAttempt.result();
+                            registrationClient.setRequestTimeout(clientConfigProperties.getRequestTimeoutMillis());
+                            activeRegClients.put(tenantId, registrationClient);
                             LOG.debug("successfully created registration client for [{}]", tenantId);
                         } else {
                             LOG.debug("failed to create registration client for [{}]", tenantId, creationAttempt.cause());
@@ -517,11 +537,15 @@ public final class HonoClientImpl implements HonoClient {
                     context,
                     connection,
                     tenantId,
+                    clientConfigProperties.getInitialCredits(),
+                    clientConfigProperties.getWaitMillisForInitialCredits(),
                     this::removeCredentialsClient,
                     this::removeCredentialsClient,
                     creationAttempt -> {
                         if (creationAttempt.succeeded()) {
-                            activeCredClients.put(tenantId, creationAttempt.result());
+                            CredentialsClient credentialsClient = creationAttempt.result();
+                            credentialsClient.setRequestTimeout(clientConfigProperties.getRequestTimeoutMillis());
+                            activeCredClients.put(tenantId, credentialsClient);
                             LOG.debug("successfully created credentials client for [{}]", tenantId);
                         } else {
                             LOG.debug("failed to create credentials client for [{}]", tenantId, creationAttempt.cause());
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
index b0098ee5f..699361024 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
@@ -65,21 +65,27 @@ public final class RegistrationClientImpl extends AbstractRequestResponseClient<
      * @param context The vert.x context to run all interactions with the server on.
      * @param con The AMQP connection to the server.
      * @param tenantId The tenant to consumer events for.
+     * @param receiverPrefetchCredits Number of credits, given initially from receiver to sender.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.*
      * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly.
      * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly.
      * @param creationHandler The handler to invoke with the outcome of the creation attempt.
      * @throws NullPointerException if any of the parameters is {@code null}.
+     * @throws IllegalArgumentException if receiverPrefetchCredits is {@code < 0}.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     public static void create(
             final Context context,
             final ProtonConnection con,
             final String tenantId,
+            final int receiverPrefetchCredits,
+            final long waitForInitialCredits,
             final Handler<String> senderCloseHook,
             final Handler<String> receiverCloseHook,
             final Handler<AsyncResult<RegistrationClient>> creationHandler) {
 
         final RegistrationClientImpl client = new RegistrationClientImpl(context, tenantId);
-        client.createLinks(con, senderCloseHook, receiverCloseHook).setHandler(s -> {
+        client.createLinks(con, receiverPrefetchCredits, waitForInitialCredits, senderCloseHook, receiverCloseHook).setHandler(s -> {
             if (s.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(client));
             } else {
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index 44bc39e9b..a5baa1afb 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -72,16 +72,19 @@ public final class TelemetrySenderImpl extends AbstractSender {
      * @param deviceId The device that the telemetry data will be uploaded for or {@code null}
      *                 if the data to be uploaded will be produced by arbitrary devices of the
      *                 tenant.
+     * @param waitForInitialCredits Milliseconds to wait after link creation if there are no credits.
      * @param closeHook The handler to invoke when the Hono server closes the sender. The sender's
      *                  target address is provided as an argument to the handler.
      * @param creationHandler The handler to invoke with the result of the creation attempt.
      * @throws NullPointerException if any of context, connection, tenant or handler is {@code null}.
+     * @throws IllegalArgumentException if waitForInitialCredits is {@code < 1}.
      */
     public static void create(
             final Context context,
             final ProtonConnection con,
             final String tenantId,
             final String deviceId,
+            final long waitForInitialCredits,
             final Handler<String> closeHook,
             final Handler<AsyncResult<MessageSender>> creationHandler) {
 
@@ -91,7 +94,7 @@ public final class TelemetrySenderImpl extends AbstractSender {
         Objects.requireNonNull(creationHandler);
 
         final String targetAddress = getTargetAddress(tenantId, deviceId);
-        createSender(context, con, targetAddress, ProtonQoS.AT_MOST_ONCE, closeHook).setHandler(created -> {
+        createSender(context, con, targetAddress, ProtonQoS.AT_MOST_ONCE, waitForInitialCredits, closeHook).setHandler(created -> {
             if (created.succeeded()) {
                 creationHandler.handle(Future.succeededFuture(
                         new TelemetrySenderImpl(created.result(), tenantId, targetAddress, context, closeHook)));
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
index b052c2be3..8c2888935 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/EventConsumerImplTest.java
@@ -19,6 +19,7 @@ import java.util.function.BiConsumer;
 import org.apache.qpid.proton.amqp.messaging.Released;
 import org.apache.qpid.proton.amqp.transport.Source;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.config.ClientConfigProperties;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -90,7 +91,7 @@ public class EventConsumerImplTest {
             return receiver;
         });
         Async consumerCreation = ctx.async();
-        EventConsumerImpl.create(vertx.getOrCreateContext(), con, "tenant", AbstractHonoClient.DEFAULT_SENDER_CREDITS, eventConsumer, ctx.asyncAssertSuccess(s -> {
+        EventConsumerImpl.create(vertx.getOrCreateContext(), con, "tenant", new ClientConfigProperties().getInitialCredits(), eventConsumer, ctx.asyncAssertSuccess(s -> {
             consumerCreation.complete();
         }));
         consumerCreation.await(500);
