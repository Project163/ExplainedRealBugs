diff --git a/client/src/main/java/org/eclipse/hono/client/MessageSender.java b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
index 35b9008ab..59de71a96 100644
--- a/client/src/main/java/org/eclipse/hono/client/MessageSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/MessageSender.java
@@ -14,22 +14,26 @@
 package org.eclipse.hono.client;
 
 import java.util.Map;
-import java.util.function.BiConsumer;
 
 import org.apache.qpid.proton.message.Message;
 
 import io.vertx.core.AsyncResult;
+import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonDelivery;
 
 /**
- * A client for publishing messages to a Hono server.
+ * A client for publishing messages to Hono.
  *
  */
 public interface MessageSender {
 
     /**
      * Gets the name of the endpoint this sender sends messages to.
+     * <p>
+     * The name returned is implementation specific, e.g. an implementation
+     * that can be used to upload telemetry data to Hono will return
+     * the value <em>telemetry</em>.
      * 
      * @return The endpoint name.
      */
@@ -37,6 +41,8 @@ public interface MessageSender {
 
     /**
      * Gets the number of messages this sender can send based on its current number of credits.
+     * <p>
+     * Note that the value returned is valid during execution of the current vert.x handler only.
      * 
      * @return The number of messages.
      */
@@ -44,8 +50,10 @@ public interface MessageSender {
 
     /**
      * Checks if this sender can send or buffer (and send later) a message.
+     * <p>
+     * Note that the value returned is valid during execution of the current vert.x handler only.
      * 
-     * @return {@code false} if a message can be sent or buffered.
+     * @return {@code true} if a message can not be sent or buffered at the moment.
      */
     boolean sendQueueFull();
 
@@ -76,32 +84,6 @@ public interface MessageSender {
      */
     void sendQueueDrainHandler(Handler<Void> handler);
 
-    /**
-     * Sets a callback for handling the closing of this sender due to an error condition indicated by
-     * the server.
-     * <p>
-     * When this handler is called back, this client's link to the Hono server's endpoint has been
-     * closed due to an error condition. Possible reasons include:
-     * <ul>
-     * <li>A sent message does not comply with the Hono API.</li>
-     * <li>This client is not authorized to publish messages for the tenant it has been configured for.</li>
-     * </ul>
-     * The former problem usually indicates an implementation error in the client whereas the
-     * latter problem indicates that the client's authorizations might have changed on the server
-     * side after it has connected to the server.
-     * 
-     * @param errorHandler The callback for handling the error condition. The error handler's <em>cause</em>
-     *                     property will contain the cause for the closing of the link.
-     */
-    void setErrorHandler(Handler<AsyncResult<Void>> errorHandler);
-
-    /**
-     * Sets the default callback for disposition updates for messages sent with this {@link MessageSender}.
-     *
-     * @param dispositionHandler consumer that accepts a message id and updated disposition
-     */
-    void setDefaultDispositionHandler(BiConsumer<Object, ProtonDelivery> dispositionHandler);
-
     /**
      * Closes the AMQP link with the Hono server this sender is using.
      * <p>
@@ -114,6 +96,8 @@ public interface MessageSender {
 
     /**
      * Checks if this sender is (locally) open.
+     * <p>
+     * Note that the value returned is valid during execution of the current vert.x handler only.
      * 
      * @return {@code true} if this sender can be used to send messages to the peer.
      */
@@ -123,204 +107,185 @@ public interface MessageSender {
      * Sends an AMQP 1.0 message to the endpoint configured for this client.
      * 
      * @param message The message to send.
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
-     * @throws NullPointerException if the message is {@code null}.
-     */
-    boolean send(Message message);
-
-    /**
-     * Sends an AMQP 1.0 message to the endpoint configured for this client.
-     *
-     * @param message The message to send.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if the message is {@code null}.
      */
-    boolean send(Message message, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+    Future<ProtonDelivery> send(Message message);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      * 
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param payload The data to send.
+     *                <p>
      *                The payload's byte representation will be contained in the message as an AMQP 1.0
      *                <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      *                    If the content type specifies a particular character set, this character set will be used to
      *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if any of the parameters is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    boolean send(String deviceId, String payload, String contentType, String registrationAssertion);
+    Future<ProtonDelivery> send(String deviceId, String payload, String contentType, String registrationAssertion);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      * 
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param payload The data to send.
+     *                <p>
      *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    boolean send(String deviceId, byte[] payload, String contentType, String registrationAssertion);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param payload The data to send.
-     *                The payload's byte representation will be contained in the message as an AMQP 1.0
-     *                <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     *                    If the content type specifies a particular character set, this character set will be used to
-     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
-     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
-     *                              this sender has been created for.
-     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
-     *                              client} can be used to obtain such an assertion.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if any of the parameters is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    boolean send(String deviceId, String payload, String contentType, String registrationAssertion, BiConsumer<Object, ProtonDelivery> dispositionHandler);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param payload The data to send.
-     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
-     *                              this sender has been created for.
-     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
-     *                              client} can be used to obtain such an assertion.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
-     * @throws NullPointerException if any of the parameters is {@code null}.
-     */
-    boolean send(String deviceId, byte[] payload, String contentType, String registrationAssertion, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+    Future<ProtonDelivery> send(String deviceId, byte[] payload, String contentType, String registrationAssertion);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      *
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param properties The application properties.
+     *                   <p>
      *                   AMQP application properties that can be used for carrying data in the message other than the payload
      * @param payload The data to send.
+     *                <p>
      *                The payload's byte representation will be contained in the message as an AMQP 1.0
      *                <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      *                    If the content type specifies a particular character set, this character set will be used to
      *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
-     * @throws NullPointerException if any of device id, payload or content type is {@code null}.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
+     * @throws NullPointerException if any of device id, payload, content type or registration assertion
+     *                              is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    boolean send(String deviceId, Map<String, ?> properties, String payload, String contentType, String registrationAssertion);
+    Future<ProtonDelivery> send(
+            String deviceId,
+            Map<String, ?> properties,
+            String payload,
+            String contentType,
+            String registrationAssertion);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
      *
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param properties The application properties.
+     *                   <p>
      *                   AMQP application properties that can be used for carrying data in the message other than the payload
      * @param payload The data to send.
+     *                <p>
      *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServerErrorException} if the message
+     *         could not be sent due to a lack of credit.
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
-     */
-    boolean send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType, String registrationAssertion);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param properties The application properties.
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
-     * @param payload The data to send.
-     *                The payload's byte representation will be contained in the message as an AMQP 1.0
-     *                <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     *                    If the content type specifies a particular character set, this character set will be used to
-     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
-     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
-     *                              this sender has been created for.
-     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
-     *                              client} can be used to obtain such an assertion.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
-     * @throws NullPointerException if any of device id, payload or content type is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    boolean send(String deviceId, Map<String, ?> properties, String payload, String contentType, String registrationAssertion,
-            BiConsumer<Object, ProtonDelivery> dispositionHandler);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     *
-     * @param deviceId The id of the device.
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param properties The application properties.
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
-     * @param payload The data to send.
-     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
-     *                              this sender has been created for.
-     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
-     *                              client} can be used to obtain such an assertion.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @return {@code true} if this client has enough capacity to accept and send the message. If not,
-     *         the message is discarded and {@code false} is returned.
-     * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
-     */
-    boolean send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType, String registrationAssertion,
-            BiConsumer<Object, ProtonDelivery> dispositionHandler);
+    Future<ProtonDelivery> send(
+            String deviceId,
+            Map<String, ?> properties,
+            byte[] payload,
+            String contentType,
+            String registrationAssertion);
 
     /**
      * Sends an AMQP 1.0 message to the endpoint configured for this client.
@@ -333,25 +298,20 @@ public interface MessageSender {
      * @param message The message to send.
      * @param capacityAvailableHandler The handler to notify when this sender can accept and send
      *                                 another message.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if the message is {@code null}.
      */
-    void send(Message message, Handler<Void> capacityAvailableHandler);
-
-    /**
-     * Sends an AMQP 1.0 message to the endpoint configured for this client.
-     * <p>
-     * The message will be sent immediately if this client has enough credit available on its
-     * link to the Hono server or it will be sent later after this client has been replenished
-     * with more credit. In both cases the handler will be notified <em>once only</em> when this
-     * sender has capacity available for accepting and sending the next message.
-     *
-     * @param message The message to send.
-     * @param capacityAvailableHandler The handler to notify when this sender can accept and send
-     *                                 another message.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @throws NullPointerException if the message is {@code null}.
-     */
-    void send(Message message, Handler<Void> capacityAvailableHandler, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+    Future<ProtonDelivery> send(Message message, Handler<Void> capacityAvailableHandler);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
@@ -362,24 +322,44 @@ public interface MessageSender {
      * sender has capacity available for accepting and sending the next message.
      * 
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param payload The data to send.
+     *                <p>
      *                The payload's byte representation will be contained in the message as an AMQP 1.0
      *                <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      *                    If the content type specifies a particular character set, this character set will be used to
      *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
      * @param capacityAvailableHandler The handler to notify when this sender can accept and send
      *                                 another message.
-     * @throws NullPointerException if any of device id, payload or content type is {@code null}.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
+     * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    void send(String deviceId, String payload, String contentType, String registrationAssertion, Handler<Void> capacityAvailableHandler);
+    Future<ProtonDelivery> send(
+            String deviceId,
+            String payload,
+            String contentType,
+            String registrationAssertion,
+            Handler<Void> capacityAvailableHandler);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
@@ -390,50 +370,41 @@ public interface MessageSender {
      * sender has capacity available for accepting and sending the next message.
      * 
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param payload The data to send.
+     *                <p>
      *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
      * @param capacityAvailableHandler The handler to notify when this sender can accept and send
      *                                 another message.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
-     */
-    void send(String deviceId, byte[] payload, String contentType, String registrationAssertion, Handler<Void> capacityAvailableHandler);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     * <p>
-     * The message will be sent immediately if this client has enough credit available on its
-     * link to the Hono server or it will be sent later after this client has been replenished
-     * with more credit. In both cases the handler will be notified <em>once only</em> when this
-     * sender has capacity available for accepting and sending the next message.
-     *
-     * @param deviceId The id of the device.
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param properties The application properties.
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
-     * @param payload The data to send.
-     *                The payload's byte representation will be contained in the message as an AMQP 1.0
-     *                <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     *                    If the content type specifies a particular character set, this character set will be used to
-     *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
-     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
-     *                              this sender has been created for.
-     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
-     *                              client} can be used to obtain such an assertion.
-     * @param capacityAvailableHandler The handler to notify when this sender can accept and send
-     *                                 another message.
-     * @throws NullPointerException if any of device id, payload or content type is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    void send(String deviceId, Map<String, ?> properties, String payload, String contentType, String registrationAssertion, Handler<Void> capacityAvailableHandler);
+    Future<ProtonDelivery> send(
+            String deviceId,
+            byte[] payload,
+            String contentType,
+            String registrationAssertion,
+            Handler<Void> capacityAvailableHandler);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
@@ -444,54 +415,48 @@ public interface MessageSender {
      * sender has capacity available for accepting and sending the next message.
      *
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param properties The application properties.
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
-     * @param payload The data to send.
-     *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
-     * @param contentType The content type of the payload.
-     *                    This parameter will be used as the value for the message's <em>content-type</em> property.
-     * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
-     *                              this sender has been created for.
-     *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
-     *                              client} can be used to obtain such an assertion.
-     * @param capacityAvailableHandler The handler to notify when this sender can accept and send
-     *                                 another message.
-     * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
-     */
-    void send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType, String registrationAssertion, Handler<Void> capacityAvailableHandler);
-
-    /**
-     * Sends a message for a given device to the endpoint configured for this client.
-     * <p>
-     * The message will be sent immediately if this client has enough credit available on its
-     * link to the Hono server or it will be sent later after this client has been replenished
-     * with more credit. In both cases the handler will be notified <em>once only</em> when this
-     * sender has capacity available for accepting and sending the next message.
-     *
-     * @param deviceId The id of the device.
-     *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
-     * @param properties The application properties.
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
+     *                   <p>
+     *                   AMQP application properties that can be used for carrying data in the message other than the payload.
      * @param payload The data to send.
+     *                <p>
      *                The payload's byte representation will be contained in the message as an AMQP 1.0
      *                <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      *                    If the content type specifies a particular character set, this character set will be used to
      *                    encode the payload to its byte representation. Otherwise, UTF-8 will be used.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
      * @param capacityAvailableHandler The handler to notify when this sender can accept and send
      *                                 another message.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
-     * @throws NullPointerException if any of device id, payload or content type is {@code null}.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
+     * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
      * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    void send(String deviceId, Map<String, ?> properties, String payload, String contentType, String registrationAssertion,
-            Handler<Void> capacityAvailableHandler, BiConsumer<Object, ProtonDelivery> dispositionHandler);
+    Future<ProtonDelivery> send(
+            String deviceId,
+            Map<String, ?> properties,
+            String payload,
+            String contentType,
+            String registrationAssertion,
+            Handler<Void> capacityAvailableHandler);
 
     /**
      * Sends a message for a given device to the endpoint configured for this client.
@@ -502,23 +467,43 @@ public interface MessageSender {
      * sender has capacity available for accepting and sending the next message.
      *
      * @param deviceId The id of the device.
+     *                 <p>
      *                 This parameter will be used as the value for the message's application property <em>device_id</em>.
      * @param properties The application properties.
-     *                   AMQP application properties that can be used for carrying data in the message other than the payload
+     *                   <p>
+     *                   AMQP application properties that can be used for carrying data in the message other than the payload.
      * @param payload The data to send.
+     *                <p>
      *                The payload will be contained in the message as an AMQP 1.0 <em>Data</em> section.
      * @param contentType The content type of the payload.
+     *                    <p>
      *                    This parameter will be used as the value for the message's <em>content-type</em> property.
      * @param registrationAssertion A JSON Web Token asserting that the device is enabled and belongs to the tenant that
      *                              this sender has been created for.
+     *                              <p>
      *                              The {@linkplain RegistrationClient#assertRegistration(String, Handler) registration
      *                              client} can be used to obtain such an assertion.
      * @param capacityAvailableHandler The handler to notify when this sender can accept and send
      *                                 another message.
-     * @param dispositionHandler The handler for disposition updates that accepts a message id and updated disposition
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         If an event is sent which cannot be processed by the peer the future will
+     *         be failed with either a {@code ServerErrorException} or a {@link ClientErrorException}
+     *         depending on the reason for the failure to process the message.
      * @throws NullPointerException if any of device id, payload, content type or registration assertion is {@code null}.
+     * @throws IllegalArgumentException if the content type specifies an unsupported character set.
      */
-    void send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType, String registrationAssertion,
-            Handler<Void> capacityAvailableHandler, BiConsumer<Object, ProtonDelivery> dispositionHandler);
-
+    Future<ProtonDelivery> send(
+            String deviceId,
+            Map<String, ?> properties,
+            byte[] payload,
+            String contentType,
+            String registrationAssertion,
+            Handler<Void> capacityAvailableHandler);
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
index 9e239b16f..391cf7306 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/AbstractSender.java
@@ -13,12 +13,11 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.net.HttpURLConnection;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.Map;
 import java.util.Objects;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.BiConsumer;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -26,6 +25,8 @@ import org.apache.qpid.proton.amqp.Binary;
 import org.apache.qpid.proton.amqp.messaging.Data;
 import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.client.ServerErrorException;
+import org.eclipse.hono.client.ServiceInvocationException;
 import org.eclipse.hono.config.ClientConfigProperties;
 import org.eclipse.hono.util.MessageHelper;
 import org.slf4j.Logger;
@@ -44,24 +45,24 @@ import io.vertx.proton.ProtonSender;
  */
 abstract class AbstractSender extends AbstractHonoClient implements MessageSender {
 
-    private static final Logger     LOG = LoggerFactory.getLogger(AbstractSender.class);
-    private static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
-    private static final Pattern    CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
+    private static final Pattern CHARSET_PATTERN = Pattern.compile("^.*;charset=(.*)$");
+
+    /**
+     * A logger to be shared with subclasses.
+     */
+    protected final Logger LOG = LoggerFactory.getLogger(getClass());
 
     protected final String tenantId;
     protected final String targetAddress;
 
-    private final Handler<String>              closeHook;
-    private Handler<Void>                      drainHandler;
-    private BiConsumer<Object, ProtonDelivery> defaultDispositionHandler = this::logUpdatedDisposition;
+    private Handler<Void> drainHandler;
 
     AbstractSender(final ClientConfigProperties config, final ProtonSender sender, final String tenantId, final String targetAddress,
-            final Context context, final Handler<String> closeHook) {
+            final Context context) {
         super(context, config);
         this.sender = Objects.requireNonNull(sender);
         this.tenantId = Objects.requireNonNull(tenantId);
         this.targetAddress = targetAddress;
-        this.closeHook = closeHook;
     }
 
     @Override
@@ -108,122 +109,74 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     }
 
     @Override
-    public final void setErrorHandler(final Handler<AsyncResult<Void>> errorHandler) {
-
-        sender.closeHandler(s -> {
-            if (s.failed()) {
-                LOG.debug("server closed link with error condition: {}", s.cause().getMessage());
-                sender.close();
-                if (closeHook != null) {
-                    closeHook.handle(targetAddress);
-                }
-                errorHandler.handle(Future.failedFuture(s.cause()));
-            } else {
-                LOG.debug("server closed link");
-                sender.close();
-                if (closeHook != null) {
-                    closeHook.handle(targetAddress);
-                }
-            }
-        });
-    }
-
-    @Override
-    public final void setDefaultDispositionHandler(final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        this.defaultDispositionHandler = dispositionHandler;
-    }
+    public final Future<ProtonDelivery> send(final Message rawMessage, final Handler<Void> capacityAvailableHandler) {
 
-    @Override
-    public final void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
         Objects.requireNonNull(rawMessage);
-        Objects.requireNonNull(dispositionHandler);
+
         if (capacityAvailableHandler == null) {
+            final Future<ProtonDelivery> result = Future.future();
             context.runOnContext(send -> {
-                sendMessage(rawMessage, dispositionHandler);
+                sendMessage(rawMessage).setHandler(result.completer());
             });
+            return result;
         } else if (this.drainHandler != null) {
             throw new IllegalStateException("cannot send message while waiting for replenishment with credit");
         } else if (sender.isOpen()) {
+            final Future<ProtonDelivery> result = Future.future();
             context.runOnContext(send -> {
-                sendMessage(rawMessage, dispositionHandler);
+                sendMessage(rawMessage).setHandler(result.completer());
                 if (sender.sendQueueFull()) {
                     sendQueueDrainHandler(capacityAvailableHandler);
                 } else {
                     capacityAvailableHandler.handle(null);
                 }
             });
+            return result;
         } else {
             throw new IllegalStateException("sender is not open");
         }
     }
 
     @Override
-    public final boolean send(final Message rawMessage, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        Objects.requireNonNull(rawMessage);
-        Objects.requireNonNull(dispositionHandler);
+    public final Future<ProtonDelivery> send(final Message rawMessage) {
 
-        if (sender.sendQueueFull()) {
-            return false;
-        } else {
-            context.runOnContext(send -> {
-                sendMessage(rawMessage, dispositionHandler);
-            });
-            return true;
-        }
-    }
-
-    private void sendMessage(final Message rawMessage, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        rawMessage.setMessageId(String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement()));
-        sender.send(rawMessage, deliveryUpdated -> dispositionHandler.accept(rawMessage.getMessageId(), deliveryUpdated));
-        LOG.trace("sent message, remaining credit: {}, queued messages: {}", sender.getCredit(), sender.getQueued());
-    }
-
-    @Override
-    public final void send(final Message rawMessage, final Handler<Void> capacityAvailableHandler) {
-        send(rawMessage, capacityAvailableHandler, this.defaultDispositionHandler);
-    }
+        Objects.requireNonNull(rawMessage);
 
-    @Override
-    public final boolean send(final Message rawMessage) {
-        return send(rawMessage, this.defaultDispositionHandler);
+        final Future<ProtonDelivery> result = Future.future();
+        context.runOnContext(send -> {
+            if (sender.sendQueueFull()) {
+                result.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, "no credit available"));
+            } else {
+                sendMessage(rawMessage).setHandler(result.completer());
+            }
+        });
+        return result;
     }
 
     @Override
-    public final boolean send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion) {
+    public final Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion) {
         return send(deviceId, null, payload, contentType, registrationAssertion);
     }
 
     @Override
-    public final boolean send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion,
-            final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        return send(deviceId, null, payload, contentType, registrationAssertion, dispositionHandler);
-    }
-
-    @Override
-    public final void send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion,
+    public final Future<ProtonDelivery> send(final String deviceId, final byte[] payload, final String contentType, final String registrationAssertion,
             final Handler<Void> capacityAvailableHandler) {
-        send(deviceId, null, payload, contentType, registrationAssertion, capacityAvailableHandler);
+        return send(deviceId, null, payload, contentType, registrationAssertion, capacityAvailableHandler);
     }
 
     @Override
-    public final boolean send(final String deviceId, final String payload, final String contentType, final String registrationAssertion) {
+    public final Future<ProtonDelivery> send(final String deviceId, final String payload, final String contentType, final String registrationAssertion) {
         return send(deviceId, null, payload, contentType, registrationAssertion);
     }
 
     @Override
-    public final boolean send(final String deviceId, final String payload, final String contentType, final String registrationAssertion,
-            final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        return send(deviceId, null, payload, contentType, registrationAssertion, dispositionHandler);
-    }
-
-    @Override
-    public final void send(final String deviceId, final String payload, final String contentType, final String registrationAssertion,
+    public final Future<ProtonDelivery> send(final String deviceId, final String payload, final String contentType, final String registrationAssertion,
             final Handler<Void> capacityAvailableHandler) {
-        send(deviceId, null, payload, contentType, registrationAssertion, capacityAvailableHandler);
+        return send(deviceId, null, payload, contentType, registrationAssertion, capacityAvailableHandler);
     }
 
     @Override
-    public final boolean send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType,
+    public final Future<ProtonDelivery> send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType,
             final String registrationAssertion) {
         Objects.requireNonNull(payload);
         final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
@@ -231,74 +184,69 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
     }
 
     @Override
-    public final boolean send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType,
-                              final String registrationAssertion, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
-        Objects.requireNonNull(payload);
-        final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
-        return send(deviceId, properties, payload.getBytes(charset), contentType, registrationAssertion, dispositionHandler);
-    }
-
-    @Override
-    public final boolean send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType,
-            final String registrationAssertion) {
-        return send(deviceId, properties, payload, contentType, registrationAssertion, this.defaultDispositionHandler);
-    }
-
-    @Override
-    public final boolean send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType,
-                              final String registrationAssertion, final BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+    public final Future<ProtonDelivery> send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType,
+                              final String registrationAssertion) {
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(payload);
         Objects.requireNonNull(contentType);
         Objects.requireNonNull(registrationAssertion);
-        Objects.requireNonNull(dispositionHandler);
+
         final Message msg = ProtonHelper.message();
         msg.setAddress(getTo(deviceId));
         msg.setBody(new Data(new Binary(payload)));
         setApplicationProperties(msg, properties);
         addProperties(msg, deviceId, contentType, registrationAssertion);
         addEndpointSpecificProperties(msg, deviceId);
-        return send(msg, dispositionHandler);
+        return send(msg);
     }
 
     @Override
-    public final void send(final String deviceId, final Map<String, ?> properties, final String payload, final String contentType,
-            final String registrationAssertion, final Handler<Void> capacityAvailableHandler) {
-        send(deviceId, properties, payload, contentType, registrationAssertion, capacityAvailableHandler, defaultDispositionHandler);
-    }
-
-    @Override
-    public final void send(final String deviceId, final Map<String, ?> properties, final byte[] payload, final String contentType,
-            final String registrationAssertion, final Handler<Void> capacityAvailableHandler) {
-        send(deviceId, properties, payload, contentType, registrationAssertion, capacityAvailableHandler, defaultDispositionHandler);
-    }
-
-    @Override
-    public void send(String deviceId, Map<String, ?> properties, String payload, String contentType,
-            String registrationAssertion, Handler<Void> capacityAvailableHandler,
-            BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+    public final Future<ProtonDelivery> send(String deviceId, Map<String, ?> properties, String payload, String contentType,
+            String registrationAssertion, Handler<Void> capacityAvailableHandler) {
         Objects.requireNonNull(payload);
         final Charset charset = getCharsetForContentType(Objects.requireNonNull(contentType));
-        send(deviceId, properties, payload.getBytes(charset), contentType, registrationAssertion, capacityAvailableHandler, dispositionHandler);
+        return send(deviceId, properties, payload.getBytes(charset), contentType, registrationAssertion, capacityAvailableHandler);
     }
 
     @Override
-    public void send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType,
-            String registrationAssertion, Handler<Void> capacityAvailableHandler,
-            BiConsumer<Object, ProtonDelivery> dispositionHandler) {
+    public final Future<ProtonDelivery> send(String deviceId, Map<String, ?> properties, byte[] payload, String contentType,
+            String registrationAssertion, Handler<Void> capacityAvailableHandler) {
+
         Objects.requireNonNull(deviceId);
         Objects.requireNonNull(payload);
         Objects.requireNonNull(contentType);
         Objects.requireNonNull(registrationAssertion);
+
         final Message msg = ProtonHelper.message();
         msg.setAddress(getTo(deviceId));
         msg.setBody(new Data(new Binary(payload)));
         setApplicationProperties(msg, properties);
         addProperties(msg, deviceId, contentType, registrationAssertion);
         addEndpointSpecificProperties(msg, deviceId);
-        send(msg, capacityAvailableHandler, dispositionHandler);
+        return send(msg, capacityAvailableHandler);
     }
 
+    /**
+     * Sends an AMQP 1.0 message to the peer this client is configured for.
+     * <p>
+     * The message is sent according to the delivery semantics defined by
+     * the Hono API this client interacts with.
+     * 
+     * @param message The message to send.
+     * @return A future indicating the outcome of the operation.
+     *         <p>
+     *         The future will be succeeded if the message has been sent to the endpoint.
+     *         The delivery contained in the future represents the delivery state at the time
+     *         the future has been succeeded, i.e. for telemetry data it will be locally
+     *         <em>unsettled</em> without any outcome yet. For events it will be locally
+     *         and remotely <em>settled</em> and will contain the <em>accepted</em> outcome.
+     *         <p>
+     *         The future will be failed with a {@link ServiceInvocationException} if the
+     *         message could not be sent.
+     * @throws NullPointerException if the message is {@code null}.
+     */
+    protected abstract Future<ProtonDelivery> sendMessage(final Message message);
+
     /**
      * Gets the value of the <em>to</em> property to be used for messages produced by this sender.
      * 
@@ -337,8 +285,4 @@ abstract class AbstractSender extends AbstractHonoClient implements MessageSende
             return StandardCharsets.UTF_8;
         }
     }
-
-    private void logUpdatedDisposition(final Object messageId, final ProtonDelivery delivery) {
-        LOG.trace("delivery state updated [message ID: {}, new remote state: {}]", messageId, delivery.getRemoteState());
-    }
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
index 8f5fb86c3..3a5a3b3a7 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/EventSenderImpl.java
@@ -13,17 +13,25 @@
 
 package org.eclipse.hono.client.impl;
 
+import java.net.HttpURLConnection;
 import java.util.Objects;
+import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.ClientErrorException;
 import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.client.ServerErrorException;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.EventConstants;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonSender;
 
@@ -32,11 +40,11 @@ import io.vertx.proton.ProtonSender;
  */
 public final class EventSenderImpl extends AbstractSender {
 
-    private static final String EVENT_ENDPOINT_NAME = "event";
+    private static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
 
-    private EventSenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId, final String targetAddress,
-            final Context context, final Handler<String> closeHook) {
-        super(config, sender, tenantId, targetAddress, context, closeHook);
+    EventSenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
+            final String targetAddress, final Context context) {
+        super(config, sender, tenantId, targetAddress, context);
     }
 
     /**
@@ -49,7 +57,7 @@ public final class EventSenderImpl extends AbstractSender {
      * @throws NullPointerException if tenant is {@code null}.
      */
     public static String getTargetAddress(final String tenantId, final String deviceId) {
-        StringBuilder address = new StringBuilder(EVENT_ENDPOINT_NAME).append("/").append(tenantId);
+        StringBuilder address = new StringBuilder(EventConstants.EVENT_ENDPOINT).append("/").append(tenantId);
         if (deviceId != null && deviceId.length() > 0) {
             address.append("/").append(deviceId);
         }
@@ -58,7 +66,7 @@ public final class EventSenderImpl extends AbstractSender {
 
     @Override
     public String getEndpoint() {
-        return EVENT_ENDPOINT_NAME;
+        return EventConstants.EVENT_ENDPOINT;
     }
 
     @Override
@@ -99,7 +107,7 @@ public final class EventSenderImpl extends AbstractSender {
         final String targetAddress = getTargetAddress(tenantId, deviceId);
         createSender(context, clientConfig, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook).compose(sender -> {
             return Future.<MessageSender> succeededFuture(
-                    new EventSenderImpl(clientConfig, sender, tenantId, targetAddress, context, closeHook));
+                    new EventSenderImpl(clientConfig, sender, tenantId, targetAddress, context));
         }).setHandler(creationHandler);
     }
 
@@ -110,4 +118,43 @@ public final class EventSenderImpl extends AbstractSender {
     protected void addEndpointSpecificProperties(final Message msg, final String deviceId) {
         msg.setDurable(true);
     }
+
+    @Override
+    protected Future<ProtonDelivery> sendMessage(final Message message) {
+
+        Objects.requireNonNull(message);
+
+        final Future<ProtonDelivery> result = Future.future();
+        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
+        message.setMessageId(messageId);
+        sender.send(message, deliveryUpdated -> {
+
+            if (deliveryUpdated.remotelySettled()) {
+                if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    LOG.trace("event [message ID: {}] accepted by peer", messageId);
+                    result.complete(deliveryUpdated);
+                } else if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    Rejected rejected = (Rejected) deliveryUpdated.getRemoteState();
+                    if (rejected.getError() == null) {
+                        LOG.debug("event [message ID: {}] rejected by peer", messageId);
+                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                    } else {
+                        LOG.debug("event [message ID: {}] rejected by peer: {}, {}", messageId,
+                                rejected.getError().getCondition(), rejected.getError().getDescription());
+                        result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST, rejected.getError().getDescription()));
+                    }
+                } else {
+                    LOG.debug("event [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
+                    result.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));
+                }
+            } else {
+                LOG.warn("peer did not settle event, failing delivery [new remote state: {}]", deliveryUpdated.getRemoteState());
+                result.fail(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));
+            }
+        });
+        LOG.trace("sent event [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
+
+        return result;
+    }
+
 }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
index dde214221..520287762 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/TelemetrySenderImpl.java
@@ -13,15 +13,21 @@
 package org.eclipse.hono.client.impl;
 
 import java.util.Objects;
+import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.message.Message;
 import org.eclipse.hono.client.MessageSender;
 import org.eclipse.hono.config.ClientConfigProperties;
+import org.eclipse.hono.util.TelemetryConstants;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
 import io.vertx.core.Future;
 import io.vertx.core.Handler;
 import io.vertx.proton.ProtonConnection;
+import io.vertx.proton.ProtonDelivery;
 import io.vertx.proton.ProtonQoS;
 import io.vertx.proton.ProtonSender;
 
@@ -30,11 +36,11 @@ import io.vertx.proton.ProtonSender;
  */
 public final class TelemetrySenderImpl extends AbstractSender {
 
-    private static final String TELEMETRY_ENDPOINT_NAME  = "telemetry";
+    private static final AtomicLong MESSAGE_COUNTER = new AtomicLong();
 
-    private TelemetrySenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
-            final String targetAddress, final Context context, final Handler<String> closeHook) {
-        super(config, sender, tenantId, targetAddress, context, closeHook);
+    TelemetrySenderImpl(final ClientConfigProperties config, final ProtonSender sender, final String tenantId,
+            final String targetAddress, final Context context) {
+        super(config, sender, tenantId, targetAddress, context);
     }
 
     /**
@@ -47,7 +53,8 @@ public final class TelemetrySenderImpl extends AbstractSender {
      * @throws NullPointerException if tenant is {@code null}.
      */
     public static String getTargetAddress(final String tenantId, final String deviceId) {
-        StringBuilder targetAddress = new StringBuilder(TELEMETRY_ENDPOINT_NAME).append("/").append(Objects.requireNonNull(tenantId));
+        StringBuilder targetAddress = new StringBuilder(TelemetryConstants.TELEMETRY_ENDPOINT)
+                .append("/").append(Objects.requireNonNull(tenantId));
         if (deviceId != null && deviceId.length() > 0) {
             targetAddress.append("/").append(deviceId);
         }
@@ -56,7 +63,7 @@ public final class TelemetrySenderImpl extends AbstractSender {
 
     @Override
     public String getEndpoint() {
-        return TELEMETRY_ENDPOINT_NAME;
+        return TelemetryConstants.TELEMETRY_ENDPOINT;
     }
 
     @Override
@@ -97,7 +104,39 @@ public final class TelemetrySenderImpl extends AbstractSender {
         final String targetAddress = getTargetAddress(tenantId, deviceId);
         createSender(context, clientConfig, con, targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook).compose(sender -> {
             return Future.<MessageSender> succeededFuture(
-                    new TelemetrySenderImpl(clientConfig, sender, tenantId, targetAddress, context, closeHook));
+                    new TelemetrySenderImpl(clientConfig, sender, tenantId, targetAddress, context));
         }).setHandler(creationHandler);
     }
+
+    @Override
+    protected Future<ProtonDelivery> sendMessage(final Message message) {
+
+        Objects.requireNonNull(message);
+
+        final String messageId = String.format("%s-%d", getClass().getSimpleName(), MESSAGE_COUNTER.getAndIncrement());
+        message.setMessageId(messageId);
+        final ProtonDelivery result = sender.send(message, deliveryUpdated -> {
+
+            if (deliveryUpdated.remotelySettled()) {
+                if (Accepted.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    LOG.trace("message [message ID: {}] accepted by peer", messageId);
+                } else if (Rejected.class.isInstance(deliveryUpdated.getRemoteState())) {
+                    Rejected remoteState = (Rejected) deliveryUpdated.getRemoteState();
+                    if (remoteState.getError() == null) {
+                        LOG.debug("message [message ID: {}] rejected by peer", messageId);
+                    } else {
+                        LOG.debug("message [message ID: {}] rejected by peer: {}, {}", messageId,
+                                remoteState.getError().getCondition(), remoteState.getError().getDescription());
+                    }
+                } else {
+                    LOG.debug("message [message ID: {}] not accepted by peer: {}", messageId, deliveryUpdated.getRemoteState());
+                }
+            } else {
+                LOG.warn("peer did not settle telemetry message [message ID: {}, remote state: {}]", messageId, deliveryUpdated.getRemoteState());
+            }
+        });
+        LOG.trace("sent telemetry message [ID: {}], remaining credit: {}, queued messages: {}", messageId, sender.getCredit(), sender.getQueued());
+
+        return Future.succeededFuture(result);
+    }
 }
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
new file mode 100644
index 000000000..9150cb870
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/EventSenderImplTest.java
@@ -0,0 +1,159 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+package org.eclipse.hono.client.impl;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.qpid.proton.amqp.messaging.Accepted;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * Tests verifying behavior of {@link EventSenderImpl}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class EventSenderImplTest {
+
+    private Context context;
+    private ClientConfigProperties config;
+    private ProtonSender sender;
+
+    /**
+     * Sets up the fixture.
+     */
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+
+        context = mock(Context.class);
+        doAnswer(invocation -> {
+            Handler<Void> handler = invocation.getArgumentAt(0, Handler.class);
+            handler.handle(null);
+            return null;
+        }).when(context).runOnContext(any(Handler.class));
+        config = new ClientConfigProperties();
+        sender = mock(ProtonSender.class);
+    }
+
+    /**
+     * Verifies that the sender waits for the peer to settle and
+     * accept a message before succeeding the returned future.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked" })
+    @Test
+    public void testSendMessageWaitsForAcceptedOutcome(final TestContext ctx) {
+
+        // GIVEN a sender that has credit
+        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
+        MessageSender messageSender = new EventSenderImpl(config, sender, "tenant", "telemetry/tenant", context);
+        final AtomicReference<Handler<ProtonDelivery>> handlerRef = new AtomicReference<>();
+        doAnswer(invocation -> {
+            handlerRef.set(invocation.getArgumentAt(1, Handler.class));
+            return mock(ProtonDelivery.class);
+        }).when(sender).send(any(Message.class), any(Handler.class));
+
+        // WHEN trying to send a message
+        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text", "token");
+
+        // THEN the message has been sent
+        // and the result is not completed yet
+        verify(sender).send(any(Message.class), eq(handlerRef.get()));
+        assertFalse(result.isComplete());
+
+        // until it gets accepted by the peer
+        ProtonDelivery accepted = mock(ProtonDelivery.class);
+        when(accepted.remotelySettled()).thenReturn(Boolean.TRUE);
+        when(accepted.getRemoteState()).thenReturn(new Accepted());
+        handlerRef.get().handle(accepted);
+
+        assertTrue(result.succeeded());
+    }
+
+    /**
+     * Verifies that the sender fails if the peer does not accept a message.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked" })
+    @Test
+    public void testSendMessageFailsForRejectedOutcome(final TestContext ctx) {
+
+        // GIVEN a sender that has credit
+        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
+        MessageSender messageSender = new EventSenderImpl(config, sender, "tenant", "telemetry/tenant", context);
+        final AtomicReference<Handler<ProtonDelivery>> handlerRef = new AtomicReference<>();
+        doAnswer(invocation -> {
+            handlerRef.set(invocation.getArgumentAt(1, Handler.class));
+            return mock(ProtonDelivery.class);
+        }).when(sender).send(any(Message.class), any(Handler.class));
+
+        // WHEN trying to send a message
+        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text", "token");
+
+        // THEN the message has been sent
+        // and the result is not completed yet
+        verify(sender).send(any(Message.class), eq(handlerRef.get()));
+        assertFalse(result.isComplete());
+
+        // and the result fails once the peer rejects the message
+        ProtonDelivery rejected = mock(ProtonDelivery.class);
+        when(rejected.remotelySettled()).thenReturn(Boolean.TRUE);
+        when(rejected.getRemoteState()).thenReturn(new Rejected());
+        handlerRef.get().handle(rejected);
+
+        assertFalse(result.succeeded());
+    }
+
+    /**
+     * Verifies that the sender fails if no credit is available.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testSendMessageFailsOnLackOfCredit(final TestContext ctx) {
+
+        // GIVEN a sender that has no credit
+        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
+        MessageSender messageSender = new EventSenderImpl(config, sender, "tenant", "telemetry/tenant", context);
+
+        // WHEN trying to send a message
+        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text", "token");
+
+        // THEN the message is not sent
+        assertFalse(result.succeeded());
+        verify(sender, never()).send(any(Message.class), any(Handler.class));
+    }
+
+}
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
new file mode 100644
index 000000000..3eaad1a26
--- /dev/null
+++ b/client/src/test/java/org/eclipse/hono/client/impl/TelemetrySenderImplTest.java
@@ -0,0 +1,120 @@
+/**
+ * Copyright (c) 2017 Bosch Software Innovations GmbH.
+ *
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ *
+ * Contributors:
+ *    Bosch Software Innovations GmbH - initial creation
+ */
+package org.eclipse.hono.client.impl;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.*;
+
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.message.Message;
+import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.config.ClientConfigProperties;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import io.vertx.core.Context;
+import io.vertx.core.Future;
+import io.vertx.core.Handler;
+import io.vertx.ext.unit.TestContext;
+import io.vertx.ext.unit.junit.VertxUnitRunner;
+import io.vertx.proton.ProtonDelivery;
+import io.vertx.proton.ProtonSender;
+
+/**
+ * Tests verifying behavior of {@link TelemetrySenderImpl}.
+ *
+ */
+@RunWith(VertxUnitRunner.class)
+public class TelemetrySenderImplTest {
+
+    private Context context;
+    private ClientConfigProperties config;
+    private ProtonSender sender;
+
+    /**
+     * Sets up the fixture.
+     */
+    @SuppressWarnings("unchecked")
+    @Before
+    public void setUp() {
+
+        context = mock(Context.class);
+        doAnswer(invocation -> {
+            Handler<Void> handler = invocation.getArgumentAt(0, Handler.class);
+            handler.handle(null);
+            return null;
+        }).when(context).runOnContext(any(Handler.class));
+        config = new ClientConfigProperties();
+        sender = mock(ProtonSender.class);
+    }
+
+    /**
+     * Verifies that the sender does not wait for the peer to settle and
+     * accept a message before succeeding.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings({ "unchecked" })
+    @Test
+    public void testSendMessageDoesNotWaitForAcceptedOutcome(final TestContext ctx) {
+
+        // GIVEN a sender that has credit
+        when(sender.sendQueueFull()).thenReturn(Boolean.FALSE);
+        MessageSender messageSender = new TelemetrySenderImpl(config, sender, "tenant", "telemetry/tenant", context);
+        final AtomicReference<Handler<ProtonDelivery>> handlerRef = new AtomicReference<>();
+        doAnswer(invocation -> {
+            handlerRef.set(invocation.getArgumentAt(1, Handler.class));
+            return mock(ProtonDelivery.class);
+        }).when(sender).send(any(Message.class), any(Handler.class));
+
+        // WHEN trying to send a message
+        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text", "token");
+        // which gets rejected by the peer
+        ProtonDelivery rejected = mock(ProtonDelivery.class);
+        when(rejected.remotelySettled()).thenReturn(Boolean.TRUE);
+        when(rejected.getRemoteState()).thenReturn(new Rejected());
+        handlerRef.get().handle(rejected);
+
+        // THEN the resulting future is succeeded nevertheless
+        assertTrue(result.succeeded());
+        // and the message has been sent
+        verify(sender).send(any(Message.class), eq(handlerRef.get()));
+    }
+
+    /**
+     * Verifies that the sender fails if no credit is available.
+     * 
+     * @param ctx The vert.x test context.
+     */
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testSendMessageFailsOnLackOfCredit(final TestContext ctx) {
+
+        // GIVEN a sender that has no credit
+        when(sender.sendQueueFull()).thenReturn(Boolean.TRUE);
+        MessageSender messageSender = new TelemetrySenderImpl(config, sender, "tenant", "telemetry/tenant", context);
+
+        // WHEN trying to send a message
+        final Future<ProtonDelivery> result = messageSender.send("device", "some payload", "application/text", "token");
+
+        // THEN the message is not sent
+        assertFalse(result.succeeded());
+        verify(sender, never()).send(any(Message.class), any(Handler.class));
+    }
+
+}
