diff --git a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
index 178e67081..e982ba726 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientImpl.java
@@ -17,12 +17,15 @@ import static java.net.HttpURLConnection.HTTP_OK;
 import static org.eclipse.hono.util.CredentialsConstants.OPERATION_GET;
 
 import java.io.IOException;
+import java.util.Objects;
 import java.util.UUID;
 
 import org.eclipse.hono.client.CredentialsClient;
 import org.eclipse.hono.util.CredentialsConstants;
 import org.eclipse.hono.util.CredentialsObject;
 import org.eclipse.hono.util.CredentialsResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
 
@@ -39,6 +42,7 @@ import io.vertx.proton.ProtonConnection;
  */
 public final class CredentialsClientImpl extends AbstractRequestResponseClient<CredentialsResult<CredentialsObject>> implements CredentialsClient {
 
+    private static Logger LOG = LoggerFactory.getLogger(CredentialsClientImpl.class);
     private static final ObjectMapper objectMapper = new ObjectMapper();
 
     private CredentialsClientImpl(final Context context, final String tenantId) {
@@ -70,6 +74,17 @@ public final class CredentialsClientImpl extends AbstractRequestResponseClient<C
         }
     }
 
+    /**
+     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Credentials API endpoint.
+     * 
+     * @param tenantId The tenant to upload data for.
+     * @return The target address.
+     * @throws NullPointerException if tenant is {@code null}.
+     */
+    public static String getTargetAddress(final String tenantId) {
+        return String.format("%s/%s", CredentialsConstants.CREDENTIALS_ENDPOINT, Objects.requireNonNull(tenantId));
+    }
+
     /**
      * Creates a new credentials client for a tenant.
      *
@@ -95,18 +110,21 @@ public final class CredentialsClientImpl extends AbstractRequestResponseClient<C
             final Handler<String> receiverCloseHook,
             final Handler<AsyncResult<CredentialsClient>> creationHandler) {
 
+        LOG.debug("creating new credentials client for [{}]", tenantId);
         final CredentialsClientImpl client = new CredentialsClientImpl(context, tenantId);
         client.createLinks(con, receiverPrefetchCredits, waitForInitialCredits, senderCloseHook, receiverCloseHook).setHandler(s -> {
             if (s.succeeded()) {
+                LOG.debug("successfully created credentials client for [{}]", tenantId);
                 creationHandler.handle(Future.succeededFuture(client));
             } else {
+                LOG.debug("failed to create credentials client for [{}]", tenantId, s.cause());
                 creationHandler.handle(Future.failedFuture(s.cause()));
             }
         });
     }
 
     @Override
-    public final void get(final String type, final String authId, final Handler<AsyncResult<CredentialsResult<CredentialsObject>>> resultHandler) {
+    public void get(final String type, final String authId, final Handler<AsyncResult<CredentialsResult<CredentialsObject>>> resultHandler) {
         JsonObject specification = new JsonObject().put(CredentialsConstants.FIELD_TYPE, type).put(CredentialsConstants.FIELD_AUTH_ID, authId);
         createAndSendRequest(OPERATION_GET, specification, resultHandler);
     }
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
index 28b264d39..98301deb7 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/HonoClientImpl.java
@@ -42,9 +42,8 @@ public final class HonoClientImpl implements HonoClient {
 
     private static final Logger LOG = LoggerFactory.getLogger(HonoClientImpl.class);
     private final Map<String, MessageSender> activeSenders = new ConcurrentHashMap<>();
-    private final Map<String, RegistrationClient> activeRegClients = new ConcurrentHashMap<>();
-    private final Map<String, CredentialsClient> activeCredClients = new ConcurrentHashMap<>();
-    private final Map<String, Boolean> senderCreationLocks = new ConcurrentHashMap<>();
+    private final Map<String, RequestResponseClient> activeRequestResponseClients = new ConcurrentHashMap<>();
+    private final Map<String, Boolean> creationLocks = new ConcurrentHashMap<>();
     private final List<Handler<Void>> creationRequests = new ArrayList<>();
     private final AtomicBoolean connecting = new AtomicBoolean(false);
     private final ConnectionFactory connectionFactory;
@@ -116,7 +115,7 @@ public final class HonoClientImpl implements HonoClient {
         result.put("name", connectionFactory.getName());
         result.put("connected", isConnected());
         result.put("server", String.format("%s:%d", connectionFactory.getHost(), connectionFactory.getPort()));
-        result.put("#regClients", activeRegClients.size());
+        result.put("#clients", activeRequestResponseClients.size());
         result.put("senders", getSenderStatus());
         return result;
     }
@@ -219,8 +218,7 @@ public final class HonoClientImpl implements HonoClient {
             LOG.debug("lost connection to server [{}:{}]", connectionFactory.getHost(), connectionFactory.getPort());
             connection.disconnect();
             activeSenders.clear();
-            activeRegClients.clear();
-            activeCredClients.clear();
+            activeRequestResponseClients.clear();
             failAllCreationRequests();
 
             if (nextHandler != null) {
@@ -281,17 +279,17 @@ public final class HonoClientImpl implements HonoClient {
         if (sender != null && sender.isOpen()) {
             LOG.debug("reusing existing message sender [target: {}, credit: {}]", key, sender.getCredit());
             resultHandler.handle(Future.succeededFuture(sender));
-        } else if (!senderCreationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
+        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
 
             // register a handler to be notified if the underlying connection to the server fails
             // so that we can fail the result handler passed in
             final Handler<Void> connectionFailureHandler = connectionLost -> {
                 // remove lock so that next attempt to open a sender doesn't fail
-                senderCreationLocks.remove(key);
+                creationLocks.remove(key);
                 resultHandler.handle(Future.failedFuture("connection to server lost"));
             };
             creationRequests.add(connectionFailureHandler);
-            senderCreationLocks.put(key, Boolean.TRUE);
+            creationLocks.put(key, Boolean.TRUE);
             LOG.debug("creating new message sender for {}", key);
 
             newSenderSupplier.accept(creationAttempt -> {
@@ -303,7 +301,7 @@ public final class HonoClientImpl implements HonoClient {
                     LOG.debug("failed to create new message sender for {}", key, creationAttempt.cause());
                     activeSenders.remove(key);
                 }
-                senderCreationLocks.remove(key);
+                creationLocks.remove(key);
                 creationRequests.remove(connectionFailureHandler);
                 resultHandler.handle(creationAttempt);
             });
@@ -450,37 +448,87 @@ public final class HonoClientImpl implements HonoClient {
         }
     }
 
+    /**
+     * Gets an existing or creates a new request-response client for a particular service.
+     * 
+     * @param key The key to look-up the client by.
+     * @param clientSupplier A consumer for an attempt to create a new client.
+     * @param resultHandler The handler to inform about the outcome of the operation.
+     */
+    void getOrCreateRequestResponseClient(
+            final String key, 
+            final Consumer<Handler<AsyncResult<RequestResponseClient>>> clientSupplier,
+            final Handler<AsyncResult<RequestResponseClient>> resultHandler) {
+
+        final RequestResponseClient client = activeRequestResponseClients.get(key);
+        if (client != null && client.isOpen()) {
+            LOG.debug("reusing existing client [target: {}]", key);
+            resultHandler.handle(Future.succeededFuture(client));
+        } else if (!creationLocks.computeIfAbsent(key, k -> Boolean.FALSE)) {
+
+            // register a handler to be notified if the underlying connection to the server fails
+            // so that we can fail the result handler passed in
+            final Handler<Void> connectionFailureHandler = connectionLost -> {
+                // remove lock so that next attempt to open a sender doesn't fail
+                creationLocks.remove(key);
+                resultHandler.handle(Future.failedFuture("connection to server lost"));
+            };
+            creationRequests.add(connectionFailureHandler);
+            creationLocks.put(key, Boolean.TRUE);
+            LOG.debug("creating new client for {}", key);
+
+            clientSupplier.accept(creationAttempt -> {
+                if (creationAttempt.succeeded()) {
+                    RequestResponseClient newClient = creationAttempt.result();
+                    LOG.debug("successfully created new client for {}", key);
+                    activeRequestResponseClients.put(key, newClient);
+                } else {
+                    LOG.debug("failed to create new client for {}", key, creationAttempt.cause());
+                    activeRequestResponseClients.remove(key);
+                }
+                creationLocks.remove(key);
+                creationRequests.remove(connectionFailureHandler);
+                resultHandler.handle(creationAttempt);
+            });
+
+        } else {
+            LOG.debug("already trying to create a client for {}", key);
+            resultHandler.handle(Future.failedFuture("request-response links not established yet"));
+        }
+    }
+
     @Override
     public HonoClient getOrCreateRegistrationClient(
             final String tenantId,
             final Handler<AsyncResult<RegistrationClient>> resultHandler) {
 
-        final RegistrationClient regClient = activeRegClients.get(Objects.requireNonNull(tenantId));
-        if (regClient != null && regClient.isOpen()) {
-            LOG.debug("reusing existing registration client for [{}]", tenantId);
-            resultHandler.handle(Future.succeededFuture(regClient));
-        } else {
-            createRegistrationClient(tenantId, resultHandler);
-        }
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(resultHandler);
+        getOrCreateRequestResponseClient(
+                RegistrationClientImpl.getTargetAddress(tenantId),
+                (creationResult) -> createRegistrationClient(tenantId, creationResult),
+                attempt -> {
+                    if (attempt.succeeded()) {
+                        resultHandler.handle(Future.succeededFuture((RegistrationClient) attempt.result()));
+                    } else {
+                        resultHandler.handle(Future.failedFuture(attempt.cause()));
+                    }
+                });
         return this;
     }
 
-    public HonoClient createRegistrationClient(
+    private void createRegistrationClient(
             final String tenantId,
-            final Handler<AsyncResult<RegistrationClient>> creationHandler) {
+            final Handler<AsyncResult<RequestResponseClient>> creationHandler) {
 
         Objects.requireNonNull(tenantId);
-        if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to server (yet)"));
-        } else {
-            // register a handler to be notified if the underlying connection to the server fails
-            // so that we can fail the result handler passed in
-            final Handler<Void> connectionFailureHandler = connectionLost -> {
-                creationHandler.handle(Future.failedFuture("connection to server lost"));
-            };
-            creationRequests.add(connectionFailureHandler);
+        Objects.requireNonNull(creationHandler);
+
+        Future<RequestResponseClient> clientTracker = Future.future();
+        clientTracker.setHandler(creationHandler);
+
+        checkConnection().compose(connected -> {
 
-            LOG.debug("creating new registration client for [{}]", tenantId);
             RegistrationClientImpl.create(
                     context,
                     connection,
@@ -493,44 +541,47 @@ public final class HonoClientImpl implements HonoClient {
                         if (creationAttempt.succeeded()) {
                             RegistrationClient registrationClient = creationAttempt.result();
                             registrationClient.setRequestTimeout(clientConfigProperties.getRequestTimeoutMillis());
-                            activeRegClients.put(tenantId, registrationClient);
-                            LOG.debug("successfully created registration client for [{}]", tenantId);
+                            clientTracker.complete(registrationClient);
                         } else {
-                            LOG.debug("failed to create registration client for [{}]", tenantId, creationAttempt.cause());
+                            clientTracker.fail(creationAttempt.cause());
                         }
-                        creationRequests.remove(connectionFailureHandler);
-                        creationHandler.handle(creationAttempt);
                     });
-        }
-        return this;
+        }, clientTracker);
     }
 
     @Override
-    public HonoClient getOrCreateCredentialsClient(final String tenantId, final Handler<AsyncResult<CredentialsClient>> resultHandler) {
-        final CredentialsClient credClient = activeCredClients.get(tenantId);
-        if (credClient != null && credClient.isOpen()) {
-            LOG.debug("reusing existing credentials client for [{}]", tenantId);
-            resultHandler.handle(Future.succeededFuture(credClient));
-        } else {
-            createCredentialsClient(tenantId, resultHandler);
-        }
+    public HonoClient getOrCreateCredentialsClient(
+            final String tenantId,
+            final Handler<AsyncResult<CredentialsClient>> resultHandler) {
+
+        Objects.requireNonNull(tenantId);
+        Objects.requireNonNull(resultHandler);
+        getOrCreateRequestResponseClient(
+                CredentialsClientImpl.getTargetAddress(tenantId),
+                (creationResult) -> createCredentialsClient(tenantId, creationResult),
+                attempt -> {
+                    if (attempt.succeeded()) {
+                        resultHandler.handle(Future.succeededFuture((CredentialsClient) attempt.result()));
+                    } else {
+                        resultHandler.handle(Future.failedFuture(attempt.cause()));
+                    }
+                });
         return this;
+
     }
 
-    public HonoClient createCredentialsClient(final String tenantId, final Handler<AsyncResult<CredentialsClient>> creationHandler) {
+    private void createCredentialsClient(
+            final String tenantId,
+            final Handler<AsyncResult<RequestResponseClient>> creationHandler) {
+
         Objects.requireNonNull(tenantId);
         Objects.requireNonNull(creationHandler);
-        if (connection == null || connection.isDisconnected()) {
-            creationHandler.handle(Future.failedFuture("client is not connected to server (yet)"));
-        } else {
-            // register a handler to be notified if the underlying connection to the server fails
-            // so that we can fail the result handler passed in
-            final Handler<Void> connectionFailureHandler = connectionLost -> {
-                creationHandler.handle(Future.failedFuture("connection to server lost"));
-            };
-            creationRequests.add(connectionFailureHandler);
 
-            LOG.debug("creating new credentials client for [{}]", tenantId);
+        Future<RequestResponseClient> clientTracker = Future.future();
+        clientTracker.setHandler(creationHandler);
+
+        checkConnection().compose(connected -> {
+
             CredentialsClientImpl.create(
                     context,
                     connection,
@@ -543,20 +594,17 @@ public final class HonoClientImpl implements HonoClient {
                         if (creationAttempt.succeeded()) {
                             CredentialsClient credentialsClient = creationAttempt.result();
                             credentialsClient.setRequestTimeout(clientConfigProperties.getRequestTimeoutMillis());
-                            activeCredClients.put(tenantId, credentialsClient);
-                            LOG.debug("successfully created credentials client for [{}]", tenantId);
+                            clientTracker.complete(credentialsClient);
                         } else {
-                            LOG.debug("failed to create credentials client for [{}]", tenantId, creationAttempt.cause());
+                            clientTracker.fail(creationAttempt.cause());
                         }
-                        creationRequests.remove(connectionFailureHandler);
-                        creationHandler.handle(creationAttempt);
                     });
-        }
-        return this;
+        }, clientTracker);
     }
 
     private void removeCredentialsClient(final String tenantId) {
-        CredentialsClient client = activeCredClients.remove(tenantId);
+        String key = CredentialsClientImpl.getTargetAddress(tenantId);
+        RequestResponseClient client = activeRequestResponseClients.remove(key);
         if (client != null) {
             client.close(s -> {});
             LOG.debug("closed and removed credentials client for [{}]", tenantId);
@@ -564,7 +612,8 @@ public final class HonoClientImpl implements HonoClient {
     }
 
     private void removeRegistrationClient(final String tenantId) {
-        RegistrationClient client = activeRegClients.remove(tenantId);
+        String key = RegistrationClientImpl.getTargetAddress(tenantId);
+        RequestResponseClient client = activeRequestResponseClients.remove(key);
         if (client != null) {
             client.close(s -> {});
             LOG.debug("closed and removed registration client for [{}]", tenantId);
diff --git a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
index 699361024..ceedbaf6a 100644
--- a/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
+++ b/client/src/main/java/org/eclipse/hono/client/impl/RegistrationClientImpl.java
@@ -16,12 +16,15 @@ import static org.eclipse.hono.util.RegistrationConstants.*;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import java.util.UUID;
 
 import org.eclipse.hono.client.RegistrationClient;
 import org.eclipse.hono.util.MessageHelper;
 import org.eclipse.hono.util.RegistrationConstants;
 import org.eclipse.hono.util.RegistrationResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import io.vertx.core.AsyncResult;
 import io.vertx.core.Context;
@@ -36,11 +39,24 @@ import io.vertx.proton.ProtonConnection;
  */
 public final class RegistrationClientImpl extends AbstractRequestResponseClient<RegistrationResult> implements RegistrationClient {
 
+    private static final Logger LOG = LoggerFactory.getLogger(RegistrationClientImpl.class);
+
     private RegistrationClientImpl(final Context context, final String tenantId) {
 
         super(context, tenantId);
     }
 
+    /**
+     * Gets the AMQP <em>target</em> address to use for sending requests to Hono's Device Registration API endpoint.
+     * 
+     * @param tenantId The tenant to upload data for.
+     * @return The target address.
+     * @throws NullPointerException if tenant is {@code null}.
+     */
+    public static String getTargetAddress(final String tenantId) {
+        return String.format("%s/%s", RegistrationConstants.REGISTRATION_ENDPOINT, Objects.requireNonNull(tenantId));
+    }
+
     @Override
     protected String getName() {
 
@@ -84,11 +100,14 @@ public final class RegistrationClientImpl extends AbstractRequestResponseClient<
             final Handler<String> receiverCloseHook,
             final Handler<AsyncResult<RegistrationClient>> creationHandler) {
 
+        LOG.debug("creating new registration client for [{}]", tenantId);
         final RegistrationClientImpl client = new RegistrationClientImpl(context, tenantId);
         client.createLinks(con, receiverPrefetchCredits, waitForInitialCredits, senderCloseHook, receiverCloseHook).setHandler(s -> {
             if (s.succeeded()) {
+                LOG.debug("successfully created registration client for [{}]", tenantId);
                 creationHandler.handle(Future.succeededFuture(client));
             } else {
+                LOG.debug("failed to create registration client for [{}]", tenantId, s.cause());
                 creationHandler.handle(Future.failedFuture(s.cause()));
             }
         });
diff --git a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
index 4a9eb0c93..007936af3 100644
--- a/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
+++ b/client/src/test/java/org/eclipse/hono/client/impl/HonoClientImplTest.java
@@ -20,6 +20,8 @@ import java.util.concurrent.TimeUnit;
 
 import org.eclipse.hono.client.HonoClient;
 import org.eclipse.hono.client.MessageSender;
+import org.eclipse.hono.client.RegistrationClient;
+import org.eclipse.hono.client.RequestResponseClient;
 import org.eclipse.hono.connection.ConnectionFactory;
 import org.eclipse.hono.util.Constants;
 import org.junit.After;
@@ -64,6 +66,71 @@ public class HonoClientImplTest {
             vertx.close(ctx.asyncAssertSuccess());
         }
     }
+    /**
+     * Verifies that a concurrent request to create a request-response client fails the given
+     * future for tracking the attempt.
+     * 
+     * @param ctx The helper to use for running async tests.
+     */
+    @Test
+    public void testGetOrCreateRequestResponseClientFailsIfInvokedConcurrently(final TestContext ctx) {
+
+        // GIVEN a client that already tries to create a registration client for "tenant"
+        ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        final Future<RequestResponseClient> firstClientTracker = Future.future();
+        client.getOrCreateRequestResponseClient("registration/tenant", handler -> {
+            firstClientTracker.setHandler(creationAttempt -> {
+                handler.handle(creationAttempt);
+            });
+        }, result -> {});
+
+        // WHEN an additional, concurrent attempt is made to create a client for "tenant"
+        final Async creationFailure = ctx.async();
+        client.getOrCreateRequestResponseClient("registration/tenant", handler -> {
+            handler.handle(Future.succeededFuture(mock(RegistrationClient.class)));
+        }, creationAttempt -> {
+            ctx.assertFalse(creationAttempt.succeeded());
+            creationFailure.complete();
+        });
+
+        // THEN the concurrent attempt fails immediately without any attempt being made to create another client
+        creationFailure.await(2000);
+
+        // succeed first creation attempt, thus invoking result handler
+        firstClientTracker.complete(mock(RegistrationClient.class));
+    }
+
+    /**
+     * Verifies that a request to create a request-response client is failed immediately when the
+     * underlying connection to the server fails.
+     * 
+     * @param ctx The Vertx test context.
+     */
+    @Test
+    public void testGetOrCreateRequestResponseClientFailsOnConnectionFailure(final TestContext ctx) {
+
+        // GIVEN a client that tries to create a registration client for "tenant"
+        ProtonConnection con = mock(ProtonConnection.class);
+        DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
+        final Async connected = ctx.async();
+        final Async disconnected = ctx.async();
+        HonoClientImpl client = new HonoClientImpl(vertx, connectionFactory);
+        client.connect(new ProtonClientOptions(), ctx.asyncAssertSuccess(ok -> connected.complete()));
+        connected.await(200);
+
+        client.getOrCreateRequestResponseClient("registration/tenant", creationResultHandler -> {
+            ctx.assertFalse(disconnected.isCompleted());
+        }, ctx.asyncAssertFailure(cause -> {
+            disconnected.complete();
+        }));
+
+        // WHEN the underlying connection fails
+        connectionFactory.getDisconnectHandler().handle(con);
+
+        // THEN all creation requests are failed
+        disconnected.await(200);
+    }
 
     /**
      * Verifies that a concurrent request to create a sender fails the given future for tracking the attempt.
@@ -108,7 +175,7 @@ public class HonoClientImplTest {
     @Test
     public void testGetOrCreateSenderFailsOnConnectionFailure(final TestContext ctx) {
 
-        // GIVEN a client that already tries to create a telemetry sender for "tenant"
+        // GIVEN a client that tries to create a telemetry sender for "tenant"
         ProtonConnection con = mock(ProtonConnection.class);
         DisconnectHandlerProvidingConnectionFactory connectionFactory = new DisconnectHandlerProvidingConnectionFactory(con);
         final Async connected = ctx.async();
