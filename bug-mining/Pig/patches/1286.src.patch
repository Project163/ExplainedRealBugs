diff --git a/CHANGES.txt b/CHANGES.txt
index 3f5fcd144..6863d9d9e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -28,6 +28,8 @@ PIG-3419: Pluggable Execution Engine (achalsoni81 via cheolsoo)
 
 IMPROVEMENTS
 
+PIG-3444: CONCAT with 2+ input parameters fail (lbendig via daijy)
+
 PIG-3529: Upgrade HBase dependency from 0.95-SNAPSHOT to 0.96 (jarcec via daijy)
 
 PIG-3117: A debug mode in which pig does not delete temporary files (ihadanny via cheolsoo)
diff --git a/src/org/apache/pig/EvalFunc.java b/src/org/apache/pig/EvalFunc.java
index 2757d044e..d0b83044e 100644
--- a/src/org/apache/pig/EvalFunc.java
+++ b/src/org/apache/pig/EvalFunc.java
@@ -89,6 +89,15 @@ public abstract class EvalFunc<T>  {
      */
     protected Type returnType;
 
+    /**
+     * EvalFunc's schema type.
+     * @see {@link EvalFunc#getSchemaType()}
+     */
+    public static enum SchemaType {
+        NORMAL, //default field type
+        VARARG //if the last field of the (udf) schema is of type vararg
+    };
+    
     public EvalFunc() {
         // Resolve concrete type for T of EvalFunc<T>
         // 1. Build map from type param to type for class hierarchy from current class to EvalFunc
@@ -320,4 +329,16 @@ public abstract class EvalFunc<T>  {
     public Schema getInputSchema(){
         return this.inputSchemaInternal;
     }
+
+    /**
+     * Returns the {@link SchemaType} of the EvalFunc. User defined functions can override
+     * this method to return {@link SchemaType#VARARG}. In this case the last FieldSchema
+     * added to the Schema in {@link #getArgToFuncMapping()} will be considered as a vararg field.
+     * 
+     * @return the schema type of the UDF
+     */
+    public SchemaType getSchemaType() {
+        return SchemaType.NORMAL;
+    }
+
 }
diff --git a/src/org/apache/pig/builtin/CONCAT.java b/src/org/apache/pig/builtin/CONCAT.java
index c1f2dd23f..99822b778 100644
--- a/src/org/apache/pig/builtin/CONCAT.java
+++ b/src/org/apache/pig/builtin/CONCAT.java
@@ -82,4 +82,9 @@ public class CONCAT extends EvalFunc<DataByteArray> {
         funcList.add(new FuncSpec(StringConcat.class.getName(), s));
         return funcList;
     }
+    
+    @Override
+    public SchemaType getSchemaType() {
+        return SchemaType.VARARG;
+    }
 }
diff --git a/src/org/apache/pig/builtin/StringConcat.java b/src/org/apache/pig/builtin/StringConcat.java
index 1a57d5676..0767c9d16 100644
--- a/src/org/apache/pig/builtin/StringConcat.java
+++ b/src/org/apache/pig/builtin/StringConcat.java
@@ -20,6 +20,7 @@ package org.apache.pig.builtin;
 import java.io.IOException;
 import org.apache.pig.EvalFunc;
 import org.apache.pig.PigException;
+import org.apache.pig.EvalFunc.SchemaType;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
@@ -57,5 +58,9 @@ public class StringConcat extends EvalFunc<String> {
     public Schema outputSchema(Schema input) {
         return new Schema(new Schema.FieldSchema(null, DataType.CHARARRAY)); 
     }
-   
+    
+    @Override
+    public SchemaType getSchemaType() {
+        return SchemaType.VARARG;
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
index 3ea5b6bec..7db1af4de 100644
--- a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
@@ -27,6 +27,7 @@ import java.util.List;
 import java.util.Map;
 
 import org.apache.pig.EvalFunc;
+import org.apache.pig.EvalFunc.SchemaType;
 import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
 import org.apache.pig.PigWarning;
@@ -709,6 +710,9 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             String msg = "Unable to get list of overloaded methods.";
             throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, e);
         }
+        
+        // EvalFunc's schema type
+        SchemaType udfSchemaType = ef.getSchemaType();
 
         /**
          * Here is an explanation of the way the matching UDF funcspec will be chosen
@@ -751,7 +755,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         if(funcSpecs!=null && funcSpecs.size()!=0){
             //Some function mappings found. Trying to see
             //if one of them fits the input schema
-            if((matchingSpec = exactMatch(funcSpecs, currentArgSchema, func))==null){
+            if((matchingSpec = exactMatch(funcSpecs, currentArgSchema, func, udfSchemaType))==null){
                 //Oops, no exact match found. Trying to see if we
                 //have mappings that we can fit using casts.
                 notExactMatch = true;
@@ -759,9 +763,9 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                     // try "exact" matching all other fields except the byte array
                     // fields and if they all exact match and we have only one candidate
                     // for the byte array cast then that's the matching one!
-                    if((matchingSpec = exactMatchWithByteArrays(funcSpecs, currentArgSchema, func))==null){
+                    if((matchingSpec = exactMatchWithByteArrays(funcSpecs, currentArgSchema, func, udfSchemaType))==null){
                         // "exact" match with byte arrays did not work - try best fit match
-                        if((matchingSpec = bestFitMatchWithByteArrays(funcSpecs, currentArgSchema, func)) == null) {
+                        if((matchingSpec = bestFitMatchWithByteArrays(funcSpecs, currentArgSchema, func, udfSchemaType)) == null) {
                             int errCode = 1045;
                             String msg = "Could not infer the matching function for "
                                 + func.getFuncSpec()
@@ -770,7 +774,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                             throw new TypeCheckerException(func, msg, errCode, PigException.INPUT);
                         }
                     }
-                } else if ((matchingSpec = bestFitMatch(funcSpecs, currentArgSchema)) == null) {
+                } else if ((matchingSpec = bestFitMatch(funcSpecs, currentArgSchema, udfSchemaType)) == null) {
                     // Either no byte arrays found or there are byte arrays
                     // but only one mapping exists.
                     // However, we could not find a match as there were either
@@ -801,7 +805,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             matchingSpec.setCtorArgs(func.getFuncSpec().getCtorArgs());
             }
             func.setFuncSpec(matchingSpec);
-            insertCastsForUDF(func, currentArgSchema, matchingSpec.getInputArgsSchema());
+            insertCastsForUDF(func, currentArgSchema, matchingSpec.getInputArgsSchema(), udfSchemaType);
 
         }
     }
@@ -816,18 +820,20 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      *            input schema
      * @param func -
      *             udf expression
+     * @param udfSchemaType - 
+     *            schema type of the udf
      * @return the funcSpec that supports the schema that is best suited to s.
      *         The best suited schema is one that has the lowest score as
      *         returned by fitPossible().
      * @throws VisitorException
      */
     private FuncSpec bestFitMatchWithByteArrays(List<FuncSpec> funcSpecs,
-            Schema s, UserFuncExpression func) throws VisitorException {
+            Schema s, UserFuncExpression func, SchemaType udfSchemaType) throws VisitorException {
                 List<Pair<Long, FuncSpec>> scoreFuncSpecList = new ArrayList<Pair<Long,FuncSpec>>();
         for (Iterator<FuncSpec> iterator = funcSpecs.iterator(); iterator
                 .hasNext();) {
             FuncSpec fs = iterator.next();
-            long score = fitPossible(s, fs.getInputArgsSchema());
+            long score = fitPossible(s, fs.getInputArgsSchema(), udfSchemaType);
             if (score != INF) {
                 scoreFuncSpecList.add(new Pair<Long, FuncSpec>(score, fs));
             }
@@ -926,14 +932,15 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      * @param funcSpecs - mappings provided by udf
      * @param s - input schema
      * @param func - UserFuncExpression for which matching is requested
+     * @param udfSchemaType - schema type of the udf
      * @return the matching spec if found else null
      * @throws FrontendException
      */
     private FuncSpec exactMatchWithByteArrays(List<FuncSpec> funcSpecs,
-            Schema s, UserFuncExpression func) throws FrontendException {
+            Schema s, UserFuncExpression func, SchemaType udfSchemaType) throws FrontendException {
         // exact match all fields except byte array fields
         // ignore byte array fields for matching
-        return exactMatchHelper(funcSpecs, s, func, true);
+        return exactMatchHelper(funcSpecs, s, func, udfSchemaType, true);
     }
 
     /**
@@ -943,13 +950,14 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      * @param funcSpecs - mappings provided by udf
      * @param s - input schema
      * @param func - UserFuncExpression for which matching is requested
+     * @param udfSchemaType - schema type of the user defined function
      * @return the matching spec if found else null
      * @throws FrontendException
      */
     private FuncSpec exactMatch(List<FuncSpec> funcSpecs, Schema s,
-            UserFuncExpression func) throws FrontendException {
+            UserFuncExpression func, SchemaType udfSchemaType) throws FrontendException {
         // exact match all fields, don't ignore byte array fields
-        return exactMatchHelper(funcSpecs, s, func, false);
+        return exactMatchHelper(funcSpecs, s, func, udfSchemaType, false);
     }
 
     /**
@@ -957,18 +965,19 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      * be obtained by inserting a set of casts to the input schema
      * @param funcSpecs - mappings provided by udf
      * @param s - input schema
+     * @param udfSchemaType - schema type of the udf
      * @return the funcSpec that supports the schema that is best suited
      *          to s. The best suited schema is one that has the
      *          lowest score as returned by fitPossible().
      */
-    private FuncSpec bestFitMatch(List<FuncSpec> funcSpecs, Schema s) {
+    private FuncSpec bestFitMatch(List<FuncSpec> funcSpecs, Schema s, SchemaType udfSchemaType) {
         FuncSpec matchingSpec = null;
         long score = INF;
         long prevBestScore = Long.MAX_VALUE;
         long bestScore = Long.MAX_VALUE;
         for (Iterator<FuncSpec> iterator = funcSpecs.iterator(); iterator.hasNext();) {
             FuncSpec fs = iterator.next();
-            score = fitPossible(s,fs.getInputArgsSchema());
+            score = fitPossible(s,fs.getInputArgsSchema(), udfSchemaType);
             if(score!=INF && score<=bestScore){
                 matchingSpec = fs;
                 prevBestScore = bestScore;
@@ -1037,18 +1046,19 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      * @param funcSpecs - mappings provided by udf
      * @param s - input schema
      * @param func user defined function
+     * @param udfSchemaType - schema type of the user defined function
      * @param ignoreByteArrays - flag for whether the exact match is to computed
      * after ignoring bytearray (if true) or without ignoring bytearray (if false)
      * @return the matching spec if found else null
      * @throws FrontendException
      */
     private FuncSpec exactMatchHelper(List<FuncSpec> funcSpecs, Schema s,
-            UserFuncExpression func, boolean ignoreByteArrays)
+            UserFuncExpression func, SchemaType udfSchemaType, boolean ignoreByteArrays)
     throws FrontendException {
         List<FuncSpec> matchingSpecs = new ArrayList<FuncSpec>();
         for (Iterator<FuncSpec> iterator = funcSpecs.iterator(); iterator.hasNext();) {
             FuncSpec fs = iterator.next();
-            if (schemaEqualsForMatching(s, fs.getInputArgsSchema(), ignoreByteArrays)) {
+            if (schemaEqualsForMatching(s, fs.getInputArgsSchema(), udfSchemaType, ignoreByteArrays)) {
                 matchingSpecs.add(fs);
 
             }
@@ -1087,7 +1097,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      * @throws FrontendException
      */
     public static boolean schemaEqualsForMatching(Schema inputSchema,
-            Schema udfSchema, boolean ignoreByteArrays) throws FrontendException {
+            Schema udfSchema, SchemaType udfSchemaType, boolean ignoreByteArrays) throws FrontendException {
 
 
         // If both of them are null, they are equal
@@ -1108,25 +1118,28 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         // fix that!
         udfSchema = Util.fixSchemaAddTupleInBag(udfSchema);
 
-
-        if (inputSchema.size() != udfSchema.size())
+        if ((udfSchemaType == SchemaType.NORMAL) && (inputSchema.size() != udfSchema.size()))
+            return false;
+        if ((udfSchemaType == SchemaType.VARARG) && inputSchema.size() < udfSchema.size())
             return false;
 
         Iterator<FieldSchema> i = inputSchema.getFields().iterator();
         Iterator<FieldSchema> j = udfSchema.getFields().iterator();
 
+        FieldSchema udfFieldSchema = null;
         while (i.hasNext()) {
 
             FieldSchema inputFieldSchema = i.next();
-            FieldSchema udfFieldSchema = j.next();
             if(inputFieldSchema == null)
                 return false;
 
-
+            //if there's no more UDF field: take the last one which is the vararg field
+            udfFieldSchema = j.hasNext() ? j.next() : udfFieldSchema;
+            
             if(ignoreByteArrays && inputFieldSchema.type == DataType.BYTEARRAY) {
                 continue;
             }
-
+            
             if (inputFieldSchema.type != udfFieldSchema.type) {
                 return false;
             }
@@ -1293,13 +1306,17 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
      * Unallowed casts are returned a dist of INFINITY.
      * @param s1
      * @param s2
+     * @param s2Type
      * @return
      */
-    private long fitPossible(Schema s1, Schema s2) {
+    private long fitPossible(Schema s1, Schema s2, SchemaType s2Type) {
         if(s1==null || s2==null) return INF;
         List<FieldSchema> sFields = s1.getFields();
         List<FieldSchema> fsFields = s2.getFields();
-        if(sFields.size()!=fsFields.size())
+        
+        if((s2Type == SchemaType.NORMAL) && (sFields.size()!=fsFields.size()))
+            return INF;
+        if((s2Type == SchemaType.VARARG) && (sFields.size() < fsFields.size()))
             return INF;
         long score = 0;
         int castCnt=0;
@@ -1315,8 +1332,10 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             // of this function
             if (sFS.type == DataType.BYTEARRAY)
                 continue;
-
-            FieldSchema fsFS = fsFields.get(i);
+            
+            //if we get to the vararg field (if defined) : take it repeatedly
+            FieldSchema fsFS = ((s2Type == SchemaType.VARARG) && i >= s2.size()) ? 
+                    fsFields.get(s2.size() - 1) : fsFields.get(i);
 
             if(DataType.isSchemaType(sFS.type)){
                 if(!FieldSchema.equals(sFS, fsFS, false, true))
@@ -1333,7 +1352,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         return score * castCnt;
     }
 
-    private void insertCastsForUDF(UserFuncExpression func, Schema fromSch, Schema toSch)
+    private void insertCastsForUDF(UserFuncExpression func, Schema fromSch, Schema toSch, SchemaType toSchType)
     throws FrontendException {
         List<FieldSchema> fsLst = fromSch.getFields();
         List<FieldSchema> tsLst = toSch.getFields();
@@ -1341,8 +1360,10 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         int i=-1;
         for (FieldSchema fFSch : fsLst) {
             ++i;
-            FieldSchema tFSch = tsLst.get(i);
-            if(fFSch.type==tFSch.type) {
+            //if we get to the vararg field (if defined) : take it repeatedly
+            FieldSchema tFSch = ((toSchType == SchemaType.VARARG) && i >= tsLst.size()) ? 
+                    tsLst.get(tsLst.size() - 1) : tsLst.get(i);
+            if (fFSch.type == tFSch.type) {
                 continue;
             }
             insertCast(func, Util.translateFieldSchema(tFSch), args.get(i));
diff --git a/test/org/apache/pig/parser/TestQueryParser.java b/test/org/apache/pig/parser/TestQueryParser.java
index 15f1481e7..4e5616752 100644
--- a/test/org/apache/pig/parser/TestQueryParser.java
+++ b/test/org/apache/pig/parser/TestQueryParser.java
@@ -486,6 +486,11 @@ public class TestQueryParser {
     
     @Test
     public void testFunction2() throws Exception {
+        shouldPass("B = foreach A generate org.apache.pig.builtin.CONCAT(b, c, 'x', 'y');");
+    }
+    
+    @Test
+    public void testFunction3() throws Exception {
         shouldPass("B = foreach A generate flatten(myudfs.Swap(name, age)), gpa;");
     }
     
diff --git a/test/org/apache/pig/test/TestBuiltin.java b/test/org/apache/pig/test/TestBuiltin.java
index 7784998ea..2290e4c5f 100644
--- a/test/org/apache/pig/test/TestBuiltin.java
+++ b/test/org/apache/pig/test/TestBuiltin.java
@@ -2191,6 +2191,34 @@ public class TestBuiltin {
         assertTrue(msg, res.equals(exp));
 
     }
+    
+    /**
+     * End-to-end testing of the CONCAT() builtin function for vararg parameters
+     * @throws Exception
+     */
+    @Test
+    public void testComplexMultiCONCAT() throws Exception {
+        String input = "vararg_concat_test_jira_3444.txt";
+        Util.createLocalInputFile(input, new String[]{"dummy"});
+        PigServer pigServer = new PigServer(ExecType.LOCAL);
+        pigServer.registerQuery("A = LOAD '"+input+"' as (x:chararray);");
+        
+        pigServer.registerQuery("B = foreach A generate CONCAT('a', CONCAT('b',CONCAT('c','d')));");
+        Iterator<Tuple> its = pigServer.openIterator("B");
+        Tuple t = its.next();
+        assertEquals("abcd",t.get(0));
+        
+        pigServer.registerQuery("B = foreach A generate CONCAT('a', 'b', 'c', 'd');");
+        its = pigServer.openIterator("B");
+        t = its.next();
+        assertEquals("abcd",t.get(0));
+        
+        pigServer.registerQuery("B = foreach A generate CONCAT('a', CONCAT('b','c'), 'd');");
+        its = pigServer.openIterator("B");
+        t = its.next();
+        assertEquals("abcd",t.get(0));
+        
+    }
 
     @Test
     public void testSIZE() throws Exception {
diff --git a/test/org/apache/pig/test/TestProjectStarRangeInUdf.java b/test/org/apache/pig/test/TestProjectStarRangeInUdf.java
index c95bc7f30..e46686fb4 100644
--- a/test/org/apache/pig/test/TestProjectStarRangeInUdf.java
+++ b/test/org/apache/pig/test/TestProjectStarRangeInUdf.java
@@ -86,17 +86,15 @@ public class TestProjectStarRangeInUdf  {
     }
 
     @Test
-    public void testProjStarExpandInForeach1Negative() throws IOException{
-        //star expansion gives 3 columns, so CONCAT(*) gives error
+    public void testProjStarExpandInForeach1Multi() throws IOException{
+        //star expansion gives 3 columns, CONCAT(*) should pass
         String query;
 
         query =
             "  l1 = load '" + INP_FILE_5FIELDS + "' as (a, b, c);"
             + "f = foreach l1 generate CONCAT(*) as ct;"
             ; 
-        Util.checkExceptionMessage(query, "f",
-                "Could not infer the matching function for " +
-                "org.apache.pig.builtin.CONCAT");
+        compileAndCompareSchema("ct : bytearray", query, "f");
     }
     
     @Test
diff --git a/test/org/apache/pig/test/TestUDF.java b/test/org/apache/pig/test/TestUDF.java
index 89b9e7610..2c3e08f37 100644
--- a/test/org/apache/pig/test/TestUDF.java
+++ b/test/org/apache/pig/test/TestUDF.java
@@ -211,6 +211,21 @@ public class TestUDF {
         pig.dumpSchema("c");
         pig.dumpSchema("d");
     }
+    
+    @Test
+    public void testEvalFuncGetVarArgToFunc() throws Exception {
+        String input = "udf_test_jira_3444.txt";
+        Util.createLocalInputFile(input, new String[]{"dummy"});
+        PigServer pigServer = new PigServer(ExecType.LOCAL);
+        pigServer.registerQuery("A = LOAD '"+input+"' USING PigStorage(',') AS (x:chararray);");
+        pigServer.registerQuery("B = FOREACH A GENERATE org.apache.pig.test.TestUDF$UdfWithFuncSpecWithVarArgs(3);");
+        pigServer.registerQuery("C = FOREACH A GENERATE org.apache.pig.test.TestUDF$UdfWithFuncSpecWithVarArgs(1,2,3,4);");
+
+        Iterator<Tuple> it = pigServer.openIterator("B");
+        assertEquals(Integer.valueOf(3),(Integer)it.next().get(0));
+        it = pigServer.openIterator("C");
+        assertEquals(Integer.valueOf(10), (Integer)it.next().get(0));
+    }
 
     @Test(expected = FrontendException.class)
     public void testEnsureProperSchema2() throws Exception {
@@ -272,4 +287,33 @@ public class TestUDF {
             return l;
         }
     }
+    
+    public static class UdfWithFuncSpecWithVarArgs extends EvalFunc<Integer> {
+        public UdfWithFuncSpecWithVarArgs() {}
+
+        @Override
+        public Integer exec(Tuple input) throws IOException {
+            int res = 0;
+            if (input == null || input.size() == 0) {
+                return res;
+            }
+            for (int i = 0; i < input.size(); i++) {
+                res += (Integer)input.get(i);
+            }
+            return res;
+        }
+        
+        @Override
+        public SchemaType getSchemaType() {
+            return SchemaType.VARARG;
+        }
+
+        @Override
+        public List<FuncSpec> getArgToFuncMapping() throws FrontendException {
+            List<FuncSpec> l = new ArrayList<FuncSpec>();
+            Schema s1 = new Schema(new Schema.FieldSchema(null,DataType.INTEGER));
+            l.add(new FuncSpec(this.getClass().getName(), s1));
+            return l;
+        }
+    }
 }
\ No newline at end of file
