diff --git a/CHANGES.txt b/CHANGES.txt
index b939da559..72f62f6c9 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -24,6 +24,8 @@ INCOMPATIBLE CHANGES
 
 IMPROVEMENTS
 
+PIG-693: Proposed improvements to pig's optimizer (sms)
+
 PIG-700: To automate the pig patch test process (gkesavan via sms)
 
 BUG FIXES
diff --git a/src/org/apache/pig/Main.java b/src/org/apache/pig/Main.java
index 04c05090e..941facd00 100644
--- a/src/org/apache/pig/Main.java
+++ b/src/org/apache/pig/Main.java
@@ -36,6 +36,7 @@ import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.logicalLayer.LogicalPlanBuilder;
 import org.apache.pig.impl.util.JarManager;
+import org.apache.pig.impl.util.ObjectSerializer;
 import org.apache.pig.impl.util.PropertiesUtil;
 import org.apache.pig.tools.cmdline.CmdLineParser;
 import org.apache.pig.tools.grunt.Grunt;
@@ -82,6 +83,7 @@ public static void main(String args[])
         boolean dryrun = false;
         ArrayList<String> params = new ArrayList<String>();
         ArrayList<String> paramFiles = new ArrayList<String>();
+        HashSet<String> optimizerRules = new HashSet<String>();
 
         CmdLineParser opts = new CmdLineParser(args);
         opts.registerOpt('4', "log4jconf", CmdLineParser.ValueExpected.REQUIRED);
@@ -91,16 +93,17 @@ public static void main(String args[])
         opts.registerOpt('e', "execute", CmdLineParser.ValueExpected.NOT_ACCEPTED);
         opts.registerOpt('f', "file", CmdLineParser.ValueExpected.REQUIRED);
         opts.registerOpt('h', "help", CmdLineParser.ValueExpected.NOT_ACCEPTED);
-        opts.registerOpt('o', "hod", CmdLineParser.ValueExpected.NOT_ACCEPTED);
-        opts.registerOpt('j', "jar", CmdLineParser.ValueExpected.REQUIRED);
-        opts.registerOpt('v', "verbose", CmdLineParser.ValueExpected.NOT_ACCEPTED);
-        opts.registerOpt('x', "exectype", CmdLineParser.ValueExpected.REQUIRED);
         opts.registerOpt('i', "version", CmdLineParser.ValueExpected.OPTIONAL);
-        opts.registerOpt('p', "param", CmdLineParser.ValueExpected.OPTIONAL);
+        opts.registerOpt('j', "jar", CmdLineParser.ValueExpected.REQUIRED);
+        opts.registerOpt('l', "logfile", CmdLineParser.ValueExpected.REQUIRED);
         opts.registerOpt('m', "param_file", CmdLineParser.ValueExpected.OPTIONAL);
+        opts.registerOpt('o', "hod", CmdLineParser.ValueExpected.NOT_ACCEPTED);
+        opts.registerOpt('p', "param", CmdLineParser.ValueExpected.OPTIONAL);
         opts.registerOpt('r', "dryrun", CmdLineParser.ValueExpected.NOT_ACCEPTED);
-        opts.registerOpt('l', "logfile", CmdLineParser.ValueExpected.REQUIRED);
+        opts.registerOpt('t', "optimizer_off", CmdLineParser.ValueExpected.REQUIRED);
+        opts.registerOpt('v', "verbose", CmdLineParser.ValueExpected.NOT_ACCEPTED);
         opts.registerOpt('w', "warning", CmdLineParser.ValueExpected.NOT_ACCEPTED);
+        opts.registerOpt('x', "exectype", CmdLineParser.ValueExpected.REQUIRED);
 
         ExecMode mode = ExecMode.UNKNOWN;
         String file = null;
@@ -162,6 +165,10 @@ public static void main(String args[])
                 usage();
                 return;
 
+            case 'i':
+            	System.out.println(getVersionString());
+            	return;
+
             case 'j': 
                 String jarsString = opts.getValStr();
                 if(jarsString != null){
@@ -205,6 +212,10 @@ public static void main(String args[])
                 // will be extended in the future
                 dryrun = true;
                 break;
+
+            case 't':
+            	optimizerRules.add(opts.getValStr());
+                break;
                             
             case 'v':
                 properties.setProperty(VERBOSE, ""+true);
@@ -222,9 +233,6 @@ public static void main(String args[])
                         throw new RuntimeException("ERROR: Unrecognized exectype.", e);
                     }
                 break;
-            case 'i':
-            	System.out.println(getVersionString());
-            	return;
             default: {
                 Character cc = new Character(opt);
                 throw new AssertionError("Unhandled option " + cc.toString());
@@ -241,6 +249,10 @@ public static void main(String args[])
         }
         
         pigContext.getProperties().setProperty("pig.logfile", logFileName);
+        
+        if(optimizerRules.size() > 0) {
+        	pigContext.getProperties().setProperty("pig.optimizer.rules", ObjectSerializer.serialize(optimizerRules));
+        }
 
         LogicalPlanBuilder.classloader = pigContext.createCl(null);
 
@@ -483,14 +495,21 @@ public static void usage()
     System.out.println("    -b, -brief brief logging (no timestamps)");
     System.out.println("    -c, -cluster clustername, kryptonite is default");
     System.out.println("    -d, -debug debug level, INFO is default");
+    System.out.println("    -e, -execute commands to execute (within quotes)");
+    System.out.println("    -f, -file path to the script to execute");
     System.out.println("    -h, -help display this message");
+    System.out.println("    -i, -version display version information");
     System.out.println("    -j, -jar jarfile load jarfile"); 
+    System.out.println("    -l, -logfile path to client side log file; current working directory is default");
+    System.out.println("    -m, -param_file path to the parameter file");
     System.out.println("    -o, -hod read hod server from system property ssh.gateway");
+    System.out.println("    -p, -param key value pair of the form param=val");
+    System.out.println("    -r, -dryrun CmdLineParser.ValueExpected.NOT_ACCEPTED");
+    System.out.println("    -t, -optimizer_off optimizer rule name, turn optimizer off for this rule; use all to turn all rules off, optimizer is turned on by default");
     System.out.println("    -v, -verbose print all error messages to screen");
-    System.out.println("    -x, -exectype local|mapreduce, mapreduce is default");
-    System.out.println("    -i, -version display version information");
-    System.out.println("    -l, -logfile path to client side log file; current working directory is default");
     System.out.println("    -w, -warning turn warning on; also turns warning aggregation off");
+    System.out.println("    -x, -exectype local|mapreduce, mapreduce is default");
+
 }
 
 private static String validateLogFile(String logFileName, String scriptName) {
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index a384c6929..bd18fb367 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -28,6 +28,7 @@ import java.util.Collection;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -64,6 +65,7 @@ import org.apache.pig.impl.plan.CompilationMessageCollector;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.CompilationMessageCollector.MessageType;
 import org.apache.pig.impl.streaming.StreamingCommand;
+import org.apache.pig.impl.util.ObjectSerializer;
 import org.apache.pig.impl.util.PropertiesUtil;
 import org.apache.pig.impl.logicalLayer.LODefine;
 import org.apache.pig.impl.logicalLayer.LOStore;
@@ -728,8 +730,6 @@ public class PigServer {
         PlanSetter ps = new PlanSetter(lpClone);
         ps.visit();
         
-        //(new SplitIntroducer(lp)).introduceImplSplits();
-        
         // run through validator
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         FrontendException caught = null;
@@ -758,8 +758,18 @@ public class PigServer {
 
         // optimize
         if (optimize) {
-            //LogicalOptimizer optimizer = new LogicalOptimizer(lpClone);
-            LogicalOptimizer optimizer = new LogicalOptimizer(lpClone, pigContext.getExecType());
+            HashSet<String> optimizerRules = null;
+            try {
+                optimizerRules = (HashSet<String>) ObjectSerializer
+                        .deserialize(pigContext.getProperties().getProperty(
+                                "pig.optimizer.rules"));
+            } catch (IOException ioe) {
+                int errCode = 2110;
+                String msg = "Unable to deserialize optimizer rules.";
+                throw new FrontendException(msg, errCode, PigException.BUG, ioe);
+            }
+
+            LogicalOptimizer optimizer = new LogicalOptimizer(lpClone, pigContext.getExecType(), optimizerRules);
             optimizer.optimize();
         }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
index 263f3d7e6..7cde1158c 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
@@ -17,14 +17,18 @@
  */
 package org.apache.pig.impl.logicalLayer.optimizer;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.util.Set;
 
 import org.apache.pig.ExecType;
+import org.apache.pig.impl.logicalLayer.LOLimit;
+import org.apache.pig.impl.logicalLayer.LOLoad;
+import org.apache.pig.impl.logicalLayer.LOPrinter;
+import org.apache.pig.impl.logicalLayer.LOStream;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
+import org.apache.pig.impl.plan.NodeIdGenerator;
+import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.optimizer.*;
 
 /**
@@ -33,8 +37,10 @@ import org.apache.pig.impl.plan.optimizer.*;
 public class LogicalOptimizer extends
         PlanOptimizer<LogicalOperator, LogicalPlan> {
 
-    public static final String LOLOAD_CLASSNAME = "org.apache.pig.impl.logicalLayer.LOLoad";
-    public static final String LOSTREAM_CLASSNAME = "org.apache.pig.impl.logicalLayer.LOStream";
+    private static final String SCOPE = "RULE";
+    private static NodeIdGenerator nodeIdGen = NodeIdGenerator.getGenerator();
+    
+    private Set<String> mRulesOff = null;
 
     public LogicalOptimizer(LogicalPlan plan) {
         this(plan, ExecType.MAPREDUCE);
@@ -44,8 +50,16 @@ public class LogicalOptimizer extends
         super(plan);
         runOptimizations(plan, mode);
     }
+    
+    public LogicalOptimizer(LogicalPlan plan, ExecType mode, Set<String> turnOffRules) {
+        super(plan);
+        mRulesOff = turnOffRules;
+        runOptimizations(plan, mode);
+    }
 
     private void runOptimizations(LogicalPlan plan, ExecType mode) {
+        RulePlan rulePlan;
+
         // List of rules for the logical optimizer
 
         // This one has to be first, as the type cast inserter expects the
@@ -54,49 +68,74 @@ public class LogicalOptimizer extends
         // it explicit. Since the RuleMatcher doesn't handle trees properly,
         // we cheat and say that we match any node. Then we'll do the actual
         // test in the transformers check method.
-        List<String> nodes = new ArrayList<String>(1);
-        Map<Integer, Integer> edges = new HashMap<Integer, Integer>();
-        List<Boolean> required = new ArrayList<Boolean>(1);
-        nodes.add("any");
-        required.add(true);
-        mRules.add(new Rule<LogicalOperator, LogicalPlan>(nodes, edges,
-                required, new ImplicitSplitInserter(plan)));
+        
+        boolean turnAllRulesOff = false;
+        if (mRulesOff != null) {
+            for (String rule : mRulesOff) {
+                if ("all".equalsIgnoreCase(rule)) {
+                    turnAllRulesOff = true;
+                    break;
+                }
+            }
+        }
+        
+        rulePlan = new RulePlan();
+        RuleOperator anyLogicalOperator = new RuleOperator(LogicalOperator.class, RuleOperator.NodeType.ANY_NODE, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(anyLogicalOperator);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                new ImplicitSplitInserter(plan), "ImplicitSplitInserter"));
 
         // Add type casting to plans where the schema has been declared (by
         // user, data, or data catalog).
-        nodes = new ArrayList<String>(1);
-        nodes.add(LOLOAD_CLASSNAME);
-        edges = new HashMap<Integer, Integer>();
-        required = new ArrayList<Boolean>(1);
-        required.add(true);
-        mRules.add(new Rule<LogicalOperator, LogicalPlan>(nodes, edges,
-                required, new TypeCastInserter(plan, LOLOAD_CLASSNAME)));
+        rulePlan = new RulePlan();
+        RuleOperator loLoad = new RuleOperator(LOLoad.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(loLoad);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                new TypeCastInserter(plan, LOLoad.class.getName()), "LoadTypeCastInserter"));
 
         // Add type casting to plans where the schema has been declared by
         // user in a statement with stream operator.
-        nodes = new ArrayList<String>(1);
-        nodes.add(LOSTREAM_CLASSNAME);
-        edges = new HashMap<Integer, Integer>();
-        required = new ArrayList<Boolean>(1);
-        required.add(true);
-        mRules.add(new Rule(nodes, edges, required, new TypeCastInserter(plan,
-                LOSTREAM_CLASSNAME)));
+        rulePlan = new RulePlan();
+        RuleOperator loStream= new RuleOperator(LOStream.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(loStream);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan, new TypeCastInserter(plan,
+                LOStream.class.getName()), "StreamTypeCastInserter"));
 
         // Optimize when LOAD precedes STREAM and the loader class
         // is the same as the serializer for the STREAM.
         // Similarly optimize when STREAM is followed by store and the
         // deserializer class is same as the Storage class.
-        mRules.add(new Rule(nodes, edges, required, new StreamOptimizer(plan,
-                LOSTREAM_CLASSNAME)));
+        if(!turnAllRulesOff) {
+            Rule rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan, new StreamOptimizer(plan,
+                    LOStream.class.getName()), "StreamOptimizer");
+            checkAndAddRule(rule);
+        }
 
         // Push up limit where ever possible.
-        nodes = new ArrayList<String>(1);
-        edges = new HashMap<Integer, Integer>();
-        required = new ArrayList<Boolean>(1);
-        nodes.add("org.apache.pig.impl.logicalLayer.LOLimit");
-        required.add(true);
-        mRules.add(new Rule<LogicalOperator, LogicalPlan>(nodes, edges,
-                required, new OpLimitOptimizer(plan, mode)));
+        if(!turnAllRulesOff) {
+            rulePlan = new RulePlan();
+            RuleOperator loLimit = new RuleOperator(LOLimit.class, 
+                    new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+            rulePlan.add(loLimit);
+            Rule rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                    new OpLimitOptimizer(plan, mode), "LimitOptimizer");
+            checkAndAddRule(rule);
+        }
+        
+    }
+
+    private void checkAndAddRule(Rule rule) {
+        if(mRulesOff != null) {
+            for(String ruleOff: mRulesOff) {
+                String ruleName = rule.getRuleName();
+                if(ruleName == null) continue;
+                if(ruleName.equalsIgnoreCase(ruleOff)) return;
+            }
+        }
+        mRules.add(rule);
     }
 
-}
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
index 3988cc090..20529174c 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
@@ -60,7 +60,7 @@ public class TypeCastInserter extends LogicalTransformer {
     }
 
     @Override
-    public boolean check(List<LogicalOperator> nodes) throws OptimizerException {
+    public boolean check(List<LogicalOperator> nodes) throws OptimizerException {       
         try {
             LogicalOperator op = getOperator(nodes);
             Schema s = op.getSchema();
@@ -70,7 +70,7 @@ public class TypeCastInserter extends LogicalTransformer {
             List<Schema.FieldSchema> fss = s.getFields();
             List<Byte> types = new ArrayList<Byte>(s.size());
             Schema determinedSchema = null;
-            if(operatorClassName == LogicalOptimizer.LOLOAD_CLASSNAME) {
+            if(LOLoad.class.getName().equals(operatorClassName)) {
                 determinedSchema = ((LOLoad)op).getDeterminedSchema();
             }
             for (int i = 0; i < fss.size(); i++) {
@@ -105,7 +105,7 @@ public class TypeCastInserter extends LogicalTransformer {
         }
         
         LogicalOperator lo = nodes.get(0);
-        if(operatorClassName == LogicalOptimizer.LOLOAD_CLASSNAME) {
+        if(LOLoad.class.getName().equals(operatorClassName)) {
             if (lo == null || !(lo instanceof LOLoad)) {
                 int errCode = 2005;
                 String msg = "Expected " + LOLoad.class.getSimpleName() + ", got " + lo.getClass().getSimpleName();
@@ -113,7 +113,7 @@ public class TypeCastInserter extends LogicalTransformer {
             }
     
             return lo;
-        } else if(operatorClassName == LogicalOptimizer.LOSTREAM_CLASSNAME){
+        } else if(LOStream.class.getName().equals(operatorClassName)){
             if (lo == null || !(lo instanceof LOStream)) {
                 int errCode = 2005;
                 String msg = "Expected " + LOStream.class.getSimpleName() + ", got " + lo.getClass().getSimpleName();
@@ -147,7 +147,7 @@ public class TypeCastInserter extends LogicalTransformer {
             // Note that in this case, the data coming out of the loader is not
             // a BYTEARRAY but is whatever determineSchema() says it is.
             Schema determinedSchema = null;
-            if(operatorClassName == LogicalOptimizer.LOLOAD_CLASSNAME) {
+            if(LOLoad.class.getName().equals(operatorClassName)) {
                 determinedSchema = ((LOLoad)lo).getDeterminedSchema();
             }
             for (int i = 0; i < s.size(); i++) {
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index 6bb0aa41b..ae4d25008 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -17,6 +17,8 @@
  */
 package org.apache.pig.impl.plan;
 
+import java.io.IOException;
+import java.io.OutputStream;
 import java.io.PrintStream;
 import java.io.Serializable;
 import java.util.ArrayList;
@@ -651,6 +653,12 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable, Seri
         }
     }
     
+    public void explain(
+            OutputStream out,
+            PrintStream ps) throws VisitorException, IOException {
+        PlanPrinter pp = new PlanPrinter(ps, this);
+        pp.print(out);
+    }
 
 
 }
diff --git a/src/org/apache/pig/impl/plan/PlanPrinter.java b/src/org/apache/pig/impl/plan/PlanPrinter.java
new file mode 100644
index 000000000..a58e12c5a
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/PlanPrinter.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.plan;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.io.PrintStream;
+import java.io.OutputStream;
+import java.io.IOException;
+import java.io.ByteArrayOutputStream;
+import java.util.Collection;
+import java.util.Collections;
+
+import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.plan.optimizer.RuleOperator;
+import org.apache.pig.impl.plan.optimizer.RulePlan;
+import org.apache.pig.impl.plan.optimizer.RulePlanVisitor;
+
+/**
+ * A visitor mechanism printing out the logical plan.
+ */
+public class PlanPrinter<O extends Operator, P extends OperatorPlan<O>> extends PlanVisitor<O, P> {
+
+    private PrintStream mStream = null;
+    private String TAB1 = "    ";
+    private String TABMore = "|   ";
+    private String LSep = "|\n|---";
+    private String USep = "|   |\n|   ";
+    private int levelCntr = -1;
+    private OutputStream printer;
+
+    /**
+     * @param ps PrintStream to output plan information to
+     * @param plan Logical plan to print
+     */
+    public PlanPrinter(PrintStream ps, P plan) {
+        //super(plan, new DependencyOrderWalker(plan));
+        super(plan, new DepthFirstWalker(plan));
+        mStream = ps;
+    }
+
+    @Override
+    public void visit() throws VisitorException {
+        try {
+            mStream.write(depthFirst().getBytes());
+        } catch (IOException e) {
+            throw new VisitorException(e);
+        }
+    }
+
+    public void print(OutputStream printer) throws VisitorException, IOException {
+        this.printer = printer;
+        printer.write(depthFirst().getBytes());
+    }
+
+
+    protected String depthFirst() throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder();
+        List<O> leaves = mPlan.getLeaves();
+        Collections.sort(leaves);
+        for (O leaf : leaves) {
+            sb.append(depthFirst(leaf));
+            sb.append("\n");
+        }
+        //sb.delete(sb.length() - "\n".length(), sb.length());
+        //sb.delete(sb.length() - "\n".length(), sb.length());
+        return sb.toString();
+    }
+    
+    private String planString(P plan) throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        if(plan!=null)
+            plan.explain(baos, mStream);
+        else
+            return "";
+        sb.append(USep);
+        sb.append(shiftStringByTabs(baos.toString(), 2));
+        return sb.toString();
+    }
+    
+    private String planString(
+            List<P> plans) throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder();
+        if(plans!=null)
+            for (P plan : plans) {
+                sb.append(planString(plan));
+            }
+        return sb.toString();
+    }
+
+    private String depthFirst(O node) throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder(node.name());
+        sb.append("\n");
+        
+        List<O> originalPredecessors =  mPlan.getPredecessors(node);
+        if (originalPredecessors == null)
+            return sb.toString();
+        
+        List<O> predecessors =  new ArrayList<O>(originalPredecessors);
+        
+        Collections.sort(predecessors);
+        int i = 0;
+        for (O pred : predecessors) {
+            i++;
+            String DFStr = depthFirst(pred);
+            if (DFStr != null) {
+                sb.append(LSep);
+                if (i < predecessors.size())
+                    sb.append(shiftStringByTabs(DFStr, 2));
+                else
+                    sb.append(shiftStringByTabs(DFStr, 1));
+            }
+        }
+        return sb.toString();
+    }
+
+    private String shiftStringByTabs(String DFStr, int TabType) {
+        StringBuilder sb = new StringBuilder();
+        String[] spl = DFStr.split("\n");
+
+        String tab = (TabType == 1) ? TAB1 : TABMore;
+
+        sb.append(spl[0] + "\n");
+        for (int i = 1; i < spl.length; i++) {
+            sb.append(tab);
+            sb.append(spl[i]);
+            sb.append("\n");
+        }
+        return sb.toString();
+    }
+
+    private void dispTabs() {
+        for (int i = 0; i < levelCntr; i++)
+            System.out.print(TAB1);
+    }
+}
+
+        
diff --git a/src/org/apache/pig/impl/plan/optimizer/CommonNodeFinder.java b/src/org/apache/pig/impl/plan/optimizer/CommonNodeFinder.java
new file mode 100644
index 000000000..4c84c38e2
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/optimizer/CommonNodeFinder.java
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.plan.optimizer;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.pig.impl.plan.DependencyOrderWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+public class CommonNodeFinder extends
+        RulePlanVisitor {
+
+    private List<RuleOperator> mCommonNodes = null;
+    
+    public CommonNodeFinder(RulePlan plan) {
+        super(plan, new DependencyOrderWalker<RuleOperator, RulePlan>(plan));
+    }
+    
+    public int getCount() {
+        return ((mCommonNodes == null) ? 0 : mCommonNodes.size());
+    }
+    
+    public List<RuleOperator> getCommonNodes() {
+        return mCommonNodes;
+    }
+    
+    private void reset() {
+        mCommonNodes = new ArrayList<RuleOperator>();
+    }
+
+    @Override
+    public void visit() throws VisitorException {
+        reset();
+        super.visit();
+    }
+    
+    /**
+     * @param ruleOp
+     *            the rule operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(RuleOperator ruleOp)
+            throws VisitorException {
+        /**
+         * A common node is a node that appears in the common path of two nodes in the rule plan
+         * Any node that has more than one predecessor is a common node
+         * Any node that has a predecessor which is a common node is a common node
+         * Any node that has more than one successor is a common node
+         */
+        if(ruleOp.getNodeType().equals(RuleOperator.NodeType.ANY_NODE)) {
+           return; 
+        }
+        List<RuleOperator> predecessors = mPlan.getPredecessors(ruleOp);
+        List<RuleOperator> successors = mPlan.getSuccessors(ruleOp);
+        
+        if(predecessors != null) {
+            if(predecessors.size() > 1) {
+                ruleOp.setNodeType(RuleOperator.NodeType.COMMON_NODE);
+                mCommonNodes.add(ruleOp);
+                return;
+            } else {
+                //has to be one predecessor
+                //check if the predecessor is a common node then this node is
+                //also a common node
+                RuleOperator ruleOperatorPredecessor = predecessors.get(0);
+                if(ruleOperatorPredecessor.getNodeType().equals(RuleOperator.NodeType.COMMON_NODE)) {
+                    ruleOp.setNodeType(RuleOperator.NodeType.COMMON_NODE);
+                    mCommonNodes.add(ruleOp);
+                    return;
+                }
+            }
+        }
+        
+        if(successors != null) {
+            if (successors.size() > 1) {
+                ruleOp.setNodeType(RuleOperator.NodeType.COMMON_NODE);
+                mCommonNodes.add(ruleOp);
+                return;
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java b/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
index 5644ebd76..0c192af72 100644
--- a/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
+++ b/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
@@ -22,6 +22,7 @@ import java.util.List;
 
 import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorPlan;
+import org.apache.pig.impl.plan.VisitorException;
 
 /******************************************************************************
  * A class to optimize plans.  This class need not be subclassed for a
@@ -34,15 +35,29 @@ public abstract class PlanOptimizer<O extends Operator, P extends OperatorPlan<O
     
     protected List<Rule> mRules;
     protected P mPlan;
+    protected int mMaxIterations;
 
     /**
      * @param plan Plan to optimize
      */
     protected PlanOptimizer(P plan) {
+        this(plan, 500);
+    }
+
+    /**
+     * @param plan Plan to optimize
+     * @param iterations maximum number of optimization iterations
+     */
+    protected PlanOptimizer(P plan, int iterations) {
         mRules = new ArrayList<Rule>();
         mPlan = plan;
+        if(iterations < 0) {
+            mMaxIterations = 1000;
+        } else {
+            mMaxIterations = iterations;
+        }
     }
-
+    
     /**
      * Run the optimizer.  This method attempts to match each of the Rules
      * against the plan.  If a Rule matches, it then calls the check
@@ -52,20 +67,26 @@ public abstract class PlanOptimizer<O extends Operator, P extends OperatorPlan<O
      * @throws OptimizerException
      */
     public final void optimize() throws OptimizerException {
-        RuleMatcher matcher = new RuleMatcher();
-        for (Rule rule : mRules) {
-            if (matcher.match(rule)) {
-                // It matches the pattern.  Now check if the transformer
-                // approves as well.
-                List<List<O>> matches = matcher.getAllMatches();
-                for (List<O> match:matches)
-                {
-	                if (rule.transformer.check(match)) {
-	                    // The transformer approves.
-	                    rule.transformer.transform(match);
-	                }
+        boolean sawMatch = false;
+        int numIterations = 0;
+        do {
+            sawMatch = false;
+            for (Rule rule : mRules) {
+                RuleMatcher matcher = new RuleMatcher();
+                if (matcher.match(rule)) {
+                    // It matches the pattern.  Now check if the transformer
+                    // approves as well.
+                    List<List<O>> matches = matcher.getAllMatches();
+                    for (List<O> match:matches)
+                    {
+    	                if (rule.getTransformer().check(match)) {
+    	                    // The transformer approves.
+    	                    sawMatch = true;
+    	                    rule.getTransformer().transform(match);
+    	                }
+                    }
                 }
             }
-        }
+        } while(sawMatch && ++numIterations < mMaxIterations);
     }
 }
diff --git a/src/org/apache/pig/impl/plan/optimizer/Rule.java b/src/org/apache/pig/impl/plan/optimizer/Rule.java
index f1be715a9..772b9163c 100644
--- a/src/org/apache/pig/impl/plan/optimizer/Rule.java
+++ b/src/org/apache/pig/impl/plan/optimizer/Rule.java
@@ -17,56 +17,70 @@
  */
 package org.apache.pig.impl.plan.optimizer;
 
-import java.util.List;
-import java.util.Map;
-
 import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorPlan;
 
 /**
- * A rule for optimizing a plan.  The rule contains a pattern that must be
- * matched in the plan before the optimizer can consider applying the rule
- * and a transformer to do further checks and possibly transform the plan.
- * The rule pattern is expressed as a list of node names, a map of edges in
- * the plan, and a list of boolean values indicating whether the node is
- * required.  For example, a rule pattern could be expressed as:
- * [Filter, Filter] {[0, 1]} [true, true], which would indicate this rule
- * matches two nodes of class name Filter, with an edge between the two,
- * and both are required.
+ * A rule for optimizing a plan. The rule contains a pattern that must be
+ * matched in the plan before the optimizer can consider applying the rule and a
+ * transformer to do further checks and possibly transform the plan. The rule
+ * pattern is expressed as a list of node names, a map of edges in the plan, and
+ * a list of boolean values indicating whether the node is required. For
+ * example, a rule pattern could be expressed as: [Filter, Filter] {[0, 1]}
+ * [true, true], which would indicate this rule matches two nodes of class name
+ * Filter, with an edge between the two, and both are required.
  */
 public class Rule<O extends Operator, P extends OperatorPlan<O>> {
 
-	public enum WalkerAlgo {DepthFirstWalker, DependencyOrderWalker};
-    public List<String> nodes;
-    public Map<Integer, Integer> edges;
-    public List<Boolean> required;
-    public Transformer<O, P> transformer;
-    public WalkerAlgo algo;
+    public enum WalkerAlgo {
+        DepthFirstWalker, DependencyOrderWalker
+    };
+
+    private RulePlan mRulePlan;
+    private Transformer<O, P> mTransformer;
+    private WalkerAlgo mWalkerAlgo;
+    private String mRuleName = null;
 
     /**
-     * @param n List of node types to look for.
-     * @param e Map of integers to integers.  Each integer
-     * represents the offset into nodes list.
-     * @param r List of boolean indicating whether given nodes are
-     * required for the pattern to match.
-     * @param t Transformer to apply if the rule matches.
-     * @param al Walker algorithm to find rule match within the plan.
+     * @param plan
+     *            pattern to look for
+     * @param t
+     *            Transformer to apply if the rule matches.
      */
-    public Rule(List<String> n,
-                Map<Integer, Integer> e, 
-                List<Boolean> r,
-                Transformer<O, P> t, WalkerAlgo al) {
-        nodes = n;
-        edges = e;
-        required = r;
-        transformer = t;
-        algo = al;
+    public Rule(RulePlan plan, Transformer<O, P> t, String ruleName) {
+        this(plan, t, ruleName, WalkerAlgo.DependencyOrderWalker);
+    }
+
+    /**
+     * @param plan
+     *            pattern to look for
+     * @param t
+     *            Transformer to apply if the rule matches.
+     * @param al
+     *            Walker algorithm to find rule match within the plan.
+     */
+    public Rule(RulePlan plan, Transformer<O, P> t, String ruleName,
+            WalkerAlgo al) {
+        mRulePlan = plan;
+        mTransformer = t;
+        mRuleName = ruleName;
+        mWalkerAlgo = al;
+    }
+
+    public RulePlan getPlan() {
+        return mRulePlan;
+    }
+
+    public Transformer<O, P> getTransformer() {
+        return mTransformer;
     }
-    
-    public Rule(List<String> n,
-                Map<Integer, Integer> e, 
-                List<Boolean> r,
-                Transformer<O, P> t) {
-    	this(n, e, r, t, WalkerAlgo.DependencyOrderWalker);
+
+    public String getRuleName() {
+        return mRuleName;
     }
-}
+
+    public WalkerAlgo getWalkerAlgo() {
+        return mWalkerAlgo;
+    }
+
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java b/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java
index 05d2f0149..15762894a 100644
--- a/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java
+++ b/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java
@@ -19,6 +19,7 @@ package org.apache.pig.impl.plan.optimizer;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -27,9 +28,12 @@ import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 
+import org.apache.pig.PigException;
 import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorPlan;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.plan.optimizer.RuleOperator.NodeType;
+import org.apache.pig.impl.util.Pair;
 
 /**
  * RuleMatcher contains the logic to determine whether a given rule matches.
@@ -41,25 +45,37 @@ import org.apache.pig.impl.plan.VisitorException;
 public class RuleMatcher<O extends Operator, P extends OperatorPlan<O>> {
 
     private Rule<O, P> mRule;
-    private List<O> mMatch;
+    private List<Pair<O, RuleOperator.NodeType>> mMatch;
+    private List<List<Pair<O, RuleOperator.NodeType>>> mPrelimMatches = new ArrayList<List<Pair<O, RuleOperator.NodeType>>>();
     private List<List<O>> mMatches = new ArrayList<List<O>>();
-    private P mPlan; // for convience.
-    Set<O> seen = new HashSet<O>();
+    private P mPlan; // for convenience.
+    private int mNumCommonNodes = 0;
+    private List<RuleOperator> mCommonNodes = null;
 
     /**
      * Test a rule to see if it matches the current plan. Save all matched nodes using BFS
      * @param rule Rule to test for a match.
      * @return true if the plan matches.
      */
-    public boolean match(Rule<O, P> rule) {
+    public boolean match(Rule<O, P> rule) throws OptimizerException {
         mRule = rule;
-        
-        mPlan = mRule.transformer.getPlan();
+        CommonNodeFinder commonNodeFinder = new CommonNodeFinder(mRule.getPlan());
+        try {
+            commonNodeFinder.visit();
+            mNumCommonNodes = commonNodeFinder.getCount();
+            mCommonNodes = commonNodeFinder.getCommonNodes();
+        } catch (VisitorException ve) {
+            int errCode = 2125;
+            String msg = "Internal error. Problem in computing common nodes in the Rule Plan.";
+            throw new OptimizerException(msg, errCode, PigException.BUG, ve);
+        }
+        mPlan = mRule.getTransformer().getPlan();
         mMatches.clear();
+        mPrelimMatches.clear();
         
-        if (mRule.algo == Rule.WalkerAlgo.DependencyOrderWalker)
+        if (mRule.getWalkerAlgo() == Rule.WalkerAlgo.DependencyOrderWalker)
         	DependencyOrderWalker();
-        else if (mRule.algo == Rule.WalkerAlgo.DepthFirstWalker)
+        else if (mRule.getWalkerAlgo() == Rule.WalkerAlgo.DepthFirstWalker)
         	DepthFirstWalker();        
         
         return (mMatches.size()!=0);
@@ -78,11 +94,181 @@ public class RuleMatcher<O extends Operator, P extends OperatorPlan<O>> {
         for (O op: fifo) {
         	if (beginMatch(op))
 			{
-        		mMatches.add(mMatch);
+        		mPrelimMatches.add(mMatch);
 			}
         }
+        
+        if(mPrelimMatches.size() > 0) {
+            processPreliminaryMatches();
+        }
     }
     
+    /**
+     * A method to compute the final matches
+     */
+    private void processPreliminaryMatches() {
+        //The preliminary matches contain paths that match
+        //the specification in the RulePlan. However, if there
+        //are twigs and DAGs, then a further computation is required
+        //to extract the nodes in the mPlan that correspond to the
+        //roots of the RulePlan
+        
+        //compute the number of common nodes in each preliminary match
+        
+        List<List<O>> commonNodesPerMatch = new ArrayList<List<O>>();
+        for(int i = 0; i < mPrelimMatches.size(); ++i) {
+            commonNodesPerMatch.add(getCommonNodesFromMatch(mPrelimMatches.get(i)));
+        }
+        
+        if(mNumCommonNodes == 0) {
+            //the rule plan had simple paths
+            
+            //verification step
+            //if any of the preliminary matches had common nodes 
+            //then its an anomaly
+            
+            for(int i = 0; i < commonNodesPerMatch.size(); ++i) {
+                if(commonNodesPerMatch.get(i) != null) {
+                    //we have found common nodes when there should be none
+                    //just return as mMatches will be empty
+                    return;
+                }
+            }
+            
+            //pick the first node of each match and put them into individual lists
+            //put the lists inside the list of lists mMatches
+            
+            for(int i = 0; i < mPrelimMatches.size(); ++i) {
+                List<O> match = new ArrayList<O>();
+                match.add(mPrelimMatches.get(i).get(0).first);
+                mMatches.add(match);
+            }
+            //all the matches have been computed for the simple path
+            return;
+        } else {
+            for(int i = 0; i < commonNodesPerMatch.size(); ++i) {
+                int commonNodes = (commonNodesPerMatch.get(i) == null? 0 : commonNodesPerMatch.get(i).size());
+                if(commonNodes != mNumCommonNodes) {
+                    //if there are is a mismatch in the common nodes then we have a problem
+                    //the rule plan states that we have mNumCommonNodes but we have commonNodes 
+                    //in the match. Just return
+                    
+                    return;
+                }
+            }
+        }
+        
+        //keep track of the matches that have been processed
+        List<Boolean> processedMatches = new ArrayList<Boolean>();
+        for(int i = 0; i < mPrelimMatches.size(); ++i) {
+            processedMatches.add(false);
+        }
+        
+        //a do while loop to handle single matches
+        int outerIndex = 0;
+        do {
+            
+            if(processedMatches.get(outerIndex)) {
+               ++outerIndex;
+               continue;
+            }
+            
+            List<Pair<O, RuleOperator.NodeType>> outerMatch = mPrelimMatches.get(outerIndex);
+            List<O> outerCommonNodes = commonNodesPerMatch.get(outerIndex);
+            Set<O> outerSetCommonNodes = new HashSet<O>(outerCommonNodes);
+            Set<O> finalIntersection = new HashSet<O>(outerCommonNodes);
+            Set<O> cumulativeIntersection = new HashSet<O>(outerCommonNodes);
+            List<O> patternMatchingRoots = new ArrayList<O>();
+            Set<O> unionOfRoots = new HashSet<O>();
+            boolean innerMatchProcessed = false;
+            unionOfRoots.add(outerMatch.get(0).first);
+            
+            
+            for(int innerIndex = outerIndex + 1; 
+                (innerIndex < mPrelimMatches.size()) && (!processedMatches.get(innerIndex)); 
+                ++innerIndex) {
+                List<Pair<O, RuleOperator.NodeType>> innerMatch = mPrelimMatches.get(innerIndex);
+                List<O> innerCommonNodes = commonNodesPerMatch.get(innerIndex);
+                Set<O> innerSetCommonNodes = new HashSet<O>(innerCommonNodes);
+                
+                //we need to compute the intersection of the common nodes
+                //the size of the intersection should be equal to the number
+                //of common nodes and the type of each rule node class
+                //if there is no match then it could be that we hit a match
+                //for a different path, i.e., another pattern that matched
+                //with a different set of nodes. In this case, we mark this
+                //match as not processed and move onto the next match
+                
+                outerSetCommonNodes.retainAll(innerSetCommonNodes);
+                
+                if(outerSetCommonNodes.size() != mNumCommonNodes) {
+                    //there was no match
+                    //continue to the next match
+                    continue;
+                } else {
+                    Set<O> tempCumulativeIntersection = new HashSet<O>(cumulativeIntersection);
+                    tempCumulativeIntersection.retainAll(outerSetCommonNodes);
+                    if(tempCumulativeIntersection.size() != mNumCommonNodes) {
+                        //problem - there was a set intersection with a size mismatch
+                        //between the cumulative intersection and the intersection of the
+                        //inner and outer common nodes 
+                        //set mMatches to empty and return
+                        mMatches = new ArrayList<List<O>>();
+                        return;
+                    } else {
+                        processedMatches.set(innerIndex, true);
+                        innerMatchProcessed = true;
+                        cumulativeIntersection = tempCumulativeIntersection;
+                        unionOfRoots.add(innerMatch.get(0).first);
+                    }
+                }
+            }
+            
+            cumulativeIntersection.retainAll(finalIntersection);
+            if(cumulativeIntersection.size() != mNumCommonNodes) {
+                //the cumulative and final intersections did not intersect
+                //this could happen when each of the matches are disjoint
+                //check if the innerMatches were processed at all
+                if(innerMatchProcessed) {
+                    //problem - the inner matches were processed and we did
+                    //not find common intersections
+                    mMatches = new ArrayList<List<O>>();
+                    return;
+                }
+            }
+            processedMatches.set(outerIndex, true);
+            for(O node: unionOfRoots) {
+                patternMatchingRoots.add(node);
+            }
+            mMatches.add(patternMatchingRoots);
+            ++outerIndex;
+        } while (outerIndex < mPrelimMatches.size() - 1);        
+    }
+
+    private List<O> getCommonNodesFromMatch(List<Pair<O, NodeType>> match) {
+        List<O> commonNodes = null;
+        //A lookup table to weed out duplicates
+        Map<O, Boolean> lookup = new HashMap<O, Boolean>();
+        for(int index = 0; index < match.size(); ++index) {
+            if(match.get(index).second.equals(RuleOperator.NodeType.COMMON_NODE)) {
+                if(commonNodes == null) {
+                    commonNodes = new ArrayList<O>();
+                }
+                O node = match.get(index).first;
+                //lookup the node under question
+                //if the node is not found in the table
+                //then we are examining it for the first time
+                //add it to the output list and mark it as seen
+                //else continue to the next iteration
+                if(lookup.get(node) == null) {
+                    commonNodes.add(node);
+                    lookup.put(node, true);
+                }
+            }
+        }
+        return commonNodes;
+    }
+
     private void BFSDoAllPredecessors(O node, Set<O> seen, Collection<O> fifo)  {
 		if (!seen.contains(node)) {
 		// We haven't seen this one before.
@@ -111,7 +297,7 @@ public class RuleMatcher<O extends Operator, P extends OperatorPlan<O>> {
         for (O suc : successors) {
             if (seen.add(suc)) {
             	if (beginMatch(suc))
-            		mMatches.add(mMatch);
+            		mPrelimMatches.add(mMatch);
                 Collection<O> newSuccessors = mPlan.getSuccessors(suc);
                 DFSVisit(suc, newSuccessors, seen);
             }
@@ -144,75 +330,83 @@ public class RuleMatcher<O extends Operator, P extends OperatorPlan<O>> {
     /*
      * This pattern matching is fairly simple and makes some important
      * assumptions.
-     * 1)  The pattern to be matched must be expressable as a simple list.  That
-     *     is it can match patterns like: 1->2, 2->3.  It cannot match patterns
-     *     like 1->2, 1->3.
-     * 2)  The pattern must always begin with the first node in the nodes array.
-     *     After that it can go where it wants.  So 1->3, 3->4 is legal.  A
-     *     pattern of 2->1 is not.
+     * 1)  The pattern to be matched must be expressible as a graph.
+     * 2)  The pattern must always begin with one of the root nodes in the rule plan.
+     *     After that it can go where it wants.
      *
      */
     private boolean beginMatch(O node) {
         if (node == null) return false;
         
-        int sz = mRule.nodes.size();
-        mMatch = new ArrayList<O>(sz);
-        // Add sufficient slots in the matches array
-        for (int i = 0; i < sz; i++) mMatch.add(null);
+        mMatch = new ArrayList<Pair<O, RuleOperator.NodeType>>();
         
-        List<O> successors = new ArrayList<O>();
-        if (node.getClass().getName().equals(mRule.nodes.get(0)) || 
-                mRule.nodes.get(0).equals("any")) {
-            mMatch.set(0, node);
-            // Follow the edge to see the next node we should be looking for.
-            Integer nextOpNum = mRule.edges.get(0);
-            if (nextOpNum == null) {
-                // This was looking for a single node
-                return true;
-            }
-            successors = mPlan.getSuccessors(node);
-            if (successors == null) return false;
-            for (O successorOp : successors) {
-                if (continueMatch(successorOp, nextOpNum)) return true;
+        List<O> nodeSuccessors;
+        List<RuleOperator> ruleRoots = mRule.getPlan().getRoots();
+        for(RuleOperator ruleRoot: ruleRoots) {
+            if (node.getClass().getName().equals(ruleRoot.getNodeClass().getName()) || 
+                    ruleRoot.getNodeType().equals(RuleOperator.NodeType.ANY_NODE)) {
+                mMatch.add(new Pair<O, RuleOperator.NodeType>(node, ruleRoot.getNodeType()));
+                // Follow the edge to see the next node we should be looking for.
+                List<RuleOperator> ruleRootSuccessors = mRule.getPlan().getSuccessors(ruleRoot);
+                if (ruleRootSuccessors == null) {
+                    // This was looking for a single node
+                    return true;
+                }
+                nodeSuccessors = mPlan.getSuccessors(node);
+                if ((nodeSuccessors == null) || (nodeSuccessors.size() != ruleRootSuccessors.size())) {
+                    //the ruleRoot has successors but the node does not
+                    //OR
+                    //the number of successors for the ruleRoot does not match 
+                    //the number of successors for the node
+                    return false; 
+                }
+                boolean foundMatch = false;
+                for (O nodeSuccessor : nodeSuccessors) {
+                    foundMatch |= continueMatch(nodeSuccessor, ruleRootSuccessors);
+                }
+                return foundMatch;
             }
         }
         // If we get here we haven't found it.
         return false;
     }
 
-    private boolean continueMatch(O current, Integer nodeNumber) {
-        if (current.getClass().getName().equals(mRule.nodes.get(nodeNumber)) || 
-                mRule.nodes.get(nodeNumber).equals("any")) {
-            mMatch.set(nodeNumber, current);
-
-            // Follow the edge to see the next node we should be looking for.
-            Integer nextOpNum = mRule.edges.get(nodeNumber);
-            if (nextOpNum == null) {
-                // We've comleted the match
-                return true;
-            }
-            List<O> successors = new ArrayList<O>();
-            successors = mPlan.getSuccessors(current);
-            if (successors == null) return false;
-            for (O successorOp : successors) {
-                if (continueMatch(successorOp, nextOpNum)) return true;
-            }
-        } else if (!mRule.required.get(nodeNumber)) {
-            // This node was optional, so it's okay if we don't match, keep
-            // going anyway.  Keep looking for the current node (don't find our
-            // successors, but look for the next edge.
-            Integer nextOpNum = mRule.edges.get(nodeNumber);
-            if (nextOpNum == null) {
-                // We've comleted the match
-                return true;
+    private boolean continueMatch(O node, List<RuleOperator> ruleOperators) {
+        for(RuleOperator ruleOperator: ruleOperators) {
+            if (node.getClass().getName().equals(ruleOperator.getNodeClass().getName()) || 
+                    ruleOperator.getNodeType().equals(RuleOperator.NodeType.ANY_NODE)) {
+                mMatch.add(new Pair<O, RuleOperator.NodeType>(node,ruleOperator.getNodeType()));
+    
+                // Follow the edge to see the next node we should be looking for.
+                List<RuleOperator> ruleOperatorSuccessors = mRule.getPlan().getSuccessors(ruleOperator);
+                if (ruleOperatorSuccessors == null) {
+                    // We've completed the match
+                    return true;
+                }
+                List<O> nodeSuccessors;
+                nodeSuccessors = mPlan.getSuccessors(node);
+                if ((nodeSuccessors == null) || 
+                        (nodeSuccessors.size() != ruleOperatorSuccessors.size())) {
+                    //the ruleOperator has successors but the node does not
+                    //OR
+                    //the number of successors for the ruleOperator does not match 
+                    //the number of successors for the node
+                    return false;
+                }
+                boolean foundMatch = false;
+                for (O nodeSuccessor : nodeSuccessors) {
+                    foundMatch |= continueMatch(nodeSuccessor, ruleOperatorSuccessors);
+                }
+                return foundMatch;
             }
-            if (continueMatch(current, nextOpNum)) return true;
+    
+            // We can arrive here either because we didn't match at this node or
+            // further down the line.  One way or another we need to remove ourselves
+            // from the match vector and return false.
+            //SMS - I don't think we need this as mMatch will be discarded anyway
+            //mMatch.set(nodeNumber, null);
+            return false;
         }
-
-        // We can arrive here either because we didn't match at this node or
-        // further down the line.  One way or another we need to remove ourselves
-        // from the match vector and return false.
-        mMatch.set(nodeNumber, null);
         return false;
     }
 
diff --git a/src/org/apache/pig/impl/plan/optimizer/RuleOperator.java b/src/org/apache/pig/impl/plan/optimizer/RuleOperator.java
new file mode 100644
index 000000000..8d78f48c1
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/optimizer/RuleOperator.java
@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.impl.plan.optimizer;
+
+import org.apache.pig.impl.plan.Operator;
+import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.VisitorException;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
+
+/**
+ * Parent for all Logical operators.
+ */
+public class RuleOperator extends Operator<RulePlanVisitor> {
+    private static final long serialVersionUID = 2L;
+
+    private static Log log = LogFactory.getLog(RuleOperator.class);
+    
+    public enum NodeType {
+        ANY_NODE,
+        SIMPLE_NODE,
+        MULTI_NODE,
+        COMMON_NODE;
+    }
+
+    private Class mNodeClass;
+    private NodeType mNodeType = NodeType.SIMPLE_NODE;
+    
+    /**
+     * @param clazz
+     *            Class type of this node, e.g.: LOFilter.class
+     * @param k
+     *            Operator key to assign to this node.
+     */
+    public RuleOperator(Class clazz, OperatorKey k) {
+        super(k);
+        mNodeClass = clazz;
+    }
+
+    /**
+     * @param clazz
+     *            Class type of this node, e.g.: LOFilter.class
+     * @param nodeType
+     *            Node type of this node             
+     * @param k
+     *            Operator key to assign to this node.
+     */
+    public RuleOperator(Class clazz, NodeType nodeType, OperatorKey k) {
+        super(k);
+        mNodeType = nodeType;
+        mNodeClass = clazz;
+    }
+    
+    /**
+     * Set the node type of this rule operator.
+     * 
+     * @param type 
+     *            Node type to set this operator to.
+     */
+    final public void setNodeType(NodeType type) {
+        mNodeType = type;
+    }
+
+    /**
+     * Get the node type of this operator.
+     */
+    public NodeType getNodeType() {
+        return mNodeType;
+    }
+
+    /**
+     * Get the node class of this operator.
+     */
+    public Class getNodeClass() {
+        return mNodeClass;
+    }
+
+    @Override
+    public String toString() {
+        return name();
+    }
+
+    /**
+     * Visit this node with the provided visitor. This should only be called by
+     * the visitor class itself, never directly.
+     * 
+     * @param v
+     *            Visitor to visit with.
+     * @throws VisitException
+     *             if the visitor has a problem.
+     */
+    public void visit(RulePlanVisitor v) throws VisitorException {
+        v.visit(this);
+    }
+
+    @Override
+    public boolean supportsMultipleOutputs() {
+        return true;
+    }
+
+    @Override
+    public boolean supportsMultipleInputs() {
+        return true;
+    }
+
+    /**
+     * @see org.apache.pig.impl.plan.Operator#clone()
+     * Do not use the clone method directly. Operators are cloned when logical plans
+     * are cloned using {@link LogicalPlanCloner}
+     */
+    @Override
+    protected Object clone() throws CloneNotSupportedException {
+        RuleOperator ruleOpClone = (RuleOperator)super.clone();
+        return ruleOpClone;
+    }
+
+    @Override
+    public String name() {
+        StringBuffer msg = new StringBuffer();
+        msg.append("(Name: " + mNodeClass.getSimpleName() + " Node Type: " + mNodeType + "[" + this.mKey + "]" + ")");
+        return msg.toString();
+    }
+
+}
diff --git a/src/org/apache/pig/impl/plan/optimizer/RulePlan.java b/src/org/apache/pig/impl/plan/optimizer/RulePlan.java
new file mode 100644
index 000000000..42629e46c
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/optimizer/RulePlan.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.plan.optimizer;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Collection;
+
+import org.apache.pig.impl.plan.OperatorPlan;
+import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.plan.PlanException;
+
+public class RulePlan extends OperatorPlan<RuleOperator> {
+    private static final long serialVersionUID = 2L;
+
+    public RulePlan() {
+        super();
+    }
+
+    public void explain(
+            OutputStream out,
+            PrintStream ps) throws VisitorException, IOException {
+        RulePlanPrinter rpp = new RulePlanPrinter(ps, this);
+
+        rpp.print(out);
+    }
+    
+    /**
+     * Do not use the clone method directly. Use {@link LogicalPlanCloner} instead.
+     */
+/*    @Override
+    public RulePlan clone() throws CloneNotSupportedException {
+        RulePlan clone = new RulePlan();
+
+        // Get all the nodes in this plan, and clone them.  As we make
+        // clones, create a map between clone and original.  Then walk the
+        // connections in this plan and create equivalent connections in the
+        // clone.
+        Map<RuleOperator, RuleOperator> matches = 
+            //new HashMap<LogicalOperator, LogicalOperator>(mOps.size());
+            LogicalPlanCloneHelper.mOpToCloneMap;
+        for (RuleOperator op : mOps.keySet()) {
+            try {
+            RuleOperator c = (RuleOperator)op.clone();
+            clone.add(c);
+            matches.put(op, c);
+            } catch (CloneNotSupportedException cnse) {
+                cnse.printStackTrace();
+                throw cnse;
+            }
+        }
+
+        // Build the edges
+        for (RuleOperator op : mToEdges.keySet()) {
+            RuleOperator cloneTo = matches.get(op);
+            if (cloneTo == null) {
+                String msg = new String("Unable to find clone for op "
+                    + op.name());
+                log.error(msg);
+                throw new RuntimeException(msg);
+            }
+            Collection<RuleOperator> fromOps = mToEdges.get(op);
+            for (RuleOperator fromOp : fromOps) {
+                RuleOperator cloneFrom = matches.get(fromOp);
+                if (cloneFrom == null) {
+                    String msg = new String("Unable to find clone for op "
+                        + fromOp.name());
+                    log.error(msg);
+                    throw new RuntimeException(msg);
+                }
+                try {
+                    clone.connect(cloneFrom, cloneTo);
+                } catch (PlanException pe) {
+                    throw new RuntimeException(pe);
+                }
+            }
+        }
+
+        return clone;
+    }
+*/    
+}
diff --git a/src/org/apache/pig/impl/plan/optimizer/RulePlanPrinter.java b/src/org/apache/pig/impl/plan/optimizer/RulePlanPrinter.java
new file mode 100644
index 000000000..75f26fcf7
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/optimizer/RulePlanPrinter.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.plan.optimizer;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.io.PrintStream;
+import java.io.OutputStream;
+import java.io.IOException;
+import java.io.ByteArrayOutputStream;
+import java.util.Collection;
+import java.util.Collections;
+
+import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.DependencyOrderWalker;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor mechanism printing out the logical plan.
+ */
+public class RulePlanPrinter extends RulePlanVisitor {
+
+    private PrintStream mStream = null;
+    private String TAB1 = "    ";
+    private String TABMore = "|   ";
+    private String LSep = "|\n|---";
+    private String USep = "|   |\n|   ";
+    private int levelCntr = -1;
+    private OutputStream printer;
+
+    /**
+     * @param ps PrintStream to output plan information to
+     * @param plan Logical plan to print
+     */
+    public RulePlanPrinter(PrintStream ps, RulePlan plan) {
+        //super(plan, new DependencyOrderWalker(plan));
+        super(plan, new DepthFirstWalker(plan));
+        mStream = ps;
+    }
+
+    @Override
+    public void visit() throws VisitorException {
+        try {
+            mStream.write(depthFirst().getBytes());
+        } catch (IOException e) {
+            throw new VisitorException(e);
+        }
+    }
+
+    public void print(OutputStream printer) throws VisitorException, IOException {
+        this.printer = printer;
+        printer.write(depthFirst().getBytes());
+    }
+
+
+    protected String depthFirst() throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder();
+        List<RuleOperator> leaves = mPlan.getLeaves();
+        Collections.sort(leaves);
+        for (RuleOperator leaf : leaves) {
+            sb.append(depthFirst(leaf));
+            sb.append("\n");
+        }
+        //sb.delete(sb.length() - "\n".length(), sb.length());
+        //sb.delete(sb.length() - "\n".length(), sb.length());
+        return sb.toString();
+    }
+    
+    private String planString(RulePlan rulePlan) throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        if(rulePlan!=null)
+            rulePlan.explain(baos, mStream);
+        else
+            return "";
+        sb.append(USep);
+        sb.append(shiftStringByTabs(baos.toString(), 2));
+        return sb.toString();
+    }
+    
+    private String planString(
+            List<RulePlan> rulePlans) throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder();
+        if(rulePlans!=null)
+            for (RulePlan rulePlan : rulePlans) {
+                sb.append(planString(rulePlan));
+            }
+        return sb.toString();
+    }
+
+    private String depthFirst(RuleOperator node) throws VisitorException, IOException {
+        StringBuilder sb = new StringBuilder(node.name());
+        sb.append("\n");
+        
+        List<RuleOperator> originalPredecessors =  mPlan.getPredecessors(node);
+        if (originalPredecessors == null)
+            return sb.toString();
+        
+        List<RuleOperator> predecessors =  new ArrayList<RuleOperator>(originalPredecessors);
+        
+        Collections.sort(predecessors);
+        int i = 0;
+        for (RuleOperator pred : predecessors) {
+            i++;
+            String DFStr = depthFirst(pred);
+            if (DFStr != null) {
+                sb.append(LSep);
+                if (i < predecessors.size())
+                    sb.append(shiftStringByTabs(DFStr, 2));
+                else
+                    sb.append(shiftStringByTabs(DFStr, 1));
+            }
+        }
+        return sb.toString();
+    }
+
+    private String shiftStringByTabs(String DFStr, int TabType) {
+        StringBuilder sb = new StringBuilder();
+        String[] spl = DFStr.split("\n");
+
+        String tab = (TabType == 1) ? TAB1 : TABMore;
+
+        sb.append(spl[0] + "\n");
+        for (int i = 1; i < spl.length; i++) {
+            sb.append(tab);
+            sb.append(spl[i]);
+            sb.append("\n");
+        }
+        return sb.toString();
+    }
+
+    private void dispTabs() {
+        for (int i = 0; i < levelCntr; i++)
+            System.out.print(TAB1);
+    }
+}
+
+        
diff --git a/src/org/apache/pig/impl/plan/optimizer/RulePlanVisitor.java b/src/org/apache/pig/impl/plan/optimizer/RulePlanVisitor.java
new file mode 100644
index 000000000..b35ecb7f1
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/optimizer/RulePlanVisitor.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.plan.optimizer;
+
+import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.PlanWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+abstract public class RulePlanVisitor extends
+        PlanVisitor<RuleOperator, RulePlan> {
+
+    public RulePlanVisitor(RulePlan plan,
+                     PlanWalker<RuleOperator, RulePlan> walker) {
+        super(plan, walker);
+    }
+
+    /**
+     * @param ruleOp
+     *            the rule operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(RuleOperator ruleOp)
+            throws VisitorException {
+        //
+        // Do Nothing
+        //
+    }
+
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java b/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java
index a4513e4a5..83691b6b6 100644
--- a/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java
+++ b/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java
@@ -23,25 +23,34 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.pig.impl.logicalLayer.LOLoad;
+import org.apache.pig.impl.logicalLayer.LOStream;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
 import org.apache.pig.impl.logicalLayer.optimizer.ImplicitSplitInserter;
 import org.apache.pig.impl.logicalLayer.optimizer.OpLimitOptimizer;
 import org.apache.pig.impl.logicalLayer.optimizer.StreamOptimizer;
 import org.apache.pig.impl.logicalLayer.optimizer.TypeCastInserter;
+import org.apache.pig.impl.plan.NodeIdGenerator;
+import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.optimizer.PlanOptimizer;
 import org.apache.pig.impl.plan.optimizer.Rule;
+import org.apache.pig.impl.plan.optimizer.RuleOperator;
+import org.apache.pig.impl.plan.optimizer.RulePlan;
+import org.apache.pig.impl.util.MultiMap;
 
 //This optimiser puts in the bare minimum modifications needed to make sure the plan is functional
 public class FunctionalLogicalOptimizer extends
         PlanOptimizer<LogicalOperator, LogicalPlan> {
 
-    public static final String LOLOAD_CLASSNAME = "org.apache.pig.impl.logicalLayer.LOLoad";
-    public static final String LOSTREAM_CLASSNAME = "org.apache.pig.impl.logicalLayer.LOStream";
-
+    private static final String SCOPE = "RULE";
+    private static NodeIdGenerator nodeIdGen = NodeIdGenerator.getGenerator();
+    
     public FunctionalLogicalOptimizer(LogicalPlan plan) {
         super(plan);
 
+        RulePlan rulePlan;        
+
         // List of rules for the logical optimizer
 
         // This one has to be first, as the type cast inserter expects the
@@ -50,33 +59,32 @@ public class FunctionalLogicalOptimizer extends
         // it explicit. Since the RuleMatcher doesn't handle trees properly,
         // we cheat and say that we match any node. Then we'll do the actual
         // test in the transformers check method.
-        List<String> nodes = new ArrayList<String>(1);
-        Map<Integer, Integer> edges = new HashMap<Integer, Integer>();
-        List<Boolean> required = new ArrayList<Boolean>(1);
-        nodes.add("any");
-        required.add(true);
-        mRules.add(new Rule<LogicalOperator, LogicalPlan>(nodes, edges,
-                required, new ImplicitSplitInserter(plan)));
+        
+        rulePlan = new RulePlan();
+        RuleOperator anyLogicalOperator = new RuleOperator(LogicalOperator.class, RuleOperator.NodeType.ANY_NODE, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(anyLogicalOperator);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                new ImplicitSplitInserter(plan), "ImplicitSplitInserter"));
+
 
         // Add type casting to plans where the schema has been declared (by
         // user, data, or data catalog).
-        nodes = new ArrayList<String>(1);
-        nodes.add(LOLOAD_CLASSNAME);
-        edges = new HashMap<Integer, Integer>();
-        required = new ArrayList<Boolean>(1);
-        required.add(true);
-        mRules.add(new Rule<LogicalOperator, LogicalPlan>(nodes, edges,
-                required, new TypeCastInserter(plan, LOLOAD_CLASSNAME)));
+        rulePlan = new RulePlan();
+        RuleOperator loLoad = new RuleOperator(LOLoad.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(loLoad);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                new TypeCastInserter(plan, LOLoad.class.getName()), "LoadTypeCastInserter"));
 
         // Add type casting to plans where the schema has been declared by
         // user in a statement with stream operator.
-        nodes = new ArrayList<String>(1);
-        nodes.add(LOSTREAM_CLASSNAME);
-        edges = new HashMap<Integer, Integer>();
-        required = new ArrayList<Boolean>(1);
-        required.add(true);
-        mRules.add(new Rule(nodes, edges, required, new TypeCastInserter(plan,
-                LOSTREAM_CLASSNAME)));
+        rulePlan = new RulePlan();
+        RuleOperator loStream= new RuleOperator(LOStream.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(loStream);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan, new TypeCastInserter(plan,
+                LOStream.class.getName()), "StreamTypeCastInserter"));
 
     }
 
diff --git a/test/org/apache/pig/test/TestOperatorPlan.java b/test/org/apache/pig/test/TestOperatorPlan.java
index e934a7db5..96bd04857 100644
--- a/test/org/apache/pig/test/TestOperatorPlan.java
+++ b/test/org/apache/pig/test/TestOperatorPlan.java
@@ -26,7 +26,6 @@ import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
 
-import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.*;
 import org.apache.pig.impl.plan.optimizer.*;
 
@@ -41,6 +40,9 @@ import org.junit.Test;
 public class TestOperatorPlan extends junit.framework.TestCase {
 
     private int mNextKey = 0;
+    private static final String SCOPE = "RULE";
+    private static NodeIdGenerator nodeIdGen = NodeIdGenerator.getGenerator();
+    public static int MAX_OPTIMIZATION_ITERATIONS = 250;
 
     abstract class TOperator extends Operator implements Comparable {
         protected String mName;
@@ -80,6 +82,7 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         }
 
         public String name() {
+            //return this.getClass().getName() + " " + mName
             return mName;
         }
 
@@ -103,6 +106,7 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         }
 
         public String name() {
+            //return this.getClass().getName() + " " + mName;
             return mName;
         }
 
@@ -194,7 +198,7 @@ public class TestOperatorPlan extends junit.framework.TestCase {
     static class TOptimizer extends PlanOptimizer<TOperator, TPlan> {
 
         public TOptimizer(TPlan plan) {
-            super(plan);
+            super(plan, TestOperatorPlan.MAX_OPTIMIZATION_ITERATIONS);
         }
 
         public void addRule(Rule rule) {
@@ -202,6 +206,49 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         }
     }
 
+    class AlwaysTransform extends Transformer<TOperator, TPlan> {
+        public boolean mTransformed = false;
+        private int mNumChecks = 0;
+
+        AlwaysTransform(TPlan plan) {
+            super(plan, new DepthFirstWalker<TOperator, TPlan>(plan));
+        }
+
+        public boolean check(List<TOperator> nodes) {
+            ++mNumChecks;
+            return true;
+        }
+
+        public void transform(List<TOperator> nodes) {
+            mTransformed = true;
+        }
+        
+        public int getNumberOfChecks() {
+            return mNumChecks;
+        }
+    }
+
+    class NeverTransform extends Transformer<TOperator, TPlan> {
+        public boolean mTransformed = false;
+        private int mNumChecks = 0;
+
+        NeverTransform(TPlan plan) {
+            super(plan, new DepthFirstWalker<TOperator, TPlan>(plan));
+        }
+
+        public boolean check(List<TOperator> nodes) {
+            ++mNumChecks;
+            return false;
+        }
+
+        public void transform(List<TOperator> nodes) {
+            mTransformed = true;
+        }
+        
+        public int getNumberOfChecks() {
+            return mNumChecks;
+        }
+    }
 
     @Test
     public void testAddRemove() throws Exception {
@@ -529,22 +576,6 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         assertEquals("Nodes: 0 1 3 4 5 FromEdges: 3->4 3->5 ToEdges: 4->3 5->3 ", plan.display());
     }
 
-    class AlwaysTransform extends Transformer<TOperator, TPlan> {
-        public boolean mTransformed = false;
-
-        AlwaysTransform(TPlan plan) {
-            super(plan, new DepthFirstWalker<TOperator, TPlan>(plan));
-        }
-
-        public boolean check(List<TOperator> nodes) {
-            return true;
-        }
-
-        public void transform(List<TOperator> nodes) {
-            mTransformed = true;
-        }
-    }
-
     // Test that we don't match when nodes don't match pattern.  Will give
     // a pattern of S->S->M and a plan of S->M->S.
     @Test
@@ -562,20 +593,22 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[1], ops[2]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(true);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+        
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
@@ -600,20 +633,23 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[0], ops[1]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(true);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
+        
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
@@ -638,25 +674,28 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[1], ops[2]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(true);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+        
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
 
         optimizer.optimize();
+
         assertTrue(transformer.mTransformed);
     }
 
@@ -677,14 +716,15 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[1], ops[2]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("any");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(1);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class,
+                RuleOperator.NodeType.ANY_NODE,
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
@@ -713,20 +753,22 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[2], ops[3]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(true);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
@@ -753,20 +795,22 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[1], ops[2]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(false);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
@@ -775,9 +819,8 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         assertTrue(transformer.mTransformed);
     }
 
-    // Test that we match when a node is optional and the optional node is
-    // missing.  Will give
-    // a pattern of S->S->M (with second S optional) and a plan of S->M.
+    // Test that we do not match when a node is missing.  Will give
+    // a pattern of S->S->M and a plan of S->M.
     @Test
     public void testOptimizerOptionalMissing() throws Exception {
         // Build a plan
@@ -790,42 +833,28 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[0], ops[1]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(false);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
         AlwaysTransform transformer = new AlwaysTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
 
         optimizer.optimize();
-        assertTrue(transformer.mTransformed);
-    }
-
-    class NeverTransform extends Transformer<TOperator, TPlan> {
-        public boolean mTransformed = false;
-
-        NeverTransform(TPlan plan) {
-            super(plan, new DepthFirstWalker<TOperator, TPlan>(plan));
-        }
-
-        public boolean check(List<TOperator> nodes) {
-            return false;
-        }
-
-        public void transform(List<TOperator> nodes) {
-            mTransformed = true;
-        }
+        assertFalse(transformer.mTransformed);
     }
 
     // Test that even if we match, if check returns false then the optimization
@@ -845,20 +874,22 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         plan.connect(ops[1], ops[2]);
 
         // Create our rule
-        ArrayList<String> nodes = new ArrayList<String>(3);
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$SingleOperator");
-        nodes.add("org.apache.pig.test.TestOperatorPlan$MultiOperator");
-        HashMap<Integer, Integer> edges = new HashMap<Integer, Integer>(2);
-        edges.put(0, 1);
-        edges.put(1, 2);
-        ArrayList<Boolean> required = new ArrayList<Boolean>(3);
-        required.add(true);
-        required.add(true);
-        required.add(true);
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
         NeverTransform transformer = new NeverTransform(plan);
         Rule<TOperator, TPlan> r =
-            new Rule<TOperator, TPlan>(nodes, edges, required, transformer);
+            new Rule<TOperator, TPlan>(rulePlan, transformer, "TestRule");
 
         TOptimizer optimizer = new TOptimizer(plan);
         optimizer.addRule(r);
@@ -909,9 +940,825 @@ public class TestOperatorPlan extends junit.framework.TestCase {
 
         assertEquals("Nodes: 1 3 4 FromEdges: 1->3 ToEdges: 3->1 ", plan.display());
     }
+    
+    // Input and pattern are both
+    // S   S
+    //  \ /
+    //   M
+    // Test that we match
+    @Test
+    public void testMultiInputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[3];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, multiOperator_1);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+    }
+    
+    // Pattern
+    // S   M
+    //  \ /
+    //   M
+    // Input has the roots swapped
+    // M   S
+    //  \ /
+    //   M
+    // Test that we match
+    @Test
+    public void testIsomorphicMultiInputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[3];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new MultiOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+        rulePlan.connect(singleOperator_1, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+    }
+    
+    // Input and pattern are both
+    // M
+    // ||
+    // M
+    // Test that we match
+    @Test
+    public void testMultiInputMultiOutputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[2];
+        ops[0] = new MultiOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new MultiOperator("2");
+        plan.add(ops[1]);
+        plan.connect(ops[0], ops[1]);
+        plan.connect(ops[0], ops[1]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+        
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+    }
+
+    // Input and pattern are both
+    //  M
+    // / \
+    // S  S
+    // Test that we match
+    @Test
+    public void testMultiOutputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[3];
+        ops[0] = new MultiOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new SingleOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[1]);
+        plan.connect(ops[0], ops[2]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.connect(multiOperator_1, singleOperator_1);
+        rulePlan.connect(multiOperator_1, singleOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+        
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+    }
+    
+    // Pattern
+    //  M
+    // / \
+    // S  S
+    // Input
+    //  M
+    //  |
+    //  S
+    // Test that we don't match
+    @Test
+    public void testNegativeMultiOutputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[2];
+        ops[0] = new MultiOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        plan.connect(ops[0], ops[1]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.connect(multiOperator_1, singleOperator_1);
+        rulePlan.connect(multiOperator_1, singleOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+        
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertFalse(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == 0); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == 0); //default max iterations
+    }
+    
+    // Pattern
+    //  M
+    //  |
+    //  M
+    // Input
+    //  M
+    // ||
+    //  M
+    // Test that we don't match
+    @Test
+    public void testNegativeMultiOutputPattern1() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[2];
+        ops[0] = new MultiOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new MultiOperator("2");
+        plan.add(ops[1]);
+        plan.connect(ops[0], ops[1]);
+        plan.connect(ops[0], ops[1]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+        
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertFalse(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == 0); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == 0); //default max iterations
+    }
+    
+    // Pattern
+    // S   S
+    //  \ /
+    //   M
+    // Input
+    // S   S    S   S
+    //  \ /      \ /
+    //   M        M
+    // Test that we match multiple instances in the disconnected graph
+    @Test
+    public void testMultipleMultiInputPatternInDisconnectedGraph() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[6];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+        
+        ops[3] = new SingleOperator("4");
+        plan.add(ops[3]);
+        ops[4] = new SingleOperator("5");
+        plan.add(ops[4]);
+        ops[5] = new MultiOperator("6");
+        plan.add(ops[5]);
+        plan.connect(ops[3], ops[5]);
+        plan.connect(ops[4], ops[5]);
 
 
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, multiOperator_1);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == (2* MAX_OPTIMIZATION_ITERATIONS)); 
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == (2 * MAX_OPTIMIZATION_ITERATIONS));
+    }
+
+    // Pattern is
+    // S   S
+    //  \ /
+    //   M
+    // Input
+    // S   S    S   S
+    //  \ /      \ /
+    //   M        M
+    //    \      /
+    //       M
+    // Test that we match multiple instances in a connected graph
+    @Test
+    public void testMultipleMultiInputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[7];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+        
+        ops[3] = new SingleOperator("4");
+        plan.add(ops[3]);
+        ops[4] = new SingleOperator("5");
+        plan.add(ops[4]);
+        ops[5] = new MultiOperator("6");
+        plan.add(ops[5]);
+        plan.connect(ops[3], ops[5]);
+        plan.connect(ops[4], ops[5]);
 
+        ops[6] = new MultiOperator("7");
+        plan.add(ops[6]);
+        plan.connect(ops[2], ops[6]);
+        plan.connect(ops[5], ops[6]);
 
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, multiOperator_1);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == (2 * MAX_OPTIMIZATION_ITERATIONS));
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == (2 * MAX_OPTIMIZATION_ITERATIONS));
+    }
+
+    // Pattern is
+    // S   S
+    //  \ /
+    //   M
+    // Test that we match only one instance in a connected graph
+    @Test
+    public void testSingleMultiInputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[6];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+        
+        ops[3] = new SingleOperator("4");
+        plan.add(ops[3]);
+        ops[4] = new MultiOperator("5");
+        plan.add(ops[4]);
+        plan.connect(ops[3], ops[4]);
+
+        ops[5] = new MultiOperator("6");
+        plan.add(ops[5]);
+        plan.connect(ops[4], ops[5]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, multiOperator_1);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS);
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS);
+    }
+    
+    // Input and pattern are both
+    //  M
+    // / \
+    // S  S
+    // \ /
+    //  M
+    // Test that we match
+    @Test
+    public void testDiamondPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[4];
+        ops[0] = new MultiOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new SingleOperator("3");
+        plan.add(ops[2]);
+        ops[3] = new MultiOperator("4");
+        plan.add(ops[3]);
+        plan.connect(ops[0], ops[1]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[3]);
+        plan.connect(ops[2], ops[3]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_1, singleOperator_1);
+        rulePlan.connect(multiOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_1, multiOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+        
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+    }
+
+    // Pattern 
+    //  M
+    // / \
+    // S  S
+    // \ /
+    //  M
+    // Input has an additional edge from the bottom of the diamond
+    //  M
+    // / \
+    // S  S
+    // \ /
+    //  M
+    //  |
+    //  S
+    // Test that we match
+    @Test
+    public void testDiamondWithEdgePattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[5];
+        ops[0] = new MultiOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new SingleOperator("3");
+        plan.add(ops[2]);
+        ops[3] = new MultiOperator("4");
+        plan.add(ops[3]);
+        ops[4] = new SingleOperator("5");
+        plan.add(ops[4]);
+        plan.connect(ops[0], ops[1]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[3]);
+        plan.connect(ops[2], ops[3]);
+        plan.connect(ops[3], ops[4]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(multiOperator_1);
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_1, singleOperator_1);
+        rulePlan.connect(multiOperator_1, singleOperator_2);
+        rulePlan.connect(singleOperator_1, multiOperator_2);
+        rulePlan.connect(singleOperator_2, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+        
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS); //default max iterations
+    }
+    
+    // Input and Pattern is
+    // S   S
+    //  \ /
+    //   M
+    //   |
+    //   M
+    //  / \
+    // S   S
+    // Test that we match once
+    @Test
+    public void testComplexInputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[6];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+        
+        ops[3] = new SingleOperator("4");
+        plan.add(ops[3]);
+        ops[4] = new SingleOperator("5");
+        plan.add(ops[4]);
+        ops[5] = new MultiOperator("6");
+        plan.add(ops[5]);
+        plan.connect(ops[5], ops[3]);
+        plan.connect(ops[5], ops[4]);
+
+        plan.connect(ops[2], ops[5]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, multiOperator_1);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+        
+        RuleOperator singleOperator_3 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_4 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_3);
+        rulePlan.add(singleOperator_4);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_2, singleOperator_3);
+        rulePlan.connect(multiOperator_2, singleOperator_4);
+        
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertTrue(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS);
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == MAX_OPTIMIZATION_ITERATIONS);
+    }
+    
+    // Pattern is
+    // S   S
+    //  \ /
+    //   M
+    //   ||
+    //   M
+    //  / \
+    // S   S
+    // Input is
+    // S   S
+    //  \ /
+    //   M
+    //   |
+    //   M
+    //  / \
+    // S   S
+    // Test that we don't match
+    @Test
+    public void testNegativeComplexInputPattern() throws Exception {
+        // Build a plan
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[6];
+        ops[0] = new SingleOperator("1");
+        plan.add(ops[0]);
+        ops[1] = new SingleOperator("2");
+        plan.add(ops[1]);
+        ops[2] = new MultiOperator("3");
+        plan.add(ops[2]);
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[2]);
+        
+        ops[3] = new SingleOperator("4");
+        plan.add(ops[3]);
+        ops[4] = new SingleOperator("5");
+        plan.add(ops[4]);
+        ops[5] = new MultiOperator("6");
+        plan.add(ops[5]);
+        plan.connect(ops[5], ops[3]);
+        plan.connect(ops[5], ops[4]);
+
+        plan.connect(ops[2], ops[5]);
+
+        // Create our rule
+        RulePlan rulePlan = new RulePlan();
+        RuleOperator singleOperator_1 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_2 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_1 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_1);
+        rulePlan.add(singleOperator_2);
+        rulePlan.add(multiOperator_1);
+        rulePlan.connect(singleOperator_1, multiOperator_1);
+        rulePlan.connect(singleOperator_2, multiOperator_1);
+        
+        RuleOperator singleOperator_3 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator singleOperator_4 = new RuleOperator(SingleOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        RuleOperator multiOperator_2 = new RuleOperator(MultiOperator.class, 
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(singleOperator_3);
+        rulePlan.add(singleOperator_4);
+        rulePlan.add(multiOperator_2);
+        rulePlan.connect(multiOperator_2, singleOperator_3);
+        rulePlan.connect(multiOperator_2, singleOperator_4);
+        
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+        rulePlan.connect(multiOperator_1, multiOperator_2);
+
+        AlwaysTransform alwaysTransform = new AlwaysTransform(plan);
+        Rule<TOperator, TPlan> r1 =
+            new Rule<TOperator, TPlan>(rulePlan, alwaysTransform, "TestRule");
+
+        NeverTransform neverTransform = new NeverTransform(plan);
+        Rule<TOperator, TPlan> r2 =
+            new Rule<TOperator, TPlan>(rulePlan, neverTransform, "TestRule");
+
+        TOptimizer optimizer = new TOptimizer(plan);
+        optimizer.addRule(r1);
+        optimizer.addRule(r2);
+
+        optimizer.optimize();
+        assertFalse(alwaysTransform.mTransformed);
+        assertTrue(alwaysTransform.getNumberOfChecks() == 0);
+        assertFalse(neverTransform.mTransformed);
+        assertTrue(neverTransform.getNumberOfChecks() == 0);
+    }
 }
 
diff --git a/test/org/apache/pig/test/data/DotFiles/optlimitplan4.dot b/test/org/apache/pig/test/data/DotFiles/optlimitplan4.dot
index c1b9cf4eb..a1ab0b2c7 100644
--- a/test/org/apache/pig/test/data/DotFiles/optlimitplan4.dot
+++ b/test/org/apache/pig/test/data/DotFiles/optlimitplan4.dot
@@ -1,7 +1,7 @@
 digraph graph1 {
-    LOLoad31 -> LOCogroup33;
-    LOCogroup33 -> LOForEach37;
-    LOForEach37 [hasflat="true"];
-    LOForEach37 -> LOLimit38;
-    LOLimit38 [limit="100"];
+    LOLoad1029 -> LOCogroup1031;
+    LOCogroup1031 -> LOForEach1035;
+    LOForEach1035 [hasflat="true"];
+    LOForEach1035 -> LOLimit1036;
+    LOLimit1036 [limit="100"];
 }
diff --git a/test/org/apache/pig/test/data/DotFiles/optlimitplan5.dot b/test/org/apache/pig/test/data/DotFiles/optlimitplan5.dot
index 85e657be0..e8877d7bc 100644
--- a/test/org/apache/pig/test/data/DotFiles/optlimitplan5.dot
+++ b/test/org/apache/pig/test/data/DotFiles/optlimitplan5.dot
@@ -1,6 +1,6 @@
 digraph graph1 {
-    LOLoad39 -> LOLimit44;
-    LOLimit44 [limit="100"];
-    LOLimit44 -> LOForEach43;
-    LOForEach43 [hasflat="false"];
+    LOLoad1037 -> LOLimit1042;
+    LOLimit1042 [limit="100"];
+    LOLimit1042 -> LOForEach1041;
+    LOForEach1041 [hasflat="false"];
 }
diff --git a/test/org/apache/pig/test/data/DotFiles/optlimitplan6.dot b/test/org/apache/pig/test/data/DotFiles/optlimitplan6.dot
index b5ea348ec..225098503 100644
--- a/test/org/apache/pig/test/data/DotFiles/optlimitplan6.dot
+++ b/test/org/apache/pig/test/data/DotFiles/optlimitplan6.dot
@@ -1,4 +1,4 @@
 digraph graph1 {
-    LOLoad45 -> LOLimit46;
-    LOLimit46 [limit="20"];
+    LOLoad1043 -> LOLimit1044;
+    LOLimit1044 [limit="20"];
 }
diff --git a/test/org/apache/pig/test/data/DotFiles/optlimitplan7.dot b/test/org/apache/pig/test/data/DotFiles/optlimitplan7.dot
index 2f0087fb8..1327629c3 100644
--- a/test/org/apache/pig/test/data/DotFiles/optlimitplan7.dot
+++ b/test/org/apache/pig/test/data/DotFiles/optlimitplan7.dot
@@ -1,6 +1,6 @@
 digraph graph1 {
-    LOLoad49 -> LOForEach53;
-    LOForEach53 [hasflat="true"];
-    LOForEach53 -> LOLimit54;
-    LOLimit54 [limit="100"];
+    LOLoad1047 -> LOForEach1051;
+    LOForEach1051 [hasflat="true"];
+    LOForEach1051 -> LOLimit1052;
+    LOLimit1052 [limit="100"];
 }
diff --git a/test/org/apache/pig/test/data/DotFiles/optlimitplan8.dot b/test/org/apache/pig/test/data/DotFiles/optlimitplan8.dot
index f5b59cb6e..d9f115c14 100644
--- a/test/org/apache/pig/test/data/DotFiles/optlimitplan8.dot
+++ b/test/org/apache/pig/test/data/DotFiles/optlimitplan8.dot
@@ -1,6 +1,6 @@
 digraph graph1 {
-    LOLoad55 -> LOSort57;
-    LOSort57 [limit="-1"];
-    LOSort57 -> LOLimit58;
-    LOLimit58 [limit="10"];
+    LOLoad1053 -> LOSort1055;
+    LOSort1055 [limit="-1"];
+    LOSort1055 -> LOLimit1056;
+    LOLimit1056 [limit="10"];
 }
diff --git a/test/org/apache/pig/test/data/DotFiles/optlimitplan9.dot b/test/org/apache/pig/test/data/DotFiles/optlimitplan9.dot
index 5616ba9d3..6d9aa9314 100644
--- a/test/org/apache/pig/test/data/DotFiles/optlimitplan9.dot
+++ b/test/org/apache/pig/test/data/DotFiles/optlimitplan9.dot
@@ -1,4 +1,4 @@
 digraph graph1 {
-    LOLoad59 -> LOSort61;
-    LOSort61 [limit="10"];
+    LOLoad1057 -> LOSort1059;
+    LOSort1059 [limit="10"];
 }
diff --git a/test/org/apache/pig/test/data/GoldenFiles/MRC15.gld b/test/org/apache/pig/test/data/GoldenFiles/MRC15.gld
index c69c7789d..c22a6763c 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/MRC15.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/MRC15.gld
@@ -1,4 +1,4 @@
-MapReduce(1,GFCross) - -153:
+MapReduce(1,GFCross) - -156:
 |   Store(DummyFil:DummyLdr) - --5683415113785058706
 |   |
 |   |---New For Each(false)[tuple] - --8002381389674382470
@@ -10,10 +10,10 @@ MapReduce(1,GFCross) - -153:
 |       |---Package[tuple]{Unknown} - --885269774183211482
 |   Local Rearrange[tuple]{Unknown}(false) - --776319888013965510
 |   |
-|   |---Load(/tmp/temp-1456742965/tmp-586682361:org.apache.pig.builtin.BinStorage) - -152
+|   |---Load(/tmp/temp-1456742965/tmp-586682361:org.apache.pig.builtin.BinStorage) - -155
 |
-|---MapReduce(1,AVG) - -150:
-    |   Store(/tmp/temp-1456742965/tmp-586682361:org.apache.pig.builtin.BinStorage) - -151
+|---MapReduce(1,AVG) - -153:
+    |   Store(/tmp/temp-1456742965/tmp-586682361:org.apache.pig.builtin.BinStorage) - -154
     |   |
     |   |---New For Each(false)[tuple] - -7965768498188214494
     |       |   |
@@ -24,10 +24,10 @@ MapReduce(1,GFCross) - -153:
     |       |---Package[tuple]{Unknown} - --7335024873119453444
     |   Local Rearrange[tuple]{Unknown}(false) - -4589138876054328603
     |   |
-    |   |---Load(/tmp/temp-1456742965/tmp-26634357:org.apache.pig.builtin.BinStorage) - -149
+    |   |---Load(/tmp/temp-1456742965/tmp-26634357:org.apache.pig.builtin.BinStorage) - -152
     |
-    |---MapReduce(20,TestMRCompiler$WeirdComparator,COUNT,SUM) - -142:
-        |   Store(/tmp/temp-1456742965/tmp-26634357:org.apache.pig.builtin.BinStorage) - -148
+    |---MapReduce(20,TestMRCompiler$WeirdComparator,COUNT,SUM) - -145:
+        |   Store(/tmp/temp-1456742965/tmp-26634357:org.apache.pig.builtin.BinStorage) - -151
         |   |
         |   |---New For Each(false,false)[tuple] - --4248200967728536480
         |       |   |
@@ -39,31 +39,37 @@ MapReduce(1,GFCross) - -153:
         |       |   |
         |       |   |---Project[tuple][*] - --1848504978980807369
         |       |
-        |       |---New For Each(true)[tuple] - -147
+        |       |---New For Each(true)[tuple] - -150
         |           |   |
-        |           |   Project[bag][1] - -146
+        |           |   Project[bag][1] - -149
         |           |
-        |           |---Package[tuple]{tuple} - -145
-        |   Local Rearrange[tuple]{tuple}(false) - -144
+        |           |---Package[tuple]{tuple} - -148
+        |   Local Rearrange[tuple]{tuple}(false) - -147
         |   |   |
-        |   |   Project[tuple][*] - -143
+        |   |   Project[tuple][*] - -146
         |   |
-        |   |---Load(/tmp/temp-1456742965/tmp-1456742965:org.apache.pig.builtin.BinStorage) - -141
+        |   |---Load(/tmp/temp-1456742965/tmp-1456742965:org.apache.pig.builtin.BinStorage) - -144
         |
         |---MapReduce(1,TestMRCompiler$WeirdComparator) - -130:
-            |   Store(/tmp/temp-1456742965/tmp2077335416:org.apache.pig.builtin.BinStorage) - -140
+            |   Store(/tmp/temp-1456742965/tmp2077335416:org.apache.pig.builtin.BinStorage) - -143
             |   |
-            |   |---New For Each(false,false)[tuple] - -139
+            |   |---New For Each(false)[tuple] - -142
             |       |   |
-            |       |   Constant(20) - -138
+            |       |   POUserFunc(org.apache.pig.impl.builtin.FindQuantiles)[tuple] - -141
             |       |   |
-            |       |   POSort[bag](org.apache.pig.test.TestMRCompiler$WeirdComparator) - --8479692259657755370
-            |       |   |   |
-            |       |   |   Project[tuple][*] - -137
-            |       |   |
-            |       |   |---Project[tuple][1] - -136
+            |       |   |---Project[tuple][*] - -140
             |       |
-            |       |---Package[tuple]{chararray} - -135
+            |       |---New For Each(false,false)[tuple] - -139
+            |           |   |
+            |           |   Constant(20) - -138
+            |           |   |
+            |           |   POSort[bag](org.apache.pig.test.TestMRCompiler$WeirdComparator) - --8479692259657755370
+            |           |   |   |
+            |           |   |   Project[tuple][*] - -137
+            |           |   |
+            |           |   |---Project[tuple][1] - -136
+            |           |
+            |           |---Package[tuple]{chararray} - -135
             |   Local Rearrange[tuple]{chararray}(false) - -134
             |   |   |
             |   |   Constant(all) - -133
diff --git a/test/org/apache/pig/test/data/GoldenFiles/MRC16.gld b/test/org/apache/pig/test/data/GoldenFiles/MRC16.gld
index 4b855a210..f7a8761b1 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/MRC16.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/MRC16.gld
@@ -1,36 +1,36 @@
-MapReduce(-1) - -167:
+MapReduce(-1) - -170:
 |   Store(DummyFil:DummyLdr) - -7973970339130605847
 |   |
-|   |---New For Each(true)[bag] - -170
+|   |---New For Each(true)[bag] - -173
 |       |   |
-|       |   Project[tuple][0] - -169
+|       |   Project[tuple][0] - -172
 |       |
-|       |---Package[tuple]{tuple} - -168
-|   Local Rearrange[tuple]{tuple}(true) - -164
+|       |---Package[tuple]{tuple} - -171
+|   Local Rearrange[tuple]{tuple}(true) - -167
 |   |   |
-|   |   Project[tuple][*] - -163
+|   |   Project[tuple][*] - -166
 |   |
-|   |---Load(/tmp/temp-1456742965/tmp2077335416:org.apache.pig.builtin.BinStorage) - -166
+|   |---Load(/tmp/temp-1456742965/tmp2077335416:org.apache.pig.builtin.BinStorage) - -169
 |
-|---MapReduce(-1) - -162:
-    |   Store(/tmp/temp-1456742965/tmp2077335416:org.apache.pig.builtin.BinStorage) - -165
+|---MapReduce(-1) - -165:
+    |   Store(/tmp/temp-1456742965/tmp2077335416:org.apache.pig.builtin.BinStorage) - -168
     |   |
     |   |---Package[tuple]{Unknown} - -2082992246427879202
     |   Local Rearrange[tuple]{Unknown}(false) - --3148893660811981376
     |   |
-    |   |---Load(/tmp/temp-1456742965/tmp-1456742965:org.apache.pig.builtin.BinStorage) - -161
+    |   |---Load(/tmp/temp-1456742965/tmp-1456742965:org.apache.pig.builtin.BinStorage) - -164
     |
-    |---MapReduce(-1) - -154:
-        |   Store(/tmp/temp-1456742965/tmp-1456742965:org.apache.pig.builtin.BinStorage) - -160
+    |---MapReduce(-1) - -157:
+        |   Store(/tmp/temp-1456742965/tmp-1456742965:org.apache.pig.builtin.BinStorage) - -163
         |   |
-        |   |---New For Each(true)[bag] - -159
+        |   |---New For Each(true)[bag] - -162
         |       |   |
-        |       |   Project[tuple][0] - -158
+        |       |   Project[tuple][0] - -161
         |       |
-        |       |---Package[tuple]{tuple} - -157
-        |   Local Rearrange[tuple]{tuple}(true) - -156
+        |       |---Package[tuple]{tuple} - -160
+        |   Local Rearrange[tuple]{tuple}(true) - -159
         |   |   |
-        |   |   Project[tuple][*] - -155
+        |   |   Project[tuple][*] - -158
         |   |
         |   |---Filter[tuple] - --7926255547935388282
         |       |
diff --git a/test/org/apache/pig/test/data/GoldenFiles/MRC17.gld b/test/org/apache/pig/test/data/GoldenFiles/MRC17.gld
index a5a6c116e..9ad02b4ae 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/MRC17.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/MRC17.gld
@@ -1,16 +1,16 @@
-MapReduce(1) - -171:
+MapReduce(1) - -174:
 |   Store(DummyFil:DummyLdr) - -7856319821130535798
 |   |
-|   |---Limit - -177
+|   |---Limit - -180
 |       |
-|       |---New For Each(true)[bag] - -176
+|       |---New For Each(true)[bag] - -179
 |           |   |
-|           |   Project[tuple][1] - -175
+|           |   Project[tuple][1] - -178
 |           |
-|           |---Package[tuple]{tuple} - -174
-|   Local Rearrange[tuple]{tuple}(false) - -173
+|           |---Package[tuple]{tuple} - -177
+|   Local Rearrange[tuple]{tuple}(false) - -176
 |   |   |
-|   |   Project[tuple][*] - -172
+|   |   Project[tuple][*] - -175
 |   |
 |   |---Limit - -7398260302074824818
 |       |
