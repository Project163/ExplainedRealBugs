diff --git a/CHANGES.txt b/CHANGES.txt
index 10cb61282..90a4f011d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -136,6 +136,9 @@ PIG-1086: Nested sort by * throw exception (rding via daijy)
 
 PIG-1146: Inconsistent column pruning in LOUnion (daijy)
 
+PIG-1176: Column Pruner issues in union of loader with and without schema
+(daijy)
+
 Release 0.6.0 - Unreleased
 
 INCOMPATIBLE CHANGES
diff --git a/src/org/apache/pig/impl/logicalLayer/ColumnPruner.java b/src/org/apache/pig/impl/logicalLayer/ColumnPruner.java
index 2b326c27b..e06d54d67 100644
--- a/src/org/apache/pig/impl/logicalLayer/ColumnPruner.java
+++ b/src/org/apache/pig/impl/logicalLayer/ColumnPruner.java
@@ -169,7 +169,7 @@ public class ColumnPruner extends LOVisitor {
                 currentOp = lOp.insertPlainForEachAfter(columnsToProject);
             }
             
-            if (lOp.pruneColumns(columnsPruned)) {
+            if (!columnsPruned.isEmpty()&&lOp.pruneColumns(columnsPruned)) {
                 prunedColumnsMap.put(currentOp, columnsToPrune);
             }
         } catch (FrontendException e) {
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PruneColumns.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PruneColumns.java
index adc3e677d..dfaf1ed04 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/PruneColumns.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PruneColumns.java
@@ -73,9 +73,10 @@ class RequiredInfo {
 }
 
 public class PruneColumns extends LogicalTransformer {
-
+    private boolean safeToPrune = true;
     private static Log log = LogFactory.getLog(PruneColumns.class);
     Map<RelationalOperator, RequiredInfo> cachedRequiredInfo = new HashMap<RelationalOperator, RequiredInfo>();
+    private Map<LOLoad, RequiredFields> prunedLoaderColumnsMap = new HashMap<LOLoad, RequiredFields>();
     ColumnPruner pruner;
     public PruneColumns(LogicalPlan plan) {
         super(plan);
@@ -175,6 +176,8 @@ public class PruneColumns extends LogicalTransformer {
     {
         try
         {
+            if (!safeToPrune)
+                return;
             if (!(lo instanceof RelationalOperator))
             {
                 int errCode = 2182;
@@ -183,6 +186,7 @@ public class PruneColumns extends LogicalTransformer {
             }
             if (lo.getSchema()==null)
             {
+                safeToPrune = false;
                 return;
             }
             RelationalOperator rlo = (RelationalOperator)lo;
@@ -195,7 +199,7 @@ public class PruneColumns extends LogicalTransformer {
             {
                 // LOLoad has only one output
                 RequiredFields loaderRequiredFields = requiredOutputInfo.requiredFieldsList.get(0);
-                pruneLoader((LOLoad)rlo, loaderRequiredFields);
+                prunedLoaderColumnsMap.put((LOLoad)rlo, loaderRequiredFields);
                 return;
             }
             
@@ -767,6 +771,12 @@ public class PruneColumns extends LogicalTransformer {
     
     public void prune() throws OptimizerException {
         try {
+            if (!safeToPrune)
+                return;
+            
+            for (LOLoad load : prunedLoaderColumnsMap.keySet())
+                pruneLoader(load, prunedLoaderColumnsMap.get(load));
+            
             if (!pruner.isEmpty())
                 pruner.visit();
         }
diff --git a/test/org/apache/pig/test/TestPruneColumn.java b/test/org/apache/pig/test/TestPruneColumn.java
index 972b70a80..f831d50d5 100644
--- a/test/org/apache/pig/test/TestPruneColumn.java
+++ b/test/org/apache/pig/test/TestPruneColumn.java
@@ -1723,4 +1723,48 @@ public class TestPruneColumn extends TestCase {
             "No map keys pruned for A", "No column pruned for B",
             "No map keys pruned for B"}));
     }
+    
+    // See PIG-1176
+    @Test
+    public void testUnionMixedSchemaPruning() throws Exception {
+        pigServer.registerQuery("A = load '"+ Util.generateURI(tmpFile1.toString()) + "' AS (a0, a1, a2);");
+        pigServer.registerQuery("B = foreach A generate a0;;");
+        pigServer.registerQuery("C = load '"+ Util.generateURI(tmpFile2.toString()) + "';");
+        pigServer.registerQuery("D = foreach C generate $0;");
+        pigServer.registerQuery("E = union B, D;");
+        Iterator<Tuple> iter = pigServer.openIterator("E");
+        Collection<String> results = new HashSet<String>();
+        results.add("(1)");
+        results.add("(2)");
+        results.add("(1)");
+        results.add("(2)");
+
+        assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+
+        assertTrue(t.size()==1);
+        assertTrue(results.contains(t.toString()));
+
+        assertTrue(iter.hasNext());
+        t = iter.next();
+
+        assertTrue(t.size()==1);
+        assertTrue(results.contains(t.toString()));
+
+        assertTrue(iter.hasNext());
+        t = iter.next();
+
+        assertTrue(t.size()==1);
+        assertTrue(results.contains(t.toString()));
+
+        assertTrue(iter.hasNext());
+        t = iter.next();
+
+        assertTrue(t.size()==1);
+        assertTrue(results.contains(t.toString()));
+
+        assertFalse(iter.hasNext());
+
+        assertTrue(emptyLogFileMessage());
+    }
 }
