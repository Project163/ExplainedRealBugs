diff --git a/CHANGES.txt b/CHANGES.txt
index 2bbfcec46..5b8d7e59d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -22,6 +22,8 @@ Trunk (unreleased changes)
 
 INCOMPATIBLE CHANGES
 
+PIG-734:  Changed maps to only take strings as keys (gates).
+
 IMPROVEMENTS
 
 PIG-697: Proposed improvements to pig's optimizer (sms)
diff --git a/src/org/apache/pig/LoadFunc.java b/src/org/apache/pig/LoadFunc.java
index 559c9af61..b522a091c 100644
--- a/src/org/apache/pig/LoadFunc.java
+++ b/src/org/apache/pig/LoadFunc.java
@@ -119,7 +119,7 @@ public interface LoadFunc {
      * @return Map value.
      * @throws IOException if the value cannot be cast.
      */
-    public Map<Object, Object> bytesToMap(byte[] b) throws IOException;
+    public Map<String, Object> bytesToMap(byte[] b) throws IOException;
 
     /**
      * Cast data from bytes to tuple value.  
diff --git a/src/org/apache/pig/PigException.java b/src/org/apache/pig/PigException.java
index dc11c41b0..52628a788 100644
--- a/src/org/apache/pig/PigException.java
+++ b/src/org/apache/pig/PigException.java
@@ -31,6 +31,9 @@ import java.io.IOException;
  */
 public class PigException extends IOException {
 
+	// Change this if you modify the class.
+	static final long serialVersionUID = 1L;
+
     /*
      * Instead of using an enum for the source of the error,
      * the classic style of using static final is adopted
diff --git a/src/org/apache/pig/backend/BackendException.java b/src/org/apache/pig/backend/BackendException.java
index 75a4119e2..e35e350de 100644
--- a/src/org/apache/pig/backend/BackendException.java
+++ b/src/org/apache/pig/backend/BackendException.java
@@ -21,6 +21,9 @@ import org.apache.pig.PigException;
 
 public class BackendException extends PigException {
 
+	// Change this if you modify the class.
+	static final long serialVersionUID = 1L;
+
     /**
      * Create a new BackendException with null as the error message.
      */
@@ -154,4 +157,4 @@ public class BackendException extends PigException {
         super(message, errCode, errSrc, retry, detailedMsg, cause);
     }
 
-}
\ No newline at end of file
+}
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/partitioners/WeightedRangePartitioner.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/partitioners/WeightedRangePartitioner.java
index 563e5d8fd..f2524ce20 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/partitioners/WeightedRangePartitioner.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/partitioners/WeightedRangePartitioner.java
@@ -35,6 +35,7 @@ import org.apache.pig.backend.hadoop.HDataType;
 import org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;
 import org.apache.pig.builtin.BinStorage;
 import org.apache.pig.data.DataBag;
+import org.apache.pig.data.InternalMap;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.builtin.FindQuantiles;
@@ -91,11 +92,11 @@ public class WeightedRangePartitioner implements Partitioner<PigNullableWritable
             // numQuantiles here is the reduce parallelism
             Map<String, Object> quantileMap = (Map<String, Object>) t.get(0);
             quantilesList = (DataBag) quantileMap.get(FindQuantiles.QUANTILES_LIST);
-            Map<Tuple, Tuple> weightedPartsData = (Map<Tuple, Tuple>) quantileMap.get(FindQuantiles.WEIGHTED_PARTS);
+            InternalMap weightedPartsData = (InternalMap) quantileMap.get(FindQuantiles.WEIGHTED_PARTS);
             convertToArray(quantilesList);
-            for(Entry<Tuple, Tuple> ent : weightedPartsData.entrySet()){
-                Tuple key = ent.getKey(); // sample item which repeats
-                float[] probVec = getProbVec(ent.getValue());
+            for(Entry<Object, Object> ent : weightedPartsData.entrySet()){
+                Tuple key = (Tuple)ent.getKey(); // sample item which repeats
+                float[] probVec = getProbVec((Tuple)ent.getValue());
                 weightedParts.put(getPigNullableWritable(key), 
                         new DiscreteProbabilitySampleGenerator(probVec));
             }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POMapLookUp.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POMapLookUp.java
index f800acf8e..b458bca76 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POMapLookUp.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POMapLookUp.java
@@ -33,7 +33,7 @@ import org.apache.pig.impl.plan.VisitorException;
 
 public class POMapLookUp extends ExpressionOperator {
 	
-	private Object key;
+	private String key;
 
 	public POMapLookUp(OperatorKey k) {
 		super(k);
@@ -43,16 +43,16 @@ public class POMapLookUp extends ExpressionOperator {
 		super(k, rp);
 	}
 	
-	public POMapLookUp(OperatorKey k, int rp, Object key) {
+	public POMapLookUp(OperatorKey k, int rp, String key) {
 		super(k, rp);
 		this.key = key;
 	}
 	
-	public void setLookUpKey(Object key) {
+	public void setLookUpKey(String key) {
 		this.key = key;
 	}
 	
-	public Object getLookUpKey() {
+	public String getLookUpKey() {
 		return key;
 	}
 
@@ -64,20 +64,18 @@ public class POMapLookUp extends ExpressionOperator {
 
 	@Override
 	public String name() {
-		// TODO Auto-generated method stub
 		return "POMapLookUp" + "[" + DataType.findTypeName(resultType) + "]" +" - " + mKey.toString();
 	}
 
 	@Override
 	public boolean supportsMultipleInputs() {
-		// TODO Auto-generated method stub
 		return false;
 	}
 	
 	@Override
 	public Result processInput() throws ExecException {
         Result res = new Result();
-        Map<Object, Object> inpValue = null;
+        Map<String, Object> inpValue = null;
         if (input == null && (inputs == null || inputs.size()==0)) {
 //            log.warn("No inputs found. Signaling End of Processing.");
             res.returnStatus = POStatus.STATUS_EOP;
@@ -93,10 +91,11 @@ public class POMapLookUp extends ExpressionOperator {
         }
     }
 	
+	@SuppressWarnings("unchecked")
 	private Result getNext() throws ExecException {
 		Result res = processInput();
 		if(res.result != null && res.returnStatus == POStatus.STATUS_OK) {
-			res.result = ((Map)res.result).get(key);
+			res.result = ((Map<String, Object>)res.result).get(key);
 		}
 		return res;
 	}
diff --git a/src/org/apache/pig/builtin/BinStorage.java b/src/org/apache/pig/builtin/BinStorage.java
index 7b9cc5824..68a25361a 100644
--- a/src/org/apache/pig/builtin/BinStorage.java
+++ b/src/org/apache/pig/builtin/BinStorage.java
@@ -222,7 +222,7 @@ public class BinStorage implements ReversibleLoadStoreFunc {
         }
     }
 
-    public Map<Object, Object> bytesToMap(byte[] b) {
+    public Map<String, Object> bytesToMap(byte[] b) {
         DataInputStream dis = new DataInputStream(new ByteArrayInputStream(b));
         try {
             return DataReaderWriter.bytesToMap(dis);
@@ -372,7 +372,7 @@ public class BinStorage implements ReversibleLoadStoreFunc {
         return baos.toByteArray();
     }
 
-    public byte[] toBytes(Map<Object, Object> m) throws IOException {
+    public byte[] toBytes(Map<String, Object> m) throws IOException {
         ByteArrayOutputStream baos = new ByteArrayOutputStream();
         DataOutputStream dos = new DataOutputStream(baos);
         try {
diff --git a/src/org/apache/pig/builtin/MapSize.java b/src/org/apache/pig/builtin/MapSize.java
index 485b02437..5ee54788d 100644
--- a/src/org/apache/pig/builtin/MapSize.java
+++ b/src/org/apache/pig/builtin/MapSize.java
@@ -36,7 +36,7 @@ public class MapSize extends EvalFunc<Long> {
     @Override
     public Long exec(Tuple input) throws IOException {
         try {
-            Map<Object, Object> m = (Map<Object, Object>)(input.get(0));
+            Map<String, Object> m = (Map<String, Object>)(input.get(0));
             return m == null ? null : new Long(m.keySet().size());
         } catch (ExecException exp) {
             throw exp;
diff --git a/src/org/apache/pig/builtin/PigStorage.java b/src/org/apache/pig/builtin/PigStorage.java
index 4df1c9366..04baa5e5b 100644
--- a/src/org/apache/pig/builtin/PigStorage.java
+++ b/src/org/apache/pig/builtin/PigStorage.java
@@ -194,17 +194,17 @@ public class PigStorage extends Utf8StorageConverter
 
         case DataType.MAP:
             boolean mapHasNext = false;
-            Map<Object, Object> m = (Map<Object, Object>)field;
+            Map<String, Object> m = (Map<String, Object>)field;
             mOut.write(mapBeginDelim.getBytes(UTF8));
-            for(Object o: m.keySet()) {
+            for(String s: m.keySet()) {
                 if(mapHasNext) {
                     mOut.write(fieldDelim.getBytes(UTF8));
                 } else {
                     mapHasNext = true;
                 }
-                putField(o);
+                putField(s);
                 mOut.write(mapKeyValueDelim.getBytes(UTF8));
-                putField(m.get(o));
+                putField(m.get(s));
             }
             mOut.write(mapEndDelim.getBytes(UTF8));
             break;
diff --git a/src/org/apache/pig/builtin/TextLoader.java b/src/org/apache/pig/builtin/TextLoader.java
index fff3a7dff..2646b68b1 100644
--- a/src/org/apache/pig/builtin/TextLoader.java
+++ b/src/org/apache/pig/builtin/TextLoader.java
@@ -132,7 +132,7 @@ public class TextLoader implements LoadFunc{
      * TextLoader does not support conversion to Map
      * @throws IOException if the value cannot be cast.
      */
-    public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
+    public Map<String, Object> bytesToMap(byte[] b) throws IOException {
         int errCode = 2109;
         String msg = "TextLoader does not support conversion to Map.";
         throw new ExecException(msg, errCode, PigException.BUG);
@@ -206,7 +206,7 @@ public class TextLoader implements LoadFunc{
         throw new ExecException(msg, errCode, PigException.BUG);
     }
 
-    public byte[] toBytes(Map<Object, Object> m) throws IOException {
+    public byte[] toBytes(Map<String, Object> m) throws IOException {
         int errCode = 2109;
         String msg = "TextLoader does not support conversion from Map.";
         throw new ExecException(msg, errCode, PigException.BUG);
diff --git a/src/org/apache/pig/builtin/Utf8StorageConverter.java b/src/org/apache/pig/builtin/Utf8StorageConverter.java
index 011137fb4..8e510dfee 100644
--- a/src/org/apache/pig/builtin/Utf8StorageConverter.java
+++ b/src/org/apache/pig/builtin/Utf8StorageConverter.java
@@ -203,12 +203,12 @@ abstract public class Utf8StorageConverter {
         }
     }
 
-    public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
+    public Map<String, Object> bytesToMap(byte[] b) throws IOException {
         if(b == null)
             return null;
-        Map<Object, Object> map;
+        Map<String, Object> map;
         try {
-            map = (Map<Object, Object>)parseFromBytes(b);
+            map = (Map<String, Object>)parseFromBytes(b);
         }
         catch (ParseException pe) {
             LogUtils.warn(this, "Unable to interpret value " + b + " in field being " +
@@ -276,7 +276,7 @@ abstract public class Utf8StorageConverter {
         return l.toString().getBytes();
     }
 
-    public byte[] toBytes(Map<Object, Object> m) throws IOException {
+    public byte[] toBytes(Map<String, Object> m) throws IOException {
         return DataType.mapToString(m).getBytes();
     }
 
diff --git a/src/org/apache/pig/data/DataReaderWriter.java b/src/org/apache/pig/data/DataReaderWriter.java
index c4591faec..3deb68c9f 100644
--- a/src/org/apache/pig/data/DataReaderWriter.java
+++ b/src/org/apache/pig/data/DataReaderWriter.java
@@ -64,9 +64,19 @@ public class DataReaderWriter {
         return bag;
     }
     
-    public static Map<Object, Object> bytesToMap(DataInput in) throws IOException {
+    public static Map<String, Object> bytesToMap(DataInput in) throws IOException {
         int size = in.readInt();    
-        Map<Object, Object> m = new HashMap<Object, Object>(size);
+        Map<String, Object> m = new HashMap<String, Object>(size);
+        for (int i = 0; i < size; i++) {
+            String key = (String)readDatum(in);
+            m.put(key, readDatum(in));
+        }
+        return m;    
+    }
+
+    public static InternalMap bytesToInternalMap(DataInput in) throws IOException {
+        int size = in.readInt();    
+        InternalMap m = new InternalMap(size);
         for (int i = 0; i < size; i++) {
             Object key = readDatum(in);
             m.put(key, readDatum(in));
@@ -105,6 +115,9 @@ public class DataReaderWriter {
             case DataType.MAP: 
                 return bytesToMap(in);    
 
+            case DataType.INTERNALMAP: 
+                return bytesToInternalMap(in);    
+
             case DataType.INTEGER:
                 return new Integer(in.readInt());
 
@@ -146,6 +159,7 @@ public class DataReaderWriter {
         }
     }
 
+	@SuppressWarnings("unchecked")
     public static void writeDatum(
             DataOutput out,
             Object val) throws IOException {
@@ -167,6 +181,20 @@ public class DataReaderWriter {
 
             case DataType.MAP: {
                 out.writeByte(DataType.MAP);
+                Map<String, Object> m = (Map<String, Object>)val;
+                out.writeInt(m.size());
+                Iterator<Map.Entry<String, Object> > i =
+                    m.entrySet().iterator();
+                while (i.hasNext()) {
+                    Map.Entry<String, Object> entry = i.next();
+                    writeDatum(out, entry.getKey());
+                    writeDatum(out, entry.getValue());
+                }
+                break;
+                               }
+            
+            case DataType.INTERNALMAP: {
+                out.writeByte(DataType.INTERNALMAP);
                 Map<Object, Object> m = (Map<Object, Object>)val;
                 out.writeInt(m.size());
                 Iterator<Map.Entry<Object, Object> > i =
@@ -178,7 +206,7 @@ public class DataReaderWriter {
                 }
                 break;
                                }
-
+            
             case DataType.INTEGER:
                 out.writeByte(DataType.INTEGER);
                 out.writeInt((Integer)val);
diff --git a/src/org/apache/pig/data/DataType.java b/src/org/apache/pig/data/DataType.java
index 88b35382a..44e828d14 100644
--- a/src/org/apache/pig/data/DataType.java
+++ b/src/org/apache/pig/data/DataType.java
@@ -66,6 +66,7 @@ public class DataType {
     public static final byte MAP       = 100;
     public static final byte TUPLE     = 110;
     public static final byte BAG       = 120;
+    public static final byte INTERNALMAP = 127; // internal use only; for maps that are object->object.  Used by FindQuantiles.
     public static final byte ERROR     =  -1;
 
     /**
@@ -83,6 +84,7 @@ public class DataType {
         else if (o instanceof DataBag) return BAG;
         else if (o instanceof Integer) return INTEGER;
         else if (o instanceof Long) return LONG;
+        else if (o instanceof InternalMap) return INTERNALMAP;
         else if (o instanceof Map) return MAP;
         else if (o instanceof Float) return FLOAT;
         else if (o instanceof Double) return DOUBLE;
@@ -109,6 +111,7 @@ public class DataType {
         else if (t == Double.class) return DOUBLE;
         else if (t == Boolean.class) return BOOLEAN;
         else if (t == Byte.class) return BYTE;
+        else if (t == InternalMap.class) return INTERNALMAP;
         else {
             // Might be a tuple or a bag, need to check the interfaces it
             // implements
@@ -144,14 +147,15 @@ public class DataType {
         return types.length;
     }
     public static byte[] genAllTypes(){
-        byte[] types = { DataType.BAG, DataType.BIGCHARARRAY, DataType.BOOLEAN, DataType.BYTE, DataType.BYTEARRAY, DataType.CHARARRAY, 
-                DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG, DataType.MAP, DataType.TUPLE};
+        byte[] types = { DataType.BAG, DataType.BIGCHARARRAY, DataType.BOOLEAN, DataType.BYTE, DataType.BYTEARRAY, 
+                DataType.CHARARRAY, DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.INTERNALMAP, 
+                DataType.LONG, DataType.MAP, DataType.TUPLE};
         return types;
     }
     
     private static String[] genAllTypeNames(){
-        String[] names = { "BAG", "BIGCHARARRAY", "BOOLEAN", "BYTE", "BYTEARRAY", "CHARARRAY", "DOUBLE", "FLOAT", "INTEGER", "LONG", 
-                "MAP", "TUPLE" };
+        String[] names = { "BAG", "BIGCHARARRAY", "BOOLEAN", "BYTE", "BYTEARRAY", "CHARARRAY", "DOUBLE", "FLOAT", "INTEGER",
+                "INTERNALMAP", "LONG", "MAP", "TUPLE" };
         return names;
     }
     
@@ -202,6 +206,7 @@ public class DataType {
         case BIGCHARARRAY: return "bigchararray";
         case CHARARRAY: return "chararray";
         case MAP:       return "map";
+        case INTERNALMAP: return "internalmap";
         case TUPLE:     return "tuple";
         case BAG:       return "bag";
         default: return "Unknown";
@@ -215,7 +220,7 @@ public class DataType {
      */
     public static boolean isComplex(byte dataType) {
         return ((dataType == BAG) || (dataType == TUPLE) ||
-            (dataType == MAP));
+            (dataType == MAP) || (dataType == INTERNALMAP));
     }
 
     /**
@@ -320,8 +325,8 @@ public class DataType {
                 return ((String)o1).compareTo((String)o2);
 
             case MAP: {
-                Map<Object, Object> m1 = (Map<Object, Object>)o1;
-                Map<Object, Object> m2 = (Map<Object, Object>)o2;
+                Map<String, Object> m1 = (Map<String, Object>)o1;
+                Map<String, Object> m2 = (Map<String, Object>)o2;
                 int sz1 = m1.size();
                 int sz2 = m2.size();
                 if (sz1 < sz2) {
@@ -331,16 +336,16 @@ public class DataType {
                 } else {
                     // This is bad, but we have to sort the keys of the maps in order
                     // to be commutative.
-                    TreeMap<Object, Object> tm1 = new TreeMap<Object, Object>(m1);
-                    TreeMap<Object, Object> tm2 = new TreeMap<Object, Object>(m2);
-                    Iterator<Map.Entry<Object, Object> > i1 =
+                    TreeMap<String, Object> tm1 = new TreeMap<String, Object>(m1);
+                    TreeMap<String, Object> tm2 = new TreeMap<String, Object>(m2);
+                    Iterator<Map.Entry<String, Object> > i1 =
                         tm1.entrySet().iterator();
-                    Iterator<Map.Entry<Object, Object> > i2 =
+                    Iterator<Map.Entry<String, Object> > i2 =
                         tm2.entrySet().iterator();
                     while (i1.hasNext()) {
-                        Map.Entry<Object, Object> entry1 = i1.next();
-                        Map.Entry<Object, Object> entry2 = i2.next();
-                        int c = compare(entry1.getKey(), entry2.getKey());
+                        Map.Entry<String, Object> entry1 = i1.next();
+                        Map.Entry<String, Object> entry2 = i2.next();
+                        int c = entry1.getKey().compareTo(entry2.getKey());
                         if (c != 0) {
                             return c;
                         } else {
@@ -354,6 +359,9 @@ public class DataType {
                 }
                       }
 
+            case INTERNALMAP:
+                return -1;  // Don't think anyway will want to do this.
+                
             case TUPLE:
                 return ((Tuple)o1).compareTo((Tuple)o2);
 
@@ -413,6 +421,7 @@ public class DataType {
 			    return null;
 
 			case MAP:
+			case INTERNALMAP:
 			case TUPLE:
 			case BAG:
 			case UNKNOWN:
@@ -489,6 +498,7 @@ public class DataType {
 			    return null;
 
 			case MAP:
+			case INTERNALMAP:
 			case TUPLE:
 			case BAG:
 			case UNKNOWN:
@@ -562,6 +572,7 @@ public class DataType {
 			case BOOLEAN:
 			case BYTE:
 			case MAP:
+			case INTERNALMAP:
 			case TUPLE:
 			case BAG:
 			case UNKNOWN:
@@ -634,6 +645,7 @@ public class DataType {
 			case BOOLEAN:
 			case BYTE:
 			case MAP:
+			case INTERNALMAP:
 			case TUPLE:
 			case BAG:
 			case UNKNOWN:
@@ -709,6 +721,7 @@ public class DataType {
 			    return ((Byte)o).toString();
 
 			case MAP:
+			case INTERNALMAP:
 			case TUPLE:
 			case BAG:
 			case UNKNOWN:
@@ -744,15 +757,15 @@ public class DataType {
      * This isn't particularly efficient, so if you
      * already <b>know</b> that the object you have is a Map you
      * should just cast it.
-     * @return The object as a Double.
+     * @return The object as a Map.
      * @throws ExecException if the type can't be forced to a Double.
      */
-    public static Map<Object, Object> toMap(Object o) throws ExecException {
+    public static Map<String, Object> toMap(Object o) throws ExecException {
         if (o == null) return null;
 
-        if (o instanceof Map) {
+        if (o instanceof Map && !(o instanceof InternalMap)) {
             try {
-				return (Map<Object, Object>)o;
+				return (Map<String, Object>)o;
     		} catch (Exception e) {
     			int errCode = 2054;
     			String msg = "Internal error. Could not convert " + o + " to Map.";
@@ -888,20 +901,21 @@ public class DataType {
         return DataType.ERROR ;
     }
     
-    public static String mapToString(Map<Object, Object> m) {
+    public static String mapToString(Map<String, Object> m) {
         boolean hasNext = false;
         StringBuilder sb = new StringBuilder();
         sb.append("[");
-        for(Object o: m.keySet()) {
+        for(String s: m.keySet()) {
             if(hasNext) {
                 sb.append(",");
             } else {
                 hasNext = true;
             }
-            sb.append(o.toString());
+            sb.append(s);
             sb.append("#");
-            if(m.get(o) != null) {
-                sb.append(m.get(o).toString());
+            Object val = m.get(s);
+            if(val != null) {
+                sb.append(val.toString());
             }
         }
         sb.append("]");
diff --git a/src/org/apache/pig/data/DefaultTuple.java b/src/org/apache/pig/data/DefaultTuple.java
index 9520c9bd5..1abb736ea 100644
--- a/src/org/apache/pig/data/DefaultTuple.java
+++ b/src/org/apache/pig/data/DefaultTuple.java
@@ -220,7 +220,7 @@ public class DefaultTuple implements Tuple {
             Object d = it.next();
             if(d != null) {
                 if(d instanceof Map) {
-                    sb.append(DataType.mapToString((Map<Object, Object>)d));
+                    sb.append(DataType.mapToString((Map<String, Object>)d));
                 } else {
                     sb.append(d.toString());
                     if(d instanceof Long) {
@@ -346,12 +346,12 @@ public class DefaultTuple implements Tuple {
                 return 8 + 12;
 
             case DataType.MAP: {
-                Map<Object, Object> m = (Map<Object, Object>)o;
-                Iterator<Map.Entry<Object, Object> > i =
+                Map<String, Object> m = (Map<String, Object>)o;
+                Iterator<Map.Entry<String, Object> > i =
                     m.entrySet().iterator();
                 long sum = 0;
                 while (i.hasNext()) {
-                    Map.Entry<Object, Object> entry = i.next();
+                    Map.Entry<String, Object> entry = i.next();
                     sum += getFieldMemorySize(entry.getKey());
                     sum += getFieldMemorySize(entry.getValue());
                 }
diff --git a/src/org/apache/pig/data/InternalMap.java b/src/org/apache/pig/data/InternalMap.java
new file mode 100644
index 000000000..b7eb93333
--- /dev/null
+++ b/src/org/apache/pig/data/InternalMap.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.data;
+
+import java.util.HashMap;
+
+/**
+ * This class is an empty extension of Map<Object, Object>.  It only
+ * exists so that DataType.findType() can distinguish an internal map
+ * type that maps object to object from an external map type that
+ * is string to object.
+ *
+ */
+public class InternalMap extends HashMap<Object, Object> {
+    
+	private static final long serialVersionUID = 1L;
+
+    public InternalMap() {
+        super();
+    }
+    
+    public InternalMap(int size) {
+        super(size);
+    }
+
+}
diff --git a/src/org/apache/pig/data/parser/TextDataParser.jjt b/src/org/apache/pig/data/parser/TextDataParser.jjt
index 6e83113ca..aca643116 100644
--- a/src/org/apache/pig/data/parser/TextDataParser.jjt
+++ b/src/org/apache/pig/data/parser/TextDataParser.jjt
@@ -124,9 +124,9 @@ Tuple Tuple() :
 	}
 }
 
-Map<Object, Object> Map() :
+Map<String, Object> Map() :
 {
-	Map<Object, Object> keyValues = new HashMap<Object, Object>();
+	Map<String, Object> keyValues = new HashMap<String, Object>();
 	log.trace("Entering Map");
 	
 }
@@ -138,14 +138,14 @@ Map<Object, Object> Map() :
 	}
 }
 
-void KeyValuePair(Map<Object, Object> keyValues) :
+void KeyValuePair(Map<String, Object> keyValues) :
 {
-	Object key = null;
+	String key = null;
 	Object value = null;
 	log.trace("Entering KeyValuePair");
 }
 {
-	(key = AtomDatum() "#" value = Datum())
+	(key = StringDatum() "#" value = Datum())
 	{
 		keyValues.put(key, value);
 		log.trace("Exiting KeyValuePair");
@@ -153,6 +153,24 @@ void KeyValuePair(Map<Object, Object> keyValues) :
 	
 }
 
+String StringDatum():
+{
+    String s = null;
+    Token t;
+    log.trace("Entering String");
+}
+{
+    (
+    t = <STRING> { s = t.image; }
+|	t = <NULL> {}
+    )
+    {
+        log.trace("Exiting String with " + t.image);
+        return s;
+    }
+}
+        
+
 Object AtomDatum():
 {
     Object obj = null;
diff --git a/src/org/apache/pig/impl/builtin/FindQuantiles.java b/src/org/apache/pig/impl/builtin/FindQuantiles.java
index 0957df676..4ff4d1d3a 100644
--- a/src/org/apache/pig/impl/builtin/FindQuantiles.java
+++ b/src/org/apache/pig/impl/builtin/FindQuantiles.java
@@ -38,6 +38,7 @@ import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.DefaultDataBag;
+import org.apache.pig.data.InternalMap;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.PigContext;
@@ -51,7 +52,7 @@ import org.apache.pig.impl.io.NullableTuple;
 import org.apache.pig.impl.io.PigNullableWritable;
 
 
-public class FindQuantiles extends EvalFunc<Map<Object, Object>>{
+public class FindQuantiles extends EvalFunc<Map<String, Object>>{
     // keys for the weightedparts Map
     public static final String QUANTILES_LIST = "quantiles.list";
     public static final String WEIGHTED_PARTS = "weighted.parts";
@@ -160,14 +161,14 @@ public class FindQuantiles extends EvalFunc<Map<Object, Object>>{
      */
     
     @Override
-    public Map<Object, Object> exec(Tuple in) throws IOException {
-        Map<Object, Object> output = new HashMap<Object, Object>();
+    public Map<String, Object> exec(Tuple in) throws IOException {
+        Map<String, Object> output = new HashMap<String, Object>();
         if(in==null || in.size()==0)
             return null;
         Integer numQuantiles = null;
         DataBag samples = null;
         ArrayList<Tuple> quantilesList = new ArrayList<Tuple>();
-        Map<Tuple,Tuple> weightedParts = new HashMap<Tuple, Tuple>();
+        InternalMap weightedParts = new InternalMap();
         // the sample file has a tuple as under:
         // (numQuantiles, bag of samples) 
         // numQuantiles here is the reduce parallelism
diff --git a/src/org/apache/pig/impl/logicalLayer/FrontendException.java b/src/org/apache/pig/impl/logicalLayer/FrontendException.java
index 579a02aa5..e4459d8d0 100644
--- a/src/org/apache/pig/impl/logicalLayer/FrontendException.java
+++ b/src/org/apache/pig/impl/logicalLayer/FrontendException.java
@@ -21,6 +21,9 @@ import org.apache.pig.PigException;
 
 public class FrontendException extends PigException {
 
+	// Change this if you modify the class.
+	static final long serialVersionUID = 1L;
+
     /**
      * Create a new FrontendException with null as the error message.
      */
@@ -154,4 +157,4 @@ public class FrontendException extends PigException {
         super(message, errCode, errSrc, retry, detailedMsg, cause);
     }
 
-}
\ No newline at end of file
+}
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java b/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
index a51b32269..3027cf538 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
@@ -36,7 +36,7 @@ public class LOMapLookup extends ExpressionOperator {
      * The key to lookup along with the type and schema corresponding to the
      * type and schema of the value linked to the key
      */
-    private Object mMapKey;
+    private String mMapKey;
     private byte mValueType;
     private Schema mValueSchema;
     private static Log log = LogFactory.getLog(LOMapLookup.class);
@@ -55,13 +55,12 @@ public class LOMapLookup extends ExpressionOperator {
      *            schema of the value if the type is tuple
      */
     public LOMapLookup(LogicalPlan plan, OperatorKey key,
-            Object mapKey, byte valueType, Schema valueSchema)
+            String mapKey, byte valueType, Schema valueSchema)
             throws ParseException {
         super(plan, key);
 
         if (!DataType.isAtomic(DataType.findType(mapKey))) {
-            throw new ParseException("Map key " + mapKey.toString()
-                    + " is not atomic");
+            throw new ParseException("Map key " + mapKey + " is not atomic");
         }
         mMapKey = mapKey;
         mValueType = valueType;
@@ -76,7 +75,7 @@ public class LOMapLookup extends ExpressionOperator {
         return (ExpressionOperator)preds.get(0);
     }
 
-    public Object getLookUpKey() {
+    public String getLookUpKey() {
         return mMapKey;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java b/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java
index a2ecfb0b4..ae59a75b1 100644
--- a/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java
+++ b/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java
@@ -54,7 +54,7 @@ public class RemoveRedundantOperators extends
      * @throws VisitorException
      */
     protected void visit(LOProject project) throws VisitorException {
-        LogicalPlan currentPlan = (LogicalPlan)mCurrentWalker.getPlan();
+        LogicalPlan currentPlan = mCurrentWalker.getPlan();
         
         //if the project is a project(*) and if there are predecessors 
         // and successors that are
@@ -119,7 +119,7 @@ public class RemoveRedundantOperators extends
             if(n instanceof LOProject){
                 LOProject lop = (LOProject)n;
                 if(current == lop.getExpression()){
-                    lop.setExpression((LogicalOperator)pred);
+                    lop.setExpression(pred);
                 }
             }
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
index 49b50e44a..d3df8704d 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
@@ -186,7 +186,7 @@ public class OpLimitOptimizer extends LogicalTransformer {
             	for (LogicalOperator prepredecessor:nodesToProcess)
             	{
             		try {
-            			newLimit = (LOLimit)limit.duplicate();
+            			newLimit = limit.duplicate();
             			insertBetween(prepredecessor, newLimit, predecessor, null);
             		} catch (Exception e) {
             		    int errCode = 2011;
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index ad330e2b4..928120a7b 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -2786,7 +2786,7 @@ ExpressionOperator BaseEvalSpec(Schema over, Map<String, LogicalOperator> specs,
 	ExpressionOperator projection; 
 	Schema subSchema = null; 
 	Token t; 
-    Object key = new Object();
+    String key;
 	log.trace("Entering BaseEvalSpec");
 }
 {
@@ -2815,7 +2815,7 @@ ExpressionOperator BaseEvalSpec(Schema over, Map<String, LogicalOperator> specs,
 				item = projection;
 			}
 		)
-|		( "#" key = AtomDatum() { 
+|		( "#" key = StringDatum() { 
 			assertAtomic(item, false);
 			ExpressionOperator mapLookup = new LOMapLookup(lp, new OperatorKey(scope, getNextId()), key, DataType.BYTEARRAY, null);
 			lp.add(mapLookup);
@@ -3461,9 +3461,9 @@ Tuple Tuple() :
 	}
 }
 
-Map<Object, Object> Map() :
+Map<String, Object> Map() :
 {
-	Map<Object, Object> keyValues = new HashMap<Object, Object>();
+	Map<String, Object> keyValues = new HashMap<String, Object>();
 	log.trace("Entering Map");
 	
 }
@@ -3475,14 +3475,14 @@ Map<Object, Object> Map() :
 	}
 }
 
-void KeyValuePair(Map<Object, Object> keyValues) :
+void KeyValuePair(Map<String, Object> keyValues) :
 {
-	Object key = null;
+	String key = null;
 	Object value = null;
 	log.trace("Entering KeyValuePair");
 }
 {
-	(key = AtomDatum() "#" value = Datum())
+	(key = StringDatum() "#" value = Datum())
 	{
 		if(key == null)
 		    throw new ParseException("key in a map cannot be null (provided input has '"+ key + "#" + value + "')");
@@ -3492,6 +3492,23 @@ void KeyValuePair(Map<Object, Object> keyValues) :
 	
 }
 
+String StringDatum():
+{
+    String s = null;
+    Token t;
+    log.trace("Entering String");
+}
+{
+    (
+    t = <QUOTEDSTRING> { s = unquote(t.image); }
+|   t = <NULL> {s = null;}
+    )
+    {
+        log.trace("Exiting String with " + t.image);
+        return s;
+    }
+}
+ 
 Object AtomDatum():
 {
     Object obj = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/schema/SchemaMergeException.java b/src/org/apache/pig/impl/logicalLayer/schema/SchemaMergeException.java
index e735a2d34..490f706bd 100644
--- a/src/org/apache/pig/impl/logicalLayer/schema/SchemaMergeException.java
+++ b/src/org/apache/pig/impl/logicalLayer/schema/SchemaMergeException.java
@@ -21,6 +21,9 @@ import org.apache.pig.impl.logicalLayer.FrontendException;
 
 public class SchemaMergeException extends FrontendException {
 
+	// Change this if you modify the class.
+	static final long serialVersionUID = 1L;
+
     /**
      * Create a new FrontendException with null as the error message.
      */
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index e04819f8f..71613bfa4 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -1007,7 +1007,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     private void insertCast(ExpressionOperator node,
                             byte toType, ExpressionOperator predecessor) 
     throws VisitorException {
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
+        LogicalPlan currentPlan = mCurrentWalker.getPlan() ;
         collectCastWarning(node, predecessor.getType(), toType);
 
         OperatorKey newKey = genNewOperatorKey(node);
@@ -2928,7 +2928,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private FuncSpec getLoadFuncSpec(ExpressionOperator exOp) throws FrontendException {
-        Schema.FieldSchema fs = ((ExpressionOperator)exOp).getFieldSchema();
+        Schema.FieldSchema fs = exOp.getFieldSchema();
         if(null == fs) {
             return null;
         }
diff --git a/src/org/apache/pig/impl/util/MultiMap.java b/src/org/apache/pig/impl/util/MultiMap.java
index 5216146ad..98bb82102 100644
--- a/src/org/apache/pig/impl/util/MultiMap.java
+++ b/src/org/apache/pig/impl/util/MultiMap.java
@@ -38,6 +38,9 @@ import java.util.Set;
  */
 public class MultiMap<K, V> implements Serializable {
 
+	// Change this if you modify the class.
+	static final long serialVersionUID = 1L;
+
     private HashMap<K, ArrayList<V>> mMap = null;
 
     public MultiMap() {
diff --git a/test/org/apache/pig/test/RangeSlicer.java b/test/org/apache/pig/test/RangeSlicer.java
index 26cdffdab..da85e300d 100644
--- a/test/org/apache/pig/test/RangeSlicer.java
+++ b/test/org/apache/pig/test/RangeSlicer.java
@@ -183,7 +183,7 @@ public class RangeSlicer
     /* (non-Javadoc)
      * @see org.apache.pig.LoadFunc#bytesToMap(byte[])
      */
-    public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
+    public Map<String, Object> bytesToMap(byte[] b) throws IOException {
         return null;
     }
 
diff --git a/test/org/apache/pig/test/TestAdd.java b/test/org/apache/pig/test/TestAdd.java
index e76d0cc3a..598630241 100644
--- a/test/org/apache/pig/test/TestAdd.java
+++ b/test/org/apache/pig/test/TestAdd.java
@@ -231,8 +231,8 @@ public class TestAdd extends TestCase{
                 break;
             }
             case DataType.MAP: {
-                Map<Integer,String> inpm1 = GenRandomData.genRandMap(r, 10);
-                Map<Integer,String> inpm2 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm1 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm2 = GenRandomData.genRandMap(r, 10);
                 lt.setValue(inpm1);
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
diff --git a/test/org/apache/pig/test/TestBuiltin.java b/test/org/apache/pig/test/TestBuiltin.java
index 18876fd39..9830f3bfd 100644
--- a/test/org/apache/pig/test/TestBuiltin.java
+++ b/test/org/apache/pig/test/TestBuiltin.java
@@ -1152,7 +1152,7 @@ public class TestBuiltin extends TestCase {
         
         // Map size
         String[] mapContents = new String[]{"key1", "value1", "key2", "value2"};
-        Map<Object, Object> map = Util.createMap(mapContents);
+        Map<String, Object> map = Util.createMap(mapContents);
         expected = new Long(2);
         t.set(0, map);
         size = new MapSize();
diff --git a/test/org/apache/pig/test/TestConstExpr.java b/test/org/apache/pig/test/TestConstExpr.java
index 3a2bd6cdd..a7a0e3b8d 100644
--- a/test/org/apache/pig/test/TestConstExpr.java
+++ b/test/org/apache/pig/test/TestConstExpr.java
@@ -138,7 +138,7 @@ public class TestConstExpr extends junit.framework.TestCase {
 
     @Test
     public void testGetNextMap() throws ExecException {
-        Map<Integer,String> inp = GenRandomData.genRandMap(r, 10);
+        Map<String,Object> inp = GenRandomData.genRandMap(r, 10);
         ce.setValue(inp);
         Result resm = ce.getNext(inp);
         Map<Integer,String> ret = (Map)resm.result;
diff --git a/test/org/apache/pig/test/TestConversions.java b/test/org/apache/pig/test/TestConversions.java
index 48bfd6fe6..7223c129e 100644
--- a/test/org/apache/pig/test/TestConversions.java
+++ b/test/org/apache/pig/test/TestConversions.java
@@ -174,9 +174,9 @@ public class TestConversions extends TestCase {
     {
         
         for (int i = 0; i < MAX; i++) {
-            Map<Object, Object>  m = GenRandomData.genRandObjectMap(r,5);
+            Map<String, Object>  m = GenRandomData.genRandMap(r,5);
             String expectedMapString = DataType.mapToString(m);
-            Map<Object, Object> convertedMap = ps.bytesToMap(expectedMapString.getBytes());
+            Map<String, Object> convertedMap = ps.bytesToMap(expectedMapString.getBytes());
             assertTrue(m.equals(convertedMap));
         }
         
@@ -227,7 +227,7 @@ public class TestConversions extends TestCase {
         
     @Test
     public void testMapToBytes() throws IOException {
-        Map<Object, Object>  m = GenRandomData.genRandObjectMap(r,5);
+        Map<String, Object>  m = GenRandomData.genRandMap(r,5);
         assertTrue(DataType.equalByteArrays(DataType.mapToString(m).getBytes(), ps.toBytes(m)));
     }
 }
diff --git a/test/org/apache/pig/test/TestDataModel.java b/test/org/apache/pig/test/TestDataModel.java
index 82869da2c..2e3e4087c 100644
--- a/test/org/apache/pig/test/TestDataModel.java
+++ b/test/org/apache/pig/test/TestDataModel.java
@@ -182,7 +182,7 @@ public class TestDataModel extends junit.framework.TestCase {
 
             o = after.get(2);
             assertTrue("isa Map", o instanceof Map);
-            Map<Object, Object> m = (Map<Object, Object>)o;
+            Map<String, Object> m = (Map<String, Object>)o;
             assertEquals("world", (String)m.get("hello"));
             assertEquals("all", (String)m.get("goodbye"));
             assertNull(m.get("fred"));
@@ -226,6 +226,42 @@ public class TestDataModel extends junit.framework.TestCase {
         file.delete();
     }
 
+    @Test
+    public void testReadWriteInternal() throws Exception {
+        // Create a tuple with every internal data type in it, and then read and
+        // write it, both via DataReaderWriter and Tuple.readFields
+        TupleFactory tf = TupleFactory.getInstance();
+
+        Tuple t1 = tf.newTuple(1);
+
+        InternalMap map = new InternalMap(2);
+        map.put(new Integer(1), new String("world"));
+        map.put(new Long(3L), new String("all"));
+        t1.set(0, map);
+
+        File file = File.createTempFile("Tuple", "put");
+        FileOutputStream fos = new FileOutputStream(file);
+        DataOutput out = new DataOutputStream(fos);
+        t1.write(out);
+        fos.close();
+
+        FileInputStream fis = new FileInputStream(file);
+        DataInput in = new DataInputStream(fis);
+ 
+        Tuple after = tf.newTuple();
+        after.readFields(in);
+
+        Object o = after.get(0);
+        assertTrue("isa InternalMap", o instanceof InternalMap);
+        
+        InternalMap m = (InternalMap)o;
+        assertEquals("world", (String)m.get(new Integer(1)));
+        assertEquals("all", (String)m.get(new Long(3L)));
+        assertNull(m.get("fred"));
+
+        file.delete();
+    }
+
     @Test
     public void testTupleToString() throws Exception {
         Tuple t = giveMeOneOfEach();
@@ -522,7 +558,7 @@ public class TestDataModel extends junit.framework.TestCase {
         bag.add(tf.newTuple(new Integer(4)));
         bag.add(tf.newTuple(new String("mary had a little lamb")));
 
-        Map<Object, Object> map = new HashMap<Object, Object>(2);
+        Map<String, Object> map = new HashMap<String, Object>(2);
         map.put(new String("hello"), new String("world"));
         map.put(new String("goodbye"), new String("all"));
 
diff --git a/test/org/apache/pig/test/TestDivide.java b/test/org/apache/pig/test/TestDivide.java
index f267ad29d..cc9df70bf 100644
--- a/test/org/apache/pig/test/TestDivide.java
+++ b/test/org/apache/pig/test/TestDivide.java
@@ -251,8 +251,8 @@ public class TestDivide extends TestCase{
                 break;
             }
             case DataType.MAP: {
-                Map<Integer,String> inpm1 = GenRandomData.genRandMap(r, 10);
-                Map<Integer,String> inpm2 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm1 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm2 = GenRandomData.genRandMap(r, 10);
                 lt.setValue(inpm1);
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
diff --git a/test/org/apache/pig/test/TestEvalPipeline.java b/test/org/apache/pig/test/TestEvalPipeline.java
index c1bd37d7d..556e7aade 100644
--- a/test/org/apache/pig/test/TestEvalPipeline.java
+++ b/test/org/apache/pig/test/TestEvalPipeline.java
@@ -147,11 +147,11 @@ public class TestEvalPipeline extends TestCase {
     @Test
     public void testMapLookup() throws Exception {
         DataBag b = BagFactory.getInstance().newDefaultBag();
-        Map<Object, Object> colors = new HashMap<Object, Object>();
+        Map<String, Object> colors = new HashMap<String, Object>();
         colors.put("apple","red");
         colors.put("orange","orange");
         
-        Map<Object, Object> weights = new HashMap<Object, Object>();
+        Map<String, Object> weights = new HashMap<String, Object>();
         weights.put("apple","0.1");
         weights.put("orange","0.3");
         
@@ -244,9 +244,9 @@ public class TestEvalPipeline extends TestCase {
         }
     }
 
-    static public class MapUDF extends EvalFunc<Map<Object, Object>> {
+    static public class MapUDF extends EvalFunc<Map<String, Object>> {
         @Override
-        public Map<Object, Object> exec(Tuple input) throws IOException {
+        public Map<String, Object> exec(Tuple input) throws IOException {
 
             TupleFactory tupleFactory = TupleFactory.getInstance();
             ArrayList<Object> objList = new ArrayList<Object>();
@@ -260,11 +260,11 @@ public class TestEvalPipeline extends TestCase {
             DataBag bag = bagFactory.newDefaultBag();
             bag.add(tuple);
 
-            Map<Object, Object> mapInMap = new HashMap<Object, Object>();
+            Map<String, Object> mapInMap = new HashMap<String, Object>();
             mapInMap.put("int", new Integer(10));
             mapInMap.put("float", new Float(10.0));
 
-            Map<Object, Object> myMap = new HashMap<Object, Object>();
+            Map<String, Object> myMap = new HashMap<String, Object>();
             myMap.put("string", new String("Hello"));
             myMap.put("int", new Integer(1));
             myMap.put("long", new Long(1));
@@ -758,7 +758,7 @@ public class TestEvalPipeline extends TestCase {
             assertEquals(new Integer(10), (Integer)t.get(3));
             assertEquals(1, ((DataBag)t.get(4)).size());
             assertEquals(4, ((Tuple)t.get(5)).size());
-            assertEquals(2, ((Map<Object, Object>)t.get(6)).size());
+            assertEquals(2, ((Map<String, Object>)t.get(6)).size());
             assertEquals(DataByteArray.class, t.get(7).getClass());
             assertEquals(8, t.size());
             ++numIdentity;
diff --git a/test/org/apache/pig/test/TestEvalPipelineLocal.java b/test/org/apache/pig/test/TestEvalPipelineLocal.java
index badf7f538..af1ddff06 100644
--- a/test/org/apache/pig/test/TestEvalPipelineLocal.java
+++ b/test/org/apache/pig/test/TestEvalPipelineLocal.java
@@ -156,11 +156,11 @@ public class TestEvalPipelineLocal extends TestCase {
     @Test
     public void testMapLookup() throws Exception {
         DataBag b = BagFactory.getInstance().newDefaultBag();
-        Map<Object, Object> colors = new HashMap<Object, Object>();
+        Map<String, Object> colors = new HashMap<String, Object>();
         colors.put("apple","red");
         colors.put("orange","orange");
         
-        Map<Object, Object> weights = new HashMap<Object, Object>();
+        Map<String, Object> weights = new HashMap<String, Object>();
         weights.put("apple","0.1");
         weights.put("orange","0.3");
         
@@ -253,9 +253,9 @@ public class TestEvalPipelineLocal extends TestCase {
         }
     }
 
-    static public class MapUDF extends EvalFunc<Map<Object, Object>> {
+    static public class MapUDF extends EvalFunc<Map<String, Object>> {
         @Override
-        public Map<Object, Object> exec(Tuple input) throws IOException {
+        public Map<String, Object> exec(Tuple input) throws IOException {
 
             TupleFactory tupleFactory = TupleFactory.getInstance();
             ArrayList<Object> objList = new ArrayList<Object>();
@@ -269,11 +269,11 @@ public class TestEvalPipelineLocal extends TestCase {
             DataBag bag = bagFactory.newDefaultBag();
             bag.add(tuple);
 
-            Map<Object, Object> mapInMap = new HashMap<Object, Object>();
+            Map<String, Object> mapInMap = new HashMap<String, Object>();
             mapInMap.put("int", new Integer(10));
             mapInMap.put("float", new Float(10.0));
 
-            Map<Object, Object> myMap = new HashMap<Object, Object>();
+            Map<String, Object> myMap = new HashMap<String, Object>();
             myMap.put("string", new String("Hello"));
             myMap.put("int", new Integer(1));
             myMap.put("long", new Long(1));
@@ -773,7 +773,7 @@ public class TestEvalPipelineLocal extends TestCase {
             assertEquals(new Integer(10), (Integer)t.get(3));
             assertEquals(1, ((DataBag)t.get(4)).size());
             assertEquals(4, ((Tuple)t.get(5)).size());
-            assertEquals(2, ((Map<Object, Object>)t.get(6)).size());
+            assertEquals(2, ((Map<String, Object>)t.get(6)).size());
             assertEquals(DataByteArray.class, t.get(7).getClass());
             assertEquals(8, t.size());
             ++numIdentity;
diff --git a/test/org/apache/pig/test/TestLocal.java b/test/org/apache/pig/test/TestLocal.java
index 1793c8db3..9823af797 100644
--- a/test/org/apache/pig/test/TestLocal.java
+++ b/test/org/apache/pig/test/TestLocal.java
@@ -233,8 +233,8 @@ public class TestLocal extends TestCase {
             return "";
         }
 
-        public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
-            return new HashMap<Object, Object>();
+        public Map<String, Object> bytesToMap(byte[] b) throws IOException {
+            return new HashMap<String, Object>();
         }
 
         public Tuple bytesToTuple(byte[] b) throws IOException {
@@ -271,7 +271,7 @@ public class TestLocal extends TestCase {
             return l.toString().getBytes();
         }
     
-        public byte[] toBytes(Map<Object, Object> m) throws IOException {
+        public byte[] toBytes(Map<String, Object> m) throws IOException {
             return m.toString().getBytes();
         }
     
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index 0b8f77858..5d3179196 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -422,7 +422,7 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
             return null;
         }
 
-        public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
+        public Map<String, Object> bytesToMap(byte[] b) throws IOException {
             return null;
         }
 
@@ -454,7 +454,7 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
             return null;
 	    }
 	
-	    public byte[] toBytes(Map<Object, Object> m) throws IOException {
+	    public byte[] toBytes(Map<String, Object> m) throws IOException {
             return null;
 	    }
 	
@@ -875,8 +875,8 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
     @Test
     public void testQuery70() {
         buildPlan(" a = load 'input1';");
-        buildPlan(" b = foreach a generate [10L#'hello', 4.0e-2#10L, 0.5f#(1), 'world'#42, 42#{('guide')}] as mymap:map[];");
-        buildPlan(" c = foreach b generate mymap#10L;");
+        buildPlan(" b = foreach a generate ['10'#'hello', '4.0e-2'#10L, '0.5f'#(1), 'world'#42, '42'#{('guide')}] as mymap:map[];");
+        buildPlan(" c = foreach b generate mymap#'10';");
     }
 
     @Test
diff --git a/test/org/apache/pig/test/TestMapReduce.java b/test/org/apache/pig/test/TestMapReduce.java
index 166a2ee96..10223a3f8 100644
--- a/test/org/apache/pig/test/TestMapReduce.java
+++ b/test/org/apache/pig/test/TestMapReduce.java
@@ -258,8 +258,8 @@ public class TestMapReduce extends TestCase {
             return "";
         }
 
-        public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
-            return new HashMap<Object, Object>();
+        public Map<String, Object> bytesToMap(byte[] b) throws IOException {
+            return new HashMap<String, Object>();
         }
 
         public Tuple bytesToTuple(byte[] b) throws IOException {
@@ -296,7 +296,7 @@ public class TestMapReduce extends TestCase {
 	        return l.toString().getBytes();
 	    }
 	
-	    public byte[] toBytes(Map<Object, Object> m) throws IOException {
+	    public byte[] toBytes(Map<String, Object> m) throws IOException {
 	        return m.toString().getBytes();
 	    }
 	
diff --git a/test/org/apache/pig/test/TestMod.java b/test/org/apache/pig/test/TestMod.java
index c2fa0b280..031c0e15a 100644
--- a/test/org/apache/pig/test/TestMod.java
+++ b/test/org/apache/pig/test/TestMod.java
@@ -229,8 +229,8 @@ public class TestMod extends TestCase{
                 break;
             }
             case DataType.MAP: {
-                Map<Integer,String> inpm1 = GenRandomData.genRandMap(r, 10);
-                Map<Integer,String> inpm2 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm1 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm2 = GenRandomData.genRandMap(r, 10);
                 lt.setValue(inpm1);
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
diff --git a/test/org/apache/pig/test/TestMultiply.java b/test/org/apache/pig/test/TestMultiply.java
index 274c1ca9b..fd19cb9a3 100644
--- a/test/org/apache/pig/test/TestMultiply.java
+++ b/test/org/apache/pig/test/TestMultiply.java
@@ -231,8 +231,8 @@ public class TestMultiply extends TestCase{
                 break;
             }
             case DataType.MAP: {
-                Map<Integer,String> inpm1 = GenRandomData.genRandMap(r, 10);
-                Map<Integer,String> inpm2 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm1 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm2 = GenRandomData.genRandMap(r, 10);
                 lt.setValue(inpm1);
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
diff --git a/test/org/apache/pig/test/TestNullConstant.java b/test/org/apache/pig/test/TestNullConstant.java
index a0e8732c0..bf7b89a93 100644
--- a/test/org/apache/pig/test/TestNullConstant.java
+++ b/test/org/apache/pig/test/TestNullConstant.java
@@ -145,8 +145,9 @@ public class TestNullConstant extends TestCase {
         pigServer.registerQuery("b = foreach a generate {(null)}, ['2'#null];");
         Iterator<Tuple> it = pigServer.openIterator("b");
         Tuple t = it.next();
+System.out.println("tuple: " + t);
         assertEquals(null, ((DataBag)t.get(0)).iterator().next().get(0));
-        assertEquals(null, ((Map<Object, Object>)t.get(1)).get("2"));
+        assertEquals(null, ((Map<String, Object>)t.get(1)).get("2"));
         
     }
 
diff --git a/test/org/apache/pig/test/TestPOCast.java b/test/org/apache/pig/test/TestPOCast.java
index a1d1ecb04..72b63cc29 100644
--- a/test/org/apache/pig/test/TestPOCast.java
+++ b/test/org/apache/pig/test/TestPOCast.java
@@ -947,7 +947,7 @@ public class TestPOCast extends TestCase {
             return new Long(Long.valueOf(new DataByteArray(b).toString()));
         }
 
-        public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
+        public Map<String, Object> bytesToMap(byte[] b) throws IOException {
           return null;
         }
 
@@ -979,10 +979,10 @@ public class TestPOCast extends TestCase {
             return l.toString().getBytes();
         }
         
-        public byte[] toBytes(Map<Object, Object> m) throws IOException {
-            return null;
-        }
-        
+	    public byte[] toBytes(Map<String, Object> m) throws IOException {
+	        return null;
+	    }
+	
         public byte[] toBytes(Tuple t) throws IOException {
             return null;
         }
@@ -1295,12 +1295,12 @@ public class TestPOCast extends TestCase {
             POCast newOp = new POCast(new OperatorKey("", r.nextLong()), -1);
             plan = constructPlan(newOp);
             Tuple t = tf.newTuple();
-            Map<Object, Object> input = new HashMap<Object, Object>();
+            Map<String, Object> input = new HashMap<String, Object>();
             input.put("key1", "value1");
             input.put("key2", "value2");
             t.append(input);
             plan.attachInput(t);
-            Result res = newOp.getNext(new HashMap<Object, Object>());
+            Result res = newOp.getNext(new HashMap<String, Object>());
             if(res.returnStatus == POStatus.STATUS_OK) {
                 //System.out.println(res.result + " : " + str);
                 assertEquals(input, res.result);
@@ -1637,7 +1637,7 @@ public class TestPOCast extends TestCase {
 		
 		{
 			Tuple t = tf.newTuple();
-			t.append(GenRandomData.genRandObjectMap(r, 10));
+			t.append(GenRandomData.genRandMap(r, 10));
 			plan.attachInput(t);
 			DataByteArray i = null;
 			Result res = op.getNext(i);
diff --git a/test/org/apache/pig/test/TestPOMapLookUp.java b/test/org/apache/pig/test/TestPOMapLookUp.java
index ea548daf2..3ed090059 100644
--- a/test/org/apache/pig/test/TestPOMapLookUp.java
+++ b/test/org/apache/pig/test/TestPOMapLookUp.java
@@ -37,7 +37,7 @@ import junit.framework.TestCase;
 public class TestPOMapLookUp extends TestCase {
 	
 	Random r = new Random();
-	Map<Integer, String> map;// = GenRandomData.genRandMap(r, 10);
+	Map<String, Object> map;// = GenRandomData.genRandMap(r, 10);
 	
 	@Test
 	public void testMapLookUp() throws PlanException, ExecException {
@@ -53,7 +53,7 @@ public class TestPOMapLookUp extends TestCase {
 			map = GenRandomData.genRandMap(r, 10);
 			Tuple t = TupleFactory.getInstance().newTuple();
 			t.append(map);
-			for(Map.Entry<Integer, String> e : map.entrySet()) {
+			for(Map.Entry<String, Object> e : map.entrySet()) {
 				op.setLookUpKey(e.getKey());
 				plan.attachInput(t);
 				Result res = op.getNext(map);
diff --git a/test/org/apache/pig/test/TestPackage.java b/test/org/apache/pig/test/TestPackage.java
index 25ca3b015..7fa967e8c 100644
--- a/test/org/apache/pig/test/TestPackage.java
+++ b/test/org/apache/pig/test/TestPackage.java
@@ -149,6 +149,7 @@ public class TestPackage extends junit.framework.TestCase {
             runTest(r.nextLong(),inner);
             break;
         case DataType.MAP:
+        case DataType.INTERNALMAP:
         case DataType.BYTE:
             return; // map not key type
         case DataType.TUPLE:
diff --git a/test/org/apache/pig/test/TestSubtract.java b/test/org/apache/pig/test/TestSubtract.java
index c45a0e4f3..c302f3a23 100644
--- a/test/org/apache/pig/test/TestSubtract.java
+++ b/test/org/apache/pig/test/TestSubtract.java
@@ -231,8 +231,8 @@ public class TestSubtract extends TestCase{
                 break;
             }
             case DataType.MAP: {
-                Map<Integer,String> inpm1 = GenRandomData.genRandMap(r, 10);
-                Map<Integer,String> inpm2 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm1 = GenRandomData.genRandMap(r, 10);
+                Map<String,Object> inpm2 = GenRandomData.genRandMap(r, 10);
                 lt.setValue(inpm1);
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
diff --git a/test/org/apache/pig/test/Util.java b/test/org/apache/pig/test/Util.java
index af3ae0e4f..1ae56a53e 100644
--- a/test/org/apache/pig/test/Util.java
+++ b/test/org/apache/pig/test/Util.java
@@ -150,9 +150,9 @@ public class Util {
         return result;
     }
     
-    static public Map<Object, Object> createMap(String[] contents)
+    static public Map<String, Object> createMap(String[] contents)
     {
-        Map<Object, Object> m = new HashMap<Object, Object>();
+        Map<String, Object> m = new HashMap<String, Object>();
         for(int i = 0; i < contents.length; ) {
             m.put(contents[i], contents[i+1]);
             i += 2;
diff --git a/test/org/apache/pig/test/utils/GenRandomData.java b/test/org/apache/pig/test/utils/GenRandomData.java
index d68daac49..593928e48 100644
--- a/test/org/apache/pig/test/utils/GenRandomData.java
+++ b/test/org/apache/pig/test/utils/GenRandomData.java
@@ -30,26 +30,14 @@ import org.apache.pig.data.Tuple;
 public class GenRandomData {
     
     
-    public static Map<Integer,String> genRandMap(Random r, int numEnt) {
-        Map<Integer,String> ret = new HashMap<Integer, String>();
+    public static Map<String, Object> genRandMap(Random r, int numEnt) {
+        Map<String,Object> ret = new HashMap<String, Object>();
         if(r==null){
-            ret.put(1, "RANDOM");
+            ret.put("random", "RANDOM");
             return ret;
         }
         for(int i=0;i<numEnt;i++){
-            ret.put(r.nextInt(), genRandString(r));
-        }
-        return ret;
-    }
-    
-    public static Map<Object,Object> genRandObjectMap(Random r, int numEnt) {
-        Map<Object,Object> ret = new HashMap<Object, Object>();
-        if(r==null){
-            ret.put(1, "RANDOM");
-            return ret;
-        }
-        for(int i=0;i<numEnt;i++){
-            ret.put(r.nextInt(), genRandString(r));
+            ret.put(genRandString(r), genRandString(r));
         }
         return ret;
     }
