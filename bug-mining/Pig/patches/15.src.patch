diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index ddefcabf0..92036a978 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -1374,14 +1374,14 @@ void NestedCommand(Schema over, Map<String, LogicalOperator> specs, List<Logical
 {
 	Token t; 
 	LogicalOperator item; 
-	ExpressionOperator eOp = null; 
+	LogicalOperator eOp = null; 
 	log.trace("Entering NestedCommand");
 }
 {
 	(
 	t = <IDENTIFIER> "="
 	(
-	eOp = InfixExpr(over,specs,lp,input) 
+	eOp = NestedProject(over,specs,lp,input) 
 	{
 		item = eOp;
 		lp.add(eOp);
@@ -1404,6 +1404,75 @@ void NestedCommand(Schema over, Map<String, LogicalOperator> specs, List<Logical
 	}
 }		
 
+LogicalOperator NestedProject(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
+{
+    Token t;
+	ArrayList<Integer> colList = new ArrayList<Integer>();
+    int i = -1;
+    LogicalOperator foreachInput = null;
+    Schema subSchema = null;
+	log.trace("Entering NestedFilter");
+}
+{
+    (
+	t = <IDENTIFIER> 
+    {
+        if(null != specs) {
+            foreachInput = specs.get(t.image);
+        }
+        if(null == foreachInput) {
+			if ((null == over) ||  (i = over.getPosition(t.image)) == -1) {
+				throw new ParseException("Invalid alias: " + t.image + " in " + over);
+			}
+            foreachInput = new LOProject(lp, new OperatorKey(scope, getNextId()), input, i);
+        }
+
+        try {
+            lp.add(foreachInput);
+            if(input instanceof ExpressionOperator) {
+                lp.add(input);
+                lp.connect(input, foreachInput);
+            }
+        } catch (Exception planException) {
+            ParseException parseException = new ParseException(planException.getMessage());
+            throw parseException;
+        }
+    }
+|   t = <DOLLARVAR>
+    {
+        foreachInput = new LOProject(lp, new OperatorKey(scope, getNextId()), input, undollar(t.image));
+    }
+    )
+    {
+        if(foreachInput instanceof ExpressionOperator) {
+            subSchema = ((ExpressionOperator)foreachInput).getFieldSchema().schema;
+        } else {
+            subSchema = foreachInput.getSchema();
+        }
+    }
+    "." 
+    (
+    i = ColName(subSchema) {colList.add(i);}
+|   "(" i = ColName(subSchema) {colList.add(i);} ("," i = ColName(over) {colList.add(i);})* ")"
+    )
+    {
+        ArrayList<LogicalPlan> foreachPlans = new ArrayList<LogicalPlan>();
+        ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
+        for(int j: colList) {
+            LogicalPlan plan = new LogicalPlan();
+            LOProject project = new LOProject(plan, new OperatorKey(scope, getNextId()), foreachInput, j);
+            plan.add(project);
+            foreachPlans.add(plan);
+            flattenList.add(false);
+        }
+		LogicalOperator foreach = new LOForEach(lp, new OperatorKey(scope, getNextId()), foreachPlans, flattenList);
+        lp.add(foreach);
+        lp.add(foreachInput);
+        lp.connect(foreachInput, foreach);
+        return foreach;
+    }
+}
+
 LogicalOperator NestedFilter(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input):
 {
 	ExpressionOperator cond; 
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index f48131a1f..829061f65 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -923,7 +923,7 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
             + "generate group, flatten(co);"
             //+ "generate group, flatten(cd);"
             + "};";
-        printPlan(buildPlan(query));
+        buildPlan(query);
     }
 
     @Test
@@ -942,6 +942,63 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         }
     }
     
+    @Test
+    public void testQuery82() {
+        buildPlan("a = load 'myfile';");
+        buildPlan("b = group a by $0;"); 
+        String query = "c = foreach b {"
+            + "c1 = order $1 by *;" 
+            + "c2 = $1.$0;" 
+            + "generate flatten(c1), c2;"
+            + "};";
+        buildPlan(query);
+    }
+
+    @Test
+    public void testQueryFail82() {
+        buildPlan("a = load 'myfile';");
+        buildPlan("b = group a by $0;"); 
+        String query = "c = foreach b {"
+            + "c1 = order $1 by *;" 
+            + "c2 = $1;" 
+            + "generate flatten(c1), c2;"
+            + "};";
+        try {
+        buildPlan(query);
+        } catch (AssertionFailedError e) {
+            assertTrue(e.getMessage().contains("Exception"));
+        }
+    }
+
+    @Test
+    public void testQuery83() {
+        buildPlan("a = load 'input1' as (name, age, gpa);");
+        buildPlan("b = filter a by age < '20';");
+        buildPlan("c = group b by (name,age);");
+        String query = "d = foreach c {" 
+            + "cf = filter b by gpa < '3.0';"
+            + "cp = cf.gpa;"
+            + "cd = distinct cp;"
+            + "co = order cd by gpa;"
+            + "generate group, flatten(co);"
+            + "};";
+        buildPlan(query);
+    }
+
+    @Test
+    public void testQuery84() {
+        buildPlan("a = load 'input1' as (name, age, gpa);");
+        buildPlan("b = filter a by age < '20';");
+        buildPlan("c = group b by (name,age);");
+        String query = "d = foreach c {"
+            + "cf = filter b by gpa < '3.0';"
+            + "cp = cf.$2;"
+            + "cd = distinct cp;"
+            + "co = order cd by gpa;"
+            + "generate group, flatten(co);"
+            + "};";
+        buildPlan(query);
+    }
     
     private void printPlan(LogicalPlan lp) {
         LOPrinter graphPrinter = new LOPrinter(System.err, lp);
