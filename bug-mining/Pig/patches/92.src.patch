diff --git a/CHANGES.txt b/CHANGES.txt
index a07a8ada4..10d895929 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -227,3 +227,6 @@ Trunk (unreleased changes)
 
     PIG-411: Pig leaves HOD processes behind if Ctrl-C is used before HOD
     connection is fully established (olgan)
+
+    PIG-430: Projections in nested filter and inside foreach do not work (sms
+    via olgan)
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index fb345a02a..5c215034f 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -66,6 +66,7 @@ public class QueryParser {
 	//a map of alias to logical operator for a quick lookup
 	private Map<String, LogicalOperator> mapAliasOp;
 	private static Log log = LogFactory.getLog(QueryParser.class);
+	private boolean bracketed = false;
 	
 	private long getNextId() {
 		return nodeIdGen.getNextNodeId(scope);
@@ -2084,11 +2085,12 @@ LogicalOperator NestedFilter(Schema over, Map<String, LogicalOperator> specs, Lo
 	(
 	<FILTER>
     (
-    LOOKAHEAD({ null != specs.get(getToken(1).image) }) t = <IDENTIFIER> {eOp = specs.get(t.image);}
+    LOOKAHEAD(NestedProject(over, specs, lp, input)) eOp = NestedProject(over, specs, lp, input)
+|   LOOKAHEAD({ null != specs.get(getToken(1).image) }) t = <IDENTIFIER> {eOp = specs.get(t.image);}
 |   eOp = BaseEvalSpec(over, specs, lp, input)
     )
 	{subSchema = eOp.getSchema();}
-	<BY> cond = PCond(subSchema,null,conditionPlan,input)
+	<BY> cond = PCond(subSchema,null,conditionPlan,eOp)
 	)
 	{ 
 		lp.add(eOp);
@@ -2122,7 +2124,8 @@ LogicalOperator NestedSortOrArrange(Schema over, Map<String, LogicalOperator> sp
 	(
 	( <ORDER> | <ARRANGE> )
     (
-    LOOKAHEAD({ null != specs.get(getToken(1).image) }) t = <IDENTIFIER> {eOp = specs.get(t.image);}
+    LOOKAHEAD(NestedProject(over, specs, lp, input)) eOp = NestedProject(over, specs, lp, input)
+|   LOOKAHEAD({ null != specs.get(getToken(1).image) }) t = <IDENTIFIER> {eOp = specs.get(t.image);}
 |   eOp = BaseEvalSpec(over, specs, lp, input)
     )
 	<BY> 
@@ -2184,7 +2187,8 @@ LogicalOperator NestedDistinct(Schema over, Map<String, LogicalOperator> specs,
 	(
 	<DISTINCT>
     (
-    LOOKAHEAD({ null != specs.get(getToken(1).image) }) t = <IDENTIFIER> {eOp = specs.get(t.image);}
+    LOOKAHEAD(NestedProject(over, specs, lp, input)) eOp = NestedProject(over, specs, lp, input)
+|   LOOKAHEAD({ null != specs.get(getToken(1).image) }) t = <IDENTIFIER> {eOp = specs.get(t.image);}
 |   eOp = BaseEvalSpec(over, specs, lp, input)
     )
 	)
@@ -2981,7 +2985,8 @@ ExpressionOperator BracketedSimpleProj(Schema over, LogicalPlan lp, LogicalOpera
 	int i; 
 	ExpressionOperator spec = null;
 	log.trace("Entering BracketedSimpleProj");
-	log.debug("eOp: " + eOp.getClass().getName());
+	log.debug("eOp: " + eOp);
+	bracketed = true;
 }
 {
 	(
@@ -2989,7 +2994,7 @@ ExpressionOperator BracketedSimpleProj(Schema over, LogicalPlan lp, LogicalOpera
 |	("(" spec = SimpleProj(over,lp,eOp) ")")	
 	
 	)
-	{log.trace("Exiting BracketedSimpleProj");return spec;}	
+	{log.trace("Exiting BracketedSimpleProj");bracketed=false; return spec;}	
 }
 
 ExpressionOperator SimpleProj(Schema over, LogicalPlan lp, LogicalOperator eOp): 
@@ -3189,7 +3194,7 @@ ExpressionOperator DollarVar(Schema over, Map<String, LogicalOperator> specs, Lo
 			log.debug("eOp: " + eOp.getClass().getName() + " " + eOp);
 			lp.add(project);
 			log.debug("DollarVar: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
-            if(eOp instanceof ExpressionOperator) {
+            if((eOp instanceof ExpressionOperator) && (bracketed)) {
 			    lp.add(eOp);
 			    lp.connect(eOp, project);
             }
@@ -3273,7 +3278,7 @@ ExpressionOperator AliasFieldOrSpec(Schema over, Map<String, LogicalOperator> sp
 			try {
 				lp.add(item);
 				log.debug("AliasFieldOrSpec: Added operator " + item.getClass().getName() + " " + item + " to logical plan " + lp);
-                if(eOp instanceof ExpressionOperator) {
+                if((eOp instanceof ExpressionOperator) && (bracketed)) {
 				    lp.add(eOp);
 				    lp.connect(eOp, item);
                 }
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index 2af99cdb9..a625ef875 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -26,6 +26,7 @@ import java.util.Map;
 import java.util.Properties;
 import java.net.URL;
 import java.util.List;
+import java.util.ArrayList;
 import java.util.Set;
 
 import junit.framework.AssertionFailedError;
@@ -1366,6 +1367,46 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("name: bytearray, age: bytearray, gpa: bytearray, max_age: double"), false, true));
     }
 
+    @Test
+    public void testQuery96() throws FrontendException, ParseException {
+        buildPlan("a = load 'input' as (name, age, gpa);");
+        buildPlan("b = filter a by age < 20;");
+        buildPlan("c = group b by age;");
+        String query = "d = foreach c {"
+        + "cf = filter b by gpa < 3.0;"
+        + "cd = distinct cf.gpa;"
+        + "co = order cd by $0;"
+        + "generate group, flatten(co);"
+        + "};";
+        LogicalPlan lp = buildPlan(query);
+
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ArrayList<LogicalPlan> foreachPlans = foreach.getForEachPlans();
+        LogicalPlan flattenPlan = foreachPlans.get(1);
+        LogicalOperator project = flattenPlan.getLeaves().get(0);
+        assertTrue(project instanceof LOProject);
+        LogicalOperator sort = flattenPlan.getPredecessors(project).get(0);
+        assertTrue(sort instanceof LOSort);
+        LogicalOperator distinct = flattenPlan.getPredecessors(sort).get(0);
+        assertTrue(distinct instanceof LODistinct);
+
+        //testing the presence of the nested foreach
+        LogicalOperator nestedForeach = flattenPlan.getPredecessors(distinct).get(0);
+        assertTrue(nestedForeach instanceof LOForEach);
+        LogicalPlan nestedForeachPlan = ((LOForEach)nestedForeach).getForEachPlans().get(0);
+        LogicalOperator nestedProject = nestedForeachPlan.getRoots().get(0);
+        assertTrue(nestedProject instanceof LOProject);
+        assertTrue(((LOProject)nestedProject).getCol() == 2);
+
+        //testing the filter inner plan for the absence of the project connected to project
+        LogicalOperator filter = flattenPlan.getPredecessors(nestedForeach).get(0);
+        assertTrue(filter instanceof LOFilter);
+        LogicalPlan comparisonPlan = ((LOFilter)filter).getComparisonPlan();
+        LOLesserThan lessThan = (LOLesserThan)comparisonPlan.getLeaves().get(0);
+        LOProject filterProject = (LOProject)lessThan.getLhsOperand();
+        assertTrue(null == comparisonPlan.getPredecessors(filterProject));
+    }
+
     private Schema getSchemaFromString(String schemaString) throws ParseException {
         return getSchemaFromString(schemaString, DataType.BYTEARRAY);
     }
diff --git a/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld b/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld
index 6bd09fba4..8d9d62802 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld
@@ -6,9 +6,9 @@ New For Each(false)[bag] - Test-Plan-Builder-16
 |       |   |
 |       |   Equal To[boolean] - Test-Plan-Builder-14
 |       |   |
-|       |   |---Project[bytearray][1] - Test-Plan-Builder-12
+|       |   |---Project[Unknown][1] - Test-Plan-Builder-12
 |       |   |
-|       |   |---Project[bytearray][2] - Test-Plan-Builder-13
+|       |   |---Project[Unknown][2] - Test-Plan-Builder-13
 |       |
 |       |---Project[tuple][0] - Test-Plan-Builder-10
 |
