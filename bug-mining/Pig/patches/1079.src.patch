diff --git a/CHANGES.txt b/CHANGES.txt
index 4cd5be1f8..7b6d27fc6 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -352,6 +352,8 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-2405: some unit test case failed with open JDK (fang fang chen via cheolsoo)
+
 PIG-3018: Refactor TestScriptLanguage to remove duplication and write script in different files (julien)
 
 PIG-2973: TestStreaming test times out (cheolsoo)
diff --git a/test/org/apache/pig/test/TestDataModel.java b/test/org/apache/pig/test/TestDataModel.java
index d04658c70..1b6c31b57 100644
--- a/test/org/apache/pig/test/TestDataModel.java
+++ b/test/org/apache/pig/test/TestDataModel.java
@@ -33,6 +33,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
+import java.util.LinkedHashMap;
 
 import org.junit.Test;
 
@@ -594,7 +595,7 @@ public class TestDataModel extends junit.framework.TestCase {
         bag.add(tf.newTuple(new Integer(4)));
         bag.add(tf.newTuple(new String("mary had a little lamb")));
 
-        Map<String, Object> map = new HashMap<String, Object>(2);
+        Map<String, Object> map = new LinkedHashMap<String, Object>(2);
         map.put(new String("hello"), new String("world"));
         map.put(new String("goodbye"), new String("all"));
 
diff --git a/test/org/apache/pig/test/TestMRCompiler.java b/test/org/apache/pig/test/TestMRCompiler.java
index 28e336685..8ccce5add 100644
--- a/test/org/apache/pig/test/TestMRCompiler.java
+++ b/test/org/apache/pig/test/TestMRCompiler.java
@@ -75,6 +75,7 @@ import org.apache.pig.impl.util.Utils;
 import org.apache.pig.test.junit.OrderedJUnit4Runner;
 import org.apache.pig.test.junit.OrderedJUnit4Runner.TestOrder;
 import org.apache.pig.test.utils.GenPhyOp;
+import org.apache.pig.test.utils.TestHelper;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -1121,7 +1122,7 @@ public class TestMRCompiler {
         System.out.println("Golden");
         System.out.println("<<<" + goldenPlan + ">>>");
         System.out.println("-------------");
-        assertEquals(removeSignature(goldenPlan), removeSignature(compiledPlan));
+        assertEquals(TestHelper.sortUDFs(removeSignature(goldenPlan)), TestHelper.sortUDFs(removeSignature(compiledPlan)));
     }
 
     /**
diff --git a/test/org/apache/pig/test/TestPruneColumn.java b/test/org/apache/pig/test/TestPruneColumn.java
index 8ac4df005..c201276cc 100644
--- a/test/org/apache/pig/test/TestPruneColumn.java
+++ b/test/org/apache/pig/test/TestPruneColumn.java
@@ -59,6 +59,7 @@ import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.ObjectSerializer;
 import org.apache.pig.impl.util.UDFContext;
 import org.apache.pig.newplan.logical.rules.ColumnPruneVisitor;
+import org.apache.pig.test.utils.TestHelper;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -206,6 +207,9 @@ public class TestPruneColumn {
             {
                 logMessages.add(line);
             }
+            if (logMessages.size() > 0) {
+                logMessages = TestHelper.sortSubFields(logMessages);
+            }
 
             // Check if all messages appear in the log
             for (int i=0;i<messages.length;i++)
@@ -1195,7 +1199,7 @@ public class TestPruneColumn {
         assertFalse(iter.hasNext());
 
         assertTrue(checkLogFileMessage(new String[]{"Columns pruned for A: $0",
-                "Map key required for A: $1->[key2, key1]"}));
+                "Map key required for A: $1->[key1, key2]"}));
     }
 
     @Test
@@ -1282,7 +1286,7 @@ public class TestPruneColumn {
 
         assertFalse(iter.hasNext());
 
-        assertTrue(checkLogFileMessage(new String[]{"Map key required for A: $0->[key2, key1]"}));
+        assertTrue(checkLogFileMessage(new String[]{"Map key required for A: $0->[key1, key2]"}));
     }
 
     @SuppressWarnings("rawtypes")
@@ -1608,7 +1612,7 @@ public class TestPruneColumn {
 
         assertTrue(iter.hasNext());
         Tuple t = iter.next();
-        assertEquals("([2#1,1#1])", t.toString());
+        assertEquals("([1#1, 2#1])", TestHelper.sortString("\\[(.*)\\]", t.toString(), ","));
 
         assertFalse(iter.hasNext());
 
@@ -2100,8 +2104,8 @@ public class TestPruneColumn {
 
         Util.checkQueryOutputsAfterSortRecursive(iter, expected, org.apache.pig.newplan.logical.Util.translateSchema(pigServer.dumpSchema("event_serve_join")));
 
-        assertTrue(checkLogFileMessage(new String[]{"Map key required for event_serve: $0->[key4, key3]",
-                "Map key required for cm_data_raw: $0->[key4, key3, key5]"}));
+        assertTrue(checkLogFileMessage(new String[]{"Map key required for event_serve: $0->[key3, key4]",
+                "Map key required for cm_data_raw: $0->[key3, key4, key5]"}));
     }
 
     // See PIG-2535
@@ -2123,7 +2127,7 @@ public class TestPruneColumn {
 
         pigServer.explain("event_serve_join", System.out);
 
-        assertTrue(checkLogFileMessage(new String[]{"Map key required for event_serve: $0->[event_guid, receive_time, filter_key]",
-                "Map key required for raw: $0->[source, p_url, cm_serve_timestamp_ms, cm_serve_id, type]"}));
+        assertTrue(checkLogFileMessage(new String[]{"Map key required for event_serve: $0->[event_guid, filter_key, receive_time]",
+                "Map key required for raw: $0->[cm_serve_id, cm_serve_timestamp_ms, p_url, source, type]"}));
     }
 }
\ No newline at end of file
diff --git a/test/org/apache/pig/test/utils/TestHelper.java b/test/org/apache/pig/test/utils/TestHelper.java
index 70beeb08c..1efabbeb1 100644
--- a/test/org/apache/pig/test/utils/TestHelper.java
+++ b/test/org/apache/pig/test/utils/TestHelper.java
@@ -24,6 +24,11 @@ import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.data.DataBag;
@@ -398,4 +403,54 @@ public class TestHelper {
 
     }
 
+    /**
+     * Find out the string which matches "regex" from "target", and sort the string with spacial
+     * order. The string elements are split by "split".
+     */
+    public static String sortString(String regex, String target, String split) {
+        Pattern p = Pattern.compile(regex);
+        Matcher matcher = p.matcher(target);
+        String original = null;
+        String replaceString = new String();
+
+        if (matcher.find()) {
+            original = matcher.group(1);
+            String[] out = original.split(split);
+            Collections.sort(Arrays.asList(out));
+            for (int j = 0; j < out.length; j++) {
+                replaceString += (j > 0 ? ", " + out[j] : out[j]);
+            }
+            return target.replace(original, replaceString);
+        }
+        return target;
+    }
+
+    /**
+     * Sort UDFs for golden plan
+     */
+    public static String sortUDFs(String goldenString) {
+        String regex = "MapReduce\\([0-9]*\\,(.*)\\) - -[0-9]*\\:";
+        String[] goldenArray = goldenString.split("\n");
+
+        for (int i = 0; i < goldenArray.length; i++) {
+            goldenString = goldenString.replace(goldenArray[i],
+                    sortString(regex, goldenArray[i], ","));
+        }
+
+        return goldenString;
+    }
+
+    /**
+     * sort subFields for LogMessages
+     */
+    public static List<String> sortSubFields(List<String> logMessages) {
+        String regex = "\\[(.*)\\]";
+
+        for (int i = 0; i < logMessages.size(); i++) {
+            logMessages.set(i, sortString(regex, logMessages.get(i), ", "));
+        }
+
+        return logMessages;
+    }
+
 }
