diff --git a/CHANGES.txt b/CHANGES.txt
index b17312f7f..f3ddf56b8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -357,6 +357,8 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1912: non-deterministic output when a file is loaded multiple times (daijy)
+
 PIG-1892: Bug in new logical plan : No output generated even though there are
 valid records (daijy)
 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
index e1a1c10b5..19e135606 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
@@ -57,6 +57,7 @@ import org.apache.pig.newplan.logical.relational.LogToPhyTranslationVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.rules.InputOutputFileValidator;
+import org.apache.pig.newplan.logical.rules.LoadStoreFuncDupSignatureValidator;
 import org.apache.pig.newplan.logical.visitor.SortInfoSetter;
 import org.apache.pig.pen.POOptimizeDisabler;
 
@@ -262,6 +263,10 @@ public class HExecutionEngine {
             optimizerRules.add("GroupByConstParallelSetter");
         }
         
+        // Check if we have duplicate signature
+        LoadStoreFuncDupSignatureValidator loadStoreFuncDupSignatureValidator = new LoadStoreFuncDupSignatureValidator(plan);
+        loadStoreFuncDupSignatureValidator.validate();
+        
         // run optimizer
         LogicalPlanOptimizer optimizer = new LogicalPlanOptimizer( plan, 100, optimizerRules );
         optimizer.optimize();
diff --git a/src/org/apache/pig/newplan/logical/relational/LOLoad.java b/src/org/apache/pig/newplan/logical/relational/LOLoad.java
index 20585cdcc..924ac6428 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOLoad.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOLoad.java
@@ -48,6 +48,7 @@ public class LOLoad extends LogicalRelationalOperator {
     private boolean castInserted = false;
     private LogicalSchema uidOnlySchema;
     private String schemaFile = null;
+    private String signature = null;
 
     /**
      * 
@@ -73,7 +74,7 @@ public class LOLoad extends LogicalRelationalOperator {
         try { 
             if (loadFunc == null && fs!=null) {
                 loadFunc = (LoadFunc)PigContext.instantiateFuncFromSpec(fs.getFuncSpec());
-                loadFunc.setUDFContextSignature(getAlias());               
+                loadFunc.setUDFContextSignature(signature);
             }
             
             return loadFunc;
@@ -162,6 +163,8 @@ public class LOLoad extends LogicalRelationalOperator {
 
 		// set the schema in this method using the new alias assigned
 		storeScriptSchema();
+		if (signature==null)
+		    signature = alias;
 	}
 	
 	/**
@@ -261,4 +264,18 @@ public class LOLoad extends LogicalRelationalOperator {
         String str = super.toString();
         return (str + "RequiredFields:" + requiredFields);
     }
+    
+    public String getSignature() {
+        return signature;
+    }
+    
+    /***
+     * This method is called by Pig logical planner to setup UDFContext signature.
+     * So that loadFunc can use signature to store its own configurations in UDFContext.
+     * This is not intend to be called by users
+     */
+    public void setSignature(String signature) {
+        this.signature = signature;
+        loadFunc.setUDFContextSignature(signature);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java b/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
index 114b134e8..8982210e0 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
@@ -125,7 +125,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
         load.setLFile(loLoad.getFileSpec());
         load.setPc(pc);
         load.setResultType(DataType.BAG);
-        load.setSignature(loLoad.getAlias());
+        load.setSignature(loLoad.getSignature());
         currentPlan.add(load);
         logToPhyMap.put(loLoad, load);
 
diff --git a/src/org/apache/pig/newplan/logical/rules/LoadStoreFuncDupSignatureValidator.java b/src/org/apache/pig/newplan/logical/rules/LoadStoreFuncDupSignatureValidator.java
new file mode 100644
index 000000000..81b3417b7
--- /dev/null
+++ b/src/org/apache/pig/newplan/logical/rules/LoadStoreFuncDupSignatureValidator.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.newplan.logical.rules;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.newplan.DepthFirstWalker;
+import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LOStore;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
+
+/***
+ * Check for duplicate alias. This is because we use alias as LoadFunc signature. If
+ * user use the same alias in two load statement, we cannot distinguish two loadFunc.
+ * LoadStoreFuncDupSignatureValidator solve this problem by appending an index if signature
+ * conflicts
+ */
+
+public class LoadStoreFuncDupSignatureValidator {
+    OperatorPlan plan;
+    public LoadStoreFuncDupSignatureValidator(OperatorPlan plan) {
+        this.plan = plan;
+    }
+    
+    public void validate() throws FrontendException {
+        LoadStoreFuncDupSignatureVisitor visitor = new LoadStoreFuncDupSignatureVisitor(plan);
+        visitor.visit();
+        visitor.finish();
+    }
+    
+    static class LoadStoreFuncDupSignatureVisitor extends LogicalRelationalNodesVisitor {
+        Map<String, List<LOLoad>> loadSignatures = new HashMap<String, List<LOLoad>>();
+        Map<String, List<LOStore>> storeSignatures = new HashMap<String, List<LOStore>>();
+        protected LoadStoreFuncDupSignatureVisitor(OperatorPlan plan)
+                throws FrontendException {
+            super(plan, new DepthFirstWalker(plan));
+        }
+
+        @Override
+        public void visit(LOLoad load) throws FrontendException {
+            if (loadSignatures.containsKey(load.getSignature())) {
+                List<LOLoad> loads = loadSignatures.get(load.getSignature());
+                loads.add(load);
+            } else {
+                List<LOLoad> loads = new ArrayList<LOLoad>();
+                loads.add(load);
+                loadSignatures.put(load.getSignature(), loads);
+            }
+        }
+        
+        @Override
+        public void visit(LOStore store) throws FrontendException {
+            if (storeSignatures.containsKey(store.getSignature())) {
+                List<LOStore> stores = storeSignatures.get(store.getSignature());
+                stores.add(store);
+            } else {
+                List<LOStore> stores = new ArrayList<LOStore>();
+                stores.add(store);
+                storeSignatures.put(store.getSignature(), stores);
+            }
+        }
+        
+        public void finish() {
+            for (Map.Entry<String, List<LOLoad>> entry : loadSignatures.entrySet()) {
+                String key = entry.getKey();
+                List<LOLoad> loads = entry.getValue();
+                if (loads.size()>1) {
+                    for (int i=0;i<loads.size();i++) {
+                        loads.get(i).setSignature(key+"$"+i);
+                    }
+                }
+            }
+            
+            for (Map.Entry<String, List<LOStore>> entry : storeSignatures.entrySet()) {
+                String key = entry.getKey();
+                List<LOStore> stores = entry.getValue();
+                if (stores.size()>1) {
+                    for (int i=0;i<stores.size();i++) {
+                        stores.get(i).setSignature(key+"$"+i);
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index 22a2e4bd5..72290b1d9 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -1367,4 +1367,38 @@ public class TestEvalPipeline2 {
         
         Assert.assertFalse(iter.hasNext());
     }
+    
+    // See PIG-1912
+    @Test
+    public void testDuplicateLoadFuncSignature() throws Exception{
+        String[] input = {
+                "0\t1\ta",
+        };
+        
+        Util.createInputFile(cluster, "table_testDuplicateLoadFuncSignature", input);
+        pigServer.setBatchOn();
+        pigServer.registerQuery("a = load 'table_testDuplicateLoadFuncSignature' as (a0, a1, a2);");
+        pigServer.registerQuery("b = foreach a generate a0, a1;");
+        pigServer.registerQuery("a = load 'table_testDuplicateLoadFuncSignature' as (a0, a1, a2);");
+        pigServer.registerQuery("c = foreach a generate a0, a2;");
+        pigServer.registerQuery("store b into 'testDuplicateLoadFuncSignatureOutput1';");
+        pigServer.registerQuery("store c into 'testDuplicateLoadFuncSignatureOutput2';");
+        
+        pigServer.executeBatch();
+        
+        pigServer.registerQuery("a = load 'testDuplicateLoadFuncSignatureOutput1';");
+        Iterator<Tuple> iter = pigServer.openIterator("a");
+        
+        Tuple t = iter.next();
+        Assert.assertTrue(t.toString().equals("(0,1)"));
+        Assert.assertFalse(iter.hasNext());
+        
+        pigServer.registerQuery("a = load 'testDuplicateLoadFuncSignatureOutput2';");
+        iter = pigServer.openIterator("a");
+        
+        t = iter.next();
+        Assert.assertTrue(t.toString().equals("(0,a)"));
+        Assert.assertFalse(iter.hasNext());
+        
+    }
 }
