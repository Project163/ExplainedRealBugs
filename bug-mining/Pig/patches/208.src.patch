diff --git a/CHANGES.txt b/CHANGES.txt
index 2e57bd1f7..2bbfcec46 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -24,6 +24,8 @@ INCOMPATIBLE CHANGES
 
 IMPROVEMENTS
 
+PIG-697: Proposed improvements to pig's optimizer (sms)
+
 PIG-753:  Allow UDFs with no parameters (zjffdu via gates).
 
 OPTIMIZATIONS
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 5d0290957..f5e1ac8c0 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -55,11 +55,13 @@ import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.LOCogroup;
 import org.apache.pig.impl.logicalLayer.LOFRJoin;
 import org.apache.pig.impl.logicalLayer.LOLoad;
+import org.apache.pig.impl.logicalLayer.LOPrinter;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
 import org.apache.pig.impl.logicalLayer.LogicalPlanBuilder;
 import org.apache.pig.impl.logicalLayer.PlanSetter;
 import org.apache.pig.impl.logicalLayer.optimizer.LogicalOptimizer;
+import org.apache.pig.impl.logicalLayer.optimizer.TypeCastInserter;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.parser.QueryParser;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
@@ -1056,6 +1058,7 @@ public class PigServer {
                 }
                 graph.postProcess();
             } catch (IOException ioe) {
+                ioe.printStackTrace();
                 graph = null;
             }          
             return graph;
@@ -1080,6 +1083,32 @@ public class PigServer {
                     String ifile = load.getInputFile().getFileName();
                     String ofile = store.getOutputFile().getFileName();
                     if (ofile.compareTo(ifile) == 0) {
+                        try {
+                            store.getPlan().connect(store, load);
+                        } catch (PlanException ex) {
+                            int errCode = 2128;
+                            String msg = "Failed to connect store with dependent load.";
+                            throw new FrontendException(msg, errCode, ex);
+                        }
+                        
+
+                         
+                        //TODO
+                        //if the load has a schema then the type cast inserter has to introduce 
+                        //casts to get the right types. Since the type cast inserter runs later,
+                        //removing the load could create problems. For example, if the storage function
+                        //does not preserve type information required and the subsequent load created
+                        //as part of the MR Compiler introduces a load then the type cast insertion
+                        //will be missing.
+                        //As a result, check if the store function preserves types. For now, the only
+                        //storage that preserves types internally is BinStorage.
+                        //In the future, Pig the storage functions should support method to enquire if
+                        //type information is preserved. Similarly, the load functions should support
+                        //a similar interface. With these interfaces in place, the code below can be
+                        //used to optimize the store/load combination
+                            
+
+                        /*                         
                         LoadFunc lFunc = (LoadFunc) pigContext.instantiateFuncFromSpec(load.getInputFile().getFuncSpec());
                         StoreFunc sFunc = (StoreFunc) pigContext.instantiateFuncFromSpec(store.getOutputFile().getFuncSpec());
                         if (lFunc.getClass() == sFunc.getClass() && lFunc instanceof ReversibleLoadStoreFunc) {
@@ -1100,29 +1129,23 @@ public class PigServer {
                             // the store happens on a job boundary.
                             store.setInputSpec(load.getInputFile());
                             
+                            Schema storePredSchema = storePred.getSchema();
+                            if(storePredSchema != null) {
+                                load.setSchema(storePredSchema);
+                                TypeCastInserter typeCastInserter = new TypeCastInserter(lp, LOLoad.class.getName());                                
+                                List<LogicalOperator> loadList = new ArrayList<LogicalOperator>();
+                                loadList.add(load);
+                                //the following needs a change to TypeCastInserter and LogicalTransformer
+                                typeCastInserter.doTransform(loadList, false);
+                            }
+                            
                             lp.disconnect(store, load);
-                            lp.replace(load, storePred);
-
-                            List<LogicalOperator> succs = lp.getSuccessors(storePred);
+                            lp.connect(storePred, load);
+                            lp.removeAndReconnectMultiSucc(load);
                             
-                            for (LogicalOperator succ : succs) {
-                                MultiMap<LogicalOperator, LogicalPlan> innerPls = null;
-                                
-                                // fix inner plans for cogroup and frjoin operators
-                                if (succ instanceof LOCogroup) {
-                                    innerPls = ((LOCogroup)succ).getGroupByPlans();
-                                } else if (succ instanceof LOFRJoin) {
-                                    innerPls = ((LOFRJoin)succ).getJoinColPlans();
-                                }
-                                
-                                if (innerPls != null) {
-                                    if (innerPls.containsKey(load)) {
-                                        Collection<LogicalPlan> pls = innerPls.get(load);
-                                        innerPls.removeKey(load);
-                                        innerPls.put(storePred, pls);
-                                    }
-                                }
-                            }
+                            List<LogicalOperator> succs = lp.getSuccessors(load);
+                            
+
                         } else {
                             try {
                                 store.getPlan().connect(store, load);
@@ -1130,8 +1153,9 @@ public class PigServer {
                                 int errCode = 2128;
                                 String msg = "Failed to connect store with dependent load.";
                                 throw new FrontendException(msg, errCode, ex);
-                            }
+                            }    
                         }
+                        */
                     }
                 }
             }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POProject.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POProject.java
index 3d9de8328..d908eada3 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POProject.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POProject.java
@@ -17,13 +17,16 @@
  */
 package org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.ArrayList;
 
 import org.apache.pig.PigException;
 import org.apache.pig.PigWarning;
 import org.apache.pig.backend.executionengine.ExecException;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
 import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataByteArray;
@@ -31,15 +34,9 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.data.SingleTupleBag;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
-import org.apache.pig.impl.plan.OperatorKey;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
-import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.NodeIdGenerator;
+import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
-import org.apache.pig.data.TupleFactory;
-import org.apache.pig.data.Tuple;
 
 /**
  * Implements the overloaded form of the project operator.
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index f4524aba0..aee10cf2c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -28,7 +28,9 @@ import java.util.Iterator;
 
 import org.apache.pig.PigException;
 import org.apache.pig.data.DataType;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
@@ -517,21 +519,28 @@ public class LOCogroup extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
         if(predecessors == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         //the column with the alias 'group' can be mapped in several ways
@@ -566,9 +575,9 @@ public class LOCogroup extends LogicalOperator {
                 
                 if(leaves.get(0) instanceof LOProject) {
                     //find out if this project is a chain of projects
-                    if(LogicalPlan.chainOfProjects(predecessorPlan)) {
-                        LOProject rootProject = (LOProject)predecessorPlan.getRoots().get(0);
-                        inputColumn = rootProject.getCol();
+                    LOProject topProject = LogicalPlan.chainOfProjects(predecessorPlan);
+                    if(topProject != null) {
+                        inputColumn = topProject.getCol();
                         mapFields.put(0, new Pair<Integer, Integer>(inputNum, inputColumn));
                     }
                 } else {
@@ -580,7 +589,8 @@ public class LOCogroup extends LogicalOperator {
             try {
                 inputSchema = predecessor.getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             if(inputSchema != null) {
@@ -609,7 +619,8 @@ public class LOCogroup extends LogicalOperator {
             removedFields = null;
         }
 
-        return new ProjectionMap(mapFields, removedFields, addedFields);
+        mProjectionMap = new ProjectionMap(mapFields, removedFields, addedFields);
+        return mProjectionMap;
     }
 
     @Override
@@ -662,4 +673,42 @@ public class LOCogroup extends LogicalOperator {
         return (requiredFields.size() == 0? null: requiredFields);
     }
 
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+     */
+    @Override
+    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+        if(newPred == null) {
+            int errCode = 1097;
+            String msg = "Replacement node cannot be null.";
+            throw new PlanException(msg, errCode, PigException.INPUT);
+        }
+        LogicalOperator previous = (LogicalOperator) oldPred;
+        LogicalOperator current = (LogicalOperator) newPred;
+        Set<LogicalOperator> cogroupInputs = new HashSet<LogicalOperator>(mGroupByPlans.keySet());
+        for(LogicalOperator input: cogroupInputs) {
+            if(input.equals(previous)) {
+                //replace the references to the key(i.e., previous) in the values with current
+                for(LogicalPlan plan: mGroupByPlans.get(input)) {
+                    try {
+                        ProjectFixerUpper projectFixer = new ProjectFixerUpper(
+                                plan, previous, oldPredIndex, current, useOldPred, this);
+                        projectFixer.visit();
+                    } catch (VisitorException ve) {
+                        int errCode = 2144;
+                        String msg = "Problem while fixing project inputs during rewiring.";
+                        throw new PlanException(msg, errCode, PigException.BUG, ve);
+                    }
+                }
+                //remove the key and the values
+                List<LogicalPlan> plans = (List<LogicalPlan>)mGroupByPlans.get(previous);
+                mGroupByPlans.removeKey(previous);
+                
+                //reinsert new key and values
+                mGroupByPlans.put(current, plans);
+            }
+        }
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCross.java b/src/org/apache/pig/impl/logicalLayer/LOCross.java
index b24fda70d..d44092fb2 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCross.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCross.java
@@ -190,21 +190,28 @@ public class LOCross extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
         if(predecessors == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
@@ -220,7 +227,8 @@ public class LOCross extends LogicalOperator {
             try {
                 inputSchema = predecessor.getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             if(inputSchema == null) {
@@ -246,14 +254,16 @@ public class LOCross extends LogicalOperator {
          */
 
         if(anyUnknownInputSchema) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(addedFields.size() == 0) {
             addedFields = null;
         }
 
-        return new ProjectionMap(mapFields, null, addedFields);
+        mProjectionMap = new ProjectionMap(mapFields, null, addedFields);
+        return mProjectionMap;
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LODistinct.java b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
index 616fa2ac4..a2a0b8240 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODistinct.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
@@ -122,15 +122,16 @@ public class LODistinct extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         Schema inputSchema = null;        
@@ -140,22 +141,22 @@ public class LODistinct extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-            return null;
-        }
-        
-        if(inputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a distinct have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
     
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
index 2450040cb..60a49fecf 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
@@ -32,7 +32,9 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
@@ -276,21 +278,28 @@ public class LOFRJoin extends LogicalOperator {
 
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
         if(predecessors == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
@@ -306,7 +315,8 @@ public class LOFRJoin extends LogicalOperator {
             try {
                 inputSchema = predecessor.getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             if(inputSchema == null) {
@@ -332,14 +342,16 @@ public class LOFRJoin extends LogicalOperator {
          */
 
         if(anyUnknownInputSchema) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(addedFields.size() == 0) {
             addedFields = null;
         }
 
-        return new ProjectionMap(mapFields, null, addedFields);
+        mProjectionMap = new ProjectionMap(mapFields, null, addedFields);
+        return mProjectionMap;
     }
 
     @Override
@@ -392,4 +404,40 @@ public class LOFRJoin extends LogicalOperator {
         return (requiredFields.size() == 0? null: requiredFields);
     }
 
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+     */
+    @Override
+    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+        LogicalOperator previous = (LogicalOperator) oldPred;
+        LogicalOperator current = (LogicalOperator) newPred;
+        Set<LogicalOperator> joinInputs = new HashSet<LogicalOperator>(mJoinColPlans.keySet()); 
+        for(LogicalOperator input: joinInputs) {
+            if(input.equals(previous)) {
+                //replace the references to the key(i.e., previous) in the values with current
+                for(LogicalPlan plan: mJoinColPlans.get(input)) {
+                    try {
+                        ProjectFixerUpper projectFixer = new ProjectFixerUpper(
+                                plan, previous, oldPredIndex, current, useOldPred, this);
+                        projectFixer.visit();
+                    } catch (VisitorException ve) {
+                        int errCode = 2144;
+                        String msg = "Problem while fixing project inputs during rewiring.";
+                        throw new PlanException(msg, errCode, PigException.BUG, ve);
+                    }
+                }
+                //remove the key and the values
+                List<LogicalPlan> plans = (List<LogicalPlan>)mJoinColPlans.get(previous);
+                mJoinColPlans.removeKey(previous);
+                
+                //reinsert new key and values
+                mJoinColPlans.put(current, plans);
+                
+                if(input.equals(fragOp)) {
+                   fragOp = current; 
+                }
+            }
+        }
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFilter.java b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
index fdc005fed..837c27693 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
@@ -22,8 +22,11 @@ import java.util.List;
 import java.util.ArrayList;
 import java.util.Set;
 
+import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
@@ -132,15 +135,16 @@ public class LOFilter extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         Schema inputSchema = null;        
@@ -150,22 +154,22 @@ public class LOFilter extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-            return null;
-        }
-        
-        if(inputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a filter have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
 
@@ -202,5 +206,24 @@ public class LOFilter extends LogicalOperator {
             return (requiredFields.size() == 0? null: requiredFields);
         }
     }
+
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+     */
+    @Override
+    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+        LogicalOperator previous = (LogicalOperator) oldPred;
+        LogicalOperator current = (LogicalOperator) newPred;
+        try {
+            ProjectFixerUpper projectFixer = new ProjectFixerUpper(
+                    mComparisonPlan, previous, oldPredIndex, current, useOldPred, this);
+            projectFixer.visit();
+        } catch (VisitorException ve) {
+            int errCode = 2144;
+            String msg = "Problem while fixing project inputs during rewiring.";
+            throw new PlanException(msg, errCode, PigException.BUG, ve);
+        }
+    }
     
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 9d5b47ee7..3e1e94573 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -30,7 +30,9 @@ import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
@@ -452,21 +454,28 @@ public class LOForEach extends LogicalOperator {
 
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
         if(predecessors == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         LogicalOperator predecessor = predecessors.get(0);
@@ -476,7 +485,8 @@ public class LOForEach extends LogicalOperator {
         try {
             inputSchema = predecessor.getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<LogicalPlan> foreachPlans = getForEachPlans();
@@ -490,20 +500,20 @@ public class LOForEach extends LogicalOperator {
             LogicalPlan foreachPlan = foreachPlans.get(i);
             List<LogicalOperator> leaves = foreachPlan.getLeaves();
             if(leaves == null || leaves.size() > 1) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             int inputColumn = -1;
             boolean mapped = false;
             
-            if(leaves.get(0) instanceof LOProject) {
+            
+            if(leaves.get(0) instanceof LOProject || leaves.get(0) instanceof LOCast) {
                 //find out if this project is a chain of projects
-                if(LogicalPlan.chainOfProjects(foreachPlan)) {
-                    LOProject rootProject = (LOProject)foreachPlan.getRoots().get(0);
-                    inputColumn = rootProject.getCol();
-                    if(inputSchema != null) {
+                LOProject topProject = LogicalPlan.chainOfProjects(foreachPlan);
+                if(topProject != null) {
+                    inputColumn = topProject.getCol();
                         mapped = true;
-                    }
                 }
             }
             
@@ -511,11 +521,13 @@ public class LOForEach extends LogicalOperator {
             try {
                 leafFS = ((ExpressionOperator)leaves.get(0)).getFieldSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             if(leafFS == null) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             if(flattenList.get(i)) {
@@ -532,17 +544,20 @@ public class LOForEach extends LogicalOperator {
                         // check that indeed we only have one field schema
                         // which is that of a tuple
                         if(innerSchema.getFields().size() != 1) {
-                            return null;
+                            mProjectionMap = null;
+                            return mProjectionMap;
                         }
                         Schema.FieldSchema tupleFS;
                         try {
                             tupleFS = innerSchema.getField(0);
                         } catch (FrontendException fee) {
-                            return null;
+                            mProjectionMap = null;
+                            return mProjectionMap;
                         }
                         
                         if(tupleFS.type != DataType.TUPLE) {
-                            return null;
+                            mProjectionMap = null;
+                            return mProjectionMap;
                         }
                         innerSchema = tupleFS.schema;
                     }
@@ -596,22 +611,21 @@ public class LOForEach extends LogicalOperator {
         }
         
         List<Pair<Integer, Integer>> removedFields = new ArrayList<Pair<Integer, Integer>>();
-       
-        if(inputSchema == null) {
-            //if input schema is null then there are no mappedFields and removedFields
+
+        //if the size of the map is zero then set it to null
+        if(mapFields.size() == 0) {
             mapFields = null;
+        }
+        
+        if(addedFields.size() == 0) {
+            addedFields = null;
+        }
+
+        if(inputSchema == null) {
+            //if input schema is null then there are no removedFields
             removedFields = null;
         } else {
             
-            //if the size of the map is zero then set it to null
-            if(mapFields.size() == 0) {
-                mapFields = null;
-            }
-            
-            if(addedFields.size() == 0) {
-                addedFields = null;
-            }
-            
             //input schema is not null. Need to compute the removedFields
             //compute the set difference between the input schema and mapped fields
             
@@ -640,7 +654,8 @@ public class LOForEach extends LogicalOperator {
             }
         }
 
-        return new ProjectionMap(mapFields, removedFields, addedFields);
+        mProjectionMap = new ProjectionMap(mapFields, removedFields, addedFields);
+        return mProjectionMap;
     }
 
     @Override
@@ -685,4 +700,25 @@ public class LOForEach extends LogicalOperator {
         }
     }
 
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+     */
+    @Override
+    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+        LogicalOperator previous = (LogicalOperator) oldPred;
+        LogicalOperator current = (LogicalOperator) newPred;
+        for(LogicalPlan plan: mForEachPlans) {
+            try {
+                ProjectFixerUpper projectFixer = new ProjectFixerUpper(
+                        plan, previous, oldPredIndex, current, useOldPred, this);
+                projectFixer.visit();
+            } catch (VisitorException ve) {
+                int errCode = 2144;
+                String msg = "Problem while fixing project inputs during rewiring.";
+                throw new PlanException(msg, errCode, PigException.BUG, ve);
+            }
+        }
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLimit.java b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
index 89559df6b..f5997371f 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLimit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
@@ -117,17 +117,17 @@ public class LOLimit extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+
         Schema inputSchema = null;        
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
@@ -135,22 +135,22 @@ public class LOLimit extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
-        if(inputSchema == null) {
-            return null;
-        }
-        
+
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a distinct have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
     
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLoad.java b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
index ca7483097..34484cf84 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLoad.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
@@ -229,16 +229,16 @@ public class LOLoad extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         Schema inputSchema = null;        
@@ -248,30 +248,41 @@ public class LOLoad extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
             try {
                 inputSchema = mLoadFunc.determineSchema(mSchemaFile, mExecType, mStorage);
             } catch (IOException ioe) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         }
         
         if(inputSchema == null) {
-            return null;
+            if(outputSchema != null) {
+                //determine schema returned null and the user specified a schema
+                //OR
+                //the predecessor did not have a schema and the user specified a schema
+                mProjectionMap = new ProjectionMap(false);
+                return mProjectionMap;
+            }
         }
         
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
             //compute the mapping assuming its a prefix projection
             for(int i = 0; i < inputSchema.size(); ++i) {
                 mapFields.put(i, new Pair<Integer, Integer>(0, i));
             }
-            return new ProjectionMap(mapFields, null, null);
+            
+            mProjectionMap = new ProjectionMap(mapFields, null, null); 
+            return mProjectionMap;
         }
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSort.java b/src/org/apache/pig/impl/logicalLayer/LOSort.java
index d4356a5f7..fde2feb45 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSort.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSort.java
@@ -28,7 +28,9 @@ import java.util.Set;
 import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
@@ -210,17 +212,17 @@ public class LOSort extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+
         Schema inputSchema = null;        
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
@@ -228,22 +230,22 @@ public class LOSort extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-            return null;
-        }
-        
-        if(inputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a sort have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
     
@@ -289,4 +291,24 @@ public class LOSort extends LogicalOperator {
         }
     }
 
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+     */
+    @Override
+    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+        LogicalOperator previous = (LogicalOperator) oldPred;
+        LogicalOperator current = (LogicalOperator) newPred;
+        for(LogicalPlan plan: mSortColPlans) {
+            try {
+                ProjectFixerUpper projectFixer = new ProjectFixerUpper(
+                        plan, previous, oldPredIndex, current, useOldPred, this);
+                projectFixer.visit();
+            } catch (VisitorException ve) {
+                int errCode = 2144;
+                String msg = "Problem while fixing project inputs during rewiring.";
+                throw new PlanException(msg, errCode, PigException.BUG, ve);
+            }
+        }
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplit.java b/src/org/apache/pig/impl/logicalLayer/LOSplit.java
index 8ac6a443c..ef1875d2b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplit.java
@@ -25,7 +25,9 @@ import java.util.Set;
 
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
@@ -126,15 +128,16 @@ public class LOSplit extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         Schema inputSchema = null;        
@@ -144,22 +147,22 @@ public class LOSplit extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-            return null;
-        }
-        
-        if(inputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a distinct have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
     
@@ -169,4 +172,15 @@ public class LOSplit extends LogicalOperator {
         requiredFields.add(new RequiredFields(false, true));
         return requiredFields;
     }
+    
+    /* (non-Javadoc)
+    * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+    */
+   @Override
+   public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+       for(LogicalOperator output: mPlan.getSuccessors(this)) {
+           output.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+       }
+   }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
index 2aae791a9..7b4de486e 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
@@ -29,7 +29,9 @@ import java.util.Set;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
@@ -133,17 +135,23 @@ public class LOSplitOutput extends LogicalOperator {
 
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+/*        
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+*/        
         Schema inputSchema = null;        
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
@@ -151,22 +159,27 @@ public class LOSplitOutput extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+/*        
         if(inputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
-        
+*/        
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a split output have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
 
@@ -204,4 +217,27 @@ public class LOSplitOutput extends LogicalOperator {
         }
     }
 
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
+     */
+    @Override
+    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
+        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
+        LogicalOperator previous = (LogicalOperator) oldPred;
+        LogicalOperator current = (LogicalOperator) newPred;
+        try {
+            ProjectFixerUpper projectFixer = new ProjectFixerUpper(
+                    mCondPlan, previous, oldPredIndex, current, useOldPred, this);
+            projectFixer.visit();
+        } catch (VisitorException ve) {
+            int errCode = 2144;
+            String msg = "Problem while fixing project inputs during rewiring.";
+            throw new PlanException(msg, errCode, PigException.BUG, ve);
+        }
+        
+        //ideally we should be fixing mIndex too but split and split output should always 
+        //be treated as one operator. Any operations on split will imply an operation on
+        //split output
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOStore.java b/src/org/apache/pig/impl/logicalLayer/LOStore.java
index a66aef7b3..0daf07025 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOStore.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOStore.java
@@ -133,14 +133,16 @@ public class LOStore extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
-        }
-        if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         Schema inputSchema = null;        
@@ -150,20 +152,20 @@ public class LOStore extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         }
         
-        if(inputSchema == null) {
-            return null;
-        }
         
         if(Schema.equals(inputSchema, outputSchema, false, true)) {
             //there is a one is to one mapping between input and output schemas
-            return new ProjectionMap(false);
+            mProjectionMap = new ProjectionMap(false);
+            return mProjectionMap;
         } else {
             //problem - input and output schemas for a store have to match!
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOStream.java b/src/org/apache/pig/impl/logicalLayer/LOStream.java
index a5ee2c425..21bb1c5b7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOStream.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOStream.java
@@ -179,16 +179,22 @@ public class LOStream extends LogicalOperator {
 
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         Schema inputSchema = null;        
@@ -198,10 +204,12 @@ public class LOStream extends LogicalOperator {
             try {
                 inputSchema = predecessors.get(0).getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
         } else {
-                return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<Integer> addedFields = new ArrayList<Integer>();
@@ -218,7 +226,8 @@ public class LOStream extends LogicalOperator {
                 removedFields.add(new Pair<Integer, Integer>(0, i));
             }
         }
-        return new ProjectionMap(null, (removedFields.size() == 0? null: removedFields), addedFields);
+        mProjectionMap = new ProjectionMap(null, (removedFields.size() == 0? null: removedFields), addedFields);
+        return mProjectionMap;
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index 114dbb535..19236e070 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -137,21 +137,28 @@ public class LOUnion extends LogicalOperator {
     
     @Override
     public ProjectionMap getProjectionMap() {
+        
+        if(mIsProjectionMapComputed) return mProjectionMap;
+        mIsProjectionMapComputed = true;
+        
         Schema outputSchema;
         
         try {
             outputSchema = getSchema();
         } catch (FrontendException fee) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         if(outputSchema == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
         if(predecessors == null) {
-            return null;
+            mProjectionMap = null;
+            return mProjectionMap;
         }
         
         MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
@@ -163,11 +170,13 @@ public class LOUnion extends LogicalOperator {
             try {
                 inputSchema = predecessor.getSchema();
             } catch (FrontendException fee) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             }
             
             if(inputSchema == null) {
-                return null;
+                mProjectionMap = null;
+                return mProjectionMap;
             } else {
                 for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
                     mapFields.put(inputColumn, new Pair<Integer, Integer>(inputNum, inputColumn));
@@ -176,7 +185,8 @@ public class LOUnion extends LogicalOperator {
             }
         }
         
-        return new ProjectionMap(mapFields, null, null);
+        mProjectionMap = new ProjectionMap(mapFields, null, null);
+        return mProjectionMap;
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
index 7aa11421f..3054f756d 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
@@ -73,6 +73,16 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
      */
     protected LogicalPlan mPlan;
 
+    /**
+     * ProjectionMap of this operator.
+     */
+    protected ProjectionMap mProjectionMap;
+
+    /**
+     * A boolean variable to remember if the projection map has been computed
+     */
+    protected boolean mIsProjectionMapComputed = false;
+    
     private static Log log = LogFactory.getLog(LogicalOperator.class);
 
     /**
@@ -150,6 +160,9 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
         mSchema = null;
     }
 
+    /**
+     * Regenerate the schema by unsetting and getting the schema
+     */
     public Schema regenerateSchema() throws FrontendException, VisitorException {
         unsetSchema();
         return getSchema();
@@ -288,9 +301,35 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
      * changes, for example a join of two inputs where one input does not have
      * a schema.
      */
+    @Override
     public ProjectionMap getProjectionMap() {
         return null;
     };
+    
+    /**
+     * Unset the projection map as if it had not been calculated.  This is used by
+     * anyone who reorganizes the tree and needs to have projection maps recalculated.
+     */
+    @Override
+    public void unsetProjectionMap() {
+        mIsProjectionMapComputed = false;
+        mProjectionMap = null;
+    }
+
+    /**
+     * Regenerate the projection map by unsetting and getting the projection map
+     */
+    @Override
+    public ProjectionMap regenerateProjectionMap() {
+        try {
+            regenerateSchema();
+        } catch (Exception e) {
+            
+        }
+        unsetProjectionMap();
+        return getProjectionMap();
+    }
+
 
     /**
 	 * Get a list of fields that this operator requires. This is not necessarily
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java b/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
index 1f348e63b..ed56840ea 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
@@ -152,46 +152,58 @@ public class LogicalPlan extends OperatorPlan<LogicalOperator> {
     
     /**
      * A utility method to check if a plan contains a chain of projection
-     * operators
+     * operators with or without casts
      * 
      * @param plan
      *            input plan
-     * @return true if there is a chain of projection operators; false otherwise
+     * @return the top most projection operator if there is a chain of
+     *         projection operators with or without casts; null otherwise
      */
-    public static boolean chainOfProjects(LogicalPlan plan) {
-        
+    public static LOProject chainOfProjects(LogicalPlan plan) {
+
+        LOProject topProject = null;
+
         if (plan == null) {
-            return false;
+            return null;
         }
-        
+
         List<LogicalOperator> leaves = plan.getLeaves();
 
         if (leaves == null) {
-            return false;
+            return null;
         }
 
         if (leaves.size() > 1) {
-            return false;
+            return null;
         }
 
         LogicalOperator node = leaves.get(0);
 
         while (true) {
-            if ((node == null) || !(node instanceof LOProject)) {
-                //not a projection operator
-                return false;
+            if (node == null) {
+                //a node cannot be null
+                return null;
+            }
+
+            if (node instanceof LOProject) {
+                topProject = (LOProject) node;
+            } else if (node instanceof LOCast) {
+                // continue
+            } else {
+                // not a projection or a cast return null
+                return null;
             }
 
             List<LogicalOperator> predecessors = plan.getPredecessors(node);
 
             if (predecessors == null) {
-                //we have reached the root
-                return true;
+                // we have reached the root
+                return topProject;
             }
 
             if (predecessors.size() > 1) {
-                //a project cannot have multiple inputs
-                return false;
+                // a project or cast cannot have multiple inputs
+                return null;
             }
 
             node = predecessors.get(0);
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java b/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java
new file mode 100644
index 000000000..ddb25df26
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java
@@ -0,0 +1,293 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.logicalLayer;
+
+import java.util.List;
+import java.util.Map;
+import java.util.ArrayList;
+
+import org.apache.pig.PigException;
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
+
+/**
+ * A class to visit all the projects and change them to attach to a new
+ * node.  This class overrides all of the relational operators visit
+ * methods because it does not want to visit contained plans.
+ */
+public class ProjectFixerUpper extends LOVisitor {
+
+    private LogicalOperator mNewNode;
+    private LogicalOperator mOldNode;
+    private int mPredecessorIndex;
+    private boolean mUseOldNode;
+    private LogicalOperator mContainingNode;
+    private Map<Integer, Integer> mProjectionMapping;
+
+    public ProjectFixerUpper(
+            LogicalPlan plan,
+            LogicalOperator oldNode,
+            int oldNodeIndex,
+            LogicalOperator newNode,
+            boolean useOldNode,
+            LogicalOperator containingNode) throws VisitorException {
+        this(plan, oldNode, newNode, (Map<Integer, Integer>)null);
+        if(containingNode == null) {
+            int errCode = 1097;
+            String msg = "Containing node cannot be null.";
+            throw new VisitorException(msg, errCode, PigException.INPUT);
+        }
+        if(oldNodeIndex < 0) {
+            int errCode = 1098;
+            String msg = "Node index cannot be negative.";
+            throw new VisitorException(msg, errCode, PigException.INPUT);
+        }
+        mContainingNode = containingNode;
+        mPredecessorIndex = oldNodeIndex;
+        mUseOldNode = useOldNode;
+    }
+    
+    public ProjectFixerUpper(
+            LogicalPlan plan,
+            LogicalOperator oldNode,
+            LogicalOperator newNode, Map<Integer, Integer> projectionMapping) throws VisitorException {
+        super(plan,
+            new DepthFirstWalker<LogicalOperator, LogicalPlan>(plan));
+        if(oldNode == null) {
+            int errCode = 1099;
+            String msg = "Node to be replaced cannot be null.";
+            throw new VisitorException(msg, errCode, PigException.INPUT);
+        }
+        mNewNode = newNode;
+        mOldNode = oldNode;
+        mProjectionMapping = projectionMapping;
+    }
+
+    protected void visit(LOCogroup cg) throws VisitorException {
+    }
+
+    protected void visit(LOSort s) throws VisitorException {
+    }
+
+    protected void visit(LOFilter f) throws VisitorException {
+    }
+
+    protected void visit(LOSplit s) throws VisitorException {
+    }
+
+    protected void visit(LOSplitOutput s) throws VisitorException {
+    }
+
+    protected void visit(LOForEach f) throws VisitorException {
+    }
+
+    protected void visit(LOProject p) throws VisitorException {
+        // Only switch the expression if this is a top level projection,
+        // that is, this project is pointing to a relational operator
+        // outside the plan).
+        List<LogicalOperator> preds = mPlan.getPredecessors(p);
+        if (preds == null || preds.size() == 0) {
+            if (p.getExpression().equals(mOldNode)) {
+                if (mNewNode == null) {
+                    int errCode = 1100;
+                    String msg = "Replacement node cannot be null.";
+                    throw new VisitorException(msg, errCode, PigException.INPUT);
+                }
+
+                // Change the expression
+                p.setExpression(mNewNode);
+                if(p.isStar()) {
+                    //its a project(*)
+                    //no need of changing it
+                    return;
+                }
+                if (mContainingNode != null) {
+                    // use the projection mapping of mOldNode or mNewNode along
+                    // with that of mContainingNode
+                    // to figure out the mapping and replace the columns
+                    // appropriately
+                    int oldNodeColumn = p.getCol();
+
+                    if (mUseOldNode) {
+                        // use mOldNode's projection map and find the column number
+                        // from the input that
+                        ProjectionMap oldNodeMap = mOldNode.getProjectionMap();
+
+                        if (oldNodeMap == null) {
+                            // bail out if the projection map is null
+                            int errCode = 2146;
+                            String msg = "Error while fixing projections. Projection map of node to be replaced is null.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+                        }
+
+                        if (!oldNodeMap.changes()) {
+                            // no change required
+                            return;
+                        }
+
+                        MultiMap<Integer, Pair<Integer, Integer>> oldNodeMappedFields = oldNodeMap
+                                .getMappedFields();
+                        if (oldNodeMappedFields == null) {
+                            // there is no mapping available bail out
+                            int errCode = 2147;
+                            String msg = "Error while fixing projections. No mapping available in old predecessor to replace column.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+
+                        }
+
+                        List<Pair<Integer, Integer>> pairs = (List<Pair<Integer, Integer>>) oldNodeMappedFields
+                                .get(oldNodeColumn);
+                        if (pairs == null) {
+                            // there is no mapping for oldNodeColumn
+                            // it could be an added field; bail out
+                            int errCode = 2148;
+                            String msg = "Error during fixing projections. No mapping available in old predecessor for column to be replaced.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+                        }
+
+                        boolean foundMapping = false;
+                        for (Pair<Integer, Integer> pair : pairs) {
+                            if (pair.first.equals(mPredecessorIndex)) {
+                                ArrayList<Integer> newColumns = new ArrayList<Integer>();
+                                newColumns.add(pair.second);
+                                p.setProjection(newColumns);
+                                foundMapping = true;
+                                break;
+                            }
+                        }
+                        if (!foundMapping) {
+                            // did not find a mapping - bail out
+                            int errCode = 2149;
+                            String msg = "Error during fixing projections. Could not locate replacement column from the old predecessor.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+                        } else {
+                            // done with adjusting the column number of the
+                            // project
+                            return;
+                        }
+                    } else {
+                        // here the projection mapping of new node has to be
+                        // used to figure out
+                        // the reverse mapping. From the newNode projection
+                        // mapping search for
+                        // the key whose value contains the pair (mOldNodeIndex,
+                        // oldNodeColumn)
+
+                        ProjectionMap newNodeMap = mNewNode.getProjectionMap();
+                        if (newNodeMap == null) {
+                            // did not find a mapping - bail out
+                            int errCode = 2150;
+                            String msg = "Error during fixing projections. Projection map of new predecessor is null.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+                        }
+                        
+                        if (!newNodeMap.changes()) {
+                            // no change required
+                            return;
+                        }
+
+                        MultiMap<Integer, Pair<Integer, Integer>> newNodeMappedFields = newNodeMap
+                                .getMappedFields();
+                        if (newNodeMappedFields == null) {
+                            // there is no mapping available bail out
+                            int errCode = 2151;
+                            String msg = "Error during fixing projections. No mapping available in new predecessor to replace column.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+
+                        }
+
+                        boolean foundMapping = false;
+                        for (Integer key : newNodeMappedFields.keySet()) {
+
+                            List<Pair<Integer, Integer>> pairs = (List<Pair<Integer, Integer>>) newNodeMappedFields
+                                    .get(key);
+                            if (pairs == null) {
+                                // should not happen
+                                int errCode = 2152;
+                                String msg = "Error during fixing projections. Could not locate mapping for column: "
+                                        + key + " in new predecessor.";
+                                throw new VisitorException(msg, errCode,
+                                        PigException.BUG);
+                            }
+
+                            for (Pair<Integer, Integer> pair : pairs) {
+                                if (pair.first.equals(mPredecessorIndex)
+                                        && pair.second.equals(oldNodeColumn)) {
+                                    ArrayList<Integer> newColumns = new ArrayList<Integer>();
+                                    newColumns.add(key);
+                                    p.setProjection(newColumns);
+                                    foundMapping = true;
+                                    break;
+                                }
+                            }
+
+                            if (foundMapping) {
+                                // done with adjusting the column number of the
+                                // project
+                                return;
+                            }
+                        }
+                        if (!foundMapping) {
+                            // did not find a mapping - bail out
+                            int errCode = 2153;
+                            String msg = "Error during fixing projections. Could not locate replacement column in the new predecessor.";
+                            throw new VisitorException(msg, errCode,
+                                    PigException.BUG);
+                        }
+                    }
+                }// end if for containing node != null
+            }// end if for projection expression equals mOldNode
+
+            // Remap the projection column if necessary
+            if (mProjectionMapping != null && !p.isStar()) {
+                List<Integer> oldProjection = p.getProjection();
+                List<Integer> newProjection = new ArrayList<Integer>(
+                        oldProjection.size());
+                for (Integer i : oldProjection) {
+                    Integer n = mProjectionMapping.get(i);
+                    assert (n != null);
+                    newProjection.add(n);
+                }
+            }
+        } else {
+            // TODO
+            // not sure if we need this. the walker should take care of this
+            p.getExpression().visit(this);
+        }
+    }
+    
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("old node: " + mOldNode);
+        sb.append(" old node index: " + mPredecessorIndex);
+        sb.append(" new node: " + mNewNode);
+        sb.append(" containing node: " + mContainingNode);
+        sb.append(" mProjectionMapping: " + mProjectionMapping);
+        return sb.toString();
+    }
+}
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java b/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java
new file mode 100644
index 000000000..b5c66dee7
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.logicalLayer;
+
+import org.apache.pig.impl.plan.DependencyOrderWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor to calculate all the projection maps in a logical plan.
+ */
+public class ProjectionMapCalculator extends
+        LOVisitor {
+	
+    public ProjectionMapCalculator(LogicalPlan plan) {
+        super(plan, new DependencyOrderWalker<LogicalOperator, LogicalPlan>(plan));
+    }
+
+
+    /**
+     * 
+     * @param cg
+     *            the logical cogroup operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOCogroup cg) throws VisitorException {
+        cg.getProjectionMap();
+        super.visit(cg);
+    }
+
+    /**
+     * 
+     * @param frjoin
+     *            the logical fragment replicate join operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOFRJoin frjoin) throws VisitorException {
+        frjoin.getProjectionMap();
+        super.visit(frjoin);
+    }
+    
+    /**
+     * 
+     * @param s
+     *            the logical sort operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOSort s) throws VisitorException {
+        s.getProjectionMap();
+        super.visit(s);
+    }
+
+    /**
+     * 
+     * @param limit
+     *            the logical limit operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOLimit limit) throws VisitorException {
+        limit.getProjectionMap();
+        super.visit(limit);
+    }
+
+    /**
+     * 
+     * @param filter
+     *            the logical filter operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOFilter filter) throws VisitorException {
+        filter.getProjectionMap();
+        super.visit(filter);
+    }
+
+    /**
+     * 
+     * @param split
+     *            the logical split operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOSplit split) throws VisitorException {
+        split.getProjectionMap();
+        super.visit(split);
+    }
+
+    /**
+     * 
+     * @param forEach
+     *            the logical foreach operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOForEach forEach) throws VisitorException {
+        super.visit(forEach);
+        forEach.getProjectionMap();
+    }
+
+    protected void visit(LOLoad load) throws VisitorException{
+        load.getProjectionMap();
+        super.visit(load);
+    }
+    
+    protected void visit(LOStore store) throws VisitorException{
+        store.getProjectionMap();
+        super.visit(store);
+    }
+    
+    protected void visit(LOUnion u) throws VisitorException {
+        u.getProjectionMap();
+        super.visit(u);
+    }
+
+    protected void visit(LOSplitOutput sop) throws VisitorException {
+        sop.getProjectionMap();
+        super.visit(sop);
+    }
+
+    protected void visit(LODistinct dt) throws VisitorException {
+        dt.getProjectionMap();
+        super.visit(dt);
+    }
+
+    protected void visit(LOCross cs) throws VisitorException {
+        cs.getProjectionMap();
+        super.visit(cs);
+    }
+
+    protected void visit(LOStream stream) throws VisitorException{
+        stream.getProjectionMap();
+        super.visit(stream);
+    }
+}
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java b/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java
new file mode 100644
index 000000000..4263a5005
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.logicalLayer;
+
+import org.apache.pig.impl.plan.DependencyOrderWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor to reset all the projection maps in a logical plan.
+ */
+public class ProjectionMapRemover extends
+        LOVisitor {
+	
+    public ProjectionMapRemover(LogicalPlan plan) {
+        super(plan, new DependencyOrderWalker<LogicalOperator, LogicalPlan>(plan));
+    }
+
+
+    /**
+     * 
+     * @param cg
+     *            the logical cogroup operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOCogroup cg) throws VisitorException {
+        cg.unsetProjectionMap();
+        super.visit(cg);
+    }
+
+    /**
+     * 
+     * @param frjoin
+     *            the logical fragment replicate join operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOFRJoin frjoin) throws VisitorException {
+        frjoin.unsetProjectionMap();
+        super.visit(frjoin);
+    }
+    
+    /**
+     * 
+     * @param s
+     *            the logical sort operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOSort s) throws VisitorException {
+        s.unsetProjectionMap();
+        super.visit(s);
+    }
+
+    /**
+     * 
+     * @param limit
+     *            the logical limit operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOLimit limit) throws VisitorException {
+        limit.unsetProjectionMap();
+        super.visit(limit);
+    }
+
+    /**
+     * 
+     * @param filter
+     *            the logical filter operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOFilter filter) throws VisitorException {
+        filter.unsetProjectionMap();
+        super.visit(filter);
+    }
+
+    /**
+     * 
+     * @param split
+     *            the logical split operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOSplit split) throws VisitorException {
+        split.unsetProjectionMap();
+        super.visit(split);
+    }
+
+    /**
+     * 
+     * @param forEach
+     *            the logical foreach operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOForEach forEach) throws VisitorException {
+        super.visit(forEach);
+        forEach.unsetProjectionMap();
+    }
+
+    protected void visit(LOLoad load) throws VisitorException{
+        load.unsetProjectionMap();
+        super.visit(load);
+    }
+    
+    protected void visit(LOStore store) throws VisitorException{
+        store.unsetProjectionMap();
+        super.visit(store);
+    }
+    
+    protected void visit(LOUnion u) throws VisitorException {
+        u.unsetProjectionMap();
+        super.visit(u);
+    }
+
+    protected void visit(LOSplitOutput sop) throws VisitorException {
+        sop.unsetProjectionMap();
+        super.visit(sop);
+    }
+
+    protected void visit(LODistinct dt) throws VisitorException {
+        dt.unsetProjectionMap();
+        super.visit(dt);
+    }
+
+    protected void visit(LOCross cs) throws VisitorException {
+        cs.unsetProjectionMap();
+        super.visit(cs);
+    }
+
+    protected void visit(LOStream stream) throws VisitorException{
+        stream.unsetProjectionMap();
+        super.visit(stream);
+    }
+}
diff --git a/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java b/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java
index b7bb28a66..939c98677 100644
--- a/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java
+++ b/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java
@@ -86,10 +86,7 @@ public class TopLevelProjectFinder extends
     	if(projectPreds == null) {
         	//check if the project's predecessor is null then add it to the list
     		mProjectList.add(project);
-    	} /*else if (!(projectPreds.get(0) instanceof LOProject)) {
-    		//check if the project's predecessor is not a project then add it to the list
-    		mProjectList.add(project);
-    	}*/
+    	}
     }
     
     public List<LOProject> getProjectList() {
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/ImplicitSplitInserter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/ImplicitSplitInserter.java
index ca83d8c0c..b8a6055df 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/ImplicitSplitInserter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/ImplicitSplitInserter.java
@@ -155,8 +155,6 @@ public class ImplicitSplitInserter extends LogicalTransformer {
                 mPlan.add(splitOutput);
                 mPlan.insertBetween(splitOp, splitOutput, succ);
                 splitOutput.setAlias(splitOp.getAlias());
-                // Patch up the contained plans of succ
-                fixUpContainedPlans(nodes.get(0), splitOutput, succ, null);
             }
             
         } catch (Exception e) {
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
index 7cde1158c..eeca96652 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
@@ -17,9 +17,12 @@
  */
 package org.apache.pig.impl.logicalLayer.optimizer;
 
+import java.util.List;
 import java.util.Set;
 
 import org.apache.pig.ExecType;
+import org.apache.pig.PigException;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.LOLimit;
 import org.apache.pig.impl.logicalLayer.LOLoad;
 import org.apache.pig.impl.logicalLayer.LOPrinter;
@@ -138,4 +141,46 @@ public class LogicalOptimizer extends
         mRules.add(rule);
     }
 
+    @Override
+    public final void optimize() throws OptimizerException {
+        //the code that follows is a copy of the code in the
+        //base class. see the todo note in the base class
+        boolean sawMatch = false;
+        int numIterations = 0;
+        do {
+            sawMatch = false;
+            for (Rule rule : mRules) {
+                RuleMatcher matcher = new RuleMatcher();
+                if (matcher.match(rule)) {
+                    // It matches the pattern.  Now check if the transformer
+                    // approves as well.
+                    List<List<LogicalOperator>> matches = matcher.getAllMatches();
+                    for (List<LogicalOperator> match:matches)
+                    {
+                        if (rule.getTransformer().check(match)) {
+                            // The transformer approves.
+                            sawMatch = true;
+                            rule.getTransformer().transform(match);
+                            try {
+                                ((LogicalTransformer)rule.getTransformer()).rebuildSchemas();
+                            } catch (FrontendException fee) {
+                                int errCode = 2145;
+                                String msg = "Problem while rebuilding schemas after transformation.";
+                                throw new OptimizerException(msg, errCode, PigException.BUG, fee);
+                            }
+
+                            try {
+                                ((LogicalTransformer)rule.getTransformer()).rebuildProjectionMaps();
+                            } catch (FrontendException fee) {
+                                int errCode = 2145;
+                                String msg = "Problem while rebuilding projection maps after transformation.";
+                                throw new OptimizerException(msg, errCode, PigException.BUG, fee);
+                            }
+
+                        }
+                    }
+                }
+            }
+        } while(sawMatch && ++numIterations < mMaxIterations);
+    }
 }
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
index 95ceb5302..038c6aaba 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
@@ -42,6 +42,9 @@ import org.apache.pig.impl.logicalLayer.LOSort;
 import org.apache.pig.impl.logicalLayer.LOSplit;
 import org.apache.pig.impl.logicalLayer.LOSplitOutput;
 import org.apache.pig.impl.logicalLayer.LOVisitor;
+import org.apache.pig.impl.logicalLayer.ProjectFixerUpper;
+import org.apache.pig.impl.logicalLayer.ProjectionMapCalculator;
+import org.apache.pig.impl.logicalLayer.ProjectionMapRemover;
 
 public abstract class LogicalTransformer extends Transformer<LogicalOperator, LogicalPlan> {
 
@@ -65,72 +68,18 @@ public abstract class LogicalTransformer extends Transformer<LogicalOperator, Lo
         sc.visit();
         
     }
-
+    
     /**
-     * A class to visit all the projects and change them to attach to a new
-     * node.  This class overrides all of the relational operators visit
-     * methods because it does not want to visit contained plans.
+     * Rebuild projection maps after a rule has transformed the tree.  This will first
+     * null out existing projection maps and then call getProjectionMap to rebuild them.
+     * @throws VisitorException
      */
-    private class ProjectFixerUpper extends LOVisitor {
-
-        private LogicalOperator mNewNode;
-        private LogicalOperator mOldNode;
-        private Map<Integer, Integer> mProjectionMapping;
-
-        ProjectFixerUpper(
-                LogicalPlan plan,
-                LogicalOperator oldNode,
-                LogicalOperator newNode, Map<Integer, Integer> projectionMapping) {
-            super(plan,
-                new DepthFirstWalker<LogicalOperator, LogicalPlan>(plan));
-            mNewNode = newNode;
-            mOldNode = oldNode;
-            mProjectionMapping = projectionMapping;
-        }
-
-        protected void visit(LOCogroup cg) throws VisitorException {
-        }
-
-        protected void visit(LOSort s) throws VisitorException {
-        }
-
-        protected void visit(LOFilter f) throws VisitorException {
-        }
-
-        protected void visit(LOSplit s) throws VisitorException {
-        }
-
-        protected void visit(LOSplitOutput s) throws VisitorException {
-        }
-
-        protected void visit(LOForEach f) throws VisitorException {
-        }
-
-        protected void visit(LOProject p) throws VisitorException {
-            // Only switch the expression if this is a top level projection,
-            // that is, this project is pointing to a relational operator
-            // outside the plan).
-            List<LogicalOperator> preds = mPlan.getPredecessors(p);
-            if (preds == null || preds.size() == 0) {
-                if(p.getExpression().equals(mOldNode))
-                    // Change the expression
-                    p.setExpression(mNewNode);
-
-                // Remap the projection column if necessary
-                if (mProjectionMapping != null && !p.isStar()) {
-                    List<Integer> oldProjection = p.getProjection();
-                    List<Integer> newProjection =
-                        new ArrayList<Integer>(oldProjection.size());
-                    for (Integer i : oldProjection) {
-                        Integer n = mProjectionMapping.get(i);
-                        assert(n != null);
-                        newProjection.add(n);
-                    }
-                }
-            } else {
-                p.getExpression().visit(this);
-            }
-        }
+    protected void rebuildProjectionMaps() throws VisitorException {
+        ProjectionMapRemover pMapRemover = new ProjectionMapRemover(mPlan);
+        pMapRemover.visit();
+        ProjectionMapCalculator pMapCalculator = new ProjectionMapCalculator(mPlan);
+        pMapCalculator.visit();
+        
     }
 
     /**
@@ -156,7 +105,6 @@ public abstract class LogicalTransformer extends Transformer<LogicalOperator, Lo
         // Insert it into the plan.
         mPlan.add(newNode);
         mPlan.insertBetween(after, newNode, before);
-        fixUpContainedPlans(after, newNode, before, projectionMapping);
     }
     
     /**
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java b/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java
index 1abe3e9ce..633da3eea 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java
@@ -77,6 +77,21 @@ public class SchemaCalculator extends LOVisitor {
         }
     }
 
+    /**
+     * 
+     * @param frjoin
+     *            the logical fragment replicate join operator that has to be visited
+     * @throws VisitorException
+     */
+    protected void visit(LOFRJoin frjoin) throws VisitorException {
+        try {
+            frjoin.getSchema();
+            super.visit(frjoin);
+        } catch (FrontendException fe) {
+            throw new VisitorException(fe);
+        }
+    }
+    
     /**
      * 
      * @param s
@@ -222,7 +237,12 @@ public class SchemaCalculator extends LOVisitor {
     }
     
     protected void visit(LOStore store) throws VisitorException{
-        // We don't calculate schema of LOStore
+        try {
+            store.getSchema();
+            super.visit(store);
+        } catch (FrontendException fe) {
+            throw new VisitorException(fe);
+        }
     }
     
     protected void visit(LOConst c) throws VisitorException{
diff --git a/src/org/apache/pig/impl/plan/Operator.java b/src/org/apache/pig/impl/plan/Operator.java
index a5ae3db6f..94b03a7da 100644
--- a/src/org/apache/pig/impl/plan/Operator.java
+++ b/src/org/apache/pig/impl/plan/Operator.java
@@ -128,4 +128,59 @@ abstract public class Operator<V extends PlanVisitor> implements Serializable, C
         return opClone;
     }
     
+    /**
+     * Produce a map describing how this operator modifies its projection.
+     * @return ProjectionMap null indicates it does not know how the projection
+     * changes, for example a join of two inputs where one input does not have
+     * a schema.
+     */
+    public ProjectionMap getProjectionMap() {
+        //TODO
+        //this method should be made abstract in the future
+        return null;
+    };
+    
+    /**
+     * Unset the projection map as if it had not been calculated.  This is used by
+     * anyone who reorganizes the tree and needs to have projection maps recalculated.
+     */
+    public void unsetProjectionMap() {
+        //TODO
+        //this method should be made abstract in the future
+    }
+
+    /**
+     * Regenerate the projection map by unsetting and getting the projection map
+     */
+    public ProjectionMap regenerateProjectionMap() {
+        unsetProjectionMap();
+        return getProjectionMap();
+    }
+
+    
+    /**
+     * Make any necessary changes to a node based on a change of position in the
+     * plan. This allows operators to rewire their projections, etc. when they
+     * are relocated in a plan.
+     * 
+     * @param oldPred
+     *            Operator that was previously the predecessor.
+     * @param oldPredIndex
+     *            position of the old predecessor in the list of predecessors
+     * @param newPred
+     *            Operator that will now be the predecessor.
+     * @param useOldPred
+     *            If true use oldPred's projection map for the rewire; otherwise
+     *            use newPred's projection map
+     * @throws PlanException
+     */
+    public void rewire(Operator<V> oldPred, int oldPredIndex,
+            Operator<V> newPred, boolean useOldPred) throws PlanException {
+        //TODO
+        //this method should be made abstract in the future
+        if (oldPred == null) {
+            return;
+        }
+    }
+    
 }
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index 99ea98f31..1a4edbe3b 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -29,10 +29,10 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
-import org.apache.pig.PigException;
-import org.apache.pig.impl.util.MultiMap;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.pig.PigException;
+import org.apache.pig.impl.util.MultiMap;
 
 
 //import org.apache.commons.collections.map.MultiValueMap;
@@ -51,6 +51,18 @@ import org.apache.commons.logging.LogFactory;
  * for graph manipulators (such as the validators and optimizers) to
  * understand the internals of various nodes.
  */
+
+//TODO
+/*
+ * The graph operations swap, insertBetween, pushBefore, etc. have to be re-implemented
+ * in a layered fashion. The layering will facilitate the re-use of operations. In addition,
+ * use of operator.rewire in the aforementioned operations requires transaction like ability
+ * due to various pre-conditions. Often, the result of one of the operations leaves the
+ * graph in an inconsistent state for the rewire operation. Clear layering and assignment
+ * of the ability to rewire will remove these inconsistencies. For now, use of rewire
+ * has resulted in a slightly less maintainable code along with the necessity to use
+ * rewire with discretion.
+ */
 public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, Serializable, Cloneable {
     protected Map<E, OperatorKey> mOps;
     protected Map<OperatorKey, E> mKeys;
@@ -241,7 +253,19 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
      * @param op Operator to trim everything before.
      */
     public void trimAbove(E op) {
-        trimAbove(getPredecessors(op));
+        List<E> predecessors = new ArrayList<E>(getPredecessors(op));
+        IndexHelper<E> indexHelper = new IndexHelper<E>(predecessors);
+        trimAbove(predecessors);
+        for(E predecessor: predecessors) {
+            try {
+                op.rewire(predecessor, indexHelper.getIndex(predecessor), null, true);
+            } catch (PlanException pe) {
+                //TODO
+                //need to change the method signature to include the exception clause
+                //for now, throwing RunTimeException to workaround this issue
+                throw new RuntimeException("Encountered problems with rewiring operators.", pe);
+            }
+        }
     }
 
     private void trimAbove(List<E> ops) {
@@ -453,15 +477,41 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             E after,
             E newNode,
             E before) throws PlanException {
+        doInsertBetween(after, newNode, before, true);
+    }
+    
+    /*
+     * Private method to perform the insertBetween operation with the ability to turn off
+     * rewiring operation.
+     */
+    private void doInsertBetween(
+            E after,
+            E newNode,
+            E before,
+            boolean rewire) throws PlanException {
         checkInPlan(newNode);
+        List<E> newNodePreds = getPredecessors(newNode);
+        //assuming that the newNode has zero or one predecessor
+        E newNodePred = (newNodePreds == null? null: newNodePreds.get(0));
         if (!replaceNode(after, newNode, before, mFromEdges) || !replaceNode(before, newNode, after, mToEdges)) {
-            PlanException pe = new PlanException("Attempt to insert between two nodes " +
-                "that were not connected.");
-            log.error(pe.getMessage());
+            int errCode = 1094;
+            String msg = "Attempt to insert between two nodes " +
+            "that were not connected.";
+            PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
             throw pe;
         }
         mFromEdges.put(newNode, before);
         mToEdges.put(newNode, after);
+
+        if(rewire) {
+            if((newNodePred != null) && !(newNodePred.equals(after))) {
+                newNodePred.regenerateProjectionMap();
+                newNode.rewire(newNodePred, 0, after, true);
+            }
+            newNode.regenerateProjectionMap();
+            IndexHelper<E> indexHelper = new IndexHelper<E>(getPredecessors(newNode));
+            before.rewire(after, indexHelper.getIndex(after), newNode, false);
+        }
     }
 
     // replaces (src -> dst) entry in multiMap with (src -> replacement)
@@ -513,7 +563,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
     /**
      * Replace an existing node in the graph with a new node.  The new node
      * will be connected to all the nodes the old node was.  The old node will
-     * be removed.
+     * be removed. The new node is assumed to have no incoming or outgoing edges
      * @param oldNode Node to be replaced
      * @param newNode Node to add in place of oldNode
      * @throws PlanException
@@ -521,9 +571,28 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
     public void replace(E oldNode, E newNode) throws PlanException {
         checkInPlan(oldNode);
         add(newNode);
+        List<E> oldNodeSuccs = (getSuccessors(oldNode) == null? null : new ArrayList<E>(getSuccessors(oldNode)));
+        List<IndexHelper<E>> indexHelpers = new ArrayList<IndexHelper<E>>();
+        if(oldNodeSuccs != null) {
+            for(int i = 0; i < oldNodeSuccs.size(); ++i) {
+                E oldNodeSucc = oldNodeSuccs.get(i);
+                indexHelpers.add(new IndexHelper<E>(new ArrayList<E>(getPredecessors(oldNodeSucc))));
+            }
+        }
+
+        
         mToEdges = generateNewMap(oldNode, newNode, mToEdges);
         mFromEdges = generateNewMap(oldNode, newNode, mFromEdges);
+        
+        //ensure that the oldNode's successors are rewired
+        if(oldNodeSuccs != null) {
+            for(int i = 0; i < oldNodeSuccs.size(); ++i) {
+                E oldNodeSucc = oldNodeSuccs.get(i);
+                oldNodeSucc.rewire(oldNode, indexHelpers.get(i).getIndex(oldNode), newNode, true);
+            }
+        }
         remove(oldNode);
+
     }
 
     private MultiMap<E, E> generateNewMap(
@@ -568,9 +637,10 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         E pred = null;
         if (preds != null) {
             if (preds.size() > 1) {
-                PlanException pe = new PlanException("Attempt to remove " +
-                    " and reconnect for node with multiple predecessors.");
-                log.error(pe.getMessage());
+                int errCode = 1095;
+                String msg = "Attempt to remove " +
+                " and reconnect for node with multiple predecessors.";
+                PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
                 throw pe;
             }
             pred = preds.get(0);
@@ -581,9 +651,10 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         E succ = null;
         if (succs != null) {
             if (succs.size() > 1) {
-                PlanException pe = new PlanException("Attempt to remove " +
-                    " and reconnect for node with multiple successors.");
-                log.error(pe.getMessage());
+                int errCode = 1095;
+                String msg = "Attempt to remove " +
+                " and reconnect for node with multiple successors.";
+                PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
                 throw pe;
             }
             succ = succs.get(0);
@@ -591,7 +662,10 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         }
 
         remove(node);
-        if (pred != null && succ != null) connect(pred, succ);
+        if (pred != null && succ != null) {
+            connect(pred, succ);
+            succ.rewire(node, 0, pred, true);
+        }
     }
 
     private void reconnectSuccessors(E node, boolean successorRequired, boolean removeNode) throws PlanException {
@@ -615,35 +689,44 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             Integer size = null;
             if(preds != null)
                 size = preds.size();
-
-            PlanException pe = new PlanException("Attempt to remove " +
-                    " and reconnect for node with  " + size +
-            " predecessors.");
-            log.error(pe.getMessage());
+            int errCode = 1096;
+            String msg = "Attempt to remove "
+                    + " and reconnect for node with  " + size
+                    + " predecessors.";
+            PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
             throw pe;
         }
 
         //A and C
         E nodeA = preds.get(0);
-        Collection<E> nodeC = mFromEdges.get(nodeB);
+        Collection<E> nodeC = (mFromEdges.get(nodeB) == null? null : new ArrayList<E>(mFromEdges.get(nodeB)));
 
         //checking pre-requisite conditions
         if(successorRequired) {
             if (nodeC == null || nodeC.size() == 0) {
-                PlanException pe = new PlanException("Attempt to remove " +
-                " and reconnect for node with no successors.");
-                log.error(pe.getMessage());
+                int errCode = 1096;
+                String msg = "Attempt to remove " +
+                " and reconnect for node with no successors.";
+                PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
                 throw pe;
             }
         }
 
+        List<IndexHelper<E>> indexHelpers = new ArrayList<IndexHelper<E>>();
+        if(nodeC != null) {
+            for(int i = 0; i < nodeC.size(); ++i) {
+                E c = ((List<E>)nodeC).get(i);
+                indexHelpers.add(new IndexHelper<E>(new ArrayList<E>(getPredecessors(c))));
+            }
+        }
 
         // replace B in A.succesors and add B.successors(ie C) to it
         replaceAndAddSucessors(nodeA, nodeB);
         
         // for all C(succs) , replace B(node) in predecessors, with A(pred)
         if(nodeC != null) {
-            for(E c: nodeC) {
+            for(int i = 0; i < nodeC.size(); ++i) {
+                E c = ((List<E>)nodeC).get(i);
                 Collection<E> sPreds = mToEdges.get(c);
                 ArrayList<E> newPreds = new ArrayList<E>(sPreds.size());
                 for(E p: sPreds){
@@ -668,6 +751,14 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             mFromEdges.removeKey(nodeB);
             mToEdges.removeKey(nodeB);
         }
+        
+        //ensure that any existing successor of nodeB is rewired to have nodeA in place of nodeB
+        if(nodeC != null) {
+            for(int i = 0; i < nodeC.size(); ++i) {
+                E c = ((List<E>)nodeC).get(i);
+                c.rewire(nodeB, indexHelpers.get(i).getIndex(nodeB), nodeA, true);
+            }
+        }
     }
     
     private void reconnectPredecessors(E node, boolean predecessorRequired, boolean removeNode) throws PlanException {
@@ -694,23 +785,24 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             if(nodeBsuccessors != null)
                 size = nodeBsuccessors.size();
 
-            PlanException pe = new PlanException("Attempt to remove " +
-                    " and reconnect for node with  " + size +
-            " successors.");
-            log.error(pe.getMessage());
+            int errCode = 1096;
+            String msg = "Attempt to remove "
+                    + " and reconnect for node with  " + size + " successors.";
+            PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
             throw pe;
         }
 
         //A and C
         E nodeA = nodeBsuccessors.get(0);
-        Collection<E> nodeC = mToEdges.get(nodeB);
+        Collection<E> nodeC = (mToEdges.get(nodeB) == null? null : new ArrayList<E>(mToEdges.get(nodeB)));
 
         //checking pre-requisite conditions
         if(predecessorRequired) {
             if (nodeC == null || nodeC.size() == 0) {
-                PlanException pe = new PlanException("Attempt to remove " +
-                " and reconnect for node with no predecessors.");
-                log.error(pe.getMessage());
+                int errCode = 1096;
+                String msg = "Attempt to remove "
+                        + " and reconnect for node with no predecessors.";
+                PlanException pe = new PlanException(msg, errCode, PigException.INPUT);
                 throw pe;
             }
         }
@@ -721,6 +813,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         
         // for all C(predecessors) , replace B(node) in successors, with A(successor)
         if(nodeC != null) {
+                        
             for(E c: nodeC) {
                 Collection<E> sPreds = mFromEdges.get(c);
                 ArrayList<E> newPreds = new ArrayList<E>(sPreds.size());
@@ -736,6 +829,8 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
                 mFromEdges.removeKey(c);
                 mFromEdges.put(c,newPreds);
                 
+                //rewire nodeA 
+                nodeA.rewire(nodeB, 0, c, true);
             }
         }
         
@@ -750,7 +845,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
     
     // removes entry for successor in list of successors of node
     // and adds successors of successor in its place
-    // @param noded - parent node whose entry for successor needs to be replaced
+    // @param node - parent node whose entry for successor needs to be replaced
     // @param successor - see above
     private void replaceAndAddSucessors(E node, E successor) throws PlanException {
        Collection<E> oldSuccessors = mFromEdges.get(node);
@@ -944,12 +1039,24 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             replaceNode(firstNode, secondNode, firstNodePredecessor, mToEdges);
             replaceNode(secondNode, firstNode, secondNodeSuccessor, mFromEdges);
             replaceNode(secondNode, firstNodePredecessor, secondNodePredecessor, mToEdges);
+            
+            //rewire the two nodes
+            secondNode.rewire(firstNode, 0, firstNodePredecessor, true);
+            secondNode.regenerateProjectionMap();
+            firstNode.rewire(firstNodePredecessor, 0, secondNode, false);            
+
         } else {
             //Replace the predecessors and successors of first and second in their respective edge lists       
             replaceNode(firstNode, secondNodeSuccessor, firstNodeSuccessor, mFromEdges);
             replaceNode(firstNode, secondNodePredecessor, firstNodePredecessor, mToEdges);
             replaceNode(secondNode, firstNodeSuccessor, secondNodeSuccessor, mFromEdges);
             replaceNode(secondNode, firstNodePredecessor, secondNodePredecessor, mToEdges);
+            
+            //rewire the two nodes
+            //here the use of true as the final parameter is questionable
+            //there is no knowledge about how to use the projection maps
+            firstNode.rewire(firstNodePredecessor, 0, secondNodePredecessor, true);
+            secondNode.rewire(secondNodePredecessor, 0, firstNodePredecessor, true);
         }
 
         //Replace first with second in the edges list for first's predecessor and successor        
@@ -960,6 +1067,18 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         replaceNode(secondNodePredecessor, firstNode, secondNode, mFromEdges);
         replaceNode(secondNodeSuccessor, firstNode, secondNode, mToEdges);
         
+        if(firstNodeSuccessor != null) {
+            //here the use of true as the final parameter is questionable
+            //there is no knowledge about how to use the projection maps
+            firstNodeSuccessor.rewire(firstNode, 0, secondNode, true);
+        }
+        
+        if(secondNodeSuccessor != null) {
+            //here the use of true as the final parameter is questionable
+            //there is no knowledge about how to use the projection maps
+            secondNodeSuccessor.rewire(secondNode, 0, firstNode, true);
+        }
+        
         markDirty();
     }
 
@@ -992,7 +1111,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         checkInPlan(firstNode);
         checkInPlan(secondNode);
         
-        List<E> firstNodePredecessors = (ArrayList<E>)mToEdges.get(firstNode);
+        List<E> firstNodePredecessors = (mToEdges.get(firstNode) == null? null : new ArrayList<E>(mToEdges.get(firstNode)));
         
         if(firstNodePredecessors == null || firstNodePredecessors.size() <= 1) {
             int size = (firstNodePredecessors == null ? 0 : firstNodePredecessors.size());
@@ -1018,7 +1137,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             throw new PlanException(msg, errCode, PigException.INPUT);
         }
         
-        List<E> secondNodePredecessors = (ArrayList<E>)mToEdges.get(secondNode);
+        List<E> secondNodePredecessors = (mToEdges.get(secondNode) == null? null : new ArrayList<E>(mToEdges.get(secondNode)));
         
         if(secondNodePredecessors == null || secondNodePredecessors.size() > 1) {
             int size = (secondNodePredecessors == null ? 0 : secondNodePredecessors.size());
@@ -1028,7 +1147,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             throw new PlanException(msg, errCode, PigException.INPUT);
         }
         
-        List<E> secondNodeSuccessors = (ArrayList<E>)mFromEdges.get(secondNode);
+        List<E> secondNodeSuccessors = (mFromEdges.get(secondNode) == null? null : new ArrayList<E>(mFromEdges.get(secondNode)));
         
         //check for multiple edges from first to second
         int edgesFromFirstToSecond = 0;
@@ -1092,7 +1211,17 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         //  F  I   J   K  H           
         
         reconnectSuccessors(secondNode, false, false);
-        insertBetween(firstNodePredecessors.get(inputNum), secondNode, firstNode);
+        doInsertBetween(firstNodePredecessors.get(inputNum), secondNode, firstNode, false);
+        
+        //A note on the use of rewire
+        //Rewire is used within reconnectPredecessors. However, rewire is explicitly turned off in insertBetween
+        //The rewiring is done explicitly here to avoid exceptions that are generated due to precondition
+        //violations in insertBetween
+        IndexHelper<E> indexHelper = new IndexHelper<E>(secondNodePredecessors);
+        secondNode.rewire(firstNode, indexHelper.getIndex(firstNode), firstNodePredecessors.get(inputNum), true);
+        secondNode.regenerateProjectionMap();
+        //firstNode.rewire(firstNodePredecessors.get(inputNum), inputNum, secondNode, false);
+        firstNode.rewire(firstNodePredecessors.get(inputNum), 0, secondNode, false);
 
         markDirty();
         return;
@@ -1127,7 +1256,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         checkInPlan(firstNode);
         checkInPlan(secondNode);
         
-        List<E> firstNodePredecessors = (ArrayList<E>)mToEdges.get(firstNode);
+        List<E> firstNodePredecessors = (mToEdges.get(firstNode) == null? null : new ArrayList<E>(mToEdges.get(firstNode)));
 
         if(firstNodePredecessors == null) {
             int errCode = 1088;
@@ -1136,7 +1265,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             throw new PlanException(msg, errCode, PigException.INPUT);
         }        
 
-        List<E> firstNodeSuccessors = (ArrayList<E>)mFromEdges.get(firstNode);
+        List<E> firstNodeSuccessors = (mFromEdges.get(firstNode) == null? null: new ArrayList<E>(mFromEdges.get(firstNode)));
         
         if(firstNodeSuccessors == null || firstNodeSuccessors.size() <= 1) {
             int size = (firstNodeSuccessors == null ? 0 : firstNodeSuccessors.size());
@@ -1153,9 +1282,9 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             throw new PlanException(msg, errCode, PigException.INPUT);
         }
         
-        List<E> secondNodePredecessors = (ArrayList<E>)mToEdges.get(secondNode);
+        List<E> secondNodePredecessors = (mToEdges.get(secondNode) == null? null : new ArrayList<E>(mToEdges.get(secondNode)));
         
-        List<E> secondNodeSuccessors = (ArrayList<E>)mFromEdges.get(secondNode);
+        List<E> secondNodeSuccessors = (mFromEdges.get(secondNode) == null? null : new ArrayList<E>(mFromEdges.get(secondNode)));
 
         if(secondNodeSuccessors == null || secondNodeSuccessors.size() > 1) {
             int size = (secondNodeSuccessors == null ? 0 : secondNodeSuccessors.size());
@@ -1189,7 +1318,8 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         
         if(!firstNode.supportsMultipleInputs()) {
             int numSecondNodePredecessors = (secondNodePredecessors == null? 0 : secondNodePredecessors.size());
-            if((firstNodePredecessors.size() > 0) || (numSecondNodePredecessors > 0)) {
+            //if((firstNodePredecessors.size() > 0) || (numSecondNodePredecessors > 0)) {
+            if(numSecondNodePredecessors > 1) {
                 int errCode = 1091;
                 String msg = "First operator does not support multiple inputs."
                     + " On completing the pushAfter operation First operator will end up with "
@@ -1227,12 +1357,51 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         //         |
         //         J
         
+        
         reconnectPredecessors(secondNode, false, false);
-        insertBetween(firstNode, secondNode, firstNodeSuccessors.get(outputNum));
+        doInsertBetween(firstNode, secondNode, firstNodeSuccessors.get(outputNum), false);
+        //A note on the use of rewire
+        //Rewire is used within reconnectPredecessors. However, rewire is explicitly turned off in insertBetween
+        //The rewiring is done explicitly here to avoid exceptions that are generated due to precodition
+        //violations in insertBetween
+
+        if(secondNodePredecessors != null) {
+            for(int i = 0; i < secondNodePredecessors.size(); ++i) {
+                E secondNodePred = secondNodePredecessors.get(i);
+                secondNode.rewire(secondNodePred, i, firstNode, true);
+            }
+        }
+        
+        secondNode.regenerateProjectionMap();
+        firstNodeSuccessors.get(outputNum).rewire(firstNode, 0, secondNode, false);
         
         markDirty();
         return;
 
     }
+    
+    /*
+     * A helper class that computes the index of each reference in a list for a quick lookup
+     */
+    class IndexHelper <E> {
+        
+        private Map<E, Integer> mIndex = null;
+        
+        public IndexHelper(List<E> list) {
+            if(list != null) {
+                if(list.size() != 0) {
+                    mIndex = new HashMap<E, Integer>();
+                    for(int i = 0; i < list.size(); ++i) {
+                        mIndex.put(list.get(i), i);
+                    }
+                }
+            }
+        }
+        
+        public int getIndex(E e) {
+            if(mIndex == null || mIndex.size() == 0) return -1;
+            return mIndex.get(e);
+        }
+    }
 
 }
diff --git a/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java b/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
index 0c192af72..5870f6245 100644
--- a/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
+++ b/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
@@ -66,7 +66,12 @@ public abstract class PlanOptimizer<O extends Operator, P extends OperatorPlan<O
      * returns true as well, then Transformer.transform is called. 
      * @throws OptimizerException
      */
-    public final void optimize() throws OptimizerException {
+    public void optimize() throws OptimizerException {
+        //TODO
+        //made the method non-final
+        //we need a call back for transformer specific actions
+        //for example, the logical transformer rebuilds schemas
+        //after each successful transformation
         boolean sawMatch = false;
         int numIterations = 0;
         do {
diff --git a/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java b/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java
index 15762894a..c9fd66093 100644
--- a/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java
+++ b/src/org/apache/pig/impl/plan/optimizer/RuleMatcher.java
@@ -323,7 +323,7 @@ public class RuleMatcher<O extends Operator, P extends OperatorPlan<O>> {
      * the rule.  The nodes will be in the vector in the order they are
      * specified in the rule.
      */
-    List<List<O>> getAllMatches() {
+    public List<List<O>> getAllMatches() {
         return mMatches;
     }
 
diff --git a/test/org/apache/pig/test/TestMultiQuery.java b/test/org/apache/pig/test/TestMultiQuery.java
index 6620f113f..434d131b2 100644
--- a/test/org/apache/pig/test/TestMultiQuery.java
+++ b/test/org/apache/pig/test/TestMultiQuery.java
@@ -657,9 +657,9 @@ public class TestMultiQuery extends TestCase {
             myPig.registerQuery("e = foreach d generate flatten(b), flatten(c);");
             myPig.registerQuery("store e into '/tmp/output2';");
 
-            LogicalPlan lp = checkLogicalPlan(2, 2, 9);
+            LogicalPlan lp = checkLogicalPlan(2, 1, 7);
 
-            PhysicalPlan pp = checkPhysicalPlan(lp, 2, 2, 12);
+            PhysicalPlan pp = checkPhysicalPlan(lp, 2, 1, 10);
 
             checkMRPlan(pp, 1, 1, 2); 
 
@@ -827,11 +827,11 @@ public class TestMultiQuery extends TestCase {
             myPig.registerQuery("b = load '/tmp/output1' using PigStorage(':'); ");
             myPig.registerQuery("store b into '/tmp/output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 7);
+            LogicalPlan lp = checkLogicalPlan(1, 1, 5);
 
-            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 7);
+            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 5);
 
-            checkMRPlan(pp, 1, 1, 1); 
+            checkMRPlan(pp, 1, 1, 2); 
 
         } catch (Exception e) {
             e.printStackTrace();
@@ -1508,8 +1508,8 @@ public class TestMultiQuery extends TestCase {
             myPig.registerQuery("g = group f by $0;");
             myPig.registerQuery("store g into '/tmp/output4';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 4, 14);
-            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 4, 20);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 14);
+            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 20);
             MROperPlan mp = checkMRPlan(pp, 1, 2, 3);
 
             MapReduceOper mo1 = mp.getRoots().get(0);
@@ -1573,8 +1573,8 @@ public class TestMultiQuery extends TestCase {
             myPig.registerQuery("d = group c by $0;");
             myPig.registerQuery("e = store d into '/tmp/output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 9);
-            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 13);
+            LogicalPlan lp = checkLogicalPlan(1, 1, 7);
+            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 11);
             MROperPlan mp = checkMRPlan(pp, 1, 1, 2);
 
             MapReduceOper mo1 = mp.getRoots().get(0);
@@ -1624,8 +1624,8 @@ public class TestMultiQuery extends TestCase {
             myPig.registerQuery("c = cogroup a by $0, b by $0;");
             myPig.registerQuery("store c into '/tmp/output5';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
-            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 17);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 12);
+            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 15);
             MROperPlan mp = checkMRPlan(pp, 1, 3, 5);
 
             myPig.executeBatch();
diff --git a/test/org/apache/pig/test/TestMultiQueryLocal.java b/test/org/apache/pig/test/TestMultiQueryLocal.java
index 58afbcafb..efc48c583 100644
--- a/test/org/apache/pig/test/TestMultiQueryLocal.java
+++ b/test/org/apache/pig/test/TestMultiQueryLocal.java
@@ -458,8 +458,8 @@ public class TestMultiQueryLocal extends TestCase {
             myPig.registerQuery("c = cogroup a by $0, b by $0;");
             myPig.registerQuery("store c into '/tmp/output5';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
-            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 21);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 12);
+            PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 19);
 
             myPig.executeBatch();
             myPig.discardBatch(); 
diff --git a/test/org/apache/pig/test/TestProjectionMap.java b/test/org/apache/pig/test/TestProjectionMap.java
index e8e9389da..a2b09750a 100644
--- a/test/org/apache/pig/test/TestProjectionMap.java
+++ b/test/org/apache/pig/test/TestProjectionMap.java
@@ -62,21 +62,28 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the foreach projection map has null mappedFields
         //and null removed fields since the input schema is null
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        assertTrue(foreachProjectionMap.getMappedFields() == null);
+
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        assertTrue(foreachMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 2);
+        
         assertTrue(foreachProjectionMap.getRemovedFields() == null);
+        assertTrue(foreachProjectionMap.getAddedFields() == null);
         
-        //check that added fields contain [0, 1]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
-        assertTrue(foreachAddedFields.size() == 2);
-        assertTrue(foreachAddedFields.get(0) == 0);
-        assertTrue(foreachAddedFields.get(1) == 1);
     }
 
     @Test
@@ -87,21 +94,27 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the foreach projection map has null mappedFields
         //and null removed fields since the input schema is null
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        assertTrue(foreachProjectionMap.getMappedFields() == null);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        assertTrue(foreachMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+
         assertTrue(foreachProjectionMap.getRemovedFields() == null);
         
         //check that added fields contain [0, 1]
         List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
-        assertTrue(foreachAddedFields.size() == 2);
-        assertTrue(foreachAddedFields.get(0) == 0);
-        assertTrue(foreachAddedFields.get(1) == 1);
+        assertTrue(foreachAddedFields.size() == 1);
+        assertTrue(foreachAddedFields.get(0) == 1);
     }
 
     @Test
@@ -112,11 +125,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
 
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -170,7 +183,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -222,7 +235,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -280,11 +293,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
 
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -345,7 +358,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -406,12 +419,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the filter projection map has null mappedFields
         LOFilter filter = (LOFilter)lp.getLeaves().get(0);
         ProjectionMap filterProjectionMap = filter.getProjectionMap();
-        assertTrue(filterProjectionMap == null);
+        assertTrue(filterProjectionMap.changes() == false);
     }
     
     @Test
@@ -422,20 +435,20 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the split projection map has null mappedFields
         LOSplit split = (LOSplit)lp.getSuccessors(load).get(0);
         ProjectionMap splitProjectionMap = split.getProjectionMap();
-        assertTrue(splitProjectionMap == null);
+        assertTrue(splitProjectionMap.changes() == false);
         
         LOSplitOutput splitb = (LOSplitOutput)lp.getSuccessors(split).get(0);
         ProjectionMap splitbProjectionMap = splitb.getProjectionMap();
-        assertTrue(splitbProjectionMap == null);
+        assertTrue(splitbProjectionMap.changes() == false);
         
         LOSplitOutput splitc = (LOSplitOutput)lp.getSuccessors(split).get(1);
         ProjectionMap splitcProjectionMap = splitc.getProjectionMap();
-        assertTrue(splitcProjectionMap == null);
+        assertTrue(splitcProjectionMap.changes() == false);
     }
     
     @Test
@@ -446,12 +459,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the order by projection map has null mappedFields
         LOSort sort = (LOSort)lp.getLeaves().get(0);
         ProjectionMap sortProjectionMap = sort.getProjectionMap();
-        assertTrue(sortProjectionMap == null);
+        assertTrue(sortProjectionMap.changes() == false);
     }
     
     @Test
@@ -463,17 +476,17 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the order by projection map is not null
         LOSort sort = (LOSort)lp.getSuccessors(load).get(0);
         ProjectionMap sortProjectionMap = sort.getProjectionMap();
-        assertTrue(sortProjectionMap == null);
+        assertTrue(sortProjectionMap.changes() == false);
         
         //check that the limit projection map is null
         LOLimit limit = (LOLimit)lp.getLeaves().get(0);
         ProjectionMap limitProjectionMap = limit.getProjectionMap();
-        assertTrue(limitProjectionMap == null);
+        assertTrue(limitProjectionMap.changes() == false);
     }
     
     @Test
@@ -484,12 +497,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the distinct projection map has null mappedFields
         LODistinct distinct = (LODistinct)lp.getLeaves().get(0);
         ProjectionMap distinctProjectionMap = distinct.getProjectionMap();
-        assertTrue(distinctProjectionMap == null);
+        assertTrue(distinctProjectionMap.changes() == false);
     }
     
     @Test
@@ -500,7 +513,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the stream projection map is null
         LOStream stream = (LOStream)lp.getLeaves().get(0);
@@ -516,7 +529,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the stream projection map is null
         LOStream stream = (LOStream)lp.getLeaves().get(0);
@@ -532,7 +545,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the foreach projection map has null mappedFields
         //and null removed fields since the input schema is null
@@ -557,11 +570,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
 
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -630,11 +643,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
 
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -697,11 +710,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cross projection map
         LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
@@ -718,11 +731,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check union projection map
         LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
@@ -739,11 +752,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cross projection map
         LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
@@ -760,11 +773,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -825,7 +838,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the filter projection map is not null
         LOFilter filter = (LOFilter)lp.getLeaves().get(0);
@@ -842,7 +855,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the split projection map has null mappedFields
         LOSplit split = (LOSplit)lp.getSuccessors(load).get(0);
@@ -866,7 +879,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the order by projection map is not null
         LOSort sort = (LOSort)lp.getLeaves().get(0);
@@ -884,7 +897,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the order by projection map is not null
         LOSort sort = (LOSort)lp.getSuccessors(load).get(0);
@@ -907,7 +920,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the distinct projection map is not null
         LODistinct distinct = (LODistinct)lp.getLeaves().get(0);
@@ -924,7 +937,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the stream projection map is null
         LOStream stream = (LOStream)lp.getLeaves().get(0);
@@ -947,7 +960,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the load projection map is null
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadProjectionMap = load.getProjectionMap();
-        assertTrue(loadProjectionMap == null);
+        assertTrue(loadProjectionMap.changes() == false);
         
         //check that the stream projection map is null
         LOStream stream = (LOStream)lp.getLeaves().get(0);
@@ -982,11 +995,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
 
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -1107,11 +1120,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cross projection map
         LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
@@ -1154,11 +1167,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check union projection map
         LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
@@ -1200,11 +1213,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cross projection map
         LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
@@ -1248,11 +1261,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
@@ -1331,11 +1344,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cross projection map
         LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
@@ -1351,11 +1364,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check union projection map
         LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
@@ -1371,11 +1384,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cross projection map
         LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
@@ -1392,11 +1405,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         //check that the loads' projection map is null
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
-        assertTrue(loadaProjectionMap == null);
+        assertTrue(loadaProjectionMap.changes() == false);
         
         LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
+        assertTrue(loadbProjectionMap.changes() == false);
         
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
diff --git a/test/org/apache/pig/test/TestRequiredFields.java b/test/org/apache/pig/test/TestRequiredFields.java
index 5410421eb..b37e71b1c 100644
--- a/test/org/apache/pig/test/TestRequiredFields.java
+++ b/test/org/apache/pig/test/TestRequiredFields.java
@@ -18,8 +18,6 @@
 package org.apache.pig.test;
 
 import java.util.List;
-import java.util.ArrayList;
-import java.util.Set;
 
 import org.junit.After;
 import org.junit.Test;
@@ -27,10 +25,8 @@ import org.junit.Test;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pig.builtin.PigStorage;
-import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.logicalLayer.*;
-import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
 import org.apache.pig.test.utils.LogicalPlanTester;
 
diff --git a/test/org/apache/pig/test/TestRewire.java b/test/org/apache/pig/test/TestRewire.java
new file mode 100644
index 000000000..04aca6d2a
--- /dev/null
+++ b/test/org/apache/pig/test/TestRewire.java
@@ -0,0 +1,602 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.After;
+import org.junit.Test;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.pig.PigException;
+import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.logicalLayer.*;
+import org.apache.pig.impl.util.LogUtils;
+import org.apache.pig.test.utils.LogicalPlanTester;
+
+
+public class TestRewire extends junit.framework.TestCase {
+
+    private final Log log = LogFactory.getLog(getClass());
+    LogicalPlanTester planTester = new LogicalPlanTester();
+    
+    @After
+    @Override
+    public void tearDown() throws Exception{
+        planTester.reset(); 
+    }
+
+    private static final String simpleEchoStreamingCommand;
+    static {
+        if (System.getProperty("os.name").toUpperCase().startsWith("WINDOWS"))
+            simpleEchoStreamingCommand = "perl -ne 'print \\\"$_\\\"'";
+        else
+            simpleEchoStreamingCommand = "perl -ne 'print \"$_\"'";
+    }
+
+    
+    @Test
+    public void testQueryForeachFilterSwap() throws Exception {
+        String query = "filter (foreach (load 'a') generate $1,$2) by $1 > 0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        LOForEach foreach = (LOForEach)lp.getSuccessors(load).get(0);
+        LOFilter filter = (LOFilter)lp.getLeaves().get(0);
+        
+        lp.swap(filter, foreach);
+        
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+        LOProject filterProject;
+        List<LogicalOperator> filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(load));
+        assertTrue(filterProject.getCol() == 2);
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        LOProject foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        assertTrue(foreachProject.getExpression().equals(filter));
+        assertTrue(foreachProject.getCol() == 1);
+        
+        foreachPlan = foreach.getForEachPlans().get(1);
+        foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        assertTrue(foreachProject.getExpression().equals(filter));
+        assertTrue(foreachProject.getCol() == 2);
+        
+    }
+    
+    @Test
+    public void testQueryForeachFilterSwap1() throws Exception {
+        planTester.buildPlan("a = foreach (foreach (load 'a') generate $1,$2 )  generate $0, $1;");
+        String query = "b = filter a by $1 > 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        LOForEach foreach = (LOForEach)lp.getSuccessors(load).get(0);
+        LOForEach foreach2 = (LOForEach)lp.getSuccessors(foreach).get(0);
+        LOFilter filter = (LOFilter)lp.getLeaves().get(0);
+        
+        lp.swap(filter, foreach2);
+        
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+        LOProject filterProject;
+        List<LogicalOperator> filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(foreach));
+        assertTrue(filterProject.getCol() == 1);
+        
+        LogicalPlan foreach2Plan = foreach2.getForEachPlans().get(0);
+        LOProject foreachProject = (LOProject) foreach2Plan.getRoots().get(0);
+        assertTrue(foreachProject.getExpression().equals(filter));
+        assertTrue(foreachProject.getCol() == 0);
+        
+        foreach2Plan = foreach2.getForEachPlans().get(1);
+        foreachProject = (LOProject) foreach2Plan.getRoots().get(0);
+        assertTrue(foreachProject.getExpression().equals(filter));
+        assertTrue(foreachProject.getCol() == 1);
+        
+        lp.swap(filter, foreach);
+        
+        filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(load));
+        assertTrue(filterProject.getCol() == 2);
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        assertTrue(foreachProject.getExpression().equals(filter));
+        assertTrue(foreachProject.getCol() == 1);
+        
+        foreachPlan = foreach.getForEachPlans().get(1);
+        foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        assertTrue(foreachProject.getExpression().equals(filter));
+        assertTrue(foreachProject.getCol() == 2);
+    }
+
+    @Test
+    public void testNegativeQueryForeach1() throws Exception {
+        String query = "foreach (load 'a') generate $1,$2;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        try {
+            lp.swap(load, foreach);
+            fail("Expected failure.");
+        } catch (Exception e){
+            PigException pe = LogUtils.getPigException(e);
+            assertTrue(pe.getErrorCode() == 1100);
+        }
+        
+    }
+
+    @Test
+    public void testQuerySortFilterSwap() throws Exception {
+        String query = "filter (order (load 'a') by $1,$2) by $1 > 0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        LOSort sort = (LOSort)lp.getSuccessors(load).get(0);
+        LOFilter filter = (LOFilter)lp.getLeaves().get(0);
+        
+        lp.swap(filter, sort);
+        
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+        LOProject filterProject;
+        List<LogicalOperator> filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(load));
+        assertTrue(filterProject.getCol() == 1);
+        
+        LogicalPlan sortPlan = sort.getSortColPlans().get(0);
+        LOProject sortProject = (LOProject) sortPlan.getRoots().get(0);
+        assertTrue(sortProject.getExpression().equals(filter));
+        assertTrue(sortProject.getCol() == 1);
+        
+        sortPlan = sort.getSortColPlans().get(1);
+        sortProject = (LOProject) sortPlan.getRoots().get(0);
+        assertTrue(sortProject.getExpression().equals(filter));
+        assertTrue(sortProject.getCol() == 2);
+        
+    }
+    
+    @Test
+    public void testQuerySplitFilterInsertBetween() throws Exception {
+        planTester.buildPlan("a = load 'a';");
+        planTester.buildPlan("b = foreach a generate $0, $1, $2;");
+        planTester.buildPlan("split b into d if $0 == '3', c if $1 == '3';");
+        String query = "filter d by $2 > 0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        LOForEach foreach = (LOForEach)lp.getSuccessors(load).get(0);
+        LOSplit split = (LOSplit)lp.getSuccessors(foreach).get(0);
+        LOSplitOutput splitd = (LOSplitOutput)lp.getSuccessors(split).get(0);
+        LOFilter filter = (LOFilter)lp.getLeaves().get(0);
+        
+        lp.insertBetween(foreach, filter, split);
+        
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+        LOProject filterProject;
+        List<LogicalOperator> filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(foreach));
+        assertTrue(filterProject.getCol() == 2);
+        
+        LogicalPlan splitdPlan = splitd.getConditionPlan();
+        LOProject splitdProject;
+        List<LogicalOperator> splitdRoots = splitdPlan.getRoots();
+        if(splitdRoots.get(0) instanceof LOProject) {
+            splitdProject = (LOProject)splitdRoots.get(0);
+        } else {
+            splitdProject = (LOProject)splitdRoots.get(1);
+        }
+
+        assertTrue(splitdProject.getExpression().equals(filter));
+        assertTrue(splitdProject.getCol() == 0);
+        
+    }
+
+    @Test
+    public void testQueryFRJoinFilterPushBefore() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' as (url, rank);");
+        planTester.buildPlan("c = join a by $0, b by $0 using \"replicated\" ;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $2 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOFilter filter = (LOFilter)lp.getSuccessors(frjoin).get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        lp.pushBefore(frjoin, filter, 0);
+        
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+        LOProject filterProject;
+        List<LogicalOperator> filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(loada));
+        assertTrue(filterProject.getCol() == 0);
+        
+        
+        LogicalPlan joinPlan = ((List<LogicalPlan>)(frjoin.getJoinColPlans().get(filter))).get(0);
+        LOProject joinProject = (LOProject)joinPlan.getRoots().get(0);
+        assertTrue(joinProject.getExpression().equals(filter));
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        LOProject foreachProject;
+        
+        if(foreachPlan.getRoots().get(0) instanceof LOProject) {
+            foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        } else {
+            foreachProject = (LOProject) foreachPlan.getRoots().get(1);
+        }
+        
+        assertTrue(foreachProject.getExpression().equals(frjoin));
+        assertTrue(foreachProject.getCol() == 2);
+        
+    }
+    
+    @Test
+    public void testQueryCogroupFilterPushBefore() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' as (url, rank);");
+        planTester.buildPlan("c = cogroup a by $1, b by $1;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $0 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        LOFilter filter = (LOFilter)lp.getSuccessors(cogroup).get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        lp.pushBefore(cogroup, filter, 1);
+        
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+        LOProject filterProject;
+        List<LogicalOperator> filterRoots = filterPlan.getRoots();
+        if(filterRoots.get(0) instanceof LOProject) {
+            filterProject = (LOProject)filterRoots.get(0);
+        } else {
+            filterProject = (LOProject)filterRoots.get(1);
+        }
+        assertTrue(filterProject.getExpression().equals(loadb));
+        assertTrue(filterProject.getCol() == 1);
+        
+        LogicalPlan cogroupPlan = ((List<LogicalPlan>)(cogroup.getGroupByPlans().get(filter))).get(0);
+        LOProject cogroupProject = (LOProject)cogroupPlan.getRoots().get(0);
+        assertTrue(cogroupProject.getExpression().equals(filter));
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        LOProject foreachProject;
+        
+        if(foreachPlan.getRoots().get(0) instanceof LOProject) {
+            foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        } else {
+            foreachProject = (LOProject) foreachPlan.getRoots().get(1);
+        }
+        
+        assertTrue(foreachProject.getExpression().equals(cogroup));
+        assertTrue(foreachProject.getCol() == 0);
+        
+    }
+    
+    @Test
+    public void testQueryFRJoinFilterPushBeforeNegative() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' ;");
+        planTester.buildPlan("c = join a by $0, b by $0 using \"replicated\" ;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $2 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOFilter filter = (LOFilter)lp.getSuccessors(frjoin).get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        try {
+            lp.pushBefore(frjoin, filter, 0);
+            fail("Expected failure.");
+        } catch (Exception e) {
+            PigException pe = LogUtils.getPigException(e);
+            assertTrue(pe.getErrorCode() == 2146);
+        }        
+    }
+    
+    @Test
+    public void testQueryCogroupFilterPushBeforeNegative() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' ;");
+        planTester.buildPlan("c = cogroup a by $0, b by $0;");
+        planTester.buildPlan("d = filter c by $1 > 0;");
+        String query = "e = foreach d generate $0 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        LOFilter filter = (LOFilter)lp.getSuccessors(cogroup).get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        try {
+            lp.pushBefore(cogroup, filter, 0);
+            fail("Expected failure.");
+        } catch(Exception e) {
+            PigException pe = LogUtils.getPigException(e);
+            assertTrue(pe.getErrorCode() == 2148);
+        }
+        
+    }
+
+    
+    @Test
+    public void testQueryCogroupTrimAboveNegative() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' as (url, rank);");
+        planTester.buildPlan("c = cogroup a by $0, b by $0;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $0 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+
+        try {
+            lp.trimAbove(cogroup);
+            fail("Excepted failure.");
+        } catch (Exception e) {
+            PigException pe = LogUtils.getPigException(e);
+            assertTrue(pe.getErrorCode() == 1097);
+        }
+        
+    }
+    
+    @Test
+    public void testQueryCogroupTrimAboveNegative1() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' as (url, rank);");
+        planTester.buildPlan("c = cogroup a by 0, b by 0;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $0 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        
+        try {
+            lp.trimAbove(cogroup);
+            fail("Excepted failure");
+        } catch (Exception e) {
+            PigException pe = LogUtils.getPigException(e);
+            assertTrue(pe.getErrorCode() == 1097);
+        }
+        
+    }
+    
+    @Test
+    public void testQueryReplaceFilter() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' as (url, rank);");
+        planTester.buildPlan("c = cogroup a by $0, b by $0;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $0 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        LOFilter filter = (LOFilter)lp.getSuccessors(cogroup).get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        LogicalPlanCloner lpCloner = new LogicalPlanCloner(foreachPlan);
+        LogicalPlan foreachPlanClone = lpCloner.getClonedPlan();
+        ArrayList<LogicalPlan> newForeachPlans = new ArrayList<LogicalPlan>();
+        newForeachPlans.add(foreachPlanClone);
+        
+        LOProject newForeachProject;
+        if(foreachPlanClone.getRoots().get(0) instanceof LOProject) {
+            newForeachProject = (LOProject)foreachPlanClone.getRoots().get(0); 
+        } else {
+            newForeachProject = (LOProject)foreachPlanClone.getRoots().get(1);
+        }
+        
+        newForeachProject.setExpression(cogroup);
+        
+        ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
+        flattenList.add(true);
+        LOForEach newForeach = new LOForEach(lp, new OperatorKey("", 1000), newForeachPlans, flattenList);        
+        lp.replace(filter, newForeach);
+        
+        LOProject foreachProject;
+        if(foreachPlan.getRoots().get(0) instanceof LOProject) {
+            foreachProject = (LOProject)foreachPlan.getRoots().get(0); 
+        } else {
+            foreachProject = (LOProject)foreachPlan.getRoots().get(1);
+        }
+        
+        assertTrue(foreachProject.getExpression().equals(newForeach));
+        assertTrue(foreachProject.getCol() == 0);
+        
+        //ensure that the new foreach projection is not altered
+        assertTrue(newForeachProject.getExpression().equals(cogroup));
+        assertTrue(newForeachProject.getCol() == 0);
+    }
+    
+    @Test
+    public void testQueryReemoveFilterAndReconnect() throws Exception {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = load 'b' as (url, rank);");
+        planTester.buildPlan("c = cogroup a by $0, b by $0;");
+        planTester.buildPlan("d = filter c by $0 > 0;");
+        String query = "e = foreach d generate $0 + 0;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        LOFilter filter = (LOFilter)lp.getSuccessors(cogroup).get(0);
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        lp.removeAndReconnect(filter);
+        
+        LOProject foreachProject;
+        if(foreachPlan.getRoots().get(0) instanceof LOProject) {
+            foreachProject = (LOProject)foreachPlan.getRoots().get(0); 
+        } else {
+            foreachProject = (LOProject)foreachPlan.getRoots().get(1);
+        }
+        
+        assertTrue(foreachProject.getExpression().equals(cogroup));
+        assertTrue(foreachProject.getCol() == 0);
+        
+    }
+    
+    //TODO
+    /*
+     * Currently, there are no use cases for pushAfter making it hard to test rewire
+     * in the case of pushAfter. This test case will fail as the foreach is pushed
+     * after the split and before the splitOutput instead of being pushed after
+     * the splitOutput
+     */
+/*
+    @Test
+    public void testQueryForeachSplitPushAfter()  {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        planTester.buildPlan("b = group a by $0;");
+        planTester.buildPlan("c = foreach b generate group, flatten(a);");
+        String query = "split c into d if $0 > 10, e if $0 < 10;";
+        
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        LOForEach foreach = (LOForEach)lp.getSuccessors(cogroup).get(0);
+        LOSplit split = (LOSplit)lp.getSuccessors(foreach).get(0);
+        LOSplitOutput splitd = (LOSplitOutput)lp.getLeaves().get(0);
+        LOSplitOutput splite = (LOSplitOutput)lp.getLeaves().get(1);
+        
+        try {
+            lp.pushAfter(split, foreach, 0);
+        } catch (PlanException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        
+        LogicalPlan splitdPlan = splitd.getConditionPlan();
+        LOProject splitdProject;
+        List<LogicalOperator> splitdRoots = splitdPlan.getRoots();
+        if(splitdRoots.get(0) instanceof LOProject) {
+            splitdProject = (LOProject)splitdRoots.get(0);
+        } else {
+            splitdProject = (LOProject)splitdRoots.get(1);
+        }
+        log.info("splitdProject.getExpression(): " + splitdProject.getExpression());
+        assertTrue(splitdProject.getExpression().equals(foreach));
+
+        LogicalPlan splitePlan = splite.getConditionPlan();
+        LOProject spliteProject;
+        List<LogicalOperator> spliteRoots = splitePlan.getRoots();
+        if(spliteRoots.get(0) instanceof LOProject) {
+            spliteProject = (LOProject)spliteRoots.get(0);
+        } else {
+            spliteProject = (LOProject)spliteRoots.get(1);
+        }
+        assertTrue(spliteProject.getExpression().equals(foreach));
+
+        
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        LOProject foreachProject;
+        
+        if(foreachPlan.getRoots().get(0) instanceof LOProject) {
+            foreachProject = (LOProject) foreachPlan.getRoots().get(0);
+        } else {
+            foreachProject = (LOProject) foreachPlan.getRoots().get(1);
+        }
+        
+        assertTrue(foreachProject.getExpression().equals(split));
+        
+    }
+*/
+}
diff --git a/test/org/apache/pig/test/utils/LogicalPlanTester.java b/test/org/apache/pig/test/utils/LogicalPlanTester.java
index 4bda77e93..0de86eff9 100644
--- a/test/org/apache/pig/test/utils/LogicalPlanTester.java
+++ b/test/org/apache/pig/test/utils/LogicalPlanTester.java
@@ -27,6 +27,7 @@ import org.apache.pig.impl.plan.PlanValidationException;
 import org.apache.pig.impl.plan.CompilationMessageCollector;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.NodeIdGenerator;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.optimizer.OptimizerException;
 import org.apache.pig.ExecType;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.* ;
@@ -237,5 +238,15 @@ public class LogicalPlanTester {
         return null;
     }
 
+    public void setPlan(LogicalPlan lp) throws VisitorException {
+        PlanSetter ps = new PlanSetter(lp);
+        ps.visit();
+    }
+    
+    public void setProjectionMap(LogicalPlan lp) throws VisitorException {
+        ProjectionMapCalculator pmc = new ProjectionMapCalculator(lp);
+        pmc.visit();
+    }
+
 
 }
