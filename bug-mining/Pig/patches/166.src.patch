diff --git a/CHANGES.txt b/CHANGES.txt
index 326100e5a..462cfc776 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -436,3 +436,7 @@ Trunk (unreleased changes)
     PIG-664: Semantics of * is not consistent (sms)
 
     PIG-684: outputSchema method in TOKENIZE is broken (thejas via sms)
+
+    PIG-655: Comparison of schemas of bincond operands is flawed (sms via
+    pradeepkth)
+
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 6ac06a131..1ee7d96bb 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -1773,9 +1773,11 @@ public class TypeCheckingVisitor extends LOVisitor {
             // Matching schemas if we're working with tuples
             if (DataType.isSchemaType(lhsType)) {            
                 try {
-                    if (!Schema.equals(binCond.getLhsOp().getSchema(), binCond.getRhsOp().getSchema(), false, true)) {
+                    if (!Schema.FieldSchema.equals(binCond.getLhsOp().getFieldSchema(), binCond.getRhsOp().getFieldSchema(), false, true)) {
                         int errCode = 1048;
-                        String msg = "Two inputs of BinCond must have compatible schemas" ;
+                        String msg = "Two inputs of BinCond must have compatible schemas." 
+                            + " left hand side: " + binCond.getLhsOp().getFieldSchema() 
+                            + " right hand side: " + binCond.getRhsOp().getFieldSchema();
                         msgCollector.collect(msg, MessageType.Error) ;
                         throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
                     }
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidator.java b/test/org/apache/pig/test/TestTypeCheckingValidator.java
index a1ec53ddf..4ea02808c 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidator.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidator.java
@@ -25,6 +25,7 @@ import java.util.ArrayList;
 
 import junit.framework.TestCase;
 
+import org.apache.pig.EvalFunc;
 import org.apache.pig.FuncSpec;
 import org.apache.pig.impl.logicalLayer.validators.*;
 import org.apache.pig.impl.logicalLayer.* ;
@@ -5556,7 +5557,79 @@ public class TestTypeCheckingValidator extends TestCase {
         assertTrue(cast.getLoadFuncSpec().getClassName().startsWith("org.apache.pig.builtin.PigStorage"));
 
     }
+    
+    @Test
+    public void testBincond() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (name: chararray, age: int, gpa: float);") ;
+        planTester.buildPlan("b = group a by name;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate (IsEmpty(a) ? " + TestBinCondFieldSchema.class.getName() + "(*): a) ;") ;
 
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Did not expect an error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        
+        Schema.FieldSchema charFs = new FieldSchema(null, DataType.CHARARRAY);
+        Schema.FieldSchema intFs = new FieldSchema(null, DataType.INTEGER);
+        Schema.FieldSchema floatFs = new FieldSchema(null, DataType.FLOAT);
+        Schema bagSchema = new Schema();
+        bagSchema.add(charFs);
+        bagSchema.add(intFs);
+        bagSchema.add(floatFs);
+        Schema.FieldSchema bagFs = null;
+        try {
+            bagFs = new Schema.FieldSchema(null, bagSchema, DataType.BAG);
+        } catch (FrontendException fee) {
+            fail("Did not expect an error");
+        }
+        
+        Schema expectedSchema = new Schema(bagFs);
+        
+        assertTrue(Schema.equals(foreach.getSchema(), expectedSchema, false, true));
+
+    }
+
+    /*
+     * A test UDF that does not data processing but implements the getOutputSchema for
+     * checking the type checker
+     */
+    public static class TestBinCondFieldSchema extends EvalFunc<DataBag> {
+        //no-op exec method
+        public DataBag exec(Tuple input) {
+            return null;
+        }
+        
+        @Override
+        public Schema outputSchema(Schema input) {
+            Schema.FieldSchema charFs = new FieldSchema(null, DataType.CHARARRAY);
+            Schema.FieldSchema intFs = new FieldSchema(null, DataType.INTEGER);
+            Schema.FieldSchema floatFs = new FieldSchema(null, DataType.FLOAT);
+            Schema bagSchema = new Schema();
+            bagSchema.add(charFs);
+            bagSchema.add(intFs);
+            bagSchema.add(floatFs);
+            Schema.FieldSchema bagFs;
+            try {
+                bagFs = new Schema.FieldSchema(null, bagSchema, DataType.BAG);
+            } catch (FrontendException fee) {
+                return null;
+            }
+            return new Schema(bagFs);
+        }
+    }
+    
     ////////////////////////// Helper //////////////////////////////////
     private void checkForEachCasting(LOForEach foreach, int idx, boolean isCast, byte toType) {
         LogicalPlan plan = foreach.getForEachPlans().get(idx) ;
