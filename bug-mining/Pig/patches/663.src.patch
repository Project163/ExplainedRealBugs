diff --git a/CHANGES.txt b/CHANGES.txt
index 06a31aa12..34fa5b57b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,6 +26,8 @@ PIG-1680: HBaseStorage should work with HBase 0.90 (gstathis, billgraham, dvryab
 
 IMPROVEMENTS
 
+PIG-1918: Line number should be give for logical plan failures (xuefu)
+
 PIG-1899: Add end to end test harness for Pig (gates)
 
 PIG-1932: GFCross should allow the user to set the DEFAULT_PARALLELISM value (gates)
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 62ab49f33..93c67bb94 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -89,7 +89,6 @@ import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.visitor.CastLineageSetter;
 import org.apache.pig.newplan.logical.visitor.ColumnAliasConversionVisitor;
-import org.apache.pig.newplan.logical.visitor.ProjectStarExpander;
 import org.apache.pig.newplan.logical.visitor.ScalarVisitor;
 import org.apache.pig.newplan.logical.visitor.SchemaAliasVisitor;
 import org.apache.pig.newplan.logical.visitor.TypeCheckingRelVisitor;
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckerException.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckerException.java
index f11fa31eb..2f55473d2 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckerException.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckerException.java
@@ -90,6 +90,18 @@ public class TypeCheckerException extends VisitorException {
         super(message, errCode, errSrc);
     }
 
+    /**
+     * Create a new TypeCheckerException with the specified message and cause.
+     *
+     * @param op - The logical operator where the error occurred
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     * @param errSrc - The error source 
+     */
+    public TypeCheckerException(org.apache.pig.newplan.Operator op, String message, int errCode, byte errSrc) {
+        super(op, message, errCode, errSrc);
+    }
+
     /**
      * Create a new TypeCheckerException with the specified message and cause.
      *
@@ -103,6 +115,20 @@ public class TypeCheckerException extends VisitorException {
         super(message, errCode, errSrc, cause);
     }
 
+    /**
+     * Create a new TypeCheckerException with the specified message and cause.
+     *
+     * @param op - The logical operator where the error occurred
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     * @param errSrc - The error source
+     * @param cause - The cause (which is saved for later retrieval by the <link>Throwable.getCause()</link> method) indicating the source of this exception. A null value is permitted, and indicates that the cause is nonexistent or unknown. 
+     */
+    public TypeCheckerException(org.apache.pig.newplan.Operator op, String message, int errCode, byte errSrc,
+            Throwable cause) {
+        super(op, message, errCode, errSrc, cause);
+    }
+
     /**
      * Create a new TypeCheckerException with the specified message and cause.
      *
diff --git a/src/org/apache/pig/impl/plan/PlanValidationException.java b/src/org/apache/pig/impl/plan/PlanValidationException.java
index 3ab4e8db2..a77c0fe7d 100644
--- a/src/org/apache/pig/impl/plan/PlanValidationException.java
+++ b/src/org/apache/pig/impl/plan/PlanValidationException.java
@@ -37,6 +37,16 @@ public class PlanValidationException extends VisitorException {
         super(message);
     }
     
+    /**
+     * Create a new PlanValidationException with the specified message and cause.
+     *
+     * @param op - logical operator where the exception occurs
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     */
+    public PlanValidationException(org.apache.pig.newplan.Operator op, String message) {
+        super(op, message);
+    }
+
     /**
      * Create a new PlanValidationException with the specified cause.
      *
@@ -66,6 +76,16 @@ public class PlanValidationException extends VisitorException {
         super(message, errCode);
     }
 
+    /**
+     * Create a new PlanValidationException with the specified message and cause.
+     *
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     */
+    public PlanValidationException(org.apache.pig.newplan.Operator op, String message, int errCode) {
+        super(op, message, errCode);
+    }
+
     /**
      * Create a new PlanValidationException with the specified message and cause.
      *
@@ -88,6 +108,17 @@ public class PlanValidationException extends VisitorException {
         super(message, errCode, errSrc);
     }   
 
+    /**
+     * Create a new PlanValidationException with the specified message and cause.
+     *
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     * @param errSrc - The error source 
+     */
+    public PlanValidationException(org.apache.pig.newplan.Operator op, String message, int errCode, byte errSrc) {
+        super(op, message, errCode, errSrc);
+    }   
+
     /**
      * Create a new PlanValidationException with the specified message and cause.
      *
diff --git a/src/org/apache/pig/impl/plan/VisitorException.java b/src/org/apache/pig/impl/plan/VisitorException.java
index e3e07e862..d9ee16106 100644
--- a/src/org/apache/pig/impl/plan/VisitorException.java
+++ b/src/org/apache/pig/impl/plan/VisitorException.java
@@ -39,6 +39,16 @@ public class VisitorException extends FrontendException {
         super(message);
     }
 
+    /**
+     * Create a new VisitorException with the specified message and cause.
+     *
+     * @param op - logical operator where the exception occurs
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     */
+    public VisitorException(org.apache.pig.newplan.Operator op, String message) {
+        super(op.getLocation() + message);
+    }
+
     /**
      * Create a new VisitorException with the specified cause.
      *
@@ -68,6 +78,17 @@ public class VisitorException extends FrontendException {
         super(message, errCode);
     }
 
+    /**
+     * Create a new VisitorException with the specified message and cause.
+     *
+     * @param op - logical operator where the exception occurs
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     */
+    public VisitorException(org.apache.pig.newplan.Operator op, String message, int errCode) {
+        super(op.getLocation() + message, errCode);
+    }
+
     /**
      * Create a new VisitorException with the specified message and cause.
      *
@@ -90,6 +111,18 @@ public class VisitorException extends FrontendException {
         super(message, errCode, errSrc);
     }
 
+    /**
+     * Create a new VisitorException with the specified message and cause.
+     *
+     * @param op - logical operator where the exception occurs
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     * @param errSrc - The error source 
+     */
+    public VisitorException(org.apache.pig.newplan.Operator op, String message, int errCode, byte errSrc) {
+        super(op.getLocation() + message, errCode, errSrc);
+    }
+
     /**
      * Create a new VisitorException with the specified message and cause.
      *
@@ -103,6 +136,20 @@ public class VisitorException extends FrontendException {
         super(message, errCode, errSrc, cause);
     }
 
+    /**
+     * Create a new VisitorException with the specified message and cause.
+     *
+     * @param op - logical operator where the exception occurs
+     * @param message - The error message (which is saved for later retrieval by the <link>Throwable.getMessage()</link> method) shown to the user 
+     * @param errCode - The error code shown to the user 
+     * @param errSrc - The error source
+     * @param cause - The cause (which is saved for later retrieval by the <link>Throwable.getCause()</link> method) indicating the source of this exception. A null value is permitted, and indicates that the cause is nonexistent or unknown. 
+     */
+    public VisitorException(org.apache.pig.newplan.Operator op, String message, int errCode, byte errSrc,
+            Throwable cause) {
+        super(op.getLocation() + message, errCode, errSrc, cause);
+    }
+
     /**
      * Create a new VisitorException with the specified message and cause.
      *
diff --git a/src/org/apache/pig/newplan/Operator.java b/src/org/apache/pig/newplan/Operator.java
index 8aa3c8e54..fe1221ea9 100644
--- a/src/org/apache/pig/newplan/Operator.java
+++ b/src/org/apache/pig/newplan/Operator.java
@@ -22,8 +22,10 @@ import java.util.HashMap;
 import java.util.Map;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.parser.SourceLocation;
 
 public abstract class Operator {
+    protected SourceLocation location; // The location of the operator in the original pig script.
     
     protected String name;
     protected OperatorPlan plan; // plan that contains this operator
@@ -34,6 +36,7 @@ public abstract class Operator {
         name = n;
         plan = p;
         annotations = new HashMap<String, Object>();
+        location = new SourceLocation();
     }
 
     /**
@@ -47,6 +50,14 @@ public abstract class Operator {
         return name;
     }
     
+    public SourceLocation getLocation() {
+        return location;
+    }
+    
+    public void setLocation(SourceLocation loc) {
+        location = loc;
+    }
+    
     /**
      * Get the plan associated with this operator.
      * @return plan
diff --git a/src/org/apache/pig/newplan/logical/expression/AddExpression.java b/src/org/apache/pig/newplan/logical/expression/AddExpression.java
index d0a23d215..49f1cd274 100644
--- a/src/org/apache/pig/newplan/logical/expression/AddExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/AddExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Add Operator
@@ -78,6 +79,7 @@ public class AddExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 }
diff --git a/src/org/apache/pig/newplan/logical/expression/AndExpression.java b/src/org/apache/pig/newplan/logical/expression/AndExpression.java
index 2f2bd19ff..3099f6d76 100644
--- a/src/org/apache/pig/newplan/logical/expression/AndExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/AndExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Boolean and expression.
@@ -79,6 +80,7 @@ public class AndExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 }
diff --git a/src/org/apache/pig/newplan/logical/expression/BinCondExpression.java b/src/org/apache/pig/newplan/logical/expression/BinCondExpression.java
index d8f7f7f75..e2eab20e9 100644
--- a/src/org/apache/pig/newplan/logical/expression/BinCondExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/BinCondExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class BinCondExpression extends LogicalExpression {
 
@@ -114,6 +115,7 @@ public class BinCondExpression extends LogicalExpression {
                 this.getCondition().deepCopy(lgExpPlan),
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 }
diff --git a/src/org/apache/pig/newplan/logical/expression/CastExpression.java b/src/org/apache/pig/newplan/logical/expression/CastExpression.java
index 0151675e1..13a93345d 100644
--- a/src/org/apache/pig/newplan/logical/expression/CastExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/CastExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class CastExpression extends UnaryExpression {
     private FuncSpec castFunc;
@@ -97,6 +98,7 @@ public class CastExpression extends UnaryExpression {
         } catch(CloneNotSupportedException e) {
             e.printStackTrace(); 
         }
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/ConstantExpression.java b/src/org/apache/pig/newplan/logical/expression/ConstantExpression.java
index 42e2b6b88..305c8ecb2 100644
--- a/src/org/apache/pig/newplan/logical/expression/ConstantExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/ConstantExpression.java
@@ -28,6 +28,7 @@ import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.Util;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * A constant
@@ -105,7 +106,9 @@ public class ConstantExpression extends ColumnExpression {
  
     @Override
     public LogicalExpression deepCopy(LogicalExpressionPlan lgExpPlan) throws FrontendException{
-        return new ConstantExpression(lgExpPlan, this.getValue());
+        LogicalExpression copy = new ConstantExpression(lgExpPlan, this.getValue());
+        copy.setLocation( new SourceLocation( location ) );
+        return copy;
     }
  
 }
diff --git a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
index d9d8f6acd..da5599fd6 100644
--- a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
@@ -28,6 +28,7 @@ import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * 
@@ -208,6 +209,7 @@ public class DereferenceExpression extends ColumnExpression {
         lgExpPlan.add( inputCopy );
         lgExpPlan.connect( copy, inputCopy );
         
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/DivideExpression.java b/src/org/apache/pig/newplan/logical/expression/DivideExpression.java
index 1d211aacb..52470fd71 100644
--- a/src/org/apache/pig/newplan/logical/expression/DivideExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/DivideExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Divide Operator
@@ -78,6 +79,7 @@ public class DivideExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/EqualExpression.java b/src/org/apache/pig/newplan/logical/expression/EqualExpression.java
index f26e115b7..d8776bc05 100644
--- a/src/org/apache/pig/newplan/logical/expression/EqualExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/EqualExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Equality test expression.
@@ -81,6 +82,7 @@ public class EqualExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/GreaterThanEqualExpression.java b/src/org/apache/pig/newplan/logical/expression/GreaterThanEqualExpression.java
index 0b9299b22..1744e93c0 100644
--- a/src/org/apache/pig/newplan/logical/expression/GreaterThanEqualExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/GreaterThanEqualExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class GreaterThanEqualExpression extends BinaryExpression {
 
@@ -75,6 +76,7 @@ public class GreaterThanEqualExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/GreaterThanExpression.java b/src/org/apache/pig/newplan/logical/expression/GreaterThanExpression.java
index c3adc5f3f..664c64a53 100644
--- a/src/org/apache/pig/newplan/logical/expression/GreaterThanExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/GreaterThanExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class GreaterThanExpression extends BinaryExpression {
 
@@ -75,6 +76,7 @@ public class GreaterThanExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/IsNullExpression.java b/src/org/apache/pig/newplan/logical/expression/IsNullExpression.java
index 732525d3c..4a961eef8 100644
--- a/src/org/apache/pig/newplan/logical/expression/IsNullExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/IsNullExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class IsNullExpression extends UnaryExpression {
 
@@ -63,6 +64,7 @@ public class IsNullExpression extends UnaryExpression {
         LogicalExpression copy = new IsNullExpression ( 
                 lgExpPlan,
                 this.getExpression().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/LessThanEqualExpression.java b/src/org/apache/pig/newplan/logical/expression/LessThanEqualExpression.java
index 07788acbb..abe06bbf3 100644
--- a/src/org/apache/pig/newplan/logical/expression/LessThanEqualExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/LessThanEqualExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class LessThanEqualExpression extends BinaryExpression {
 
@@ -75,6 +76,7 @@ public class LessThanEqualExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/LessThanExpression.java b/src/org/apache/pig/newplan/logical/expression/LessThanExpression.java
index a512b02a8..0d5c25fed 100644
--- a/src/org/apache/pig/newplan/logical/expression/LessThanExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/LessThanExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class LessThanExpression extends BinaryExpression {
 
@@ -75,6 +76,7 @@ public class LessThanExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/MapLookupExpression.java b/src/org/apache/pig/newplan/logical/expression/MapLookupExpression.java
index b38bc891a..bbce80e11 100644
--- a/src/org/apache/pig/newplan/logical/expression/MapLookupExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/MapLookupExpression.java
@@ -26,6 +26,7 @@ import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class MapLookupExpression extends ColumnExpression {
 
@@ -135,6 +136,7 @@ public class MapLookupExpression extends ColumnExpression {
         LogicalExpression inputCopy = input.deepCopy( lgExpPlan );
         lgExpPlan.add( inputCopy );
         lgExpPlan.connect( copy, inputCopy );
+        copy.setLocation( new SourceLocation( location ) );
         
         return copy;
     }
diff --git a/src/org/apache/pig/newplan/logical/expression/ModExpression.java b/src/org/apache/pig/newplan/logical/expression/ModExpression.java
index 06276db16..e7703b2d8 100644
--- a/src/org/apache/pig/newplan/logical/expression/ModExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/ModExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Mod Operator
@@ -78,6 +79,7 @@ public class ModExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan));
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/MultiplyExpression.java b/src/org/apache/pig/newplan/logical/expression/MultiplyExpression.java
index c23f990a1..4339d979a 100644
--- a/src/org/apache/pig/newplan/logical/expression/MultiplyExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/MultiplyExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Multiply Operator
@@ -78,6 +79,7 @@ public class MultiplyExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/NegativeExpression.java b/src/org/apache/pig/newplan/logical/expression/NegativeExpression.java
index 0b1c768c5..4448d4f6d 100644
--- a/src/org/apache/pig/newplan/logical/expression/NegativeExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/NegativeExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class NegativeExpression extends UnaryExpression {
 
@@ -63,6 +64,7 @@ public class NegativeExpression extends UnaryExpression {
         LogicalExpression copy = new NegativeExpression(
                 lgExpPlan,
                 this.getExpression().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/NotEqualExpression.java b/src/org/apache/pig/newplan/logical/expression/NotEqualExpression.java
index 9ffd51e97..f81fb3eaf 100644
--- a/src/org/apache/pig/newplan/logical/expression/NotEqualExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/NotEqualExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * NotEquality test expression.
@@ -79,6 +80,7 @@ public class NotEqualExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/NotExpression.java b/src/org/apache/pig/newplan/logical/expression/NotExpression.java
index 48e2929df..0136f1ef8 100644
--- a/src/org/apache/pig/newplan/logical/expression/NotExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/NotExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class NotExpression extends UnaryExpression {
 
@@ -63,6 +64,7 @@ public class NotExpression extends UnaryExpression {
         LogicalExpression copy = new NotExpression(
                 lgExpPlan,
                 this.getExpression().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/OrExpression.java b/src/org/apache/pig/newplan/logical/expression/OrExpression.java
index d67dd9df5..8c578810e 100644
--- a/src/org/apache/pig/newplan/logical/expression/OrExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/OrExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Boolean OR Expression
@@ -79,6 +80,7 @@ public class OrExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java b/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java
index 3e67f1aa2..2bb28fe1c 100644
--- a/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java
@@ -34,6 +34,7 @@ import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Projection of columns in an expression.
@@ -90,7 +91,7 @@ public class ProjectExpression extends ColumnExpression {
      * @throws FrontendException 
      */
     public ProjectExpression(OperatorPlan plan, int inputNum, String alias,
-            LogicalRelationalOperator attachedRelationalOp) throws FrontendException {
+            LogicalRelationalOperator attachedRelationalOp) {
         super("Project", plan);
         this.input = inputNum;
         this.alias = alias;
@@ -151,14 +152,14 @@ public class ProjectExpression extends ColumnExpression {
             if(startCol < 0){
                 String msg = "Invalid start column position in " +
                 "range projection (..) " + startCol;
-                throw new FrontendException(msg, 2270, PigException.BUG);
+                throw new PlanValidationException(this, msg, 2270, PigException.BUG);
             }
             
             if(endCol > 0 && startCol > endCol){
                 String msg = "start column appears after end column in " +
                 "range projection (..) . Start column position " + startCol +
                 " End column position " + endCol;
-                throw new FrontendException(msg, 1127, PigException.INPUT);
+                throw new PlanValidationException(this, msg, 1127, PigException.INPUT);
             }
         }else{
             setColNum(findColNum(alias));
@@ -174,7 +175,7 @@ public class ProjectExpression extends ColumnExpression {
         if( alias != null ) {
             int colNum = inputSchema == null ? -1 : inputSchema.getFieldPosition( alias );
             if( colNum == -1 ) {
-                throw new PlanValidationException(
+                throw new PlanValidationException( this,
                         "Invalid field projection. Projected field [" + 
                         alias + "] does not exist in schema: " +
                         (inputSchema!=null?inputSchema.toString(false):"") + ".", 1025 );
@@ -183,7 +184,7 @@ public class ProjectExpression extends ColumnExpression {
         } else {
             int col = getColNum();
             if( inputSchema != null && col >= inputSchema.size() ) {
-                throw new PlanValidationException( 
+                throw new PlanValidationException( this,
                         "Out of bound access. Trying to access non-existent column: " + 
                         col + ". Schema " +  inputSchema.toString(false) + 
                         " has " + inputSchema.size() + " column(s)." , 1000);
@@ -501,7 +502,8 @@ public class ProjectExpression extends ColumnExpression {
                 this.getInputNum(),
                 this.getColNum(),
                 this.getAttachedRelationalOp());
-        copy.alias = this.alias; 
+        copy.setLocation( new SourceLocation( location ) );
+        copy.alias = alias; 
         copy.isRangeProject = this.isRangeProject;
         copy.startCol = this.startCol;
         copy.endCol = this.endCol;
diff --git a/src/org/apache/pig/newplan/logical/expression/RegexExpression.java b/src/org/apache/pig/newplan/logical/expression/RegexExpression.java
index b5c9b3c5e..303158c7e 100644
--- a/src/org/apache/pig/newplan/logical/expression/RegexExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/RegexExpression.java
@@ -24,6 +24,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Regex Operator
@@ -79,6 +80,7 @@ public class RegexExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/ScalarExpression.java b/src/org/apache/pig/newplan/logical/expression/ScalarExpression.java
index 36ae6924a..0d0207c83 100644
--- a/src/org/apache/pig/newplan/logical/expression/ScalarExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/ScalarExpression.java
@@ -30,6 +30,7 @@ import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class ScalarExpression extends UserFuncExpression {
     private Operator implicitReferencedOperator = null;
@@ -96,6 +97,7 @@ public class ScalarExpression extends UserFuncExpression {
             }
         }
         
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/SubtractExpression.java b/src/org/apache/pig/newplan/logical/expression/SubtractExpression.java
index f41199a9d..5a1b60e35 100644
--- a/src/org/apache/pig/newplan/logical/expression/SubtractExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/SubtractExpression.java
@@ -23,6 +23,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Subtract Operator
@@ -78,6 +79,7 @@ public class SubtractExpression extends BinaryExpression {
                 lgExpPlan,
                 this.getLhs().deepCopy(lgExpPlan),
                 this.getRhs().deepCopy(lgExpPlan) );
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
  
diff --git a/src/org/apache/pig/newplan/logical/expression/UnaryExpression.java b/src/org/apache/pig/newplan/logical/expression/UnaryExpression.java
index 466bb5f85..c8780d10f 100644
--- a/src/org/apache/pig/newplan/logical/expression/UnaryExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/UnaryExpression.java
@@ -19,7 +19,6 @@
 package org.apache.pig.newplan.logical.expression;
 
 import java.util.List;
-import java.io.IOException;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.newplan.Operator;
diff --git a/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java b/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
index 9162807b9..04f0acdf9 100644
--- a/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
@@ -31,6 +31,7 @@ import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.Util;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.parser.SourceLocation;
 
 public class UserFuncExpression extends LogicalExpression {
 
@@ -164,6 +165,7 @@ public class UserFuncExpression extends LogicalExpression {
         } catch(CloneNotSupportedException e) {
              e.printStackTrace();
         }
+        copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
     
diff --git a/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java b/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java
index d74c7fc6f..ad7c4141d 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java
@@ -27,6 +27,7 @@ import org.apache.pig.newplan.PlanVisitor;
 import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
 import org.apache.pig.newplan.logical.expression.ProjectExpression;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+import org.apache.pig.parser.SourceLocation;
 
 /**
  * Operator to map the data into the inner plan of LOForEach
@@ -175,4 +176,10 @@ public class LOInnerLoad extends LogicalRelationalOperator {
         }
         return msg.toString();
     }
+    
+    @Override
+    public void setLocation(SourceLocation loc) {
+    	super.setLocation( loc );
+    	prj.setLocation( loc );
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/rules/InputOutputFileValidator.java b/src/org/apache/pig/newplan/logical/rules/InputOutputFileValidator.java
index 49a9dcc66..5d4e74a5d 100644
--- a/src/org/apache/pig/newplan/logical/rules/InputOutputFileValidator.java
+++ b/src/org/apache/pig/newplan/logical/rules/InputOutputFileValidator.java
@@ -26,18 +26,11 @@ import org.apache.pig.StoreFuncInterface;
 import org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.newplan.DepthFirstWalker;
 import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.PlanWalker;
-import org.apache.pig.newplan.logical.Util;
-import org.apache.pig.newplan.logical.relational.LOCogroup;
 import org.apache.pig.newplan.logical.relational.LOStore;
-import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
-import org.apache.pig.newplan.logical.rules.GroupByConstParallelSetter.GroupAllParallelSetterTransformer;
-import org.apache.pig.newplan.optimizer.Rule;
-import org.apache.pig.newplan.optimizer.Transformer;
 
 public class InputOutputFileValidator {
     private PigContext pigCtx;
@@ -79,7 +72,7 @@ public class InputOutputFileValidator {
                 } 
                 String exceptionMsg = ioe.getMessage();
                 validationErrStr += (exceptionMsg == null) ? "" : " More info to follow:\n" +exceptionMsg;
-                throw new FrontendException(validationErrStr, errCode, pigCtx.getErrorSource(), ioe);
+                throw new VisitorException(store, validationErrStr, errCode, pigCtx.getErrorSource(), ioe);
             }
             
             validationErrStr += " More info to follow:\n";
@@ -99,10 +92,10 @@ public class InputOutputFileValidator {
                     break;
                 }
                 validationErrStr  += ioe.getMessage();
-                throw new FrontendException(validationErrStr, errCode, errSrc, ioe);
+                throw new VisitorException(store, validationErrStr, errCode, errSrc, ioe);
             } catch (InterruptedException ie) {
                 validationErrStr += ie.getMessage();
-                throw new FrontendException(validationErrStr, errCode, pigCtx.getErrorSource(), ie);
+                throw new VisitorException(store, validationErrStr, errCode, pigCtx.getErrorSource(), ie);
             }
         }
     }
diff --git a/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java b/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java
index 8363f9ded..b9367d1f4 100644
--- a/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java
@@ -25,7 +25,6 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.plan.PlanValidationException;
 import org.apache.pig.newplan.DependencyOrderWalker;
-import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.logical.expression.DereferenceExpression;
 import org.apache.pig.newplan.logical.expression.LogicalExpression;
@@ -33,8 +32,6 @@ import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
 import org.apache.pig.newplan.logical.expression.LogicalExpressionVisitor;
 import org.apache.pig.newplan.logical.expression.ProjectExpression;
 import org.apache.pig.newplan.logical.optimizer.AllExpressionVisitor;
-import org.apache.pig.newplan.logical.relational.LogicalPlan;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 
 /**
@@ -84,14 +81,14 @@ public class ColumnAliasConversionVisitor extends AllExpressionVisitor {
                     if( rc instanceof Integer ) {
                     	col = (Integer)rc;
                     	if( schema != null && col >= schema.size() ) {
-                            throw new PlanValidationException( "Out of bound access. Trying to access non-existent column: " + 
+                            throw new PlanValidationException( expr, "Out of bound access. Trying to access non-existent column: " + 
                                     col + ". Schema " + schema.toString(false) + " has " + schema.size() + " column(s).", 1000 );
                     	}
                         cols.add( (Integer)rc );
                     } else {
                         col = schema == null ? -1 : schema.getFieldPosition( (String)rc );
                         if( col == -1 ) {
-                            throw new PlanValidationException( "Invalid field reference. Referenced field [" + 
+                            throw new PlanValidationException( expr, "Invalid field reference. Referenced field [" + 
                             		rc + "] does not exist in schema: " + (schema!=null?schema.toString(false):"") + "." , 1000);
                         }
                         cols.add( col );
diff --git a/src/org/apache/pig/newplan/logical/visitor/LineageFindRelVisitor.java b/src/org/apache/pig/newplan/logical/visitor/LineageFindRelVisitor.java
index fb1f93950..60219fff6 100644
--- a/src/org/apache/pig/newplan/logical/visitor/LineageFindRelVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/LineageFindRelVisitor.java
@@ -26,7 +26,6 @@ import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.streaming.StreamingCommand;
 import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
@@ -409,13 +408,13 @@ public class LineageFindRelVisitor extends LogicalRelationalNodesVisitor{
         if(inputSch == null || outSchema == null){
             String msg = "Bug: in split only one of input/output schema is null "
                 + split;
-            throw new VisitorException(msg,2260, PigException.BUG) ; 
+            throw new VisitorException(split, msg,2260, PigException.BUG) ; 
         }
         
         if(inputSch.size() != outSchema.size()){
             String msg = "Bug: input and output schema size of split differ "
                 + split;
-            throw new VisitorException(msg,2261, PigException.BUG) ; 
+            throw new VisitorException(split, msg,2261, PigException.BUG) ; 
         }
 
         for(int i=0; i<inputSch.size(); i++){
diff --git a/src/org/apache/pig/newplan/logical/visitor/ProjectStarExpander.java b/src/org/apache/pig/newplan/logical/visitor/ProjectStarExpander.java
index 09670b2b7..585ffb303 100644
--- a/src/org/apache/pig/newplan/logical/visitor/ProjectStarExpander.java
+++ b/src/org/apache/pig/newplan/logical/visitor/ProjectStarExpander.java
@@ -25,6 +25,7 @@ import java.util.Map.Entry;
 
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.newplan.DependencyOrderWalker;
 import org.apache.pig.newplan.DepthFirstWalker;
@@ -164,7 +165,7 @@ public class ProjectStarExpander extends LogicalRelationalNodesVisitor{
                         String msg = "Cogroup/Group by '*' or 'x..' " +
                         "(range of columns to the end) " +
                         "is only allowed if the input has a schema";
-                        throw new FrontendException(
+                        throw new VisitorException( cg,
                                 msg,
                                 1123,
                                 PigException.INPUT
@@ -178,7 +179,7 @@ public class ProjectStarExpander extends LogicalRelationalNodesVisitor{
             if(arity != inpExprPlans.get(i).size()) {
                 String msg = "The arity of cogroup/group by columns " +
                 "do not match";
-                throw new FrontendException(
+                throw new VisitorException(cg,
                         msg,
                         1122,
                         PigException.INPUT
@@ -215,11 +216,11 @@ public class ProjectStarExpander extends LogicalRelationalNodesVisitor{
             if(op instanceof LOGenerate){
                 if(gen != null){
                     String msg = "Expected single LOGenerate output in innerplan of foreach";
-                    throw new FrontendException(
+                    throw new VisitorException(foreach,
                             msg,
                             2266,
                             PigException.BUG
-                    );                    
+                    );
                 }
                 gen = (LOGenerate) op;
             }
@@ -573,7 +574,7 @@ public class ProjectStarExpander extends LogicalRelationalNodesVisitor{
                     if(outputs.size() > 1){
                         String msg = "More than one operator in an expression plan" +
                         " containing project star(*)/project-range (..)";
-                        throw new FrontendException(
+                        throw new VisitorException(proj,
                                 msg,
                                 2264,
                                 PigException.BUG
diff --git a/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java b/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java
index 1da05f1eb..52924e572 100644
--- a/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java
@@ -82,7 +82,7 @@ public class ScalarVisitor extends AllExpressionVisitor {
                     try {
                         fileSpec = new FileSpec( FileLocalizer.getTemporaryPath( pigContext ).toString(), funcSpec );                    // TODO: need to hookup the pigcontext.
                     } catch (IOException e) {
-                        throw new PlanValidationException( "Failed to process scalar: " + e);
+                        throw new PlanValidationException( expr, "Failed to process scalar" + e);
                     }
                     store = new LOStore( lp, fileSpec );
                     store.setTmpStore(true);
diff --git a/src/org/apache/pig/newplan/logical/visitor/SchemaAliasVisitor.java b/src/org/apache/pig/newplan/logical/visitor/SchemaAliasVisitor.java
index 94d0e341e..0b169b873 100644
--- a/src/org/apache/pig/newplan/logical/visitor/SchemaAliasVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/SchemaAliasVisitor.java
@@ -71,7 +71,7 @@ public class SchemaAliasVisitor extends LogicalRelationalNodesVisitor {
                         String msg = "Duplicate schema alias: " + schema.getField( i ).alias;
                         if( op.getAlias() != null )
                             msg = msg + " in \"" + op.getAlias() + "\"";
-                        throw new PlanValidationException( msg, errCode, PigException.INPUT );
+                        throw new PlanValidationException( op, msg, errCode, PigException.INPUT );
                     }
                     seenAliases.add(alias);
                 }
diff --git a/src/org/apache/pig/newplan/logical/visitor/SortInfoSetter.java b/src/org/apache/pig/newplan/logical/visitor/SortInfoSetter.java
index fe37a55dc..270cb3e5d 100644
--- a/src/org/apache/pig/newplan/logical/visitor/SortInfoSetter.java
+++ b/src/org/apache/pig/newplan/logical/visitor/SortInfoSetter.java
@@ -21,6 +21,7 @@ package org.apache.pig.newplan.logical.visitor;
 import org.apache.pig.PigException;
 import org.apache.pig.SortInfo;
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.newplan.DependencyOrderWalker;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
@@ -46,7 +47,7 @@ public class SortInfoSetter extends LogicalRelationalNodesVisitor {
         if(storePred == null){
             int errCode = 2051;
             String msg = "Did not find a predecessor for Store." ;
-            throw new FrontendException(msg, errCode, PigException.BUG);    
+            throw new VisitorException(store, msg, errCode, PigException.BUG);    
         }
         
         SortInfo sortInfo = null;
@@ -72,12 +73,8 @@ public class SortInfoSetter extends LogicalRelationalNodesVisitor {
         }
         // if this predecessor is a sort, get
         // the sort info.
-        if(storePred instanceof LOSort) {
-            try {
-                sortInfo = ((LOSort)storePred).getSortInfo();
-            } catch (FrontendException e) {
-                throw new FrontendException(e);
-            }
+        if( storePred instanceof LOSort ) {
+            sortInfo = ((LOSort)storePred).getSortInfo();
         }
         store.setSortInfo(sortInfo);
     }
diff --git a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
index c1b9b2f11..5b5f50caa 100644
--- a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
@@ -168,7 +168,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1039;
             String msg = generateIncompatibleTypesMessage(binOp);
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(binOp, msg, errCode, PigException.INPUT) ;
         }
 
         binOp.resetFieldSchema();
@@ -211,14 +211,14 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1039;
             String msg = generateIncompatibleTypesMessage(binOp);
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(binOp, msg, errCode, PigException.INPUT) ;
         }
         binOp.resetFieldSchema();
     }
 
     private String generateIncompatibleTypesMessage(BinaryExpression binOp)
     throws FrontendException {
-        String msg = ""; 
+        String msg = binOp.toString(); 
         if (currentRelOp.getAlias()!=null){
             msg = "In alias " + currentRelOp.getAlias() + ", ";
         }
@@ -247,7 +247,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1041;
             String msg = "NEG can be used with numbers or Bytearray only" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(negExp, msg, errCode, PigException.INPUT) ;
         }
 
         negExp.resetFieldSchema();
@@ -257,7 +257,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1040;
             String msg = "Could not set Negative field schema";
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throw new TypeCheckerException(negExp, msg, errCode, PigException.INPUT, fe) ;
         }
     }
     
@@ -272,7 +272,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1042;
             String msg = "NOT can be used with boolean only" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException( notExp, msg, errCode, PigException.INPUT) ;
         }
 
     }
@@ -302,7 +302,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1038;
             String msg = "Operands of AND/OR can be boolean only" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(boolExp, msg, errCode, PigException.INPUT) ;
         }
     }
 
@@ -403,7 +403,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1039;
             String msg = generateIncompatibleTypesMessage(binOp);
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(binOp, msg, errCode, PigException.INPUT) ;
         }
         //input types might have changed, regenerate field schema
         binOp.resetFieldSchema();
@@ -450,7 +450,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         catch (PlanException pe) {
             int errCode = 2059;
             String msg = "Problem with inserting cast operator for " + node + " in plan.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
+            throw new TypeCheckerException(arg, msg, errCode, PigException.BUG, pe);
         }
         this.visit(cast);
     }
@@ -474,7 +474,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1051;
             String msg = "Cannot cast to bytearray";
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ; 
+            throw new TypeCheckerException(cast, msg, errCode, PigException.INPUT) ; 
         }
         
         LogicalFieldSchema inFs = cast.getExpression().getFieldSchema();
@@ -496,7 +496,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                            + DataType.findTypeName(outType)
                            + ((DataType.isSchemaType(outType))? " with schema " + outFs.toString(false) : "");
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ; 
+            throw new TypeCheckerException(cast, msg, errCode, PigException.INPUT) ; 
         }
        
     }
@@ -527,7 +527,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1037;
             String msg = "Operands of Regex can be CharArray only :" + rg;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(rg, msg, errCode, PigException.INPUT) ;
         }
     }
     
@@ -538,7 +538,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1047;
             String msg = "Condition in BinCond must be boolean" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(binCond, msg, errCode, PigException.INPUT) ;
         }       
         
         byte lhsType = binCond.getLhs().getType() ;
@@ -575,7 +575,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             } catch (FrontendException e) {
                 int errCode = 2216;
                 String msg = "Problem getting fieldSchema for " +binCond.getRhs();
-                throw new TypeCheckerException(msg, errCode, PigException.BUG, e);
+                throw new TypeCheckerException(binCond, msg, errCode, PigException.BUG, e);
             }
         } else if (binCond.getRhs() instanceof ConstantExpression
                 && ((ConstantExpression) binCond.getRhs()).getValue() == null) {
@@ -584,7 +584,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             } catch (FrontendException e) {
                 int errCode = 2216;
                 String msg = "Problem getting fieldSchema for " +binCond.getRhs();
-                throw new TypeCheckerException(msg, errCode, PigException.BUG, e);
+                throw new TypeCheckerException(binCond, msg, errCode, PigException.BUG, e);
             }
         } else if (lhsType == rhsType) {
             // Matching schemas if we're working with tuples/bags
@@ -596,7 +596,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                             + " left hand side: " + binCond.getLhs().getFieldSchema() 
                             + " right hand side: " + binCond.getRhs().getFieldSchema();
                         msgCollector.collect(msg, MessageType.Error) ;
-                        throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                        throw new TypeCheckerException(binCond, msg, errCode, PigException.INPUT) ;
                     }
                     // TODO: We may have to merge the schema here
                     //       if the previous check is not exact match
@@ -605,7 +605,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                     int errCode = 1049;
                     String msg = "Problem during evaluaton of BinCond output type" ;
                     msgCollector.collect(msg, MessageType.Error) ;
-                    throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+                    throw new TypeCheckerException(binCond, msg, errCode, PigException.INPUT, fe) ;
                 }
             }
         }
@@ -616,7 +616,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                 + DataType.findTypeName(rhsType);
             
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throw new TypeCheckerException(binCond, msg, errCode, PigException.INPUT) ;
         }
         
 
@@ -645,14 +645,14 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                 int errCode = 1014;
                 String msg = "Problem with input " + op + " of User-defined function: " + func;
                 msgCollector.collect(msg, MessageType.Error);
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                throw new TypeCheckerException(func, msg, errCode, PigException.INPUT) ;
             }
             try {
                 currentArgSchema.add(Util.translateFieldSchema(op.getFieldSchema()));    
             } catch (FrontendException e) {
                 int errCode = 1043;
                 String msg = "Unable to retrieve field schema.";
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT, e);
+                throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, e);
             }
             
         }
@@ -674,7 +674,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         } catch (Exception e) {
             int errCode = 1044;
             String msg = "Unable to get list of overloaded methods.";
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, e);
+            throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, e);
         }
         
         /**
@@ -722,7 +722,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                 //Oops, no exact match found. Trying to see if we
                 //have mappings that we can fit using casts.
                 notExactMatch = true;
-                if(byteArrayFound(currentArgSchema)){
+                if(byteArrayFound(func, currentArgSchema)){
                     // try "exact" matching all other fields except the byte array 
                     // fields and if they all exact match and we have only one candidate
                     // for the byte array cast then that's the matching one!
@@ -734,7 +734,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                                 + func.getFuncSpec()
                                 + " as multiple or none of them fit. Please use an explicit cast.";
                             msgCollector.collect(msg, MessageType.Error);
-                            throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+                            throw new TypeCheckerException(func, msg, errCode, PigException.INPUT);
                         }
                     }
                 } else if ((matchingSpec = bestFitMatch(funcSpecs, currentArgSchema)) == null) {
@@ -748,7 +748,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                             + func.getFuncSpec()
                             + " as multiple or none of them fit. Please use an explicit cast.";
                     msgCollector.collect(msg, MessageType.Error);
-                    throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+                    throw new TypeCheckerException(func, msg, errCode, PigException.INPUT);
                 }
             }
         }
@@ -778,7 +778,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1040;
             String msg = "Could not set UserFunc field schema";
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee) ;
+            throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, fee) ;
         }
     }
     
@@ -826,11 +826,11 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                         + scoreFuncSpecList.get(0).second.getInputArgsSchema() + ", " 
                         + scoreFuncSpecList.get(1).second.getInputArgsSchema() + "). Please use an explicit cast.";
                 msgCollector.collect(msg, MessageType.Error);
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+                throw new TypeCheckerException(func, msg, errCode, PigException.INPUT);
             }
         
             // now consider the bytearray fields
-            List<Integer> byteArrayPositions = getByteArrayPositions(s);
+            List<Integer> byteArrayPositions = getByteArrayPositions(func, s);
             // make sure there is only one type to "cast to" for the byte array
             // positions among the candidate funcSpecs
             Map<Integer, Pair<FuncSpec, Byte>> castToMap = new HashMap<Integer, Pair<FuncSpec, Byte>>();
@@ -857,13 +857,13 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                                         + ", " + funcSpec.getInputArgsSchema() 
                                         + "). Please use an explicit cast.";
                                 msgCollector.collect(msg, MessageType.Error);
-                                throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+                                throw new TypeCheckerException(func, msg, errCode, PigException.INPUT);
                             }
                         }
                     } catch (FrontendException fee) {
                         int errCode = 1043;
                         String msg = "Unalbe to retrieve field schema.";
-                        throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee);
+                        throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, fee);
                     }
                 }
             }
@@ -959,11 +959,12 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
     
     /**
      * Checks to see if any field of the input schema is a byte array
+     * @param func 
      * @param s - input schema
      * @return true if found else false
      * @throws VisitorException
      */
-    private boolean byteArrayFound(Schema s) throws VisitorException {
+    private boolean byteArrayFound(UserFuncExpression func, Schema s) throws VisitorException {
         for(int i=0;i<s.size();i++){
             try {
                 FieldSchema fs=s.getField(i);
@@ -973,7 +974,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             } catch (FrontendException fee) {
                 int errCode = 1043;
                 String msg = "Unable to retrieve field schema.";
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee);
+                throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, fee);
             }
         }
         return false;
@@ -981,12 +982,13 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
 
     /**
      * Gets the positions in the schema which are byte arrays
+     * @param func 
      * 
      * @param s -
      *            input schema
      * @throws VisitorException
      */
-    private List<Integer> getByteArrayPositions(Schema s)
+    private List<Integer> getByteArrayPositions(UserFuncExpression func, Schema s)
             throws VisitorException {
         List<Integer> result = new ArrayList<Integer>();
         for (int i = 0; i < s.size(); i++) {
@@ -998,7 +1000,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             } catch (FrontendException fee) {
                 int errCode = 1043;
                 String msg = "Unable to retrieve field schema.";
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee);            }
+                throw new TypeCheckerException(func, msg, errCode, PigException.INPUT, fee);            }
         }
         return result;
     }
@@ -1036,7 +1038,7 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
                                         + ", " + matchingSpecs.get(1).getInputArgsSchema() 
                                         + "). Please use an explicit cast.";
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+            throw new TypeCheckerException(func, msg, errCode, PigException.INPUT);
         }
         
         // exactly one matching spec - return it
diff --git a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingRelVisitor.java b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingRelVisitor.java
index 08347729b..b19a53ef5 100644
--- a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingRelVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingRelVisitor.java
@@ -103,7 +103,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1057;
             String msg = "Filter's cond plan can only have one output" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throwTypeCheckerException(filter, msg, errCode, PigException.INPUT, null) ;
         }
 
         // visit the filter expression
@@ -114,12 +114,12 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
         byte innerCondType = ((LogicalExpression)comparisonPlan.getSources().get(0)).getType();
         if (innerCondType != DataType.BOOLEAN) {
             int errCode = 1058;
-            String msg = "Filter's condition must evaluate to boolean. Found: " + DataType.findTypeName(innerCondType);
+            String msg = "Filter's condition must evaluate to boolean. Found: " + 
+                         DataType.findTypeName(innerCondType);
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throwTypeCheckerException(filter, msg, errCode, PigException.INPUT, null) ;
         }       
 
-
         try {
             // re-compute the schema
             filter.resetSchema();
@@ -129,11 +129,20 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1059;
             String msg = "Problem while reconciling output schema of Filter" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(filter, msg, errCode, PigException.INPUT, fe) ;
         }
     }
     
-    @Override
+    private void throwTypeCheckerException(Operator op, String msg,
+			int errCode, byte input, FrontendException fe) throws TypeCheckerException {
+    	if( fe == null ) {
+		    throw new TypeCheckerException(op, msg, errCode, PigException.INPUT);
+    	}
+		throw new TypeCheckerException(op, msg, errCode, PigException.INPUT, fe);
+		
+	}
+
+	@Override
     public void visit(LOGenerate gen) throws FrontendException {
         for(int i=0; i < gen.getOutputPlans().size(); i++) {
             LogicalExpressionPlan expPlan = gen.getOutputPlans().get(i);
@@ -142,7 +151,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                 int errCode = 1057;
                 String msg = "LOGenerate expression plan can only have one output" ;
                 msgCollector.collect(msg, MessageType.Error) ;
-                throw new TypeCheckerException( msg, errCode, PigException.BUG ) ;
+                throwTypeCheckerException( gen, msg, errCode, PigException.BUG, null) ;
             }
             // visit the filter expression
             visitExpressionPlan( expPlan, gen );
@@ -170,7 +179,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1059;
             String msg = "Problem while reconciling output schema of ForEach" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(forEach, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -212,7 +221,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1055;
             String msg = "Problem while reading schemas from inputs of Union" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee) ;
+            throwTypeCheckerException(u, msg, errCode, PigException.INPUT, fee) ;
         }
 
         // Do cast insertion only if we are typed 
@@ -237,7 +246,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                         int errCode = 1056;
                         String msg = "Problem while casting inputs of Union" ;
                         msgCollector.collect(msg, MessageType.Error) ;
-                        throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee) ;
+                        throwTypeCheckerException(u, msg, errCode, PigException.INPUT, fee) ;
                     }
                 }
             }
@@ -276,7 +285,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
         if (!found) {
             int errCode = 1077;
             String msg = "Two operators that require a cast in between are not adjacent.";
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+            throwTypeCheckerException(fromOp, msg, errCode, PigException.INPUT, null);
         }
 
         // retrieve input schema to be casted
@@ -291,7 +300,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1055;
             String msg = "Problem while reading schema from input of " 
                 + fromOp.getClass().getSimpleName();
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, fe);
+            throwTypeCheckerException(fromOp, msg, errCode, PigException.BUG, fe);
         }
 
         // make sure the supplied targetSchema has the same number of members
@@ -300,7 +309,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1078;
             String msg = "Schema size mismatch for casting. Input schema size: " 
                 + fromSchema.size() + ". Target schema size: " + toSchema.size();
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+            throwTypeCheckerException(toOp, msg, errCode, PigException.INPUT, null);
         }
 
         // Plans inside Generate. Fields that do not need casting will only
@@ -379,7 +388,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
         if (list.size() != 1) {
             int errCode = 2008;
             String msg = "LOSplitOutput cannot have more than one input. Found: " + list.size() + " input(s).";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG) ;
+            throwTypeCheckerException(op, msg, errCode, PigException.BUG, null) ;
         }
 
         LogicalExpressionPlan condPlan = op.getFilterPlan() ;
@@ -389,7 +398,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1057;
             String msg = "Split's inner plan can only have one output (leaf)" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throwTypeCheckerException(op, msg, errCode, PigException.INPUT, null) ;
         }
 
         visitExpressionPlan(condPlan, op);
@@ -399,7 +408,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1058;
             String msg = "Split's condition must evaluate to boolean. Found: " + DataType.findTypeName(innerCondType) ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+            throwTypeCheckerException(op, msg, errCode, PigException.INPUT, null) ;
         }
 
         try {
@@ -411,7 +420,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             String msg = "Problem while reading"
                 + " schemas from inputs of SplitOutput" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(op, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -434,7 +443,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             String msg = "Problem while reading"
                 + " schemas from inputs of Distinct" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(op, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -450,7 +459,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             String msg = "Problem while reading"
                 + " schemas from inputs of Limit" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(op, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -473,7 +482,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             String msg = "Problem while reading"
                 + " schemas from inputs of Cross" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(cs, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -494,7 +503,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                 int errCode = 1057;
                 String msg = "Sort's inner plan can only have one output (leaf)" ;
                 msgCollector.collect(msg, MessageType.Error) ;
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                throwTypeCheckerException(sort, msg, errCode, PigException.INPUT, null) ;
             }
 
             visitExpressionPlan(sortColPlan, sort);
@@ -508,7 +517,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1059;
             String msg = "Problem while reconciling output schema of Sort" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fee) ;
+            throwTypeCheckerException(sort, msg, errCode, PigException.INPUT, fee) ;
         }
     }
 
@@ -523,7 +532,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
         if (inputList.size() != 1) {            
             int errCode = 2008;
             String msg = "LOSplit cannot have more than one input. Found: " + inputList.size() + " input(s).";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG) ;
+            throwTypeCheckerException(split, msg, errCode, PigException.BUG, null) ;
         }
 
         split.resetSchema();
@@ -535,7 +544,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1059;
             String msg = "Problem while reconciling output schema of Split" ;
             msgCollector.collect(msg, MessageType.Error);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(split, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -551,7 +560,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1060;
             String msg = "Cannot resolve Join output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(join, msg, errCode, PigException.INPUT, fe) ;
         }
 
         MultiMap<Integer, LogicalExpressionPlan> joinColPlans
@@ -573,7 +582,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                     String msg = "Join's inner plans can only"
                         + " have one output (leaf)" ;
                     msgCollector.collect(msg, MessageType.Error) ;
-                    throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                    throwTypeCheckerException(join, msg, errCode, PigException.INPUT, null) ;
                 }
                 visitExpressionPlan(innerPlan, join);
             }
@@ -623,7 +632,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                             String msg = "Join's inner plans can only"
                                 + "have one output (leaf)" ;
                             msgCollector.collect(msg, MessageType.Error) ;
-                            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                            throwTypeCheckerException(join, msg, errCode, PigException.INPUT, null) ;
                         }
                         if (innerType != expectedType) {
                             insertAtomicCastForInnerPlan(
@@ -638,7 +647,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1060;
             String msg = "Cannot resolve Join output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(join, msg, errCode, PigException.INPUT, fe) ;
         }
 
         try {
@@ -649,7 +658,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1060;
             String msg = "Cannot resolve Join output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(join, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
@@ -768,14 +777,14 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1051;
             String msg = "Cannot cast to "
                 + DataType.findTypeName(toType);
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT);
+            throwTypeCheckerException(relOp, msg, errCode, PigException.INPUT, null);
         }
 
         List<Operator> outputs = innerPlan.getSources();
         if (outputs.size() > 1) {
             int errCode = 2060;
             String msg = "Expected one output. Found " + outputs.size() + "  outputs.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG);
+            throwTypeCheckerException(relOp, msg, errCode, PigException.BUG, null);
         }
         LogicalExpression currentOutput = (LogicalExpression) outputs.get(0);
         TypeCheckingExpVisitor.collectCastWarning(
@@ -866,7 +875,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1060;
             String msg = "Cannot resolve COGroup output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(cg, msg, errCode, PigException.INPUT, fe) ;
         }
 
         MultiMap<Integer, LogicalExpressionPlan> groupByPlans = 
@@ -889,7 +898,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                     String msg = "COGroup's inner plans can only"
                         + "have one output (leaf)" ;
                     msgCollector.collect(msg, MessageType.Error) ;
-                    throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                    throwTypeCheckerException(cg, msg, errCode, PigException.INPUT, null) ;
                 }
                 visitExpressionPlan(innerPlan, cg);
             }
@@ -935,7 +944,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
                             String msg = "Sorry, group by complex types"
                                 + " will be supported soon" ;
                             msgCollector.collect(msg, MessageType.Error) ;
-                            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
+                            throwTypeCheckerException(cg, msg, errCode, PigException.INPUT, null) ;
                         }
 
                         expectedType = groupBySchema.getField(j).type ;
@@ -953,7 +962,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1060;
             String msg = "Cannot resolve COGroup output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(cg, msg, errCode, PigException.INPUT, fe) ;
         }
 
         try {
@@ -964,7 +973,7 @@ public class TypeCheckingRelVisitor extends LogicalRelationalNodesVisitor {
             int errCode = 1060;
             String msg = "Cannot resolve COGroup output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
+            throwTypeCheckerException(cg, msg, errCode, PigException.INPUT, fe) ;
         }
     }
 
diff --git a/src/org/apache/pig/parser/AstValidator.g b/src/org/apache/pig/parser/AstValidator.g
index bd148c03f..8f953d6f8 100644
--- a/src/org/apache/pig/parser/AstValidator.g
+++ b/src/org/apache/pig/parser/AstValidator.g
@@ -76,21 +76,20 @@ public String getErrorHeader(RecognitionException ex) {
 	return QueryParserUtils.generateErrorHeader( ex );
 }
 
-private void validateSchemaAliasName(Set<String> fieldNames, Token t)
+private void validateSchemaAliasName(Set<String> fieldNames, CommonTree node, String name)
 throws DuplicatedSchemaAliasException {
-    String name = t.getText();
     if( fieldNames.contains( name ) ) {
-        throw new DuplicatedSchemaAliasException( input, t, name );
+        throw new DuplicatedSchemaAliasException( input, 
+            new SourceLocation( (PigParserNode)node ), name );
     } else {
         fieldNames.add( name );
     }
 }
 
-private void validateAliasRef(Set<String> aliases, Token t)
+private void validateAliasRef(Set<String> aliases, CommonTree node, String alias)
 throws UndefinedAliasException {
-    String alias = t.getText();
     if( !aliases.contains( alias ) ) {
-        throw new UndefinedAliasException( input, t, alias );
+        throw new UndefinedAliasException( input, new SourceLocation( (PigParserNode)node ), alias );
     }
 }
 
@@ -120,11 +119,11 @@ general_statement : ^( STATEMENT ( alias { aliases.add( $alias.name ); } )? op_c
 parallel_clause : ^( PARALLEL INTEGER )
 ;
 
-alias returns[String name, Token token]
+alias returns[String name, CommonTree node]
  : IDENTIFIER
    { 
        $name = $IDENTIFIER.text;
-       $token = $IDENTIFIER.token;
+       $node = $IDENTIFIER;
    }
 ;
 
@@ -185,7 +184,7 @@ as_clause: ^( AS field_def_list )
 ;
 
 field_def[Set<String> fieldNames] throws Exception
- : ^( FIELD_DEF IDENTIFIER { validateSchemaAliasName( fieldNames, $IDENTIFIER.token ); } type? )
+ : ^( FIELD_DEF IDENTIFIER { validateSchemaAliasName( fieldNames, $IDENTIFIER, $IDENTIFIER.text ); } type? )
 ;
 
 field_def_list
@@ -243,13 +242,13 @@ group_item
            // For the first input
            $group_clause::arity = $join_group_by_clause.exprCount;
        } else if( $join_group_by_clause.exprCount != $group_clause::arity ) {
-           throw new ParserValidationException( input, new SourceLocation( (CommonTree)$group_item.start ),
+           throw new ParserValidationException( input, new SourceLocation( (PigParserNode)$group_item.start ),
                "The arity of the group by columns do not match." );
        }
    }
 ;
 
-rel : alias {  validateAliasRef( aliases, $alias.token ); }
+rel : alias {  validateAliasRef( aliases, $alias.node, $alias.name ); }
     | op_clause
 ;
 
@@ -386,7 +385,7 @@ join_item
            // For the first input
            $join_clause::arity = $join_group_by_clause.exprCount;
        } else if( $join_group_by_clause.exprCount != $join_clause::arity ) {
-           throw new ParserValidationException( input, new SourceLocation( (CommonTree)$join_item.start ),
+           throw new ParserValidationException( input, new SourceLocation( (PigParserNode)$join_item.start ),
                "The arity of the join columns do not match." );
        }
    }
diff --git a/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java b/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java
index f1c1cb878..1c7be5924 100644
--- a/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java
+++ b/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java
@@ -19,15 +19,14 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.Token;
 
 public class DuplicatedSchemaAliasException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private String alias;
     
-    public DuplicatedSchemaAliasException(IntStream input, Token t, String alias) {
-        super( input, new SourceLocation( t ) );
+    public DuplicatedSchemaAliasException(IntStream input, SourceLocation loc, String alias) {
+        super( input, loc );
         this.alias = alias;
     }
     
diff --git a/src/org/apache/pig/parser/LogicalPlanBuilder.java b/src/org/apache/pig/parser/LogicalPlanBuilder.java
index 24259c4fe..22574c499 100644
--- a/src/org/apache/pig/parser/LogicalPlanBuilder.java
+++ b/src/org/apache/pig/parser/LogicalPlanBuilder.java
@@ -28,10 +28,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
-import org.antlr.grammar.v3.ANTLRv3Parser.range_return;
 import org.antlr.runtime.IntStream;
 import org.antlr.runtime.RecognitionException;
-import org.apache.jute.InputArchive;
 import org.apache.pig.ExecType;
 import org.apache.pig.FuncSpec;
 import org.apache.pig.LoadFunc;
@@ -151,53 +149,56 @@ public class LogicalPlanBuilder {
         return new LOFilter( plan );
     }
 
-    String buildFilterOp(LOFilter op, String alias, String inputAlias, LogicalExpressionPlan expr) {
+    String buildFilterOp(SourceLocation loc, LOFilter op, String alias, String inputAlias, LogicalExpressionPlan expr) {
         op.setFilterPlan( expr );
-        return buildOp( op, alias, inputAlias, null );
+        return buildOp( loc, op, alias, inputAlias, null );
     }
     
-    String buildDistinctOp(String alias, String inputAlias, String partitioner) {
+    String buildDistinctOp(SourceLocation loc, String alias, String inputAlias, String partitioner) {
         LODistinct op = new LODistinct( plan );
-        return buildOp( op, alias, inputAlias, partitioner );
+        return buildOp( loc, op, alias, inputAlias, partitioner );
     }
 
-    String buildLimitOp(String alias, String inputAlias, long limit) {
+    String buildLimitOp(SourceLocation loc, String alias, String inputAlias, long limit) {
         LOLimit op = new LOLimit( plan, limit );
-        return buildOp( op, alias, inputAlias, null );
+        return buildOp( loc, op, alias, inputAlias, null );
     }
     
-    String buildSampleOp(String alias, String inputAlias, double value) {
+    String buildSampleOp(SourceLocation loc, String alias, String inputAlias, double value,
+            SourceLocation valLoc) {
         LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
         //  Generate a filter condition.
         LogicalExpression konst = new ConstantExpression( filterPlan, value);
+        konst.setLocation( valLoc );
         UserFuncExpression udf = new UserFuncExpression( filterPlan, new FuncSpec( RANDOM.class.getName() ) );
         new LessThanEqualExpression( filterPlan, udf, konst );
-        return buildFilterOp( new LOFilter( plan ), alias, inputAlias, filterPlan );
+        LOFilter filter = new LOFilter( plan );
+        return buildFilterOp( loc, filter, alias, inputAlias, filterPlan );
     }
     
-    String buildUnionOp(String alias, List<String> inputAliases, boolean onSchema) {
+    String buildUnionOp(SourceLocation loc, String alias, List<String> inputAliases, boolean onSchema) {
         LOUnion op = new LOUnion( plan, onSchema );
-        return buildOp( op, alias, inputAliases, null );
+        return buildOp( loc, op, alias, inputAliases, null );
     }
 
-    String buildSplitOp(String inputAlias) {
+    String buildSplitOp(SourceLocation loc, String inputAlias) {
         LOSplit op = new LOSplit( plan );
-        return buildOp( op, null, inputAlias, null );
+        return buildOp( loc, op, null, inputAlias, null );
     }
     
     LOSplitOutput createSplitOutputOp() {
         return  new LOSplitOutput( plan );
     }
     
-    String buildSplitOutputOp(LOSplitOutput op, String alias, String inputAlias,
+    String buildSplitOutputOp(SourceLocation loc, LOSplitOutput op, String alias, String inputAlias,
             LogicalExpressionPlan filterPlan) {
         op.setFilterPlan( filterPlan );
-        return buildOp ( op, alias, inputAlias, null );
+        return buildOp ( loc, op, alias, inputAlias, null );
     }
     
-    String buildCrossOp(String alias, List<String> inputAliases, String partitioner) {
+    String buildCrossOp(SourceLocation loc, String alias, List<String> inputAliases, String partitioner) {
         LOCross op = new LOCross( plan );
-        return buildOp ( op, alias, inputAliases, partitioner );
+        return buildOp ( loc, op, alias, inputAliases, partitioner );
     }
     
     LOSort createSortOp() {
@@ -213,7 +214,7 @@ public class LogicalPlanBuilder {
                 ascFlags.add(true);
         }
         sort.setAscendingCols( ascFlags );
-        alias = buildOp( sort, alias, inputAlias, null );
+        alias = buildOp( loc, sort, alias, inputAlias, null );
         try {
             (new ProjectStarExpander(sort.getPlan())).visit(sort);
         } catch (FrontendException e) {
@@ -272,7 +273,7 @@ public class LogicalPlanBuilder {
         op.setJoinType( jt );
         op.setInnerFlags( flags );
         op.setJoinPlans( joinPlans );
-        alias = buildOp( op, alias, inputAliases, partitioner );
+        alias = buildOp( loc, op, alias, inputAliases, partitioner );
         try {
             (new ProjectStarExpander(op.getPlan())).visit(op);
         } catch (FrontendException e) {
@@ -313,7 +314,7 @@ public class LogicalPlanBuilder {
         op.setExpressionPlans( expressionPlans );
         op.setGroupType( gt );
         op.setInnerFlags( flags );
-        alias = buildOp( op, alias, inputAliases, partitioner );
+        alias = buildOp( loc, op, alias, inputAliases, partitioner );
         try {
             (new ProjectStarExpander(op.getPlan())).visit(op);
         } catch (FrontendException e) {
@@ -354,19 +355,22 @@ public class LogicalPlanBuilder {
         
         FileSpec loader = new FileSpec( absolutePath, funcSpec );
         LOLoad op = new LOLoad( loader, schema, plan, ConfigurationUtil.toConfiguration( pigContext.getProperties() ) );
-        return buildOp( op, alias, new ArrayList<String>(), null );
+        return buildOp( loc, op, alias, new ArrayList<String>(), null );
     }
     
-    private String buildOp(LogicalRelationalOperator op, String alias, String inputAlias, String partitioner) {
+    private String buildOp(SourceLocation loc, LogicalRelationalOperator op, String alias, 
+    		String inputAlias, String partitioner) {
         List<String> inputAliases = new ArrayList<String>();
         if( inputAlias != null )
             inputAliases.add( inputAlias );
-        return buildOp( op, alias, inputAliases, partitioner );
+        return buildOp( loc, op, alias, inputAliases, partitioner );
     }
     
-    private String buildOp(LogicalRelationalOperator op, String alias, List<String> inputAliases, String partitioner) {
+    private String buildOp(SourceLocation loc, LogicalRelationalOperator op, String alias, 
+    		List<String> inputAliases, String partitioner) {
         setAlias( op, alias );
         setPartitioner( op, partitioner );
+        op.setLocation( loc );
         plan.add( op );
         for( String a : inputAliases ) {
             Operator pred = operators.get( a );
@@ -410,7 +414,7 @@ public class LogicalPlanBuilder {
         
         FileSpec fileSpec = new FileSpec( absPath, funcSpec );
         LOStore op = new LOStore( plan, fileSpec );
-        return buildOp( op, alias, inputAlias, null );
+        return buildOp( loc, op, alias, inputAlias, null );
     }
     
     LOForEach createForeachOp() {
@@ -420,7 +424,7 @@ public class LogicalPlanBuilder {
     String buildForeachOp(SourceLocation loc, LOForEach op, String alias, String inputAlias, LogicalPlan innerPlan)
     throws ParserValidationException {
         op.setInnerPlan( innerPlan );
-        alias = buildOp( op, alias, inputAlias, null );
+        alias = buildOp( loc, op, alias, inputAlias, null );
         try {
             (new ProjectStarExpander(op.getPlan())).visit(op);
         } catch (FrontendException e) {
@@ -456,6 +460,7 @@ public class LogicalPlanBuilder {
         gen.setFlattenFlags( flags );
         gen.setUserDefinedSchema( schemas );
         innerPlan.add( gen );
+        gen.setLocation( loc );
         for( Operator input : inputs ) {
             innerPlan.connect( input, gen );
         }
@@ -526,7 +531,7 @@ public class LogicalPlanBuilder {
     private static void setupInnerLoadAndProj(LOInnerLoad innerLoad,
             ProjectExpression projExpr, LogicalPlan lp,
             ArrayList<Operator> inputs) {
-        
+        innerLoad.setLocation( projExpr.getLocation() );
         projExpr.setInputNum( inputs.size() );
         projExpr.setColNum( -1 ); // Projection Expression on InnerLoad is always (*).
         lp.add( innerLoad );
@@ -549,10 +554,12 @@ public class LogicalPlanBuilder {
             op = operators.get( colAlias );
             if( op == null ) {
                 op = createInnerLoad(loc, innerPlan, foreach, colAlias );
+                op.setLocation( projExpr.getLocation() );
                 innerPlan.add( op );
             }
         } else {
             op = new LOInnerLoad( innerPlan, foreach, projExpr.getColNum() );
+            op.setLocation( projExpr.getLocation() );
             innerPlan.add( op );
         }
         return op;
@@ -631,7 +638,7 @@ public class LogicalPlanBuilder {
     throws RecognitionException {
         try {
             LOStream op = new LOStream( plan, pigContext.createExecutableManager(), command, schema );
-            return buildOp( op, alias, inputAlias, null );
+            return buildOp( loc, op, alias, inputAlias, null );
         } catch (ExecException ex) {
             throw new PlanGenerationFailureException( input, loc, ex );
         }
@@ -646,7 +653,7 @@ public class LogicalPlanBuilder {
             pigContext.addJar( inputJar );
             for( String path : paths )
                 pigContext.addJar( path );
-            buildOp( op, null, new ArrayList<String>(), null );
+            buildOp( loc, op, null, new ArrayList<String>(), null );
             ((LOStore)operators.get( storeAlias )).setTmpStore(true);
             plan.connect( operators.get( storeAlias ), op );
             LOLoad load = (LOLoad)operators.get( loadAlias );
@@ -734,6 +741,8 @@ public class LogicalPlanBuilder {
     LogicalExpression buildProjectExpr(SourceLocation loc, LogicalExpressionPlan plan, LogicalRelationalOperator op,
             Map<String, LogicalExpressionPlan> exprPlans, String colAlias, int col)
     throws RecognitionException {
+        ProjectExpression result = null;
+        
         if( colAlias != null ) {
             LogicalExpressionPlan exprPlan = exprPlans.get( colAlias );
             if( exprPlan != null ) {
@@ -759,14 +768,14 @@ public class LogicalPlanBuilder {
                 }
                 return (LogicalExpression)planCopy.getSources().get( 0 );// get the root of the plan
             } else {
-                try {
-                    return new ProjectExpression( plan, 0, colAlias, op );
-                } catch (FrontendException e) {
-                    throw new ParserValidationException(intStream, loc, e);
-                }
+                result = new ProjectExpression( plan, 0, colAlias, op );
+                result.setLocation( loc );
+                return result;
             }
         }
-        return new ProjectExpression( plan, 0, col, op );
+        result = new ProjectExpression( plan, 0, col, op );
+        result.setLocation( loc );
+        return result;
     }
 
     /**
@@ -777,14 +786,12 @@ public class LogicalPlanBuilder {
             LogicalExpressionPlan plan, LogicalRelationalOperator relOp,
             int input, String colAlias, int col)
     throws ParserValidationException {
-    
-        if( colAlias != null )
-            try {
-                return new ProjectExpression( plan, input, colAlias, relOp );
-            } catch (FrontendException e) {
-                throw new ParserValidationException(intStream, loc, e);
-            }
-        return new ProjectExpression( plan, input, col, relOp );
+        ProjectExpression result = null;
+        result = colAlias != null ?
+            new ProjectExpression( plan, input, colAlias, relOp ) :
+            new ProjectExpression( plan, input, col, relOp );
+        result.setLocation( loc );
+        return result;
     }
 
     /**
@@ -888,7 +895,9 @@ public class LogicalPlanBuilder {
             funcSpec = new FuncSpec( funcName );
         }
         
-        return new UserFuncExpression( plan, funcSpec, args );
+        LogicalExpression le = new UserFuncExpression( plan, funcSpec, args );
+        le.setLocation( loc );
+        return le;
     }
     
     private long getNextId() {
@@ -900,27 +909,28 @@ public class LogicalPlanBuilder {
     }
     
     // Build operator for foreach inner plan.
-    Operator buildNestedFilterOp(LOFilter op, LogicalPlan plan, String alias, 
+    Operator buildNestedFilterOp(SourceLocation loc, LOFilter op, LogicalPlan plan, String alias, 
             Operator inputOp, LogicalExpressionPlan expr) {
         op.setFilterPlan( expr );
-        buildNestedOp( plan, op, alias, inputOp );
+        buildNestedOp( loc, plan, op, alias, inputOp );
         return op;
     }
 
-    Operator buildNestedDistinctOp(LogicalPlan plan, String alias, Operator inputOp) {
+    Operator buildNestedDistinctOp(SourceLocation loc, LogicalPlan plan, String alias, Operator inputOp) {
         LODistinct op = new LODistinct( plan );
-        buildNestedOp( plan, op, alias, inputOp );
+        buildNestedOp( loc, plan, op, alias, inputOp );
         return op;
     }
 
-    Operator buildNestedLimitOp(LogicalPlan plan, String alias, Operator inputOp, long limit) {
+    Operator buildNestedLimitOp(SourceLocation loc, LogicalPlan plan, String alias, Operator inputOp, long limit) {
         LOLimit op = new LOLimit( plan, limit );
-        buildNestedOp( plan, op, alias, inputOp );
+        buildNestedOp( loc, plan, op, alias, inputOp );
         return op;
     }
     
-    private void buildNestedOp(LogicalPlan plan, LogicalRelationalOperator op,
+    private void buildNestedOp(SourceLocation loc, LogicalPlan plan, LogicalRelationalOperator op,
             String alias, Operator inputOp) {
+        op.setLocation( loc );
         setAlias( op, alias );
         plan.add( op );
         plan.connect( inputOp, op );
@@ -945,7 +955,7 @@ public class LogicalPlanBuilder {
         }
     }
     
-    Operator buildNestedSortOp(LOSort op, LogicalPlan plan, String alias, Operator inputOp,
+    Operator buildNestedSortOp(SourceLocation loc, LOSort op, LogicalPlan plan, String alias, Operator inputOp,
             List<LogicalExpressionPlan> plans, 
             List<Boolean> ascFlags, FuncSpec fs) {
         op.setSortColPlans( plans );
@@ -955,14 +965,11 @@ public class LogicalPlanBuilder {
         }
         op.setAscendingCols( ascFlags );
         op.setUserFunc( fs );
-        buildNestedOp( plan, op, alias, inputOp );
+        buildNestedOp( loc, plan, op, alias, inputOp );
         return op;
     }
     
-    Operator buildNestedProjectOp(
-            SourceLocation loc,
-            LogicalPlan innerPlan,
-            LOForEach foreach, 
+    Operator buildNestedProjectOp(SourceLocation loc, LogicalPlan innerPlan, LOForEach foreach, 
             Map<String, Operator> operators,
             String alias,
             ProjectExpression projExpr,
@@ -979,15 +986,18 @@ public class LogicalPlanBuilder {
             } else {
                 // Assuming that ProjExpr refers to a column by name. Create an LOInnerLoad
                 input = createInnerLoad( loc, innerPlan, foreach, colAlias );
+                input.setLocation( projExpr.getLocation() );
             }
         } else {
             // ProjExpr refers to a column by number.
             input = new LOInnerLoad( innerPlan, foreach, projExpr.getColNum() );
+            input.setLocation( projExpr.getLocation() );
         }
         
         LogicalPlan lp = new LogicalPlan(); // f's inner plan
         LOForEach f = new LOForEach( innerPlan );
         f.setInnerPlan( lp );
+        f.setLocation( loc );
         LOGenerate gen = new LOGenerate( lp );
         boolean[] flatten = new boolean[exprPlans.size()];
         
@@ -997,6 +1007,7 @@ public class LogicalPlanBuilder {
             String al = pe.getColAlias();
             LOInnerLoad iload = ( al == null ) ?  
                     new LOInnerLoad( lp, f, pe.getColNum() ) : createInnerLoad(loc, lp, f, al );
+            iload.setLocation( pe.getLocation() );
             pe.setColNum( -1 );
             pe.setInputNum( innerLoads.size() );
             pe.setAttachedRelationalOp( gen );
diff --git a/src/org/apache/pig/parser/LogicalPlanGenerator.g b/src/org/apache/pig/parser/LogicalPlanGenerator.g
index 84cba0a39..7ae903ee5 100644
--- a/src/org/apache/pig/parser/LogicalPlanGenerator.g
+++ b/src/org/apache/pig/parser/LogicalPlanGenerator.g
@@ -233,7 +233,7 @@ cmd[String alias] returns[StreamingCommand command]
 @init {
     List<String> shipPaths = new ArrayList<String>();
     List<String> cachePaths = new ArrayList<String>();
-    SourceLocation loc = new SourceLocation( (CommonTree)$cmd.start );
+    SourceLocation loc = new SourceLocation( (PigParserNode)$cmd.start );
 }
  : ^( EXECCOMMAND ( ship_clause[shipPaths] | cache_caluse[cachePaths] | input_clause | output_clause | error_clause )* )
    {
@@ -310,7 +310,7 @@ error_clause returns[String dir, Integer limit]
 load_clause returns[String alias]
  : ^( LOAD filename func_clause[FunctionType.LOADFUNC]? as_clause? )
   {
-      SourceLocation loc = new SourceLocation( (CommonTree)$load_clause.start );
+      SourceLocation loc = new SourceLocation( (PigParserNode)$load_clause.start );
       $alias = builder.buildLoadOp( loc, $statement::alias,
           $filename.filename, $func_clause.funcSpec, $as_clause.logicalSchema  );
   }
@@ -419,7 +419,7 @@ map_type returns[LogicalSchema logicalSchema]
 
 func_clause[byte ft] returns[FuncSpec funcSpec]
 @init {
-    SourceLocation loc = new SourceLocation( (CommonTree)$func_clause.start );
+    SourceLocation loc = new SourceLocation( (PigParserNode)$func_clause.start );
 }
  : ^( FUNC_REF func_name )
    {
@@ -468,7 +468,7 @@ scope GScope;
     $group_clause::inputAliases = new ArrayList<String>();
     $group_clause::innerFlags = new ArrayList<Boolean>();
     GROUPTYPE groupType = GROUPTYPE.REGULAR;
-    SourceLocation loc = new SourceLocation( (CommonTree)$group_clause.start );
+    SourceLocation loc = new SourceLocation( (PigParserNode)$group_clause.start );
 }
  : ^( GROUP group_item+ ( group_type { groupType = $group_type.type; ((LOCogroup)$GScope::currentOp).pinOption(LOCogroup.OPTION_GROUPTYPE); } )? partition_clause? )
    {
@@ -487,7 +487,7 @@ scope GScope;
 group_type returns[GROUPTYPE type]
  : QUOTEDSTRING
    {
-       $type =builder.parseGroupType( $QUOTEDSTRING.text, new SourceLocation( $QUOTEDSTRING.token ) );
+       $type =builder.parseGroupType( $QUOTEDSTRING.text, new SourceLocation( (PigParserNode)$QUOTEDSTRING ) );
    } 
 ;
 
@@ -500,7 +500,8 @@ group_item
          | ALL 
          {
              LogicalExpressionPlan plan = new LogicalExpressionPlan();
-             new ConstantExpression( plan, "all");
+             ConstantExpression ce = new ConstantExpression( plan, "all");
+             ce.setLocation( new SourceLocation( (PigParserNode)$ALL ) );
              List<LogicalExpressionPlan> plans = new ArrayList<LogicalExpressionPlan>( 1 );
              plans.add( plan );
              $group_clause::groupPlans.put( $group_clause::inputIndex, plans );
@@ -508,7 +509,8 @@ group_item
          | ANY
          {
              LogicalExpressionPlan plan = new LogicalExpressionPlan();
-             new UserFuncExpression( plan, new FuncSpec( GFAny.class.getName() ) );
+             UserFuncExpression udf = new UserFuncExpression( plan, new FuncSpec( GFAny.class.getName() ) );
+             udf.setLocation( new SourceLocation( (PigParserNode)$ANY ) );
              List<LogicalExpressionPlan> plans = new ArrayList<LogicalExpressionPlan>( 1 );
              plans.add( plan );
              $group_clause::groupPlans.put( $group_clause::inputIndex, plans );
@@ -553,8 +555,8 @@ flatten_generated_item returns[LogicalExpressionPlan plan, boolean flattenFlag,
    | expr[$plan]
    | STAR
      {
-         SourceLocation loc = new SourceLocation( $STAR.token );
-         builder.buildProjectExpr(loc, $plan, $GScope::currentOp, $statement::inputIndex, null, -1 );
+         builder.buildProjectExpr( new SourceLocation( (PigParserNode)$STAR ), $plan, $GScope::currentOp,
+             $statement::inputIndex, null, -1 );
      }
    )
    ( field_def_list { $schema = $field_def_list.schema; } )?
@@ -567,7 +569,7 @@ flatten_clause[LogicalExpressionPlan plan]
 store_clause returns[String alias]
  : ^( STORE rel filename func_clause[FunctionType.STOREFUNC]? )
    {
-       SourceLocation loc = new SourceLocation( $STORE.token );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$STORE );
        $alias= builder.buildStoreOp( loc, $statement::alias,
           $statement::inputAlias, $filename.filename, $func_clause.funcSpec );
    }
@@ -581,8 +583,9 @@ scope GScope;
 }
  : ^( FILTER rel cond[exprPlan] )
    {
-       $alias = builder.buildFilterOp( (LOFilter)$GScope::currentOp, $statement::alias,
-          $statement::inputAlias, exprPlan );
+       $alias = builder.buildFilterOp( new SourceLocation( (PigParserNode)$FILTER ),
+           (LOFilter)$GScope::currentOp, $statement::alias,
+           $statement::inputAlias, exprPlan );
    }
 ;
 
@@ -590,48 +593,61 @@ cond[LogicalExpressionPlan exprPlan] returns[LogicalExpression expr]
  : ^( OR left = cond[exprPlan] right = cond[exprPlan] )
    {
        $expr = new OrExpression( $exprPlan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$OR ) );
    }
  | ^( AND left = cond[exprPlan] right = cond[exprPlan] )
    {
        $expr = new AndExpression( $exprPlan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$AND ) );
    }
  | ^( NOT c = cond[exprPlan] )
    {
        $expr = new NotExpression( $exprPlan, $c.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$NOT ) );
    }
  | ^( NULL expr[$exprPlan] NOT? )
    {
        $expr = new IsNullExpression( $exprPlan, $expr.expr );
-       if( $NOT != null )
+       $expr.setLocation( new SourceLocation( (PigParserNode)$NULL ) );
+       if( $NOT != null ) {
            $expr = new NotExpression( $exprPlan, $expr );
+           $expr.setLocation( new SourceLocation( (PigParserNode)$NOT ) );
+       }
    }
  | ^( rel_op_eq e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new EqualExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$rel_op_eq.start ) );
    } 
  | ^( rel_op_ne e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new NotEqualExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$rel_op_ne.start ) );
    } 
  | ^( rel_op_lt e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new LessThanExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$rel_op_lt.start ) );
    } 
  | ^( rel_op_lte e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new LessThanEqualExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$rel_op_lte.start ) );
    }
  | ^( rel_op_gt e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new GreaterThanExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$rel_op_gt.start ) );
    } 
  | ^( rel_op_gte e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new GreaterThanEqualExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$rel_op_gte.start ) );
    }
  | ^( STR_OP_MATCHES e1 = expr[$exprPlan] e2 = expr[$exprPlan] )
    {
        $expr = new RegexExpression( $exprPlan, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$STR_OP_MATCHES ) );
    }
  | func_eval[$exprPlan]
    {
@@ -645,7 +661,7 @@ func_eval[LogicalExpressionPlan plan] returns[LogicalExpression expr]
 }
  : ^( FUNC_EVAL func_name ( real_arg[$plan] { args.add( $real_arg.expr ); } )* )
    {
-       SourceLocation loc = new SourceLocation( (CommonTree)$func_eval.start );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$func_name.start );
        $expr = builder.buildUDF( loc, $plan, $func_name.funcName, args );
    }
 ;
@@ -654,8 +670,8 @@ real_arg [LogicalExpressionPlan plan] returns[LogicalExpression expr]
  : e = expr[$plan] { $expr = $e.expr; }
  | STAR
    {
-       SourceLocation loc = new SourceLocation( $STAR.token );
-       $expr = builder.buildProjectExpr(loc, $plan, $GScope::currentOp, $statement::inputIndex, null, -1 );
+       $expr = builder.buildProjectExpr( new SourceLocation( (PigParserNode)$STAR ), $plan, $GScope::currentOp, 
+           $statement::inputIndex, null, -1 );
    }
 ;
 
@@ -663,22 +679,27 @@ expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  : ^( PLUS left = expr[$plan] right = expr[$plan] )
    {
        $expr = new AddExpression( $plan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$PLUS ) );
    }
  | ^( MINUS left = expr[$plan] right = expr[$plan] )
    {
        $expr = new SubtractExpression( $plan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$MINUS ) );
    }
  | ^( STAR left = expr[$plan] right = expr[$plan] )
    {
        $expr = new MultiplyExpression( $plan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$STAR ) );
    }
  | ^( DIV left = expr[$plan] right = expr[$plan] )
    {
        $expr = new DivideExpression( $plan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$DIV ) );
    }
  | ^( PERCENT left = expr[$plan] right = expr[$plan] )
    {
        $expr = new ModExpression( $plan, $left.expr, $right.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$PERCENT ) );
    }
  | const_expr[$plan]
    {
@@ -691,10 +712,12 @@ expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  | ^( NEG e = expr[$plan] )
    {
        $expr = new NegativeExpression( $plan, $e.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$e.start ) );
    }
  | ^( CAST_EXPR type_cast e = expr[$plan] ) // cast expr
    {
        $expr = new CastExpression( $plan, $e.expr, $type_cast.fieldSchema );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$type_cast.start ) );
    }
  | ^( EXPR_IN_PAREN e = expr[$plan] ) // unary expr
    {
@@ -741,7 +764,7 @@ bag_type_cast returns[LogicalSchema logicalSchema]
 var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
 @init {
     List<Object> columns = null;
-    SourceLocation loc = new SourceLocation( (CommonTree)$var_expr.start );
+    SourceLocation loc = new SourceLocation( (PigParserNode)$var_expr.start );
 }
  : projectable_expr[$plan] { $expr = $projectable_expr.expr; }
    ( dot_proj 
@@ -782,6 +805,7 @@ var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
          } else {
              DereferenceExpression e = new DereferenceExpression( $plan );
              e.setRawColumns( $dot_proj.cols );
+             e.setLocation( new SourceLocation( (PigParserNode)$dot_proj.start ) );
              $plan.connect( e, $expr );
              $expr = e;
          }
@@ -789,6 +813,7 @@ var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
    | pound_proj
      {
          MapLookupExpression e = new MapLookupExpression( $plan, $pound_proj.key );
+         e.setLocation( new SourceLocation( (PigParserNode)$pound_proj.start ) );
          $plan.connect( e, $expr );
          $expr = e;
      }
@@ -852,7 +877,7 @@ col_index returns[Integer col]
 col_range[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  :  ^(COL_RANGE (startExpr = col_ref[$plan])? DOUBLE_PERIOD (endExpr = col_ref[$plan])? )
     {
-        SourceLocation loc = new SourceLocation(  (CommonTree)$col_range.start );
+        SourceLocation loc = new SourceLocation( (PigParserNode)$col_range.start );
         $expr = builder.buildRangeProjectExpr(
                     loc, plan, $GScope::currentOp,
                     $statement::inputIndex, 
@@ -870,18 +895,19 @@ bin_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  : ^( BIN_EXPR cond[$plan] e1 = expr[$plan] e2 = expr[$plan] )
    {
        $expr = new BinCondExpression( $plan, $cond.expr, $e1.expr, $e2.expr );
+       $expr.setLocation( new SourceLocation( (PigParserNode)$bin_expr.start ) );
    }
 ;
 
 limit_clause returns[String alias]
  : ^( LIMIT rel INTEGER  )
    {
-       $alias = builder.buildLimitOp( $statement::alias,
+       $alias = builder.buildLimitOp( new SourceLocation( (PigParserNode)$LIMIT ), $statement::alias,
            $statement::inputAlias, Long.valueOf( $INTEGER.text ) );
    }
  | ^( LIMIT rel LONGINTEGER )
    {
-       $alias = builder.buildLimitOp( $statement::alias,
+       $alias = builder.buildLimitOp( new SourceLocation( (PigParserNode)$LIMIT ), $statement::alias,
            $statement::inputAlias, builder.parseLong( $LONGINTEGER.text ) );
    }
 ;
@@ -889,8 +915,9 @@ limit_clause returns[String alias]
 sample_clause returns[String alias]
  : ^( SAMPLE rel DOUBLENUMBER )
    {
-       $alias = builder.buildSampleOp( $statement::alias,
-           $statement::inputAlias, Double.valueOf( $DOUBLENUMBER.text ) );
+       $alias = builder.buildSampleOp( new SourceLocation( (PigParserNode)$SAMPLE ), $statement::alias,
+           $statement::inputAlias, Double.valueOf( $DOUBLENUMBER.text ),
+           new SourceLocation( (PigParserNode)$DOUBLENUMBER ) );
    }
 ;
 
@@ -901,7 +928,7 @@ scope GScope;
 }
  : ^( ORDER rel order_by_clause func_clause[FunctionType.COMPARISONFUNC]? )
    {
-       SourceLocation loc = new SourceLocation( $ORDER.token );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$ORDER );
        $alias = builder.buildSortOp( loc, (LOSort)$GScope::currentOp, $statement::alias,
            $statement::inputAlias, $order_by_clause.plans, 
            $order_by_clause.ascFlags, $func_clause.funcSpec );
@@ -915,8 +942,8 @@ order_by_clause returns[List<LogicalExpressionPlan> plans, List<Boolean> ascFlag
 }
  : STAR {
        LogicalExpressionPlan plan = new LogicalExpressionPlan();
-       SourceLocation loc = new SourceLocation( $STAR.token );
-       builder.buildProjectExpr(loc, plan, $GScope::currentOp, $statement::inputIndex, null, -1 );
+       builder.buildProjectExpr( new SourceLocation( (PigParserNode)$STAR ), plan, $GScope::currentOp,
+           $statement::inputIndex, null, -1 );
        $plans.add( plan );
    }
    ( ASC { $ascFlags.add( true ); } | DESC { $ascFlags.add( false ); } )?
@@ -939,7 +966,7 @@ order_col returns[LogicalExpressionPlan plan, Boolean ascFlag]
 distinct_clause returns[String alias]
  : ^( DISTINCT rel partition_clause? )
    {
-       $alias = builder.buildDistinctOp( $statement::alias,
+       $alias = builder.buildDistinctOp( new SourceLocation( (PigParserNode)$DISTINCT ), $statement::alias,
           $statement::inputAlias, $partition_clause.partitioner );
    }
 ;
@@ -954,7 +981,7 @@ partition_clause returns[String partitioner]
 cross_clause returns[String alias]
  : ^( CROSS rel_list partition_clause? )
    {
-       $alias = builder.buildCrossOp( $statement::alias,
+       $alias = builder.buildCrossOp( new SourceLocation( (PigParserNode)$CROSS ), $statement::alias,
           $rel_list.aliasList, $partition_clause.partitioner );
    }
 ;
@@ -980,7 +1007,7 @@ scope GScope;
 }
  : ^( JOIN join_sub_clause join_type? partition_clause? )
    {
-       SourceLocation loc = new SourceLocation( $JOIN.token );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$JOIN );
        $alias = builder.buildJoinOp( loc, (LOJoin)$GScope::currentOp, $statement::alias,
           $join_clause::inputAliases, $join_clause::joinPlans,
           $join_type.type, $join_clause::innerFlags, $partition_clause.partitioner );
@@ -990,7 +1017,7 @@ scope GScope;
 join_type returns[JOINTYPE type]
  : QUOTEDSTRING
    {
-       $type = builder.parseJoinType( $QUOTEDSTRING.text, new SourceLocation( $QUOTEDSTRING.token ) );
+       $type = builder.parseJoinType( $QUOTEDSTRING.text, new SourceLocation( (PigParserNode)$QUOTEDSTRING ) );
    }
 ;
 
@@ -1031,8 +1058,8 @@ join_group_by_expr returns[LogicalExpressionPlan plan]
  | expr[$plan]
  | STAR 
    {
-       SourceLocation loc = new SourceLocation( $STAR.token );
-       builder.buildProjectExpr(loc, $plan, $GScope::currentOp, $statement::inputIndex, null, -1 );
+       builder.buildProjectExpr( new SourceLocation( (PigParserNode)$STAR ), $plan, $GScope::currentOp, 
+           $statement::inputIndex, null, -1 );
    }
 ;
 
@@ -1042,7 +1069,8 @@ union_clause returns[String alias]
 }
  : ^( UNION ( ONSCHEMA { onSchema = true; } )? rel_list )
    {
-      $alias = builder.buildUnionOp( $statement::alias, $rel_list.aliasList, onSchema );
+      $alias = builder.buildUnionOp( new SourceLocation( (PigParserNode)$UNION ), $statement::alias, 
+          $rel_list.aliasList, onSchema );
    }
 ;
 
@@ -1057,7 +1085,7 @@ scope GScope;
 }
  : ^( FOREACH rel foreach_plan )
    {
-       SourceLocation loc = new SourceLocation( $FOREACH.token );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$FOREACH );
        $alias = builder.buildForeachOp( loc, $foreach_clause::foreachOp, $statement::alias,
           $statement::inputAlias, $foreach_plan.plan );
    }
@@ -1102,9 +1130,9 @@ scope GScope;
                  }
                )+
     )
-   {   SourceLocation loc = new SourceLocation( $GENERATE.token );
-       builder.buildGenerateOp(loc, $foreach_clause::foreachOp, (LOGenerate)$GScope::currentOp,
-           $foreach_plan::operators,
+   {   
+       builder.buildGenerateOp( new SourceLocation( (PigParserNode)$GENERATE ), $foreach_clause::foreachOp, 
+           (LOGenerate)$GScope::currentOp, $foreach_plan::operators,
            plans, flattenFlags, schemas );
    }
 ;
@@ -1145,8 +1173,8 @@ nested_proj[String alias] returns[Operator op]
         }
       )+ )
    {
-       SourceLocation loc = new SourceLocation(  (CommonTree)$nested_proj.start);
-       $op = builder.buildNestedProjectOp(loc, $foreach_plan::innerPlan, $foreach_clause::foreachOp, 
+       SourceLocation loc = new SourceLocation( (PigParserNode)$cr0.start );
+       $op = builder.buildNestedProjectOp( loc, $foreach_plan::innerPlan, $foreach_clause::foreachOp, 
            $foreach_plan::operators, $alias, (ProjectExpression)$cr0.expr, plans );
    }
 ;
@@ -1160,7 +1188,8 @@ scope GScope;
 }
  : ^( FILTER nested_op_input cond[plan] )
    {
-       $op = builder.buildNestedFilterOp( (LOFilter)$GScope::currentOp, $foreach_plan::innerPlan, $alias, 
+       SourceLocation loc = new SourceLocation( (PigParserNode)$FILTER );
+       $op = builder.buildNestedFilterOp( loc, (LOFilter)$GScope::currentOp, $foreach_plan::innerPlan, $alias, 
            $nested_op_input.op, plan );
    }
 ;
@@ -1173,7 +1202,8 @@ scope GScope;
 }
  : ^( ORDER nested_op_input order_by_clause func_clause[FunctionType.COMPARISONFUNC]? )
    {
-       $op = builder.buildNestedSortOp( (LOSort)$GScope::currentOp, $foreach_plan::innerPlan, $alias,
+       SourceLocation loc = new SourceLocation( (PigParserNode)$ORDER );
+       $op = builder.buildNestedSortOp( loc, (LOSort)$GScope::currentOp, $foreach_plan::innerPlan, $alias,
            $nested_op_input.op, 
            $order_by_clause.plans, $order_by_clause.ascFlags, $func_clause.funcSpec );
    }
@@ -1185,7 +1215,8 @@ nested_distinct[String alias] returns[Operator op]
 }
  : ^( DISTINCT nested_op_input )
    {
-       $op = builder.buildNestedDistinctOp( $foreach_plan::innerPlan, $alias, $nested_op_input.op );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$DISTINCT );
+       $op = builder.buildNestedDistinctOp( loc, $foreach_plan::innerPlan, $alias, $nested_op_input.op );
    }
 ;
 
@@ -1195,7 +1226,8 @@ nested_limit[String alias] returns[Operator op]
 }
  : ^( LIMIT nested_op_input INTEGER )
    {
-       $op = builder.buildNestedLimitOp( $foreach_plan::innerPlan, $alias, $nested_op_input.op, 
+       SourceLocation loc = new SourceLocation( (PigParserNode)$LIMIT );
+       $op = builder.buildNestedLimitOp( loc, $foreach_plan::innerPlan, $alias, $nested_op_input.op, 
            Integer.valueOf( $INTEGER.text ) );
    }
 ;
@@ -1206,7 +1238,7 @@ nested_op_input returns[Operator op]
 }
  : col_ref[plan]
    {
-       SourceLocation loc = new SourceLocation( (CommonTree)$col_ref.start );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$col_ref.start );
        $op = builder.buildNestedOperatorInput( loc, $foreach_plan::innerPlan,
            $foreach_clause::foreachOp, $foreach_plan::operators, $col_ref.expr );
    }
@@ -1219,7 +1251,7 @@ nested_op_input returns[Operator op]
 stream_clause returns[String alias]
 @init {
     StreamingCommand cmd = null;
-    SourceLocation loc = new SourceLocation( (CommonTree)$stream_clause.start );
+    SourceLocation loc = new SourceLocation( (PigParserNode)$stream_clause.start );
 }
  : ^( STREAM rel ( EXECCOMMAND { cmd = builder.buildCommand( loc, builder.unquote( $EXECCOMMAND.text ) ); } 
                  | IDENTIFIER 
@@ -1228,7 +1260,7 @@ stream_clause returns[String alias]
                        if( cmd == null ) {
                            String msg = "Undefined command-alias [" + $IDENTIFIER.text + "]";
                            throw new ParserValidationException( input, 
-                               new SourceLocation( $IDENTIFIER.token ), msg );
+                               new SourceLocation( (PigParserNode)$IDENTIFIER ), msg );
                        }
                    }
                  ) as_clause? )
@@ -1242,7 +1274,7 @@ mr_clause returns[String alias]
 @init {
     List<String> paths = new ArrayList<String>();
     String alias = $statement::alias;
-    SourceLocation loc = new SourceLocation( (CommonTree)$mr_clause.start );
+    SourceLocation loc = new SourceLocation( (PigParserNode)$mr_clause.start );
 }
  : ^( MAPREDUCE QUOTEDSTRING path_list[paths]? 
      { $statement::alias = null; } store_clause 
@@ -1256,8 +1288,14 @@ mr_clause returns[String alias]
 ;
 
 split_clause
- : ^( SPLIT rel { $statement::inputAlias = builder.buildSplitOp( $statement::inputAlias ); } 
-      split_branch+ )
+ : ^( SPLIT
+      rel 
+      { 
+          SourceLocation loc = new SourceLocation( (PigParserNode)$SPLIT );
+          $statement::inputAlias = builder.buildSplitOp( loc, $statement::inputAlias );
+      } 
+      split_branch+
+    )
 ;
 
 split_branch
@@ -1268,7 +1306,8 @@ scope GScope;
 }
  : ^( SPLIT_BRANCH alias cond[splitPlan] )
    {
-       builder.buildSplitOutputOp( (LOSplitOutput)$GScope::currentOp, $alias.name,
+       SourceLocation loc = new SourceLocation( (PigParserNode)$alias.start );
+       builder.buildSplitOutputOp( loc, (LOSplitOutput)$GScope::currentOp, $alias.name,
            $statement::inputAlias, splitPlan );
    }
 ;
@@ -1281,13 +1320,12 @@ col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
 alias_col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  : GROUP 
    {
-       SourceLocation loc = new SourceLocation( $GROUP.token );
-       $expr = builder.buildProjectExpr(loc, $plan, $GScope::currentOp, 
+       $expr = builder.buildProjectExpr( new SourceLocation( (PigParserNode)$GROUP ), $plan, $GScope::currentOp, 
            $statement::inputIndex, $GROUP.text, 0 );
    }
  | scoped_alias_col_ref
    {
-       SourceLocation loc = new SourceLocation( (CommonTree)$scoped_alias_col_ref.start );
+       SourceLocation loc = new SourceLocation( (PigParserNode)$scoped_alias_col_ref.start );
        String alias = $scoped_alias_col_ref.alias;
        Operator inOp = builder.lookupOperator( $statement::inputAlias );
        LogicalSchema schema;
@@ -1301,6 +1339,7 @@ alias_col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
        if( op != null && ( schema == null || schema.getFieldPosition( alias ) == -1 ) ) {
            $expr = new ScalarExpression( plan, op,
                inForeachPlan ? $foreach_clause::foreachOp : $GScope::currentOp );
+           $expr.setLocation( loc );
        } else {
            if( inForeachPlan ) {
                $expr = builder.buildProjectExpr( loc, $plan, $GScope::currentOp, 
@@ -1330,8 +1369,7 @@ dollar_col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  : DOLLARVAR
    {
        int col = builder.undollar( $DOLLARVAR.text );
-       SourceLocation loc = new SourceLocation( $DOLLARVAR.token );
-       $expr = builder.buildProjectExpr(loc, $plan, $GScope::currentOp, 
+       $expr = builder.buildProjectExpr( new SourceLocation( (PigParserNode)$DOLLARVAR ), $plan, $GScope::currentOp, 
            $statement::inputIndex, null, col );
    }
 ;
@@ -1340,6 +1378,7 @@ const_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
  : literal
    {
        $expr = new ConstantExpression( $plan, $literal.value);
+       $expr.setLocation( new SourceLocation( (PigParserNode)$const_expr.start ) );
    }
 ;
 
diff --git a/src/org/apache/pig/parser/PigRecognitionException.java b/src/org/apache/pig/parser/PigRecognitionException.java
index 36b05e7f7..c6614e655 100644
--- a/src/org/apache/pig/parser/PigRecognitionException.java
+++ b/src/org/apache/pig/parser/PigRecognitionException.java
@@ -31,19 +31,17 @@ import org.antlr.runtime.RecognitionException;
 public abstract class PigRecognitionException extends RecognitionException {
     private static final long serialVersionUID = 1L;
     
+    private SourceLocation location;
+    
     public PigRecognitionException(IntStream input, SourceLocation loc) {
         super( input );
         this.line = loc.line();
         this.charPositionInLine = loc.offset();
+        this.location = loc;
     }
     
     protected String msgHeader() {
-        StringBuilder sb = new StringBuilder();
-        sb.append( "<line " + line );
-        if( charPositionInLine >= 0 )
-            sb.append( ", column " + charPositionInLine );
-        sb.append( "> " );
-        return sb.toString();
+        return location.toString();
     }
 
 }
diff --git a/src/org/apache/pig/parser/SourceLocation.java b/src/org/apache/pig/parser/SourceLocation.java
index 64486580d..364f0feac 100644
--- a/src/org/apache/pig/parser/SourceLocation.java
+++ b/src/org/apache/pig/parser/SourceLocation.java
@@ -18,32 +18,30 @@
 
 package org.apache.pig.parser;
 
-import org.antlr.runtime.Token;
-import org.antlr.runtime.tree.CommonTree;
-
 public class SourceLocation {
+    private String file = null; // Name of the source, null if unknown.
     private int line = -1; // line number, -1 if unknown.
     private int offset = -1; // offset, -f if unknown.
     
-    public SourceLocation(int line, int offset) {
-        this.line = line;
-        this.offset = offset;
+    public SourceLocation() {
     }
     
-    public SourceLocation(int line) {
-        this.line = line;
+    public SourceLocation(PigParserNode tree) {
+        this.file = tree.getFileName();
+        this.line = tree.getLine();
+        this.offset = tree.getCharPositionInLine();
     }
     
-    public SourceLocation(Token token) {
-        this.line = token.getLine();
-        this.offset = token.getCharPositionInLine();
+    public SourceLocation(SourceLocation location) {
+        this.file = location.file;
+        this.line = location.line;
+        this.offset = location.offset;
     }
     
-    public SourceLocation(CommonTree tree) {
-        this.line = tree.getLine();
-        this.offset = tree.getCharPositionInLine();
+    public String file() {
+        return file;
     }
-    
+
     public int line() {
         return line;
     }
@@ -52,4 +50,17 @@ public class SourceLocation {
         return offset;
     }
     
+    @Override
+    public String toString() {
+        if( line == -1 )
+            return "";
+        
+        StringBuilder sb = new StringBuilder( "<" );
+        if( file != null )
+            sb.append( "file " + file + ", " );
+        sb.append( "line " + line +", column " + offset + "> " );
+        
+        return sb.toString();
+    }
+    
 }
diff --git a/src/org/apache/pig/parser/UndefinedAliasException.java b/src/org/apache/pig/parser/UndefinedAliasException.java
index f8e860470..5044c3efb 100644
--- a/src/org/apache/pig/parser/UndefinedAliasException.java
+++ b/src/org/apache/pig/parser/UndefinedAliasException.java
@@ -19,15 +19,14 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.Token;
 
 public class UndefinedAliasException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private String alias;
     
-    public UndefinedAliasException(IntStream input, Token t, String alias) {
-        super( input, new SourceLocation( t ) );
+    public UndefinedAliasException(IntStream input, SourceLocation loc, String alias) {
+        super( input, loc );
         this.alias = alias;
     }
     
diff --git a/test/org/apache/pig/parser/TestLogicalPlanGenerator.java b/test/org/apache/pig/parser/TestLogicalPlanGenerator.java
index 78fb56111..dce4f4af2 100644
--- a/test/org/apache/pig/parser/TestLogicalPlanGenerator.java
+++ b/test/org/apache/pig/parser/TestLogicalPlanGenerator.java
@@ -24,7 +24,6 @@ import java.io.IOException;
 
 import junit.framework.Assert;
 
-import org.antlr.runtime.RecognitionException;
 import org.apache.pig.test.Util;
 import org.junit.BeforeClass;
 import org.junit.Test;
