diff --git a/CHANGES.txt b/CHANGES.txt
index 8977fe323..0b5015748 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -285,6 +285,8 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-2917: SpillableMemoryManager memory leak for WeakReference (haitao.yao via dvryaboy)
+
 PIG-2938: All unit tests that use MR2 MiniCluster are broken in trunk (cheolsoo via dvryaboy)
 
 PIG-2936: Tuple serialization bug (jcoveney)
diff --git a/src/org/apache/pig/impl/util/SpillableMemoryManager.java b/src/org/apache/pig/impl/util/SpillableMemoryManager.java
index 1381cbd73..403d7749b 100644
--- a/src/org/apache/pig/impl/util/SpillableMemoryManager.java
+++ b/src/org/apache/pig/impl/util/SpillableMemoryManager.java
@@ -181,22 +181,13 @@ public class SpillableMemoryManager implements NotificationListener {
             }
 
         }
-         
+        clearSpillables();
         if (toFree < 0) {
             log.debug("low memory handler returning " + 
                 "because there is nothing to free");
             return;
         }
         synchronized(spillables) {
-            // Walk the list first and remove nulls, otherwise the sort
-            // takes way too long.
-            Iterator<WeakReference<Spillable>> i;
-            for (i = spillables.iterator(); i.hasNext();) {
-                Spillable s = i.next().get();
-                if (s == null) {
-                    i.remove();
-                }
-            }
             Collections.sort(spillables, new Comparator<WeakReference<Spillable>>() {
 
                 /**
@@ -233,7 +224,7 @@ public class SpillableMemoryManager implements NotificationListener {
             long estimatedFreed = 0;
             int numObjSpilled = 0;
             boolean invokeGC = false;
-            for (i = spillables.iterator(); i.hasNext();) {
+            for (Iterator<WeakReference<Spillable>> i = spillables.iterator(); i.hasNext();) {
                 Spillable s = i.next().get();
                 // Still need to check for null here, even after we removed
                 // above, because the reference may have gone bad on us
@@ -280,6 +271,19 @@ public class SpillableMemoryManager implements NotificationListener {
         }
     }
     
+    public void clearSpillables() {
+        synchronized (spillables) {
+            // Walk the list first and remove nulls, otherwise the sort
+            // takes way too long.
+            for (Iterator<WeakReference<Spillable>> i = spillables.iterator(); i
+                    .hasNext();) {
+                Spillable s = i.next().get();
+                if (s == null) {
+                    i.remove();
+                }
+            }
+        }
+    }
     /**
      * Register a spillable to be tracked. No need to unregister, the tracking will stop
      * when the spillable is GCed.
