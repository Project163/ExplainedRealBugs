diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index 18dfc19ad..4b73dabec 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -30,6 +30,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -280,4 +281,14 @@ public class LOCogroup extends LogicalOperator {
         mGroupByPlans.put(newOp, innerPlans);
     }
 
+    public void resetSchema() throws VisitorException{
+        for(LogicalOperator input: getInputs()) {
+            for(LogicalPlan plan: mGroupByPlans.get(input)) {
+                SchemaRemover sr = new SchemaRemover(plan);
+                sr.visit();
+            }
+        }
+        unsetSchema();
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 03cf65ab3..f5dfff47f 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -25,6 +25,7 @@ import java.util.Set;
 import java.util.Iterator;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
@@ -247,4 +248,13 @@ public class LOForEach extends LogicalOperator {
         log.debug("Exiting getSchema");
         return mSchema;
     }
+
+    public void resetSchema() throws VisitorException{
+        for(LogicalPlan plan: mForEachPlans) {
+            SchemaRemover sr = new SchemaRemover(plan);
+            sr.visit();
+        }
+        unsetSchema();
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 1be0705a5..5d0743040 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -1370,9 +1370,10 @@ public class TypeCheckingVisitor extends LOVisitor {
             } else {
                 func.setFuncSpec(matchingSpec);
                 ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(matchingSpec);
-                func.setType(DataType.findType(ef.getReturnType()));
+                setUdfSchema(func, ef, s);
             }
-            
+        } else {
+            setUdfSchema(func, ef, s);
         }
         /*
         while (iterator.hasNext()) {
@@ -1381,6 +1382,26 @@ public class TypeCheckingVisitor extends LOVisitor {
         */
     }
 
+    private void setUdfSchema(LOUserFunc func, EvalFunc ef, Schema inputSchema) throws VisitorException {
+        Schema udfSchema = ef.outputSchema(inputSchema);
+        if (null != udfSchema) {
+            Schema.FieldSchema fs;
+            try {
+                fs = udfSchema.getField(0);
+            } catch (ParseException pe) {
+                throw new VisitorException(pe.getMessage());
+            }
+            func.setType(fs.type);
+            try {
+                func.setFieldSchema(fs);
+            } catch (FrontendException fe) {
+                throw new VisitorException(fe.getMessage());
+            }
+        } else {
+            func.setType(DataType.findType(ef.getReturnType()));
+        }
+    }
+
     /**
      * For Bincond, lhsOp and rhsOp must have the same output type
      * or both sides have to be number
@@ -1570,6 +1591,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     @Override
     protected void visit(LOUnion u) throws VisitorException {
+        u.unsetSchema();
         // Have to make a copy, because as we insert operators, this list will
         // change under us.
         List<LogicalOperator> inputs = 
@@ -1690,6 +1712,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     
     @Override
     protected void visit(LODistinct op) throws VisitorException {
+        op.unsetSchema();
         LogicalPlan currentPlan = mCurrentWalker.getPlan() ;
         List<LogicalOperator> list = currentPlan.getPredecessors(op) ;
 
@@ -1716,6 +1739,7 @@ public class TypeCheckingVisitor extends LOVisitor {
      * @throws VisitorException
      */
     protected void visit(LOCross cs) throws VisitorException {
+        cs.unsetSchema();
         List<LogicalOperator> inputs = cs.getInputs() ;
         List<FieldSchema> fsList = new ArrayList<FieldSchema>() ;
 
@@ -1753,6 +1777,7 @@ public class TypeCheckingVisitor extends LOVisitor {
      */
 
     protected void visit(LOSort s) throws VisitorException {
+        s.unsetSchema();
         LogicalOperator input = s.getInput() ;
         
         // Type checking internal plans.
@@ -1794,6 +1819,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     @Override
     protected void visit(LOFilter filter) throws VisitorException {
+        filter.unsetSchema();
         LogicalOperator input = filter.getInput() ;
         LogicalPlan comparisonPlan = filter.getComparisonPlan() ;
         
@@ -1860,6 +1886,16 @@ public class TypeCheckingVisitor extends LOVisitor {
      * same type
      */
     protected void visit(LOCogroup cg) throws VisitorException {
+        cg.resetSchema();
+        try {
+            cg.getSchema();
+        } catch (FrontendException fe) {
+            String msg = "Cannot resolve COGroup output schema" ;
+            msgCollector.collect(msg, MessageType.Error) ;
+            VisitorException vse = new VisitorException(msg) ;
+            vse.initCause(fe) ;
+            throw vse ;
+        }
         MultiMap<LogicalOperator, LogicalPlan> groupByPlans
                                                     = cg.getGroupByPlans() ;
         List<LogicalOperator> inputs = cg.getInputs() ;
@@ -2156,6 +2192,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         List<LogicalPlan> plans = f.getForEachPlans() ;
         List<Boolean> flattens = f.getFlatten() ;
 
+        f.resetSchema();
         try {
 
             // Have to resolve all inner plans before calling getSchema
@@ -2193,7 +2230,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
             }
 
-            f.setSchemaComputed(false);
             f.getSchema();
 
         }
diff --git a/test/org/apache/pig/test/TestEvalPipeline.java b/test/org/apache/pig/test/TestEvalPipeline.java
index 6259471ff..fc401acf1 100644
--- a/test/org/apache/pig/test/TestEvalPipeline.java
+++ b/test/org/apache/pig/test/TestEvalPipeline.java
@@ -44,6 +44,8 @@ import org.apache.pig.builtin.TextLoader;
 import org.apache.pig.data.*;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.io.PigFile;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 
 import junit.framework.TestCase;
 
@@ -173,7 +175,6 @@ public class TestEvalPipeline extends TestCase {
         assertFalse(iter.hasNext());
     }
     
-    
     static public class TitleNGrams extends EvalFunc<DataBag> {
         
         @Override
@@ -232,6 +233,16 @@ public class TestEvalPipeline extends TestCase {
             }
             return sb.toString();
         }
+
+        public Schema outputSchema(Schema input) {
+            try {
+            Schema stringSchema = new Schema(new Schema.FieldSchema(null, DataType.CHARARRAY));
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, stringSchema, DataType.BAG);
+            return new Schema(fs);
+            } catch (Exception e) {
+                return null;
+            }
+        }
     }
 
     
@@ -240,6 +251,10 @@ public class TestEvalPipeline extends TestCase {
         public Tuple exec(Tuple input) throws IOException {
            return input; 
         }
+
+        public Schema outputSchema(Schema input) {
+            return input;
+        }
     }
     
     
