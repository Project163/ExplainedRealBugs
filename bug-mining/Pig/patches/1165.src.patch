diff --git a/CHANGES.txt b/CHANGES.txt
index ecb3ac88f..d5f9ed3ce 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -145,6 +145,8 @@ PIG-3013: BinInterSedes improve chararray sort performance (rohini)
 
 BUG FIXES
 
+PIG-3172: Partition filter push down does not happen when there is a non partition key map column filter (rohini)
+
 PIG-3205: Passing arguments to python script does not work with -f option (rohini)
 
 PIG-2507: Semicolon in paramenters for UDF results in parsing error (tnachen via daijy)
diff --git a/src/org/apache/pig/newplan/PColFilterExtractor.java b/src/org/apache/pig/newplan/PColFilterExtractor.java
index 73af5259b..f988b506d 100644
--- a/src/org/apache/pig/newplan/PColFilterExtractor.java
+++ b/src/org/apache/pig/newplan/PColFilterExtractor.java
@@ -25,7 +25,6 @@ import java.util.List;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pig.Expression;
-import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.Pair;
 
@@ -36,6 +35,7 @@ import org.apache.pig.newplan.logical.expression.BinCondExpression;
 import org.apache.pig.newplan.logical.expression.BinaryExpression;
 import org.apache.pig.newplan.logical.expression.CastExpression;
 import org.apache.pig.newplan.logical.expression.ConstantExpression;
+import org.apache.pig.newplan.logical.expression.DereferenceExpression;
 import org.apache.pig.newplan.logical.expression.DivideExpression;
 import org.apache.pig.newplan.logical.expression.EqualExpression;
 import org.apache.pig.newplan.logical.expression.GreaterThanEqualExpression;
@@ -44,6 +44,7 @@ import org.apache.pig.newplan.logical.expression.IsNullExpression;
 import org.apache.pig.newplan.logical.expression.LessThanEqualExpression;
 import org.apache.pig.newplan.logical.expression.LessThanExpression;
 import org.apache.pig.newplan.logical.expression.LogicalExpression;
+import org.apache.pig.newplan.logical.expression.MapLookupExpression;
 import org.apache.pig.newplan.logical.expression.ModExpression;
 import org.apache.pig.newplan.logical.expression.MultiplyExpression;
 import org.apache.pig.newplan.logical.expression.NotEqualExpression;
@@ -493,7 +494,11 @@ public class PColFilterExtractor extends PlanVisitor {
 			visit( (NotExpression)op );
 		} else if( op instanceof RegexExpression ) {
 			visit( (RegexExpression)op );
-		}
+        } else if (op instanceof MapLookupExpression) {
+            visit((MapLookupExpression) op);
+        } else if (op instanceof DereferenceExpression) {
+            visit((DereferenceExpression) op);
+        }
 	}
 
 	// some specific operators which are of interest to catch some
@@ -525,7 +530,15 @@ public class PColFilterExtractor extends PlanVisitor {
 	private void visit(IsNullExpression isNull) throws FrontendException {
 		visit(isNull.getExpression());
 	}
-
+	
+	private void visit(MapLookupExpression mapLookup) throws FrontendException {
+        visit(mapLookup.getMap());
+    }
+	
+	private void visit(DereferenceExpression deref) throws FrontendException {
+        visit(deref.getReferredExpression());
+    }
+	
     public boolean canPushDown() {
         return canPushDown;
     }
diff --git a/test/org/apache/pig/test/TestPartitionFilterPushDown.java b/test/org/apache/pig/test/TestPartitionFilterPushDown.java
index b8af861a8..b5e2f35f0 100644
--- a/test/org/apache/pig/test/TestPartitionFilterPushDown.java
+++ b/test/org/apache/pig/test/TestPartitionFilterPushDown.java
@@ -72,7 +72,8 @@ import org.junit.Test;
  */
 public class TestPartitionFilterPushDown {
     static PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
-    String query = "a = load 'foo' as (srcid:int, mrkt:chararray, dstid:int, name:chararray, age:int);";
+    String query = "a = load 'foo' as (srcid:int, mrkt:chararray, dstid:int, name:chararray, " +
+    		"age:int, browser:map[], location:tuple(country:chararray, zip:int));";
 
     @BeforeClass
     public static void setup() throws Exception {
@@ -297,6 +298,47 @@ public class TestPartitionFilterPushDown {
         "(age != 15)");
     }
 
+    /**
+     * test case where there is a single expression on partition columns in the
+     * filter expression along with an expression on non partition column of
+     * type map
+     * @throws Exception
+     */
+    @Test
+    public void testMixedNonPartitionTypeMap() throws Exception {
+        String q = query + "b = filter a by srcid == 10 and browser#'type' == 'IE';" +
+                "store b into 'out';";
+        test(q, Arrays.asList("srcid"), "(srcid == 10)");
+
+        q = query + "b = filter a by srcid == 10 and browser#'type' == 'IE' and " +
+                "browser#'version'#'major' == '8.0';" + "store b into 'out';";
+        test(q, Arrays.asList("srcid"), "(srcid == 10)");
+
+        // Some complex partition filters with a non-partition filter
+        q = query + "b = filter a by srcid == 10 and mrkt > '1' and mrkt < '5';" +
+                "c = filter b by browser#'type' == 'IE';" + "store b into 'out';";
+        test(q, Arrays.asList("srcid", "mrkt"),
+                "(((srcid == 10) and (mrkt > '1')) and (mrkt < '5'))");
+
+        q = query + "b = filter a by srcid == 10 and (mrkt > '1' and mrkt < '5');" +
+                "c = filter b by browser#'type' == 'IE';" + "store b into 'out';";
+        test(q, Arrays.asList("srcid", "mrkt"),
+                "((srcid == 10) and ((mrkt > '1') and (mrkt < '5')))");
+    }
+
+    /**
+     * test case where there is a single expression on partition columns in the
+     * filter expression along with an expression on non partition column of
+     * type tuple
+     * @throws Exception
+     */
+    @Test
+    public void testMixedNonPartitionTypeTuple() throws Exception {
+        String q = query + "b = filter a by srcid == 10 and location.country == 'US';" +
+                "store b into 'out';";
+        test(q, Arrays.asList("srcid"), "(srcid == 10)");
+    }
+
     @Test
     public void testNegPColConditionWithNonPCol() throws Exception {
         // use of partition column condition and non partition column in
@@ -589,7 +631,17 @@ public class TestPartitionFilterPushDown {
     //// helper methods ///////
 
     private PColFilterExtractor test(String query, List<String> partitionCols,
-            String expPartFilterString, String expFilterString)
+            String expPartFilterString) throws Exception {
+        return test(query, partitionCols, expPartFilterString, null, true);
+    }
+
+    private PColFilterExtractor test(String query, List<String> partitionCols,
+            String expPartFilterString, String expFilterString) throws Exception {
+        return test(query, partitionCols, expPartFilterString, expFilterString, false);
+    }
+
+    private PColFilterExtractor test(String query, List<String> partitionCols,
+            String expPartFilterString, String expFilterString, boolean skipTrimmedFilterCheck)
     throws Exception {
         PigServer pigServer = new PigServer( pc );
         LogicalPlan newLogicalPlan = Util.buildLp(pigServer, query);
@@ -608,15 +660,23 @@ public class TestPartitionFilterPushDown {
                     pColExtractor.getPColCondition().toString().toLowerCase());
         }
 
-        if(expFilterString == null) {
-            Assert.assertTrue("Check that filter can be removed:",
-                    pColExtractor.isFilterRemovable());
-        } else {
-            String actual = pColExtractor.getExpression(
-                    (LogicalExpression)filter.getFilterPlan().getSources().get(0)).
-                    toString().toLowerCase();
-            Assert.assertEquals("checking trimmed filter expression:", expFilterString,
-                    actual);
+        // The getExpression() in PColFilterExtractor was written to get the
+        // pushdown filter expression and does not have support for columns of
+        // type tuple or map as partition columns are expected to be of
+        // primitive data type. But we are using the method in the tests for forming
+        // trimmed filter after pushdown. So skip check in cases where we expect a
+        // trimmed filter to have a map or tuple in the condition.
+        if (!skipTrimmedFilterCheck) {
+            if (expFilterString == null) {
+                Assert.assertTrue("Check that filter can be removed:",
+                        pColExtractor.isFilterRemovable());
+            } else {
+                String actual = pColExtractor
+                        .getExpression(
+                                (LogicalExpression) filter.getFilterPlan().getSources().get(0))
+                        .toString().toLowerCase();
+                Assert.assertEquals("checking trimmed filter expression:", expFilterString, actual);
+            }
         }
         return pColExtractor;
     }
