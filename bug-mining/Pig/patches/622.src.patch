diff --git a/CHANGES.txt b/CHANGES.txt
index 6e7c2b0b2..1a0e9ffe5 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -282,6 +282,9 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1813: Pig 0.8 throws ERROR 1075 while trying to refer a map in the result
+of eval udf.Works with 0.7 (daijy)
+
 PIG-1776: changing statement corresponding to alias after explain , then 
   doing dump gives incorrect result (thejas)
 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java
index 47827dc56..d05911e56 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java
@@ -203,13 +203,6 @@ public class POUserFunc extends ExpressionOperator {
                     result.result = func.exec((Tuple) result.result);
                     }
                 }
-                if(resultType == DataType.BYTEARRAY) {
-                    // This is needed if some EvalFunc has default datatype as bytearray and returns arbitrary objects
-                    // We see such behavior in case of script EvalFunc, which is used to run udfs in scripting langs
-                    if(result.result != null && DataType.findType(result.result) != DataType.BYTEARRAY) {
-                        result.result = new DataByteArray(result.result.toString().getBytes());
-                    }
-                }
                 return result;
             }
 
diff --git a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
index 6d68daef5..6d84ed067 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
@@ -82,6 +82,7 @@ public class LOGenerate extends LogicalRelationalOperator {
             
             LogicalFieldSchema fieldSchema = null;
             
+            // schema of the expression after flatten
             LogicalSchema expSchema = null;
             
             if (exp.getFieldSchema()!=null) {
@@ -101,7 +102,7 @@ public class LOGenerate extends LogicalRelationalOperator {
                         expSchema = null;
                     }
                     else {
-                        // if flatten is set, set schema of tuple field to this schema
+                     // if we come here, we get a BAG/Tuple with flatten, extract inner schema of the tuple as expSchema
                         List<LogicalSchema.LogicalFieldSchema> innerFieldSchemas = new ArrayList<LogicalSchema.LogicalFieldSchema>();
                         if (flattenFlags[i]) {
                             if (fieldSchema.type == DataType.BAG) {
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index 28a2bf4a3..6902400db 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -42,6 +42,7 @@ import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataByteArray;
 import org.apache.pig.data.DataType;
+import org.apache.pig.data.DefaultBagFactory;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.io.FileLocalizer;
@@ -1216,4 +1217,61 @@ public class TestEvalPipeline2 extends TestCase {
         }
         fail();
     }
+    
+    public static class BagGenerateNoSchema extends EvalFunc<DataBag> {
+        @Override
+        public DataBag exec(Tuple input) throws IOException {
+            DataBag bg = DefaultBagFactory.getInstance().newDefaultBag();
+            bg.add(input);
+            return bg;
+        }
+    }
+    
+    // See PIG-1813
+    @Test
+    public void testUDFNoSchemaPropagate1() throws Exception{
+        String[] input1 = {
+                "[key#1,key2#2]",
+                "[key#2,key2#3]",
+        };
+        
+        Util.createInputFile(cluster, "table_testUDFNoSchemaPropagate1", input1);
+
+        pigServer.registerQuery("a = load 'table_testUDFNoSchemaPropagate1' as (a0:map[]);");
+        pigServer.registerQuery("b = foreach a generate " + BagGenerateNoSchema.class.getName() + "(*) as b0;");
+        pigServer.registerQuery("c = foreach b generate flatten(IdentityColumn(b0));");
+        pigServer.registerQuery("d = foreach c generate $0#'key';");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("d");
+        
+        Tuple t = iter.next();
+        assertTrue(t.toString().contains("(1)"));
+        t = iter.next();
+        assertTrue(t.toString().contains("(2)"));
+        assertFalse(iter.hasNext());
+    }
+    
+    // See PIG-1813
+    @Test
+    public void testUDFNoSchemaPropagate2() throws Exception{
+        String[] input1 = {
+                "[key#1,key2#2]",
+                "[key#2,key2#3]",
+        };
+        
+        Util.createInputFile(cluster, "table_testUDFNoSchemaPropagate2", input1);
+
+        pigServer.registerQuery("a = load 'table_testUDFNoSchemaPropagate2' as (a0:map[]);");
+        pigServer.registerQuery("b = foreach a generate flatten(" + BagGenerateNoSchema.class.getName() + "(*)) as b0;");
+        pigServer.registerQuery("c = foreach b generate IdentityColumn(b0);");
+        pigServer.registerQuery("d = foreach c generate $0#'key';");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("d");
+        
+        Tuple t = iter.next();
+        assertTrue(t.toString().contains("(1)"));
+        t = iter.next();
+        assertTrue(t.toString().contains("(2)"));
+        assertFalse(iter.hasNext());
+    }
 }
