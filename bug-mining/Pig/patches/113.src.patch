diff --git a/CHANGES.txt b/CHANGES.txt
index 975434ec5..03d3f2c4b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -267,3 +267,5 @@ Trunk (unreleased changes)
     PIG-54: MIN/MAX don't deal with invalid data (pradeepk via olgan)
 
     PIG-470: TextLoader should produce bytearrays (sms via olgan)
+
+    PIG-335: lineage (sms vi olgan)
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index 428456637..6126492e8 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -1150,7 +1150,12 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         ExpressionOperator from = (ExpressionOperator) LogToPhyMap.get(op
                 .getExpression());
         physOp.setResultType(op.getType());
-        ((POCast) physOp).setLoadFSpec(load.getClass().getName());
+        LoadFunc lf = op.getLoadFunc();
+        String lfString = null;
+        if(null != lf) {
+            lfString = lf.getClass().getName();
+            ((POCast) physOp).setLoadFSpec(lfString);
+        }
         try {
             currentPlan.connect(from, physOp);
         } catch (PlanException e) {
@@ -1159,6 +1164,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         }
 
     }
+
     @Override
     public void visit(LOLimit limit) throws VisitorException {
             String scope = limit.getOperatorKey().scope;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
index 5dd904aa6..f95e129ac 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
@@ -44,7 +44,7 @@ import org.apache.pig.impl.plan.VisitorException;
  * Need the full operator implementation.
  */
 public class POCast extends ExpressionOperator {
-    private String loadFSpec;
+    private String loadFSpec = null;
 	transient private LoadFunc load;
 	private Log log = LogFactory.getLog(getClass());
     private boolean castNotNeeded = false;
@@ -63,7 +63,9 @@ public class POCast extends ExpressionOperator {
     
     private void instantiateFunc() {
         if(load!=null) return;
-        this.load = (LoadFunc) PigContext.instantiateFuncFromSpec(this.loadFSpec);
+        if(this.loadFSpec != null) {
+            this.load = (LoadFunc) PigContext.instantiateFuncFromSpec(this.loadFSpec);
+        }
     }
     
     public void setLoadFSpec(String fSpec) {
diff --git a/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java b/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java
index 7f1fc61b3..add8f3948 100644
--- a/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java
@@ -84,8 +84,7 @@ public abstract class ExpressionOperator extends LogicalOperator {
      *             if there is already a schema and the existing schema cannot
      *             be reconciled with this new schema.
      */
-    public final void setFieldSchema(Schema.FieldSchema fs) throws FrontendException {
-		log.debug("Inside setFieldSchema");
+    public void setFieldSchema(Schema.FieldSchema fs) throws FrontendException {
         mFieldSchema = fs;
         setAlias(fs.alias);
         setType(fs.type);
diff --git a/src/org/apache/pig/impl/logicalLayer/LOAdd.java b/src/org/apache/pig/impl/logicalLayer/LOAdd.java
index 7827ed487..bcbccda2a 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOAdd.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOAdd.java
@@ -53,9 +53,11 @@ public class LOAdd extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
             mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOAnd.java b/src/org/apache/pig/impl/logicalLayer/LOAnd.java
index 12c80d88a..20b41f27c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOAnd.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOAnd.java
@@ -53,10 +53,12 @@ public class LOAnd extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCast.java b/src/org/apache/pig/impl/logicalLayer/LOCast.java
index 6cfc1806c..fa3c578b6 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCast.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCast.java
@@ -18,6 +18,7 @@
 
 package org.apache.pig.impl.logicalLayer;
 
+import org.apache.pig.LoadFunc;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
@@ -30,6 +31,7 @@ public class LOCast extends ExpressionOperator {
 
     private static final long serialVersionUID = 2L;
     private ExpressionOperator mExpr;
+    private LoadFunc mLoadFunc = null;
 
     /**
      * 
@@ -66,14 +68,8 @@ public class LOCast extends ExpressionOperator {
     @Override
     public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            if(DataType.isAtomic(mType)) {
-                mFieldSchema = new Schema.FieldSchema(null, mType);
-                if (mExpr.getFieldSchema() != null) {
-                    mFieldSchema.canonicalName =
-                        mExpr.getFieldSchema().canonicalName;
-                }
-                mIsFieldSchemaComputed = true;
-            }
+            mFieldSchema = new Schema.FieldSchema(null, mType);
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
@@ -88,4 +84,12 @@ public class LOCast extends ExpressionOperator {
         return false;
     }
 
+    public LoadFunc getLoadFunc() {
+        return mLoadFunc;
+    }
+
+    public void setLoadFunc(LoadFunc loadFunc) {
+        mLoadFunc = loadFunc;
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index 7caaa08c8..c99d4bf6f 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -167,6 +167,7 @@ public class LOCogroup extends LogicalOperator {
              */
             int arity = mGroupByPlans.get(inputs.get(0)).size();
             for (int i = 0; i < arity; ++i) {
+                Schema.FieldSchema groupByFs;
                 Collection<String> cAliases = positionAlias.get(i);
                 if(null != cAliases) {
                     Object[] aliases = cAliases.toArray();
@@ -181,11 +182,14 @@ public class LOCogroup extends LogicalOperator {
                                     if(!aliasLookup.get(alias)) {
                                         Schema.FieldSchema fs = eOp.getFieldSchema();
                                         if(null != fs) {
-                                            groupByFss.add(new Schema.FieldSchema(alias, fs.schema, fs.type));
+                                            groupByFs = new Schema.FieldSchema(alias, fs.schema, fs.type);
+                                            groupByFss.add(groupByFs);
                                             aliasLookup.put(alias, true);
                                         } else {
-                                            groupByFss.add(new Schema.FieldSchema(alias, null, DataType.BYTEARRAY));
+                                            groupByFs = new Schema.FieldSchema(alias, null, DataType.BYTEARRAY);
+                                            groupByFss.add(groupByFs);
                                         }
+                                        setFieldSchemaParent(groupByFs, positionOperators, i);
                                         break;
                                     } else {
                                         if(j < aliases.length) {
@@ -195,10 +199,19 @@ public class LOCogroup extends LogicalOperator {
                                             //just add the schema of the expression operator with the null alias
                                             Schema.FieldSchema fs = eOp.getFieldSchema();
                                             if(null != fs) {
-                                                groupByFss.add(new Schema.FieldSchema(null, fs.schema, fs.type));
+                                                groupByFs = new Schema.FieldSchema(null, fs.schema, fs.type);
+                                                groupByFss.add(groupByFs);
+                                                for(ExpressionOperator op: cEops) {
+                                                    Schema.FieldSchema opFs = op.getFieldSchema();
+                                                    if(null != opFs) {
+                                                        groupByFs.setParent(opFs.canonicalName, eOp);
+                                                    }
+                                                }
                                             } else {
-                                                groupByFss.add(new Schema.FieldSchema(null, null, DataType.BYTEARRAY));
+                                                groupByFs = new Schema.FieldSchema(null, null, DataType.BYTEARRAY);
+                                                groupByFss.add(groupByFs);
                                             }
+                                            setFieldSchemaParent(groupByFs, positionOperators, i);
                                             break;
                                         }
                                     }
@@ -218,10 +231,10 @@ public class LOCogroup extends LogicalOperator {
                 } else {
                     //We do not have any alias for this position in the group by columns
                     //We have positions $1, $2, etc.
-                    groupByFss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
+                    groupByFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                    groupByFss.add(groupByFs);
+                    setFieldSchemaParent(groupByFs, positionOperators, i);
                 }
-                //The schema for these columns is the merged schema of the expression operatore
-                //This part is handled in the type checker
             }            
 
             groupBySchema = new Schema(groupByFss);
@@ -229,7 +242,9 @@ public class LOCogroup extends LogicalOperator {
             if(1 == arity) {
                 byte groupByType = getAtomicGroupByType();
                 Schema groupSchema = groupByFss.get(0).schema;
-                fss.add(new Schema.FieldSchema("group", groupSchema, groupByType));
+                Schema.FieldSchema groupByFs = new Schema.FieldSchema("group", groupSchema, groupByType);
+                setFieldSchemaParent(groupByFs, positionOperators, 0);
+                fss.add(groupByFs);
             } else {
                 Schema mergedGroupSchema = getTupleGroupBySchema();
                 if(mergedGroupSchema.size() != groupBySchema.size()) {
@@ -255,9 +270,10 @@ public class LOCogroup extends LogicalOperator {
             }
             for (LogicalOperator op : inputs) {
                 try {
-                    Schema cSchema = op.getSchema();
-                    fss.add(new Schema.FieldSchema(op.getAlias(), op
-                            .getSchema(), DataType.BAG));
+                    Schema.FieldSchema bagFs = new Schema.FieldSchema(op.getAlias(),
+                            op.getSchema(), DataType.BAG);
+                    fss.add(bagFs);
+                    setFieldSchemaParent(bagFs, op);
                 } catch (FrontendException ioe) {
                     mIsSchemaComputed = false;
                     mSchema = null;
@@ -374,12 +390,35 @@ public class LOCogroup extends LogicalOperator {
 
             for(int j=0;j < innerPlans.size(); j++) {
                 byte innerType = innerPlans.get(j).getSingleLeafPlanOutputType() ;
-                fsList.get(j).type = DataType.mergeType(fsList.get(j).type,
-                                                        innerType) ;
+                ExpressionOperator eOp = (ExpressionOperator)innerPlans.get(j).getSingleLeafPlanOutputOp();
+                Schema.FieldSchema groupFs = fsList.get(j);
+                groupFs.type = DataType.mergeType(groupFs.type, innerType) ;
+                groupFs.setParent(eOp.getFieldSchema().canonicalName, eOp);
             }
         }
 
         return new Schema(fsList) ;
     }
 
+    private void setFieldSchemaParent(Schema.FieldSchema fs, MultiMap<Integer, ExpressionOperator> positionOperators, int position) throws FrontendException {
+        for(ExpressionOperator op: positionOperators.get(position)) {
+            Schema.FieldSchema opFs = op.getFieldSchema();
+            if(null != opFs) {
+                fs.setParent(opFs.canonicalName, op);
+            }
+        }
+    }
+
+    private void setFieldSchemaParent(Schema.FieldSchema fs, LogicalOperator op) throws FrontendException {
+        Schema s = op.getSchema();
+        if(null != s) {
+            for(Schema.FieldSchema inputFs: s.getFields()) {
+                if(null != inputFs) {
+                    fs.setParent(inputFs.canonicalName, op);
+                }
+            }
+        } else {
+            fs.setParent(null, op);
+        }
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCross.java b/src/org/apache/pig/impl/logicalLayer/LOCross.java
index 88b91b7b0..c5a0e1fac 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCross.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCross.java
@@ -67,6 +67,7 @@ public class LOCross extends LogicalOperator {
             for (LogicalOperator op : inputs) {
                 String opAlias = op.getAlias();
                 Schema s = op.getSchema();
+                Schema.FieldSchema newFs;
 
                 //need to extract the children and create the aliases
                 //assumption here is that flatten is only for one column
@@ -78,7 +79,7 @@ public class LOCross extends LogicalOperator {
                         log.debug("fs.alias: " + fs.alias);
                         if(null != fs.alias) {
                             String disambiguatorAlias = opAlias + "::" + fs.alias;
-                            Schema.FieldSchema newFs = new Schema.FieldSchema(disambiguatorAlias, fs.schema, fs.type);
+                            newFs = new Schema.FieldSchema(disambiguatorAlias, fs.schema, fs.type);
                             fss.add(newFs);
                             Integer count;
                             count = aliases.get(fs.alias);
@@ -99,9 +100,10 @@ public class LOCross extends LogicalOperator {
                             //we just need to record if its due to
                             //flattening
                         } else {
-                            Schema.FieldSchema newFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                            newFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
                             fss.add(newFs);
                         }
+                        newFs.setParent(fs.canonicalName, op);
                     }
                 } else {
                     mSchema = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/LODistinct.java b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
index 035a8063d..e5e062e23 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODistinct.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
@@ -64,7 +64,7 @@ public class LODistinct extends LogicalOperator {
                     throw new FrontendException("Could not find operator in plan");
                 }
                 if(op instanceof ExpressionOperator) {
-                    Schema.FieldSchema fs = ((ExpressionOperator)op).getFieldSchema();
+                    Schema.FieldSchema fs = new Schema.FieldSchema(((ExpressionOperator)op).getFieldSchema());
                     if(DataType.isSchemaType(fs.type)) {
                         mSchema = fs.schema;
                     } else {
diff --git a/src/org/apache/pig/impl/logicalLayer/LODivide.java b/src/org/apache/pig/impl/logicalLayer/LODivide.java
index b514024e3..3f6037a9a 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODivide.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODivide.java
@@ -53,9 +53,11 @@ public class LODivide extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
             mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOEqual.java b/src/org/apache/pig/impl/logicalLayer/LOEqual.java
index 667b4474b..2c58c5c11 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOEqual.java
@@ -53,10 +53,12 @@ public class LOEqual extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFilter.java b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
index bf4582efa..399fe0c95 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
@@ -66,7 +66,7 @@ public class LOFilter extends LogicalOperator {
             ArrayList<Schema.FieldSchema> fss = new ArrayList<Schema.FieldSchema>();
             try {
                 if(input instanceof ExpressionOperator) {
-                    Schema.FieldSchema fs = ((ExpressionOperator)input).getFieldSchema();
+                    Schema.FieldSchema fs = new Schema.FieldSchema(((ExpressionOperator)input).getFieldSchema());
                     if(DataType.isSchemaType(fs.type)) {
                         mSchema = fs.schema;
                     } else {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index f12ff6026..c0e0b0db7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -172,6 +172,7 @@ public class LOForEach extends LogicalOperator {
                                     Schema.FieldSchema fs;
                                     try {
                                         fs = new Schema.FieldSchema(s.getField(i));
+                                        fs.setParent(s.getField(i).canonicalName, op);
                                     } catch (ParseException pe) {
                                         throw new FrontendException(pe.getMessage());
                                     }
@@ -195,13 +196,23 @@ public class LOForEach extends LogicalOperator {
 									if((null != outerCanonicalAlias) && (null != innerCanonicalAlias)) {
 										String disambiguatorAlias = outerCanonicalAlias + "::" + innerCanonicalAlias;
 										newFs = new Schema.FieldSchema(disambiguatorAlias, fs.schema, fs.type);
-										fss.add(newFs);
+                                        try {
+                                            newFs.setParent(s.getField(i).canonicalName, op);
+										} catch (ParseException pe) {
+                                            throw new FrontendException(pe.getMessage());
+                                        }
+                                        fss.add(newFs);
                                         updateAliasCount(aliases, disambiguatorAlias);
 										//it's fine if there are duplicates
 										//we just need to record if its due to
 										//flattening
 									} else {
-										newFs = new Schema.FieldSchema(fs.alias, fs.schema, fs.type);
+										newFs = new Schema.FieldSchema(fs);
+                                        try {
+                                            newFs.setParent(s.getField(i).canonicalName, op);
+										} catch (ParseException pe) {
+                                            throw new FrontendException(pe.getMessage());
+                                        }
 										fss.add(newFs);
 									}
                                     updateAliasCount(aliases, innerCanonicalAlias);
@@ -225,10 +236,13 @@ public class LOForEach extends LogicalOperator {
                                         }
                                         updateAliasCount(aliases, newFs.alias);
                                         fss.add(newFs);
+                                        newFs.setParent(null, op);
                                     } else {
                                         for(Schema.FieldSchema ufs: userDefinedSchema.getFields()) {
                                             QueryParser.SchemaUtils.setFieldSchemaDefaultType(ufs, DataType.BYTEARRAY);
-                                            fss.add(new Schema.FieldSchema(ufs.alias, ufs.schema, ufs.type));
+                                            newFs = new Schema.FieldSchema(ufs);
+                                            fss.add(newFs);
+                                            newFs.setParent(null, op);
                                             updateAliasCount(aliases, ufs.alias);
                                         }
                                     }
@@ -239,6 +253,7 @@ public class LOForEach extends LogicalOperator {
 								        newFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
                                     }
                                     fss.add(newFs);
+                                    newFs.setParent(null, op);
                                 }
 							}
 						} else {
@@ -262,14 +277,17 @@ public class LOForEach extends LogicalOperator {
                         String outerCanonicalAlias = null;
                         if(null != userDefinedSchema) {
                             try {
-                                Schema.FieldSchema userDefinedFieldSchema = userDefinedSchema.getField(0);
+                                Schema.FieldSchema userDefinedFieldSchema = new Schema.FieldSchema(userDefinedSchema.getField(0));
                                 fss.add(userDefinedFieldSchema);
+                                userDefinedFieldSchema.setParent(null, op);
                                 updateAliasCount(aliases, userDefinedFieldSchema.alias);
                             } catch (ParseException pe) {
                                 throw new FrontendException(pe.getMessage());
                             }
                         } else {
-						    fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
+                            Schema.FieldSchema newFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+						    fss.add(newFs);
+                            newFs.setParent(null, op);
                         }
 					}
                 } catch (FrontendException fee) {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGenerate.java b/src/org/apache/pig/impl/logicalLayer/LOGenerate.java
index 2cfff4eff..0720cbcf7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGenerate.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGenerate.java
@@ -131,7 +131,7 @@ public class LOGenerate extends LogicalOperator {
                     throw new FrontendException("Could not find operator in plan");
                 }
                 if(op instanceof ExpressionOperator) {
-                    fss.add(((ExpressionOperator)op).getFieldSchema());
+                    fss.add(new Schema.FieldSchema(((ExpressionOperator)op).getFieldSchema()));
                     mSchema = new Schema(fss);
                 } else {
                     mSchema = op.getSchema();
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java b/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
index fcf535caf..f41c4deb9 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
@@ -53,10 +53,12 @@ public class LOGreaterThan extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java b/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
index 0d86ac543..f5cd598f2 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
@@ -53,10 +53,12 @@ public class LOGreaterThanEqual extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOIsNull.java b/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
index 5cd65773c..00a48d2ed 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
@@ -51,10 +51,11 @@ public class LOIsNull extends UnaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getOperand().getFieldSchema().canonicalName, getOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java b/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
index a644ba108..8ee13c799 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
@@ -53,10 +53,12 @@ public class LOLesserThan extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java b/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
index 289efffc8..868aabdce 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
@@ -53,10 +53,12 @@ public class LOLesserThanEqual extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java b/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
index 73d8ab9dd..f7fa20288 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
@@ -108,6 +108,7 @@ public class LOMapLookup extends ExpressionOperator {
             } else {
                 mFieldSchema = new Schema.FieldSchema(null, mValueType);
             }
+            mFieldSchema.setParent(mMap.getFieldSchema().canonicalName, mMap);
 
             mIsFieldSchemaComputed = true;
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMod.java b/src/org/apache/pig/impl/logicalLayer/LOMod.java
index 731e1cb54..3035c84b8 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMod.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMod.java
@@ -53,9 +53,11 @@ public class LOMod extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
             mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMultiply.java b/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
index c0bfe09da..d5a102072 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
@@ -53,9 +53,11 @@ public class LOMultiply extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
             mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/LONegative.java b/src/org/apache/pig/impl/logicalLayer/LONegative.java
index ebd12f521..6a08d20c1 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONegative.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONegative.java
@@ -47,9 +47,10 @@ public class LONegative extends UnaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
-        if(!mIsSchemaComputed) {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
+        if(!mIsFieldSchemaComputed) {
             mFieldSchema = new Schema.FieldSchema(null, getOperand().getType());
+            mFieldSchema.setParent(getOperand().getFieldSchema().canonicalName, getOperand());
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/LONot.java b/src/org/apache/pig/impl/logicalLayer/LONot.java
index 8158a20c5..50de7af4c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONot.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONot.java
@@ -51,10 +51,11 @@ public class LONot extends UnaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getOperand().getFieldSchema().canonicalName, getOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LONotEqual.java b/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
index fc8625a80..40075a9e4 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
@@ -53,10 +53,12 @@ public class LONotEqual extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOOr.java b/src/org/apache/pig/impl/logicalLayer/LOOr.java
index 3731422c2..5d31e441d 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOOr.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOOr.java
@@ -53,10 +53,12 @@ public class LOOr extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOProject.java b/src/org/apache/pig/impl/logicalLayer/LOProject.java
index abf727643..1af341dbd 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOProject.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOProject.java
@@ -194,7 +194,9 @@ public class LOProject extends ExpressionOperator {
                                 + expressionOperator.getClass().getName() + " " + expressionOperator);
                         if(!mSentinel) {
                             //we have an expression operator and hence a list of field shcemas
-                            mFieldSchema = ((ExpressionOperator)expressionOperator).getFieldSchema();
+                            Schema.FieldSchema fs = ((ExpressionOperator)expressionOperator).getFieldSchema();
+                            mFieldSchema = new Schema.FieldSchema(fs);
+                            mFieldSchema.setParent(fs.canonicalName, expressionOperator);
                         } else {
                             //we have a relational operator as input and hence a schema
                             log.debug("expression operator alias: " + expressionOperator.getAlias());
@@ -204,6 +206,7 @@ public class LOProject extends ExpressionOperator {
                             //the type of the operator will be unknown. when type checking is in place
                             //add the type of the operator as a parameter to the fieldschema creation
                             mFieldSchema = new Schema.FieldSchema(expressionOperator.getAlias(), expressionOperator.getSchema(), DataType.TUPLE);
+                            mFieldSchema.setParent(null, expressionOperator);
                             //mFieldSchema = new Schema.FieldSchema(expressionOperator.getAlias(), expressionOperator.getSchema());
                         }
                     } else {
@@ -233,23 +236,30 @@ public class LOProject extends ExpressionOperator {
                                 if(null != expOpFs) {
                                     Schema s = expOpFs.schema;
                                     if(null != s) {
-                                        mFieldSchema = new Schema.FieldSchema(s.getField(mProjection.get(0)));
+                                        Schema.FieldSchema fs = s.getField(mProjection.get(0));
+                                        mFieldSchema = new Schema.FieldSchema(fs);
+                                        mFieldSchema.setParent(fs.canonicalName, expressionOperator);
                                     } else {
                                         mFieldSchema = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                                        mFieldSchema.setParent(expOpFs.canonicalName, expressionOperator);
                                     }
                                 } else {
                                     mFieldSchema = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                                    mFieldSchema.setParent(null, expressionOperator);
                                 }
                             } else {
                                 log.debug("Input is a logical operator");
-                                   Schema s = expressionOperator.getSchema();
+                                Schema s = expressionOperator.getSchema();
                                 log.debug("s: " + s);
                                 if(null != s) {
-                                    mFieldSchema = new Schema.FieldSchema(s.getField(mProjection.get(0)));
+                                    Schema.FieldSchema fs = s.getField(mProjection.get(0));
+                                    mFieldSchema = new Schema.FieldSchema(fs);
+                                    mFieldSchema.setParent(fs.canonicalName, expressionOperator);
                                     log.debug("mFieldSchema alias: " + mFieldSchema.alias);
                                     log.debug("mFieldSchema schema: " + mFieldSchema.schema);
                                 } else {
                                     mFieldSchema = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                                    mFieldSchema.setParent(null, expressionOperator);
                                 }
                                 mType = mFieldSchema.type ;
                             }
@@ -259,6 +269,7 @@ public class LOProject extends ExpressionOperator {
                         
                         for (int colNum : mProjection) {
                             log.debug("Col: " + colNum);
+                            Schema.FieldSchema fs;
                             if(!mSentinel) {
                                 Schema.FieldSchema expOpFs = ((ExpressionOperator)expressionOperator).getFieldSchema();
                                 if(null != expOpFs) {
@@ -266,22 +277,36 @@ public class LOProject extends ExpressionOperator {
                                     log.debug("Schema s: " + s);
                                     if(null != s) {
                                         if(colNum < s.size()) {
-                                            fss.add(new Schema.FieldSchema(s.getField(colNum)));
+                                            Schema.FieldSchema parentFs = s.getField(colNum);
+                                            fs = new Schema.FieldSchema(parentFs);
+                                            fss.add(fs);
+                                            fs.setParent(parentFs.canonicalName, expressionOperator);
                                         } else {
-                                            fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
+                                            fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                                            fss.add(fs);
+                                            fs.setParent(expOpFs.canonicalName, expressionOperator);
                                         }
                                     } else {
-                                        fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
+                                        fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                                        fss.add(fs);
+                                        fs.setParent(expOpFs.canonicalName, expressionOperator);
                                     }
                                 } else {
+                                    fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
                                     fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
+                                    fs.setParent(null, expressionOperator);
                                 }
                             } else {
                                 Schema s = expressionOperator.getSchema();
                                 if(null != s) {
-                                    fss.add(new Schema.FieldSchema(s.getField(colNum)));
+                                    Schema.FieldSchema parentFs = s.getField(colNum);
+                                    fs = new Schema.FieldSchema(parentFs);
+                                    fss.add(fs);
+                                    fs.setParent(parentFs.canonicalName, expressionOperator);
                                 } else {
-                                    fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
+                                    fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                                    fss.add(fs);
+                                    fs.setParent(null, expressionOperator);
                                 }
                             }
                         }
@@ -296,6 +321,7 @@ public class LOProject extends ExpressionOperator {
                     throw new FrontendException(pe.getMessage());
                 }
                 mFieldSchema = new Schema.FieldSchema(expressionOperator.getAlias(), new Schema(fss));
+                mFieldSchema.setParent(null, expressionOperator);
                 mIsFieldSchemaComputed = true;
                 log.debug("mIsStar is false, returning computed field schema of expressionOperator");
             }
@@ -311,6 +337,7 @@ public class LOProject extends ExpressionOperator {
             if(!DataType.isSchemaType(mType)) {
                 Schema pjSchema = new Schema(mFieldSchema);
                 mFieldSchema = new Schema.FieldSchema(getAlias(), pjSchema, DataType.TUPLE);
+                mFieldSchema.setParent(null, expressionOperator);
             } else {
                 mFieldSchema.type = DataType.TUPLE;
             }
@@ -322,6 +349,7 @@ public class LOProject extends ExpressionOperator {
                 if(!DataType.isSchemaType(mType)) {
                     Schema pjSchema = new Schema(mFieldSchema);
                     mFieldSchema = new Schema.FieldSchema(getAlias(), pjSchema, DataType.BAG);
+                    mFieldSchema.setParent(null, expressionOperator);
                 } else {
                     mFieldSchema.type = DataType.BAG;
                 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LORegexp.java b/src/org/apache/pig/impl/logicalLayer/LORegexp.java
index 4a91ff827..d8c3cfa83 100644
--- a/src/org/apache/pig/impl/logicalLayer/LORegexp.java
+++ b/src/org/apache/pig/impl/logicalLayer/LORegexp.java
@@ -93,10 +93,12 @@ public class LORegexp extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-            mFieldSchema = fs;
+            mFieldSchema = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
+            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSort.java b/src/org/apache/pig/impl/logicalLayer/LOSort.java
index fec594182..e72cbfe9b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSort.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSort.java
@@ -129,7 +129,7 @@ public class LOSort extends LogicalOperator {
                     throw new FrontendException("Could not find operator in plan");
                 }
                 if(op instanceof ExpressionOperator) {
-                    Schema.FieldSchema fs = ((ExpressionOperator)op).getFieldSchema();
+                    Schema.FieldSchema fs = new Schema.FieldSchema(((ExpressionOperator)op).getFieldSchema());
                     if(DataType.isSchemaType(fs.type)) {
                         mSchema = fs.schema;
                     } else {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSubtract.java b/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
index 17009ec16..3125adde3 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
@@ -53,9 +53,11 @@ public class LOSubtract extends BinaryExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
             mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mFieldSchema.setParent(getLhsOperand().getFieldSchema().canonicalName, getLhsOperand());
+            mFieldSchema.setParent(getRhsOperand().getFieldSchema().canonicalName, getRhsOperand());
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index cb62be888..f903ddd07 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -68,6 +68,22 @@ public class LOUnion extends LogicalOperator {
                         mSchema = op.getSchema();
                     }
                 }
+                if(null != mSchema) {
+                    for(Schema.FieldSchema fs: mSchema.getFields()) {
+                        iter = s.iterator();
+                        while(iter.hasNext()) {
+                            op = iter.next();
+                            Schema opSchema = op.getSchema();
+                            if(null != s) {
+                                for(Schema.FieldSchema opFs: opSchema.getFields()) {
+                                    fs.setParent(opFs.canonicalName, op);
+                                }
+                            } else {
+                                fs.setParent(null, op);
+                            }
+                        }
+                    }
+                }
                 mIsSchemaComputed = true;
             } catch (FrontendException fe) {
                 mSchema = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
index e52179e56..ab501b778 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
@@ -80,35 +80,37 @@ public class LOUserFunc extends ExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() throws FrontendException {
-        Schema inputSchema = new Schema();
-        for(ExpressionOperator op: mArgs) {
-            if (!DataType.isUsableType(op.getType())) {
-                String msg = "Problem with input: " + op + " of User-defined function: " + this ;
-                mFieldSchema = null;
-                mIsFieldSchemaComputed = false;
-                throw new FrontendException(msg) ;
+        if(!mIsFieldSchemaComputed) {
+            Schema inputSchema = new Schema();
+            for(ExpressionOperator op: mArgs) {
+                if (!DataType.isUsableType(op.getType())) {
+                    String msg = "Problem with input: " + op + " of User-defined function: " + this ;
+                    mFieldSchema = null;
+                    mIsFieldSchemaComputed = false;
+                    throw new FrontendException(msg) ;
+                }
+                inputSchema.add(op.getFieldSchema());    
             }
-            inputSchema.add(op.getFieldSchema());    
-        }
-
-        EvalFunc<?> ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(mFuncSpec);
-        Schema udfSchema = ef.outputSchema(inputSchema);
-
-        if (null != udfSchema) {
-            Schema.FieldSchema fs;
-            try {
-                fs = new Schema.FieldSchema(udfSchema.getField(0));
-            } catch (ParseException pe) {
-                throw new FrontendException(pe.getMessage());
+    
+            EvalFunc<?> ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(mFuncSpec);
+            Schema udfSchema = ef.outputSchema(inputSchema);
+    
+            if (null != udfSchema) {
+                Schema.FieldSchema fs;
+                try {
+                    fs = new Schema.FieldSchema(udfSchema.getField(0));
+                } catch (ParseException pe) {
+                    throw new FrontendException(pe.getMessage());
+                }
+                setType(fs.type);
+                mFieldSchema = fs;
+                mIsFieldSchemaComputed = true;
+            } else {
+                byte returnType = DataType.findType(ef.getReturnType());
+                setType(returnType);
+                mFieldSchema = new Schema.FieldSchema(null, null, returnType);
+                mIsFieldSchemaComputed = true;
             }
-            setType(fs.type);
-            mFieldSchema = fs;
-            mIsFieldSchemaComputed = true;
-        } else {
-            byte returnType = DataType.findType(ef.getReturnType());
-            setType(returnType);
-            mFieldSchema = new Schema.FieldSchema(null, null, returnType);
-            mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
index 166ccf80c..9eb5f45f3 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
@@ -167,11 +167,6 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
      */
     public void setCanonicalNames() {
         for (Schema.FieldSchema fs : mSchema.getFields()) {
-            if (fs.canonicalName != null) {
-                throw new RuntimeException("Attempt to rename field " +
-                        fs.alias + " in operator " + name() + " that " +
-                    "already has canonical name "  + fs.canonicalName);
-            }
             fs.canonicalName = CanonicalNamer.getNewName();
         }
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
index 98b998601..1f64c1788 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
@@ -36,6 +36,11 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.DepthFirstWalker;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.optimizer.OptimizerException;
+import org.apache.pig.LoadFunc;
+import org.apache.pig.impl.PigContext;
+import org.apache.pig.impl.streaming.StreamingCommand;
+import org.apache.pig.impl.streaming.StreamingCommand.Handle;
+import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
 
 /**
  * A visitor to discover if any schema has been specified for a file being
@@ -129,6 +134,17 @@ public class TypeCastInserter extends LogicalTransformer {
                     p.connect(proj, cast);
                     
                     cast.setFieldSchema(fs.clone());
+                    LoadFunc loadFunc = null;
+                    if(lo instanceof LOLoad) {
+                        loadFunc = ((LOLoad)lo).getLoadFunc();
+                    } else if (lo instanceof LOStream) {
+                        StreamingCommand command = ((LOStream)lo).getStreamingCommand();
+                        HandleSpec streamOutputSpec = command.getOutputSpec(); 
+                        loadFunc = (LoadFunc)PigContext.instantiateFuncFromSpec(streamOutputSpec.getSpec());
+                    } else {
+                        throw new OptimizerException("TypeCastInserter invoked with an invalid operator class name:" + lo.getClass().getSimpleName());
+                    }
+                    cast.setLoadFunc(loadFunc);
                     typeChanges.put(fs.canonicalName, fs.type);
                     // Reset the loads field schema to byte array so that it
                     // will reflect reality.
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 3023e1e1c..879f9ed5a 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -913,7 +913,6 @@ LogicalOperator BaseExpr(LogicalPlan lp) :
             {
                 SchemaUtils.setSchemaDefaultType(schema, DataType.BYTEARRAY); 
                 op.setSchema(schema); 
-                op.setCanonicalNames(); 
                 log.debug("Load as schema" + schema);
             } 
         |   fs = AtomSchema() 
@@ -949,7 +948,6 @@ LogicalOperator BaseExpr(LogicalPlan lp) :
             {
                 SchemaUtils.setSchemaDefaultType(schema, DataType.BYTEARRAY); 
                 op.setSchema(schema); 
-                op.setCanonicalNames(); 
                 log.debug("Stream as schema()"+ schema);
             } 
         | fs = AtomSchema() 
diff --git a/src/org/apache/pig/impl/logicalLayer/schema/Schema.java b/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
index b39b78582..e6e4167ed 100644
--- a/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
+++ b/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
@@ -32,9 +32,25 @@ import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pig.impl.util.MultiMap;
-import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-
+import org.apache.pig.impl.logicalLayer.CanonicalNamer;
+
+/**
+ * The Schema class encapsulates the notion of a schema for a relational operator.
+ * A schema is a list of columns that describe the output of a relational operator.
+ * Each column in the relation is represented as a FieldSchema, a static class inside
+ * the Schema. A column by definition has an alias, a type and a possible schema (if the
+ * column is a bag or a tuple). In addition, each column in the schema has a unique
+ * auto generated name used for tracking the lineage of the column in a sequence of
+ * statements.
+ *
+ * The lineage of the column is tracked using a map of the predecessors' columns to
+ * the operators that generate the predecessor columns. The predecessor columns are the
+ * columns required in order to generate the column under consideration.  Similarly, a
+ * reverse lookup of operators that generate the predecessor column to the predecessor
+ * column is maintained.
+ */
 
 public class Schema implements Serializable, Cloneable {
 
@@ -71,7 +87,7 @@ public class Schema implements Serializable, Cloneable {
          */
         public String canonicalName = null;
 
-        /**
+        /*
          * Map of canonical names used for this field in other sections of the
          * plan.  It can occur that a single field will have different
          * canonical names in different branches of a plan.  For example, 
@@ -79,10 +95,25 @@ public class Schema implements Serializable, Cloneable {
          * column will have canonical name, say, of 'r'.  But in branches
          * above the cogroup it may have been known as 's' in the A branch and
          * 't' in the B branch.  This map preserves that.  The key is a
-         * logical operator's key, and the value is the canonical name
+         * logical operator, and the value is the canonical name
          * associated with the field for that operator.
          */
-        public Map<OperatorKey, String> canonicalMap = null;
+        private Map<String, LogicalOperator> canonicalMap = null;
+
+        /**
+         * A reverse lookup of canonical names to logical operators. The reverse
+         * lookup serves cases where the canonical name of the predecessor
+         * cannot be determined. In such cases the keys of the reverse lookup
+         * can be used to navigate the plan
+         */
+        private MultiMap<LogicalOperator, String> reverseCanonicalMap = null;
+        
+        /**
+         * Canonical namer object to generate new canonical names on
+         * request. In order to ensure unique and consistent names, across
+         * all field schema objects, the object is made static.
+         */
+        public static CanonicalNamer canonicalNamer = new CanonicalNamer();
         
         private static Log log = LogFactory.getLog(Schema.FieldSchema.class);
 
@@ -99,6 +130,9 @@ public class Schema implements Serializable, Cloneable {
             alias = a;
             type = t;
             schema = null;            
+            canonicalName = canonicalNamer.getNewName();
+            canonicalMap = new HashMap<String, LogicalOperator>();
+            reverseCanonicalMap = new MultiMap<LogicalOperator, String>();
         }
 
         /**
@@ -113,6 +147,9 @@ public class Schema implements Serializable, Cloneable {
             alias = a;
             type = DataType.TUPLE;
             schema = s;
+            canonicalName = canonicalNamer.getNewName();
+            canonicalMap = new HashMap<String, LogicalOperator>();
+            reverseCanonicalMap = new MultiMap<LogicalOperator, String>();
         }
 
         /**
@@ -131,11 +168,14 @@ public class Schema implements Serializable, Cloneable {
             alias = a;
             schema = s;
             log.debug("t: " + t + " Bag: " + DataType.BAG + " tuple: " + DataType.TUPLE);
-            if ((null != s) && (t != DataType.BAG) && (t != DataType.TUPLE)) {
+            if ((null != s) && !(DataType.isSchemaType(t))) {
                 throw new FrontendException("Only a BAG or TUPLE can have schemas. Got "
                         + DataType.findTypeName(t));
             }
             type = t;
+            canonicalName = canonicalNamer.getNewName();
+            canonicalMap = new HashMap<String, LogicalOperator>();
+            reverseCanonicalMap = new MultiMap<LogicalOperator, String>();
         }
 
         /**
@@ -159,9 +199,27 @@ public class Schema implements Serializable, Cloneable {
                 schema = null;
                 type = DataType.UNKNOWN;
             }
+            canonicalName = canonicalNamer.getNewName();
+            canonicalMap = new HashMap<String, LogicalOperator>();
+            reverseCanonicalMap = new MultiMap<LogicalOperator, String>();
         }
 
-        /***
+        public void setParent(String parentCanonicalName, LogicalOperator parent) {
+            if(null != parentCanonicalName) {
+                canonicalMap.put(parentCanonicalName, parent);
+            }
+            reverseCanonicalMap.put(parent, parentCanonicalName);
+        }
+
+        public Map<String, LogicalOperator> getCanonicalMap() {
+            return canonicalMap;
+        }
+
+        public MultiMap<LogicalOperator, String> getReverseCanonicalMap() {
+            return reverseCanonicalMap;
+        }
+
+        /**
          *  Two field schemas are equal if types and schemas
          *  are equal in all levels.
          *
@@ -350,7 +408,7 @@ public class Schema implements Serializable, Cloneable {
                 fs.canonicalName = canonicalName;
                 if (canonicalMap != null) {
                     fs.canonicalMap =
-                        new HashMap<OperatorKey, String>(canonicalMap);
+                        new HashMap<String, LogicalOperator>(canonicalMap);
                 }
                 return fs;
             } catch (FrontendException fe) {
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 61bf6385b..2d1e52705 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -25,9 +25,11 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Stack;
+import java.util.HashSet;
 
 import org.apache.pig.EvalFunc;
 import org.apache.pig.FuncSpec;
+import org.apache.pig.LoadFunc;
 import org.apache.pig.Algebraic;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.logicalLayer.FrontendException;
@@ -44,6 +46,9 @@ import org.apache.pig.impl.plan.CompilationMessageCollector.MessageType ;
 import org.apache.pig.impl.plan.*;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.data.DataType ;
+import org.apache.pig.impl.streaming.StreamingCommand;
+import org.apache.pig.impl.streaming.StreamingCommand.Handle;
+import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -359,7 +364,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
     }
 
-    private void insertCastForRegexp(LORegexp rg) {
+    private void insertCastForRegexp(LORegexp rg) throws VisitorException {
         LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
         collectCastWarning(rg, DataType.BYTEARRAY, DataType.CHARARRAY) ;
         OperatorKey newKey = genNewOperatorKey(rg) ;
@@ -376,6 +381,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw err ;
         }
         rg.setOperand(cast) ;
+        this.visit(cast);
     }
 
     public void visit(LOAnd binOp) throws VisitorException {
@@ -1055,7 +1061,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private void insertLeftCastForBinaryOp(BinaryExpressionOperator binOp,
-                                           byte toType ) {
+                                           byte toType ) throws VisitorException {
         LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
         collectCastWarning(binOp,
                            binOp.getLhsOperand().getType(),
@@ -1075,10 +1081,11 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw err ;
         }
         binOp.setLhsOperand(cast) ;
+        this.visit(cast);
     }
 
     private void insertRightCastForBinaryOp(BinaryExpressionOperator binOp,
-                                            byte toType ) {
+                                            byte toType ) throws VisitorException {
         LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
         collectCastWarning(binOp,
                            binOp.getRhsOperand().getType(),
@@ -1098,6 +1105,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw err ;
         }
         binOp.setRhsOperand(cast) ;
+        this.visit(cast);
     }
 
     /**
@@ -1139,7 +1147,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     }
 
-    private void insertCastForUniOp(UnaryExpressionOperator uniOp, byte toType) {
+    private void insertCastForUniOp(UnaryExpressionOperator uniOp, byte toType) throws VisitorException {
         collectCastWarning(uniOp,
                            uniOp.getOperand().getType(),
                            toType) ;
@@ -1164,6 +1172,8 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw err ;
         }
 
+        this.visit(cast);
+
     }
     
     // Currently there is no input type information support in UserFunc
@@ -1507,7 +1517,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     }
 
-    private void insertLeftCastForBinCond(LOBinCond binCond, byte toType) {
+    private void insertLeftCastForBinCond(LOBinCond binCond, byte toType) throws VisitorException {
         LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
 
         collectCastWarning(binCond,
@@ -1528,10 +1538,11 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw err ;
         } 
         binCond.setLhsOp(cast) ;
+        this.visit(cast);
 
     }
 
-    private void insertRightCastForBinCond(LOBinCond binCond, byte toType) {
+    private void insertRightCastForBinCond(LOBinCond binCond, byte toType) throws VisitorException {
         LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
 
         collectCastWarning(binCond,
@@ -1552,6 +1563,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw err ;
         }               
         binCond.setRhsOp(cast) ;
+        this.visit(cast);
 
     }
 
@@ -1600,6 +1612,17 @@ public class TypeCheckingVisitor extends LOVisitor {
         // cast.getType() already returns the correct type so don't have to 
         // set here. This is a special case where output type is not
         // automatically determined.
+        
+        if(inputType == DataType.BYTEARRAY) {
+            try {
+                LoadFunc loadFunc = getLoadFunc(cast.getExpression());
+                cast.setLoadFunc(loadFunc);
+            } catch (FrontendException fee) {
+                throw new VisitorException("Cannot resolve load function to use for casting from " + 
+                            DataType.findTypeName(inputType) + " to " +
+                            DataType.findTypeName(expectedType) + ". " + fee.getMessage());
+            }
+        }
     }
     
     
@@ -1751,7 +1774,6 @@ public class TypeCheckingVisitor extends LOVisitor {
         LogicalPlan currentPlan = mCurrentWalker.getPlan() ;
         List<LogicalOperator> list = currentPlan.getPredecessors(op) ;
 
-        // LOSplitOutput can only have 1 input
         try {
             // Compute the schema
             op.getSchema() ;
@@ -1766,6 +1788,22 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
     }
 
+    @Override
+    protected void visit(LOLimit op) throws VisitorException {
+        try {
+            // Compute the schema
+            op.regenerateSchema() ;
+        }
+        catch (FrontendException fe) {
+            String msg = "Problem while reading"
+                         + " schemas from inputs of LODistinct" ;
+            msgCollector.collect(msg, MessageType.Error) ;
+            VisitorException vse = new VisitorException(msg) ;
+            vse.initCause(fe) ;
+            throw vse ;
+        }
+    }
+
     /***
      * Return concatenated of all fields from all input operators
      * If one of the inputs have no schema then we cannot construct
@@ -1853,6 +1891,19 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         checkInnerPlan(comparisonPlan) ;
               
+
+        /*
+        try {
+            System.err.println("Filter inner plan typechecked");
+            LOPrinter lv = new LOPrinter(System.err, comparisonPlan);
+            lv.visit();
+            System.err.println();
+        } catch (Exception e) {
+            System.err.println(e.getMessage());
+            e.printStackTrace();
+        }
+        */
+        
         byte innerCondType = comparisonPlan.getLeaves().get(0).getType() ;
         if (innerCondType != DataType.BOOLEAN) {
             String msg = "Filter's condition must evaluate to boolean. Found: " + DataType.findTypeName(innerCondType);
@@ -1890,7 +1941,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         
         try {
             // Compute the schema
-            split.getSchema() ;
+            split.regenerateSchema() ;
         }
         catch (FrontendException ioe) {
             String msg = "Problem while reconciling output schema of LOSplit" ;
@@ -2040,7 +2091,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     // as a new leave of the plan
     private void insertAtomicCastForCOGroupInnerPlan(LogicalPlan innerPlan,
                                                      LOCogroup cg,
-                                                     byte toType) {
+                                                     byte toType) throws VisitorException {
         if(!DataType.isUsableType(toType)) {
             throw new AssertionError("Cannot cast to type " + DataType.findTypeName(toType));
         }
@@ -2063,6 +2114,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             err.initCause(ioe) ;
             throw err ;
         }
+        this.visit(cast);
     }
 
     /**
@@ -2508,4 +2560,155 @@ public class TypeCheckingVisitor extends LOVisitor {
         return new OperatorKey(scope, newId) ;
     }
 
+    private LoadFunc getLoadFunc(ExpressionOperator exOp) throws FrontendException {
+        Schema.FieldSchema fs = ((ExpressionOperator)exOp).getFieldSchema();
+        if(null == fs) {
+            return null;
+        }
+
+        Map<String, LogicalOperator> canonicalMap = fs.getCanonicalMap();
+        MultiMap<LogicalOperator, String> reverseCanonicalMap = fs.getReverseCanonicalMap();
+        MultiMap<String, LoadFunc> loadFuncMap = new MultiMap<String, LoadFunc>();
+        
+        if(canonicalMap.keySet().size() > 0) {
+            for(String parentCanonicalName: canonicalMap.keySet()) {
+                LoadFunc lf = getLoadFunc(exOp, parentCanonicalName);
+                if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+            }
+        } else {
+            for(LogicalOperator op: reverseCanonicalMap.keySet()) {
+                for(String parentCanonicalName: reverseCanonicalMap.get(op)) {
+                    LoadFunc lf = getLoadFunc(op, parentCanonicalName);
+                    if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                }
+            }
+        }
+        if(loadFuncMap.keySet().size() == 0) {
+            return null;
+        }
+        if(loadFuncMap.keySet().size() == 1) {
+            String lfString = loadFuncMap.keySet().iterator().next();
+            return (LoadFunc)(loadFuncMap.get(lfString).iterator().next());
+        }
+
+        throw new FrontendException("Found more than one load function to use: " + loadFuncMap.keySet());
+    }
+
+    private LoadFunc getLoadFunc(LogicalOperator op, String parentCanonicalName) throws FrontendException {
+        MultiMap<String, LoadFunc> loadFuncMap = new MultiMap<String, LoadFunc>();
+        if(op instanceof ExpressionOperator) {
+            if(op instanceof LOUserFunc) {
+                throw new FrontendException("Found a user defined function. Cannot determine the load function to use");
+            }
+            
+            Schema.FieldSchema fs = ((ExpressionOperator)op).getFieldSchema();
+            Map<String, LogicalOperator> canonicalMap = fs.getCanonicalMap();
+            MultiMap<LogicalOperator, String> reverseCanonicalMap = fs.getReverseCanonicalMap();
+            
+            if(canonicalMap.keySet().size() > 0) {
+                for(String canonicalName: canonicalMap.keySet()) {
+                    LoadFunc lf = getLoadFunc(fs, canonicalName);
+                    if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                }
+            } else {
+                for(LogicalOperator lop: reverseCanonicalMap.keySet()) {
+                    for(String canonicalName: reverseCanonicalMap.get(lop)) {
+                        LoadFunc lf = getLoadFunc(fs, canonicalName);
+                        if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                    }
+                }
+            }
+        } else {
+            if(op instanceof LOLoad) {
+                return ((LOLoad)op).getLoadFunc();
+            } else if (op instanceof LOStream) {
+                StreamingCommand command = ((LOStream)op).getStreamingCommand();
+                HandleSpec streamOutputSpec = command.getOutputSpec(); 
+                LoadFunc streamLoader = (LoadFunc)PigContext.instantiateFuncFromSpec(streamOutputSpec.getSpec());
+                return streamLoader;
+            } else if ((op instanceof LOFilter)
+                    || (op instanceof LODistinct)
+                    || (op instanceof LOSort)
+                    || (op instanceof LOSplit)
+                    || (op instanceof LOSplitOutput)
+                    || (op instanceof LOLimit)) {
+                LogicalPlan lp = op.getPlan();
+                LoadFunc lf = getLoadFunc(lp.getPredecessors(op).get(0), parentCanonicalName);
+                return lf;
+                //return getLoadFunc(lp.getPredecessors(op).get(0), parentCanonicalName);        
+            }
+            
+            Schema s = op.getSchema();
+            if(null != s) {
+                for(Schema.FieldSchema fs: s.getFields()) {
+                    if(null != parentCanonicalName && (parentCanonicalName.equals(fs.canonicalName))) {
+                        if(fs.getCanonicalMap().keySet().size() > 0) {
+                            for(String canonicalName: fs.getCanonicalMap().keySet()) {
+                                LoadFunc lf = getLoadFunc(fs, canonicalName);
+                                if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                            }
+                        } else {
+                            LoadFunc lf = getLoadFunc(fs, null);
+                            if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                        }
+                    } else if (null == parentCanonicalName) {
+                        LoadFunc lf = getLoadFunc(fs, null);
+                        if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                    }
+                }
+            } else {
+                LogicalPlan lp = op.getPlan();
+                for(LogicalOperator pred: lp.getPredecessors(op)) {
+                    LoadFunc lf = getLoadFunc(pred, parentCanonicalName);
+                    if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                }
+            }
+        }
+        if(loadFuncMap.keySet().size() == 0) {
+            return null;
+        }
+        if(loadFuncMap.keySet().size() == 1) {
+            String lfString = loadFuncMap.keySet().iterator().next();
+            return (LoadFunc)(loadFuncMap.get(lfString).iterator().next());
+        }
+    
+        throw new FrontendException("Found more than one load function to use: " + loadFuncMap.keySet());
+    }
+
+    private LoadFunc getLoadFunc(Schema.FieldSchema fs, String parentCanonicalName) throws FrontendException {
+        if(null == fs) {
+            return null;
+        }
+        Map<String, LogicalOperator> canonicalMap = fs.getCanonicalMap();
+        MultiMap<LogicalOperator, String> reverseCanonicalMap = fs.getReverseCanonicalMap();
+        MultiMap<String, LoadFunc> loadFuncMap = new MultiMap<String, LoadFunc>();
+
+        if(canonicalMap.keySet().size() > 0) {
+            for(String canonicalName: canonicalMap.keySet()) {
+                if((null == parentCanonicalName) || (parentCanonicalName.equals(canonicalName))) {
+                    LoadFunc lf = getLoadFunc(canonicalMap.get(canonicalName), parentCanonicalName);
+                    if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                }
+            }
+        } else {
+            for(LogicalOperator op: reverseCanonicalMap.keySet()) {
+                for(String canonicalName: reverseCanonicalMap.get(op)) {
+                    if((null == parentCanonicalName) || (parentCanonicalName.equals(canonicalName))) {
+                        LoadFunc lf = getLoadFunc(op, parentCanonicalName);
+                        if(null != lf) loadFuncMap.put(lf.getClass().getName(), lf);
+                    }
+                }
+            }
+        }
+        if(loadFuncMap.keySet().size() == 0) {
+            return null;
+        }
+        if(loadFuncMap.keySet().size() == 1) {
+            String lfString = loadFuncMap.keySet().iterator().next();
+            return (LoadFunc)(loadFuncMap.get(lfString).iterator().next());
+        }
+
+        throw new FrontendException("Found more than one load function to use: " + loadFuncMap.keySet());
+    }
+
 }
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidator.java b/test/org/apache/pig/test/TestTypeCheckingValidator.java
index 47356fb35..9e723fb5c 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidator.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidator.java
@@ -36,10 +36,21 @@ import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.builtin.PigStorage;
 import org.junit.Test;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.* ;
+import org.apache.pig.test.utils.LogicalPlanTester;
+import org.apache.pig.test.utils.TypeCheckingTestUtil;
 
 public class TestTypeCheckingValidator extends TestCase {
 
+    LogicalPlanTester planTester = new LogicalPlanTester() ;
     
+	private static final String simpleEchoStreamingCommand;
+        static {
+            if (System.getProperty("os.name").toUpperCase().startsWith("WINDOWS"))
+                simpleEchoStreamingCommand = "perl -ne 'print \\\"$_\\\"'";
+            else
+                simpleEchoStreamingCommand = "perl -ne 'print \"$_\"'";
+        }
+
     @Test
     public void testExpressionTypeChecking1() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
@@ -2774,33 +2785,2139 @@ public class TestTypeCheckingValidator extends TestCase {
 
     }
 
+    @Test
+    public void testLineage1() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1: int, field2: float, field3: chararray );") ;
+        LogicalPlan plan = planTester.buildPlan("b = foreach a generate field1 + 1.0 ;") ;
 
-    ////////////////////////// Helper //////////////////////////////////
-    private void checkForEachCasting(LOForEach foreach, int idx, boolean isCast, byte toType) {
-        LogicalPlan plan = foreach.getForEachPlans().get(idx) ;
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
 
-        if (isCast) {
-            List<LogicalOperator> leaveList = plan.getLeaves() ;
-            assertEquals(leaveList.size(), 1);
-            assertTrue(leaveList.get(0) instanceof LOCast);
-            assertTrue(leaveList.get(0).getType() == toType) ;
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
         }
-        else {
-            List<LogicalOperator> leaveList = plan.getLeaves() ;
-            assertEquals(leaveList.size(), 1);
-            assertTrue(leaveList.get(0) instanceof LOProject);
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc() == null);
+
+    }
+
+    @Test
+    public void testLineage1NoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a';") ;
+        LogicalPlan plan = planTester.buildPlan("b = foreach a generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testLineage2() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        LogicalPlan plan = planTester.buildPlan("b = foreach a generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testGroupLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = group a by field1 ;") ;
+        planTester.buildPlan("c = foreach b generate flatten(a) ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+    }
+
+    @Test
+    public void testGroupLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = group a by $0 ;") ;
+        planTester.buildPlan("c = foreach b generate flatten(a) ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $0 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+    }
+
+    @Test
+    public void testGroupLineage2() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = group a by field1 ;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate group + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
         }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+    }
+
+    @Test
+    public void testGroupLineage2NoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = group a by $0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate group + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
         
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+    }
+
+    @Test
+    public void testCogroupLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupMapLookupLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate group, field1#'key' + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOMapLookup map = (LOMapLookup)foreachPlan.getSuccessors(exOp).get(0);
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(map).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupLineageFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate group + 1, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
     }
 
-    private void printPlan(LogicalPlan lp, String title) {
+    @Test
+    public void testCogroupUDFLineageFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate flatten(DIFF(a, b)) as diff_a_b ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate diff_a_b + 1;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
         try {
-            System.err.println(title);
-            LOPrinter lv = new LOPrinter(System.err, lp);
-            lv.visit();
-            System.err.println();
-        } catch (Exception e) {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testCogroupLineage2NoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
         }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testUnionLineage() throws Throwable {
+        //here the type checker will insert a cast for the union, converting the column field2 into a float
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate field2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc() == null);
+
+    }
+
+    @Test
+    public void testUnionLineageFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate field1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testUnionLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+    }
+
+    @Test
+    public void testUnionLineageNoSchemaFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testUnionLineageDifferentSchema() throws Throwable {
+        //here the type checker will insert a cast for the union, converting the column field2 into a float
+        planTester.buildPlan("a = load 'a' using PigStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray, field7 );") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testUnionLineageDifferentSchemaFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray, field7 );") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testUnionLineageMixSchema() throws Throwable {
+        //here the type checker will insert a cast for the union, converting the column field2 into a float
+        planTester.buildPlan("a = load 'a' using PigStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testUnionLineageMixSchemaFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = union a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testFilterLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        LogicalPlan plan = planTester.buildPlan("b = filter a by field1 > 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOFilter filter = (LOFilter)plan.getLeaves().get(0);
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+
+        LogicalOperator exOp = filterPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = filterPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)filterPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testFilterLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        LogicalPlan plan = planTester.buildPlan("b = filter a by $0 > 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOFilter filter = (LOFilter)plan.getLeaves().get(0);
+        LogicalPlan filterPlan = filter.getComparisonPlan();
+
+        LogicalOperator exOp = filterPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = filterPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)filterPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testFilterLineage1() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = filter a by field2 > 1.0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testFilterLineage1NoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        planTester.buildPlan("b = filter a by $0 > 1.0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupFilterLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = filter d by field4 > 5;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupFilterLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = filter d by $2 > 5;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testSplitLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        LogicalPlan plan = planTester.buildPlan("split a into b if field1 > 1.0, c if field1 <= 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOSplitOutput splitOutputB = (LOSplitOutput)plan.getLeaves().get(0);
+        LogicalPlan bPlan = splitOutputB.getConditionPlan();
+
+        LogicalOperator exOp = bPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = bPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)bPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+        LOSplitOutput splitOutputC = (LOSplitOutput)plan.getLeaves().get(0);
+        LogicalPlan cPlan = splitOutputC.getConditionPlan();
+
+        exOp = cPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = cPlan.getRoots().get(1);
+
+        cast = (LOCast)cPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+    }
+
+    @Test
+    public void testSplitLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        LogicalPlan plan = planTester.buildPlan("split a into b if $0 > 1.0, c if $1 <= 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOSplitOutput splitOutputB = (LOSplitOutput)plan.getLeaves().get(0);
+        LogicalPlan bPlan = splitOutputB.getConditionPlan();
+
+        LogicalOperator exOp = bPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = bPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)bPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+        LOSplitOutput splitOutputC = (LOSplitOutput)plan.getLeaves().get(0);
+        LogicalPlan cPlan = splitOutputC.getConditionPlan();
+
+        exOp = cPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = cPlan.getRoots().get(1);
+
+        cast = (LOCast)cPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testSplitLineage1() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("split a into b if field2 > 1.0, c if field2 <= 1.0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testSplitLineage1NoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        planTester.buildPlan("split a into b if $0 > 1.0, c if $1 <= 1.0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupSplitLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("split d into e if field4 > 'm', f if field6 > 'm'  ;") ;
+        LogicalPlan plan = planTester.buildPlan("g = foreach e generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupSplitLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("split d into e if $1 > 'm', f if $1 > 'm'  ;") ;
+        LogicalPlan plan = planTester.buildPlan("g = foreach e generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testDistinctLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = distinct a;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testDistinctLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        planTester.buildPlan("b = distinct a;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupDistinctLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = distinct d ;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupDistinctLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = distinct d ;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testSortLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = order a by field1;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testSortLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        planTester.buildPlan("b = order a by $1;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupSortLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = order d by field4 desc;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupSortLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = order d by $2 desc;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCrossLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cross a, b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(1);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+    }
+
+    @Test
+    public void testCrossLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("c = cross a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+    }
+
+    @Test
+    public void testCrossLineageNoSchemaFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cross a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testCrossLineageMixSchema() throws Throwable {
+        //here the type checker will insert a cast for the union, converting the column field2 into a float
+        planTester.buildPlan("a = load 'a' using PigStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cross a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCrossLineageMixSchemaFail() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cross a , b ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+            fail("Exception expected") ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (!collector.hasError()) {
+            throw new AssertionError("Expect error") ;
+        }
+
+    }
+
+    @Test
+    public void testJoinLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = join a by field1, b by field4 ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(1);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+    }
+
+    @Test
+    public void testJoinLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("c = join a by $0, b by $0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+    }
+
+    @Test
+    public void testJoinLineageNoSchemaFail() throws Throwable {
+        //this test case should change when we decide on what flattening a tuple or bag
+        //with null schema results in a foreach flatten and hence a join
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = join a by $0, b by $0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $1 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+    }
+
+    @Test
+    public void testJoinLineageMixSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using PigStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = join a by field1, b by $0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testJoinLineageMixSchemaFail() throws Throwable {
+        //this test case should change when we decide on what flattening a tuple or bag
+        //with null schema results in a foreach flatten and hence a join
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = join a by field1, b by $0 ;") ;
+        LogicalPlan plan = planTester.buildPlan("d = foreach c generate $3 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+
+        try {
+            typeValidator.validate(plan, collector) ;
+        }
+        catch (PlanValidationException pve) {
+            // good
+        }
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+    }
+
+    @Test
+    public void testLimitLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = limit a 100;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate field1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testLimitLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' ;") ;
+        planTester.buildPlan("b = limit a 100;") ;
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupLimitLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = limit d 100;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupLimitLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = limit d 100;") ;
+        LogicalPlan plan = planTester.buildPlan("f = foreach e generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupTopKLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() as (field4, field5, field6: chararray );") ;
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = order d by field1 desc;") ;
+        planTester.buildPlan("f = limit e 100;") ;
+        LogicalPlan plan = planTester.buildPlan("g = foreach f generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupTopKLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = load 'a' using PigStorage() ;") ;
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        planTester.buildPlan("e = order d by $2 desc;") ;
+        planTester.buildPlan("f = limit e 100;") ;
+        LogicalPlan plan = planTester.buildPlan("g = foreach f generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testStreamingLineage1() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1: int, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = stream a through `" + simpleEchoStreamingCommand + "`;");
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate $1 + 1.0 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testStreamingLineage2() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1: int, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = stream a through `" + simpleEchoStreamingCommand + "` as (f1, f2: float);");
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate f1 + 1.0, f2 + 4 ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(1);
+
+        exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        assertTrue(foreachPlan.getSuccessors(exOp).get(0) instanceof LOAdd);
+    }
+
+    @Test
+    public void testCogroupStreamingLineage() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() as (field1, field2: float, field3: chararray );") ;
+        planTester.buildPlan("b = stream a through `" + simpleEchoStreamingCommand + "` as (field4, field5, field6: chararray);");
+        planTester.buildPlan("c = cogroup a by field1, b by field4 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate group, field1 + 1, field4 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    public void testCogroupStreamingLineageNoSchema() throws Throwable {
+        planTester.buildPlan("a = load 'a' using BinStorage() ;") ;
+        planTester.buildPlan("b = stream a through `" + simpleEchoStreamingCommand + "` ;");
+        planTester.buildPlan("c = cogroup a by $0, b by $0 ;") ;
+        planTester.buildPlan("d = foreach c generate group, flatten(a), flatten(b)  ;") ;
+        LogicalPlan plan = planTester.buildPlan("e = foreach d generate group, $1 + 1, $2 + 2.0  ;") ;
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(1);
+
+        LogicalOperator exOp = foreachPlan.getRoots().get(0);
+
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+
+        LOCast cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.BinStorage"));
+
+        foreachPlan = foreach.getForEachPlans().get(2);
+        exOp = foreachPlan.getRoots().get(0);
+        if(! (exOp instanceof LOProject)) exOp = foreachPlan.getRoots().get(1);
+        cast = (LOCast)foreachPlan.getSuccessors(exOp).get(0);
+        assertTrue(cast.getLoadFunc().toString().startsWith("org.apache.pig.builtin.PigStorage"));
+
+    }
+
+    @Test
+    ////////////////////////// Helper //////////////////////////////////
+    private void checkForEachCasting(LOForEach foreach, int idx, boolean isCast, byte toType) {
+        LogicalPlan plan = foreach.getForEachPlans().get(idx) ;
+
+        if (isCast) {
+            List<LogicalOperator> leaveList = plan.getLeaves() ;
+            assertEquals(leaveList.size(), 1);
+            assertTrue(leaveList.get(0) instanceof LOCast);
+            assertTrue(leaveList.get(0).getType() == toType) ;
+        }
+        else {
+            List<LogicalOperator> leaveList = plan.getLeaves() ;
+            assertEquals(leaveList.size(), 1);
+            assertTrue(leaveList.get(0) instanceof LOProject);
+        }
+        
     }
 
 }
diff --git a/test/org/apache/pig/test/utils/LogicalPlanTester.java b/test/org/apache/pig/test/utils/LogicalPlanTester.java
index 3f2a05d7a..07f5db8ee 100644
--- a/test/org/apache/pig/test/utils/LogicalPlanTester.java
+++ b/test/org/apache/pig/test/utils/LogicalPlanTester.java
@@ -176,6 +176,16 @@ public class LogicalPlanTester {
 
     }
 
+    public void printPlan(LogicalPlan lp, String title) {
+        try {
+            System.err.println(title);
+            LOPrinter lv = new LOPrinter(System.err, lp);
+            lv.visit();
+            System.err.println();
+        } catch (Exception e) {
+        }
+    }
+
     ////////////// Helpers ////////////////
 
     // The actual plan builder
diff --git a/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java b/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java
index 784f942cc..fb72ce588 100644
--- a/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java
+++ b/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java
@@ -95,4 +95,16 @@ public class TypeCheckingTestUtil {
        }
     }
 
+    public static String getCurrentMethodName() {
+       StackTraceElement e[] = Thread.currentThread().getStackTrace() ;
+       boolean doNext = false;
+       for (StackTraceElement s : e) {
+           if (doNext) {
+              return s.getMethodName();
+           }
+           doNext = s.getMethodName().equals("getCurrentMethodName");
+       }
+       return null;
+    }
+
 }
