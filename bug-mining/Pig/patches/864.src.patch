diff --git a/CHANGES.txt b/CHANGES.txt
index 0c3eeaa35..9677f4a23 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -54,6 +54,8 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-2427: getSchemaFromString throws away the name of the tuple that is in a bag (jcoveney via dvryaboy)
+
 PIG-2425: Aggregate Warning does not work as expected on Embedding Pig in Java 0.9.1 (prkommireddi via thejas)
 
 PIG-2384: Generic Invokers should use PigContext to resolve classes (dvryaboy)
diff --git a/src/org/apache/pig/parser/AliasMasker.g b/src/org/apache/pig/parser/AliasMasker.g
index 99e464da5..470404d00 100644
--- a/src/org/apache/pig/parser/AliasMasker.g
+++ b/src/org/apache/pig/parser/AliasMasker.g
@@ -209,7 +209,7 @@ tuple_type
 ;
 
 bag_type 
-    : ^( BAG_TYPE tuple_type? )  
+    : ^( BAG_TYPE IDENTIFIER? tuple_type? )
 ;
 
 map_type : ^( MAP_TYPE type? )
diff --git a/src/org/apache/pig/parser/AstValidator.g b/src/org/apache/pig/parser/AstValidator.g
index 8fedcc613..67f674806 100644
--- a/src/org/apache/pig/parser/AstValidator.g
+++ b/src/org/apache/pig/parser/AstValidator.g
@@ -209,7 +209,7 @@ simple_type : BOOLEAN | INT | LONG | FLOAT | DOUBLE | CHARARRAY | BYTEARRAY
 tuple_type : ^( TUPLE_TYPE field_def_list? )
 ;
 
-bag_type : ^( BAG_TYPE tuple_type? )
+bag_type : ^( BAG_TYPE IDENTIFIER? tuple_type? )
 ;
 
 map_type : ^( MAP_TYPE type? )
diff --git a/src/org/apache/pig/parser/LogicalPlanGenerator.g b/src/org/apache/pig/parser/LogicalPlanGenerator.g
index eec7f4c3c..3a0c56ed6 100644
--- a/src/org/apache/pig/parser/LogicalPlanGenerator.g
+++ b/src/org/apache/pig/parser/LogicalPlanGenerator.g
@@ -375,14 +375,14 @@ tuple_type returns[LogicalSchema logicalSchema]
 ;
 
 bag_type returns[LogicalSchema logicalSchema]
- : ^( BAG_TYPE tuple_type? )
+ : ^( BAG_TYPE IDENTIFIER? tuple_type? )
    {
        if ($tuple_type.logicalSchema!=null && $tuple_type.logicalSchema.size()==1 && $tuple_type.logicalSchema.getField(0).type==DataType.TUPLE) {
            $logicalSchema = $tuple_type.logicalSchema;
        }
        else {
            LogicalSchema s = new LogicalSchema();
-           s.addField(new LogicalFieldSchema(null, $tuple_type.logicalSchema, DataType.TUPLE));
+           s.addField(new LogicalFieldSchema($IDENTIFIER.text, $tuple_type.logicalSchema, DataType.TUPLE));
            $logicalSchema = s;
        }
    }
diff --git a/src/org/apache/pig/parser/QueryParser.g b/src/org/apache/pig/parser/QueryParser.g
index 09a3d7bd3..72bfb5980 100644
--- a/src/org/apache/pig/parser/QueryParser.g
+++ b/src/org/apache/pig/parser/QueryParser.g
@@ -313,7 +313,7 @@ tuple_type : TUPLE? LEFT_PAREN field_def_list? RIGHT_PAREN
 ;
 
 bag_type : BAG? LEFT_CURLY ( ( identifier COLON )? tuple_type )? RIGHT_CURLY
-        -> ^( BAG_TYPE tuple_type? )
+        -> ^( BAG_TYPE identifier? tuple_type? )
 ;
 
 map_type : MAP? LEFT_BRACKET type? RIGHT_BRACKET
diff --git a/test/org/apache/pig/test/TestSchema.java b/test/org/apache/pig/test/TestSchema.java
index bc61a2e24..f9ba6aa3b 100644
--- a/test/org/apache/pig/test/TestSchema.java
+++ b/test/org/apache/pig/test/TestSchema.java
@@ -694,7 +694,7 @@ public class TestSchema {
         LogicalSchema ls1 = Utils.parseSchema("a:{t:(a0:int, a1:int)}");
         LogicalSchema ls2 = Utils.parseSchema("b:{t:(b0:int, b1:int)}");
         LogicalSchema ls3 = LogicalSchema.merge(ls1, ls2, MergeMode.LoadForEach);
-        Assert.assertTrue(org.apache.pig.newplan.logical.Util.translateSchema(ls3).toString().equals("{a: {(a0: int,a1: int)}}"));
+        Assert.assertTrue(org.apache.pig.newplan.logical.Util.translateSchema(ls3).toString().equals("{a: {t: (a0: int,a1: int)}}"));
     }
     
     @Test
@@ -865,4 +865,30 @@ public class TestSchema {
         Schema s2 = Schema.getPigSchema(new ResourceSchema(s1));
         Assert.assertTrue(s1.equals(s2));
 }
+
+    @Test
+    public void testGetStringFromSchema() throws ParserException {
+        String[] schemaStrings = {
+            "a:int",
+            "a:long",
+            "a:chararray",
+            "a:double",
+            "a:float",
+            "a:bytearray",
+            "b:bag{tuple(x:int,y:int,z:int)}",
+            "b:bag{t:tuple(x:int,y:int,z:int)}",
+            "a:int,b:chararray,c:Map[int]",
+            "a:double,b:float,t:tuple(x:int,y:double,z:bytearray)",
+            "a:double,b:float,t:tuple(x:int,b:bag{t:tuple(a:int,b:float,c:double,x:tuple(z:bag{r:tuple(z:bytearray)}))},z:bytearray)",
+            "a,b,t:tuple(x,b:bag{t:tuple(a,b,c,x:tuple(z:bag{r:tuple(z)}))},z)",
+            "a:bag{t:tuple(a:bag{t:tuple(a:bag{t:tuple(a:bag{t:tuple(a:bag{t:tuple(a:bag{t:tuple(a:int,b:float)})})})})})}",
+            "a:bag{}"
+        };
+        for (String schemaString : schemaStrings) {
+            Schema s1 = Utils.getSchemaFromString(schemaString);
+            String s=s1.toString();
+            Schema s2 = Utils.getSchemaFromString(s.substring(1,s.length()-1)); //have to cut out the brackets that surround it
+            Assert.assertTrue(Schema.equals(s1,s2,false,true));
+        }
+    }
 }
