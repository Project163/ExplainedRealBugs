diff --git a/CHANGES.txt b/CHANGES.txt
index 0ab34946c..db87fac8d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -239,3 +239,5 @@ Trunk (unreleased changes)
     PIG-447: improved error messages (pradeepk via olgan)
 
     PIG-448: explain broken after load with types (pradeepk via olgan)
+
+    PIG-380: invalid schema for databag constant (sms via olgan)
diff --git a/src/org/apache/pig/data/DataType.java b/src/org/apache/pig/data/DataType.java
index 36634c910..9fc369a0c 100644
--- a/src/org/apache/pig/data/DataType.java
+++ b/src/org/apache/pig/data/DataType.java
@@ -23,6 +23,7 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.TreeMap;
+import java.util.ArrayList;
 
 import org.apache.hadoop.io.BooleanWritable;
 import org.apache.hadoop.io.BytesWritable;
@@ -32,6 +33,9 @@ import org.apache.hadoop.io.LongWritable;
 import org.apache.hadoop.io.Text;
 import org.apache.hadoop.io.WritableComparable;
 import org.apache.pig.backend.executionengine.ExecException;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 
 /**
  * A class of static final values used to encode data type and a number of
@@ -706,4 +710,94 @@ public class DataType {
         return true;
     }
         
+    /***
+     * Determine the field schema of an object
+     * @param o the object whose field schema is to be determined
+     * @return the field schema corresponding to the object
+     * @throws ExecException,FrontendException,SchemaMergeException
+     */
+    public static Schema.FieldSchema determineFieldSchema(Object o) 
+        throws ExecException, FrontendException, SchemaMergeException {
+        byte dt = findType(o);
+
+        switch (dt) {
+        case NULL:
+            return new Schema.FieldSchema(null, NULL);
+
+        case BOOLEAN:
+            return new Schema.FieldSchema(null, BOOLEAN);
+
+        case INTEGER:
+            return new Schema.FieldSchema(null, INTEGER);
+
+        case LONG:
+            return new Schema.FieldSchema(null, LONG);
+
+        case FLOAT:
+            return new Schema.FieldSchema(null, FLOAT);
+
+        case DOUBLE:
+            return new Schema.FieldSchema(null, DOUBLE);
+
+        case BYTEARRAY:
+            return new Schema.FieldSchema(null, BYTEARRAY);
+
+        case CHARARRAY:
+            return new Schema.FieldSchema(null, CHARARRAY);
+
+        case MAP: 
+            return new Schema.FieldSchema(null, MAP);
+        
+        case TUPLE: {
+	            Tuple t = (Tuple)o;
+                long tupleSize = t.size();
+                Schema schema = null;
+
+                if(tupleSize != 0) {
+	                schema = new Schema();
+	                for(int i = 0; i < t.size(); ++i) {
+	                    schema.add(determineFieldSchema(t.get(i))); 
+	                }
+                }
+	            return new Schema.FieldSchema(null, schema, TUPLE);
+            }
+        
+        case BAG: {
+                DataBag b = (DataBag)o;
+                long bagSize = b.size();
+                Schema schema = null;
+
+                if(bagSize != 0) {
+                    Iterator<Tuple> it = b.iterator();
+                    ArrayList<Schema> schemas = new ArrayList<Schema>();
+                    while(it.hasNext()) {
+                        schemas.add(determineFieldSchema((Object)it.next()).schema);
+                    }
+                    schema = schemas.get(0);
+                    if(null == schema) {
+                        Schema.FieldSchema tupleFs = new Schema.FieldSchema(null, null, TUPLE);
+                        Schema bagSchema = new Schema(tupleFs);
+                        return new Schema.FieldSchema(null, null, BAG);
+                    }
+                    int schemaSize = schema.size();
+
+                    for(int i = 1; i < schemas.size(); ++i) {
+                        Schema currSchema = schemas.get(i);
+                        if((null == currSchema) || (currSchema.size() != schemaSize)) {
+                            Schema.FieldSchema tupleFs = new Schema.FieldSchema(null, null, TUPLE);
+                            Schema bagSchema = new Schema(tupleFs);
+                            return new Schema.FieldSchema(null, bagSchema, BAG);
+                        }
+                        schema = Schema.mergeSchema(schema, currSchema, false, false, false); 
+                    }
+                }
+                Schema.FieldSchema tupleFs = new Schema.FieldSchema(null, schema, TUPLE);
+                Schema bagSchema = new Schema(tupleFs);
+                return new Schema.FieldSchema(null, bagSchema, BAG);
+            }
+        default: {
+                throw new ExecException("Cannot determine field schema for " + o);
+            }
+        }
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOConst.java b/src/org/apache/pig/impl/logicalLayer/LOConst.java
index a9d9d5edb..14d0e732c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOConst.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOConst.java
@@ -60,11 +60,17 @@ public class LOConst extends ExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
-            if(DataType.isAtomic(mType)) {
-                mFieldSchema = new Schema.FieldSchema(null, mType);
+            try {
+                mFieldSchema = DataType.determineFieldSchema(mValue);
                 mIsFieldSchemaComputed = true;
+            } catch (Exception e) {
+                mFieldSchema = null;
+                mIsFieldSchemaComputed = false;
+                System.err.println("LOConst: " + e.getMessage());
+                e.printStackTrace();
+                throw new FrontendException(e.getMessage());
             }
         }
         return mFieldSchema;
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 5c215034f..3023e1e1c 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -2807,9 +2807,9 @@ Schema TupleSchema() :
 		fs = FieldSchema() {log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);} 
 		( "," fs = FieldSchema() {log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);})* 
 	)
-|		{}
+|		{} {list = null;}
 	)
-	{log.debug("Printing Aliases in TupleSchema"); list.printAliases();log.trace("Exiting TupleSchema");return list;}
+	{log.debug("Printing list in TupleSchema" + list); log.trace("Exiting TupleSchema");return list;}
 }
 
 
@@ -2927,9 +2927,9 @@ Schema TypeTupleSchema() :
 		fs = TypeFieldSchema() {log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);} 
 		( "," fs = TypeFieldSchema() {log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);})* 
 	)
-|		{}
+|		{} {list = null;}
 	)
-	{log.debug("Printing Aliases in TypeTupleSchema"); list.printAliases();log.trace("Exiting TypeTupleSchema");return list;}
+	{log.debug("Printing list in TypeTupleSchema: " + list); log.trace("Exiting TypeTupleSchema");return list;}
 }
 
 // These the simple non-terminals that are shared across many
@@ -3050,7 +3050,6 @@ Tuple Tuple() :
                 obj = Datum() {log.debug("Adding " + obj + " to the list: " + objList); objList.add(obj);} 
 		        ( LOOKAHEAD(2) "," obj = Datum() {log.debug("Adding " + obj + " to the list: " + objList); objList.add(obj);})* 
             )
-            |		{}
 	)
 	)
 	{
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 528ae58b7..1326ea55e 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -944,6 +944,13 @@ public class TypeCheckingVisitor extends LOVisitor {
                 insertRightCastForBinaryOp(binOp, DataType.LONG) ;
             }
         }
+        else if ( (rhsType == DataType.LONG) &&
+                  ( (lhsType == DataType.INTEGER) || (lhsType == DataType.LONG) )
+                ) {
+            if (lhsType == DataType.INTEGER) {
+                insertLeftCastForBinaryOp(binOp, DataType.LONG) ;
+            }
+        }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   ( (rhsType == DataType.INTEGER) || (rhsType == DataType.LONG) )
                 ) {
@@ -1206,7 +1213,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
 
         try {
-            func.regenerateSchema();
+            func.regenerateFieldSchema();
         } catch (FrontendException fee) {
             String msg = "Could not set LOUserFunc field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -1288,6 +1295,16 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
+        try {
+            binCond.regenerateFieldSchema();
+        } catch (FrontendException fee) {
+            String msg = "Could not set LOBinCond field schema";
+            msgCollector.collect(msg, MessageType.Error);
+            VisitorException vse = new VisitorException(msg) ;
+            vse.initCause(fee) ;
+            throw new VisitorException(msg) ;
+        }
+
     }
 
     private void insertLeftCastForBinCond(LOBinCond binCond, byte toType) {
@@ -1304,7 +1321,6 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             currentPlan.connect(binCond.getLhsOp(), cast) ;
             currentPlan.connect(cast, binCond) ;
-            binCond.setLhsOp(cast);
         } 
         catch (PlanException ioe) {
             AssertionError err =  new AssertionError("Explicit casting insertion") ;
@@ -1329,7 +1345,6 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             currentPlan.connect(binCond.getRhsOp(), cast) ;
             currentPlan.connect(cast, binCond) ;
-            binCond.setRhsOp(cast);
         } 
         catch (PlanException ioe) {
             AssertionError err =  new AssertionError("Explicit casting insertion") ;
diff --git a/test/org/apache/pig/test/TestGrunt.java b/test/org/apache/pig/test/TestGrunt.java
index b4b700e8a..89508ff4f 100644
--- a/test/org/apache/pig/test/TestGrunt.java
+++ b/test/org/apache/pig/test/TestGrunt.java
@@ -107,7 +107,7 @@ public class TestGrunt extends TestCase {
         PigServer server = new PigServer("MAPREDUCE");
         PigContext context = server.getPigContext();
         
-        String strCmd = "a = load 'input1'; b = foreach a generate {(1, '1', 0.4f),(2, '2', 0.45)} as b: bag{t(i: int, c:chararray, f: float)};\n";
+        String strCmd = "a = load 'input1'; b = foreach a generate {(1, '1', 0.4f),(2, '2', 0.45)} as b: bag{t(i: int, c:chararray, d: double)};\n";
         
         ByteArrayInputStream cmd = new ByteArrayInputStream(strCmd.getBytes());
         InputStreamReader reader = new InputStreamReader(cmd);
@@ -137,7 +137,7 @@ public class TestGrunt extends TestCase {
         PigServer server = new PigServer("MAPREDUCE");
         PigContext context = server.getPigContext();
         
-        String strCmd = "a = load 'input1'; b = foreach a {generate {(1, '1', 0.4f),(2, '2', 0.45)} as b: bag{t(i: int, c:chararray, f: float)};};\n";
+        String strCmd = "a = load 'input1'; b = foreach a {generate {(1, '1', 0.4f),(2, '2', 0.45)} as b: bag{t(i: int, c:chararray, d: double)};};\n";
         
         ByteArrayInputStream cmd = new ByteArrayInputStream(strCmd.getBytes());
         InputStreamReader reader = new InputStreamReader(cmd);
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index a625ef875..577bba6fc 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -171,7 +171,7 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
     public void testQuery102() {
         // test basic store
         buildPlan("a = load 'a';");
-        printPlan(buildPlan("store a into 'out';"));
+        buildPlan("store a into 'out';");
     }
 
     @Test
@@ -864,13 +864,13 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
     @Test
     public void testQuery68() {
         buildPlan(" a = load 'input1';");
-        buildPlan(" b = foreach a generate 10, {(16, 4.0e-2, 'hello'), (0.5f, 'another tuple', 12l, {()})};");
+        buildPlan(" b = foreach a generate 10, {(16, 4.0e-2, 'hello'), (0.5f, 12l, 'another tuple')};");
     }
 
     @Test
     public void testQuery69() {
         buildPlan(" a = load 'input1';");
-        buildPlan(" b = foreach a generate {(16, 4.0e-2, 'hello'), (0.5f, 'another tuple', 12L, (1), ())};");
+        buildPlan(" b = foreach a generate {(16, 4.0e-2, 'hello'), (0.5f, 'another tuple', 12L, (1))};");
     }
 
     @Test
@@ -1191,7 +1191,7 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         //the schema of group is unchanged
         lp = buildPlan("c = foreach b generate flatten(group) as (), COUNT(a) as mycount;");
         foreach = (LOForEach) lp.getLeaves().get(0);
-        assertTrue(foreach.getSchema().equals(getSchemaFromString("name: chararray, age: int, mycount: long")));
+        assertTrue(foreach.getSchema().equals(getSchemaFromString("group::name: chararray, group::age: int, mycount: long")));
 
         //the first element in group, i.e., name is renamed as myname 
         lp = buildPlan("c = foreach b generate flatten(group) as myname, COUNT(a) as mycount;");
@@ -1407,6 +1407,116 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         assertTrue(null == comparisonPlan.getPredecessors(filterProject));
     }
 
+    @Test
+    public void testQuery97() throws FrontendException, ParseException {
+        LogicalPlan lp;
+        LOForEach foreach;
+
+        buildPlan("a = load 'one' as (name, age, gpa);");
+
+        lp = buildPlan("b = foreach a generate 1;");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("x: int"), false, true));
+
+        lp = buildPlan("b = foreach a generate 1L;");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("x: long"), false, true));
+
+        lp = buildPlan("b = foreach a generate 1.0;");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("x: double"), false, true));
+
+        lp = buildPlan("b = foreach a generate 1.0f;");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("x: float"), false, true));
+
+        lp = buildPlan("b = foreach a generate 'hello';");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("x: chararray"), false, true));
+    }
+
+    @Test
+    public void testQuery98() throws FrontendException, ParseException {
+        LogicalPlan lp;
+        LOForEach foreach;
+
+        buildPlan("a = load 'one' as (name, age, gpa);");
+
+        lp = buildPlan("b = foreach a generate (1);");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: int)"), false, true));
+
+        lp = buildPlan("b = foreach a generate (1L);");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: long)"), false, true));
+
+        lp = buildPlan("b = foreach a generate (1.0);");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: double)"), false, true));
+
+        lp = buildPlan("b = foreach a generate (1.0f);");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: float)"), false, true));
+
+        lp = buildPlan("b = foreach a generate ('hello');");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: chararray)"), false, true));
+
+        lp = buildPlan("b = foreach a generate ('hello', 1, 1L, 1.0f, 1.0);");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: chararray, y: int, z: long, a: float, b: double)"), false, true));
+
+        lp = buildPlan("b = foreach a generate ('hello', {(1), (1.0)});");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("t:(x: chararray, ib:{it:(d: double)})"), false, true));
+
+    }
+
+    @Test
+    public void testQuery99() throws FrontendException, ParseException {
+        LogicalPlan lp;
+        LOForEach foreach;
+
+        buildPlan("a = load 'one' as (name, age, gpa);");
+
+        lp = buildPlan("b = foreach a generate {(1, 'hello'), (2, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: int, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1, 'hello'), (1L, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: long, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1, 'hello'), (1.0f, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: float, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1, 'hello'), (1.0, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: double, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1L, 'hello'), (1.0f, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: float, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1L, 'hello'), (1.0, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: double, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1.0f, 'hello'), (1.0, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: double, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1.0, 'hello'), (1.0f, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:(x: double, y: chararray)}"), false, true));
+
+        lp = buildPlan("b = foreach a generate {(1.0, 'hello', 3.14), (1.0f, 'world')};");
+        foreach = (LOForEach) lp.getLeaves().get(0);
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("b:{t:()}"), false, true));
+
+    }
+
     private Schema getSchemaFromString(String schemaString) throws ParseException {
         return getSchemaFromString(schemaString, DataType.BYTEARRAY);
     }
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidator.java b/test/org/apache/pig/test/TestTypeCheckingValidator.java
index a0e9d2ade..47356fb35 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidator.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidator.java
@@ -136,7 +136,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
         constant1.setType(DataType.INTEGER) ;
-        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20D) ;
+        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), new DataByteArray()) ;
         constant2.setType(DataType.BYTEARRAY) ;
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123L) ;
         constant3.setType(DataType.LONG) ;        
@@ -193,7 +193,7 @@ public class TestTypeCheckingValidator extends TestCase {
     public void testExpressionTypeChecking3() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
-        constant1.setType(DataType.BYTEARRAY) ;
+        constant1.setType(DataType.INTEGER) ;
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123) ;
@@ -212,7 +212,7 @@ public class TestTypeCheckingValidator extends TestCase {
         plan.connect(constant2, mod1) ;
         plan.connect(mod1, equal1) ;
         plan.connect(constant3, equal1) ;
-                     
+        
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
         typeValidator.validate(plan, collector) ;        
@@ -329,9 +329,9 @@ public class TestTypeCheckingValidator extends TestCase {
     @Test
     public void testExpressionTypeChecking5() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
-        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
+        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10F) ;
         constant1.setType(DataType.FLOAT) ;
-        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20) ;
+        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123F) ;
         constant3.setType(DataType.FLOAT) ;
@@ -354,7 +354,7 @@ public class TestTypeCheckingValidator extends TestCase {
         plan.connect(constant3, bincond1) ;
         plan.connect(constant4, bincond1) ;
         
-                          
+         
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
         typeValidator.validate(plan, collector) ;        
@@ -380,9 +380,9 @@ public class TestTypeCheckingValidator extends TestCase {
     @Test
     public void testExpressionTypeChecking6() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
-        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
+        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), "10") ;
         constant1.setType(DataType.CHARARRAY) ;
-        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20) ;
+        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
         
         LOAdd add1 = new LOAdd(plan, genNewOperatorKey(), constant1, constant2) ;
@@ -741,7 +741,7 @@ public class TestTypeCheckingValidator extends TestCase {
     @Test
     public void testRegexTypeChecking1() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
-        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
+        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), "10") ;
         constant1.setType(DataType.CHARARRAY) ;
 
         LORegexp regex = new LORegexp(plan, genNewOperatorKey(), constant1,
@@ -768,7 +768,7 @@ public class TestTypeCheckingValidator extends TestCase {
     @Test
     public void testRegexTypeChecking2() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
-        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
+        LOConst constant1 = new LOConst(plan, genNewOperatorKey(), new DataByteArray()) ;
         constant1.setType(DataType.BYTEARRAY) ;
 
         LORegexp regex = new LORegexp(plan, genNewOperatorKey(), constant1,
@@ -1514,7 +1514,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LogicalPlan innerPlan2 = new LogicalPlan() ;
         LOProject project21 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 0) ;
         project21.setSentinel(true);
-        LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
+        LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26L) ;
         const21.setType(DataType.LONG);
         LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey(), project21, const21) ;
 
@@ -1612,8 +1612,8 @@ public class TestTypeCheckingValidator extends TestCase {
         LogicalPlan innerPlan2 = new LogicalPlan() ;
         LOProject project21 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 0) ;
         project21.setSentinel(true);
-        LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
-        const21.setType(DataType.BYTEARRAY);
+        LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), "26") ;
+        const21.setType(DataType.CHARARRAY);
         LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey(), project21, const21) ;
 
         innerPlan2.add(project21) ;
@@ -2448,7 +2448,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LogicalPlan innerPlan1 = new LogicalPlan() ;
         LOProject project11 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 0) ;
         project11.setSentinel(true);
-        LOConst const11 = new LOConst(innerPlan1, genNewOperatorKey(), 26F) ;
+        LOConst const11 = new LOConst(innerPlan1, genNewOperatorKey(), "26F") ;
         const11.setType(DataType.CHARARRAY);
         LOSubtract subtract11 = new LOSubtract(innerPlan1,
                                                 genNewOperatorKey(),
@@ -2793,4 +2793,14 @@ public class TestTypeCheckingValidator extends TestCase {
         
     }
 
+    private void printPlan(LogicalPlan lp, String title) {
+        try {
+            System.err.println(title);
+            LOPrinter lv = new LOPrinter(System.err, lp);
+            lv.visit();
+            System.err.println();
+        } catch (Exception e) {
+        }
+    }
+
 }
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java b/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java
index f1292f94f..fcb9c6e5b 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java
@@ -523,7 +523,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOProject project2 = new LOProject(innerPlan, genNewOperatorKey(), load1, 1) ;
         project2.setSentinel(true);
         LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey(), project1, project2) ;
-        LOConst const1  = new LOConst(innerPlan, genNewOperatorKey(), 10) ;
+        LOConst const1  = new LOConst(innerPlan, genNewOperatorKey(), "10") ;
         const1.setType(DataType.CHARARRAY);
 
         LOGreaterThan gt1 = new LOGreaterThan(innerPlan,
