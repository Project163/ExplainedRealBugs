diff --git a/CHANGES.txt b/CHANGES.txt
index 8e2ac836b..e1c4703b6 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,6 +26,8 @@ IMPROVEMENTS
  
 BUG FIXES
 
+PIG-4327: Schema of map with value that has an alias can't be parsed again (mprim via daijy)
+
 PIG-4330: Regression test for PIG-3584 - AvroStorage does not correctly translate arrays of strings (brocknoland via daijy)
 
 PIG-3615: Update the way that JsonLoader/JsonStorage deal with BigDecimal (tyro89 via daijy)
diff --git a/src/org/apache/pig/parser/AliasMasker.g b/src/org/apache/pig/parser/AliasMasker.g
index 620721620..263ca0790 100644
--- a/src/org/apache/pig/parser/AliasMasker.g
+++ b/src/org/apache/pig/parser/AliasMasker.g
@@ -227,7 +227,7 @@ bag_type
     : ^( BAG_TYPE IDENTIFIER? tuple_type? )
 ;
 
-map_type : ^( MAP_TYPE type? )
+map_type : ^( MAP_TYPE IDENTIFIER? type? )
 ;
 
 func_clause
diff --git a/src/org/apache/pig/parser/AstPrinter.g b/src/org/apache/pig/parser/AstPrinter.g
index 0eeb75b36..792f6ec66 100644
--- a/src/org/apache/pig/parser/AstPrinter.g
+++ b/src/org/apache/pig/parser/AstPrinter.g
@@ -222,7 +222,7 @@ bag_type
     : ^( BAG_TYPE { sb.append("bag{"); } ( { sb.append("T:"); } IDENTIFIER? tuple_type )? ) { sb.append("}"); }
 ;
 
-map_type : ^( MAP_TYPE { sb.append("map["); } type? ) { sb.append("]"); }
+map_type : ^( MAP_TYPE { sb.append("map["); } IDENTIFIER? type? ) { sb.append("]"); }
 ;
 
 func_clause
diff --git a/src/org/apache/pig/parser/AstValidator.g b/src/org/apache/pig/parser/AstValidator.g
index ce2c180db..666187148 100644
--- a/src/org/apache/pig/parser/AstValidator.g
+++ b/src/org/apache/pig/parser/AstValidator.g
@@ -276,7 +276,7 @@ tuple_type : ^( TUPLE_TYPE field_def_list? )
 bag_type : ^( BAG_TYPE IDENTIFIER? tuple_type? )
 ;
 
-map_type : ^( MAP_TYPE type? )
+map_type : ^( MAP_TYPE IDENTIFIER? type? )
 ;
 
 func_clause : ^( FUNC_REF func_name )
diff --git a/src/org/apache/pig/parser/LogicalPlanGenerator.g b/src/org/apache/pig/parser/LogicalPlanGenerator.g
index 0e7079db4..71b95ae04 100644
--- a/src/org/apache/pig/parser/LogicalPlanGenerator.g
+++ b/src/org/apache/pig/parser/LogicalPlanGenerator.g
@@ -437,12 +437,12 @@ bag_type returns[LogicalSchema logicalSchema]
 ;
 
 map_type returns[LogicalSchema logicalSchema]
- : ^( MAP_TYPE type? )
+ : ^( MAP_TYPE IDENTIFIER? type? )
    {
        LogicalSchema s = null;
        if( $type.datatype != null ) {
            s = new LogicalSchema();
-           s.addField( new LogicalFieldSchema( null, $type.logicalSchema, $type.datatype ) );
+           s.addField( new LogicalFieldSchema( $IDENTIFIER.text, $type.logicalSchema, $type.datatype ) );
        }
        $logicalSchema = s;
    }
diff --git a/src/org/apache/pig/parser/QueryParser.g b/src/org/apache/pig/parser/QueryParser.g
index c83f9966c..bb0af5dbd 100644
--- a/src/org/apache/pig/parser/QueryParser.g
+++ b/src/org/apache/pig/parser/QueryParser.g
@@ -329,7 +329,7 @@ explicit_bag_type : BAG! implicit_bag_type
 explicit_bag_type_cast : BAG LEFT_CURLY explicit_tuple_type_cast? RIGHT_CURLY -> ^( BAG_TYPE_CAST explicit_tuple_type_cast? )
 ;
 
-implicit_map_type : LEFT_BRACKET type? RIGHT_BRACKET -> ^( MAP_TYPE type? )
+implicit_map_type : LEFT_BRACKET ( ( identifier_plus COLON )? type )? RIGHT_BRACKET -> ^( MAP_TYPE identifier_plus? type? )
 ;
 
 explicit_map_type : MAP! implicit_map_type
diff --git a/test/org/apache/pig/test/TestSchema.java b/test/org/apache/pig/test/TestSchema.java
index 903337ddf..3262f2cd1 100644
--- a/test/org/apache/pig/test/TestSchema.java
+++ b/test/org/apache/pig/test/TestSchema.java
@@ -20,6 +20,7 @@ package org.apache.pig.test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -122,6 +123,41 @@ public class TestSchema {
         assertFalse(Schema.equals(schema1, schema2, false, false));
     }
 
+    @Test
+    public void testParsingMapSchemasFromString() throws ParserException {
+        assertNotNull(Utils.getSchemaFromString("b:[(a:int)]"));
+        assertNotNull(Utils.getSchemaFromString("b:[someAlias: (b:int)]"));
+        assertNotNull(Utils.getSchemaFromString("a:map[{bag: (a:int)}]"));
+        assertNotNull(Utils.getSchemaFromString("a:map[someAlias: {bag: (a:int)}]"));
+        assertNotNull(Utils.getSchemaFromString("a:map[chararray]"));
+        assertNotNull(Utils.getSchemaFromString("a:map[someAlias: chararray]"));
+        assertNotNull(Utils.getSchemaFromString("a:map[someAlias: (bar: {bag: (a:int)})]"));
+    }
+
+    @Test
+    public void testMapWithoutAlias() throws FrontendException {
+        List<FieldSchema> innerFields = new ArrayList<FieldSchema>();
+        innerFields.add(new FieldSchema(null, DataType.LONG));
+        List<FieldSchema> fields = new ArrayList<FieldSchema>();
+        fields.add(new FieldSchema("mapAlias", new Schema(innerFields), DataType.MAP));
+
+        Schema inputSchema = new Schema(fields);
+        Schema fromString = Utils.getSchemaFromBagSchemaString(inputSchema.toString());
+        assertTrue(Schema.equals(inputSchema, fromString, false, false));
+    }
+
+    @Test
+    public void testMapWithAlias() throws FrontendException {
+        List<FieldSchema> innerFields = new ArrayList<FieldSchema>();
+        innerFields.add(new FieldSchema("valueAlias", DataType.LONG));
+        List<FieldSchema> fields = new ArrayList<FieldSchema>();
+        fields.add(new FieldSchema("mapAlias", new Schema(innerFields), DataType.MAP));
+
+        Schema inputSchema = new Schema(fields);
+        Schema fromString = Utils.getSchemaFromBagSchemaString(inputSchema.toString());
+        assertTrue(Schema.equals(inputSchema, fromString, false, false));
+    }
+
     @Test
     public void testNormalNestedMerge1() {
 
