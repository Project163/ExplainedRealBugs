diff --git a/CHANGES.txt b/CHANGES.txt
index fb559b8af..d7b0eb642 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -70,6 +70,8 @@ PIG-1876: Typed map for Pig (daijy)
 
 IMPROVEMENTS
 
+PIG-2059: PIG doesn't validate incomplete query in batch mode even if -c option is given (xuefu)
+
 PIG-2062: Script silently ended (xuefu)
 
 PIG-2039: IndexOutOfBounException for a case (xuefu)
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index cde1c7ade..4a8603b11 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -1588,10 +1588,7 @@ public class PigServer {
                 scriptCache.add( query );
             }
            
-            if( !batchMode ) {
-                validateQuery();
-            }
-            
+            validateQuery();
             parseQuery();
             
             if( !batchMode ) {
diff --git a/test/org/apache/pig/parser/TestQueryParser.java b/test/org/apache/pig/parser/TestQueryParser.java
index 3b5ecb3e3..73ae260f2 100644
--- a/test/org/apache/pig/parser/TestQueryParser.java
+++ b/test/org/apache/pig/parser/TestQueryParser.java
@@ -96,7 +96,7 @@ public class TestQueryParser {
        
         Assert.assertFalse(stats.isSuccessful());
         
-        String expected = "Error during parsing. <file myscript.pig, line 1, column 10>";
+        String expected = "<file myscript.pig, line 1, column 10>";
         String msg = stats.getErrorMessage();
         
         Assert.assertFalse(msg == null);
diff --git a/test/org/apache/pig/test/TestBuiltin.java b/test/org/apache/pig/test/TestBuiltin.java
index 0d2be29d5..ca9694c40 100644
--- a/test/org/apache/pig/test/TestBuiltin.java
+++ b/test/org/apache/pig/test/TestBuiltin.java
@@ -82,6 +82,7 @@ import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.ReadToEndLoader;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
 import org.apache.pig.impl.logicalLayer.validators.TypeCheckerException;
@@ -992,8 +993,8 @@ public class TestBuiltin {
              pigServer.registerQuery("C = foreach B generate COUNT(A.$0, A.$0);");
              pigServer.openIterator("C");
              Assert.fail("COUNT is suppose to run with one argument of type BAG, however it ran with couple of arguments.");
-         }catch(TypeCheckerException e) {
-
+         }catch(FrontendException e) {
+             Assert.assertTrue( e.getCause() instanceof TypeCheckerException );
          }finally {
              Util.deleteFile(cluster, inputFileName);
          }
@@ -1008,8 +1009,8 @@ public class TestBuiltin {
              pigServer.registerQuery("C = foreach B generate COUNT(A.$0, A.$0);");
              pigServer.openIterator("C");
              Assert.fail("COUNT is suppose to run with one argument of type BAG, however it ran with couple of arguments.");
-         }catch(TypeCheckerException e) {
-             
+         }catch(FrontendException e) {
+             Assert.assertTrue( e.getCause() instanceof TypeCheckerException );
          }finally {
              Util.deleteFile(cluster, inputFileName);
          }
@@ -1024,8 +1025,8 @@ public class TestBuiltin {
              pigServer.registerQuery("C = foreach B generate COUNT('data');");
              pigServer.openIterator("C");
              Assert.fail("COUNT is suppose to run with one argument of type BAG, however it ran with an argument of type chararray.");
-         }catch(TypeCheckerException e) {
-             
+         }catch(FrontendException e) {
+             Assert.assertTrue( e.getCause() instanceof TypeCheckerException );
          }finally {
              Util.deleteFile(cluster, inputFileName);
          }
diff --git a/test/org/apache/pig/test/TestGrunt.java b/test/org/apache/pig/test/TestGrunt.java
index 46b959807..72e61cb12 100644
--- a/test/org/apache/pig/test/TestGrunt.java
+++ b/test/org/apache/pig/test/TestGrunt.java
@@ -125,7 +125,7 @@ public class TestGrunt extends TestCase {
         try {
             grunt.exec();
         } catch (Exception e) {
-            assertTrue(e.getMessage().contains("Error during parsing"));
+            assertTrue(e.getMessage().contains("<line 1, column 62>  mismatched input ';' expecting RIGHT_PAREN"));
         }
     }
 
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index ec37b06fd..f08bd372f 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -87,13 +87,13 @@ public class TestLogicalPlanBuilder {
     // TODO FIX Query3 and Query4
     @Test
     public void testQuery3() throws Exception {
-        String query = "foreach (cogroup (load 'a') by $1, (load 'b') by $1) generate org.apache.pig.builtin.AVG($1) ;";
+        String query = "foreach (cogroup (load 'a' as (u:int)) by $0, (load 'b' as (v:int) ) by $0) generate org.apache.pig.builtin.AVG($1);";
         buildPlan(query);
     }
 
     @Test
     public void testQuery4() throws Exception {
-        String query = "foreach (load 'a') generate AVG($1, $2) ;";
+        String query = "foreach (load 'a' as (u:int, v:bag{T:tuple(t:double)})) generate AVG($1) ;";
         buildPlan(query);
     }
 
@@ -127,13 +127,13 @@ public class TestLogicalPlanBuilder {
     // TODO FIX Query11 and Query12
     @Test
     public void testQuery11() throws Exception {
-        String query = " foreach (group (load 'a') by $1, (load 'b') by $2) generate group, AVG($1) ;";
+        String query = " foreach (group (load 'a' as (u:int)) by $0, (load 'b' as (v:long)) by $0) generate group, AVG($1) ;";
         buildPlan(query);
     }
     
     @Test
     public void testQuery12() throws Exception {
-        String query = "foreach (load 'a' using " + PigStorage.class.getName() + "()) generate AVG($1) ;";
+        String query = "foreach (load 'a' using " + PigStorage.class.getName() + "() as (v: long, u:bag{T:tuple(t:double)} ) ) generate AVG($1) ;";
         buildPlan(query);
     }
 
@@ -374,7 +374,7 @@ public class TestLogicalPlanBuilder {
 
     @Test
     public void testQuery25() throws Exception {
-        String query = "foreach (load 'a') {" +
+        String query = "foreach (load 'a' as (u:bag{}, v, w) ) {" +
                 "B = FILTER $0 BY (($1 == $2) AND ('a' < 'b'));" +
                 "generate B;" +
                 "};";
@@ -390,7 +390,7 @@ public class TestLogicalPlanBuilder {
     // TODO FIX Query27 and Query28
     @Test
     public void testQuery27() throws Exception {
-        String query =  "foreach (load 'a'){" +
+        String query =  "foreach (load 'a' as (u, v:bag{}, w, x:bag{}, y) ){" +
                 "A = DISTINCT $3.$1;" +
                 " generate " + TestApplyFunc.class.getName() + "($2, $1.($1, $4));" +
                         "};";
@@ -474,7 +474,7 @@ public class TestLogicalPlanBuilder {
     //TODO: Nested schemas don't work now. Probably a bug in the new parser.
     public void testQuery34() throws Exception {
         String query = "A = load 'a' as (aCol1, aCol2 : tuple(subCol1, subCol2));" +
-        "A = filter A by aCol2 == '1';" +
+        "A = filter A by aCol1 == '1';" +
         "B = load 'b' as (bCol1, bCol2);" +
         "foreach (cogroup A by (aCol1), B by bCol1 ) generate A.aCol2, B.bCol2 ;";
         buildPlan(query);
@@ -512,11 +512,11 @@ public class TestLogicalPlanBuilder {
     // TODO FIX Query39 and Query40
     @Test
     public void testQuery39() throws Exception{
-        String query = "a = load 'a' as (url, host, rank);" +
+        String query = "a = load 'a' as (url, host, rank:double);" +
                        "b = group a by (url,host); " +
                        "c = foreach b generate flatten(group.url), SUM(a.rank) as totalRank;";
         buildPlan(query);
-        query += "d = filter c by totalRank > '10';" +
+        query += "d = filter c by totalRank > 10;" +
                  "e = foreach d generate totalRank;";
         buildPlan( query );
     }
@@ -571,7 +571,7 @@ public class TestLogicalPlanBuilder {
         "b = load 'a' as (url,rank);" +
         "c = cogroup a by url, b by url;" +
         "d = foreach c generate group,flatten(a),flatten(b);" +
-        "e = foreach d generate group, a::url, b::url, b::rank, rank;";
+        "e = foreach d generate group, a::url, b::url, b::rank;";
         buildPlan( q );
     }
 
@@ -592,7 +592,7 @@ public class TestLogicalPlanBuilder {
     public void testQuery44() throws Exception {
         String q = "a = load 'a' as (url, pagerank);" +
         "b = load 'b' as (url, query, rank);" +
-        "c = cogroup a by (pagerank#'nonspam', url) , b by (rank/'2', url) ;" +
+        "c = cogroup a by (pagerank#'nonspam', url) , b by (rank, url) ;" +
         "foreach c generate group.url;";
         buildPlan( q );
     }
@@ -617,7 +617,7 @@ public class TestLogicalPlanBuilder {
     
     @Test
     public void testQuery57() throws Exception {
-        String query = "foreach (load 'a') generate ($1+$2), ($1-$2), ($1*$2), ($1/$2), ($1%$2), -($1) ;";
+        String query = "foreach (load 'a' as (u:int, v:long, w:int)) generate ($1+$2), ($1-$2), ($1*$2), ($1/$2), ($1%$2), -($1) ;";
         buildPlan(query);
     }
 
@@ -817,14 +817,14 @@ public class TestLogicalPlanBuilder {
 
     @Test
     public void testQuery72() throws Exception {
-        String q = "split (load 'a') into x if $0 > '7', y if $0 < '7';" +
+        String q = "split (load 'a') into x if $0 > 7, y if $0 < 7;" +
         "b = foreach x generate (int)$0;" +
         "c = foreach y generate (bag{})$1;" +
-        "d = foreach y generate (int)($1/2);" +
-        "e = foreach y generate (bag{tuple(int, float)})($1/2);" +
-        "f = foreach x generate (tuple(int, float))($1/2);" +
-        "g = foreach x generate (tuple())($1/2);" +
-        "h = foreach x generate (chararray)($1/2);";
+        "d = foreach y generate (int)($2/2);" +
+        "e = foreach y generate (bag{tuple(int, float)})($2);" +
+        "f = foreach x generate (tuple(int, float))($3);" +
+        "g = foreach x generate (tuple())($4);" +
+        "h = foreach x generate (chararray)($5);";
         buildPlan( q );
     }
 
@@ -1177,7 +1177,7 @@ public class TestLogicalPlanBuilder {
                        "b = group a by (name, age);";
 
         try {
-            buildPlan( query + "c = foreach b generate group as mygroup:(myname, myage, mygpa), COUNT(a) as mycount;");
+            buildPlan( query + "c = foreach b generate group as mygroup:(myname, myage), COUNT(a) as mycount;");
         } catch (AssertionFailedError e) {
             Assert.assertTrue(e.getMessage().contains("Schema size mismatch"));
         }
@@ -1197,13 +1197,13 @@ public class TestLogicalPlanBuilder {
         try {
             buildPlan( query + "c = foreach b generate group as mygroup:{t: (myname, myage)}, COUNT(a) as mycount;");
         } catch (AssertionFailedError e) {
-            Assert.assertTrue(e.getMessage().contains("Type mismatch"));
+            Assert.assertTrue(e.getMessage().contains("Incompatable field schema"));
         }
 
         try {
             buildPlan( query + "c = foreach b generate flatten(group) as (myname, myage, mygpa), COUNT(a) as mycount;");
         } catch (AssertionFailedError e) {
-            Assert.assertTrue(e.getMessage().contains("Schema size mismatch"));
+            Assert.assertTrue(e.getMessage().contains("Incompatable schema"));
         }
     }
         
@@ -1259,7 +1259,7 @@ public class TestLogicalPlanBuilder {
         // test that we can refer to "b::name" field and not name
         "e = foreach d generate a::name, b::name;"+
         // test that we can refer to gpa and somethingelse
-        "f = foreach d generate gpa, somethingelse, a::gpa, b::somethingelse;";
+        "f = foreach d generate gpa, somethingelse;";
         buildPlan( query );
     }
     
@@ -1274,7 +1274,7 @@ public class TestLogicalPlanBuilder {
         try {
             buildPlan(query);
         } catch (AssertionFailedError e) {
-            Assert.assertTrue(e.getMessage().contains("Found more than one match:"));
+            Assert.assertTrue(e.getMessage().contains("Invalid field projection. Projected field [name] does not exist"));
         }
     }
 
@@ -2054,7 +2054,7 @@ public class TestLogicalPlanBuilder {
             "store c into 'output';";
             buildPlan( query );
         } catch (AssertionFailedError e) {
-            Assert.assertTrue(e.getMessage().contains("Cannot resolve COGroup output schema"));
+            Assert.assertTrue(e.getMessage().contains("Cannot cast to Unknown"));
             exceptionThrown = true;
         }
         Assert.assertEquals("An exception was expected but did " +
diff --git a/test/org/apache/pig/test/TestMacroExpansion.java b/test/org/apache/pig/test/TestMacroExpansion.java
index 0f1cda927..10b030f5d 100644
--- a/test/org/apache/pig/test/TestMacroExpansion.java
+++ b/test/org/apache/pig/test/TestMacroExpansion.java
@@ -586,7 +586,7 @@ public class TestMacroExpansion {
             "    C = group $A by $0;\n" +
             "    X = FOREACH C GENERATE group, SUM ($A.$1);\n" +
             "    Y = FOREACH C GENERATE group, FLATTEN($A);\n" +
-            "    Z = FOREACH C GENERATE FLATTEN($A.($1, $2)), FLATTEN($A.age);\n" +
+            "    Z = FOREACH C GENERATE FLATTEN($A.($0, $2)), FLATTEN($A.age);\n" +
             "    X = FOREACH $A GENERATE $1+$2 AS f1:int;\n" +
             "};\n";
         
@@ -601,7 +601,7 @@ public class TestMacroExpansion {
             "macro_group_and_count_C_0 = group alpha by ($0);\n" +
             "macro_group_and_count_X_0 = FOREACH macro_group_and_count_C_0 GENERATE group, SUM(alpha.($1));\n" +
             "macro_group_and_count_Y_0 = FOREACH macro_group_and_count_C_0 GENERATE group, FLATTEN(alpha) ;\n" +
-            "macro_group_and_count_Z_0 = FOREACH macro_group_and_count_C_0 GENERATE FLATTEN(alpha.($1, $2)) , FLATTEN(alpha.(age)) ;\n" +
+            "macro_group_and_count_Z_0 = FOREACH macro_group_and_count_C_0 GENERATE FLATTEN(alpha.($0, $2)) , FLATTEN(alpha.(age)) ;\n" +
             "macro_group_and_count_X_0 = FOREACH alpha GENERATE $1 + $2 AS f1:int;\n" +
             "store gamma INTO 'byuser';\n";
             
@@ -637,20 +637,20 @@ public class TestMacroExpansion {
     @Test
     public void bincondTest() throws Exception {
         String macro = "define group_and_count (A) returns B {\n" +
-            "    X = FOREACH $A GENERATE f1, f2, f1%f2;\n" +
+            "    X = FOREACH $A GENERATE f1, f2, f0%f2;\n" +
             "    Y = FOREACH $A GENERATE f2, (f2==1?1:COUNT(B));\n" +
             "    Z = FILTER $A BY f1 is not null;\n" +
             "    $B = FILTER $A BY (f1 matches '.*apache.*');\n" +
             "};\n";
         
         String script = 
-            "alpha = LOAD 'data' AS (f1:chararray, f2:int, B:bag{T:tuple(t1:int,t2:int)});\n" +
+            "alpha = LOAD 'data' AS (f0:long, f1:chararray, f2:int, B:bag{T:tuple(t1:int,t2:int)});\n" +
             "gamma = group_and_count (alpha);\n" +
             "store gamma into 'byuser';\n";
         
         String expected = 
-            "alpha = LOAD 'data' AS (f1:chararray, f2:int, B:bag{T:(t1:int, t2:int)});\n" +
-            "macro_group_and_count_X_0 = FOREACH alpha GENERATE f1, f2, f1 % f2;\n" +
+            "alpha = LOAD 'data' AS (f0:long, f1:chararray, f2:int, B:bag{T:(t1:int, t2:int)});\n" +
+            "macro_group_and_count_X_0 = FOREACH alpha GENERATE f1, f2, f0 % f2;\n" +
             "macro_group_and_count_Y_0 = FOREACH alpha GENERATE f2,  (f2 == 1 ? 1 : COUNT(B)) ;\n" +
             "macro_group_and_count_Z_0 = FILTER alpha BY (f1 IS not null);\n" +
             "gamma = FILTER alpha BY (f1 matches '.*apache.*');\n" +
@@ -1722,11 +1722,11 @@ public class TestMacroExpansion {
     @Test
     public void test21() throws Exception {
         String macro = 
-            "a = load '1.txt' as ( u, v, w : int );" +
+            "a = load '1.txt' as ( u:tuple(p, q), v, w : int );" +
             "b = foreach a generate * as ( x, y, z ), flatten( u ) as ( r, s ), flatten( v ) as d, w + 5 as e:int;";
             
         String expected =
-            "macro_mymacro_a_0 = load '1.txt' as (u, v, w:int);\n" +
+            "macro_mymacro_a_0 = load '1.txt' as (u:(p, q), v, w:int);\n" +
             "macro_mymacro_b_0 = foreach macro_mymacro_a_0 generate  * AS (x, y, z), flatten(u)  AS (r, s), flatten(v)  AS d, w + 5 AS e:int;\n";
         
         testMacro(macro, expected);
@@ -1750,11 +1750,11 @@ public class TestMacroExpansion {
     @Test
     public void test23() throws Exception {
         String macro = 
-            "a = load '1.txt' as ( u, v, w : int );" +
+            "a = load '1.txt' as ( u:tuple(p, q), v, w : int );" +
             "b = foreach a generate * as ( x, y, z ), flatten( u ) as ( r, s ), flatten( v ) as d, w + 5 as e:int;";
             
         String expected =
-            "macro_mymacro_a_0 = load '1.txt' as (u, v, w:int);\n" +
+            "macro_mymacro_a_0 = load '1.txt' as (u:(p, q), v, w:int);\n" +
             "macro_mymacro_b_0 = foreach macro_mymacro_a_0 generate  * AS (x, y, z), flatten(u)  AS (r, s), flatten(v)  AS d, w + 5 AS e:int;\n";
         
         testMacro(macro, expected);
@@ -2140,7 +2140,7 @@ public class TestMacroExpansion {
             grunt.checkScript(scriptFile);
             
             Assert.fail("Expected exception isn't thrown");
-        } catch (FrontendException e) { 
+        } catch (Exception e) { 
             String msg = e.getMessage();
             int pos = msg.indexOf(keyword);
             if (pos < 0) {
diff --git a/test/org/apache/pig/test/TestNewPlanLogToPhyTranslationVisitor.java b/test/org/apache/pig/test/TestNewPlanLogToPhyTranslationVisitor.java
index 3d7330c8e..868b2b64a 100644
--- a/test/org/apache/pig/test/TestNewPlanLogToPhyTranslationVisitor.java
+++ b/test/org/apache/pig/test/TestNewPlanLogToPhyTranslationVisitor.java
@@ -508,9 +508,9 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         LogicalRelationalOperator ld =  (LogicalRelationalOperator)newLogicalPlan.getSources().get(0);
         LogicalRelationalOperator fe = (LogicalRelationalOperator)newLogicalPlan.getSuccessors(ld).get(0);
         LogicalSchema ls = fe.getSchema();
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(4, ls.getField(1).uid);
-        assertEquals(5, ls.getField(2).uid);
+        assertEquals(6, ls.getField(0).uid);
+        assertEquals(9, ls.getField(1).uid);
+        assertEquals(10, ls.getField(2).uid);
         
         LogicalSchema expected = new LogicalSchema();
         expected.addField(new LogicalFieldSchema("id", null, DataType.BYTEARRAY));
@@ -561,8 +561,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -615,8 +615,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -668,8 +668,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -721,8 +721,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -774,8 +774,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -827,8 +827,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -871,8 +871,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         LOLoad load = (LOLoad)ld;
         LogicalSchema ls = load.getSchema();
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(4, ls.getField(0).uid);
+        assertEquals(5, ls.getField(1).uid);
         
         LogicalRelationalOperator fil = (LogicalRelationalOperator)
         newLogicalPlan.getSuccessors( newLogicalPlan.getSources().get(0) ).get(0);
@@ -906,8 +906,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         LOLoad load = (LOLoad)ld;
         LogicalSchema ls = load.getSchema();
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(5, ls.getField(0).uid);
+        assertEquals(6, ls.getField(1).uid);
         
         LogicalRelationalOperator fil = (LogicalRelationalOperator)
         newLogicalPlan.getSuccessors( newLogicalPlan.getSources().get(0) ).get(0);
@@ -952,8 +952,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(5, ls.getField(0).uid);
+        assertEquals(6, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -1033,8 +1033,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln1 = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(7, ls.getField(0).uid);
+        assertEquals(8, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
@@ -1094,8 +1094,8 @@ public class TestNewPlanLogToPhyTranslationVisitor extends TestCase {
         POForEach pForEach = (POForEach)pFE;
         PhysicalPlan inputPln = pForEach.getInputPlans().get(0);
         
-        assertEquals(1, ls.getField(0).uid);
-        assertEquals(2, ls.getField(1).uid);
+        assertEquals(11, ls.getField(0).uid);
+        assertEquals(12, ls.getField(1).uid);
         
         LogicalRelationalOperator fe = 
             (LogicalRelationalOperator) newLogicalPlan.getSuccessors(load).get(0);
diff --git a/test/org/apache/pig/test/TestPigServer.java b/test/org/apache/pig/test/TestPigServer.java
index c75b3b4f9..7f932df05 100644
--- a/test/org/apache/pig/test/TestPigServer.java
+++ b/test/org/apache/pig/test/TestPigServer.java
@@ -778,4 +778,17 @@ public class TestPigServer {
         Assert.assertTrue(s==null);
     }
 
+    @Test // PIG-2059
+    public void test1() throws Throwable {
+    	pig.setBatchOn();
+        pig.registerQuery("A = load 'x' as (u, v);") ;
+        try {
+            pig.registerQuery("B = foreach A generate $2;") ;
+        } catch(Exception ex) {
+        	Assert.assertTrue( ex.getMessage().contains("<line 1, column 46> Out of bound access. Trying to access non-existent column: 2") );
+        	return;
+        }
+        Assert.fail( "Query is supposed to fail." );
+    }
+
 }
diff --git a/test/org/apache/pig/test/TestStreaming.java b/test/org/apache/pig/test/TestStreaming.java
index 4459d2ee2..0be98ab97 100644
--- a/test/org/apache/pig/test/TestStreaming.java
+++ b/test/org/apache/pig/test/TestStreaming.java
@@ -32,8 +32,8 @@ import org.apache.pig.builtin.PigStreaming;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.io.FileLocalizer;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.TupleFormat;
-import org.apache.pig.parser.ParserException;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Assert;
@@ -752,7 +752,7 @@ public class TestStreaming {
     }
     
     @Test
-    public void testNegativeMutipleInput() throws IOException {
+    public void testNegativeMultipleInput() throws IOException {
         // Perl script 
         String[] script = 
             new String[] {
@@ -775,7 +775,7 @@ public class TestStreaming {
     	
     	try {
     		pigServer.registerQuery( query );
-    	} catch(ParserException ex) {
+    	} catch(FrontendException ex) {
     		String expectedMsg = "pig script failed to validate: Duplicated command option";
     	    System.out.println( ex.getMessage() );
     		Assert.assertTrue( ex.getMessage().contains( expectedMsg ) );
