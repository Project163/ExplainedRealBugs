diff --git a/CHANGES.txt b/CHANGES.txt
index d1470b995..6208935dc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -24,6 +24,8 @@ INCOMPATIBLE CHANGES
 
 IMPROVEMENTS
 
+PIG-2699: Reduce the number of instances of Load and Store Funcs down to 2+1 (julien)
+
 PIG-2166: UDFs to join a bag (hluu via daijy)
 
 PIG-2651: Provide a much easier to use accumulator interface (jcoveney via daijy)
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index fe7084ba6..449809a32 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -943,7 +943,7 @@ public class PigServer {
         currDAG.buildPlan( alias );
 
         try {
-            QueryParserUtils.attachStorePlan( currDAG.lp, filename, func, currDAG.getOperator( alias ), alias, pigContext );
+            QueryParserUtils.attachStorePlan(scope, currDAG.lp, filename, func, currDAG.getOperator( alias ), alias, pigContext);
             currDAG.compile();
             return executeCompiledLogicalPlan();
         } catch (PigException e) {
@@ -1225,7 +1225,7 @@ public class PigServer {
         if( !isBatchOn() || alias != null ) {
             // MRCompiler needs a store to be the leaf - hence
             // add a store to the plan to explain
-            QueryParserUtils.attachStorePlan( currDAG.lp, "fakefile", null, currDAG.getOperator( alias ), 
+            QueryParserUtils.attachStorePlan(scope, currDAG.lp, "fakefile", null, currDAG.getOperator( alias ), 
                     "fake", pigContext );
         }
         currDAG.compile();
@@ -1628,9 +1628,9 @@ public class PigServer {
         }
         
         private void compile(LogicalPlan lp) throws FrontendException  {
-            new ColumnAliasConversionVisitor( lp ).visit();
-            new SchemaAliasVisitor( lp ).visit();
-            new ScalarVisitor( lp, pigContext ).visit();
+            new ColumnAliasConversionVisitor(lp).visit();
+            new SchemaAliasVisitor(lp).visit();
+            new ScalarVisitor(lp, pigContext, scope).visit();
             
             // TODO: move optimizer here from HExecuteEngine.
             // TODO: input/output validation visitor
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
index 86cf9bc57..d5c93155e 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
@@ -56,7 +56,6 @@ import org.apache.pig.newplan.logical.relational.LogToPhyTranslationVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.rules.InputOutputFileValidator;
-import org.apache.pig.newplan.logical.rules.LoadStoreFuncDupSignatureValidator;
 import org.apache.pig.newplan.logical.visitor.SortInfoSetter;
 import org.apache.pig.newplan.logical.visitor.StoreAliasSetter;
 import org.apache.pig.pen.POOptimizeDisabler;
@@ -269,11 +268,7 @@ public class HExecutionEngine {
             optimizerRules.add("AddForEach");
             optimizerRules.add("GroupByConstParallelSetter");
         }
-        
-        // Check if we have duplicate signature
-        LoadStoreFuncDupSignatureValidator loadStoreFuncDupSignatureValidator = new LoadStoreFuncDupSignatureValidator(plan);
-        loadStoreFuncDupSignatureValidator.validate();
-        
+
         StoreAliasSetter storeAliasSetter = new StoreAliasSetter( plan );
         storeAliasSetter.visit();
         
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
index 357de610e..cb89d3fb1 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
@@ -252,7 +252,7 @@ public class MapReduceLauncher extends Launcher{
 
             // Set the thread UDFContext so registered classes are available.
             final UDFContext udfContext = UDFContext.getUDFContext();
-            Thread jcThread = new Thread(jc) {
+            Thread jcThread = new Thread(jc, "JobControl") {
                 @Override
                 public void run() {
                     UDFContext.setUdfContext(udfContext.clone()); //PIG-2576
@@ -650,7 +650,7 @@ public class MapReduceLauncher extends Launcher{
             } catch (Exception e) {
                 String errMsg = "Could not resolve error that occured when launching map reduce job: "
                         + jobControlExceptionStackTrace;
-                jobControlException = new RuntimeException(errMsg);
+                jobControlException = new RuntimeException(errMsg, throwable);
             }
         }
     }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POStore.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POStore.java
index c06771cae..80307f073 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POStore.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POStore.java
@@ -293,4 +293,8 @@ public class POStore extends PhysicalOperator {
     public boolean disableCounter() {
         return disableCounter;
     }
+
+    public void setStoreFunc(StoreFuncInterface storeFunc) {
+        this.storer = storeFunc;
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOLoad.java b/src/org/apache/pig/newplan/logical/relational/LOLoad.java
index 447be50ef..4828bbc54 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOLoad.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOLoad.java
@@ -40,33 +40,58 @@ import org.apache.pig.newplan.logical.Util;
 public class LOLoad extends LogicalRelationalOperator {
     
     private LogicalSchema scriptSchema;
-    private FileSpec fs;
+    private final FileSpec fs;
     private transient LoadFunc loadFunc;
     transient private Configuration conf;
-    private LogicalSchema determinedSchema;
+    private final LogicalSchema determinedSchema;
     private List<Integer> requiredFields = null;
     private boolean castInserted = false;
     private LogicalSchema uidOnlySchema;
-    private String schemaFile = null;
-    private String signature = null;
+    private final String schemaFile;
+    private final String signature;
     private long limit = -1;
 
     /**
+     * used for pattern matching
      * 
-     * @param loader FuncSpec for load function to use for this load.
      * @param schema schema user specified in script, or null if not
      * specified.
      * @param plan logical plan this load is part of.
      */
-    public LOLoad(FileSpec loader, LogicalSchema schema, LogicalPlan plan, Configuration conf) {
-       super("LOLoad", plan);
-       scriptSchema = schema;
-       fs = loader;
-       if (loader != null)
-           schemaFile = loader.getFileName();
-       this.conf = conf;
+    public LOLoad(LogicalSchema schema, LogicalPlan plan) {
+        this(null, schema, plan, null, null, null);
     }
-    
+
+    /**
+     * Used from the LogicalPlanBuilder
+     *
+     * @param loader FuncSpec for load function to use for this load.
+     * @param schema schema user specified in script, or null if not specified.
+     * @param plan logical plan this load is part of.
+     * @param conf
+     * @param loadFunc the LoadFunc that was instantiated from loader
+     * @param signature the signature that will be passed to the LoadFunc
+     */
+    public LOLoad(FileSpec loader, LogicalSchema schema, LogicalPlan plan, Configuration conf, LoadFunc loadFunc, String signature) {
+        super("LOLoad", plan);
+        this.scriptSchema = schema;
+        this.fs = loader;
+        this.schemaFile = loader == null ? null : loader.getFileName();
+        this.conf = conf;
+        this.loadFunc = loadFunc;
+        this.signature = signature;
+        if (loadFunc != null) {
+            this.loadFunc.setUDFContextSignature(signature);
+            try {
+                this.determinedSchema = getSchemaFromMetaData();
+            } catch (FrontendException e) {
+                throw new RuntimeException("Can not retrieve schema from loader " + loadFunc, e);
+            }
+        } else {
+            this.determinedSchema = null;
+        }
+    }
+
     public String getSchemaFile() {
         return schemaFile;
     }
@@ -105,10 +130,6 @@ public class LOLoad extends LogicalRelationalOperator {
             return schema;
         
         LogicalSchema originalSchema = null;
-
-        if (determinedSchema==null) {
-            determinedSchema = getSchemaFromMetaData();
-        }
         
         if (scriptSchema != null && determinedSchema != null) {
             originalSchema = LogicalSchema.merge(scriptSchema, determinedSchema, LogicalSchema.MergeMode.LoadForEach);
@@ -158,15 +179,13 @@ public class LOLoad extends LogicalRelationalOperator {
         return null;
     }
 
-	@Override
-	public void setAlias(String alias) {
-		super.setAlias(alias);
+    @Override
+    public void setAlias(String alias) {
+        super.setAlias(alias);
 
-		// set the schema in this method using the new alias assigned
-		storeScriptSchema();
-		if (signature==null)
-		    signature = alias;
-	}
+        // set the schema in this method using the new alias assigned
+        storeScriptSchema();
+    }
 	
 	/**
 	 * This method will store the scriptSchema:Schema using ObjectSerializer to
@@ -270,16 +289,6 @@ public class LOLoad extends LogicalRelationalOperator {
         return signature;
     }
     
-    /***
-     * This method is called by Pig logical planner to setup UDFContext signature.
-     * So that loadFunc can use signature to store its own configurations in UDFContext.
-     * This is not intend to be called by users
-     */
-    public void setSignature(String signature) {
-        this.signature = signature;
-        loadFunc.setUDFContextSignature(signature);
-    }
-    
     public LogicalSchema getScriptSchema() {
         return scriptSchema;
     }
@@ -291,4 +300,5 @@ public class LOLoad extends LogicalRelationalOperator {
     public void setLimit(long limit) {
         this.limit = limit;
     }
+
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOStore.java b/src/org/apache/pig/newplan/logical/relational/LOStore.java
index 97d91c4c1..a8e215222 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOStore.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOStore.java
@@ -17,42 +17,31 @@
  */
 package org.apache.pig.newplan.logical.relational;
 
-//import org.apache.commons.logging.Log;
-//import org.apache.commons.logging.LogFactory;
-import org.apache.pig.FuncSpec;
 import org.apache.pig.SortInfo;
 import org.apache.pig.StoreFuncInterface;
-import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.PlanVisitor;
 
 public class LOStore extends LogicalRelationalOperator {
-    private static final long serialVersionUID = 2L;
 
-    private FileSpec output;
-    
- // If we know how to reload the store, here's how. The lFile
+    private final FileSpec output;
+
+    // If we know how to reload the store, here's how. The lFile
     // FileSpec is set in PigServer.postProcess. It can be used to
     // reload this store, if the optimizer has the need.
     private FileSpec mInputSpec;
-    private String signature;
+    private final String signature;
     private boolean isTmpStore;
     private SortInfo sortInfo;
-    transient private StoreFuncInterface storeFunc;
-    
-    //private static Log log = LogFactory.getLog(LOStore.class);
-    
-    public LOStore(LogicalPlan plan) {
-        super("LOStore", plan);
-    }
-    
-    public LOStore(LogicalPlan plan, FileSpec outputFileSpec) {
-        super("LOStore", plan);
+    private final StoreFuncInterface storeFunc;
 
-        output = outputFileSpec;
-        storeFunc = (StoreFuncInterface) PigContext.instantiateFuncFromSpec(outputFileSpec.getFuncSpec()); 
+    public LOStore(LogicalPlan plan, FileSpec outputFileSpec, StoreFuncInterface storeFunc, String signature) {
+        super("LOStore", plan);
+        this.output = outputFileSpec;
+        this.storeFunc = storeFunc;
+        this.signature = signature;
     }
     
     public FileSpec getOutputSpec() {
@@ -123,23 +112,9 @@ public class LOStore extends LogicalRelationalOperator {
     public String getSignature() {
         return signature;
     }
-    
-    public void setSignature(String sig) {
-        signature = sig;
-        storeFunc.setStoreFuncUDFContextSignature(signature);
-    }
 
-    public static String constructSignature(String alias, String filename, FuncSpec funcSpec) {
-        return alias+"_"+filename+"_"+funcSpec.toString();
+    public FileSpec getFileSpec() {
+        return output;
     }
 
-	public FileSpec getFileSpec() {
-		return output;
-	}
-    
-	@Override
-	public void setAlias(String alias) {
-        this.alias = alias;
-        setSignature(constructSignature(alias, output.getFileName(), output.getFuncSpec()));
-    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java b/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
index 39004a38e..03b7db277 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
@@ -677,6 +677,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
         store.setSignature(loStore.getSignature());
         store.setSortInfo(loStore.getSortInfo());
         store.setIsTmpStore(loStore.isTmpStore());
+        store.setStoreFunc(loStore.getStoreFunc());
         
         store.setSchema(Util.translateSchema( loStore.getSchema() ));
 
diff --git a/src/org/apache/pig/newplan/logical/rules/LoadStoreFuncDupSignatureValidator.java b/src/org/apache/pig/newplan/logical/rules/LoadStoreFuncDupSignatureValidator.java
deleted file mode 100644
index 81b3417b7..000000000
--- a/src/org/apache/pig/newplan/logical/rules/LoadStoreFuncDupSignatureValidator.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pig.newplan.logical.rules;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.newplan.DepthFirstWalker;
-import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.logical.relational.LOLoad;
-import org.apache.pig.newplan.logical.relational.LOStore;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
-
-/***
- * Check for duplicate alias. This is because we use alias as LoadFunc signature. If
- * user use the same alias in two load statement, we cannot distinguish two loadFunc.
- * LoadStoreFuncDupSignatureValidator solve this problem by appending an index if signature
- * conflicts
- */
-
-public class LoadStoreFuncDupSignatureValidator {
-    OperatorPlan plan;
-    public LoadStoreFuncDupSignatureValidator(OperatorPlan plan) {
-        this.plan = plan;
-    }
-    
-    public void validate() throws FrontendException {
-        LoadStoreFuncDupSignatureVisitor visitor = new LoadStoreFuncDupSignatureVisitor(plan);
-        visitor.visit();
-        visitor.finish();
-    }
-    
-    static class LoadStoreFuncDupSignatureVisitor extends LogicalRelationalNodesVisitor {
-        Map<String, List<LOLoad>> loadSignatures = new HashMap<String, List<LOLoad>>();
-        Map<String, List<LOStore>> storeSignatures = new HashMap<String, List<LOStore>>();
-        protected LoadStoreFuncDupSignatureVisitor(OperatorPlan plan)
-                throws FrontendException {
-            super(plan, new DepthFirstWalker(plan));
-        }
-
-        @Override
-        public void visit(LOLoad load) throws FrontendException {
-            if (loadSignatures.containsKey(load.getSignature())) {
-                List<LOLoad> loads = loadSignatures.get(load.getSignature());
-                loads.add(load);
-            } else {
-                List<LOLoad> loads = new ArrayList<LOLoad>();
-                loads.add(load);
-                loadSignatures.put(load.getSignature(), loads);
-            }
-        }
-        
-        @Override
-        public void visit(LOStore store) throws FrontendException {
-            if (storeSignatures.containsKey(store.getSignature())) {
-                List<LOStore> stores = storeSignatures.get(store.getSignature());
-                stores.add(store);
-            } else {
-                List<LOStore> stores = new ArrayList<LOStore>();
-                stores.add(store);
-                storeSignatures.put(store.getSignature(), stores);
-            }
-        }
-        
-        public void finish() {
-            for (Map.Entry<String, List<LOLoad>> entry : loadSignatures.entrySet()) {
-                String key = entry.getKey();
-                List<LOLoad> loads = entry.getValue();
-                if (loads.size()>1) {
-                    for (int i=0;i<loads.size();i++) {
-                        loads.get(i).setSignature(key+"$"+i);
-                    }
-                }
-            }
-            
-            for (Map.Entry<String, List<LOStore>> entry : storeSignatures.entrySet()) {
-                String key = entry.getKey();
-                List<LOStore> stores = entry.getValue();
-                if (stores.size()>1) {
-                    for (int i=0;i<stores.size();i++) {
-                        stores.get(i).setSignature(key+"$"+i);
-                    }
-                }
-            }
-        }
-    }
-}
diff --git a/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java b/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
index 898f59e57..158b76d3c 100644
--- a/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
+++ b/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
@@ -85,7 +85,7 @@ public class PartitionFilterOptimizer extends Rule {
     protected OperatorPlan buildPattern() {
         // match each foreach.
         LogicalPlan plan = new LogicalPlan();
-        LogicalRelationalOperator load = new LOLoad (null, null, plan, null );
+        LogicalRelationalOperator load = new LOLoad (null, plan);
         plan.add( load );
 //        LogicalRelationalOperator filter = new LOFilter( plan );
 //        plan.add( filter );
diff --git a/src/org/apache/pig/newplan/logical/rules/TypeCastInserter.java b/src/org/apache/pig/newplan/logical/rules/TypeCastInserter.java
index a526a372d..35dcfced4 100644
--- a/src/org/apache/pig/newplan/logical/rules/TypeCastInserter.java
+++ b/src/org/apache/pig/newplan/logical/rules/TypeCastInserter.java
@@ -55,7 +55,7 @@ public abstract class TypeCastInserter extends Rule {
         LogicalPlan plan = new LogicalPlan();
         LogicalRelationalOperator op;
         if (getOperatorClassName().equals(LOLoad.class.getName()))
-            op = new LOLoad(null, null, plan, null);
+            op = new LOLoad(null, plan);
         else // LOStream
             op = new LOStream(plan, null, null, null);
         plan.add(op);
diff --git a/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java b/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java
index 52924e572..62aa143e7 100644
--- a/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/ScalarVisitor.java
@@ -22,6 +22,7 @@ import java.io.IOException;
 import java.util.List;
 
 import org.apache.pig.FuncSpec;
+import org.apache.pig.StoreFuncInterface;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.io.FileSpec;
@@ -38,6 +39,7 @@ import org.apache.pig.newplan.logical.expression.ScalarExpression;
 import org.apache.pig.newplan.logical.optimizer.AllExpressionVisitor;
 import org.apache.pig.newplan.logical.relational.LOStore;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.parser.LogicalPlanBuilder;
 
 /**
  * Logical plan visitor which handles scalar projections. It will find or create a LOStore 
@@ -46,10 +48,12 @@ import org.apache.pig.newplan.logical.relational.LogicalPlan;
  */
 public class ScalarVisitor extends AllExpressionVisitor {
     private final PigContext pigContext;
+    private final String scope;
     
-    public ScalarVisitor(OperatorPlan plan, PigContext pigContext) throws FrontendException {
+    public ScalarVisitor(OperatorPlan plan, PigContext pigContext, String scope) throws FrontendException {
         super( plan, new DependencyOrderWalker( plan ) );
         this.pigContext = pigContext;
+        this.scope = scope;
     }
 
     @Override
@@ -84,7 +88,10 @@ public class ScalarVisitor extends AllExpressionVisitor {
                     } catch (IOException e) {
                         throw new PlanValidationException( expr, "Failed to process scalar" + e);
                     }
-                    store = new LOStore( lp, fileSpec );
+                    StoreFuncInterface stoFunc = (StoreFuncInterface)PigContext.instantiateFuncFromSpec(funcSpec);
+                    String sig = LogicalPlanBuilder.newOperatorKey(scope);
+                    stoFunc.setStoreFuncUDFContextSignature(sig);
+                    store = new LOStore(lp, fileSpec, stoFunc, sig);
                     store.setTmpStore(true);
                     lp.add( store );
                     lp.connect( refOp, store );
diff --git a/src/org/apache/pig/parser/FunctionType.java b/src/org/apache/pig/parser/FunctionType.java
index 18249a74f..607652694 100644
--- a/src/org/apache/pig/parser/FunctionType.java
+++ b/src/org/apache/pig/parser/FunctionType.java
@@ -33,28 +33,32 @@ class FunctionType {
     public static final byte PIGTOSTREAMFUNC = 32;
     public static final byte STREAMTOPIGFUNC = 64;
 
-    public static void tryCasting(Object func, byte funcType) throws Exception {
+    public static void tryCasting(Class<?> func, byte funcType) {
+        Class<?> typeClass;
         switch(funcType) {
         case FunctionType.EVALFUNC:
-            EvalFunc evalFunc = (EvalFunc) func;
+            typeClass = EvalFunc.class;
             break;
         case FunctionType.COMPARISONFUNC:
-            ComparisonFunc comparisonFunc = (ComparisonFunc) func;
+            typeClass = ComparisonFunc.class;
             break;
         case FunctionType.LOADFUNC:
-            LoadFunc loadFunc = (LoadFunc) func;
+            typeClass = LoadFunc.class;
             break;
         case FunctionType.STOREFUNC:
-            StoreFuncInterface storeFunc = (StoreFuncInterface) func;
+            typeClass = StoreFuncInterface.class;
             break;
         case FunctionType.PIGTOSTREAMFUNC:
-            PigToStream ptsFunc = (PigToStream) func;
+            typeClass = PigToStream.class;
             break;
         case FunctionType.STREAMTOPIGFUNC:
-            StreamToPig stpFunc = (StreamToPig) func;
+            typeClass = StreamToPig.class;
             break;
         default:
-            throw new Exception("Received an unknown function type: " + funcType);
+            throw new IllegalArgumentException("Received an unknown function type: " + funcType);
+        }
+        if (!typeClass.isAssignableFrom(func)) {
+            throw new ClassCastException(func + " does not implement " + typeClass);
         }
     }
     
diff --git a/src/org/apache/pig/parser/LogicalPlanBuilder.java b/src/org/apache/pig/parser/LogicalPlanBuilder.java
index a7420a760..bf46e778b 100644
--- a/src/org/apache/pig/parser/LogicalPlanBuilder.java
+++ b/src/org/apache/pig/parser/LogicalPlanBuilder.java
@@ -106,6 +106,10 @@ public class LogicalPlanBuilder {
     
     private static NodeIdGenerator nodeIdGen = NodeIdGenerator.getGenerator();
     
+    public static long getNextId(String scope) {
+        return nodeIdGen.getNextNodeId( scope );
+    }
+    
     LogicalPlanBuilder(PigContext pigContext, String scope, Map<String, String> fileNameMap,
             IntStream input) {
         this.pigContext = pigContext;
@@ -635,44 +639,46 @@ public class LogicalPlanBuilder {
         op.setInnerFlags( flags );
         alias = buildOp( loc, op, alias, inputAliases, partitioner );
         expandAndResetVisitor(loc, op);
+
         return alias;
     }
-    
-    private String getAbolutePathForLoad(String filename, FuncSpec funcSpec)
-    throws IOException, URISyntaxException {
-        if( funcSpec == null ){
-            funcSpec = new FuncSpec( PigStorage.class.getName() );
-        }
-
-        LoadFunc loFunc = (LoadFunc)PigContext.instantiateFuncFromSpec( funcSpec );
-        String sig = QueryParserUtils.constructFileNameSignature( filename, funcSpec );
-        String absolutePath = fileNameMap.get( sig );
-        if (absolutePath == null) {
-            absolutePath = loFunc.relativeToAbsolutePath( filename, QueryParserUtils.getCurrentDir( pigContext ) );
 
-            if (absolutePath!=null) {
-                QueryParserUtils.setHdfsServers( absolutePath, pigContext );
-            }
-            fileNameMap.put( sig, absolutePath );
-        }
-        
-        return absolutePath;
-    }
-     
     String buildLoadOp(SourceLocation loc, String alias, String filename, FuncSpec funcSpec, LogicalSchema schema)
     throws ParserValidationException {
-        String absolutePath = filename;
+        String absolutePath;
+        LoadFunc loFunc;
         try {
-            absolutePath = getAbolutePathForLoad( filename, funcSpec );
+            FuncSpec instantiatedFuncSpec =
+                    funcSpec == null ?
+                        new FuncSpec(PigStorage.class.getName()) :
+                        funcSpec;
+
+            loFunc = (LoadFunc)PigContext.instantiateFuncFromSpec(instantiatedFuncSpec);
+            String sig = QueryParserUtils.constructFileNameSignature(filename, instantiatedFuncSpec);
+            absolutePath = fileNameMap.get(sig);
+            if (absolutePath == null) {
+                absolutePath = loFunc.relativeToAbsolutePath( filename, QueryParserUtils.getCurrentDir( pigContext ) );
+
+                if (absolutePath!=null) {
+                    QueryParserUtils.setHdfsServers( absolutePath, pigContext );
+                }
+                fileNameMap.put( sig, absolutePath );
+            }
         } catch(Exception ex) {
             throw new ParserValidationException( intStream, loc, ex );
         }
-        
-        FileSpec loader = new FileSpec( absolutePath, funcSpec );
-        LOLoad op = new LOLoad( loader, schema, plan, ConfigurationUtil.toConfiguration( pigContext.getProperties() ) );
+
+        FileSpec loader = new FileSpec(absolutePath, funcSpec);
+        LOLoad op = new LOLoad(
+                loader,
+                schema,
+                plan,
+                ConfigurationUtil.toConfiguration(pigContext.getProperties()),
+                loFunc,
+                alias + "_" + newOperatorKey());
         return buildOp( loc, op, alias, new ArrayList<String>(), null );
     }
-    
+
     private String buildOp(SourceLocation loc, LogicalRelationalOperator op, String alias, 
     		String inputAlias, String partitioner) throws ParserValidationException {
         List<String> inputAliases = new ArrayList<String>();
@@ -699,41 +705,41 @@ public class LogicalPlanBuilder {
         return op.getAlias();
     }
 
-    private String getAbolutePathForStore(String inputAlias, String filename, FuncSpec funcSpec)
-    throws IOException, URISyntaxException {
-        if( funcSpec == null ){
-            funcSpec = new FuncSpec( PigStorage.class.getName() );
-        }
-        
-        Object obj = PigContext.instantiateFuncFromSpec( funcSpec );
-        StoreFuncInterface stoFunc = (StoreFuncInterface)obj;
-        String sig = QueryParserUtils.constructSignature( inputAlias, filename, funcSpec);
-        stoFunc.setStoreFuncUDFContextSignature( sig );
-        String absolutePath = fileNameMap.get( sig );
-        if (absolutePath == null) {
-            absolutePath = stoFunc.relToAbsPathForStoreLocation( filename, 
-                    QueryParserUtils.getCurrentDir( pigContext ) );
-            if (absolutePath!=null) {
-                QueryParserUtils.setHdfsServers( absolutePath, pigContext );
-            }
-            fileNameMap.put( sig, absolutePath );
-        }
-        
-        return absolutePath;
-    }
-
     String buildStoreOp(SourceLocation loc, String alias, String inputAlias, String filename, FuncSpec funcSpec)
     throws ParserValidationException {
-        String absPath = filename;
         try {
-            absPath = getAbolutePathForStore( inputAlias, filename, funcSpec );
+            FuncSpec instantiatedFuncSpec =
+                    funcSpec == null ?
+                            new FuncSpec(PigStorage.class.getName()):
+                            funcSpec;
+
+            StoreFuncInterface stoFunc = (StoreFuncInterface)PigContext.instantiateFuncFromSpec(instantiatedFuncSpec);
+            String sig = inputAlias + "_" + newOperatorKey();
+            stoFunc.setStoreFuncUDFContextSignature(sig);
+            String absolutePath = fileNameMap.get(sig);
+            if (absolutePath == null) {
+                absolutePath = stoFunc.relToAbsPathForStoreLocation(
+                        filename,
+                        QueryParserUtils.getCurrentDir(pigContext));
+                if (absolutePath!=null) {
+                    QueryParserUtils.setHdfsServers(absolutePath, pigContext);
+                }
+                fileNameMap.put(sig, absolutePath);
+            }
+            FileSpec fileSpec = new FileSpec(absolutePath, funcSpec);
+            LOStore op = new LOStore(plan, fileSpec, stoFunc, sig);
+            return buildOp(loc, op, alias, inputAlias, null);
         } catch(Exception ex) {
-            throw new ParserValidationException( intStream, loc, ex );
+            throw new ParserValidationException(intStream, loc, ex);
         }
-        
-        FileSpec fileSpec = new FileSpec( absPath, funcSpec );
-        LOStore op = new LOStore( plan, fileSpec );
-        return buildOp( loc, op, alias, inputAlias, null );
+    }
+
+    private String newOperatorKey() {
+        return new OperatorKey( scope, getNextId() ).toString();
+    }
+    
+    public static String newOperatorKey(String scope) {
+        return new OperatorKey( scope, getNextId(scope)).toString();
     }
     
     LOForEach createForeachOp() {
@@ -983,7 +989,7 @@ public class LogicalPlanBuilder {
     
     void setAlias(LogicalRelationalOperator op, String alias) {
         if( alias == null )
-            alias = new OperatorKey( scope, getNextId() ).toString();
+            alias = newOperatorKey();
         op.setAlias( alias );
     }
     
@@ -1006,17 +1012,17 @@ public class LogicalPlanBuilder {
     }
     
     private void validateFuncSpec(SourceLocation loc, FuncSpec funcSpec, byte ft) throws RecognitionException {
-        switch( ft ) {
+        switch (ft) {
         case FunctionType.COMPARISONFUNC:
         case FunctionType.LOADFUNC:
         case FunctionType.STOREFUNC:
         case FunctionType.STREAMTOPIGFUNC:
         case FunctionType.PIGTOSTREAMFUNC:
-            Object func = PigContext.instantiateFuncFromSpec( funcSpec );
             try{
-                FunctionType.tryCasting( func, ft );
+                Class<?> func = PigContext.resolveClassName(funcSpec.getClassName());
+                FunctionType.tryCasting(func, ft);
             } catch(Exception ex){
-                throw new ParserValidationException( intStream, loc, ex );
+                throw new ParserValidationException(intStream, loc, ex);
             }
         }
     }
@@ -1196,32 +1202,33 @@ public class LogicalPlanBuilder {
     LogicalExpression buildUDF(SourceLocation loc, LogicalExpressionPlan plan,
             String funcName, List<LogicalExpression> args)
     throws RecognitionException {
-        Object func;
+
+        Class<?> func;
         try {
-            func = pigContext.instantiateFuncFromAlias( funcName );
-            FunctionType.tryCasting( func, FunctionType.EVALFUNC );
+            func = pigContext.getClassForAlias(funcName);
+            FunctionType.tryCasting(func, FunctionType.EVALFUNC);
         } catch (Exception e) {
-            throw new PlanGenerationFailureException( intStream, loc, e );
+            throw new PlanGenerationFailureException(intStream, loc, e);
         }
         
-        FuncSpec funcSpec = pigContext.getFuncSpecFromAlias( funcName );
+        FuncSpec funcSpec = pigContext.getFuncSpecFromAlias(funcName);
         LogicalExpression le;
         if( funcSpec == null ) {
-            funcName = func.getClass().getName();
-            funcSpec = new FuncSpec( funcName );
+            funcName = func.getName();
+            funcSpec = new FuncSpec(funcName);
             //this point is only reached if there was no DEFINE statement for funcName
             //in which case, we pass that information along
-            le = new UserFuncExpression( plan, funcSpec, args, false );
+            le = new UserFuncExpression(plan, funcSpec, args, false);
         } else {
-            le = new UserFuncExpression( plan, funcSpec, args, true );
+            le = new UserFuncExpression(plan, funcSpec, args, true);
         }
         
-        le.setLocation( loc );
+        le.setLocation(loc);
         return le;
     }
     
     private long getNextId() {
-        return nodeIdGen.getNextNodeId( scope );
+        return getNextId(scope);
     }
 
     static LOFilter createNestedFilterOp(LogicalPlan plan) {
diff --git a/src/org/apache/pig/parser/QueryParserUtils.java b/src/org/apache/pig/parser/QueryParserUtils.java
index aa5f411de..13a9bae53 100644
--- a/src/org/apache/pig/parser/QueryParserUtils.java
+++ b/src/org/apache/pig/parser/QueryParserUtils.java
@@ -61,7 +61,7 @@ public class QueryParserUtils {
             return str;
     }
 
-    public static void attachStorePlan(LogicalPlan lp, String fileName,    String func, 
+    public static void attachStorePlan(String scope, LogicalPlan lp, String fileName, String func, 
             Operator input, String alias, PigContext pigContext) throws FrontendException {
         if( func == null ) {
             func = PigStorage.class.getName();
@@ -69,12 +69,13 @@ public class QueryParserUtils {
 
         FuncSpec funcSpec = new FuncSpec( func );
         StoreFuncInterface stoFunc = (StoreFuncInterface)PigContext.instantiateFuncFromSpec( funcSpec );
-        stoFunc.setStoreFuncUDFContextSignature( LOStore.constructSignature( alias, fileName, funcSpec ) );
-
+        
         fileName = removeQuotes( fileName );
         FileSpec fileSpec = new FileSpec( fileName, funcSpec );
-        LOStore store = new LOStore( lp, fileSpec );
-        store.setAlias( alias );
+        String sig = alias + "_" + LogicalPlanBuilder.newOperatorKey(scope);
+        stoFunc.setStoreFuncUDFContextSignature(sig);
+        LOStore store = new LOStore(lp, fileSpec, stoFunc, sig);
+        store.setAlias(alias);
 
         try {
             stoFunc.relToAbsPathForStoreLocation( fileName, getCurrentDir( pigContext ) );
@@ -169,14 +170,10 @@ public class QueryParserUtils {
          return fileName + "_" + funcSpec.toString();
      }
 
-     static String constructSignature(String alias, String filename, FuncSpec funcSpec) {
-         return alias + "_" + filename + "_" + funcSpec.toString();
-     }
-     
     static String generateErrorHeader(RecognitionException ex, String filename) {
         return new SourceLocation( filename, ex.line, ex.charPositionInLine ).toString();
     }
-    
+
     @SuppressWarnings({ "unchecked", "rawtypes" })
     static void replaceNodeWithNodeList(Tree oldNode, CommonTree newTree,
             String fileName) {
diff --git a/test/org/apache/pig/TestLoadStoreFuncLifeCycle.java b/test/org/apache/pig/TestLoadStoreFuncLifeCycle.java
new file mode 100644
index 000000000..85425bf2e
--- /dev/null
+++ b/test/org/apache/pig/TestLoadStoreFuncLifeCycle.java
@@ -0,0 +1,369 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig;
+
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.Assert.assertTrue;
+import static org.apache.pig.builtin.mock.Storage.tuple;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.mapreduce.InputFormat;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.OutputFormat;
+import org.apache.hadoop.mapreduce.RecordReader;
+import org.apache.hadoop.mapreduce.RecordWriter;
+import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;
+import org.apache.pig.builtin.mock.Storage;
+import org.apache.pig.builtin.mock.Storage.Data;
+import org.apache.pig.data.Tuple;
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.junit.Test;
+
+public class TestLoadStoreFuncLifeCycle {
+
+    public static String loaderSignature;
+    public static String storerSignature;
+
+    abstract public static class InstrumentedStorage extends Storage implements LoadPushDown {
+
+        protected final int id;
+
+        abstract void incCall();
+
+        private void logCaller(Object... params) {
+            incCall();
+            TestLoadStoreFuncLifeCycle.logCaller(id, this.getClass(), params);
+        }
+
+        public InstrumentedStorage(int id) {
+            super();
+            this.id = id;
+            logCaller();
+        }
+
+        @Override
+        public String relativeToAbsolutePath(String location, Path curDir)
+                throws IOException {
+            logCaller(location, curDir);
+            return super.relativeToAbsolutePath(location, curDir);
+        }
+
+        @Override
+        public void setLocation(String location, Job job) throws IOException {
+            logCaller(location, job);
+            super.setLocation(location, job);
+        }
+
+        @Override
+        public InputFormat<?, ?> getInputFormat() throws IOException {
+            logCaller();
+            return super.getInputFormat();
+        }
+
+        @Override
+        public LoadCaster getLoadCaster() throws IOException {
+            logCaller();
+            return super.getLoadCaster();
+        }
+
+        @Override
+        public void prepareToRead(@SuppressWarnings("rawtypes") RecordReader reader, PigSplit split)
+                throws IOException {
+            logCaller(reader, split);
+            super.prepareToRead(reader, split);
+        }
+
+        @Override
+        public Tuple getNext() throws IOException {
+            logCaller();
+            return super.getNext();
+        }
+
+        @Override
+        public void setUDFContextSignature(String signature) {
+            logCaller(signature);
+            if (TestLoadStoreFuncLifeCycle.loaderSignature == null) {
+                TestLoadStoreFuncLifeCycle.loaderSignature = signature;
+            } else {
+                assertEquals(TestLoadStoreFuncLifeCycle.loaderSignature, signature);
+            }
+            super.setUDFContextSignature(signature);
+        }
+
+        @Override
+        public ResourceSchema getSchema(String location, Job job)
+                throws IOException {
+            logCaller(location, job);
+            return super.getSchema(location, job);
+        }
+
+        @Override
+        public ResourceStatistics getStatistics(String location, Job job)
+                throws IOException {
+            logCaller(location, job);
+            return super.getStatistics(location, job);
+        }
+
+        @Override
+        public String[] getPartitionKeys(String location, Job job)
+                throws IOException {
+            logCaller(location, job);
+            return super.getPartitionKeys(location, job);
+        }
+
+        @Override
+        public void setPartitionFilter(Expression partitionFilter)
+                throws IOException {
+            logCaller(partitionFilter);
+            super.setPartitionFilter(partitionFilter);
+        }
+
+        @Override
+        public List<OperatorSet> getFeatures() {
+            logCaller();
+            return null;
+        }
+
+        @Override
+        public RequiredFieldResponse pushProjection(
+                RequiredFieldList requiredFieldList) throws FrontendException {
+            logCaller(requiredFieldList);
+            return null;
+        }
+
+        @Override
+        public String relToAbsPathForStoreLocation(String location, Path curDir)
+                throws IOException {
+            logCaller(location, curDir);
+            return super.relToAbsPathForStoreLocation(location, curDir);
+        }
+
+        @Override
+        public OutputFormat<?, ?> getOutputFormat() throws IOException {
+            logCaller();
+            return super.getOutputFormat();
+        }
+
+        @Override
+        public void setStoreLocation(String location, Job job) throws IOException {
+            logCaller(location, job);
+            super.setStoreLocation(location, job);
+        }
+
+        @Override
+        public void checkSchema(ResourceSchema s) throws IOException {
+            logCaller(s);
+            super.checkSchema(s);
+        }
+
+        @Override
+        public void prepareToWrite(@SuppressWarnings("rawtypes") RecordWriter writer) throws IOException {
+            logCaller(writer);
+            super.prepareToWrite(writer);
+        }
+
+        @Override
+        public void putNext(Tuple t) throws IOException {
+            logCaller(t);
+            super.putNext(t);
+        }
+
+        @Override
+        public void setStoreFuncUDFContextSignature(String signature) {
+            logCaller(signature);
+            if (TestLoadStoreFuncLifeCycle.storerSignature == null) {
+                TestLoadStoreFuncLifeCycle.storerSignature = signature;
+            } else {
+                assertEquals(TestLoadStoreFuncLifeCycle.storerSignature, signature);
+            }
+            super.setStoreFuncUDFContextSignature(signature);
+        }
+
+        @Override
+        public void cleanupOnFailure(String location, Job job) throws IOException {
+            logCaller(location, job);
+            super.cleanupOnFailure(location, job);
+        }
+
+        @Override
+        public void storeStatistics(ResourceStatistics stats, String location,
+                Job job) throws IOException {
+            logCaller(stats, location, job);
+            super.storeStatistics(stats, location, job);
+        }
+
+        @Override
+        public void storeSchema(ResourceSchema schema, String location, Job job)
+                throws IOException {
+            logCaller(schema, location, job);
+            super.storeSchema(schema, location, job);
+        }
+
+    }
+
+    public static class Loader extends InstrumentedStorage {
+        static int count;
+        static int callCount;
+
+        public Loader() {
+            super(++ count);
+        }
+
+        @Override
+        void incCall() {
+            ++callCount;
+        }
+
+    }
+
+    public static class Storer extends InstrumentedStorage {
+        static int count;
+        static int callCount;
+
+        public Storer() {
+            super(++ count);
+        }
+
+        @Override
+        void incCall() {
+            ++callCount;
+        }
+
+    }
+
+    private static final int MAX_PARAM_SIZE = 70;
+
+    static List<String> calls = new ArrayList<String>();
+    static List<String> constructorCallers = new ArrayList<String>();
+
+    private static void logCaller(int id, Class<?> clazz, Object[] params) {
+        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
+        int i = 0;
+        // skip the stackframes that where after the call to logCaller (included)
+        while (!stackTrace[i].toString().startsWith(InstrumentedStorage.class.getName() + ".logCaller")) {
+            ++i;
+        }
+        StackTraceElement called = stackTrace[i + 1];
+        String calledClass = clazz.getSimpleName();
+
+        String paramsString = null;
+        for (Object param : params) {
+            String paramString = String.valueOf(param);
+            if (paramString.length() > MAX_PARAM_SIZE || paramString.contains("\n")) {
+                int end = paramString.indexOf('\n');
+                if (end == -1 || end > MAX_PARAM_SIZE) {
+                    end = MAX_PARAM_SIZE;
+                }
+                paramString = paramString.substring(0, end) + "...";
+            }
+            if (paramsString == null) {
+                paramsString = "(";
+            } else {
+                paramsString += ", ";
+            }
+            paramsString += paramString;
+        }
+        if (paramsString == null) {
+            paramsString = "()";
+        } else {
+            paramsString += ")";
+        }
+        String call = calledClass + "[" + id + "]." + called.getMethodName();
+        calls.add(call + paramsString /*+ " called by " + findSalient(stackTrace)*/);
+        if (called.getMethodName().equals("<init>")) {
+            constructorCallers.add(call + " called by " + findSalient(stackTrace));
+        }
+    }
+
+    /**
+     * helper method for debugging
+     * @param stackTrace the stack trace of the constructor call
+     * @return the first interesting stack frame of where the constructor was called from
+     */
+    private static String findSalient(StackTraceElement[] stackTrace) {
+        String message = "";
+        int count = 0;
+        // when finding the caller we want to keep only the pig calls to shorten the report
+        for (StackTraceElement el : stackTrace) {
+            String cl = el.getClassName();
+            if (cl.startsWith("org.apache.pig")
+                    && !cl.startsWith(TestLoadStoreFuncLifeCycle.class.getName())
+                    ) {
+                message += "\n" + el.toString();
+                ++ count;
+            }
+            if (count > 15) {
+                break;
+            }
+        }
+
+        return message;
+    }
+
+    @Test
+    public void testLoadStoreFunc() throws Exception {
+        PigServer pigServer = new PigServer(ExecType.LOCAL);
+        Data data = Storage.resetData(pigServer.getPigContext());
+        data.set("foo",
+                tuple("a"),
+                tuple("b"),
+                tuple("c")
+                );
+
+        pigServer.registerQuery(
+                "A = LOAD 'foo' USING " + TestLoadStoreFuncLifeCycle.class.getName() + "$Loader();\n" +
+                        "STORE A INTO 'bar' USING " + TestLoadStoreFuncLifeCycle.class.getName() + "$Storer();");
+
+        List<Tuple> out = data.get("bar");
+
+        assertEquals("a", out.get(0).get(0));
+        assertEquals("b", out.get(1).get(0));
+        assertEquals("c", out.get(2).get(0));
+
+        assertTrue("loader instanciation count increasing: " + Loader.count, Loader.count <= 3);
+        assertTrue("storer instanciation count increasing: " + Storer.count, Storer.count <= 3);
+
+    }
+
+    /**
+     * prints out a report on instantiation sites and method calls
+     */
+    public static void main(String[] args) throws Exception {
+        new TestLoadStoreFuncLifeCycle().testLoadStoreFunc();
+        System.out.println("report:");
+        System.out.println(Loader.count + " instances of Loader");
+        System.out.println(Loader.callCount + " calls to Loader");
+        System.out.println(Storer.count + " instances of Storer");
+        System.out.println(Storer.callCount + " calls to Storer");
+        System.out.println();
+        System.out.println("all calls:");
+        for (String caller : calls) {
+            System.out.println(caller);
+        }
+        System.out.println();
+        System.out.println("constructor calls:");
+        for (String caller : constructorCallers) {
+            System.out.println(caller);
+        }
+    }
+
+}
diff --git a/test/org/apache/pig/newplan/logical/relational/LOTestHelper.java b/test/org/apache/pig/newplan/logical/relational/LOTestHelper.java
new file mode 100644
index 000000000..7ba602f10
--- /dev/null
+++ b/test/org/apache/pig/newplan/logical/relational/LOTestHelper.java
@@ -0,0 +1,12 @@
+package org.apache.pig.newplan.logical.relational;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.pig.LoadFunc;
+import org.apache.pig.impl.PigContext;
+import org.apache.pig.impl.io.FileSpec;
+
+public class LOTestHelper {
+    public static LOLoad newLOLoad(FileSpec loader, LogicalSchema schema, LogicalPlan plan, Configuration conf) {
+        return new LOLoad(loader, schema, plan, conf, (LoadFunc)PigContext.instantiateFuncFromSpec(loader.getFuncSpec()), null);
+    }
+}
diff --git a/test/org/apache/pig/parser/TestScalarVisitor.java b/test/org/apache/pig/parser/TestScalarVisitor.java
index b37c84851..17ea3c8cd 100644
--- a/test/org/apache/pig/parser/TestScalarVisitor.java
+++ b/test/org/apache/pig/parser/TestScalarVisitor.java
@@ -88,7 +88,7 @@ public class TestScalarVisitor {
         LogicalPlan plan = ParserTestingUtils.generateLogicalPlan( query );
         PigContext pc = new PigContext( ExecType.LOCAL, new Properties() );
         pc.connect();
-        ScalarVisitor visitor = new ScalarVisitor( plan, pc );
+        ScalarVisitor visitor = new ScalarVisitor(plan, pc, "test");
         visitor.visit();
         return plan;
     }
diff --git a/test/org/apache/pig/test/TestInputOutputFileValidator.java b/test/org/apache/pig/test/TestInputOutputFileValidator.java
index 01fcea59f..7b2fd1b0b 100644
--- a/test/org/apache/pig/test/TestInputOutputFileValidator.java
+++ b/test/org/apache/pig/test/TestInputOutputFileValidator.java
@@ -17,6 +17,8 @@
  */
 package org.apache.pig.test;
 
+import static org.apache.pig.newplan.logical.relational.LOTestHelper.newLOLoad;
+
 import java.io.* ;
 import java.util.Iterator;
 import java.util.Properties;
@@ -26,6 +28,7 @@ import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
 import org.apache.pig.PigServer;
 import org.apache.pig.ResourceSchema;
+import org.apache.pig.StoreFuncInterface;
 import org.apache.pig.backend.datastorage.DataStorage;
 import org.apache.pig.backend.datastorage.ElementDescriptor;
 import org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;
@@ -243,9 +246,9 @@ public class TestInputOutputFileValidator extends TestCase {
             new FileSpec(inputFile, new FuncSpec("org.apache.pig.builtin.PigStorage")) ;
         FileSpec filespec2 =
             new FileSpec(outputFile, new FuncSpec("org.apache.pig.builtin.PigStorage"));
-        LOLoad load = new LOLoad( filespec1, null, plan,
+        LOLoad load = newLOLoad( filespec1, null, plan,
                 ConfigurationUtil.toConfiguration(dfs.getConfiguration())) ;       
-        LOStore store = new LOStore(plan, filespec2) ;
+        LOStore store = new LOStore(plan, filespec2, (StoreFuncInterface)PigContext.instantiateFuncFromSpec(filespec2.getFuncSpec()), null) ;
         
         plan.add(load) ;
         plan.add(store) ;
diff --git a/test/org/apache/pig/test/TestLoad.java b/test/org/apache/pig/test/TestLoad.java
index df1f4def4..a34e2bbb9 100644
--- a/test/org/apache/pig/test/TestLoad.java
+++ b/test/org/apache/pig/test/TestLoad.java
@@ -164,7 +164,7 @@ public class TestLoad extends junit.framework.TestCase {
     @Test
     public void testLoadRemoteAbsAuth() throws Exception {
         pc = servers[0].getPigContext();
-        checkLoadPath("hdfs://localhost:9000/test","/test");
+        checkLoadPath(cluster.getFileSystem().getUri()+"/test","/test");
     }
 
     @Test
diff --git a/test/org/apache/pig/test/TestLogToPhyCompiler.java b/test/org/apache/pig/test/TestLogToPhyCompiler.java
index 584c46a61..a7b1cc017 100644
--- a/test/org/apache/pig/test/TestLogToPhyCompiler.java
+++ b/test/org/apache/pig/test/TestLogToPhyCompiler.java
@@ -20,13 +20,16 @@ package org.apache.pig.test;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Properties;
 import java.util.Random;
 
+import org.apache.commons.lang.CharSet;
 import org.apache.pig.ExecType;
 import org.apache.pig.PigServer;
 import org.apache.pig.SortColInfo;
@@ -45,15 +48,9 @@ import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.junit.Test;
 
 /**
- * All new tests should be included at the end of the existing test cases. This is to ensure that 
- * nodeIdGenerator produces the same sequence as in the golden files for the previously existing test cases 
  * 
- * To generate golden files, use the following code :
- * ByteArrayOutputStream baos = new ByteArrayOutputStream();
- * pp.explain(baos);
- * FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Union.gld");
- * fos.write(baos.toByteArray());
- *
+ * To generate golden files, update generate to true
+ * 
  */
 public class TestLogToPhyCompiler extends junit.framework.TestCase {
     File A;
@@ -65,6 +62,7 @@ public class TestLogToPhyCompiler extends junit.framework.TestCase {
     private boolean generate = false;
     
     PigServer pigServer = null;
+    private static final int MAX_SIZE = 100000;;
    
     
     @Override
@@ -73,335 +71,163 @@ public class TestLogToPhyCompiler extends junit.framework.TestCase {
         pc.connect();
     }
     
-    @Test // Commented out due to PIG-2020
-    public void testComplexForeach() throws Exception {
-    	String query = "C = foreach (load 'a' as  (a:bag{} ) ) {" +
-        "B = FILTER $0 BY ($1 == $2);" +
-        "generate B;" +
-        "};" + "store C into 'output';";
-        LogicalPlan plan = buildPlan(query);
-    	PhysicalPlan pp = buildPhysicalPlan(plan); 
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
+    private String compilePlan(String query, String goldenFile, boolean checkOneLeaf)
+            throws Exception, FrontendException, FileNotFoundException,
+            IOException {
+        LogicalPlan lp = buildPlan(query);
+        PhysicalPlan pp = buildPhysicalPlan(lp);
         
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld");
-            fos.write(baos.toByteArray());
-            return;
+        if (checkOneLeaf) {
+          //Ensure that there is only 1 leaf node
+            assertEquals(1, pp.getLeaves().size());
         }
         
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testComplexForeach");
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
-    }
-        
-    public void testSort() throws Exception {
-    	String query = "store (order (load 'a') by $0) into 'output';";
-    	LogicalPlan plan = buildPlan(query);
-    	PhysicalPlan pp = buildPhysicalPlan(plan);
-
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
         pp.explain(baos);
         baos.write((int)'\n');
         String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
+        compiledPlan = removedUnaffectingChanges(compiledPlan);
 
+        generateGolden(goldenFile, compiledPlan);
+        return compiledPlan;
+    }
+
+    private void generateGolden(String goldenFile, String data)
+            throws FileNotFoundException, IOException {
         if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Sort.gld");
-            fos.write(baos.toByteArray());
-            return;
+            FileOutputStream fos = new FileOutputStream(goldenFile);
+            fos.write(data.getBytes("UTF-8"));
+            fos.close();
         }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Sort.gld");
+    }
+
+    private String readGolden(int MAX_SIZE, String goldenFile)
+            throws FileNotFoundException, IOException {
+        FileInputStream fis = new FileInputStream(goldenFile);
         byte[] b = new byte[MAX_SIZE];
         int len = fis.read(b);
+        fis.close();
         String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
+        goldenPlan = removedUnaffectingChanges(goldenPlan);
+        return goldenPlan;
+    }
 
+    private String removedUnaffectingChanges(String compiledPlan) {
+        return compiledPlan
+                .replaceAll("test-[0-9]*: ","test-: ")
+                .replaceAll("Load(.*)","Load()")
+                .replaceAll("Store(.*)","Store()")
+                .replaceAll("scope-[0-9]*\\n", "\n");
+    }
+    
+    private void checkAgainstGolden(String query, String goldenFile,
+            boolean checkOneLeaf, String testName) throws Exception, FrontendException,
+            FileNotFoundException, IOException {
+        goldenFile = "test/org/apache/pig/test/data/GoldenFiles/" + goldenFile;
+        String compiledPlan = compilePlan(query, goldenFile, checkOneLeaf);
+        String goldenPlan = readGolden(MAX_SIZE, goldenFile);
         System.out.println();
         System.out.println(compiledPlan);
-        System.out.println("-------------testSort");
-        
+        System.out.println("-------------" + testName);
         assertEquals(compiledPlan, goldenPlan);
     }
+    
+    @Test // Commented out due to PIG-2020
+    public void testComplexForeach() throws Exception {
+        checkAgainstGolden(
+                "C = foreach (load 'a' as  (a:bag{} ) ) {" +
+                "B = FILTER $0 BY ($1 == $2);" +
+                "generate B;" +
+                "};" + 
+                "store C into 'output';", 
+                "ComplexForeach.gld", 
+                false, 
+                "testComplexForeach");
+    }
+ 
+    public void testSort() throws Exception {
+        checkAgainstGolden(
+                "store (order (load 'a') by $0) into 'output';", 
+                "Sort.gld", 
+                false, 
+                "testSort");
+    }
+
         
     public void testDistinct() throws Exception {
-    	String query = "store( distinct (load 'a') ) into 'output';";
-    	LogicalPlan plan = buildPlan(query);
-    	PhysicalPlan pp = buildPhysicalPlan(plan);
-    	
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-        
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Distinct.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Distinct.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testDistinct");
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+                "store( distinct (load 'a') ) into 'output';", 
+                "Distinct.gld", 
+                false, 
+                "testDistinct");
     }
     
     public void testCogroup() throws Exception {
-        System.out.println("testCogroup");
-    	String query = "A = cogroup (load 'a') by ($0 + $1, $0 - $1), (load 'b') by ($0 + $1, $0 - $1);"
-    		+ "store A into 'output';";
-    	LogicalPlan plan = buildPlan(query);
-    	PhysicalPlan pp = buildPhysicalPlan(plan);
-    	
-    	
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-        
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Cogroup.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Cogroup.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------");
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+              "A = cogroup (load 'a') by ($0 + $1, $0 - $1), (load 'b') by ($0 + $1, $0 - $1);" +
+              "store A into 'output';", 
+              "Cogroup.gld", 
+              false, 
+              "testCogroup");
     }
     
     public void testArithmetic() throws Exception {
-    	
-    	String query = "A = foreach (load 'A') generate $0 + $1 + 5, $0 - 5 - $1, 'hello';" +
-    	"store A into 'output';";
-    	LogicalPlan lp = buildPlan(query);
-    	
-    	PhysicalPlan pp = buildPhysicalPlan(lp);
-    	
-        //Ensure that there is only 1 leaf node
-    	assertEquals(1, pp.getLeaves().size());
-    	
-    	
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Arithmetic.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Arithmetic.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------");
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+                "A = foreach (load 'A') generate $0 + $1 + 5, $0 - 5 - $1, 'hello';" +
+                "store A into 'output';", 
+                "Arithmetic.gld", 
+                true, 
+                "testArithmetic");
     }
-    
-    public void testComparison() throws Exception {
-    	String query = "A = filter (load 'a' using " + PigStorage.class.getName() + "(':')) by $0 + $1 > ($0 - $1) * (4 / 2);" +
-    	"store A into 'output';";
-    	LogicalPlan lp = buildPlan(query);
-    	PhysicalPlan pp = buildPhysicalPlan(lp);
-    	
-        //Ensure that there is only 1 leaf node
-    	assertEquals(1, pp.getLeaves().size());
-    	
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-        
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Comparison.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Comparison.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
 
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testComparison");
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
+    public void testComparison() throws Exception {
+        checkAgainstGolden(
+                "A = filter (load 'a' using " + PigStorage.class.getName() + "(':')) by $0 + $1 > ($0 - $1) * (4 / 2);" +
+                "store A into 'output';", 
+                "Comparison.gld", 
+                true, 
+                "testComparison");
     }
 
     @Test
     public void testBinCond() throws Exception {
-        String query = "A = foreach (load 'a') generate ($1 == '3'? $2 + $3 : $2 - $3) ;" +
-    	"store A into 'output';";
-        LogicalPlan lp = buildPlan(query);
-
-        PhysicalPlan pp = buildPhysicalPlan(lp);
-
-        
-        int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/BinCond.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/BinCond.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testBinCond");
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+                "A = foreach (load 'a') generate ($1 == '3'? $2 + $3 : $2 - $3) ;" +
+                "store A into 'output';", 
+                "BinCond.gld", 
+                false, 
+                "testBinCond");
     }
-    
-    
+
     @Test
     public void testGenerate() throws Exception {
-        String query = "A = foreach (load 'a') generate ($1+$2), ($1-$2), ($1*$2), ($1/$2), ((int)$1%(int)$2), -($1) ;" +
-    	"store A into 'output';";
-        LogicalPlan lp = buildPlan(query);
-
-        PhysicalPlan pp = buildPhysicalPlan(lp);
-
-        
-        int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Generate.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Generate.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testGenerate");
-        
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+                "A = foreach (load 'a') generate ($1+$2), ($1-$2), ($1*$2), ($1/$2), ((int)$1%(int)$2), -($1) ;" +
+                "store A into 'output';", 
+                "Generate.gld", 
+                false, 
+                "testGenerate");
     }
 
     @Test
     public void testUnion() throws Exception {
-    	String query = "A = union (load 'a'), (load 'b'), (load 'c');" +
-    	"store A into 'output';";
-    	LogicalPlan lp = buildPlan(query);
-    	PhysicalPlan pp = buildPhysicalPlan(lp);
-    	
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Union.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-    	FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Union.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testUnion");
-        
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+                "A = union (load 'a'), (load 'b'), (load 'c');" +
+                        "store A into 'output';", 
+                        "Union.gld", 
+                        false, 
+                "testUnion");
     }
     
     @Test
     public void testSplit() throws Exception {
     	String query = "split (load 'a') into x if $0 < '7', y if $0 > '7';"  +
     	"store x into 'output';";
-    	LogicalPlan plan = buildPlan(query);
-    	
-    	PhysicalPlan pp = buildPhysicalPlan(plan);
+    	String goldenFile = "test/org/apache/pig/test/data/GoldenFiles/Split1.gld";
     	
-    	int MAX_SIZE = 100000;
-    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Split1.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
+    	String compiledPlan = compilePlan(query, goldenFile, false);
         
-    	FileInputStream fis1 = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Split1.gld");
+    	FileInputStream fis1 = new FileInputStream(goldenFile);
     	FileInputStream fis2 = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Split2.gld");
         byte[] b1 = new byte[MAX_SIZE];
         byte[] b2 = new byte[MAX_SIZE];
@@ -410,8 +236,8 @@ public class TestLogToPhyCompiler extends junit.framework.TestCase {
         //System.out.println("Length of first plan = " + len + " of second = " + test);
         String goldenPlan1 = new String(b1, 0, len);
         String goldenPlan2 = new String(b2, 0, len);
-        goldenPlan1 = goldenPlan1.replaceAll("Load(.*)","Load()");
-        goldenPlan2 = goldenPlan2.replaceAll("Load(.*)","Load()");
+        goldenPlan1 = removedUnaffectingChanges(goldenPlan1);
+        goldenPlan2 = removedUnaffectingChanges(goldenPlan2);
 
         System.out.println();
         System.out.println(compiledPlan);
@@ -444,17 +270,15 @@ public class TestLogToPhyCompiler extends junit.framework.TestCase {
     	
     	PhysicalPlan pp = buildPhysicalPlan(plan);
     	
-    	int MAX_SIZE = 100000;
     	ByteArrayOutputStream baos = new ByteArrayOutputStream();
         pp.explain(baos);
         baos.write((int)'\n');
         String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
+        compiledPlan = removedUnaffectingChanges(compiledPlan);
 
         if(generate){
             FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/IsNull1.gld");
             fos.write(baos.toByteArray());
-            return;
         }
         
     	FileInputStream fis1 = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/IsNull1.gld");
@@ -466,8 +290,8 @@ public class TestLogToPhyCompiler extends junit.framework.TestCase {
         //System.out.println("Length of first plan = " + len + " of second = " + test + " Length of compiled plan = " + compiledPlan.length());
         String goldenPlan1 = new String(b1, 0, len);
         String goldenPlan2 = new String(b2, 0, len);
-        goldenPlan1 = goldenPlan1.replaceAll("Load(.*)","Load()");
-        goldenPlan2 = goldenPlan2.replaceAll("Load(.*)","Load()");
+        goldenPlan1 = removedUnaffectingChanges(goldenPlan1);
+        goldenPlan2 = removedUnaffectingChanges(goldenPlan2);
 
         System.out.println();
         System.out.println(compiledPlan);
@@ -491,35 +315,11 @@ public class TestLogToPhyCompiler extends junit.framework.TestCase {
 
     @Test
     public void testLimit() throws Exception {
-        String query = "store( limit (load 'a') 5 ) into 'output';";
-        LogicalPlan plan = buildPlan(query);
-        PhysicalPlan pp = buildPhysicalPlan(plan);
-
-        int MAX_SIZE = 100000;
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        pp.explain(baos);
-        baos.write((int)'\n');
-        String compiledPlan = baos.toString();
-        compiledPlan = compiledPlan.replaceAll("Load(.*)","Load()").replaceAll("Store(.*)","Store()");
-
-        if(generate){
-            FileOutputStream fos = new FileOutputStream("test/org/apache/pig/test/data/GoldenFiles/Limit.gld");
-            fos.write(baos.toByteArray());
-            return;
-        }
-        
-        FileInputStream fis = new FileInputStream("test/org/apache/pig/test/data/GoldenFiles/Limit.gld");
-        byte[] b = new byte[MAX_SIZE];
-        int len = fis.read(b);
-        String goldenPlan = new String(b, 0, len);
-        goldenPlan = goldenPlan.replaceAll("Load(.*)","Load()");
-
-        System.out.println();
-        System.out.println(compiledPlan);
-        System.out.println("-------------testLimit");
-
-        //System.out.println(compiledPlan.compareTo(goldenPlan)==0);
-        assertEquals(compiledPlan, goldenPlan);
+        checkAgainstGolden(
+                "store( limit (load 'a') 5 ) into 'output';", 
+                "Limit.gld", 
+                false, 
+                "testLimit");
     }
 
     /**
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index c0ded418b..5068dfd5b 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -2084,14 +2084,17 @@ public class TestLogicalPlanBuilder {
         LogicalPlan plan = buildPlan( query );
         Operator op = plan.getSinks().get(0);
         LOLoad load = (LOLoad)plan.getPredecessors(op).get(0);
-        Assert.assertTrue(((PigStorageWithSchema)(load).getLoadFunc()).getUDFContextSignature().equals("a"));
+        // the signature is now a unique string of the format "{alias}_{scope id}-{id}" example: "a_12-0"
+        String udfContextSignature = ((PigStorageWithSchema)(load).getLoadFunc()).getUDFContextSignature();
+        Assert.assertTrue(udfContextSignature, udfContextSignature.matches("a_[0-9]*-[0-9]*"));
         
         query = " b = load '1.txt' using org.apache.pig.test.PigStorageWithSchema();" +
                 "store b into 'output';";
         plan = buildPlan(query);
         op = plan.getSinks().get(0);
         load = (LOLoad)plan.getPredecessors(op).get(0);
-        Assert.assertTrue(((PigStorageWithSchema)(load).getLoadFunc()).getUDFContextSignature().equals("b"));
+        udfContextSignature = ((PigStorageWithSchema)(load).getLoadFunc()).getUDFContextSignature();
+        Assert.assertTrue(udfContextSignature, udfContextSignature.matches("b_[0-9]*-[0-9]*"));
     }
     
     @Test
diff --git a/test/org/apache/pig/test/TestMRCompiler.java b/test/org/apache/pig/test/TestMRCompiler.java
index 1e0426d36..537815b8a 100644
--- a/test/org/apache/pig/test/TestMRCompiler.java
+++ b/test/org/apache/pig/test/TestMRCompiler.java
@@ -1077,7 +1077,17 @@ public class TestMRCompiler extends junit.framework.TestCase {
         System.out.println("Golden");
         System.out.println("<<<" + goldenPlan + ">>>");
         System.out.println("-------------");
-        assertEquals(goldenPlan, compiledPlan);
+        assertEquals(removeSignature(goldenPlan), removeSignature(compiledPlan));
+    }
+
+    /**
+     * this removes the signature from the serialized plan
+     * changing the way the unique signature is generated should not break this test
+     * @param plan the plan to canonicalize
+     * @return the cleaned up plan
+     */
+    private String removeSignature(String plan) {
+        return plan.replaceAll("','','[^']*','scope','true'\\)\\)", "','','','scope','true'))");
     }
 
     public static class TestCollectableLoadFunc extends PigStorage implements CollectableLoadFunc {
diff --git a/test/org/apache/pig/test/TestNewPlanFilterRule.java b/test/org/apache/pig/test/TestNewPlanFilterRule.java
index c7d4ed401..088eeb910 100644
--- a/test/org/apache/pig/test/TestNewPlanFilterRule.java
+++ b/test/org/apache/pig/test/TestNewPlanFilterRule.java
@@ -80,7 +80,7 @@ public class TestNewPlanFilterRule {
         schema.getField(0).uid = 1;
         schema.getField(1).uid = 2;
         schema.getField(2).uid = 3;
-        LogicalRelationalOperator l1 = new LOLoad(null, schema, plan, null);
+        LogicalRelationalOperator l1 = new LOLoad(schema, plan);
         l1.setAlias("A");
         plan.add(l1);
 
@@ -91,7 +91,7 @@ public class TestNewPlanFilterRule {
         schema.getField(0).uid = 4;
         schema.getField(1).uid = 5;
         schema.getField(2).uid = 6;
-        LogicalRelationalOperator l2 = new LOLoad(null, schema, plan, null);
+        LogicalRelationalOperator l2 = new LOLoad(schema, plan);
         l2.setAlias("B");
         plan.add(l2);
         
@@ -125,7 +125,7 @@ public class TestNewPlanFilterRule {
         f1.setAlias("D");
         plan.add(f1);
         
-        LogicalRelationalOperator s1 = new LOStore(plan);
+        LogicalRelationalOperator s1 = new LOStore(plan, null, null, null);
         plan.add(s1);       
         
         // load --|-join - filter - store
diff --git a/test/org/apache/pig/test/TestNewPlanListener.java b/test/org/apache/pig/test/TestNewPlanListener.java
index daf3bc219..77011826c 100644
--- a/test/org/apache/pig/test/TestNewPlanListener.java
+++ b/test/org/apache/pig/test/TestNewPlanListener.java
@@ -79,7 +79,7 @@ public class TestNewPlanListener extends TestCase {
         aschema.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
         aschema.getField(0).uid = 1;
-        LOLoad A = new LOLoad(null, null, lp, null);
+        LOLoad A = new LOLoad(null, lp);
         A.neverUseForRealSetSchema(aschema);
         lp.add(A);
         
@@ -88,7 +88,7 @@ public class TestNewPlanListener extends TestCase {
         bschema.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
         bschema.getField(0).uid = 2;
-        LOLoad B = new LOLoad(null, null, lp, null);
+        LOLoad B = new LOLoad(null, lp);
         B.neverUseForRealSetSchema(bschema);
         lp.add(B);
         
diff --git a/test/org/apache/pig/test/TestNewPlanLogicalOptimizer.java b/test/org/apache/pig/test/TestNewPlanLogicalOptimizer.java
index 7fe1b10ae..5eb841d03 100644
--- a/test/org/apache/pig/test/TestNewPlanLogicalOptimizer.java
+++ b/test/org/apache/pig/test/TestNewPlanLogicalOptimizer.java
@@ -17,6 +17,8 @@
  */
 package org.apache.pig.test;
 
+import static org.apache.pig.newplan.logical.relational.LOTestHelper.newLOLoad;
+
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
@@ -84,7 +86,7 @@ public class TestNewPlanLogicalOptimizer {
             	"x", null, DataType.BYTEARRAY));
         	aschema.addField(new LogicalSchema.LogicalFieldSchema(
             	"y", null, DataType.BYTEARRAY));
-        	LOLoad A = new LOLoad(new FileSpec("bla", new FuncSpec("PigStorage", "\t")), aschema, lp, conf);
+        	LOLoad A = newLOLoad(new FileSpec("bla", new FuncSpec("PigStorage", "\t")), aschema, lp, conf);
         	A.setAlias("A");
         	lp.add(A);
 	        
@@ -94,7 +96,7 @@ public class TestNewPlanLogicalOptimizer {
             	"a", null, DataType.BYTEARRAY));
         	bschema.addField(new LogicalSchema.LogicalFieldSchema(
             	"b", null, DataType.BYTEARRAY));
-        	LOLoad B = new LOLoad(new FileSpec("morebla", new FuncSpec("PigStorage", "\t")), bschema, lp, conf);
+        	LOLoad B = newLOLoad(new FileSpec("morebla", new FuncSpec("PigStorage", "\t")), bschema, lp, conf);
         	B.setAlias("B");
         	lp.add(B);
 	        
@@ -160,7 +162,7 @@ public class TestNewPlanLogicalOptimizer {
             	"x", null, DataType.BYTEARRAY));
         	aschema.addField(new LogicalSchema.LogicalFieldSchema(
             	"y", null, DataType.BYTEARRAY));
-        	LOLoad A = new LOLoad(new FileSpec("bla", new FuncSpec("PigStorage", "\t")), aschema, expected, conf);
+        	LOLoad A = newLOLoad(new FileSpec("bla", new FuncSpec("PigStorage", "\t")), aschema, expected, conf);
         	expected.add(A);
         	
         	// DA = filter
@@ -186,7 +188,7 @@ public class TestNewPlanLogicalOptimizer {
             	"a", null, DataType.BYTEARRAY));
         	bschema.addField(new LogicalSchema.LogicalFieldSchema(
             	"b", null, DataType.BYTEARRAY));
-        	LOLoad B = new LOLoad(new FileSpec("morebla", new FuncSpec("PigStorage", "\t")), bschema, expected, conf);
+        	LOLoad B = newLOLoad(new FileSpec("morebla", new FuncSpec("PigStorage", "\t")), bschema, expected, conf);
         	expected.add(B);
         	
         	// DB = filter
diff --git a/test/org/apache/pig/test/TestNewPlanOperatorPlan.java b/test/org/apache/pig/test/TestNewPlanOperatorPlan.java
index 18130330d..42bbd3280 100644
--- a/test/org/apache/pig/test/TestNewPlanOperatorPlan.java
+++ b/test/org/apache/pig/test/TestNewPlanOperatorPlan.java
@@ -18,10 +18,14 @@
 
 package org.apache.pig.test;
 
+import static org.apache.pig.newplan.logical.relational.LOTestHelper.newLOLoad;
+
 import java.util.Collection;
 import java.util.List;
 import java.util.Properties;
 
+import junit.framework.TestCase;
+
 import org.apache.hadoop.conf.Configuration;
 import org.apache.pig.ExecType;
 import org.apache.pig.FuncSpec;
@@ -50,18 +54,14 @@ import org.apache.pig.newplan.logical.expression.LogicalExpressionVisitor;
 import org.apache.pig.newplan.logical.expression.ProjectExpression;
 import org.apache.pig.newplan.logical.relational.LOFilter;
 import org.apache.pig.newplan.logical.relational.LOJoin;
+import org.apache.pig.newplan.logical.relational.LOJoin.JOINTYPE;
 import org.apache.pig.newplan.logical.relational.LOLoad;
-import org.apache.pig.newplan.logical.relational.LOSplit;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
-import org.apache.pig.newplan.logical.relational.LOJoin.JOINTYPE;
-import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
 import org.junit.Before;
 import org.junit.Test;
 
-import junit.framework.TestCase;
-
 public class TestNewPlanOperatorPlan extends TestCase {
     
     private static class SillyPlan extends BaseOperatorPlan {
@@ -706,7 +706,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
     @Test
     public void testLogicalPlanVisitor() throws FrontendException {
         LogicalPlan lp = new LogicalPlan();
-        LOLoad load = new LOLoad(null, null, lp, conf);
+        LOLoad load = newLOLoad(null, null, lp, conf);
         /*lp.add((LogicalRelationalOperator)null, load,
             (LogicalRelationalOperator)null);*/
         lp.add(load);
@@ -834,7 +834,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             LogicalSchema aschema = new LogicalSchema();
             aschema.addField(new LogicalSchema.LogicalFieldSchema(
                 "x", null, DataType.INTEGER));
-            LOLoad A = new LOLoad(new FileSpec("/abc",
+            LOLoad A = newLOLoad(new FileSpec("/abc",
                 new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema, lp, conf);
             lp.add(A);
         
@@ -842,7 +842,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             LogicalSchema bschema = new LogicalSchema();
             bschema.addField(new LogicalSchema.LogicalFieldSchema(
                 "y", null, DataType.INTEGER));
-            LOLoad B = new LOLoad(new FileSpec("/def",
+            LOLoad B = newLOLoad(new FileSpec("/def",
                 new FuncSpec("PigStorage", "\t")), bschema, lp, conf);
             lp.add(B);
         
@@ -884,7 +884,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             LogicalSchema aschema = new LogicalSchema();
             aschema.addField(new LogicalSchema.LogicalFieldSchema(
                 "x", null, DataType.INTEGER));
-            LOLoad A = new LOLoad(new FileSpec("/abc",
+            LOLoad A = newLOLoad(new FileSpec("/abc",
                 new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema, lp1, conf);
             lp1.add(A);
             
@@ -892,7 +892,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             LogicalSchema bschema = new LogicalSchema();
             bschema.addField(new LogicalSchema.LogicalFieldSchema(
                 "y", null, DataType.INTEGER));
-            LOLoad B = new LOLoad(new FileSpec("/def",
+            LOLoad B = newLOLoad(new FileSpec("/def",
                 new FuncSpec("PigStorage", "\t")), bschema, lp1, conf);
             lp1.add(B);
             
@@ -939,11 +939,11 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad load1 = new LOLoad(new FileSpec("/abc",
+        LOLoad load1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp, conf);
         lp.add(load1);
         
-        LOLoad load2 = new LOLoad(new FileSpec("/abc",
+        LOLoad load2 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "z"})), aschema1, lp, conf);
         lp.add(load2);
         
@@ -957,11 +957,11 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad load1 = new LOLoad(new FileSpec("/abc",
+        LOLoad load1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp, conf);
         lp.add(load1);
         
-        LOLoad load3 = new LOLoad(new FileSpec("/abc",
+        LOLoad load3 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), "x")), aschema1, lp, conf);
         lp.add(load3);
         
@@ -975,12 +975,12 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad load1 = new LOLoad(new FileSpec("/abc",
+        LOLoad load1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp, conf);
         lp.add(load1);
         
          // Different function names in FuncSpec
-        LOLoad load4 = new LOLoad(new FileSpec("/abc",
+        LOLoad load4 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "z"})), aschema1, lp, conf);
         lp.add(load4);
         
@@ -993,12 +993,12 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad load1 = new LOLoad(new FileSpec("/abc",
+        LOLoad load1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp, conf);
         lp.add(load1);
     
         // Different file name
-        LOLoad load5 = new LOLoad(new FileSpec("/def",
+        LOLoad load5 = newLOLoad(new FileSpec("/def",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "z"})), aschema1, lp, conf);
         lp.add(load5);
         
@@ -1011,7 +1011,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad load1 = new LOLoad(new FileSpec("/abc",
+        LOLoad load1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp, conf);
         lp.add(load1);
         
@@ -1020,7 +1020,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         aschema2.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.CHARARRAY));
         
-        LOLoad load6 = new LOLoad(new FileSpec("/abc",
+        LOLoad load6 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "z"})), aschema2, lp, conf);
         lp.add(load6);
             
@@ -1031,11 +1031,11 @@ public class TestNewPlanOperatorPlan extends TestCase {
     public void testRelationalEqualityNullSchemas() throws FrontendException {
         LogicalPlan lp = new LogicalPlan();
         // Test that two loads with no schema are still equal
-        LOLoad load7 = new LOLoad(new FileSpec("/abc",
+        LOLoad load7 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), null, lp, conf);
         lp.add(load7);
         
-        LOLoad load8 = new LOLoad(new FileSpec("/abc",
+        LOLoad load8 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), null, lp, conf);
         lp.add(load8);
         
@@ -1048,12 +1048,12 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad load1 = new LOLoad(new FileSpec("/abc",
+        LOLoad load1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp, conf);
         lp.add(load1);
         
         // Test that one with schema and one without breaks equality
-        LOLoad load9 = new LOLoad(new FileSpec("/abc",
+        LOLoad load9 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "z"})), null, lp, conf);
         lp.add(load9);
         
@@ -1099,7 +1099,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
        LogicalSchema jaschema1 = new LogicalSchema();
        jaschema1.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-       LOLoad A1 = new LOLoad(new FileSpec("/abc",
+       LOLoad A1 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema1, lp, conf);
        lp.add(A1);
         
@@ -1107,7 +1107,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbschema1 = new LogicalSchema();
         jbschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad B1 = new LOLoad(new FileSpec("/def",
+        LOLoad B1 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema1, lp, conf);
         lp.add(B1);
         
@@ -1135,7 +1135,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema2 = new LogicalSchema();
         jaschema2.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A2 = new LOLoad(new FileSpec("/abc",
+        LOLoad A2 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema2, lp, conf);
         lp.add(A2);
         
@@ -1143,7 +1143,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbschema2 = new LogicalSchema();
         jbschema2.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad B2 = new LOLoad(new FileSpec("/def",
+        LOLoad B2 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema2, lp, conf);
         lp.add(B2);
         
@@ -1176,7 +1176,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
                LogicalSchema jaschema1 = new LogicalSchema();
        jaschema1.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-       LOLoad A1 = new LOLoad(new FileSpec("/abc",
+       LOLoad A1 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema1, lp, conf);
        lp.add(A1);
         
@@ -1184,7 +1184,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbschema1 = new LogicalSchema();
         jbschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad B1 = new LOLoad(new FileSpec("/def",
+        LOLoad B1 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema1, lp, conf);
         lp.add(B1);
         
@@ -1214,7 +1214,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema3 = new LogicalSchema();
         jaschema3.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A3 = new LOLoad(new FileSpec("/abc",
+        LOLoad A3 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema3, lp, conf);
         lp.add(A3);
         
@@ -1222,7 +1222,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbschema3 = new LogicalSchema();
         jbschema3.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad B3 = new LOLoad(new FileSpec("/def",
+        LOLoad B3 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema3, lp, conf);
         lp.add(B3);
         
@@ -1256,7 +1256,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
                LogicalSchema jaschema1 = new LogicalSchema();
        jaschema1.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-       LOLoad A1 = new LOLoad(new FileSpec("/abc",
+       LOLoad A1 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema1, lp, conf);
        lp.add(A1);
         
@@ -1264,7 +1264,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbschema1 = new LogicalSchema();
         jbschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad B1 = new LOLoad(new FileSpec("/def",
+        LOLoad B1 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema1, lp, conf);
         lp.add(B1);
         
@@ -1292,7 +1292,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema5 = new LogicalSchema();
         jaschema5.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A5 = new LOLoad(new FileSpec("/abc",
+        LOLoad A5 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema5, lp, conf);
         lp.add(A5);
         
@@ -1300,7 +1300,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbschema5 = new LogicalSchema();
         jbschema5.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad B5 = new LOLoad(new FileSpec("/def",
+        LOLoad B5 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema5, lp, conf);
         lp.add(B5);
         
@@ -1308,7 +1308,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jbetaschema5 = new LogicalSchema();
         jbetaschema5.addField(new LogicalSchema.LogicalFieldSchema(
             "y", null, DataType.INTEGER));
-        LOLoad Beta5 = new LOLoad(new FileSpec("/ghi",
+        LOLoad Beta5 = newLOLoad(new FileSpec("/ghi",
             new FuncSpec("PigStorage", "\t")), jbetaschema5, lp, conf);
         lp.add(Beta5);
         
@@ -1347,7 +1347,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema6 = new LogicalSchema();
         jaschema6.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A6 = new LOLoad(new FileSpec("/abc",
+        LOLoad A6 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema6, lp, conf);
         lp.add(A6);
         
@@ -1357,7 +1357,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             "y", null, DataType.INTEGER));
         jbschema6.addField(new LogicalSchema.LogicalFieldSchema(
             "z", null, DataType.LONG));
-        LOLoad B6 = new LOLoad(new FileSpec("/def",
+        LOLoad B6 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema6, lp, conf);
         lp.add(B6);
         
@@ -1388,7 +1388,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema7 = new LogicalSchema();
         jaschema7.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A7 = new LOLoad(new FileSpec("/abc",
+        LOLoad A7 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema7, lp, conf);
         lp.add(A7);
         
@@ -1398,7 +1398,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             "y", null, DataType.INTEGER));
         jbschema7.addField(new LogicalSchema.LogicalFieldSchema(
             "z", null, DataType.LONG));
-        LOLoad B7 = new LOLoad(new FileSpec("/def",
+        LOLoad B7 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema7, lp, conf);
         lp.add(B7);
         
@@ -1436,7 +1436,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema6 = new LogicalSchema();
         jaschema6.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A6 = new LOLoad(new FileSpec("/abc",
+        LOLoad A6 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema6, lp, conf);
         lp.add(A6);
         
@@ -1446,7 +1446,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             "y", null, DataType.INTEGER));
         jbschema6.addField(new LogicalSchema.LogicalFieldSchema(
             "z", null, DataType.LONG));
-        LOLoad B6 = new LOLoad(new FileSpec("/def",
+        LOLoad B6 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema6, lp, conf);
         lp.add(B6);
         
@@ -1477,7 +1477,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema jaschema8 = new LogicalSchema();
         jaschema8.addField(new LogicalSchema.LogicalFieldSchema(
            "x", null, DataType.INTEGER));
-        LOLoad A8 = new LOLoad(new FileSpec("/abc",
+        LOLoad A8 = newLOLoad(new FileSpec("/abc",
            new FuncSpec("/fooload", new String[] {"x", "y"})), jaschema8, lp, conf);
         lp.add(A8);
         
@@ -1487,7 +1487,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
             "y", null, DataType.INTEGER));
         jbschema8.addField(new LogicalSchema.LogicalFieldSchema(
             "z", null, DataType.LONG));
-        LOLoad B8 = new LOLoad(new FileSpec("/def",
+        LOLoad B8 = newLOLoad(new FileSpec("/def",
             new FuncSpec("PigStorage", "\t")), jbschema8, lp, conf);
         lp.add(B8);
         
@@ -1520,7 +1520,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         LogicalSchema aschema1 = new LogicalSchema();
         aschema1.addField(new LogicalSchema.LogicalFieldSchema(
             "x", null, DataType.INTEGER));
-        LOLoad A1 = new LOLoad(new FileSpec("/abc",
+        LOLoad A1 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "y"})), aschema1, lp1, new Configuration());
         lp1.add(A1);
         
@@ -1538,7 +1538,7 @@ public class TestNewPlanOperatorPlan extends TestCase {
         lp1.connect(A1, D1);
         
         LogicalPlan lp2 = new LogicalPlan();
-        LOLoad A2 = new LOLoad(new FileSpec("/abc",
+        LOLoad A2 = newLOLoad(new FileSpec("/abc",
             new FuncSpec(DummyLoad.class.getName(), new String[] {"x", "z"})), null, lp2, new Configuration());
         lp2.add(A2);
         
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java b/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
index 6e5edaf27..719cc078f 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
@@ -18,6 +18,8 @@
 
 package org.apache.pig.test;
 
+import static org.apache.pig.newplan.logical.relational.LOTestHelper.newLOLoad;
+
 import static org.apache.pig.ExecType.LOCAL;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.genDummyLOLoadNewLP;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.genFlatSchema;
@@ -864,12 +866,12 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() ;
             
-            LOLoad load1 = new LOLoad(
+            LOLoad load1 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
                 
-            LOLoad load2 = new LOLoad(
+            LOLoad load2 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -999,12 +1001,12 @@ public class TestTypeCheckingValidatorNewLP {
             String pigStorage = PigStorage.class.getName() ;
     
             
-            LOLoad load1 = new LOLoad(
+            LOLoad load1 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
                 
-            LOLoad load2 = new LOLoad(
+            LOLoad load2 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1107,7 +1109,7 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() ;
     
-            LOLoad load1 = new LOLoad(
+            LOLoad load1 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1175,7 +1177,7 @@ public class TestTypeCheckingValidatorNewLP {
 
             String pigStorage = PigStorage.class.getName() ;
 
-            LOLoad load1 = new LOLoad(
+            LOLoad load1 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1238,7 +1240,7 @@ public class TestTypeCheckingValidatorNewLP {
 
             String pigStorage = PigStorage.class.getName() ;
 
-            LOLoad load1 = new LOLoad(
+            LOLoad load1 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1300,7 +1302,7 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() ;
     
-            LOLoad load1 = new LOLoad(
+            LOLoad load1 = newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1390,7 +1392,7 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() ;
     
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1475,7 +1477,7 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() ;
     
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1558,7 +1560,7 @@ public class TestTypeCheckingValidatorNewLP {
 
             String pigStorage = PigStorage.class.getName() ;
 
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1665,7 +1667,7 @@ public class TestTypeCheckingValidatorNewLP {
 
             String pigStorage = PigStorage.class.getName() ;
 
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1750,12 +1752,12 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() ;
     
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
             
-            LOLoad load2 =  new LOLoad(
+            LOLoad load2 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -1888,12 +1890,12 @@ public class TestTypeCheckingValidatorNewLP {
             LogicalPlan plan = new LogicalPlan() ;
     
             String pigStorage = PigStorage.class.getName() ;
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
             
-            LOLoad load2 =  new LOLoad(
+            LOLoad load2 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
@@ -2007,12 +2009,12 @@ public class TestTypeCheckingValidatorNewLP {
     
             String pigStorage = PigStorage.class.getName() + "('\\t','-noschema')" ;
     
-            LOLoad load1 =  new LOLoad(
+            LOLoad load1 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
             
-            LOLoad load2 =  new LOLoad(
+            LOLoad load2 =  newLOLoad(
                     new FileSpec("pi", new FuncSpec(pigStorage)),
                     null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
             );
diff --git a/test/org/apache/pig/test/Util.java b/test/org/apache/pig/test/Util.java
index a29f7ccec..3913692bd 100644
--- a/test/org/apache/pig/test/Util.java
+++ b/test/org/apache/pig/test/Util.java
@@ -24,7 +24,6 @@ import java.io.BufferedReader;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
@@ -67,10 +66,8 @@ import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;
 import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MRCompiler;
 import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MapReduceLauncher;
-import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MapReduceOper;
 import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.plans.MROperPlan;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhysicalPlan;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POStore;
 import org.apache.pig.backend.hadoop.executionengine.util.MapRedUtil;
 import org.apache.pig.builtin.Utf8StorageConverter;
 import org.apache.pig.data.BagFactory;
@@ -78,7 +75,6 @@ import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataByteArray;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.DefaultBagFactory;
-import org.apache.pig.data.SortedDataBag;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.PigContext;
@@ -91,13 +87,11 @@ import org.apache.pig.impl.util.LogUtils;
 import org.apache.pig.newplan.logical.optimizer.DanglingNestedNodeRemover;
 import org.apache.pig.newplan.logical.optimizer.LogicalPlanPrinter;
 import org.apache.pig.newplan.logical.optimizer.SchemaResetter;
-import org.apache.pig.newplan.logical.relational.LOStore;
 import org.apache.pig.newplan.logical.relational.LogToPhyTranslationVisitor;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
 import org.apache.pig.newplan.logical.optimizer.UidResetter;
-import org.apache.pig.newplan.logical.rules.LoadStoreFuncDupSignatureValidator;
 import org.apache.pig.newplan.logical.visitor.CastLineageSetter;
 import org.apache.pig.newplan.logical.visitor.ColumnAliasConversionVisitor;
 import org.apache.pig.newplan.logical.visitor.ScalarVisitor;
@@ -739,10 +733,7 @@ public class Util {
         SchemaResetter schemaResetter = 
                 new SchemaResetter( lp, true /*disable duplicate uid check*/ );
         schemaResetter.visit();
-        
-        LoadStoreFuncDupSignatureValidator loadStoreFuncDupSignatureValidator = new LoadStoreFuncDupSignatureValidator(lp);
-        loadStoreFuncDupSignatureValidator.validate();
-        
+
         StoreAliasSetter storeAliasSetter = new StoreAliasSetter( lp );
         storeAliasSetter.visit();
         
@@ -1001,9 +992,9 @@ public class Util {
         QueryParserDriver parserDriver = new QueryParserDriver( pc, "test", fileNameMap );
         org.apache.pig.newplan.logical.relational.LogicalPlan lp = parserDriver.parse( query );
         
-        new ColumnAliasConversionVisitor( lp ).visit();
-        new SchemaAliasVisitor( lp ).visit();
-        new ScalarVisitor( lp, pc ).visit();
+        new ColumnAliasConversionVisitor(lp).visit();
+        new SchemaAliasVisitor(lp).visit();
+        new ScalarVisitor(lp, pc, "test").visit();
         
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         
@@ -1021,7 +1012,7 @@ public class Util {
         
         new ColumnAliasConversionVisitor( lp ).visit();
         new SchemaAliasVisitor( lp ).visit();
-        new ScalarVisitor( lp, pc ).visit();
+        new ScalarVisitor(lp, pc, "test").visit();
         
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         
diff --git a/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java b/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java
index cb6f22681..f07bbbde7 100644
--- a/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java
+++ b/test/org/apache/pig/test/utils/TypeCheckingTestUtil.java
@@ -18,6 +18,8 @@
 
 package org.apache.pig.test.utils;
 
+import static org.apache.pig.newplan.logical.relational.LOTestHelper.newLOLoad;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -45,7 +47,7 @@ public class TypeCheckingTestUtil {
         PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
         pc.connect();
         org.apache.pig.newplan.logical.relational.LOLoad load =
-        new org.apache.pig.newplan.logical.relational.LOLoad(
+        newLOLoad(
                 new FileSpec("pi", new FuncSpec(pigStorage)),
                 null, plan, new Configuration(ConfigurationUtil.toConfiguration(pc.getFs().getConfiguration()))
         );
