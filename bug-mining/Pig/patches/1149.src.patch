diff --git a/CHANGES.txt b/CHANGES.txt
index 996d6b4e6..4b5de4414 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -28,6 +28,8 @@ PIG-3174:  Remove rpm and deb artifacts from build.xml (gates)
 
 IMPROVEMENTS
 
+PIG-3202: CUBE operator not documented in user docs (prasanth_j via billgraham)
+
 PIG-3189: Remove ivy/pig.pom and improve build mvn targets (billgraham)
 
 PIG-3192: Better call to action to download Pig in docs (rjurney via jcoveney)
diff --git a/src/docs/src/documentation/content/xdocs/basic.xml b/src/docs/src/documentation/content/xdocs/basic.xml
index 1b307c30b..51bdce534 100644
--- a/src/docs/src/documentation/content/xdocs/basic.xml
+++ b/src/docs/src/documentation/content/xdocs/basic.xml
@@ -5331,6 +5331,192 @@ DUMP X;
    
    </section></section>
    
+
+<!-- =================================================================== -->
+   <section id="cube">
+      <title>CUBE</title>
+      <p>Performs cube/rollup operations.</p>
+
+      <section>
+         <title>Cube operation</title>
+         <p>Cube operation computes aggregates for all possbile combinations of specified group by dimensions. The number of group by combinations generated by cube for n dimensions will be 2^n.</p>
+      </section>
+
+      <section>
+         <title>Rollup operation</title>
+         <p>Rollup operations computes multiple levels of aggregates based on hierarchical ordering of specified group by dimensions. Rollup is useful when there is hierarchical ordering on the dimensions. The number of group by combinations generated by rollup for n dimensions will be n+1.</p>
+      </section>
+
+      <section>
+         <title>Syntax</title>
+            <table>
+               <tr>
+                  <td>
+                     <p>alias = CUBE alias BY { CUBE expression | ROLLUP expression }, [ CUBE expression | ROLLUP expression ] [PARALLEL n];</p>
+                  </td>
+               </tr>
+            </table>
+      </section>
+
+      <section>
+         <title>Terms</title>
+         <table>
+            <tr>
+               <td>
+                  <p>alias</p>
+               </td>
+               <td>
+                  <p>The name of the relation.</p>
+               </td>
+            </tr>
+
+            <tr>
+               <td>
+                  <p>CUBE</p>
+                  </td>
+                  <td>
+                   <p>Keyword</p>
+               </td>
+            </tr>
+
+            <tr>
+               <td>
+                  <p>BY</p>
+                  </td>
+                  <td>
+                   <p>Keyword</p>
+               </td>
+            </tr>
+
+            <tr>
+               <td>
+                  <p>expression</p>
+                  </td>
+                  <td>
+                   <p>Projections (dimensions) of the relation. Supports field, star and project-range expressions.</p>
+               </td>
+            </tr>
+
+            <tr>
+               <td>
+                  <p>ROLLUP</p>
+                  </td>
+                  <td>
+                   <p>Keyword</p>
+               </td>
+            </tr>
+
+            <tr>
+               <td>
+                  <p>PARALLEL n</p>
+               </td>
+               <td>
+                  <p>Increase the parallelism of a job by specifying the number of reduce tasks, n.</p>
+                  <p>For more information, see <a href="perf.html#Parallel">Use the Parallel Features</a>.</p>
+               </td>
+            </tr>
+         </table>
+      </section>
+
+      <section>
+         <title>Example</title>
+      </section>
+
+      <section>
+         <title>Basic usage of CUBE operation</title>
+         <source>
+salesinp = LOAD '/pig/data/salesdata' USING PigStorage(',') AS
+    (product:chararray, year:int, region:chararray, state:chararray, city:chararray, sales:long);
+cubedinp = CUBE salesinp BY CUBE(product,year);
+result = FOREACH cubedinp GENERATE FLATTEN(group), SUM(cube.sales) AS totalsales;</source>
+         <p>For a sample input tuple (car, 2012, midwest, ohio, columbus, 4000), the above query with cube operation will output</p>
+         <source>
+(car,2012,4000)
+(car,,4000)
+(,2012,4000)
+(,,4000)</source>
+      </section>
+
+      <section>
+         <title>Output schema</title>
+         <source>
+grunt> describe cubedinp;
+cubedinp: {group: (product: chararray,year: int),cube: {(product: chararray,year: int,region: chararray,
+state: chararray,city: chararray,sales: long)}}</source>
+         <p>Note the second column, ‘cube’ field which is a bag of all tuples that belong to ‘group’. Also note that the measure attribute ‘sales’ along with other unused dimensions in load statement are pushed down so that it can be referenced later while computing aggregates on the measure, like in this case SUM(cube.sales).</p>
+      </section>
+
+      <section>
+         <title>Basic usage of ROLLUP operation</title>
+         <source>
+salesinp = LOAD '/pig/data/salesdata' USING PigStorage(',') AS
+    (product:chararray, year:int, region:chararray, state:chararray, city:chararray, sales:long);
+rolledup = CUBE salesinp BY ROLLUP(region,state,city);
+result = FOREACH rolledup GENERATE FLATTEN(group), SUM(cube.sales) AS totalsales;</source>
+         <p>For a sample input tuple (car, 2012, midwest, ohio, columbus, 4000), the above query with rollup operation will output</p>
+         <source>
+(midwest,ohio,columbus,4000)
+(midwest,ohio,,4000)
+(midwest,,,4000)
+(,,,4000)</source>
+      </section>
+
+      <section>
+         <title>Output schema</title>
+         <source>
+grunt> describe rolledup;
+rolledup: {group: (region: chararray,state: chararray,city: chararray),cube: {(region: chararray,
+state: chararray,city: chararray,product: chararray,year: int,sales: long)}}</source>
+      </section>
+
+      <section>
+         <title>Basic usage of CUBE and ROLLUP operation combined</title>
+         <p>If CUBE and ROLLUP operations are used together, the output groups will be the cross product of all groups generated by cube and rollup operation. If there are m dimensions in cube operations and n dimensions in rollup operation then overall number of combinations will be (2^m) * (n+1).</p>
+         <source>
+salesinp = LOAD '/pig/data/salesdata' USING PigStorage(',') AS
+    (product:chararray, year:int, region:chararray, state:chararray, city:chararray, sales:long);
+cubed_and_rolled = CUBE salesinp BY CUBE(product,year), ROLLUP(region, state, city);
+result = FOREACH cubed_and_rolled GENERATE FLATTEN(group), SUM(cube.sales) AS totalsales;</source>
+         <p>For a sample input tuple (car, 2012, midwest, ohio, columbus, 4000), the above query with cube and rollup operation will output</p>
+         <source>
+(car,2012,midwest,ohio,columbus,4000)
+(car,2012,midwest,ohio,,4000)
+(car,2012,midwest,,,4000)
+(car,2012,,,,4000)
+(car,,midwest,ohio,columbus,4000)
+(car,,midwest,ohio,,4000)
+(car,,midwest,,,4000)
+(car,,,,,4000)
+(,2012,midwest,ohio,columbus,4000)
+(,2012,midwest,ohio,,4000)
+(,2012,midwest,,,4000)
+(,2012,,,,4000)
+(,,midwest,ohio,columbus,4000)
+(,,midwest,ohio,,4000)
+(,,midwest,,,4000)
+(,,,,,4000)</source>
+      </section>
+
+      <section>
+         <title>Output schema</title>
+         <source>
+grunt> describe cubed_and_rolled;
+cubed_and_rolled: {group: (product: chararray,year: int,region: chararray,
+state: chararray,city: chararray),cube: {(product: chararray,year: int,region: chararray,
+state: chararray,city: chararray,sales: long)}}</source>
+      </section>
+
+      <section>
+         <title>Handling null values in dimensions</title>
+         <p>Since null values are used to represent subtotals in cube and rollup operation, in order to differentiate the legitimate null values that already exists as dimension values, CUBE operator converts any null values in dimensions to "unknown" value before performing cube or rollup operation. For example, for CUBE(product,location) with a sample tuple (car,) the output will be </p>
+         <source>
+(car,unknown)
+(car,)
+(,unknown)
+(,)</source>
+      </section>
+   </section>
+
 <!-- =================================================================== -->    
    <section id="define">
    <title>DEFINE</title>
