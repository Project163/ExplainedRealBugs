diff --git a/CHANGES.txt b/CHANGES.txt
index b47c59e73..20f478244 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -165,3 +165,5 @@ Trunk (unreleased changes)
     PIG-381: bincond does not handle null data
 
     PIG-382: bincond throws typecast exception
+
+    PIG-352: java.lang.ClassCastException when invalid field is accessed
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index e2c9a71f0..520765f03 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -597,7 +597,11 @@ LogicalPlan Parse() :
 		if(null != root) {
             log.debug("Adding " + root.getAlias() + " " + root + " to the lookup table " + aliases);
             addLogicalPlan(root, lp);
-			log.debug("Root: " + root.getClass().getName() + " schema: " + root.getSchema());
+            try {
+			    log.debug("Root: " + root.getClass().getName() + " schema: " + root.getSchema());
+            } catch(FrontendException fee) {
+                throw new ParseException(fee.getMessage());
+            }
 		}
 
         ArrayList<LogicalOperator> roots = new ArrayList<LogicalOperator>(lp.getRoots().size());
@@ -2428,7 +2432,7 @@ Schema.FieldSchema TypeAtomSchema() :
 {
 	byte type = DataType.BYTEARRAY;
 	Schema.FieldSchema fs;
-	log.info("Entering TypeAtomSchema");
+	log.trace("Entering TypeAtomSchema");
 }
 {
 	(  ( type = BasicType() )
@@ -2438,7 +2442,7 @@ Schema.FieldSchema TypeAtomSchema() :
             }
 			fs = new Schema.FieldSchema(null, type); 
 			
-			log.info("Exiting TypeAtomSchema");
+			log.trace("Exiting TypeAtomSchema");
 			return fs;
 		} 
 	)
@@ -2757,8 +2761,8 @@ ExpressionOperator ColOrSpec(Schema over, Map<String, LogicalOperator> specs, Lo
 }
 {
 	(
-	spec = DollarVar(lp, eOp)
-|	spec = AliasFieldOrSpec(over,specs,lp,eOp)
+	spec = DollarVar(over, specs, lp, eOp)
+|	spec = AliasFieldOrSpec(over, specs, lp, eOp)
 
 	)
 	{
@@ -2767,7 +2771,7 @@ ExpressionOperator ColOrSpec(Schema over, Map<String, LogicalOperator> specs, Lo
 	}
 }
 
-ExpressionOperator DollarVar(LogicalPlan lp, LogicalOperator eOp) : 
+ExpressionOperator DollarVar(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator eOp) : 
 {
 	Token t1;
 	log.trace("Entering DollarVar");
@@ -2775,7 +2779,13 @@ ExpressionOperator DollarVar(LogicalPlan lp, LogicalOperator eOp) :
 {
 	t1=<DOLLARVAR>	
 	{
+        int colNum = undollar(t1.image);
 		log.debug("Token: " + t1.image);
+        if(null != over) {
+            if(colNum >= over.size()) {
+                throw new ParseException("Out of bound access. Trying to access non-existent column: " + colNum + ". Schema " + over + " has " + over.size() + " column(s).");
+            }
+        }
 		ExpressionOperator project = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, undollar(t1.image));
 		try {
 			log.debug("eOp: " + eOp.getClass().getName() + " " + eOp);
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index 4049f2762..6a363debe 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -1139,6 +1139,24 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         assertEquals(project1.getExpression(), cogroup) ;
     }
 
+    @Test
+    public void testQuery89() {
+        buildPlan("a = load 'myfile';");
+        buildPlan("b = foreach a generate $0, $100;");
+        buildPlan("c = load 'myfile' as (i: int);");
+        buildPlan("d = foreach c generate $0 as zero, i;");
+    }
+
+    @Test
+    public void testQueryFail89() {
+        buildPlan("c = load 'myfile' as (i: int);");
+        try {
+            buildPlan("d = foreach c generate $0, $5;");
+        } catch (AssertionFailedError e) {
+            assertTrue(e.getMessage().contains("Out of bound access"));
+        }
+    }
+
     private void printPlan(LogicalPlan lp) {
         LOPrinter graphPrinter = new LOPrinter(System.err, lp);
         System.err.println("Printing the logical plan");
