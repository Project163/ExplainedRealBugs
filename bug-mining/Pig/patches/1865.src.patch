diff --git a/CHANGES.txt b/CHANGES.txt
index 0489c111c..576afa74e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -36,6 +36,8 @@ OPTIMIZATIONS
 Â 
 BUG FIXES
 
+PIG-4953: Predicate push-down will not run filters for single unary expressions (rdblue via daijy)
+
 PIG-4940: Predicate push-down filtering unary expressions can be pushed (rdblue via daijy)
 
 PIG-4938: [PiggyBank] XPath returns empty values when using aggregation method (nkollar via daijy)
diff --git a/src/org/apache/pig/newplan/FilterExtractor.java b/src/org/apache/pig/newplan/FilterExtractor.java
index b0837661e..462cdf9b4 100644
--- a/src/org/apache/pig/newplan/FilterExtractor.java
+++ b/src/org/apache/pig/newplan/FilterExtractor.java
@@ -98,13 +98,17 @@ public abstract class FilterExtractor {
     public void visit() throws FrontendException {
         // we will visit the leaf and it will recursively walk the plan
         LogicalExpression leaf = (LogicalExpression)originalPlan.getSources().get( 0 );
-        // if the leaf is a unary operator it should be a FilterFunc in
-        // which case we don't try to extract partition filter conditions
-        if(leaf instanceof BinaryExpression) {
-            // recursively traverse the tree bottom up
-            // checkPushdown returns KeyState which is pair of LogicalExpression
-            BinaryExpression binExpr = (BinaryExpression)leaf;
-            KeyState finale = checkPushDown(binExpr);
+
+        // recursively traverse the tree bottom up
+        // checkPushdown returns KeyState which is pair of LogicalExpression
+        KeyState finale = null;
+        if (leaf instanceof BinaryExpression) {
+            finale = checkPushDown((BinaryExpression) leaf);
+        } else if (leaf instanceof UnaryExpression) {
+            finale = checkPushDown((UnaryExpression) leaf);
+        }
+
+        if (finale != null) {
             this.filterExpr = finale.filterExpr;
             this.pushdownExpr = getExpression(finale.pushdownExpr);
         }
@@ -290,6 +294,7 @@ public abstract class FilterExtractor {
                     state.pushdownExpr = unaryExpr;
                     state.filterExpr = null;
                 } else {
+                    removeFromFilteredPlan(childState.filterExpr);
                     state.filterExpr = addToFilterPlan(unaryExpr);
                     state.pushdownExpr = null;
                 }
diff --git a/test/org/apache/pig/test/TestNewPartitionFilterPushDown.java b/test/org/apache/pig/test/TestNewPartitionFilterPushDown.java
index 0f13274ae..2dcfe0514 100644
--- a/test/org/apache/pig/test/TestNewPartitionFilterPushDown.java
+++ b/test/org/apache/pig/test/TestNewPartitionFilterPushDown.java
@@ -57,6 +57,7 @@ import org.apache.pig.newplan.logical.expression.EqualExpression;
 import org.apache.pig.newplan.logical.expression.IsNullExpression;
 import org.apache.pig.newplan.logical.expression.LogicalExpression;
 import org.apache.pig.newplan.logical.expression.MapLookupExpression;
+import org.apache.pig.newplan.logical.expression.NotEqualExpression;
 import org.apache.pig.newplan.logical.expression.NotExpression;
 import org.apache.pig.newplan.logical.expression.OrExpression;
 import org.apache.pig.newplan.logical.expression.ProjectExpression;
@@ -123,6 +124,17 @@ public class TestNewPartitionFilterPushDown {
 
     }
 
+    /**
+     * test case where filter only contains condition on partition cols
+     * @throws Exception
+     */
+    @Test
+    public void testPartIsNullFilter() throws Exception {
+        String q = query + "b = filter a by srcid is null;" + "store b into 'out';";
+        test(q, Arrays.asList("srcid"),
+                null, "(srcid is null)");
+    }
+
     /**
      * test case where filter only contains condition on partition cols
      * @throws Exception
@@ -859,7 +871,7 @@ public class TestNewPartitionFilterPushDown {
         return "(" + input + ")";
     }
 
-    private static String getTestExpression(LogicalExpression op) throws FrontendException {
+    public static String getTestExpression(LogicalExpression op) throws FrontendException {
         if(op == null) {
             return null;
         }
@@ -881,6 +893,8 @@ public class TestNewPartitionFilterPushDown {
                     opStr = " and ";
                 } else if (op instanceof OrExpression) {
                     opStr = " or ";
+                } else if (op instanceof NotEqualExpression) {
+                    opStr = " != ";
                 } else {
                     opStr = op.getName();
                 }
diff --git a/test/org/apache/pig/test/TestNewPredicatePushDown.java b/test/org/apache/pig/test/TestNewPredicatePushDown.java
new file mode 100644
index 000000000..bc26255f4
--- /dev/null
+++ b/test/org/apache/pig/test/TestNewPredicatePushDown.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.test;
+
+import org.apache.pig.*;
+import org.apache.pig.impl.PigContext;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.PredicatePushDownFilterExtractor;
+import org.apache.pig.newplan.logical.expression.*;
+import org.apache.pig.newplan.logical.relational.LOFilter;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.util.*;
+
+import static org.apache.pig.Expression.OpType.OP_NOT;
+import static org.apache.pig.Expression.OpType.OP_NULL;
+import static org.apache.pig.Expression.OpType.OP_AND;
+import static org.apache.pig.Expression.OpType.OP_EQ;
+
+/**
+ * unit tests to test extracting new push-down filter conditions out of the filter
+ * condition in the filter following a load which talks to metadata system (.i.e.
+ * implements {@link LoadMetadata})
+ */
+public class TestNewPredicatePushDown {
+    static PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
+    String query = "a = load 'foo' as (srcid:int, mrkt:chararray, dstid:int, name:chararray, " +
+            "age:int, browser:map[], location:tuple(country:chararray, zip:int));";
+
+    // PIG-4940
+    @Test
+    public void testSingleUnaryExpressionUnsupportedPushdown() throws Exception {
+        String q = query + "b = filter a by not browser#'type' is null;" +
+                "store b into 'out';";
+        test(q, Arrays.asList("browser"), Arrays.asList(OP_NOT, OP_NULL), null,
+                "(not (browser#'type' is null))", true);
+    }
+
+    // PIG-4953
+    @Test
+    public void testSingleUnaryExpressionSuccessfulPushdown() throws Exception {
+        String q = query + "b = filter a by mrkt is not null;" +
+                "store b into 'out';";
+        test(q, Arrays.asList("mrkt"), Arrays.asList(OP_NOT, OP_NULL),
+                "((mrkt is null) not)", null, true);
+    }
+
+    @Test
+    public void testUnaryAndExpressionSuccessfulPushdown() throws Exception {
+        String q = query + "b = filter a by not (mrkt is null and mrkt == 'us');" +
+                "store b into 'out';";
+        test(q, Arrays.asList("mrkt"), Arrays.asList(OP_NOT, OP_NULL, OP_AND, OP_EQ),
+                "(((mrkt is null) and (mrkt == 'us')) not)", null, true);
+    }
+
+    @Test
+    public void testUnaryAndExpressionUnsupportedPushdown() throws Exception {
+        String q = query + "b = filter a by not (mrkt is null and mrkt != 'us');" +
+                "store b into 'out';";
+        test(q, Arrays.asList("mrkt"), Arrays.asList(OP_NOT, OP_NULL, OP_AND, OP_EQ),
+                null, "(not ((mrkt is null) and (mrkt != us)))", true);
+    }
+
+    private PredicatePushDownFilterExtractor test(String query, List<String> predicateCols, List<Expression.OpType> supportedOpTypes,
+                                                  String expPushFilterString, String expFilterString, boolean unsupportedExpression)
+            throws Exception {
+        PigServer pigServer = new PigServer( pc );
+        LogicalPlan newLogicalPlan = Util.buildLp(pigServer, query);
+        Operator op = newLogicalPlan.getSinks().get(0);
+        LOFilter filter = (LOFilter)newLogicalPlan.getPredecessors(op).get(0);
+        PredicatePushDownFilterExtractor pushColExtractor = new PredicatePushDownFilterExtractor(
+                filter.getFilterPlan(), predicateCols, supportedOpTypes);
+        pushColExtractor.visit();
+
+        if (expPushFilterString == null) {
+            Assert.assertEquals("Checking partition column filter:", null,
+                    pushColExtractor.getPushDownExpression());
+        } else  {
+            Assert.assertEquals("Checking partition column filter:",
+                    expPushFilterString,
+                    pushColExtractor.getPushDownExpression().toString());
+        }
+
+        if (expFilterString == null) {
+            Assert.assertTrue("Check that filter can be removed:",
+                    pushColExtractor.isFilterRemovable());
+        } else {
+            if (unsupportedExpression) {
+                String actual = TestNewPartitionFilterPushDown.getTestExpression(
+                        (LogicalExpression)pushColExtractor.getFilteredPlan().getSources().get(0)).toString();
+                Assert.assertEquals("checking trimmed filter expression:", expFilterString, actual);
+            } else {
+                String actual = pushColExtractor.getExpression(
+                        (LogicalExpression)pushColExtractor.getFilteredPlan().getSources().get(0)).toString();
+                Assert.assertEquals("checking trimmed filter expression:", expFilterString, actual);
+            }
+        }
+        return pushColExtractor;
+    }
+
+}
