diff --git a/CHANGES.txt b/CHANGES.txt
index a89d0e5cc..4edbcc2dc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -93,6 +93,8 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-834: incorrect plan when algebraic functions are nested (ashutoshc)
+
 PIG-1217: Fix argToFuncMapping in Piggybank Top function (dvryaboy via gates)
 
 PIG-1154: Local Mode fails when hadoop config directory is specified in 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/CombinerOptimizer.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/CombinerOptimizer.java
index 9c56b0fd9..4203648a0 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/CombinerOptimizer.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/CombinerOptimizer.java
@@ -76,7 +76,7 @@ import org.apache.pig.impl.plan.optimizer.OptimizerException;
  * works for things like generate group, SUM(A.$1 + 1).  But it fails for
  * things like the above.  Certain types of inner plans will never be
  * movable (like filters).  But distinct or order by in the inner plan
- * should be moble.  And, things like:
+ * should be mobile.  And, things like:
  *      C = cogroup A by $0, B by $0;
  *      D = foreach C {
  *          D1 = distinct A;
@@ -427,13 +427,51 @@ public class CombinerOptimizer extends MROpPlanVisitor {
             }
             return ExprType.SIMPLE_PROJECT;
         } else if (leaf instanceof POUserFunc) {
-            return ((POUserFunc)leaf).combinable() ? ExprType.ALGEBRAIC :
-                ExprType.NOT_ALGEBRAIC;
+            
+            POUserFunc userFunc = (POUserFunc)leaf;
+            if(!userFunc.combinable() ){
+                return ExprType.NOT_ALGEBRAIC;
+            }
+            // The leaf userFunc may be combinable, but there might be other 
+            // algebraic userFuncs in the predecessors, if there are
+            // we choose not to fire combiner.
+            CheckCombinableUserFunc ccuf = new CheckCombinableUserFunc(pp);
+            ccuf.visit();
+            return ccuf.exprType;
         } else {
             return ExprType.NOT_ALGEBRAIC;
         }
     }
 
+      private static class CheckCombinableUserFunc extends PhyPlanVisitor{
+
+        private ExprType exprType = ExprType.ALGEBRAIC;
+          
+        public CheckCombinableUserFunc(PhysicalPlan plan) {
+            super(plan, new DependencyOrderWalker<PhysicalOperator, PhysicalPlan>(plan));
+        }
+        
+        @Override
+        public void visit() throws VisitorException {
+            super.visit();
+        }
+         
+        @Override
+        public void visitUserFunc(POUserFunc userFunc) throws VisitorException {
+            
+            /* We already know there is one combinable POUserFunc and its a leaf. So,  
+             * successor of that userFunc is null. We are interested to find
+             * if there is another combinable userFunc somewhere in plan (that 
+             * is a userFunc with successors and is Combinable).
+             */
+            List<PhysicalOperator> succs = this.mPlan.getSuccessors(userFunc);
+            
+            if(succs != null && !succs.isEmpty() && userFunc.combinable()){
+                this.exprType = ExprType.NOT_ALGEBRAIC;                
+            }
+        }
+      }
+    
     // Returns number of fields that this will project, including the added
     // key field if that is necessary
     private void fixUpForeachs(
diff --git a/test/org/apache/pig/test/TestCombiner.java b/test/org/apache/pig/test/TestCombiner.java
index 9e41ae888..7f1adc56f 100644
--- a/test/org/apache/pig/test/TestCombiner.java
+++ b/test/org/apache/pig/test/TestCombiner.java
@@ -39,13 +39,40 @@ import org.apache.pig.PigServer;
 import org.apache.pig.builtin.PigStorage;
 import org.apache.pig.data.Tuple;
 
+import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileLocalizer;
+import org.apache.pig.impl.logicalLayer.LogicalPlan;
+import org.apache.pig.test.utils.LogicalPlanTester;
 
 public class TestCombiner extends TestCase {
 
-    
-
     MiniCluster cluster = MiniCluster.buildCluster();
+
+    @Test
+    public void testSuccessiveUserFuncs1() throws Exception{
+        
+        LogicalPlanTester tester = new LogicalPlanTester();
+        tester.buildPlan( "a = load 'students.txt' as (c1,c2,c3,c4); ");
+        tester.buildPlan("c = group a by c2; ");
+        tester.buildPlan("f = foreach c generate COUNT(org.apache.pig.builtin.Distinct($1.$2)); ");
+        LogicalPlan lp = tester.buildPlan("store f into 'out';");
+        PigContext pc = new PigServer(ExecType.MAPREDUCE, cluster.getProperties()).getPigContext();
+        assertTrue((Util.buildMRPlan(Util.buildPhysicalPlan(lp,pc),pc).getRoots().get(0).combinePlan.isEmpty()));
+    }
+
+    @Test
+    public void testSuccessiveUserFuncs2() throws Exception{
+        
+        LogicalPlanTester tester = new LogicalPlanTester();
+        tester.buildPlan( "a = load 'students.txt' as (c1,c2,c3,c4); ");
+        tester.buildPlan("c = group a by c2; ");
+        String dummyUDF = JiraPig1030.class.getName();
+        tester.buildPlan("f = foreach c generate COUNT("+dummyUDF+"" +
+        		"(org.apache.pig.builtin.Distinct($1.$2),"+dummyUDF+"())); ");
+        LogicalPlan lp = tester.buildPlan("store f into 'out';");
+        PigContext pc = new PigServer(ExecType.MAPREDUCE, cluster.getProperties()).getPigContext();
+        assertTrue((Util.buildMRPlan(Util.buildPhysicalPlan(lp,pc),pc).getRoots().get(0).combinePlan.isEmpty()));
+    }
     
     @Test
     public void testOnCluster() throws Exception {
@@ -92,7 +119,6 @@ public class TestCombiner extends TestCase {
                 + PigStorage.class.getName() + "(',');");
     }
     
-    
     @Test
     public void testNoCombinerUse() {
         // To simulate this, we will have two input files
@@ -348,7 +374,7 @@ public class TestCombiner extends TestCase {
             return "";
         }
     }
-    
+   
     @Test
     public void testJiraPig1030() {
         // test that combiner is NOT invoked when
@@ -391,4 +417,5 @@ public class TestCombiner extends TestCase {
             }
         }
     }
+
 }
