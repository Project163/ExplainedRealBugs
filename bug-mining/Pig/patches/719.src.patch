diff --git a/CHANGES.txt b/CHANGES.txt
index 187c6e6e8..b9ea7ed61 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -194,6 +194,9 @@ PIG-1696: Performance: Use System.arraycopy() instead of manually copying the by
 
 BUG FIXES
 
+PIG-1990: support casting of complex types with empty inner schema
+ to complex type with non-empty inner schema (thejas)
+
 PIG-2016: -dot option does not work with explain and new logical plan (daijy)
 
 PIG-2018: NPE for co-group with group-by column having complex schema and 
diff --git a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
index 6dd2478ec..57cc54898 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
@@ -289,10 +289,12 @@ public class LogicalSchema {
                 if(inType == DataType.BYTEARRAY) {
                     //good
                 } else if (inType == outType) {
-                    // Don't do the comparison if both embedded schemas are
+                    // Don't do the comparison if either input inner schema 
+                    // is null/empty or  both inner schemas are
                     // null.  That will cause Schema.equals to return false,
                     // even though we want to view that as true.
-                    if (!(outFs.schema == null && inFs.schema == null)) { 
+                    if (!(inFs.schema == null || inFs.schema.size() == 0 || 
+                            (outFs.schema == null && inFs.schema == null))) { 
                         // compare recursively using schema
                         if (!LogicalSchema.castable(inFs.schema, outFs.schema)) {
                             return false ;
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java b/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
index adf3c6852..49ad07d2a 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
@@ -18,6 +18,7 @@
 
 package org.apache.pig.test;
 
+import static org.apache.pig.ExecType.LOCAL;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.genDummyLOLoadNewLP;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.genFlatSchema;
 import static org.apache.pig.test.utils.TypeCheckingTestUtil.genFlatSchemaInTuple;
@@ -31,7 +32,9 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.io.File;
+import java.io.FileWriter;
 import java.io.IOException;
+import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -4106,6 +4109,34 @@ public class TestTypeCheckingValidatorNewLP {
             checkLastForeachCastLoadFunc(query, null, 0);
         }
 
+        //see PIG-1990
+        @Test
+        public void testCastEmptyInnerSchema() throws IOException, ParseException{
+            final String INP_FILE = "testCastEmptyInnerSchema.txt";
+            PrintWriter w = new PrintWriter(new FileWriter(INP_FILE));
+            w.println("(1,2)");
+            w.println("(2,3)");
+            w.close();
+            PigServer pigServer = new PigServer(LOCAL);
+            
+            String query = "a = load '" + INP_FILE + "' as (t:tuple());" +
+            "b = foreach a generate (tuple(int, long))t;" +
+            "c = foreach b generate t.$0 + t.$1;";
+
+            
+            Util.registerMultiLineQuery(pigServer, query);
+
+            List<Tuple> expectedRes = 
+                Util.getTuplesFromConstantTupleStrings(
+                        new String[] {
+                                "(3L)",
+                                "(5L)",
+                        });
+            Iterator<Tuple> it = pigServer.openIterator("c");
+            Util.checkQueryOutputs(it, expectedRes);
+            
+        }
+
         //see PIG-2018
         @Test
         public void testCoGroupComplex(){
@@ -4119,4 +4150,5 @@ public class TestTypeCheckingValidatorNewLP {
                 fail("caught exception creating lp");
             }
         }
+
 }
