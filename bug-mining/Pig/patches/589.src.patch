diff --git a/CHANGES.txt b/CHANGES.txt
index db660d798..b0f1fb646 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -220,6 +220,8 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1737: New logical plan: Improve error messages when merge schema fail (daijy)
+
 PIG-1725: New logical plan: uidOnlySchema bug in LOGenerate (daijy)
 
 PIG-1729: New logical plan: Dereference does not add into plan after deepCopy (daijy)
diff --git a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
index 1564a4a8a..996676a54 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
@@ -142,6 +142,10 @@ public class LOGenerate extends LogicalRelationalOperator {
                 else {
                     // Merge uid with the exp field schema
                     mergedSchema = LogicalSchema.merge(mUserDefinedSchemaCopy, expSchema);
+                    if (mergedSchema==null) {
+                        throw new FrontendException("Cannot merge (" + expSchema.toString(false) + 
+                                ") with user defined schema (" + mUserDefinedSchemaCopy.toString(false) + ")", 1117);
+                    }
                     mergedSchema.mergeUid(expSchema);
                 }
                 for (LogicalFieldSchema fs : mergedSchema.getFields())
diff --git a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
index c93e46a90..6a9544142 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
@@ -71,19 +71,27 @@ public class LogicalSchema {
             }
         }
                
-        public String toString() {
+        public String toString(boolean verbose) {
+            String uidString = "";
+            if (verbose)
+                uidString="#" + uid;
+            
             if( type == DataType.BAG ) {
                 if( schema == null ) {
-                    return ( alias + "#" + uid + ":bag{}#" );
+                    return ( alias + uidString + ":bag{}" );
                 }
-                return ( alias + "#" + uid + ":bag{" + schema.toString() + "}" );
+                return ( alias + uidString + ":bag{" + schema.toString() + "}" );
             } else if( type == DataType.TUPLE ) {
                 if( schema == null ) {
-                    return ( alias + "#" + uid + ":tuple{}" );
+                    return ( alias + uidString + ":tuple{}" );
                 }
-                return ( alias + "#" + uid + ":tuple(" + schema.toString() + ")" );
+                return ( alias + uidString + ":tuple(" + schema.toString() + ")" );
             }
-            return ( alias + "#" + uid + ":" + DataType.findTypeName(type) );
+            return ( alias + uidString + ":" + DataType.findTypeName(type) );
+        }
+        
+        public String toString() {
+            return toString(true);
         }
         
         public void stampFieldSchema() {
@@ -338,11 +346,11 @@ public class LogicalSchema {
         return mergedSchema;
     }
     
-    public String toString() {
+    public String toString(boolean verbose) {
         StringBuilder str = new StringBuilder();
         
         for( LogicalFieldSchema field : fields ) {
-            str.append( field.toString() + "," );
+            str.append( field.toString(verbose) + "," );
         }
         if( fields.size() != 0 ) {
             str.deleteCharAt( str.length() -1 );
@@ -350,6 +358,10 @@ public class LogicalSchema {
         return str.toString();
     }
     
+    public String toString() {
+        return toString(true);
+    }
+    
     public void setTwoLevelAccessRequired(boolean flag) {
         twoLevelAccessRequired = flag;
     }
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index be369a716..c1e5783c0 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -32,6 +32,7 @@ import java.util.Random;
 import junit.framework.TestCase;
 
 import org.apache.pig.ExecType;
+import org.apache.pig.PigException;
 import org.apache.pig.PigServer;
 import org.apache.pig.builtin.BinStorage;
 import org.apache.pig.data.BagFactory;
@@ -42,6 +43,7 @@ import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.util.LogUtils;
 import org.apache.pig.test.utils.Identity;
 import org.junit.AfterClass;
 import org.junit.Before;
@@ -891,4 +893,22 @@ public class TestEvalPipeline2 extends TestCase {
         
         assertFalse(iter.hasNext());
     }
+    
+    // See PIG-1737
+    @Test
+    public void testMergeSchemaErrorMessage() throws IOException {
+        pigServer.registerQuery("a = load '1.txt' as (a0, a1, a2);");
+        pigServer.registerQuery("b = group a by (a0, a1);");
+        pigServer.registerQuery("c = foreach b generate flatten(group) as c0;");
+        
+        try {
+            pigServer.openIterator("c");
+        } catch (Exception e) {
+            PigException pe = LogUtils.getPigException(e);
+            assertTrue(pe.getErrorCode()==1117);
+            assertTrue(pe.getMessage().contains("Cannot merge"));
+            return;
+        }
+        fail();
+    }
 }
