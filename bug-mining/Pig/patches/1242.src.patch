diff --git a/CHANGES.txt b/CHANGES.txt
index 5300ffb59..15911a930 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -214,6 +214,8 @@ PIG-3013: BinInterSedes improve chararray sort performance (rohini)
 
 BUG FIXES
 
+PIG-3379: Alias reuse in nested foreach causes PIG script to fail (xuefuz via daijy)
+
 PIG-3432: typo in log message in SchemaTupleFrontend (epishkin via cheolsoo)
 
 PIG-3410: LimitOptimizer is applied before PartitionFilterOptimizer (aniket486)
diff --git a/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java b/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java
index e330a0efb..1ef1a26a3 100644
--- a/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/ProjectExpression.java
@@ -52,6 +52,12 @@ public class ProjectExpression extends ColumnExpression {
     private int col; // The column in the input which the project references.
                      // Count is zero based.
     private String alias; // The alias of the projected field.
+    
+    /**
+     * In Foreach inner plan, a projection can be made on a relational operator, which may get reused.
+     * However, the expression needs to be sticky to the operator on which the expression is projected.
+     */
+    private Operator projectedOperator;
 
     private LogicalRelationalOperator attachedRelationalOp;
 
@@ -91,11 +97,12 @@ public class ProjectExpression extends ColumnExpression {
      * @param attachedRelationalOp
      * @throws FrontendException
      */
-    public ProjectExpression(OperatorPlan plan, int inputNum, String alias,
+    public ProjectExpression(OperatorPlan plan, int inputNum, String alias, Operator projectedOp,
             LogicalRelationalOperator attachedRelationalOp) {
         super("Project", plan);
         this.input = inputNum;
         this.alias = alias;
+        this.projectedOperator = projectedOp;
         plan.add(this);
         this.attachedRelationalOp = attachedRelationalOp;
     }
@@ -126,6 +133,7 @@ public class ProjectExpression extends ColumnExpression {
         this.input = projExpr.input;
         this.col = projExpr.col;
         this.alias = projExpr.alias;
+        this.projectedOperator = projExpr.projectedOperator;
         this.attachedRelationalOp = projExpr.attachedRelationalOp;
         this.isRangeProject = projExpr.isRangeProject;
         this.startCol = projExpr.startCol;
@@ -239,6 +247,10 @@ public class ProjectExpression extends ColumnExpression {
     public String getColAlias() {
         return alias;
     }
+    
+    public Operator getProjectedOperator() {
+    	return this.projectedOperator;
+    }
 
     /**
      * Set the column number for this project.  This should only be called by
@@ -536,6 +548,7 @@ public class ProjectExpression extends ColumnExpression {
                 this.getAttachedRelationalOp());
         copy.setLocation( new SourceLocation( location ) );
         copy.alias = alias;
+        copy.projectedOperator = this.projectedOperator;
         copy.isRangeProject = this.isRangeProject;
         copy.startCol = this.startCol;
         copy.endCol = this.endCol;
diff --git a/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java b/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java
index ad7c4141d..dd03c98bd 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOInnerLoad.java
@@ -59,7 +59,7 @@ public class LOInnerLoad extends LogicalRelationalOperator {
         // to be able to dynamically adjust column number during optimization
         LogicalExpressionPlan exp = new LogicalExpressionPlan();
         
-        this.prj = new ProjectExpression( exp, 0, colAlias, foreach );
+        this.prj = new ProjectExpression( exp, 0, colAlias, null, foreach );
         this.foreach = foreach;
     }
 
diff --git a/src/org/apache/pig/parser/LogicalPlanBuilder.java b/src/org/apache/pig/parser/LogicalPlanBuilder.java
index 99e481d76..dadc59d3a 100644
--- a/src/org/apache/pig/parser/LogicalPlanBuilder.java
+++ b/src/org/apache/pig/parser/LogicalPlanBuilder.java
@@ -19,7 +19,6 @@
 package org.apache.pig.parser;
 
 import java.io.IOException;
-import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.net.MalformedURLException;
@@ -29,8 +28,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 import org.antlr.runtime.IntStream;
 import org.antlr.runtime.RecognitionException;
@@ -54,8 +51,6 @@ import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
-import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
 import org.apache.pig.impl.plan.NodeIdGenerator;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.streaming.StreamingCommand;
@@ -103,8 +98,6 @@ import org.apache.pig.newplan.logical.rules.OptimizerUtils;
 import org.apache.pig.newplan.logical.visitor.ProjStarInUdfExpander;
 import org.apache.pig.newplan.logical.visitor.ProjectStarExpander;
 
-import com.google.common.collect.Lists;
-
 public class LogicalPlanBuilder {
 
     private LogicalPlan plan = new LogicalPlan();
@@ -556,7 +549,7 @@ public class LogicalPlanBuilder {
 		        .getFields();
 		for (int i = 0; i < fields.size(); i++) {
 		    LogicalExpressionPlan lEplan = new LogicalExpressionPlan();
-		    new ProjectExpression(lEplan, i, fields.get(i).alias, gen);
+		    new ProjectExpression(lEplan, i, fields.get(i).alias, null, gen);
 		    allExprPlan.add(lEplan);
 		}
 	    }
@@ -649,7 +642,7 @@ public class LogicalPlanBuilder {
 	// Generate and Foreach operator creation
 	String falias = null;
 	try {
-	    buildGenerateOp(loc, (LOForEach) foreach, (LOGenerate) gen, operators, allExprPlan,
+	    buildGenerateOp(loc, (LOForEach) foreach, (LOGenerate) gen, allExprPlan,
 		    flattenFlags, getUserDefinedSchema(allExprPlan));
 	    falias = buildForeachOp(loc, (LOForEach) foreach, "cube", inputAlias, innerPlan);
 	} catch (ParserValidationException pve) {
@@ -668,7 +661,7 @@ public class LogicalPlanBuilder {
 	for (LogicalExpressionPlan exp : expressionPlans.values()) {
 	    LogicalExpression lexp = (LogicalExpression) exp.getSources().get(0);
 	    LogicalExpressionPlan epGrp = new LogicalExpressionPlan();
-	    new ProjectExpression(epGrp, 0, lexp.getFieldSchema().alias, groupby);
+	    new ProjectExpression(epGrp, 0, lexp.getFieldSchema().alias, null, groupby);
 	    exprPlansCopy.put(0, epGrp);
 	}
 
@@ -944,7 +937,6 @@ public class LogicalPlanBuilder {
     }
 
     void buildGenerateOp(SourceLocation loc, LOForEach foreach, LOGenerate gen,
-            Map<String, Operator> operators,
             List<LogicalExpressionPlan> exprPlans, List<Boolean> flattenFlags,
             List<LogicalSchema> schemas)
     throws ParserValidationException {
@@ -969,7 +961,7 @@ public class LogicalPlanBuilder {
             }
             idx++;
             try {
-                processExpressionPlan( foreach, innerPlan, exprPlan, operators, inputs );
+                processExpressionPlan( foreach, innerPlan, exprPlan, inputs );
             } catch (FrontendException e) {
                 throw new ParserValidationException(intStream, loc, e);
             }
@@ -991,14 +983,12 @@ public class LogicalPlanBuilder {
      * @param foreach
      * @param lp Logical plan in which the LOGenerate is in
      * @param plan One of the output expression of the LOGenerate
-     * @param operators All logical operators in lp;
      * @param inputs  inputs of the LOGenerate
      * @throws FrontendException
      */
     private static void processExpressionPlan(LOForEach foreach,
                                       LogicalPlan lp,
                                       LogicalExpressionPlan plan,
-                                      Map<String, Operator> operators,
                                       ArrayList<Operator> inputs ) throws FrontendException {
         Iterator<Operator> it = plan.getOperators();
         while( it.hasNext() ) {
@@ -1013,10 +1003,9 @@ public class LogicalPlanBuilder {
                             new ProjectExpression(projExpr, new LogicalExpressionPlan())
                     );
                     setupInnerLoadAndProj(innerLoad, projExpr, lp, inputs);
-                }
-                else if( colAlias != null ) {
+                } else if( colAlias != null ) {
                     // the project is using a column alias
-                    Operator op = operators.get( colAlias );
+                    Operator op = projExpr.getProjectedOperator();
                     if( op != null ) {
                         // this means the project expression refers to a relation
                         // in the nested foreach
@@ -1268,7 +1257,7 @@ public class LogicalPlanBuilder {
      * @throws RecognitionException
      */
     LogicalExpression buildProjectExpr(SourceLocation loc, LogicalExpressionPlan plan, LogicalRelationalOperator op,
-            Map<String, LogicalExpressionPlan> exprPlans, String colAlias, int col)
+    		Map<String, Operator> operators, Map<String, LogicalExpressionPlan> exprPlans, String colAlias, int col)
     throws RecognitionException {
         ProjectExpression result = null;
 
@@ -1307,7 +1296,7 @@ public class LogicalPlanBuilder {
                 }
                 return root;
             } else {
-                result = new ProjectExpression( plan, 0, colAlias, op );
+                result = new ProjectExpression( plan, 0, colAlias, operators.get( colAlias ), op );
                 result.setLocation( loc );
                 return result;
             }
@@ -1327,7 +1316,7 @@ public class LogicalPlanBuilder {
     throws ParserValidationException {
         ProjectExpression result = null;
         result = colAlias != null ?
-            new ProjectExpression( plan, input, colAlias, relOp ) :
+            new ProjectExpression( plan, input, colAlias, null, relOp ) :
             new ProjectExpression( plan, input, col, relOp );
         result.setLocation( loc );
         return result;
diff --git a/src/org/apache/pig/parser/LogicalPlanGenerator.g b/src/org/apache/pig/parser/LogicalPlanGenerator.g
index bcb8b544a..9686ac2ab 100644
--- a/src/org/apache/pig/parser/LogicalPlanGenerator.g
+++ b/src/org/apache/pig/parser/LogicalPlanGenerator.g
@@ -1602,8 +1602,7 @@ scope GScope;
    {
        builder.buildGenerateOp( new SourceLocation( (PigParserNode)$GENERATE ),
        	   inNestedCommand ? $nested_foreach::foreachOp : $foreach_clause::foreachOp,
-           (LOGenerate)$GScope::currentOp, $foreach_plan::operators,
-           plans, flattenFlags, schemas );
+           (LOGenerate)$GScope::currentOp, plans, flattenFlags, schemas );
    }
 ;
 
@@ -1745,7 +1744,7 @@ alias_col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
        } else {
            if( inForeachPlan ) {
                $expr = builder.buildProjectExpr( loc, $plan, $GScope::currentOp,
-                   $foreach_plan::exprPlans, alias, 0 );
+                    $foreach_plan::operators, $foreach_plan::exprPlans, alias, 0 );
            } else {
                $expr = builder.buildProjectExpr( loc, $plan, $GScope::currentOp,
                    $statement::inputIndex, alias, 0 );
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index 568012640..85b40a018 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -839,6 +839,55 @@ public class TestEvalPipeline2 {
         Assert.assertFalse(iter.hasNext());
     }
     
+    // See PIG-3379
+    @Test
+    public void testNestedOperatorReuse() throws Exception{
+        String[] input1 = {
+        		"60000\tdv1\txuaHeartBeat",
+        		"70000\tdv2\txuaHeartBeat",
+        		"80000\tdv1\txuaPowerOff",
+        		"90000\tdv1\txuaPowerOn",
+        		"110000\tdv2\txuaHeartBeat",
+        		"120000\tdv2\txuaPowerOff",
+        		"140000\tdv2\txuaPowerOn",
+        		"150000\tdv1\txuaHeartBeat",
+        		"160000\tdv2\txuaHeartBeat",
+        		"250000\tdv1\txuaHeartBeat",
+        		"310000\tdv2\txuaPowerOff",
+        		"360000\tdv1\txuaPowerOn",
+        		"420000\tdv3\txuaHeartBeat",
+        		"450000\tdv3\txuaHeartBeat",
+        		"540000\tdv4\txuaPowerOn",
+        		"550000\tdv3\txuaHeartBeat",
+        		"560000\tdv5\txuaHeartBeat" };
+        Util.createInputFile( cluster, "table_testNestedOperatorReuse", input1 );
+        String query = "Events = LOAD 'table_testNestedOperatorReuse' AS (eventTime:long, deviceId:chararray, eventName:chararray);" +
+        		"Events = FOREACH Events GENERATE eventTime, deviceId, eventName;" +
+        		"EventsPerMinute = GROUP Events BY (eventTime / 60000);" +
+        		"EventsPerMinute = FOREACH EventsPerMinute {" +
+        		"  DistinctDevices = DISTINCT Events.deviceId;" +
+        		"  nbDevices = SIZE(DistinctDevices);" +
+        		"  DistinctDevices = FILTER Events BY eventName == 'xuaHeartBeat';" +
+        		"  nbDevicesWatching = SIZE(DistinctDevices);" +
+        		"  GENERATE $0*60000 as timeStamp, nbDevices as nbDevices, nbDevicesWatching as nbDevicesWatching;" +
+        		"}" +
+        		"EventsPerMinute = FILTER EventsPerMinute BY timeStamp >= 0  AND timeStamp < 300000;";
+
+        pigServer.registerQuery(query);
+        Iterator<Tuple> iter = pigServer.openIterator("EventsPerMinute");
+        
+        Tuple t = iter.next();
+        Assert.assertTrue( (Long)t.get(0) == 60000 && (Long)t.get(1) == 2 && (Long)t.get(2) == 3 );
+        
+        t = iter.next();
+        Assert.assertTrue( (Long)t.get(0) == 120000 && (Long)t.get(1) == 2 && (Long)t.get(2) == 2 );
+        
+        t = iter.next();
+        Assert.assertTrue( (Long)t.get(0) == 240000 && (Long)t.get(1) == 1 && (Long)t.get(2) == 1 );
+
+        Assert.assertFalse(iter.hasNext());
+    }
+
     // See PIG-1729
     @Test
     public void testDereferenceInnerPlan() throws Exception{
