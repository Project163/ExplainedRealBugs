diff --git a/CHANGES.txt b/CHANGES.txt
index c7d0fab5d..6e1a2076a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,6 +26,8 @@ IMPROVEMENTS
  
 BUG FIXES
 
+PIG-3413: JsonLoader fails the pig job in case of malformed json input (eyal via daijy)
+
 PIG-4247: S3 properties are not picked up from core-site.xml in local mode (cheolsoo)
 
 PIG-4242: For indented xmls with multiline content (e.g. wikipedia) XMLLoader cuts out the begining of every line
diff --git a/src/org/apache/pig/builtin/JsonLoader.java b/src/org/apache/pig/builtin/JsonLoader.java
index 4ddb0967d..e11ff3550 100644
--- a/src/org/apache/pig/builtin/JsonLoader.java
+++ b/src/org/apache/pig/builtin/JsonLoader.java
@@ -28,6 +28,7 @@ import java.util.Properties;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.format.DateTimeFormatter;
 import org.codehaus.jackson.JsonFactory;
+import org.codehaus.jackson.JsonParseException;
 import org.codehaus.jackson.JsonParser;
 import org.codehaus.jackson.JsonToken;
 import org.apache.hadoop.io.Text;
@@ -149,23 +150,31 @@ public class JsonLoader extends LoadFunc implements LoadMetadata {
         // isn't what we expect we return a tuple with null fields rather than
         // throwing an exception.  That way a few mangled lines don't fail the
         // job.
-        if (p.nextToken() != JsonToken.START_OBJECT) {
-            warn("Bad record, could not find start of record " +
-                val.toString(), PigWarning.UDF_WARNING_1);
-            return t;
-        }
-
-        // Read each field in the record
-        for (int i = 0; i < fields.length; i++) {
-            t.set(i, readField(p, fields[i], i));
-        }
-
-        if (p.nextToken() != JsonToken.END_OBJECT) {
-            warn("Bad record, could not find end of record " +
-                val.toString(), PigWarning.UDF_WARNING_1);
-            return t;
+        
+        try {
+            if (p.nextToken() != JsonToken.START_OBJECT) {
+                warn("Bad record, could not find start of record " +
+                    val.toString(), PigWarning.UDF_WARNING_1);
+                return t;
+            }
+    
+            // Read each field in the record
+            for (int i = 0; i < fields.length; i++) {
+                t.set(i, readField(p, fields[i], i));
+            }
+    
+            if (p.nextToken() != JsonToken.END_OBJECT) {
+                warn("Bad record, could not find end of record " +
+                    val.toString(), PigWarning.UDF_WARNING_1);
+                return t;
+            }
+            
+        } catch (JsonParseException jpe) {
+            warn("Bad record, returning null for " + val, PigWarning.UDF_WARNING_1);
+        } finally {
+            p.close();
         }
-        p.close();
+        
         return t;
     }
 
diff --git a/test/org/apache/pig/test/TestJsonLoaderStorage.java b/test/org/apache/pig/test/TestJsonLoaderStorage.java
index 410eafb96..c34de9282 100644
--- a/test/org/apache/pig/test/TestJsonLoaderStorage.java
+++ b/test/org/apache/pig/test/TestJsonLoaderStorage.java
@@ -111,7 +111,21 @@ public class TestJsonLoaderStorage {
     "\"l\":null," +
     "\"m\":null" +
     "}";
-
+  
+  private static final String badJson =
+    "{" +
+    "\"a\":\"good\"," +
+    "\"b\":\"good\"" +
+    "}\n" +
+	"{" +
+    "\"a\":bad," +
+    "\"b\":\"good\"" +
+    "}\n" +
+	"{" +
+    "\"a\":\"good\"," +
+    "\"b\":\"good\"" +
+    "}";
+      
   private static final String jsonOutput =
     "{\"f1\":\"18\",\"count\":3}";
 
@@ -214,6 +228,34 @@ public class TestJsonLoaderStorage {
     assertEquals(1, count);
   }
 
+  @SuppressWarnings("rawtypes")
+  @Test
+  public void testJsonLoaderBadRow() throws Exception{
+
+    String badJsonFile = createInput(badJson);
+    pigServer.registerQuery("data = load '" + badJsonFile + "' using JsonLoader('a:chararray, b:chararray');");
+    Iterator<Tuple> tuples = pigServer.openIterator("data");
+    
+    Tuple t = tuples.next();
+    assertTrue(t.size()==2);
+    assertTrue(t.get(0)!=null);
+    assertTrue(t.get(1)!=null);
+    assertTrue(tuples.hasNext());
+
+    // bad row - skip it, returning a null tuple.
+    t = tuples.next();
+    assertTrue(t.size()==2);
+    assertTrue(t.get(0)==null);
+    assertTrue(t.get(1)==null);
+    assertTrue(tuples.hasNext());
+
+    t = tuples.next();
+    assertTrue(t.size()==2);
+    assertTrue(t.get(0)!=null);
+    assertTrue(t.get(1)!=null);
+    assertTrue(!tuples.hasNext());
+  }
+  
   @Test
   public void testJsonLoaderNull() throws IOException {
     Iterator<Tuple> tuples = loadJson(nullJson);
