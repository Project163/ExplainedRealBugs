diff --git a/CHANGES.txt b/CHANGES.txt
index 591725f78..f783ef07c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -243,6 +243,8 @@ PIG-1212: LogicalPlan.replaceAndAddSucessors produce wrong result when successor
 
 PIG-1255: Tiny code cleanup for serialization code for PigSplit (daijy)
 
+PIG-613: Casting elements inside a tuple does not take effect (daijy)
+
 Release 0.6.0 - Unreleased
 
 INCOMPATIBLE CHANGES
diff --git a/build.xml b/build.xml
index fc8d97944..e97b972b4 100644
--- a/build.xml
+++ b/build.xml
@@ -246,8 +246,6 @@
         <javacc target="${src.dir}/org/apache/pig/tools/parameters/ParamLoader.jj" outputdirectory="${src.gen.param.parser.dir}" javacchome="${javacc.home}" />
         <jjtree target="${test.src.dir}/org/apache/pig/test/utils/dotGraph/DOTParser.jjt" outputdirectory="${src.gen.dot.parser.dir}" javacchome="${javacc.home}" />
         <javacc target="${src.gen.dot.parser.dir}/DOTParser.jj" outputdirectory="${src.gen.dot.parser.dir}" javacchome="${javacc.home}" />
-        <jjtree target="${src.dir}/org/apache/pig/data/parser/TextDataParser.jjt" outputdirectory="${src.gen.textdata.parser.dir}/" javacchome="${javacc.home}" />
-        <javacc target="${src.gen.textdata.parser.dir}/TextDataParser.jj" outputdirectory="${src.gen.textdata.parser.dir}" javacchome="${javacc.home}" />
     </target>
 
     <!-- ================================================================== -->
diff --git a/src/org/apache/pig/LoadCaster.java b/src/org/apache/pig/LoadCaster.java
index 6da5c6e91..e67665f3e 100644
--- a/src/org/apache/pig/LoadCaster.java
+++ b/src/org/apache/pig/LoadCaster.java
@@ -6,6 +6,7 @@ package org.apache.pig;
 import java.io.IOException;
 import java.util.Map;
 
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.Tuple;
 
@@ -65,17 +66,19 @@ public interface LoadCaster {
     /**
      * Cast data from bytes to tuple value.  
      * @param b byte array to be cast.
+     * @param fieldSchema field schema for the output tuple
      * @return Tuple value.
      * @throws IOException if the value cannot be cast.
      */
-    public Tuple bytesToTuple(byte[] b) throws IOException;
+    public Tuple bytesToTuple(byte[] b, ResourceFieldSchema fieldSchema) throws IOException;
 
     /**
      * Cast data from bytes to bag value.  
      * @param b byte array to be cast.
+     * @param fieldSchema field schema for the output bag
      * @return Bag value.
      * @throws IOException if the value cannot be cast.
      */
-    public DataBag bytesToBag(byte[] b) throws IOException;
+    public DataBag bytesToBag(byte[] b, ResourceFieldSchema fieldSchema) throws IOException;
 
 }
diff --git a/src/org/apache/pig/ResourceSchema.java b/src/org/apache/pig/ResourceSchema.java
index 97e9aec10..1ffa9aa80 100644
--- a/src/org/apache/pig/ResourceSchema.java
+++ b/src/org/apache/pig/ResourceSchema.java
@@ -125,12 +125,22 @@ public class ResourceSchema implements Serializable {
                 
         @Override
         public String toString() {
+            return getDescription(true);
+        }
+        
+        public String getCastString() {
+            return getDescription(false);
+        }
+        
+        private String getDescription(boolean printAlias) {
             StringBuilder sb = new StringBuilder();
-            sb.append(this.name).append(":");
-            if (DataType.isAtomic(this.type)) {
+            if (printAlias)
+                sb.append(this.name).append(":");
+            if (DataType.isAtomic(this.type)||this.type==DataType.MAP) {
                 sb.append(DataType.findTypeName(this.type));
             } else {
-                stringifyResourceSchema(sb, this.schema, this.type);
+                if (this.schema!=null)
+                    stringifyResourceSchema(sb, this.schema, this.type, printAlias);
             }
             return sb.toString();
         }
@@ -253,12 +263,12 @@ public class ResourceSchema implements Serializable {
     @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
-        stringifyResourceSchema(sb, this, DataType.UNKNOWN) ;
+        stringifyResourceSchema(sb, this, DataType.UNKNOWN, true) ;
         return sb.toString();
     }
     
     private static void stringifyResourceSchema(StringBuilder sb, 
-            ResourceSchema rs, byte type) {
+            ResourceSchema rs, byte type, boolean printAlias) {
         if (type == DataType.UNKNOWN) {
             sb.append("<");
         } else if (type == DataType.BAG) {
@@ -268,7 +278,7 @@ public class ResourceSchema implements Serializable {
         }
         
         for (int i=0; i<rs.getFields().length; i++) {
-            sb.append(rs.getFields()[i].toString());
+            sb.append(rs.getFields()[i].getDescription(printAlias));
             if (i < rs.getFields().length - 1) {
                 sb.append(",");
             }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index 73555b369..ff2737430 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -40,6 +40,7 @@ import org.apache.pig.data.NonSpillableDataBag;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.PigContext;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhysicalPlan;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.*;
@@ -1815,7 +1816,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
     @Override
     public void visit(LOCast op) throws VisitorException {
         String scope = op.getOperatorKey().scope;
-        ExpressionOperator physOp = new POCast(new OperatorKey(scope, nodeGen
+        POCast physOp = new POCast(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), op.getRequestedParallelism());
         physOp.setAlias(op.getAlias());
         currentPlan.add(physOp);
@@ -1824,10 +1825,19 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         ExpressionOperator from = (ExpressionOperator) logToPhyMap.get(op
                 .getExpression());
         physOp.setResultType(op.getType());
+        try {
+            if (op.getType()==DataType.BAG || op.getType()==DataType.TUPLE) {
+                physOp.setFieldSchema(new ResourceFieldSchema(op.getFieldSchema()));
+            }
+        } catch (FrontendException e) {
+            int errCode = 2216;
+            String msg = "Cannot get field schema for "+op;
+            throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
+        }
         FuncSpec lfSpec = op.getLoadFuncSpec();
         if(null != lfSpec) {
             try {
-                ((POCast) physOp).setFuncSpec(lfSpec);
+                physOp.setFuncSpec(lfSpec);
             } catch (IOException e) {
                 int errCode = 1053;
                 String msg = "Cannot resolve load function to use for casting" +
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
index 1e40efc11..45d4f4ef4 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
@@ -29,6 +29,7 @@ import org.apache.pig.FuncSpec;
 import org.apache.pig.LoadCaster;
 import org.apache.pig.LoadFunc;
 import org.apache.pig.PigException;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
@@ -57,6 +58,7 @@ public class POCast extends ExpressionOperator {
     private boolean castNotNeeded = false;
     private Byte realType = null;
     private transient List<ExpressionOperator> child;
+    private ResourceFieldSchema fieldSchema = null;
 
     private static final long serialVersionUID = 1L;
 
@@ -97,7 +99,12 @@ public class POCast extends ExpressionOperator {
 
     @Override
     public String name() {
-        return "Cast" + "[" + DataType.findTypeName(resultType) + "]" + " - "
+        if (resultType==DataType.BAG||resultType==DataType.TUPLE)
+            return "Cast" + "[" + DataType.findTypeName(resultType)+":"
+            + fieldSchema.getCastString() + "]" + " - "
+            + mKey.toString();
+        else
+            return "Cast" + "[" + DataType.findTypeName(resultType) + "]" + " - "
                 + mKey.toString();
     }
 
@@ -762,7 +769,7 @@ public class POCast extends ExpressionOperator {
                 }
                 try {
                     if (null != caster) {
-                        res.result = caster.bytesToTuple(dba.get());
+                        res.result = caster.bytesToTuple(dba.get(), fieldSchema);
                     } else {
                         int errCode = 1075;
                         String msg = "Received a bytearray from the UDF. Cannot determine how to convert the bytearray to tuple.";
@@ -850,7 +857,7 @@ public class POCast extends ExpressionOperator {
                 }
                 try {
                     if (null != caster) {
-                        res.result = caster.bytesToBag(dba.get());
+                        res.result = caster.bytesToBag(dba.get(), fieldSchema);
                     } else {
                         int errCode = 1075;
                         String msg = "Received a bytearray from the UDF. Cannot determine how to convert the bytearray to bag.";
@@ -992,6 +999,7 @@ public class POCast extends ExpressionOperator {
                 .getGenerator().getNextNodeId(mKey.scope)));
         clone.cloneHelper(this);
         clone.funcSpec = funcSpec;
+        clone.fieldSchema = fieldSchema;
         try {
             clone.instantiateFunc();
         } catch (IOException e) {
@@ -1016,5 +1024,9 @@ public class POCast extends ExpressionOperator {
         
         return child;				
     }
+    
+    public void setFieldSchema(ResourceFieldSchema s) {
+        fieldSchema = s;
+    }
 
 }
diff --git a/src/org/apache/pig/builtin/BinStorage.java b/src/org/apache/pig/builtin/BinStorage.java
index 84b5f9ad4..aeb1a06f4 100644
--- a/src/org/apache/pig/builtin/BinStorage.java
+++ b/src/org/apache/pig/builtin/BinStorage.java
@@ -45,6 +45,7 @@ import org.apache.pig.LoadMetadata;
 import org.apache.pig.PigException;
 import org.apache.pig.PigWarning;
 import org.apache.pig.ResourceSchema;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.ResourceStatistics;
 import org.apache.pig.StoreFuncInterface;
 import org.apache.pig.backend.executionengine.ExecException;
@@ -104,7 +105,7 @@ implements LoadCaster, StoreFuncInterface, LoadMetadata {
     }
 
     @Override
-    public DataBag bytesToBag(byte[] b){
+    public DataBag bytesToBag(byte[] b, ResourceFieldSchema schema){
         DataInputStream dis = new DataInputStream(new ByteArrayInputStream(b));
         try {
             return DataReaderWriter.bytesToBag(dis);
@@ -209,7 +210,7 @@ implements LoadCaster, StoreFuncInterface, LoadMetadata {
     }
 
     @Override
-    public Tuple bytesToTuple(byte[] b) {
+    public Tuple bytesToTuple(byte[] b, ResourceFieldSchema schema) {
         DataInputStream dis = new DataInputStream(new ByteArrayInputStream(b));
         try {
             return DataReaderWriter.bytesToTuple(dis);
diff --git a/src/org/apache/pig/builtin/TextLoader.java b/src/org/apache/pig/builtin/TextLoader.java
index 5e8325b6a..d2abc9324 100644
--- a/src/org/apache/pig/builtin/TextLoader.java
+++ b/src/org/apache/pig/builtin/TextLoader.java
@@ -29,6 +29,7 @@ import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
 import org.apache.pig.LoadCaster;
 import org.apache.pig.LoadFunc;
 import org.apache.pig.PigException;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;
 import org.apache.pig.data.DataBag;
@@ -133,7 +134,7 @@ public class TextLoader extends LoadFunc implements LoadCaster {
      * @throws IOException if the value cannot be cast.
      */
     @Override
-    public Tuple bytesToTuple(byte[] b) throws IOException {
+    public Tuple bytesToTuple(byte[] b, ResourceFieldSchema schema) throws IOException {
         int errCode = 2109;
         String msg = "TextLoader does not support conversion to Tuple.";
         throw new ExecException(msg, errCode, PigException.BUG);
@@ -143,7 +144,7 @@ public class TextLoader extends LoadFunc implements LoadCaster {
      * TextLoader does not support conversion to Bag
      * @throws IOException if the value cannot be cast.
      */
-    public DataBag bytesToBag(byte[] b) throws IOException {
+    public DataBag bytesToBag(byte[] b, ResourceFieldSchema schema) throws IOException {
         int errCode = 2109;
         String msg = "TextLoader does not support conversion to Bag.";
         throw new ExecException(msg, errCode, PigException.BUG);
diff --git a/src/org/apache/pig/builtin/Utf8StorageConverter.java b/src/org/apache/pig/builtin/Utf8StorageConverter.java
index 76e74c515..c564df132 100644
--- a/src/org/apache/pig/builtin/Utf8StorageConverter.java
+++ b/src/org/apache/pig/builtin/Utf8StorageConverter.java
@@ -17,27 +17,27 @@
  */
 package org.apache.pig.builtin;
 
-import java.io.IOException;
-import java.util.Map;
 import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
 import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Stack;
 
-import org.apache.commons.logging.LogFactory;
 import org.apache.commons.logging.Log;
-
+import org.apache.commons.logging.LogFactory;
 import org.apache.pig.LoadCaster;
-import org.apache.pig.PigException;
 import org.apache.pig.PigWarning;
-import org.apache.pig.backend.executionengine.ExecException;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PigLogger;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
+import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
+import org.apache.pig.data.DataByteArray;
 import org.apache.pig.data.DataType;
+import org.apache.pig.data.DefaultBagFactory;
+import org.apache.pig.data.DefaultTupleFactory;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
-import org.apache.pig.data.BagFactory;
-import org.apache.pig.data.parser.ParseException;
-import org.apache.pig.data.parser.TextDataParser;
 import org.apache.pig.impl.util.LogUtils;
 
 /**
@@ -53,40 +53,246 @@ public class Utf8StorageConverter implements LoadCaster {
 
     private Integer mMaxInt = Integer.valueOf(Integer.MAX_VALUE);
     private Long mMaxLong = Long.valueOf(Long.MAX_VALUE);
-    private TextDataParser dataParser = null;
+    private static final int BUFFER_SIZE = 1024;
         
     public Utf8StorageConverter() {
     }
 
-    private Object parseFromBytes(byte[] b) throws ParseException {
-        ByteArrayInputStream in = new ByteArrayInputStream(b);
-        if(dataParser == null) {
-            dataParser = new TextDataParser(in);
-        } else {
-            dataParser.ReInit(in);
+    private char findStartChar(char start) throws IOException{
+        switch (start) {
+        case ')': return '(';
+        case ']': return '[';
+        case '}': return '{';
+        default: throw new IOException("Unknown start character");
         }
-        return dataParser.Parse();
+    }
+    
+    private DataBag consumeBag(ByteArrayInputStream in, ResourceFieldSchema fieldSchema) throws IOException {
+        if (fieldSchema==null) {
+            throw new IOException("Schema is null");
+        }
+        ResourceFieldSchema[] fss=fieldSchema.getSchema().getFields();;
+        Tuple t;
+        int buf;
+        while ((buf=in.read())!='{') {
+            if (buf==-1) {
+                throw new IOException("Unexpect end of bag");
+            }
+        }
+        if (fss.length!=1)
+            throw new IOException("Only tuple is allowed inside bag schema");
+        ResourceFieldSchema fs = fss[0];
+        DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
+        while (true) {
+            t = consumeTuple(in, fs);
+            db.add(t);
+            while ((buf=in.read())!='}'&&buf!=',') {
+                if (buf==-1) {
+                    throw new IOException("Unexpect end of bag");
+                }
+            }
+            if (buf=='}')
+                break;
+        }
+        return db;
+    }
+    
+    private Tuple consumeTuple(ByteArrayInputStream in, ResourceFieldSchema fieldSchema) throws IOException {
+        if (fieldSchema==null) {
+            throw new IOException("Schema is null");
+        }
+        int buf;
+        ByteArrayOutputStream mOut;
+        
+        while ((buf=in.read())!='(') {
+            if (buf==-1) {
+                throw new IOException("Unexpect end of tuple");
+            }
+        }
+        Tuple t = DefaultTupleFactory.getInstance().newTuple();
+        if (fieldSchema.getSchema()!=null && fieldSchema.getSchema().getFields().length!=0) {
+            ResourceFieldSchema[] fss = fieldSchema.getSchema().getFields();
+            // Interpret item inside tuple one by one based on the inner schema
+            for (int i=0;i<fss.length;i++) {
+                Object field;
+                ResourceFieldSchema fs = fss[i];
+                int delimit = ',';
+                if (i==fss.length-1)
+                    delimit = ')';
+                
+                if (DataType.isComplex(fs.getType())) {
+                    field = consumeComplexType(in, fs);
+                    while ((buf=in.read())!=delimit) {
+                        if (buf==-1) {
+                            throw new IOException("Unexpect end of tuple");
+                        }
+                    }
+                }
+                else {
+                    mOut = new ByteArrayOutputStream(BUFFER_SIZE);
+                    while ((buf=in.read())!=delimit) {
+                        if (buf==-1) {
+                            throw new IOException("Unexpect end of tuple");
+                        }
+                        if (buf==delimit)
+                            break;
+                        mOut.write(buf);
+                    }
+                    field = parseSimpleType(mOut.toByteArray(), fs);
+                }
+                t.append(field);
+            }
+        }
+        else {
+            // No inner schema, treat everything inside tuple as bytearray
+            Stack<Character> level = new Stack<Character>();  // keep track of nested tuple/bag/map. We do not interpret, save them as bytearray
+            mOut = new ByteArrayOutputStream(BUFFER_SIZE);
+            while (true) {
+                buf=in.read();
+                if (buf==-1) {
+                    throw new IOException("Unexpect end of tuple");
+                }
+                if (buf=='['||buf=='{'||buf=='(') {
+                    level.push((char)buf);
+                }
+                else if (buf==')' && level.isEmpty()) // End of tuple
+                    break;
+                else if (buf==']' ||buf=='}'||buf==')')
+                {
+                    if (level.peek()==findStartChar((char)buf))
+                        level.pop();
+                    else
+                        throw new IOException("Malformed tuple");
+                }
+                mOut.write(buf);
+            }
+            DataByteArray value = new DataByteArray(mOut.toByteArray());
+            t.append(value);
+        }
+        return t;
+    }
+    
+    private Map<String, Object> consumeMap(ByteArrayInputStream in, ResourceFieldSchema fieldSchema) throws IOException {
+        if (fieldSchema==null) {
+            throw new IOException("Schema is null");
+        }
+        int buf;
+        
+        while ((buf=in.read())!='[') {
+            if (buf==-1) {
+                throw new IOException("Unexpect end of map");
+            }
+        }
+        HashMap<String, Object> m = new HashMap<String, Object>();
+        ByteArrayOutputStream mOut = new ByteArrayOutputStream(BUFFER_SIZE);
+        while (true) {
+            // Read key (assume key can not contains special character such as #, (, [, {, }, ], )
+            while ((buf=in.read())!='#') {
+                if (buf==-1) {
+                    throw new IOException("Unexpect end of map");
+                }
+                mOut.write(buf);
+            }
+            String key = bytesToCharArray(mOut.toByteArray());
+            if (key.length()==0)
+                throw new IOException("Map key can not be null");
+            
+            // Read value
+            mOut.reset();
+            Stack<Character> level = new Stack<Character>(); // keep track of nested tuple/bag/map. We do not interpret, save them as bytearray
+            while (true) {
+                buf=in.read();
+                if (buf==-1) {
+                    throw new IOException("Unexpect end of map");
+                }
+                if (buf=='['||buf=='{'||buf=='(') {
+                    level.push((char)buf);
+                }
+                else if (buf==']' && level.isEmpty()) // End of map
+                    break;
+                else if (buf==']' ||buf=='}'||buf==')')
+                {
+                    if (level.peek()==findStartChar((char)buf))
+                        level.pop();
+                    else
+                        throw new IOException("Malformed map");
+                } else if (buf==','&&level.isEmpty()) { // Current map item complete
+                    break;
+                }
+                mOut.write(buf);
+            }
+            DataByteArray value = null;
+            if (mOut.size()>0)
+                value = new DataByteArray(mOut.toByteArray());
+            m.put(key, value);
+            mOut.reset();
+            if (buf==']')
+                break;
+        }
+        return m;
+    }
+    
+    private Object consumeComplexType(ByteArrayInputStream in, ResourceFieldSchema complexFieldSchema) throws IOException {
+        Object field;
+        switch (complexFieldSchema.getType()) {
+        case DataType.BAG:
+            field = consumeBag(in, complexFieldSchema);
+            break;
+        case DataType.TUPLE:
+            field = consumeTuple(in, complexFieldSchema);
+            break;
+        case DataType.MAP:
+            field = consumeMap(in, complexFieldSchema);
+            break;
+        default:
+            throw new IOException("Unknown complex data type");
+        }
+        return field;
+    }
+    
+    private Object parseSimpleType(byte[] b, ResourceFieldSchema simpleFieldSchema) throws IOException {
+        Object field;
+        switch (simpleFieldSchema.getType()) {
+        case DataType.INTEGER:
+            field = bytesToInteger(b);
+            break;
+        case DataType.LONG:
+            field = bytesToLong(b);
+            break;
+        case DataType.FLOAT:
+            field = bytesToFloat(b);
+            break;
+        case DataType.DOUBLE:
+            field = bytesToDouble(b);
+            break;
+        case DataType.CHARARRAY:
+            field = bytesToCharArray(b);
+            break;
+        case DataType.BYTEARRAY:
+            field = new DataByteArray(b);
+            break;
+        case DataType.BOOLEAN:
+            field = bytesToBoolean(b);
+            break;
+        default:
+            throw new IOException("Unknown simple data type");
+        }
+        return field;
     }
 
-    public DataBag bytesToBag(byte[] b) throws IOException {
+    public DataBag bytesToBag(byte[] b, ResourceFieldSchema schema) throws IOException {
         if(b == null)
             return null;
         DataBag db;
         try {
-            db = (DataBag)parseFromBytes(b);
-        } catch (ParseException pe) {
+            ByteArrayInputStream in = new ByteArrayInputStream(b);
+            db = consumeBag(in, schema);
+        } catch (IOException e) {
             LogUtils.warn(this, "Unable to interpret value " + Arrays.toString(b) + " in field being " +
                     "converted to type bag, caught ParseException <" +
-                    pe.getMessage() + "> field discarded", 
-                    PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, mLog);
-            return null;       
-        }catch (Exception e){
-            // can happen if parseFromBytes identifies it as being of different type
-            LogUtils.warn(this, "Unable to interpret value " + Arrays.toString(b) + " in field being " +
-                    "converted to type bag, caught Exception <" +
                     e.getMessage() + "> field discarded", 
                     PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, mLog);
-            return null;       
+            return null;
         }
         return db;
     }
@@ -133,6 +339,13 @@ public class Utf8StorageConverter implements LoadCaster {
             return null;
         }
     }
+    
+    public Boolean bytesToBoolean(byte[] b) throws IOException {
+        if(b == null)
+            return null;
+        String s = new String(b);
+        return Boolean.valueOf(s);
+    }
 
     public Integer bytesToInteger(byte[] b) throws IOException {
         if(b == null)
@@ -208,19 +421,15 @@ public class Utf8StorageConverter implements LoadCaster {
         if(b == null)
             return null;
         Map<String, Object> map;
+        ResourceFieldSchema fs = new ResourceFieldSchema();
+        fs.setType(DataType.MAP);
         try {
-            map = (Map<String, Object>)parseFromBytes(b);
+            ByteArrayInputStream in = new ByteArrayInputStream(b);
+            map = consumeMap(in, fs);
         }
-        catch (ParseException pe) {
+        catch (IOException e) {
             LogUtils.warn(this, "Unable to interpret value " + Arrays.toString(b) + " in field being " +
                     "converted to type map, caught ParseException <" +
-                    pe.getMessage() + "> field discarded", 
-                    PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, mLog);
-            return null;       
-        }catch (Exception e){
-            // can happen if parseFromBytes identifies it as being of different type
-            LogUtils.warn(this, "Unable to interpret value " + Arrays.toString(b) + " in field being " +
-                    "converted to type map, caught Exception <" +
                     e.getMessage() + "> field discarded", 
                     PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, mLog);
             return null;       
@@ -228,27 +437,23 @@ public class Utf8StorageConverter implements LoadCaster {
         return map;
     }
 
-    public Tuple bytesToTuple(byte[] b) throws IOException {
+    public Tuple bytesToTuple(byte[] b, ResourceFieldSchema fieldSchema) throws IOException {
         if(b == null)
             return null;
         Tuple t;
+        
         try {
-            t = (Tuple)parseFromBytes(b);
+            ByteArrayInputStream in = new ByteArrayInputStream(b);
+            t = consumeTuple(in, fieldSchema);
         } 
-        catch (ParseException pe) {
+        catch (IOException e) {
             LogUtils.warn(this, "Unable to interpret value " + Arrays.toString(b) + " in field being " +
                     "converted to type tuple, caught ParseException <" +
-                    pe.getMessage() + "> field discarded", 
-                    PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, mLog);
-            return null;       
-        }catch (Exception e){
-            // can happen if parseFromBytes identifies it as being of different type
-            LogUtils.warn(this, "Unable to interpret value " + Arrays.toString(b) + " in field being " +
-                    "converted to type tuple, caught Exception <" +
                     e.getMessage() + "> field discarded", 
                     PigWarning.FIELD_DISCARDED_TYPE_CONVERSION_FAILED, mLog);
             return null;       
         }
+
         return t;
     }
 
diff --git a/src/org/apache/pig/data/parser/TextDataParser.jjt b/src/org/apache/pig/data/parser/TextDataParser.jjt
deleted file mode 100644
index 63436120b..000000000
--- a/src/org/apache/pig/data/parser/TextDataParser.jjt
+++ /dev/null
@@ -1,235 +0,0 @@
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/**
- * JavaCC file
- * This file lists the grammar for PIG Latin.
- * QueryParser program ouputs a ParseTree given a Valid Pig Latin Query
- */
-options {
-  // Generate non-static functions
-  STATIC = false;
-  // Case is ignored in keywords
-  IGNORE_CASE = true;
-  USER_TOKEN_MANAGER = false;
-  USER_CHAR_STREAM = false;
-}
-
-PARSER_BEGIN(TextDataParser)
-package org.apache.pig.data.parser;
-import java.io.*;
-import java.util.*;
-import org.apache.pig.data.DataType;
-import org.apache.pig.impl.PigContext;
-import org.apache.pig.impl.io.*;
-import org.apache.pig.builtin.PigStorage;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.pig.data.TupleFactory;
-import org.apache.pig.data.Tuple;
-import org.apache.pig.data.BagFactory;
-import org.apache.pig.data.DataBag;
-import org.apache.pig.data.DataByteArray;
-
-
-public class TextDataParser {
-	private static Log log = LogFactory.getLog(TextDataParser.class);
-}
-
-	
-PARSER_END(TextDataParser)
-
-
-TOKEN :
-{
- 	< #FLOATINGPOINT: <INTEGER> ( "." <INTEGER> )? | "." <INTEGER> >
-|	<#DIGIT : ["0"-"9"] >
-| 	< #INTEGER: ( <DIGIT> )+ >
-| 	< SIGNEDINTEGER: (["-","+"])? <INTEGER> >
-| 	< LONGINTEGER: <SIGNEDINTEGER> (["l","L"])? >
-|   < DOUBLENUMBER: (["-","+"])? <FLOATINGPOINT> ( ["e","E"] ([ "-","+"])? <FLOATINGPOINT> )?>
-|   < FLOATNUMBER: <DOUBLENUMBER> (["f","F"])? >
-}
-
-TOKEN : { <NULL : "null" > }
-TOKEN : { <STRING : (~[",","(",")","{","}","[","]","#"])* > }
-
-Object Parse() : 
-{
-	Token t1; 
-	String s;
-	Object obj = null;
-	log.trace("Entering Parse");
-}
-{
-	(
-	LOOKAHEAD(AtomDatum()) obj = AtomDatum ()
-|	obj= Datum()
-	)
-	{
-		return obj;
-	}
-}
-
-DataBag Bag() :
-{
-	BagFactory bagFactory = BagFactory.getInstance();
-    DataBag bag = bagFactory.newDefaultBag();
-    Tuple t = null;
-    log.trace("Entering bag");
-}
-{
- ("(" t = Tuple() {bag.add(t);} ")" ("," "(" t = Tuple() {bag.add(t);} ")" )* )
- {
-    log.trace("Exiting bag with bag: " + bag);
-    return bag;
- }
-}
-
-Tuple Tuple() : 
-{
-	Object obj = null;
-	TupleFactory tupleFactory = TupleFactory.getInstance();
-	ArrayList<Object> objList = new ArrayList<Object>(); 
-	log.trace("Entering Tuple");
-}
-{
-	(	
-	(	
-            (
-                obj = Datum() {objList.add(obj);} 
-		        ("," obj = Datum() {objList.add(obj);})* 
-            )
-            |		{}
-	)
-	)
-	{
-		Tuple tuple = tupleFactory.newTuple(objList);
-		log.trace("Exiting Tuple");
-		return tuple;
-	}
-}
-
-Map<String, Object> Map() :
-{
-	Map<String, Object> keyValues = new HashMap<String, Object>();
-	log.trace("Entering Map");
-	
-}
-{
-	( KeyValuePair(keyValues) ("," KeyValuePair(keyValues))* )
-	{
-		log.trace("Exiting Map");
-		return keyValues;
-	}
-}
-
-void KeyValuePair(Map<String, Object> keyValues) :
-{
-	String key = null;
-	String value = null;
-	log.trace("Entering KeyValuePair");
-}
-{
-	(key = StringDatum() "#" value = StringDatum())
-	{
-		keyValues.put(key, new DataByteArray(value.getBytes("UTF-8")));
-		log.trace("Exiting KeyValuePair");
-	}
-	
-}
-
-String StringDatum():
-{
-    String s = null;
-    Token t;
-    log.trace("Entering String");
-}
-{
-    (
-	(
-	t = <SIGNEDINTEGER> 
-|	t = <LONGINTEGER> 
-|	t = <FLOATNUMBER> 
-|	t = <DOUBLENUMBER> 
-|	t = <STRING>
-	) 
-    {
-        s = t.image;
-    }
-
-    )
-    {
-        log.trace("Exiting String with " + s);
-        return s;
-    }
-}
-        
-
-Object AtomDatum():
-{
-    Object obj = null;
-	Token t;
-	log.trace("Entering AtomDatum");
-}
-{
-	(
-	t = <SIGNEDINTEGER> 
-    {
-        obj = new Integer(Integer.parseInt(t.image));
-    }
-|	t = <LONGINTEGER> 
-    {
-        obj = new Long(Long.parseLong(t.image.substring(0, t.image.length() - 1)));
-    }
-|	t = <FLOATNUMBER> 
-    {
-        obj = new Float(Float.parseFloat(t.image));
-    }
-|	t = <DOUBLENUMBER> 
-    {
-        obj = new Double(Double.parseDouble(t.image));
-    }
-|	t = <STRING> 
-    {
-        obj = t.image;
-    }
-	)
-	{
-		log.trace("Exiting AtomDatum");
-		return obj;
-	}
-}
-
-Object Datum(): 
-{
-    Object obj = null;
-	log.trace("Entering Datum");
-}
-{
-	(
-	"[" obj = Map() "]"
-|	"{" obj = Bag() "}"
-|	"(" obj = Tuple() ")"
-|	obj = AtomDatum()
-	)
-	{
-		log.trace("Exiting Datum with obj: " + obj);
-		return obj;
-	}
-}
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 07899515e..8b7796069 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -236,10 +236,9 @@ public class LOForEach extends RelationalOperator {
 					                throw new FrontendException(msg, errCode, PigException.INPUT, false, null);
 					            }
 					            s = tupleFS.schema;
-							    
-							}
-							if(null != s) {
-								for(int i = 0; i < s.size(); ++i) {
+					        }
+						    if(null != s && s.size()!=0) {
+						        for(int i = 0; i < s.size(); ++i) {
                                     Schema.FieldSchema fs;
                                     fs = new Schema.FieldSchema(s.getField(i));
                                     fs.setParent(s.getField(i).canonicalName, op);
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
index cd81ee1af..113ce5308 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
@@ -171,6 +171,7 @@ public class TypeCastInserter extends LogicalTransformer {
                             // from the type specified - so we need to cast
                             LOCast cast = new LOCast(p, 
                                         OperatorKey.genOpKey(scope), fs.type);
+                            cast.setFieldSchema(fs);
                             p.add(cast);
                             p.connect(proj, cast);
                             
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 2d909f92f..7a51ca4ec 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -244,7 +244,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         if(map.getMap().getType() != DataType.MAP) {
             // insert cast if the predecessor does not
             // return map
-            insertCast(map, DataType.MAP, map.getMap());
+            insertCast(map, DataType.MAP, null, map.getMap());
         }
 
     }
@@ -275,7 +275,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private void insertCastForRegexp(LORegexp rg) throws VisitorException {
-        insertCast(rg, DataType.CHARARRAY, rg.getOperand());
+        insertCast(rg, DataType.CHARARRAY, null, rg.getOperand());
     }
 
     public void visit(LOAnd binOp) throws VisitorException {
@@ -978,23 +978,31 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     private void insertLeftCastForBinaryOp(BinaryExpressionOperator binOp,
                                            byte toType ) throws VisitorException {
-        insertCast(binOp, toType, binOp.getLhsOperand());
+        insertCast(binOp, toType, null, binOp.getLhsOperand());
     }
 
     private void insertRightCastForBinaryOp(BinaryExpressionOperator binOp,
                                             byte toType ) throws VisitorException {
-        insertCast(binOp, toType, binOp.getRhsOperand());
+        insertCast(binOp, toType, null, binOp.getRhsOperand());
     }
 
 
     private void insertCast(ExpressionOperator node,
-                            byte toType, ExpressionOperator predecessor) 
+                            byte toType, FieldSchema toFs, ExpressionOperator predecessor) 
     throws VisitorException {
         LogicalPlan currentPlan = mCurrentWalker.getPlan() ;
         collectCastWarning(node, predecessor.getType(), toType);
 
         OperatorKey newKey = genNewOperatorKey(node);
         LOCast cast = new LOCast(currentPlan, newKey, toType) ;
+        try {
+            if (toFs!=null)
+                cast.setFieldSchema(toFs);
+        } catch (FrontendException e) {
+            int errCode = 2217;
+            String msg = "Problem setFieldSchema for " + node + " ";
+            throw new TypeCheckerException(msg, errCode, PigException.BUG, e);
+        }
         currentPlan.add(cast) ;
         try {
             currentPlan.insertBetween(predecessor, cast, node);
@@ -1053,7 +1061,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private void insertCastForUniOp(UnaryExpressionOperator uniOp, byte toType) throws VisitorException {
-        insertCast(uniOp, toType, uniOp.getOperand());
+        insertCast(uniOp, toType, null, uniOp.getOperand());
     }
     
     // Currently there is no input type information support in UserFunc
@@ -1584,7 +1592,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             if(fFSch.type==tFSch.type) {
                 continue;
             }
-            insertCast(udf, tFSch.type, args.get(i));
+            insertCast(udf, tFSch.type, tFSch, args.get(i));
         }
     }
 
@@ -1610,10 +1618,10 @@ public class TypeCheckingVisitor extends LOVisitor {
         if (DataType.isNumberType(lhsType) && DataType.isNumberType(rhsType)) {
             byte biggerType = lhsType > rhsType ? lhsType:rhsType ;
             if (biggerType > lhsType) {
-                insertLeftCastForBinCond(binCond, biggerType) ;
+                insertLeftCastForBinCond(binCond, biggerType, null) ;
             }
             else if (biggerType > rhsType) {
-                insertRightCastForBinCond(binCond, biggerType) ;
+                insertRightCastForBinCond(binCond, biggerType, null) ;
             }
             binCond.setType(biggerType) ;
         } 
@@ -1621,23 +1629,35 @@ public class TypeCheckingVisitor extends LOVisitor {
                 && ((rhsType == DataType.CHARARRAY) || (DataType
                         .isNumberType(rhsType)))) {
             // Cast byte array to the type on rhs
-            insertLeftCastForBinCond(binCond, rhsType);
+            insertLeftCastForBinCond(binCond, rhsType, null);
             binCond.setType(DataType.mergeType(lhsType, rhsType));
         } else if ((rhsType == DataType.BYTEARRAY)
                 && ((lhsType == DataType.CHARARRAY) || (DataType
                         .isNumberType(lhsType)))) {
             // Cast byte array to the type on lhs
-            insertRightCastForBinCond(binCond, lhsType);
+            insertRightCastForBinCond(binCond, lhsType, null);
             binCond.setType(DataType.mergeType(lhsType, rhsType));
         }
         // A constant null is always bytearray - so cast it
         // to rhs type
         else if (binCond.getLhsOp() instanceof LOConst
                 && ((LOConst) binCond.getLhsOp()).getValue() == null) {
-            insertLeftCastForBinCond(binCond, rhsType);
+            try {
+                insertLeftCastForBinCond(binCond, rhsType, binCond.getRhsOp().getFieldSchema());
+            } catch (FrontendException e) {
+                int errCode = 2216;
+                String msg = "Problem getting fieldSchema for " +binCond.getRhsOp();
+                throw new TypeCheckerException(msg, errCode, PigException.BUG, e);
+            }
         } else if (binCond.getRhsOp() instanceof LOConst
                 && ((LOConst) binCond.getRhsOp()).getValue() == null) {
-            insertRightCastForBinCond(binCond, lhsType);
+            try {
+                insertRightCastForBinCond(binCond, lhsType, binCond.getLhsOp().getFieldSchema());
+            } catch (FrontendException e) {
+                int errCode = 2216;
+                String msg = "Problem getting fieldSchema for " +binCond.getRhsOp();
+                throw new TypeCheckerException(msg, errCode, PigException.BUG, e);
+            }
         } else if (lhsType == rhsType) {
             // Matching schemas if we're working with tuples
             if (DataType.isSchemaType(lhsType)) {            
@@ -1683,12 +1703,12 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     }
 
-    private void insertLeftCastForBinCond(LOBinCond binCond, byte toType) throws VisitorException {
-        insertCast(binCond, toType, binCond.getLhsOp());
+    private void insertLeftCastForBinCond(LOBinCond binCond, byte toType, FieldSchema toFs) throws VisitorException {
+        insertCast(binCond, toType, toFs, binCond.getLhsOp());
     }
 
-    private void insertRightCastForBinCond(LOBinCond binCond, byte toType) throws VisitorException {
-        insertCast(binCond, toType, binCond.getRhsOp());
+    private void insertRightCastForBinCond(LOBinCond binCond, byte toType, FieldSchema toFs) throws VisitorException {
+        insertCast(binCond, toType, toFs, binCond.getRhsOp());
     }
 
     /**
diff --git a/src/org/apache/pig/impl/util/Utils.java b/src/org/apache/pig/impl/util/Utils.java
index 8e17b85f8..b0fb72612 100644
--- a/src/org/apache/pig/impl/util/Utils.java
+++ b/src/org/apache/pig/impl/util/Utils.java
@@ -17,6 +17,13 @@
  */
 package org.apache.pig.impl.util;
 
+import java.io.ByteArrayInputStream;
+
+import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.parser.ParseException;
+import org.apache.pig.impl.logicalLayer.parser.QueryParser;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+
 /**
  * Class with utility static methods
  */
@@ -69,6 +76,17 @@ public class Utils {
             return false;
         }
     }
+    
+    public static Schema getSchemaFromString(String schemaString) throws ParseException {
+        return Utils.getSchemaFromString(schemaString, DataType.BYTEARRAY);
+    }
 
+    public static Schema getSchemaFromString(String schemaString, byte defaultType) throws ParseException {
+        ByteArrayInputStream stream = new ByteArrayInputStream(schemaString.getBytes()) ;
+        QueryParser queryParser = new QueryParser(stream) ;
+        Schema schema = queryParser.TupleSchema() ;
+        Schema.setSchemaDefaultType(schema, defaultType);
+        return schema;
+    }
     
 }
diff --git a/test/findbugsExcludeFile.xml b/test/findbugsExcludeFile.xml
index 0750cbdaa..87de06cab 100644
--- a/test/findbugsExcludeFile.xml
+++ b/test/findbugsExcludeFile.xml
@@ -329,4 +329,9 @@
         <Method name = "launchPig" />
         <Bug pattern="DE_MIGHT_IGNORE" />
     </Match>
+    <Match>
+        <Class name="org.apache.pig.builtin.Utf8StorageConverter" />
+        <Method name = "bytesToBoolean" />
+        <Bug pattern="NP_BOOLEAN_RETURN_NULL" />
+    </Match>
 </FindBugsFilter>
diff --git a/test/org/apache/pig/test/TestConversions.java b/test/org/apache/pig/test/TestConversions.java
index f482a55c4..e05994a12 100644
--- a/test/org/apache/pig/test/TestConversions.java
+++ b/test/org/apache/pig/test/TestConversions.java
@@ -22,6 +22,8 @@ import java.util.Random;
 import java.util.Map;
 import java.io.IOException;
 
+import org.apache.pig.ResourceSchema;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.builtin.PigStorage;
 import org.apache.pig.builtin.Utf8StorageConverter;
 import org.apache.pig.test.utils.GenRandomData;
@@ -31,6 +33,9 @@ import org.apache.pig.data.TupleFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataByteArray;
 import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.parser.ParseException;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.util.Utils;
 
 import org.junit.Test;
 
@@ -156,7 +161,10 @@ public class TestConversions extends TestCase {
     {
         for (int i = 0; i < MAX; i++) {
             Tuple t = GenRandomData.genRandSmallBagTextTuple(r, 1, 100);
-            Tuple convertedTuple = ps.getLoadCaster().bytesToTuple(t.toString().getBytes());
+            
+            ResourceFieldSchema fs = GenRandomData.getSmallBagTextTupleFieldSchema();
+            
+            Tuple convertedTuple = ps.getLoadCaster().bytesToTuple(t.toString().getBytes(), fs);
             assertTrue(TestHelper.tupleEquals(t, convertedTuple));
         }
         
@@ -165,9 +173,11 @@ public class TestConversions extends TestCase {
     @Test
     public  void testBytesToBag() throws IOException
     {
+        ResourceFieldSchema fs = GenRandomData.getFullTupTextDataBagFieldSchema();
+        
         for (int i = 0; i < MAX; i++) {
             DataBag b = GenRandomData.genRandFullTupTextDataBag(r,5,100);
-            DataBag convertedBag = ps.getLoadCaster().bytesToBag(b.toString().getBytes());
+            DataBag convertedBag = ps.getLoadCaster().bytesToBag(b.toString().getBytes(), fs);
             assertTrue(TestHelper.bagEquals(b, convertedBag));
         }
         
@@ -234,4 +244,130 @@ public class TestConversions extends TestCase {
         Map<String, Object>  m = GenRandomData.genRandMap(r,5);
         assertTrue(DataType.equalByteArrays(DataType.mapToString(m).getBytes(), ((Utf8StorageConverter)ps.getLoadCaster()).toBytes(m)));
     }
+    
+    @Test
+    public void testBytesToBagWithConversion() throws IOException {
+        DataBag b = GenRandomData.genFloatDataBag(r,5,100);
+        ResourceFieldSchema fs = GenRandomData.getFloatDataBagFieldSchema(5);
+        DataBag convertedBag = ps.getLoadCaster().bytesToBag(b.toString().getBytes(), fs);
+        
+        Iterator<Tuple> iter1 = b.iterator();
+        Iterator<Tuple> iter2 = convertedBag.iterator();
+        for (int i=0;i<100;i++) {
+            Tuple t1 = (Tuple)iter1.next();
+            assertTrue(iter2.hasNext());
+            Tuple t2 = (Tuple)iter2.next();
+            for (int j=0;j<5;j++) {
+                assertTrue(t2.get(j) instanceof Integer);
+                float expectedValue = (Float)(t1.get(j));
+                assertTrue((Integer)t2.get(j)==(int)expectedValue);
+            }
+        }
+    }
+    
+    @Test
+    public void testBytesToTupleWithConversion() throws IOException {
+        for (int i=0;i<100;i++) {
+            Tuple t = GenRandomData.genMixedTupleToConvert(r);
+            ResourceFieldSchema fs = GenRandomData.getMixedTupleToConvertFieldSchema();
+            Tuple convertedTuple = ps.getLoadCaster().bytesToTuple(t.toString().getBytes(), fs);
+            
+            assertTrue(convertedTuple.get(0) instanceof String);
+            assertTrue(convertedTuple.get(0).equals(((Integer)t.get(0)).toString()));            
+            
+            assertTrue(convertedTuple.get(1) instanceof Long);
+            Integer origValue1 = (Integer)t.get(1);
+            assertTrue(convertedTuple.get(1).equals(new Long(origValue1.longValue())));
+            
+            assertTrue(convertedTuple.get(2)==null);
+            
+            assertTrue(convertedTuple.get(3) instanceof Double);
+            Float origValue3 = (Float)t.get(3);
+            assertTrue(((Double)convertedTuple.get(3) - origValue3.doubleValue())<0.01);
+            
+            assertTrue(convertedTuple.get(4) instanceof Float);
+            Double origValue4 = (Double)t.get(4);
+            assertTrue(((Float)convertedTuple.get(4) - origValue4.floatValue())<0.01);
+            
+            assertTrue(convertedTuple.get(5) instanceof String);
+            assertTrue(convertedTuple.get(5).equals(t.get(5)));
+            
+            assertTrue(convertedTuple.get(6)==null);
+            
+            assertTrue(convertedTuple.get(7)==null);
+            
+            assertTrue(convertedTuple.get(8)==null);
+            
+            assertTrue(convertedTuple.get(9) instanceof Boolean);
+            String origValue9 = (String)t.get(9);
+            assertTrue(new Boolean(origValue9).equals(convertedTuple.get(9)));
+        }
+    }
+    
+    public void testBytesToComplexTypeMisc() throws IOException, ParseException {
+        String s = "(a,b";
+        Schema schema = Utils.getSchemaFromString("t:tuple(a:chararray, b:chararray)");
+        ResourceFieldSchema rfs = new ResourceSchema(schema).getFields()[0];
+        Tuple t = ps.getLoadCaster().bytesToTuple(s.getBytes(), rfs);
+        assertTrue(t==null);
+        
+        s = "{(a,b}";
+        schema = Utils.getSchemaFromString("b:bag{t:tuple(a:chararray, b:chararray)}");
+        rfs = new ResourceSchema(schema).getFields()[0];
+        DataBag b = ps.getLoadCaster().bytesToBag(s.getBytes(), rfs);
+        assertTrue(b==null);
+        
+        s = "{(a,b)";
+        schema = Utils.getSchemaFromString("b:bag{t:tuple(a:chararray, b:chararray)}");
+        rfs = new ResourceSchema(schema).getFields()[0];
+        b = ps.getLoadCaster().bytesToBag(s.getBytes(), rfs);
+        assertTrue(b==null);
+        
+        s = "[ab]";
+        Map<String, Object> m = ps.getLoadCaster().bytesToMap(s.getBytes());
+        assertTrue(m==null);
+        
+        s = "[a#b";
+        m = ps.getLoadCaster().bytesToMap(s.getBytes());
+        assertTrue(m==null);
+        
+        s = "[a#]";
+        m = ps.getLoadCaster().bytesToMap(s.getBytes());
+        Map.Entry<String, Object> entry = m.entrySet().iterator().next();
+        assertTrue(entry.getKey().equals("a"));
+        assertTrue(entry.getValue()==null);
+        
+        s = "[#]";
+        m = ps.getLoadCaster().bytesToMap(s.getBytes());
+        assertTrue(m==null);
+        
+        s = "(a,b)";
+        schema = Utils.getSchemaFromString("t:tuple()");
+        rfs = new ResourceSchema(schema).getFields()[0];
+        t = ps.getLoadCaster().bytesToTuple(s.getBytes(), rfs);
+        assertTrue(t.size()==1);
+        assertTrue(t.get(0) instanceof DataByteArray);
+        assertTrue(t.get(0).toString().equals("a,b"));
+        
+        s = "[a#(1,2,3)]";
+        m = ps.getLoadCaster().bytesToMap(s.getBytes());
+        entry = m.entrySet().iterator().next();
+        assertTrue(entry.getKey().equals("a"));
+        assertTrue(entry.getValue() instanceof DataByteArray);
+        assertTrue(entry.getValue().toString().equals("(1,2,3)"));
+        
+        s = "(a,b,(123,456,{(1,2,3)}))";
+        schema = Utils.getSchemaFromString("t:tuple()");
+        rfs = new ResourceSchema(schema).getFields()[0];
+        t = ps.getLoadCaster().bytesToTuple(s.getBytes(), rfs);
+        assertTrue(t.size()==1);
+        assertTrue(t.get(0) instanceof DataByteArray);
+        assertTrue(t.get(0).toString().equals("a,b,(123,456,{(1,2,3)})"));
+        
+        s = "(a,b,(123,456,{(1,2,3}))";
+        schema = Utils.getSchemaFromString("t:tuple()");
+        rfs = new ResourceSchema(schema).getFields()[0];
+        t = ps.getLoadCaster().bytesToTuple(s.getBytes(), rfs);
+        assertTrue(t==null);
+    }
 }
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index c60a5b2c0..e33c683f4 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -235,7 +235,11 @@ public class TestEvalPipeline2 extends TestCase {
 
         //tuple 4 - integer exceeds size limit
         tup = it.next();
-        assertTrue(tup.get(0) == null);
+        assertTrue(tup.get(0) instanceof DataBag);
+        DataBag db = (DataBag)tup.get(0);
+        assertTrue(db.iterator().hasNext());
+        Tuple innerTuple = (Tuple)db.iterator().next();
+        assertTrue(innerTuple.get(0)==null);
 
         //tuple 5 
         tup = it.next();
@@ -271,7 +275,7 @@ public class TestEvalPipeline2 extends TestCase {
 
         //tuple 1 
         tup = it.next();
-        assertTrue(tup.get(0) != null);
+        assertTrue(tup.get(0) == null);
         
         //tuple 2 -malformed tuple
         tup = it.next();
@@ -281,9 +285,9 @@ public class TestEvalPipeline2 extends TestCase {
         tup = it.next();
         assertTrue(tup.get(0) == null);
 
-        //tuple 5 
+        //tuple 4
         tup = it.next();
-        assertTrue(tup.get(0) != null);
+        assertTrue(tup.get(0) == null);
 
         Util.deleteFile(cluster, "table_bs_ac_clxt");
     }
diff --git a/test/org/apache/pig/test/TestPOCast.java b/test/org/apache/pig/test/TestPOCast.java
index 4007bce1e..0ad711a7f 100644
--- a/test/org/apache/pig/test/TestPOCast.java
+++ b/test/org/apache/pig/test/TestPOCast.java
@@ -32,6 +32,7 @@ import org.apache.pig.ExecType;
 import org.apache.pig.FuncSpec;
 import org.apache.pig.LoadCaster;
 import org.apache.pig.LoadFunc;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.backend.datastorage.DataStorage;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.data.BagFactory;
@@ -919,7 +920,7 @@ public class TestPOCast extends TestCase {
             return null;
         }
         
-        public DataBag bytesToBag(byte[] b) throws IOException {
+        public DataBag bytesToBag(byte[] b, ResourceFieldSchema s) throws IOException {
             return null;
         }
 
@@ -956,7 +957,7 @@ public class TestPOCast extends TestCase {
           return null;
         }
 
-        public Tuple bytesToTuple(byte[] b) throws IOException {
+        public Tuple bytesToTuple(byte[] b, ResourceFieldSchema s) throws IOException {
             return null;
         }
 
diff --git a/test/org/apache/pig/test/TestStore.java b/test/org/apache/pig/test/TestStore.java
index 93b7a30a1..c41555c00 100644
--- a/test/org/apache/pig/test/TestStore.java
+++ b/test/org/apache/pig/test/TestStore.java
@@ -43,6 +43,7 @@ import org.apache.pig.ResourceSchema;
 import org.apache.pig.ResourceStatistics;
 import org.apache.pig.StoreFunc;
 import org.apache.pig.StoreMetadata;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.backend.datastorage.DataStorage;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;
@@ -248,7 +249,11 @@ public class TestStore extends junit.framework.TestCase {
         for(String line=br.readLine();line!=null;line=br.readLine()){
             String[] flds = line.split(":",-1);
             Tuple t = new DefaultTuple();
-            t.append(flds[0].compareTo("")!=0 ? ps.getLoadCaster().bytesToBag(flds[0].getBytes()) : null);
+            
+            ResourceFieldSchema bagfs = GenRandomData.getSmallTupDataBagFieldSchema();
+            ResourceFieldSchema tuplefs = GenRandomData.getSmallTupleFieldSchema();
+            
+            t.append(flds[0].compareTo("")!=0 ? ps.getLoadCaster().bytesToBag(flds[0].getBytes(), bagfs) : null);
             t.append(flds[1].compareTo("")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[1].getBytes()) : null);
             t.append(flds[2].compareTo("")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[2].getBytes()) : null);
             t.append(flds[3].compareTo("")!=0 ? ps.getLoadCaster().bytesToDouble(flds[3].getBytes()) : null);
@@ -256,7 +261,7 @@ public class TestStore extends junit.framework.TestCase {
             t.append(flds[5].compareTo("")!=0 ? ps.getLoadCaster().bytesToInteger(flds[5].getBytes()) : null);
             t.append(flds[6].compareTo("")!=0 ? ps.getLoadCaster().bytesToLong(flds[6].getBytes()) : null);
             t.append(flds[7].compareTo("")!=0 ? ps.getLoadCaster().bytesToMap(flds[7].getBytes()) : null);
-            t.append(flds[8].compareTo("")!=0 ? ps.getLoadCaster().bytesToTuple(flds[8].getBytes()) : null);
+            t.append(flds[8].compareTo("")!=0 ? ps.getLoadCaster().bytesToTuple(flds[8].getBytes(), tuplefs) : null);
             assertEquals(true, TestHelper.bagContains(inpDB, t));
             ++size;
         }
@@ -277,7 +282,25 @@ public class TestStore extends junit.framework.TestCase {
             System.err.println(line);
             String[] flds = line.split(":",-1);
             Tuple t = new DefaultTuple();
-            t.append(flds[0].compareTo("")!=0 ? ps.getLoadCaster().bytesToBag(flds[0].getBytes()) : null);
+            
+            ResourceFieldSchema stringfs = new ResourceFieldSchema();
+            stringfs.setType(DataType.CHARARRAY);
+            ResourceFieldSchema intfs = new ResourceFieldSchema();
+            intfs.setType(DataType.INTEGER);
+            
+            ResourceSchema tupleSchema = new ResourceSchema();
+            tupleSchema.setFields(new ResourceFieldSchema[]{stringfs, intfs});
+            ResourceFieldSchema tuplefs = new ResourceFieldSchema();
+            tuplefs.setSchema(tupleSchema);
+            tuplefs.setType(DataType.TUPLE);
+            
+            ResourceSchema bagSchema = new ResourceSchema();
+            bagSchema.setFields(new ResourceFieldSchema[]{tuplefs});
+            ResourceFieldSchema bagfs = new ResourceFieldSchema();
+            bagfs.setSchema(bagSchema);
+            bagfs.setType(DataType.BAG);
+            
+            t.append(flds[0].compareTo("")!=0 ? ps.getLoadCaster().bytesToBag(flds[0].getBytes(), bagfs) : null);
             t.append(flds[1].compareTo("")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[1].getBytes()) : null);
             t.append(flds[2].compareTo("")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[2].getBytes()) : null);
             t.append(flds[3].compareTo("")!=0 ? ps.getLoadCaster().bytesToDouble(flds[3].getBytes()) : null);
@@ -285,7 +308,7 @@ public class TestStore extends junit.framework.TestCase {
             t.append(flds[5].compareTo("")!=0 ? ps.getLoadCaster().bytesToInteger(flds[5].getBytes()) : null);
             t.append(flds[6].compareTo("")!=0 ? ps.getLoadCaster().bytesToLong(flds[6].getBytes()) : null);
             t.append(flds[7].compareTo("")!=0 ? ps.getLoadCaster().bytesToMap(flds[7].getBytes()) : null);
-            t.append(flds[8].compareTo("")!=0 ? ps.getLoadCaster().bytesToTuple(flds[8].getBytes()) : null);
+            t.append(flds[8].compareTo("")!=0 ? ps.getLoadCaster().bytesToTuple(flds[8].getBytes(), tuplefs) : null);
             t.append(flds[9].compareTo("")!=0 ? ps.getLoadCaster().bytesToCharArray(flds[9].getBytes()) : null);
             assertTrue(TestHelper.tupleEquals(inputTuple, t));
             ++size;
diff --git a/test/org/apache/pig/test/TestTextDataParser.java b/test/org/apache/pig/test/TestTextDataParser.java
index 8229220a2..9d9ea8ff3 100644
--- a/test/org/apache/pig/test/TestTextDataParser.java
+++ b/test/org/apache/pig/test/TestTextDataParser.java
@@ -17,63 +17,97 @@
  */
 package org.apache.pig.test;
 
-import java.io.ByteArrayInputStream;
 import java.util.Map;
 
 import org.junit.Test;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.pig.ResourceSchema;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
+import org.apache.pig.builtin.PigStorage;
 import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataByteArray;
+import org.apache.pig.data.DataType;
 import org.apache.pig.data.DefaultBagFactory;
 import org.apache.pig.data.DefaultTupleFactory;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
-import org.apache.pig.data.parser.TextDataParser;
-import org.apache.pig.data.parser.ParseException ;
-
 
 public class TestTextDataParser extends junit.framework.TestCase {
 
     private final Log log = LogFactory.getLog(getClass());
     private TupleFactory tupleFactory = DefaultTupleFactory.getInstance();
     private BagFactory bagFactory = DefaultBagFactory.getInstance();
+    PigStorage ps = new PigStorage();
     
 
+    ResourceFieldSchema getTupleFieldSchema() {
+        ResourceFieldSchema stringfs = new ResourceFieldSchema();
+        stringfs.setType(DataType.CHARARRAY);
+        ResourceFieldSchema intfs = new ResourceFieldSchema();
+        intfs.setType(DataType.INTEGER);
+        
+        ResourceSchema tupleSchema = new ResourceSchema();
+        tupleSchema.setFields(new ResourceFieldSchema[]{intfs, stringfs});
+        ResourceFieldSchema tuplefs = new ResourceFieldSchema();
+        tuplefs.setSchema(tupleSchema);
+        tuplefs.setType(DataType.TUPLE);
+        
+        return tuplefs;
+    }
+    
+    public ResourceFieldSchema getBagFieldSchema(){
+        ResourceFieldSchema tuplefs = getTupleFieldSchema();
+        
+        ResourceSchema outBagSchema = new ResourceSchema();
+        outBagSchema.setFields(new ResourceFieldSchema[]{tuplefs});
+        ResourceFieldSchema outBagfs = new ResourceFieldSchema();
+        outBagfs.setSchema(outBagSchema);
+        outBagfs.setType(DataType.BAG);
+        
+        return outBagfs;
+    }
+    
+    ResourceFieldSchema getLongFieldSchema() {
+        ResourceFieldSchema longfs = new ResourceFieldSchema();
+        longfs.setType(DataType.LONG);
+        return longfs;
+    }
+    
     @Test
     public void testInteger() throws Exception{
         String myInteger = "1";
-        Integer i = (Integer)parseTextData(myInteger);
+        Integer i = ps.getLoadCaster().bytesToInteger(myInteger.getBytes());
         assertTrue(i.equals(1));
     }
 
     @Test
     public void testLong() throws Exception{
         String myLong = "1l";
-        Long l = (Long)parseTextData(myLong);
+        Long l = ps.getLoadCaster().bytesToLong(myLong.getBytes());
         assertTrue(l.equals(1l));
     }
     
     @Test
     public void testFloat() throws Exception{
         String myFloat = "0.1f";
-        Float f = (Float)parseTextData(myFloat);
+        Float f = ps.getLoadCaster().bytesToFloat(myFloat.getBytes());
         assertTrue(f.equals(0.1f));
     }
     
     @Test
     public void testDouble() throws Exception{
         String myDouble = "0.1";
-        Double d = (Double)parseTextData(myDouble);
+        Double d = ps.getLoadCaster().bytesToDouble(myDouble.getBytes());
         assertTrue(d.equals(0.1));
     }
     
     @Test
     public void testString() throws Exception{
         String myString = "1a";
-        String s = (String)parseTextData(myString);
+        String s = ps.getLoadCaster().bytesToCharArray(myString.getBytes());
         assertTrue(s.equals(myString));
     }
     
@@ -84,7 +118,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testMapStringValueType() throws Exception{
         String myMap = "[key1#value1]";
-        Map<String, Object> map = (Map<String, Object>)parseTextData(myMap);
+        Map<String, Object> map = ps.getLoadCaster().bytesToMap(myMap.getBytes());
         String key = map.keySet().iterator().next();        
         Object v = map.get("key1");
         assertTrue(key.equals("key1"));
@@ -99,7 +133,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testMapIntegerValueType() throws Exception{
         String myMap = "[key1#1]";
-        Map<String, Object> map = (Map<String, Object>)parseTextData(myMap);
+        Map<String, Object> map = ps.getLoadCaster().bytesToMap(myMap.getBytes());
         String key = map.keySet().iterator().next();        
         Object v = map.get("key1");
         assertTrue(key.equals("key1"));
@@ -114,7 +148,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testMapLongValueType() throws Exception{
         String myMap = "[key1#1l]";
-        Map<String, Object> map = (Map<String, Object>)parseTextData(myMap);
+        Map<String, Object> map = ps.getLoadCaster().bytesToMap(myMap.getBytes());
         String key = map.keySet().iterator().next();        
         Object v = map.get("key1");
         assertTrue(key.equals("key1"));
@@ -129,7 +163,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testMapFloatValueType() throws Exception{
         String myMap = "[key1#0.1f]";
-        Map<String, Object> map = (Map<String, Object>)parseTextData(myMap);
+        Map<String, Object> map = ps.getLoadCaster().bytesToMap(myMap.getBytes());
         String key = map.keySet().iterator().next();        
         Object v = map.get("key1");
         assertTrue(key.equals("key1"));
@@ -144,7 +178,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testMapDoubleValueType() throws Exception{
         String myMap = "[key1#0.1]";
-        Map<String, Object> map = (Map<String, Object>)parseTextData(myMap);
+        Map<String, Object> map = ps.getLoadCaster().bytesToMap(myMap.getBytes());
         String key = map.keySet().iterator().next();        
         Object v = map.get("key1");
         assertTrue(key.equals("key1"));
@@ -156,7 +190,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testTuple() throws Exception{
         String myTuple = "(1,a)";
-        Object o = parseTextData(myTuple);
+        Object o = ps.getLoadCaster().bytesToTuple(myTuple.getBytes(), getTupleFieldSchema());
         assertTrue(o instanceof Tuple);
         Tuple t = (Tuple)o;
         Tuple expectedTuple = tupleFactory.newTuple(2);
@@ -168,7 +202,7 @@ public class TestTextDataParser extends junit.framework.TestCase {
     @Test
     public void testBag() throws Exception{
         String myBag = "{(1,a),(2,b)}";
-        Object o = parseTextData(myBag);
+        Object o = ps.getLoadCaster().bytesToBag(myBag.getBytes(), getBagFieldSchema());
         assertTrue(o instanceof DataBag);
         DataBag b = (DataBag)o;
         DataBag expectedBag = bagFactory.newDefaultBag();
@@ -181,12 +215,5 @@ public class TestTextDataParser extends junit.framework.TestCase {
         expectedTuple.set(1, "b");
         expectedBag.add(expectedTuple);
         assertTrue(b.equals(expectedBag));
-    }
-
-    
-    private Object parseTextData(String pigConstantAsString) throws ParseException {
-        ByteArrayInputStream stream = new ByteArrayInputStream(pigConstantAsString.getBytes()) ;
-        TextDataParser textDataParser = new TextDataParser(stream) ;
-        return textDataParser.Datum();
-    }
+    }    
 }
diff --git a/test/org/apache/pig/test/utils/GenRandomData.java b/test/org/apache/pig/test/utils/GenRandomData.java
index 593928e48..564540f1a 100644
--- a/test/org/apache/pig/test/utils/GenRandomData.java
+++ b/test/org/apache/pig/test/utils/GenRandomData.java
@@ -21,10 +21,14 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.Random;
 
+import org.apache.pig.ResourceSchema;
+import org.apache.pig.ResourceSchema.ResourceFieldSchema;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataByteArray;
+import org.apache.pig.data.DataType;
 import org.apache.pig.data.DefaultBagFactory;
 import org.apache.pig.data.DefaultTuple;
+import org.apache.pig.data.DefaultTupleFactory;
 import org.apache.pig.data.Tuple;
 
 public class GenRandomData {
@@ -37,7 +41,7 @@ public class GenRandomData {
             return ret;
         }
         for(int i=0;i<numEnt;i++){
-            ret.put(genRandString(r), genRandString(r));
+            ret.put(genRandString(r), new DataByteArray(genRandString(r).getBytes()));
         }
         return ret;
     }
@@ -73,6 +77,20 @@ public class GenRandomData {
         return new DataByteArray(genRandString(r).getBytes());
     }
     
+    public static ResourceFieldSchema getSmallTupleFieldSchema(){
+        ResourceFieldSchema stringfs = new ResourceFieldSchema();
+        stringfs.setType(DataType.CHARARRAY);
+        ResourceFieldSchema intfs = new ResourceFieldSchema();
+        intfs.setType(DataType.INTEGER);
+        
+        ResourceSchema tupleSchema = new ResourceSchema();
+        tupleSchema.setFields(new ResourceFieldSchema[]{stringfs, intfs});
+        ResourceFieldSchema tuplefs = new ResourceFieldSchema();
+        tuplefs.setSchema(tupleSchema);
+        tuplefs.setType(DataType.TUPLE);
+        
+        return tuplefs;
+    }
     public static Tuple genRandSmallTuple(Random r, int limit){
         if(r==null){
             Tuple t = new DefaultTuple();
@@ -125,6 +143,18 @@ public class GenRandomData {
         return db;
     }
     
+    public static ResourceFieldSchema getSmallTupDataBagFieldSchema() {
+        ResourceFieldSchema tuplefs = getSmallTupleFieldSchema();
+        
+        ResourceSchema bagSchema = new ResourceSchema();
+        bagSchema.setFields(new ResourceFieldSchema[]{tuplefs});
+        ResourceFieldSchema bagfs = new ResourceFieldSchema();
+        bagfs.setSchema(bagSchema);
+        bagfs.setType(DataType.BAG);
+        
+        return bagfs;
+    }
+    
     public static DataBag genRandSmallTupDataBag(Random r, int num, int limit){
         if(r==null) {
             DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
@@ -160,6 +190,39 @@ public class GenRandomData {
         return t;
     }
     
+    public static ResourceFieldSchema getSmallBagTextTupleFieldSchema(){
+        ResourceFieldSchema stringfs = new ResourceFieldSchema();
+        stringfs.setType(DataType.CHARARRAY);
+        
+        ResourceFieldSchema intfs = new ResourceFieldSchema();
+        intfs.setType(DataType.INTEGER);
+    	
+        ResourceFieldSchema bagfs = getSmallTupDataBagFieldSchema();
+        
+        ResourceFieldSchema floatfs = new ResourceFieldSchema();
+        floatfs.setType(DataType.FLOAT);
+        
+        ResourceFieldSchema doublefs = new ResourceFieldSchema();
+        doublefs.setType(DataType.DOUBLE);
+        
+        ResourceFieldSchema longfs = new ResourceFieldSchema();
+        longfs.setType(DataType.LONG);
+        
+        ResourceFieldSchema mapfs = new ResourceFieldSchema();
+        mapfs.setType(DataType.MAP);
+        
+        ResourceFieldSchema tuplefs = getSmallTupleFieldSchema();
+        
+        ResourceSchema outSchema = new ResourceSchema();
+        outSchema.setFields(new ResourceFieldSchema[]{bagfs, stringfs, stringfs, doublefs, floatfs,
+                intfs, longfs, mapfs, tuplefs});
+        ResourceFieldSchema outfs = new ResourceFieldSchema();
+        outfs.setSchema(outSchema);
+        outfs.setType(DataType.TUPLE);
+        
+        return outfs;
+    }
+    
     public static Tuple genRandSmallBagTextTuple(Random r, int num, int limit){
         if(r==null){
             Tuple t = new DefaultTuple();
@@ -199,6 +262,18 @@ public class GenRandomData {
         return db;
     }
 
+    public static ResourceFieldSchema getFullTupTextDataBagFieldSchema(){
+        ResourceFieldSchema tuplefs = getSmallBagTextTupleFieldSchema();
+        
+        ResourceSchema outBagSchema = new ResourceSchema();
+        outBagSchema.setFields(new ResourceFieldSchema[]{tuplefs});
+        ResourceFieldSchema outBagfs = new ResourceFieldSchema();
+        outBagfs.setSchema(outBagSchema);
+        outBagfs.setType(DataType.BAG);
+        
+        return outBagfs;
+    }
+    
     public static DataBag genRandFullTupTextDataBag(Random r, int num, int limit){
         if(r==null) {
             DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
@@ -260,4 +335,84 @@ public class GenRandomData {
         return t;
     }
     
+    public static DataBag genFloatDataBag(Random r, int column, int row) {
+        DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
+        for (int i=0;i<row;i++) {
+            Tuple t = DefaultTupleFactory.getInstance().newTuple();
+            for (int j=0;j<column;j++) {
+                t.append(r.nextFloat()*1000);
+            }
+            db.add(t);
+        }
+        return db;
+    }
+    
+    public static ResourceFieldSchema getFloatDataBagFieldSchema(int column) {
+        ResourceFieldSchema intfs = new ResourceFieldSchema();
+        intfs.setType(DataType.INTEGER);
+        
+        ResourceSchema tupleSchema = new ResourceSchema();
+        ResourceFieldSchema[] fss = new ResourceFieldSchema[column];
+        for (int i=0;i<column;i++) {
+            fss[i] = intfs;
+        }
+        tupleSchema.setFields(fss);
+        ResourceFieldSchema tuplefs = new ResourceFieldSchema();
+        tuplefs.setSchema(tupleSchema);
+        tuplefs.setType(DataType.TUPLE);
+        
+        ResourceSchema bagSchema = new ResourceSchema();
+        bagSchema.setFields(new ResourceFieldSchema[]{tuplefs});
+        ResourceFieldSchema bagfs = new ResourceFieldSchema();
+        bagfs.setSchema(bagSchema);
+        bagfs.setType(DataType.BAG);
+        
+        return bagfs;
+    }
+    
+    public static Tuple genMixedTupleToConvert(Random r) {
+        Tuple t = DefaultTupleFactory.getInstance().newTuple();
+        t.append(r.nextInt());
+        t.append(r.nextInt());
+        long l = 0;
+        while (l<=Integer.MAX_VALUE && l>=Integer.MIN_VALUE)
+            l = r.nextLong();
+        t.append(l);
+        t.append(r.nextFloat()*1000);
+        t.append(r.nextDouble()*10000);
+        t.append(genRandString(r));
+        t.append("K"+genRandString(r));
+        t.append("K"+genRandString(r));
+        t.append("K"+genRandString(r));
+        if (r.nextFloat()>0.5)
+            t.append("true");
+        else
+            t.append("false");
+        return t;
+    }
+    
+    public static ResourceFieldSchema getMixedTupleToConvertFieldSchema() {
+        ResourceFieldSchema stringfs = new ResourceFieldSchema();
+        stringfs.setType(DataType.CHARARRAY);
+        ResourceFieldSchema intfs = new ResourceFieldSchema();
+        intfs.setType(DataType.INTEGER);
+        ResourceFieldSchema longfs = new ResourceFieldSchema();
+        longfs.setType(DataType.LONG);
+        ResourceFieldSchema floatfs = new ResourceFieldSchema();
+        floatfs.setType(DataType.FLOAT);
+        ResourceFieldSchema doublefs = new ResourceFieldSchema();
+        doublefs.setType(DataType.DOUBLE);
+        ResourceFieldSchema booleanfs = new ResourceFieldSchema();
+        booleanfs.setType(DataType.BOOLEAN);
+        
+        ResourceSchema tupleSchema = new ResourceSchema();
+        tupleSchema.setFields(new ResourceFieldSchema[]{stringfs, longfs, intfs, doublefs, floatfs, stringfs, intfs, doublefs, floatfs, booleanfs});
+        ResourceFieldSchema tuplefs = new ResourceFieldSchema();
+        tuplefs.setSchema(tupleSchema);
+        tuplefs.setType(DataType.TUPLE);
+        
+        return tuplefs;
+    }
+
+    
 }
diff --git a/test/org/apache/pig/test/utils/TestHelper.java b/test/org/apache/pig/test/utils/TestHelper.java
index 5f819ccb7..2e7b7a406 100644
--- a/test/org/apache/pig/test/utils/TestHelper.java
+++ b/test/org/apache/pig/test/utils/TestHelper.java
@@ -261,7 +261,7 @@ public class TestHelper {
         for(String key: expectedMap.keySet()) {
             Object v = convertedMap.get(key);
             String convertedValue = new String(((DataByteArray)v).get());
-            if(!expectedMap.get(key).equals(convertedValue)) {
+            if(!expectedMap.get(key).toString().equals(convertedValue)) {
                 return false;
             }
         }
