diff --git a/CHANGES.txt b/CHANGES.txt
index 28181bd3c..e7cc16a49 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -204,6 +204,9 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1605: PIG-1605: Adding soft link to plan to solve input file dependency
+(daijy)
+
 PIG-1598: Pig gobbles up error messages - Part 2 (nrai via daijy)
 
 PIG-1616: 'union onschema' does not use create output with correct schema 
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 5d9f47eef..927f0ca63 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -96,6 +96,7 @@ import org.apache.pig.impl.plan.CompilationMessageCollector.MessageType;
 import org.apache.pig.impl.streaming.StreamingCommand;
 import org.apache.pig.impl.util.LogUtils;
 import org.apache.pig.impl.util.ObjectSerializer;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.impl.util.PropertiesUtil;
 import org.apache.pig.impl.util.Utils;
 import org.apache.pig.newplan.logical.LogicalPlanMigrationVistor;
@@ -927,7 +928,6 @@ public class PigServer {
             if( pigContext.getProperties().getProperty("pig.usenewlogicalplan", "true").equals("true") ) {
                 LogicalPlanMigrationVistor migrator = new LogicalPlanMigrationVistor(lp);
                 migrator.visit();
-                migrator.finish();
                 org.apache.pig.newplan.logical.relational.LogicalPlan newPlan = migrator.getNewLogicalPlan();
                 
                 HashSet<String> optimizerRules = null;
@@ -1248,10 +1248,10 @@ public class PigServer {
         ScalarFinder scalarFinder = new ScalarFinder(lp);
         scalarFinder.visit();
 
-        Map<LOUserFunc, LogicalPlan> scalarMap = scalarFinder.getScalarMap();
+        Map<LOUserFunc, Pair<LogicalPlan, LogicalOperator>> scalarMap = scalarFinder.getScalarMap();
 
         try {
-            for(Map.Entry<LOUserFunc, LogicalPlan> scalarEntry: scalarMap.entrySet()) {
+            for(Map.Entry<LOUserFunc, Pair<LogicalPlan, LogicalOperator>> scalarEntry: scalarMap.entrySet()) {
                 FileSpec fileSpec;
                 String alias = scalarEntry.getKey().getImplicitReferencedOperator().getAlias();
                 LogicalOperator store;
@@ -1281,12 +1281,15 @@ public class PigServer {
                 lp.mergeSharedPlan(referredPlan);
 
                 // Attach a constant operator to the ReadScalar func
-                LogicalPlan innerPlan = scalarEntry.getValue();
+                LogicalPlan innerPlan = scalarEntry.getValue().first;
                 LOConst rconst = new LOConst(innerPlan, new OperatorKey(scope, NodeIdGenerator.getGenerator().getNextNodeId(scope)), fileSpec.getFileName());
                 rconst.setType(DataType.CHARARRAY);
 
                 innerPlan.add(rconst);
                 innerPlan.connect(rconst, scalarEntry.getKey());
+                
+                if (lp.getSoftLinkSuccessors(store)==null || !lp.getSoftLinkSuccessors(store).contains(scalarEntry.getValue().second))
+                    lp.createSoftLink(store, scalarEntry.getValue().second);
             }
         } catch (IOException ioe) {
             int errCode = 2219;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
index 1b6e36306..360c2f323 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
@@ -240,7 +240,6 @@ public class HExecutionEngine {
                 // translate old logical plan to new plan
                 LogicalPlanMigrationVistor visitor = new LogicalPlanMigrationVistor(plan);
                 visitor.visit();
-                visitor.finish();
                 org.apache.pig.newplan.logical.relational.LogicalPlan newPlan = visitor.getNewLogicalPlan();
                 
                 SchemaResetter schemaResetter = new SchemaResetter(newPlan);
@@ -268,7 +267,6 @@ public class HExecutionEngine {
                 
                 translator.setPigContext(pigContext);
                 translator.visit();
-                translator.finish();
                 return translator.getPhysicalPlan();
                 
             }else{       
@@ -276,7 +274,6 @@ public class HExecutionEngine {
                     new LogToPhyTranslationVisitor(plan);
                 translator.setPigContext(pigContext);
                 translator.visit();
-                translator.finish();
                 return translator.getPhysicalPlan();
             }
         } catch (Exception ve) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
index 92c43a9b8..87d6a0232 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
@@ -228,7 +228,7 @@ public class MRCompiler extends PhyPlanVisitor {
                 + " optimistic? " + optimisticFileConcatenation);
     }
     
-    public void connectScalars() throws PlanException, IOException {
+    public void aggregateScalarsFiles() throws PlanException, IOException {
         List<MapReduceOper> mrOpList = new ArrayList<MapReduceOper>();
         for(MapReduceOper mrOp: MRPlan) {
             mrOpList.add(mrOp);
@@ -264,16 +264,16 @@ public class MRCompiler extends PhyPlanVisitor {
                         new FindStoreNameVisitor(pl, newSpec, oldSpec).visit();
                         
                         POStore newSto = getStore();
-                        newSto.setSFile(oldSpec);                        
+                        newSto.setSFile(oldSpec);
+                        if (MRPlan.getPredecessors(mrOp)!=null && 
+                                MRPlan.getPredecessors(mrOp).contains(mro))
+                            MRPlan.disconnect(mro, mrOp);
                         MapReduceOper catMROp = getConcatenateJob(newSpec, mro, newSto); 
                         MRPlan.connect(catMROp, mrOp);   
                         seen.put(oldSpec, catMROp);
                     } else {
-                        MRPlan.connect(mro, mrOp);
                         if (!hasSeen) seen.put(oldSpec, mro);
                     }
-                } else {
-                    MRPlan.connect(mro, mrOp);
                 }
             }
         }
@@ -360,6 +360,8 @@ public class MRCompiler extends PhyPlanVisitor {
         RearrangeAdjuster ra = new RearrangeAdjuster(MRPlan);
         ra.visit();
         
+        connectSoftLink();
+        
         LimitAdjuster la = new LimitAdjuster(MRPlan);
         la.visit();
         la.adjust();
@@ -367,6 +369,22 @@ public class MRCompiler extends PhyPlanVisitor {
         return MRPlan;
     }
     
+    public void connectSoftLink() throws PlanException, IOException {
+        for (PhysicalOperator op : plan) {
+            if (plan.getSoftLinkPredecessors(op)!=null) {
+                for (PhysicalOperator pred : plan.getSoftLinkPredecessors(op)) {
+                    MapReduceOper from = phyToMROpMap.get(pred);
+                    MapReduceOper to = phyToMROpMap.get(op);
+                    if (from==to)
+                        continue;
+                    if (MRPlan.getPredecessors(to)==null || !MRPlan.getPredecessors(to).contains(from)) {
+                        MRPlan.connect(from, to);
+                    }
+                }
+            }
+        }
+    }
+    
     /**
      * Compiles the plan below op into a MapReduce Operator
      * and stores it in curMROp.
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
index bdf93a911..2cf300654 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
@@ -466,7 +466,7 @@ public class MapReduceLauncher extends Launcher{
         MRCompiler comp = new MRCompiler(php, pc);
         comp.randomizeFileLocalizer();
         comp.compile();
-        comp.connectScalars();
+        comp.aggregateScalarsFiles();
         MROperPlan plan = comp.getMRPlan();
         
         //display the warning message(s) from the MRCompiler
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index 076ae4793..d89e5c49e 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -73,8 +73,6 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 
     protected PigContext pc;
     
-    protected Map<PhysicalOperator, LogicalOperator> scalarAliasMap = new HashMap<PhysicalOperator, LogicalOperator>();
-
     public LogToPhyTranslationVisitor(LogicalPlan plan) {
         super(plan, new DependencyOrderWalker<LogicalOperator, LogicalPlan>(
                 plan));
@@ -83,12 +81,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         currentPlan = new PhysicalPlan();
         logToPhyMap = new HashMap<LogicalOperator, PhysicalOperator>();
     }
-    
-    public void finish() {
-        for(PhysicalOperator physOp: scalarAliasMap.keySet()) {
-            ((POUserFunc)physOp).setReferencedOperator(logToPhyMap.get(scalarAliasMap.get(physOp)));
-        }
-    }
+
     public void setPigContext(PigContext pc) {
         this.pc = pc;
     }
@@ -718,6 +711,8 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         default:
             throw new LogicalToPhysicalTranslatorException("Unknown CoGroup Modifier",PigException.BUG);
         }
+        
+        translateSoftLinks(cg);
     }
     
     private boolean validateMergeCogrp(boolean[] innerFlags){
@@ -1148,6 +1143,8 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             logToPhyMap.put(loj, fe);
             poPackage.setPackageType(PackageType.JOIN);
 		}
+		
+		translateSoftLinks(loj);
 	}
 	
 	private POForEach compileFE4Flattening(boolean[] innerFlags,String scope, 
@@ -1281,6 +1278,8 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
+        
+        translateSoftLinks(filter);
     }
 
     @Override
@@ -1395,7 +1394,8 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
-
+        
+        translateSoftLinks(g);
     }
 
     @Override
@@ -1588,6 +1588,8 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
+        
+        translateSoftLinks(split);
     }
 
     @Override
@@ -1623,10 +1625,10 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         logToPhyMap.put(func, p);
         
         // We need to track all the scalars
-        if(func.getImplicitReferencedOperator() != null) {
-            scalarAliasMap.put(p, func.getImplicitReferencedOperator());
+        if (func.getImplicitReferencedOperator()!=null) {
+            PhysicalOperator referredOp = logToPhyMap.get(func.getImplicitReferencedOperator());
+            ((POUserFunc)p).setReferencedOperator(referredOp);
         }
-
     }
 
     @Override
@@ -1969,5 +1971,22 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             }
         }
     }
+    
+    private void translateSoftLinks(LogicalOperator op) throws VisitorException  {
+        List<LogicalOperator> preds = op.getPlan().getSoftLinkPredecessors(op);
+
+        if (preds == null)
+            return;
 
+        try {
+            for (LogicalOperator pred : preds) {
+                PhysicalOperator from = logToPhyMap.get(pred);
+                currentPlan.createSoftLink(from, logToPhyMap.get(op));
+            }
+        } catch (PlanException e) {
+            int errorCode = 2015;
+            String msg = "Cannot translate soft link";
+            throw new VisitorException(msg, errorCode, PigException.BUG, e);
+        }
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/ScalarFinder.java b/src/org/apache/pig/impl/logicalLayer/ScalarFinder.java
index 3d48505f6..08d8e57f6 100644
--- a/src/org/apache/pig/impl/logicalLayer/ScalarFinder.java
+++ b/src/org/apache/pig/impl/logicalLayer/ScalarFinder.java
@@ -22,10 +22,17 @@ import java.util.Map;
 
 import org.apache.pig.impl.plan.DepthFirstWalker;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Pair;
 
 public class ScalarFinder extends LOVisitor {
 
-    Map<LOUserFunc, LogicalPlan> mScalarMap = new HashMap<LOUserFunc, LogicalPlan>();
+    // We need to find top level logical operator associated with the scalar,
+    // visiting nested plan will not change currentOp; inOp is to make sure
+    // we only track top level operator
+    private LogicalOperator currentOp;
+    
+    private boolean inOp = false;
+    Map<LOUserFunc, Pair<LogicalPlan, LogicalOperator>> mScalarMap = new HashMap<LOUserFunc, Pair<LogicalPlan, LogicalOperator>>();
 
     /**
      * @param plan
@@ -38,14 +45,64 @@ public class ScalarFinder extends LOVisitor {
     @Override
     protected void visit(LOUserFunc scalar) throws VisitorException {
         if(scalar.getImplicitReferencedOperator() != null) {
-            mScalarMap.put(scalar, mCurrentWalker.getPlan());
+            mScalarMap.put(scalar, new Pair<LogicalPlan, LogicalOperator>(mCurrentWalker.getPlan(), currentOp));
         }
     }
+    
+    @Override
+    protected void visit(LOFilter op) throws VisitorException {
+        if (!inOp) {
+            inOp = true;
+            currentOp = op;
+        }
+        super.visit(op);
+        inOp = false;
+    }
+
+    @Override
+    protected void visit(LOForEach op) throws VisitorException {
+        if (!inOp) {
+            inOp = true;
+            currentOp = op;
+        }
+        super.visit(op);
+        inOp = false;
+    }
+    
+    @Override
+    protected void visit(LOSplitOutput op) throws VisitorException {
+        if (!inOp) {
+            inOp = true;
+            currentOp = op;
+        }
+        super.visit(op);
+        inOp = false;
+    }
+    
+    @Override
+    protected void visit(LOCogroup op) throws VisitorException {
+        if (!inOp) {
+            inOp = true;
+            currentOp = op;
+        }
+        super.visit(op);
+        inOp = false;
+    }
+
+    @Override
+    protected void visit(LOJoin op) throws VisitorException {
+        if (!inOp) {
+            inOp = true;
+            currentOp = op;
+        }
+        super.visit(op);
+        inOp = false;
+    }
 
     /**
      * @return Map of scalar operators found in the plan
      */
-    public Map<LOUserFunc, LogicalPlan> getScalarMap() {
+    public Map<LOUserFunc, Pair<LogicalPlan, LogicalOperator>> getScalarMap() {
         return mScalarMap;
     }
    
diff --git a/src/org/apache/pig/impl/plan/DependencyOrderWalker.java b/src/org/apache/pig/impl/plan/DependencyOrderWalker.java
index 56fab772f..6a7783fe4 100644
--- a/src/org/apache/pig/impl/plan/DependencyOrderWalker.java
+++ b/src/org/apache/pig/impl/plan/DependencyOrderWalker.java
@@ -23,6 +23,8 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.apache.pig.impl.util.Utils;
+
 
 /**
  * DependencyOrderWalker traverses the graph in such a way that no node is visited
@@ -64,7 +66,6 @@ public class DependencyOrderWalker <O extends Operator, P extends OperatorPlan<O
         for (O op : leaves) {
             doAllPredecessors(op, seen, fifo);
         }
-
         for (O op: fifo) {
             op.visit(visitor);
         }
@@ -79,7 +80,7 @@ public class DependencyOrderWalker <O extends Operator, P extends OperatorPlan<O
                                    Collection<O> fifo) throws VisitorException {
         if (!seen.contains(node)) {
             // We haven't seen this one before.
-            Collection<O> preds = mPlan.getPredecessors(node);
+            Collection<O> preds = Utils.mergeCollection(mPlan.getPredecessors(node), mPlan.getSoftLinkPredecessors(node));
             if (preds != null && preds.size() > 0) {
                 // Do all our predecessors before ourself
                 for (O op : preds) {
diff --git a/src/org/apache/pig/impl/plan/DependencyOrderWalkerWOSeenChk.java b/src/org/apache/pig/impl/plan/DependencyOrderWalkerWOSeenChk.java
index ba8e9b75e..94385a83b 100644
--- a/src/org/apache/pig/impl/plan/DependencyOrderWalkerWOSeenChk.java
+++ b/src/org/apache/pig/impl/plan/DependencyOrderWalkerWOSeenChk.java
@@ -23,6 +23,8 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.apache.pig.impl.util.Utils;
+
 
 /**
  * DependencyOrderWalker traverses the graph in such a way that no node is visited
@@ -79,7 +81,7 @@ public class DependencyOrderWalkerWOSeenChk <O extends Operator, P extends Opera
                                    Collection<O> fifo) throws VisitorException {
 //        if (!seen.contains(node)) {
             // We haven't seen this one before.
-            Collection<O> preds = mPlan.getPredecessors(node);
+            Collection<O> preds = Utils.mergeCollection(mPlan.getPredecessors(node), mPlan.getSoftLinkPredecessors(node));
             if (preds != null && preds.size() > 0) {
                 // Do all our predecessors before ourself
                 for (O op : preds) {
diff --git a/src/org/apache/pig/impl/plan/DepthFirstWalker.java b/src/org/apache/pig/impl/plan/DepthFirstWalker.java
index 89703e0a7..da8ef3f50 100644
--- a/src/org/apache/pig/impl/plan/DepthFirstWalker.java
+++ b/src/org/apache/pig/impl/plan/DepthFirstWalker.java
@@ -22,6 +22,8 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.apache.pig.impl.util.Utils;
+
 
 /**
  * DepthFirstWalker traverses a plan in a depth first manner.  One important note
@@ -65,7 +67,7 @@ public class DepthFirstWalker <O extends Operator, P extends OperatorPlan<O>>
         for (O suc : successors) {
             if (seen.add(suc)) {
                 suc.visit(visitor);
-                Collection<O> newSuccessors = mPlan.getSuccessors(suc);
+                Collection<O> newSuccessors = Utils.mergeCollection(mPlan.getSuccessors(suc), mPlan.getSoftLinkSuccessors(suc));
                 depthFirst(suc, newSuccessors, seen, visitor);
             }
         }
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index 9c6b3586d..e24e47111 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -71,6 +71,8 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
     protected Map<OperatorKey, E> mKeys;
     protected MultiMap<E, E> mFromEdges;
     protected MultiMap<E, E> mToEdges;
+    protected MultiMap<E, E> mSoftFromEdges;
+    protected MultiMap<E, E> mSoftToEdges;
 
     private List<E> mRoots;
     private List<E> mLeaves;
@@ -83,6 +85,8 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         mKeys = new HashMap<OperatorKey, E>();
         mFromEdges = new MultiMap<E, E>();
         mToEdges = new MultiMap<E, E>();
+        mSoftFromEdges = new MultiMap<E, E>();
+        mSoftToEdges = new MultiMap<E, E>();
     }
 
     /**
@@ -193,7 +197,32 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         mFromEdges.put(from, to);
         mToEdges.put(to, from);
     }
+    
+    /**
+     * Create an soft edge between two nodes.
+     * @param from Operator dependent upon.
+     * @param to Operator having the dependency.
+     * @throws PlanException if the nodes is not in plan
+     */
+    public void createSoftLink(E from, E to) throws PlanException {
+        // Check that both nodes are in the plan.
+        checkInPlan(from);
+        checkInPlan(to);
+
+        mSoftFromEdges.put(from, to);
+        mSoftToEdges.put(to, from);
+    }
 
+    /**
+     * Remove an soft edge
+     * @param from Operator dependent upon
+     * @param to Operator having the dependency
+     */
+    public void removeSoftLink(E from, E to) {
+        mSoftFromEdges.remove(from, to);
+        mSoftToEdges.remove(to, from);
+    }
+    
     /**
      * Remove an edge from between two nodes. 
      * Use {@link org.apache.pig.impl.plan.OperatorPlan#insertBetween(Operator, Operator, Operator)} 
@@ -224,6 +253,9 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
 
         removeEdges(op, mFromEdges, mToEdges);
         removeEdges(op, mToEdges, mFromEdges);
+        
+        removeEdges(op, mSoftFromEdges, mSoftToEdges);
+        removeEdges(op, mSoftToEdges, mSoftFromEdges);
 
         // Remove the operator from nodes
         mOps.remove(op);
@@ -304,6 +336,27 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         return (List<E>)mFromEdges.get(op);
     }
     
+    /**
+     * Find all of the nodes that have soft edges to the indicated node from
+     * themselves.
+     * @param op Node to look to
+     * @return Collection of nodes.
+     */
+    public List<E> getSoftLinkPredecessors(E op) {
+        return (List<E>)mSoftToEdges.get(op);
+    }
+
+
+    /**
+     * Find all of the nodes that have soft edges from the indicated node to
+     * themselves.
+     * @param op Node to look from
+     * @return Collection of nodes.
+     */
+    public List<E> getSoftLinkSuccessors(E op) {
+        return (List<E>)mSoftFromEdges.get(op);
+    }
+    
     /**
      * A method to check if there is a path from a given node to another node
      * @param from the start node for checking
diff --git a/src/org/apache/pig/impl/plan/ReverseDependencyOrderWalker.java b/src/org/apache/pig/impl/plan/ReverseDependencyOrderWalker.java
index 2b594966e..f8ac80c47 100644
--- a/src/org/apache/pig/impl/plan/ReverseDependencyOrderWalker.java
+++ b/src/org/apache/pig/impl/plan/ReverseDependencyOrderWalker.java
@@ -23,6 +23,8 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
+import org.apache.pig.impl.util.Utils;
+
 
 /**
  * ReverseDependencyOrderWalker traverses the graph in such a way that no node is visited
@@ -79,7 +81,7 @@ public class ReverseDependencyOrderWalker <O extends Operator, P extends Operato
                                    Collection<O> fifo) throws VisitorException {
         if (!seen.contains(node)) {
             // We haven't seen this one before.
-            Collection<O> succs = mPlan.getSuccessors(node);
+            Collection<O> succs = Utils.mergeCollection(mPlan.getSuccessors(node), mPlan.getSoftLinkSuccessors(node));
             if (succs != null && succs.size() > 0) {
                 // Do all our successors before ourself
                 for (O op : succs) {
diff --git a/src/org/apache/pig/impl/util/Utils.java b/src/org/apache/pig/impl/util/Utils.java
index e65080494..ce6522e1f 100644
--- a/src/org/apache/pig/impl/util/Utils.java
+++ b/src/org/apache/pig/impl/util/Utils.java
@@ -19,6 +19,7 @@ package org.apache.pig.impl.util;
 
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
+import java.util.Collection;
 import java.util.List;
 
 import org.apache.hadoop.conf.Configuration;
@@ -205,5 +206,36 @@ public class Utils {
     public static String slashisize(String str) {
         return str.replace("\\\\", "\\");
     }
+    
+    @SuppressWarnings("unchecked")
+    public static <O> Collection<O> mergeCollection(Collection<O> a, Collection<O> b) {
+        if (a==null && b==null)
+            return null;
+        Collection<O> result = null;
+        try {
+            if (a!=null)
+                result = (Collection<O>)a.getClass().newInstance();
+            else
+                result = (Collection<O>)b.getClass().newInstance();
+        } catch (Exception e) {
+            // Shall not happen
+        }
+        if (a==null) {
+            result.addAll(b);
+        }
+        else if (b==null) {
+            result.addAll(a);
+        }
+        else {
+            result.addAll(a);
+            for (O o : b) {
+                if (!result.contains(o)) {
+                    result.add(o);
+                }
+            }
+        }
+        
+        return result;
+    }
 
 }
diff --git a/src/org/apache/pig/newplan/BaseOperatorPlan.java b/src/org/apache/pig/newplan/BaseOperatorPlan.java
index 5b918e588..6e1c5d53e 100644
--- a/src/org/apache/pig/newplan/BaseOperatorPlan.java
+++ b/src/org/apache/pig/newplan/BaseOperatorPlan.java
@@ -36,6 +36,8 @@ public abstract class BaseOperatorPlan implements OperatorPlan {
     protected Set<Operator> ops;
     protected PlanEdge fromEdges;
     protected PlanEdge toEdges;
+    protected PlanEdge softFromEdges;
+    protected PlanEdge softToEdges;
 
     private List<Operator> roots;
     private List<Operator> leaves;
@@ -48,6 +50,8 @@ public abstract class BaseOperatorPlan implements OperatorPlan {
         leaves = new ArrayList<Operator>();
         fromEdges = new PlanEdge();
         toEdges = new PlanEdge();
+        softFromEdges = new PlanEdge();
+        softToEdges = new PlanEdge();
     }
     
     /**
@@ -109,6 +113,27 @@ public abstract class BaseOperatorPlan implements OperatorPlan {
     public List<Operator> getSuccessors(Operator op) {
         return (List<Operator>)fromEdges.get(op);
     }
+    
+    /**
+     * For a given operator, get all operators softly immediately before it in the
+     * plan.
+     * @param op operator to fetch predecessors of
+     * @return list of all operators immediately before op, or an empty list
+     * if op is a root.
+     */
+    public List<Operator> getSoftLinkPredecessors(Operator op) {
+        return (List<Operator>)softToEdges.get(op);
+    }
+    
+    /**
+     * For a given operator, get all operators softly immediately after it.
+     * @param op operator to fetch successors of
+     * @return list of all operators immediately after op, or an empty list
+     * if op is a leaf.
+     */
+    public List<Operator> getSoftLinkSuccessors(Operator op) {
+        return (List<Operator>)softFromEdges.get(op);
+    }
 
     /**
      * Add a new operator to the plan.  It will not be connected to any
@@ -132,6 +157,10 @@ public abstract class BaseOperatorPlan implements OperatorPlan {
             throw new FrontendException("Attempt to remove operator " + op.getName()
                     + " that is still connected in the plan", 2243);
         }
+        if (softFromEdges.containsKey(op) || softToEdges.containsKey(op)) {
+            throw new FrontendException("Attempt to remove operator " + op.getName()
+                    + " that is still softly connected in the plan", 2243);
+        }
         markDirty();
         ops.remove(op);
     }
@@ -164,6 +193,26 @@ public abstract class BaseOperatorPlan implements OperatorPlan {
         toEdges.put(to, from);
     }
     
+    /**
+     * Create an soft edge between two nodes.
+     * @param from Operator dependent upon
+     * @param to Operator having the dependency
+     */
+    public void createSoftLink(Operator from, Operator to) {
+        softFromEdges.put(from, to);
+        softToEdges.put(to, from);
+    }
+    
+    /**
+     * Remove an soft edge
+     * @param from Operator dependent upon
+     * @param to Operator having the dependency
+     */
+    public void removeSoftLink(Operator from, Operator to) {
+        softFromEdges.remove(from, to);
+        softToEdges.remove(to, from);
+    }
+    
     /**
      * Disconnect two operators in the plan.
      * @param from Operator edge is coming from
diff --git a/src/org/apache/pig/newplan/DependencyOrderWalker.java b/src/org/apache/pig/newplan/DependencyOrderWalker.java
index f7828895d..a5014e9ae 100644
--- a/src/org/apache/pig/newplan/DependencyOrderWalker.java
+++ b/src/org/apache/pig/newplan/DependencyOrderWalker.java
@@ -26,6 +26,7 @@ import java.util.Set;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Utils;
 
 /**
  * A walker to walk graphs in dependency order.  It is guaranteed that a node
@@ -64,7 +65,7 @@ public class DependencyOrderWalker extends PlanWalker {
 
         List<Operator> fifo = new ArrayList<Operator>();
         Set<Operator> seen = new HashSet<Operator>();
-        List<Operator> leaves = getSinks();
+        List<Operator> leaves = plan.getSinks();
         if (leaves == null) return;
         for (Operator op : leaves) {
             doAllPredecessors(op, seen, fifo);
@@ -74,17 +75,13 @@ public class DependencyOrderWalker extends PlanWalker {
             op.accept(visitor);
         }
     }
-    
-    protected List<Operator> getSinks() throws FrontendException{
-        return plan.getSinks();
-    }
 
     protected void doAllPredecessors(Operator node,
                                    Set<Operator> seen,
                                    Collection<Operator> fifo) throws FrontendException {
         if (!seen.contains(node)) {
             // We haven't seen this one before.
-            Collection<Operator> preds = plan.getPredecessors(node);
+            Collection<Operator> preds = Utils.mergeCollection(plan.getPredecessors(node), plan.getSoftLinkPredecessors(node));
             if (preds != null && preds.size() > 0) {
                 // Do all our predecessors before ourself
                 for (Operator op : preds) {
diff --git a/src/org/apache/pig/newplan/DependencyOrderWalkerLPScalar.java b/src/org/apache/pig/newplan/DependencyOrderWalkerLPScalar.java
index 4b0a65d28..e69de29bb 100644
--- a/src/org/apache/pig/newplan/DependencyOrderWalkerLPScalar.java
+++ b/src/org/apache/pig/newplan/DependencyOrderWalkerLPScalar.java
@@ -1,146 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.pig.newplan;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.newplan.logical.expression.UserFuncExpression;
-import org.apache.pig.newplan.logical.optimizer.ScalarFinder;
-import org.apache.pig.newplan.logical.relational.LogicalPlan;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
-
-/**
- * Dependency walker that walks logical plan, it picks the leafs based 
- * on scalar-alias dependency order
- */
-public class DependencyOrderWalkerLPScalar extends DependencyOrderWalker {
-    
-    public DependencyOrderWalkerLPScalar(OperatorPlan plan) {
-        super(plan);
-    }
-
-
-    @Override
-    protected List<Operator> getSinks() throws FrontendException{
-        //find list of scalars and the LogicalRelationalOperator that has them
-        ScalarFinder sFinder = new ScalarFinder(plan);
-        sFinder.visit();
-        HashMap<UserFuncExpression, LogicalRelationalOperator> scalars =
-            sFinder.getScalarLOMap();
-        
-        //create a plan with only the sinks from original plan
-        // that maps dependency between sink nodes based on 
-        // scalar dependency
-        LogicalPlan sinksPlan = new LogicalPlan();
-        for(Map.Entry<UserFuncExpression, LogicalRelationalOperator> e : scalars.entrySet()){
-            List<LogicalRelationalOperator> scalarSinks =
-                new ArrayList<LogicalRelationalOperator>();
-            getSinks(e.getValue(), scalarSinks);
-            
-            List<LogicalRelationalOperator> sourceSinks =
-                new ArrayList<LogicalRelationalOperator>();
-            getSinks(e.getKey().getImplicitReferencedOperator(), sourceSinks);
-            
-            for(LogicalRelationalOperator scalarSink : scalarSinks){
-                for(LogicalRelationalOperator sourceSink : sourceSinks ){
-                    //if the link already exists, don't add again
-                    if(sinksPlan.getSuccessors(sourceSink) != null
-                            && sinksPlan.getSuccessors(sourceSink).contains(scalarSink)
-                    ){
-                        continue;
-                    }
-                    // add the relationship - scalarSink depends on sourceSink
-                    sinksPlan.add(sourceSink);
-                    sinksPlan.add(scalarSink);
-                    sinksPlan.connect(sourceSink, scalarSink);
-                }
-            }
-            
-        }
-        
-        //list of sink nodes ordered by the scalar dependency order
-        ArrayList<Operator> orderedSinkNodes =
-            new ArrayList<Operator>();
-
-        //keep track of sink nodes that have been added so far
-        Set<Operator> sinkNodesAdded = new HashSet<Operator>();
-        
-        
-        //use the plan to get sink operators out first
-        List<Operator> sources;
-        do{
-            sources = new ArrayList<Operator>(sinksPlan.getSources());
-            for(Operator source : sources){
-                // add the current sources to list
-                // and remove them from plan to get new sources
-                orderedSinkNodes.add(source);
-                sinkNodesAdded.add(source);
-                if(sinksPlan.getSuccessors(source) != null){
-                    //disconnect before removing
-                    List<Operator>succs = new ArrayList<Operator>(sinksPlan.getSuccessors(source));
-                    for(Operator succ : succs){
-                        sinksPlan.disconnect(source, succ);
-                    }
-                }
-                sinksPlan.remove(source);
-            }
-        }
-        while(sources.size() > 0);
-
-        //add remaining sink nodes from original plan
-        List<Operator> allSinks = plan.getSinks();
-        for(Operator sink : allSinks){
-            if(!sinkNodesAdded.contains(sink)){
-                orderedSinkNodes.add(sink);
-            }
-        }
-        
-        return orderedSinkNodes;
-    }
-
-
-    /**
-     * get all sinks that are successor of LogicalRelationalOperator lop
-     * and add them to scalarSinks
-     * @param lop LogicalRelationalOperator
-     * @param scalarSinks
-     */
-    private void getSinks(LogicalRelationalOperator lop, 
-            List<LogicalRelationalOperator> scalarSinks) {
-        
-        List<Operator> succs = lop.getPlan().getSuccessors(lop);
-        if(succs == null){
-            // no successors, this is a sink
-            scalarSinks.add(lop);
-            return;
-        }
-        for(Operator op : succs){
-            getSinks((LogicalRelationalOperator)op, scalarSinks);
-        }
-        
-    }
-
-    
-}
diff --git a/src/org/apache/pig/newplan/DepthFirstWalker.java b/src/org/apache/pig/newplan/DepthFirstWalker.java
index ef371e631..cda196335 100644
--- a/src/org/apache/pig/newplan/DepthFirstWalker.java
+++ b/src/org/apache/pig/newplan/DepthFirstWalker.java
@@ -24,6 +24,7 @@ import java.util.List;
 import java.util.Set;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.util.Utils;
 
 /**
  * Do a depth first traversal of the graph.
@@ -61,7 +62,7 @@ public class DepthFirstWalker extends PlanWalker {
         for (Operator suc : successors) {
             if (seen.add(suc)) {
                 suc.accept(visitor);
-                Collection<Operator> newSuccessors = plan.getSuccessors(suc);
+                Collection<Operator> newSuccessors = Utils.mergeCollection(plan.getSuccessors(suc), plan.getSoftLinkSuccessors(suc));
                 depthFirst(suc, newSuccessors, seen, visitor);
             }
         }
diff --git a/src/org/apache/pig/newplan/OperatorPlan.java b/src/org/apache/pig/newplan/OperatorPlan.java
index f3fa932e5..38497a592 100644
--- a/src/org/apache/pig/newplan/OperatorPlan.java
+++ b/src/org/apache/pig/newplan/OperatorPlan.java
@@ -71,6 +71,23 @@ public interface OperatorPlan {
      */
     public List<Operator> getSuccessors(Operator op);
 
+    /**
+     * For a given operator, get all operators softly immediately before it in the
+     * plan.
+     * @param op operator to fetch predecessors of
+     * @return list of all operators immediately before op, or an empty list
+     * if op is a root.
+     */
+    public List<Operator> getSoftLinkPredecessors(Operator op);
+    
+    /**
+     * For a given operator, get all operators softly immediately after it.
+     * @param op operator to fetch successors of
+     * @return list of all operators immediately after op, or an empty list
+     * if op is a leaf.
+     */
+    public List<Operator> getSoftLinkSuccessors(Operator op);
+    
     /**
      * Add a new operator to the plan.  It will not be connected to any
      * existing operators.
@@ -103,6 +120,20 @@ public interface OperatorPlan {
      */
     public void connect(Operator from, Operator to);
     
+    /**
+     * Create an soft edge between two nodes.
+     * @param from Operator dependent upon
+     * @param to Operator having the dependency
+     */
+    public void createSoftLink(Operator from, Operator to);
+    
+    /**
+     * Remove an soft edge
+     * @param from Operator dependent upon
+     * @param to Operator having the dependency
+     */
+    public void removeSoftLink(Operator from, Operator to);
+    
     /**
      * Disconnect two operators in the plan.
      * @param from Operator edge is coming from
diff --git a/src/org/apache/pig/newplan/OperatorSubPlan.java b/src/org/apache/pig/newplan/OperatorSubPlan.java
index d3cdf727b..2c804d1f8 100644
--- a/src/org/apache/pig/newplan/OperatorSubPlan.java
+++ b/src/org/apache/pig/newplan/OperatorSubPlan.java
@@ -153,5 +153,25 @@ public class OperatorSubPlan implements OperatorPlan {
     @Override
     public boolean isEqual(OperatorPlan other) throws FrontendException {		
         return BaseOperatorPlan.isEqual(this, other);
+    }
+
+    @Override
+    public void createSoftLink(Operator from, Operator to) {
+        throw new UnsupportedOperationException("connect() can not be called on OperatorSubPlan");
+    }
+    
+    @Override
+    public void removeSoftLink(Operator from, Operator to) {
+        throw new UnsupportedOperationException("connect() can not be called on OperatorSubPlan");
+    }
+
+    @Override
+    public List<Operator> getSoftLinkPredecessors(Operator op) {
+        return basePlan.getSoftLinkPredecessors(op);
+    }
+
+    @Override
+    public List<Operator> getSoftLinkSuccessors(Operator op) {
+        return basePlan.getSoftLinkSuccessors(op);
     }    
 }
diff --git a/src/org/apache/pig/newplan/ReverseDependencyOrderWalker.java b/src/org/apache/pig/newplan/ReverseDependencyOrderWalker.java
index bb55da890..cf4d28677 100644
--- a/src/org/apache/pig/newplan/ReverseDependencyOrderWalker.java
+++ b/src/org/apache/pig/newplan/ReverseDependencyOrderWalker.java
@@ -25,6 +25,7 @@ import java.util.List;
 import java.util.Set;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.util.Utils;
 
 /**
  * Visit a plan in the reverse of the dependency order.  That is, every node
@@ -75,7 +76,7 @@ public class ReverseDependencyOrderWalker extends PlanWalker {
                                    Collection<Operator> fifo) throws FrontendException {
         if (!seen.contains(node)) {
             // We haven't seen this one before.
-            Collection<Operator> succs = plan.getSuccessors(node);
+            Collection<Operator> succs = Utils.mergeCollection(plan.getSuccessors(node), plan.getSoftLinkSuccessors(node));
             if (succs != null && succs.size() > 0) {
                 // Do all our successors before ourself
                 for (Operator op : succs) {
diff --git a/src/org/apache/pig/newplan/logical/ForeachInnerPlanVisitor.java b/src/org/apache/pig/newplan/logical/ForeachInnerPlanVisitor.java
index 6724727ce..48cc3e8dc 100644
--- a/src/org/apache/pig/newplan/logical/ForeachInnerPlanVisitor.java
+++ b/src/org/apache/pig/newplan/logical/ForeachInnerPlanVisitor.java
@@ -55,12 +55,12 @@ public class ForeachInnerPlanVisitor extends LogicalExpPlanMigrationVistor {
     private LOForEach oldForeach;
     private org.apache.pig.newplan.logical.relational.LogicalRelationalOperator gen;
     private int inputNo;
-    private HashMap<LogicalOperator, LogicalRelationalOperator> innerOpsMap;
-    private Map<LogicalExpression, LogicalOperator> scalarAliasMap = new HashMap<LogicalExpression, LogicalOperator>();
+    private Map<LogicalOperator, LogicalRelationalOperator> innerOpsMap;
+    private Map<LogicalOperator, LogicalRelationalOperator> outerOpsMap;
 
     public ForeachInnerPlanVisitor(org.apache.pig.newplan.logical.relational.LOForEach foreach, LOForEach oldForeach, LogicalPlan innerPlan, 
-            LogicalPlan oldLogicalPlan, Map<LogicalExpression, LogicalOperator> scalarMap) throws FrontendException {
-        super(innerPlan, oldForeach, foreach, oldLogicalPlan, scalarMap);
+            LogicalPlan oldLogicalPlan, Map<LogicalOperator, LogicalRelationalOperator> outerOpsMap) throws FrontendException {
+        super(innerPlan, oldForeach, foreach, oldLogicalPlan, outerOpsMap);
         newInnerPlan = foreach.getInnerPlan();
         
         // get next inputNo 
@@ -73,9 +73,9 @@ public class ForeachInnerPlanVisitor extends LogicalExpPlanMigrationVistor {
         }
         
         this.oldForeach = oldForeach;
-                    
+        this.outerOpsMap = outerOpsMap;
+        
         innerOpsMap = new HashMap<LogicalOperator, LogicalRelationalOperator>();
-        scalarAliasMap = scalarMap;
     }
     
     private void translateInnerPlanConnection(LogicalOperator oldOp, org.apache.pig.newplan.Operator newOp) throws FrontendException {
@@ -101,7 +101,7 @@ public class ForeachInnerPlanVisitor extends LogicalExpPlanMigrationVistor {
         PlanWalker<LogicalOperator, LogicalPlan> childWalker = 
             new DependencyOrderWalker<LogicalOperator, LogicalPlan>(lp);
         
-        LogicalExpPlanMigrationVistor childPlanVisitor = new LogicalExpPlanMigrationVistor(lp, oldOp, op, outerPlan, scalarAliasMap);
+        LogicalExpPlanMigrationVistor childPlanVisitor = new LogicalExpPlanMigrationVistor(lp, oldOp, op, outerPlan, outerOpsMap);
         
         childWalker.walk(childPlanVisitor);
         return childPlanVisitor.exprPlan;
diff --git a/src/org/apache/pig/newplan/logical/LogicalExpPlanMigrationVistor.java b/src/org/apache/pig/newplan/logical/LogicalExpPlanMigrationVistor.java
index c4388bcaf..f0442b8be 100644
--- a/src/org/apache/pig/newplan/logical/LogicalExpPlanMigrationVistor.java
+++ b/src/org/apache/pig/newplan/logical/LogicalExpPlanMigrationVistor.java
@@ -21,6 +21,7 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.apache.pig.impl.logicalLayer.ExpressionOperator;
 import org.apache.pig.impl.logicalLayer.FrontendException;
@@ -91,31 +92,41 @@ public class LogicalExpPlanMigrationVistor extends LOVisitor {
     protected LogicalRelationalOperator attachedRelationalOp;
     protected LogicalOperator oldAttachedRelationalOp;
     protected LogicalPlan outerPlan;
-    protected Map<LogicalExpression, LogicalOperator> scalarAliasMap = new HashMap<LogicalExpression, LogicalOperator>();
+    private Map<LogicalOperator, LogicalRelationalOperator> outerOpsMap;
     
     public LogicalExpPlanMigrationVistor(LogicalPlan expressionPlan, LogicalOperator oldAttachedOperator,
-            LogicalRelationalOperator attachedOperator, LogicalPlan outerPlan, Map<LogicalExpression, LogicalOperator> scalarMap) {
+            LogicalRelationalOperator attachedOperator, LogicalPlan outerPlan, 
+            Map<LogicalOperator, LogicalRelationalOperator> outerOpsMap) {
         super(expressionPlan, new DependencyOrderWalker<LogicalOperator, LogicalPlan>(expressionPlan));
         exprPlan = new org.apache.pig.newplan.logical.expression.LogicalExpressionPlan();
         exprOpsMap = new HashMap<LogicalOperator, LogicalExpression>();
         attachedRelationalOp = attachedOperator;
         oldAttachedRelationalOp = oldAttachedOperator;
         this.outerPlan = outerPlan;
-        scalarAliasMap = scalarMap;
+        this.outerOpsMap = outerOpsMap;
     }    
 
     private void translateConnection(LogicalOperator oldOp, org.apache.pig.newplan.Operator newOp) {       
-       List<LogicalOperator> preds = mPlan.getPredecessors(oldOp); 
+       List<LogicalOperator> preds = mPlan.getPredecessors(oldOp);
        
        // the dependency relationship of new expression plan is opposite to the old logical plan
        // for example, a+b, in old plan, "add" is a leave, and "a" and "b" are roots
        // in new plan, "add" is root, and "a" and "b" are leaves.
-       if(preds != null) {            
+       if(preds != null) {
            for(LogicalOperator pred: preds) {
                org.apache.pig.newplan.Operator newPred = exprOpsMap.get(pred);
-               newOp.getPlan().connect(newOp, newPred);                 
+               newOp.getPlan().connect(newOp, newPred);
            }
-       }        
+       }
+       
+       List<LogicalOperator> softPreds = mPlan.getSoftLinkPredecessors(oldOp);
+       
+       if(softPreds != null) {
+           for(LogicalOperator softPred: softPreds) {
+               org.apache.pig.newplan.Operator newSoftPred = exprOpsMap.get(softPred);
+               newOp.getPlan().createSoftLink(newOp, newSoftPred);
+           }
+       }
    }
     
     public void visit(LOProject project) throws VisitorException {
@@ -216,7 +227,7 @@ public class LogicalExpPlanMigrationVistor extends LOVisitor {
         exprOpsMap.put(op, exp);
         // We need to track all the scalars
         if(op.getImplicitReferencedOperator() != null) {
-            scalarAliasMap.put(exp, op.getImplicitReferencedOperator());
+            exp.setImplicitReferencedOperator(outerOpsMap.get(op.getImplicitReferencedOperator()));
         }
 
     }
diff --git a/src/org/apache/pig/newplan/logical/LogicalPlanMigrationVistor.java b/src/org/apache/pig/newplan/logical/LogicalPlanMigrationVistor.java
index c9a9e631a..16fe7b017 100644
--- a/src/org/apache/pig/newplan/logical/LogicalPlanMigrationVistor.java
+++ b/src/org/apache/pig/newplan/logical/LogicalPlanMigrationVistor.java
@@ -60,8 +60,6 @@ import org.apache.pig.newplan.logical.relational.LogicalSchema;
 public class LogicalPlanMigrationVistor extends LOVisitor { 
     private org.apache.pig.newplan.logical.relational.LogicalPlan logicalPlan;
     private Map<LogicalOperator, LogicalRelationalOperator> opsMap;
-    private Map<org.apache.pig.newplan.logical.expression.LogicalExpression, LogicalOperator> scalarAliasMap = 
-        new HashMap<org.apache.pig.newplan.logical.expression.LogicalExpression, LogicalOperator>();
    
     public LogicalPlanMigrationVistor(LogicalPlan plan) {
         super(plan, new DependencyOrderWalker<LogicalOperator, LogicalPlan>(plan));
@@ -72,19 +70,28 @@ public class LogicalPlanMigrationVistor extends LOVisitor {
     private void translateConnection(LogicalOperator oldOp, org.apache.pig.newplan.Operator newOp) {       
         List<LogicalOperator> preds = mPlan.getPredecessors(oldOp); 
         
-        if(preds != null) {            
+        if(preds != null) {
             for(LogicalOperator pred: preds) {
                 org.apache.pig.newplan.Operator newPred = opsMap.get(pred);
-                newOp.getPlan().connect(newPred, newOp);                 
+                newOp.getPlan().connect(newPred, newOp);
             }
-        }        
+        }
+        
+        List<LogicalOperator> softPreds = mPlan.getSoftLinkPredecessors(oldOp); 
+        
+        if(softPreds != null) {
+            for(LogicalOperator softPred: softPreds) {
+                org.apache.pig.newplan.Operator newSoftPred = opsMap.get(softPred);
+                newOp.getPlan().createSoftLink(newSoftPred, newOp);
+            }
+        }
     }      
     
     private LogicalExpressionPlan translateExpressionPlan(LogicalPlan lp, LogicalOperator oldOp, LogicalRelationalOperator op) throws VisitorException {
         PlanWalker<LogicalOperator, LogicalPlan> childWalker = 
             new DependencyOrderWalker<LogicalOperator, LogicalPlan>(lp);
         
-        LogicalExpPlanMigrationVistor childPlanVisitor = new LogicalExpPlanMigrationVistor(lp, oldOp, op, mPlan, scalarAliasMap);
+        LogicalExpPlanMigrationVistor childPlanVisitor = new LogicalExpPlanMigrationVistor(lp, oldOp, op, mPlan, opsMap);
         
         childWalker.walk(childPlanVisitor);
         return childPlanVisitor.exprPlan;
@@ -223,7 +230,7 @@ public class LogicalPlanMigrationVistor extends LOVisitor {
         try {
             for(int i=0; i<ll.size(); i++) {
                 LogicalPlan lp = ll.get(i);
-                ForeachInnerPlanVisitor v = new ForeachInnerPlanVisitor(newForeach, forEach, lp, mPlan, scalarAliasMap);
+                ForeachInnerPlanVisitor v = new ForeachInnerPlanVisitor(newForeach, forEach, lp, mPlan, opsMap);
                 v.visit();
                 
                 expPlans.add(v.exprPlan);
@@ -418,15 +425,5 @@ public class LogicalPlanMigrationVistor extends LOVisitor {
         logicalPlan.add(newNativeMR);
         opsMap.put(nativeMR, newNativeMR);
         translateConnection(nativeMR, newNativeMR);
-    }
-    
-
-    
-    public void finish() {
-        for(org.apache.pig.newplan.logical.expression.LogicalExpression exp: scalarAliasMap.keySet()) {
-            ((org.apache.pig.newplan.logical.expression.UserFuncExpression)exp).setImplicitReferencedOperator(
-                    opsMap.get(scalarAliasMap.get(exp)));
-        }
-    }
-    
+    }    
 }
diff --git a/src/org/apache/pig/newplan/logical/expression/ExpToPhyTranslationVisitor.java b/src/org/apache/pig/newplan/logical/expression/ExpToPhyTranslationVisitor.java
index c25efd1f1..bae1b220a 100644
--- a/src/org/apache/pig/newplan/logical/expression/ExpToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/newplan/logical/expression/ExpToPhyTranslationVisitor.java
@@ -78,21 +78,19 @@ public class ExpToPhyTranslationVisitor extends LogicalExpressionVisitor {
 
     // This value points to the current LogicalRelationalOperator we are working on
     protected LogicalRelationalOperator currentOp;
-    protected Map<PhysicalOperator, LogicalRelationalOperator> scalarAliasMap;
     
     public ExpToPhyTranslationVisitor(OperatorPlan plan, LogicalRelationalOperator op, PhysicalPlan phyPlan, 
-            Map<Operator, PhysicalOperator> map, Map<PhysicalOperator, LogicalRelationalOperator> scalarMap) throws FrontendException {
-        this(plan, new DependencyOrderWalker(plan), op, phyPlan, map, scalarMap);
+            Map<Operator, PhysicalOperator> map) throws FrontendException {
+        this(plan, new DependencyOrderWalker(plan), op, phyPlan, map);
     }
     
-    public ExpToPhyTranslationVisitor(OperatorPlan plan, PlanWalker walker, LogicalRelationalOperator op, PhysicalPlan phyPlan, Map<Operator, PhysicalOperator> map, 
-            Map<PhysicalOperator, LogicalRelationalOperator> scalarMap) throws FrontendException {
+    public ExpToPhyTranslationVisitor(OperatorPlan plan, PlanWalker walker, LogicalRelationalOperator op, PhysicalPlan phyPlan, 
+            Map<Operator, PhysicalOperator> map) throws FrontendException {
         super(plan, walker);
         currentOp = op;
         logToPhyMap = map;
         currentPlan = phyPlan;
         currentPlans = new Stack<PhysicalPlan>();
-        scalarAliasMap = scalarMap;
     }
     
     protected Map<Operator, PhysicalOperator> logToPhyMap;
@@ -510,8 +508,9 @@ public class ExpToPhyTranslationVisitor extends LogicalExpressionVisitor {
         logToPhyMap.put(op, p);
         
         //We need to track all the scalars
+        
         if(op.getImplicitReferencedOperator() != null) {
-            scalarAliasMap.put(p, op.getImplicitReferencedOperator());
+            ((POUserFunc)p).setReferencedOperator(logToPhyMap.get(op.getImplicitReferencedOperator()));
         }
     }
     
diff --git a/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java b/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
index 9ad1b9975..968ca65b3 100644
--- a/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
@@ -41,7 +41,7 @@ import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchem
 public class UserFuncExpression extends LogicalExpression {
 
     private FuncSpec mFuncSpec;
-    private LogicalRelationalOperator implicitReferencedOperator = null; 
+    private Operator implicitReferencedOperator = null; 
     
     public UserFuncExpression(OperatorPlan plan, FuncSpec funcSpec) {
         super("UserFunc", plan);
@@ -108,9 +108,12 @@ public class UserFuncExpression extends LogicalExpression {
             List<Operator> args = plan.getSuccessors(this);
             if(args != null && args.size() > 0 ){
                 int pos = (Integer)((ConstantExpression)args.get(0)).getValue();
-                if( implicitReferencedOperator.getSchema() != null){
-                    LogicalFieldSchema inpFs = implicitReferencedOperator.getSchema().getField(pos);
+                LogicalRelationalOperator inp = (LogicalRelationalOperator)implicitReferencedOperator;
+
+                if( inp.getSchema() != null){
+                    LogicalFieldSchema inpFs = inp.getSchema().getField(pos);
                     fieldSchema = new LogicalFieldSchema(inpFs);
+                    //  fieldSchema.alias = "ReadScalars_" + fieldSchema.alias;
                 }else{
                     fieldSchema = new LogicalFieldSchema(null, null, DataType.BYTEARRAY);
                 }
@@ -154,11 +157,11 @@ public class UserFuncExpression extends LogicalExpression {
         return fieldSchema;
     }
     
-    public LogicalRelationalOperator getImplicitReferencedOperator() {
+    public Operator getImplicitReferencedOperator() {
         return implicitReferencedOperator;
     }
     
-    public void setImplicitReferencedOperator(LogicalRelationalOperator implicitReferencedOperator) {
+    public void setImplicitReferencedOperator(Operator implicitReferencedOperator) {
         this.implicitReferencedOperator = implicitReferencedOperator;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/optimizer/ScalarFinder.java b/src/org/apache/pig/newplan/logical/optimizer/ScalarFinder.java
index 22d2872f5..e69de29bb 100644
--- a/src/org/apache/pig/newplan/logical/optimizer/ScalarFinder.java
+++ b/src/org/apache/pig/newplan/logical/optimizer/ScalarFinder.java
@@ -1,136 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.pig.newplan.logical.optimizer;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.util.MultiMap;
-import org.apache.pig.newplan.DepthFirstWalker;
-import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.PlanWalker;
-import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
-import org.apache.pig.newplan.logical.expression.LogicalExpressionVisitor;
-import org.apache.pig.newplan.logical.expression.UserFuncExpression;
-import org.apache.pig.newplan.logical.relational.LOCogroup;
-import org.apache.pig.newplan.logical.relational.LOFilter;
-import org.apache.pig.newplan.logical.relational.LOForEach;
-import org.apache.pig.newplan.logical.relational.LOGenerate;
-import org.apache.pig.newplan.logical.relational.LOJoin;
-import org.apache.pig.newplan.logical.relational.LOSort;
-import org.apache.pig.newplan.logical.relational.LOSplitOutput;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
-
-public class ScalarFinder extends LogicalRelationalNodesVisitor  {
-
-    private HashMap<UserFuncExpression, LogicalRelationalOperator>  scalars =
-       new HashMap<UserFuncExpression, LogicalRelationalOperator>();
-    
-    public ScalarFinder(OperatorPlan plan)
-            throws FrontendException {
-        super(plan, new DepthFirstWalker(plan));
-    }
-
-    public HashMap<UserFuncExpression, LogicalRelationalOperator> getScalarLOMap(){
-        return scalars;
-    }
-    
-    @Override
-    public void visit(LOFilter filter) throws FrontendException {
-        ScalarFinderInExpPlan sFinder = new ScalarFinderInExpPlan(filter.getFilterPlan(), filter);
-        sFinder.visit();
-    }
-  
-    @Override
-    public void visit(LOJoin join) throws FrontendException {
-        Collection<LogicalExpressionPlan> joinPlans = join.getExpressionPlanValues();
-        for (LogicalExpressionPlan joinPlan : joinPlans) {
-            ScalarFinderInExpPlan sFinder = new ScalarFinderInExpPlan(joinPlan, join);
-            sFinder.visit();
-        }
-    }
-    
-    @Override
-    public void visit(LOForEach foreach) throws FrontendException {
-        OperatorPlan innerPlan = foreach.getInnerPlan();
-        PlanWalker newWalker = currentWalker.spawnChildWalker(innerPlan);
-        pushWalker(newWalker);
-        currentWalker.walk(this);
-        popWalker();
-    }
-    
-    @Override
-    public void visit(LOGenerate gen) throws FrontendException {
-        List<LogicalExpressionPlan> genPlans = gen.getOutputPlans();
-        for (LogicalExpressionPlan genPlan : genPlans) {
-            ScalarFinderInExpPlan sFinder = new ScalarFinderInExpPlan(genPlan, gen);
-            sFinder.visit();
-        }
-    }
-    
-    @Override
-    public void visit(LOCogroup loCogroup) throws FrontendException {
-        MultiMap<Integer, LogicalExpressionPlan> expPlans = loCogroup.getExpressionPlans();
-        for (LogicalExpressionPlan expPlan : expPlans.values()) {
-            ScalarFinderInExpPlan sFinder = new ScalarFinderInExpPlan(expPlan, loCogroup);
-            sFinder.visit();
-        }
-    }
-    
-    
-    @Override
-    public void visit(LOSplitOutput loSplitOutput) throws FrontendException {
-        ScalarFinderInExpPlan sFinder =
-            new ScalarFinderInExpPlan(loSplitOutput.getFilterPlan(), loSplitOutput);
-        sFinder.visit();
-    }
-    
-
-    @Override
-    public void visit(LOSort loSort) throws FrontendException {
-        List<LogicalExpressionPlan> sortPlans = loSort.getSortColPlans();
-        for (LogicalExpressionPlan sortPlan : sortPlans) {
-            ScalarFinderInExpPlan sFinder = new ScalarFinderInExpPlan(sortPlan, loSort);
-            sFinder.visit();
-        }
-    }
-    
-    
-    class ScalarFinderInExpPlan extends LogicalExpressionVisitor{
-
-        
-        private LogicalRelationalOperator logicalOp;
-
-        protected ScalarFinderInExpPlan(LogicalExpressionPlan lep, LogicalRelationalOperator lo)
-                throws FrontendException {
-            super(lep, new DepthFirstWalker(lep));
-            this.logicalOp = lo;
-        }
-        
-        public void visit(UserFuncExpression op) throws FrontendException {
-            if(op.getImplicitReferencedOperator() != null){
-                scalars.put(op, logicalOp);
-            }
-        }
-    }
-    
-}
diff --git a/src/org/apache/pig/newplan/logical/optimizer/SchemaPatcher.java b/src/org/apache/pig/newplan/logical/optimizer/SchemaPatcher.java
index 2a83efedf..2752ebf3c 100644
--- a/src/org/apache/pig/newplan/logical/optimizer/SchemaPatcher.java
+++ b/src/org/apache/pig/newplan/logical/optimizer/SchemaPatcher.java
@@ -20,7 +20,6 @@ package org.apache.pig.newplan.logical.optimizer;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.optimizer.PlanTransformListener;
 
 /**
diff --git a/src/org/apache/pig/newplan/logical/optimizer/SchemaResetter.java b/src/org/apache/pig/newplan/logical/optimizer/SchemaResetter.java
index e4eddeeb2..6957d0476 100644
--- a/src/org/apache/pig/newplan/logical/optimizer/SchemaResetter.java
+++ b/src/org/apache/pig/newplan/logical/optimizer/SchemaResetter.java
@@ -5,7 +5,7 @@ import java.util.List;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.MultiMap;
-import org.apache.pig.newplan.DependencyOrderWalkerLPScalar;
+import org.apache.pig.newplan.DependencyOrderWalker;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanWalker;
 import org.apache.pig.newplan.ReverseDependencyOrderWalker;
@@ -33,7 +33,7 @@ import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
 public class SchemaResetter extends LogicalRelationalNodesVisitor {
 
     public SchemaResetter(OperatorPlan plan) throws FrontendException {
-        super(plan, new DependencyOrderWalkerLPScalar(plan));
+        super(plan, new DependencyOrderWalker(plan));
     }
 
     @Override
diff --git a/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java b/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
index 7f58edbee..4828e50ea 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogToPhyTranslationVisitor.java
@@ -106,9 +106,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
     protected NodeIdGenerator nodeGen = NodeIdGenerator.getGenerator();
 
     protected PigContext pc;
-    
-    protected Map<PhysicalOperator, LogicalRelationalOperator> scalarAliasMap = new HashMap<PhysicalOperator, LogicalRelationalOperator>();
-    
+        
     public void setPigContext(PigContext pc) {
         this.pc = pc;
     }
@@ -208,7 +206,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
         //currentWalker.walk(this);
         currentWalker.walk(
                 new ExpToPhyTranslationVisitor( currentWalker.getPlan(), 
-                        childWalker, filter, currentPlan, logToPhyMap, scalarAliasMap ) );
+                        childWalker, filter, currentPlan, logToPhyMap ) );
         popWalker();
 
         poFilter.setPlan(currentPlan);
@@ -232,6 +230,8 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
+        
+        translateSoftLinks(filter);
 //        System.err.println("Exiting Filter");
     }
     
@@ -248,7 +248,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             PlanWalker childWalker = new ReverseDependencyOrderWalker(plan);
             pushWalker(childWalker);
             childWalker.walk(new ExpToPhyTranslationVisitor( currentWalker.getPlan(), 
-                    childWalker, sort, currentPlan, logToPhyMap, scalarAliasMap ));
+                    childWalker, sort, currentPlan, logToPhyMap));
             sortPlans.add(currentPlan);
             popWalker();
         }
@@ -517,7 +517,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             PlanWalker childWalker = new ReverseDependencyOrderWalker(exps.get(i));
             pushWalker(childWalker);
             childWalker.walk(new ExpToPhyTranslationVisitor(exps.get(i),
-                    childWalker, gen, currentPlan, logToPhyMap, scalarAliasMap ));            
+                    childWalker, gen, currentPlan, logToPhyMap));            
             popWalker();
             
             List<Operator> leaves = exps.get(i).getSinks();
@@ -590,6 +590,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
 
+        translateSoftLinks(foreach);
     }
     
     /**
@@ -623,7 +624,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             currentWalker.walk(
                     new ExpToPhyTranslationVisitor( 
                             currentWalker.getPlan(), 
-                            childWalker, loj, currentPlan, logToPhyMap, scalarAliasMap ) );
+                            childWalker, loj, currentPlan, logToPhyMap) );
             
             exprPlans.add(currentPlan);
             popWalker();
@@ -706,6 +707,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
         default:
             throw new LogicalToPhysicalTranslatorException("Unknown CoGroup Modifier",PigException.BUG);
         }
+        translateSoftLinks(cg);
     }
     
     private void translateCollectedCogroup(LOCogroup cg) throws FrontendException {
@@ -1064,6 +1066,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             logToPhyMap.put(loj, fe);
             poPackage.setPackageType(POPackage.PackageType.JOIN);
         }
+        translateSoftLinks(loj);
     }
     
     private POPackage compileToLR_GR_PackTrio(LogicalRelationalOperator relationalOp, String customPartitioner, 
@@ -1318,7 +1321,7 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
         //currentWalker.walk(this);
         currentWalker.walk(
                 new ExpToPhyTranslationVisitor( currentWalker.getPlan(), 
-                        childWalker, loSplitOutput, currentPlan, logToPhyMap, scalarAliasMap ) );
+                        childWalker, loSplitOutput, currentPlan, logToPhyMap) );
         popWalker();
 
         poFilter.setPlan(currentPlan);
@@ -1342,6 +1345,8 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
+        
+        translateSoftLinks(loSplitOutput);
 //        System.err.println("Exiting Filter");
     }
 
@@ -1402,9 +1407,15 @@ public class LogToPhyTranslationVisitor extends LogicalRelationalNodesVisitor {
         return true;
     }
     
-    public void finish() {
-        for(PhysicalOperator physOp: scalarAliasMap.keySet()) {
-            ((POUserFunc)physOp).setReferencedOperator(logToPhyMap.get(scalarAliasMap.get(physOp)));
+    private void translateSoftLinks(Operator op) throws FrontendException {
+        List<Operator> preds = op.getPlan().getSoftLinkPredecessors(op);
+
+        if (preds == null)
+            return;
+
+        for (Operator pred : preds) {
+            PhysicalOperator from = logToPhyMap.get(pred);
+            currentPlan.createSoftLink(from, logToPhyMap.get(op));
         }
     }
 }
diff --git a/src/org/apache/pig/newplan/logical/rules/MergeFilter.java b/src/org/apache/pig/newplan/logical/rules/MergeFilter.java
index f5faa3fb9..426b96cec 100644
--- a/src/org/apache/pig/newplan/logical/rules/MergeFilter.java
+++ b/src/org/apache/pig/newplan/logical/rules/MergeFilter.java
@@ -84,6 +84,14 @@ public class MergeFilter extends Rule {
                     subPlan.add(op);
                 }
                 
+                // Since we remove next, we need to merge soft link into filter
+                List<Operator> nextSoftPreds = currentPlan.getSoftLinkPredecessors(next);
+                if (nextSoftPreds!=null) {
+                    for (Operator softPred : nextSoftPreds) {
+                        currentPlan.createSoftLink(softPred, filter);
+                    }
+                }
+                
                 currentPlan.remove(next);
             }
             
diff --git a/src/org/apache/pig/newplan/logical/rules/MergeForEach.java b/src/org/apache/pig/newplan/logical/rules/MergeForEach.java
index a6b389fd7..60ef82b26 100644
--- a/src/org/apache/pig/newplan/logical/rules/MergeForEach.java
+++ b/src/org/apache/pig/newplan/logical/rules/MergeForEach.java
@@ -19,6 +19,7 @@
 package org.apache.pig.newplan.logical.rules;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -39,6 +40,7 @@ import org.apache.pig.newplan.optimizer.Rule;
 import org.apache.pig.newplan.optimizer.Transformer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.Pair;
+import org.apache.pig.impl.util.Utils;
 
 public class MergeForEach extends Rule {
 
@@ -221,6 +223,33 @@ public class MergeForEach extends Rule {
             // remove foreach1, foreach2, add new foreach
             Operator pred = currentPlan.getPredecessors(foreach1).get(0);
             Operator succ = currentPlan.getSuccessors(foreach2).get(0);
+            
+            // rebuild soft link
+            Collection<Operator> newSoftLinkPreds = Utils.mergeCollection(currentPlan.getSoftLinkPredecessors(foreach1), 
+                    currentPlan.getSoftLinkPredecessors(foreach2));
+            
+            Collection<Operator> foreach1SoftLinkPred = null;
+            if (currentPlan.getSoftLinkPredecessors(foreach1)!=null) {
+                foreach1SoftLinkPred = new ArrayList<Operator>();
+                foreach1SoftLinkPred.addAll(currentPlan.getSoftLinkPredecessors(foreach1));
+            }
+            if (foreach1SoftLinkPred!=null) {
+                for (Operator softPred : foreach1SoftLinkPred) {
+                    currentPlan.removeSoftLink(softPred, foreach1);
+                }
+            }
+            
+            Collection<Operator> foreach2SoftLinkPred = null;
+            if (currentPlan.getSoftLinkPredecessors(foreach2)!=null) {
+                foreach2SoftLinkPred = new ArrayList<Operator>();
+                foreach2SoftLinkPred.addAll(currentPlan.getSoftLinkPredecessors(foreach2));
+            }
+            if (foreach2SoftLinkPred!=null) {
+                for (Operator softPred : foreach2SoftLinkPred) {
+                    currentPlan.removeSoftLink(softPred, foreach2);
+                }
+            }
+            
             Pair<Integer, Integer> pos = currentPlan.disconnect(pred, foreach1);
             currentPlan.disconnect(foreach1, foreach2);
             currentPlan.disconnect(foreach2, succ);
@@ -231,6 +260,12 @@ public class MergeForEach extends Rule {
             currentPlan.connect(pred, pos.first, newForEach, pos.second);
             currentPlan.connect(newForEach, succ);
             
+            if (newSoftLinkPreds!=null) {
+                for (Operator softPred : newSoftLinkPreds) {
+                    currentPlan.createSoftLink(softPred, newForEach);
+                }
+            }
+            
             subPlan.add(newForEach);
         }
     }
diff --git a/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java b/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
index fc1a03781..06358e24f 100644
--- a/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
+++ b/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
@@ -23,6 +23,7 @@ import java.util.Set;
 import java.util.HashSet;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.util.Utils;
 import org.apache.pig.newplan.logical.expression.*;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
@@ -264,7 +265,7 @@ class NOTConversionVisitor extends LogicalExpressionVisitor {
                 if (seen.add(suc)) {
                     if (suc instanceof NotExpression)
                         ((NOTConversionVisitor) visitor).flip();
-                    Collection<Operator> newSuccessors = plan.getSuccessors(suc);
+                    Collection<Operator> newSuccessors = Utils.mergeCollection(plan.getSuccessors(suc), plan.getSoftLinkSuccessors(suc));
                     depthFirst(suc, newSuccessors, seen, visitor);
                     suc.accept(visitor);
                     if (suc instanceof NotExpression)
diff --git a/src/org/apache/pig/newplan/logical/rules/SplitFilter.java b/src/org/apache/pig/newplan/logical/rules/SplitFilter.java
index d03ce3745..fab3647ef 100644
--- a/src/org/apache/pig/newplan/logical/rules/SplitFilter.java
+++ b/src/org/apache/pig/newplan/logical/rules/SplitFilter.java
@@ -54,7 +54,7 @@ public class SplitFilter extends Rule {
             LOFilter filter = (LOFilter)matched.getSources().get(0);
             LogicalExpressionPlan cond = filter.getFilterPlan();
             LogicalExpression root = (LogicalExpression) cond.getSources().get(0);
-            if (root instanceof AndExpression) {
+            if (root instanceof AndExpression && currentPlan.getSoftLinkPredecessors(filter)==null) {
                 return true;
             }
             
diff --git a/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java b/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java
index 37e13c78f..15b41d3ab 100644
--- a/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java
+++ b/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java
@@ -29,6 +29,7 @@ import org.apache.pig.impl.plan.OperatorPlan;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.PlanWalker;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Utils;
 
 public class PreOrderDepthFirstWalker<O extends Operator, P extends OperatorPlan<O>>
         extends PlanWalker<O, P> {
@@ -68,7 +69,7 @@ public class PreOrderDepthFirstWalker<O extends Operator, P extends OperatorPlan
         for (O pred : predecessors) {
             if (seen.add(pred)) {
                 pred.visit(visitor);
-                Collection<O> newPredecessors = mPlan.getPredecessors(pred);
+                Collection<O> newPredecessors = Utils.mergeCollection(mPlan.getPredecessors(pred), mPlan.getSoftLinkPredecessors(pred));
                 depthFirst(pred, newPredecessors, seen, visitor);
             }
         }
diff --git a/test/findbugsExcludeFile.xml b/test/findbugsExcludeFile.xml
index ab810af78..657fda32b 100644
--- a/test/findbugsExcludeFile.xml
+++ b/test/findbugsExcludeFile.xml
@@ -412,9 +412,14 @@
         <Method name = "init" />
         <Bug pattern="OBL_UNSATISFIED_OBLIGATION" />
     </Match>
-	<Match>
-		<Class name = "org.apache.pig.impl.builtin.ReadScalars" />
-		<Method name = "exec" />
-		<Bug pattern= "RV_DONT_JUST_NULL_CHECK_READLINE" />
-	</Match>
+    <Match>
+        <Class name = "org.apache.pig.impl.builtin.ReadScalars" />
+        <Method name = "exec" />
+        <Bug pattern = "RV_DONT_JUST_NULL_CHECK_READLINE" />
+    </Match>
+    <Match>
+        <Class name = "org.apache.pig.impl.util.Utils" />
+        <Method name = "mergeCollection" />
+        <Bug pattern = "NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH" />
+    </Match>
 </FindBugsFilter>
diff --git a/test/org/apache/pig/test/TestFRJoin2.java b/test/org/apache/pig/test/TestFRJoin2.java
index 64ec57cbe..1456e8512 100644
--- a/test/org/apache/pig/test/TestFRJoin2.java
+++ b/test/org/apache/pig/test/TestFRJoin2.java
@@ -178,7 +178,6 @@ public class TestFRJoin2 {
     
     // test scalar alias with file concatenation following 
     // a multi-query job
-    /*
     @Test
     public void testConcatenateJobForScalar3() throws Exception {
         PigServer pigServer = new PigServer(ExecType.MAPREDUCE, cluster
@@ -221,7 +220,7 @@ public class TestFRJoin2 {
         
         assertEquals(dbfrj.size(), dbshj.size());
         assertEquals(true, TestHelper.compareBags(dbfrj, dbshj));    
-    }*/
+    }
     
     @Test
     public void testConcatenateJobForFRJoin() throws Exception {
diff --git a/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld b/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld
index cfe9e108f..e1914e080 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld
@@ -18,4 +18,4 @@ Reduce Plan Empty
     |   |   |
     |   |   Project[tuple][*] - scope-126
     |   |
-    |   |---b: Load(/tmp/input2:org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MergeJoinIndexer('org.apache.pig.builtin.PigStorage','kmonaaafhdhcaabdgkgbhggbcohfhegjgmcoebhchcgbhjemgjhdhehiibncbnjjmhgbjnadaaabejaaaehdgjhkgfhihaaaaaaaabhhaeaaaaaaabhdhcaaeogphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccohagmgbgohdcofagihjhdgjgdgbgmfagmgbgoaaaaaaaaaaaaaaabacaaabfkaaangfgogeepggebgmgmejgohahfhehihcaacfgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcfagmgbgogpkikkjgaddcgofpacaaagemaaakgneghcgpgnefgeghgfhdheaacdemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphfhegjgmcpenhfgmhegjengbhadlemaaafgnelgfhjhdheaaapemgkgbhggbcphfhegjgmcpengbhadlemaaahgnemgfgbhggfhdheaabaemgkgbhggbcphfhegjgmcpemgjhdhedlemaaaegnephahdhbaahoaaafemaaaggnfcgpgphehdhbaahoaaagemaaaignfegpefgeghgfhdhbaahoaaaehihahdhcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohfhegjgmcoenhfgmhegjengbhaaaaaaaaaaaaaaaacacaaabemaaaegnengbhahbaahoaaafhihahdhcaabbgkgbhggbcohfhegjgmcoeigbhdgiengbhaafahnkmbmdbgganbadaaacegaaakgmgpgbgeeggbgdhegphcejaaajhegihcgfhdgigpgmgehihadpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhdhcaacegphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcelgfhjaaaaaaaaaaaaaaabacaaacekaaacgjgeemaaafhdgdgphagfheaabcemgkgbhggbcpgmgbgoghcpfdhehcgjgoghdlhihaaaaaaaaaaaaaaahhheaaafhdgdgphagfhdhcaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdheaaaaaaaaaaaaaaabacaaaffkaaakgphggfhcgmgpgbgegfgefkaabfhahcgpgdgfhdhdgjgoghecgbghepggfehfhagmgfhdfkaabehcgfhdhfgmhefdgjgoghgmgffehfhagmgfecgbghfkaaaehdhegbhcemaaahgdgpgmhfgngohdheaabfemgkgbhggbcphfhegjgmcpebhchcgbhjemgjhdhedlhihcaagcgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcoefhihahcgfhdhdgjgpgoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaadgmgpghheaacaemgphcghcpgbhagbgdgigfcpgdgpgngngpgohdcpgmgpghghgjgoghcpemgpghdlhihcaaemgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofagihjhdgjgdgbgmephagfhcgbhegphcaaaaaaaaaaaaaaabacaaamfkaaafgbgdgdhfgnfkaaangjgohahfheebhehegbgdgigfgeejaabehcgfhbhfgfhdhegfgefagbhcgbgmgmgfgmgjhdgnecaaakhcgfhdhfgmhefehjhagfemaaafgbgmgjgbhdhbaahoaaaoemaaafgjgohahfheheaablemgphcghcpgbhagbgdgigfcphagjghcpgegbhegbcpfehfhagmgfdlemaaaggjgohahfhehdhbaahoaaagemaaangmgjgogfgbghgffehcgbgdgfhcheaachemgphcghcpgbhagbgdgigfcphagjghcphagfgocphfhegjgmcpemgjgogfgbghgffehcgbgdgfhcdlemaaadgmgpghhbaahoaabeemaaahgphfhehahfhehdhbaahoaaagemaaakhagbhcgfgohefagmgbgoheaafaemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccphagmgbgohdcpfagihjhdgjgdgbgmfagmgbgodlemaaadhcgfhdheaaeeemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccpfcgfhdhfgmhedlhihcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaaegnelgfhjheaacgemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphagmgbgocpephagfhcgbhegphcelgfhjdlhihahbaahoaaapaaaappppppppdchahahahahdhcaaclgphcghcogbhagbgdgigfcogdgpgngngpgohdcogmgpghghgjgoghcogjgnhagmcoemgpghdeekemgpghghgfhccikmpnoicknfncdiacaaabemaaaegogbgngfhbaahoaaaohihaheaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdhehahahdhcaaecgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofcgfhdhfgmheaaaaaaaaaaaaaaabacaaacecaaamhcgfhehfhcgofdhegbhehfhdemaaaghcgfhdhfgmheheaabcemgkgbhggbcpgmgbgoghcpepgcgkgfgdhedlhihaachahbaahoaaboaaaaaaaahdhbaahoaaaaaaaaaaabhhaeaaaaaaabhdhcaabbgkgbhggbcogmgbgoghcoejgohegfghgfhcbcockakephibihdiacaaabejaaafhggbgmhfgfhihcaabagkgbhggbcogmgbgoghcoeohfgngcgfhcigkmjfbnaljeoailacaaaahihaaaaaaaaahihihdhbaahoaaaaaaaaaaabhhaeaaaaaaakhbaahoaabmhihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhbaahoaabmhbaahoaaaphihdhbaahoaaaaaaaaaaaahhaeaaaaaaakhihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahiaahi','','b','scope','true')) - scope-117
\ No newline at end of file
+    |   |---b: Load(/tmp/input2:org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MergeJoinIndexer('org.apache.pig.builtin.PigStorage','kmonaaafhdhcaabdgkgbhggbcohfhegjgmcoebhchcgbhjemgjhdhehiibncbnjjmhgbjnadaaabejaaaehdgjhkgfhihaaaaaaaabhhaeaaaaaaabhdhcaaeogphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccohagmgbgohdcofagihjhdgjgdgbgmfagmgbgoaaaaaaaaaaaaaaabacaaabfkaaangfgogeepggebgmgmejgohahfhehihcaacfgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcfagmgbgoeaondlnechegpmlgacaaaiemaaakgneghcgpgnefgeghgfhdheaacdemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphfhegjgmcpenhfgmhegjengbhadlemaaafgnelgfhjhdheaaapemgkgbhggbcphfhegjgmcpengbhadlemaaahgnemgfgbhggfhdheaabaemgkgbhggbcphfhegjgmcpemgjhdhedlemaaaegnephahdhbaahoaaafemaaaggnfcgpgphehdhbaahoaaagemaaaognfdgpggheeghcgpgnefgeghgfhdhbaahoaaaeemaaamgnfdgpgghefegpefgeghgfhdhbaahoaaaeemaaaignfegpefgeghgfhdhbaahoaaaehihahdhcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohfhegjgmcoenhfgmhegjengbhaaaaaaaaaaaaaaaacacaaabemaaaegnengbhahbaahoaaafhihahdhcaabbgkgbhggbcohfhegjgmcoeigbhdgiengbhaafahnkmbmdbgganbadaaacegaaakgmgpgbgeeggbgdhegphcejaaajhegihcgfhdgigpgmgehihadpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhdhcaacegphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcelgfhjaaaaaaaaaaaaaaabacaaacekaaacgjgeemaaafhdgdgphagfheaabcemgkgbhggbcpgmgbgoghcpfdhehcgjgoghdlhihaaaaaaaaaaaaaaahhheaaafhdgdgphagfhdhcaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdheaaaaaaaaaaaaaaabacaaaffkaaakgphggfhcgmgpgbgegfgefkaabfhahcgpgdgfhdhdgjgoghecgbghepggfehfhagmgfhdfkaabehcgfhdhfgmhefdgjgoghgmgffehfhagmgfecgbghfkaaaehdhegbhcemaaahgdgpgmhfgngohdheaabfemgkgbhggbcphfhegjgmcpebhchcgbhjemgjhdhedlhihcaagcgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcoefhihahcgfhdhdgjgpgoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaadgmgpghheaacaemgphcghcpgbhagbgdgigfcpgdgpgngngpgohdcpgmgpghghgjgoghcpemgpghdlhihcaaemgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofagihjhdgjgdgbgmephagfhcgbhegphcaaaaaaaaaaaaaaabacaaamfkaaafgbgdgdhfgnfkaaangjgohahfheebhehegbgdgigfgeejaabehcgfhbhfgfhdhegfgefagbhcgbgmgmgfgmgjhdgnecaaakhcgfhdhfgmhefehjhagfemaaafgbgmgjgbhdhbaahoaaaoemaaafgjgohahfheheaablemgphcghcpgbhagbgdgigfcphagjghcpgegbhegbcpfehfhagmgfdlemaaaggjgohahfhehdhbaahoaaagemaaangmgjgogfgbghgffehcgbgdgfhcheaachemgphcghcpgbhagbgdgigfcphagjghcphagfgocphfhegjgmcpemgjgogfgbghgffehcgbgdgfhcdlemaaadgmgpghhbaahoaabeemaaahgphfhehahfhehdhbaahoaaagemaaakhagbhcgfgohefagmgbgoheaafaemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccphagmgbgohdcpfagihjhdgjgdgbgmfagmgbgodlemaaadhcgfhdheaaeeemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccpfcgfhdhfgmhedlhihcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaaegnelgfhjheaacgemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphagmgbgocpephagfhcgbhegphcelgfhjdlhihahbaahoaaapaaaappppppppdchahahahahdhcaaclgphcghcogbhagbgdgigfcogdgpgngngpgohdcogmgpghghgjgoghcogjgnhagmcoemgpghdeekemgpghghgfhccikmpnoicknfncdiacaaabemaaaegogbgngfhbaahoaaaohihaheaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdhehahahdhcaaecgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofcgfhdhfgmheaaaaaaaaaaaaaaabacaaacecaaamhcgfhehfhcgofdhegbhehfhdemaaaghcgfhdhfgmheheaabcemgkgbhggbcpgmgbgoghcpepgcgkgfgdhedlhihaachahbaahoaaboaaaaaaaahdhbaahoaaaaaaaaaaabhhaeaaaaaaabhdhcaabbgkgbhggbcogmgbgoghcoejgohegfghgfhcbcockakephibihdiacaaabejaaafhggbgmhfgfhihcaabagkgbhggbcogmgbgoghcoeohfgngcgfhcigkmjfbnaljeoailacaaaahihaaaaaaaaahihihdhbaahoaaaaaaaaaaabhhaeaaaaaaakhbaahoaabmhihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhbaahoaabmhbaahoaaaphihdhbaahoaaaaaaaaaaaahhaeaaaaaaakhihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahiaahi','','b','scope','true')) - scope-117
\ No newline at end of file
