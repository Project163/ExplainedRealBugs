diff --git a/CHANGES.txt b/CHANGES.txt
index bfc9a49b2..b17312f7f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -118,6 +118,9 @@ PIG-1696: Performance: Use System.arraycopy() instead of manually copying the by
 
 BUG FIXES
 
+PIG-1925: Parser error message doesn't show location of the error or show it
+as Line 0:0 (xuefuz via gates)
+
 PIG-671:  typechecker does not throw an error when multiple arguments are
 passed to COUNT (deepujain via gates)
 
diff --git a/src/org/apache/pig/parser/AliasMasker.g b/src/org/apache/pig/parser/AliasMasker.g
index 10a19d03d..46101065f 100644
--- a/src/org/apache/pig/parser/AliasMasker.g
+++ b/src/org/apache/pig/parser/AliasMasker.g
@@ -237,46 +237,23 @@ func_args
 ;
 
 group_clause
-scope {
-    int arity;
-}
-@init {
-    $group_clause::arity = 0;
-    int gt = HINT_REGULAR;
-    int num_inputs = 0;
-}
  : ^( ( GROUP { sb.append($GROUP.text).append(" "); } | COGROUP { sb.append($COGROUP.text).append(" "); } ) 
-      group_item { num_inputs++; } ( { sb.append(", "); } group_item { num_inputs++; } )* 
-      ( { sb.append(" USING "); } group_type { gt = $group_type.type; } )? 
+      group_item ( { sb.append(", "); } group_item )* 
+      ( { sb.append(" USING "); } group_type )? 
       partition_clause?
     )
-    {
-    	if( gt == HINT_COLLECTED ) {
-    	    if( num_inputs > 1 ) {
-                throw new ParserValidationException( input, "Collected group is only supported for single input" );
-    	   } 
-    	}
-    }
 ;
 
-group_type returns [int type]
-    : HINT_COLLECTED { $type = HINT_COLLECTED; sb.append($HINT_COLLECTED.text); } 
-    | HINT_MERGE  { $type = HINT_MERGE; sb.append($HINT_MERGE.text); } 
-    | HINT_REGULAR { $type = HINT_REGULAR; sb.append($HINT_REGULAR.text); } 
+group_type
+    : HINT_COLLECTED { sb.append($HINT_COLLECTED.text); } 
+    | HINT_MERGE  { sb.append($HINT_MERGE.text); } 
+    | HINT_REGULAR { sb.append($HINT_REGULAR.text); } 
 ;
 
 group_item
     : rel ( join_group_by_clause 
             | ALL { sb.append(" ").append($ALL.text); } | ANY { sb.append(" ").append($ANY.text); } ) 
             ( INNER { sb.append(" ").append($INNER.text); } | OUTER { sb.append(" ").append($OUTER.text); } )?
-   {
-       if( $group_clause::arity == 0 ) {
-           // For the first input
-           $group_clause::arity = $join_group_by_clause.exprCount;
-       } else if( $join_group_by_clause.exprCount != $group_clause::arity ) {
-           throw new ParserValidationException( input, "The arity of the group by columns do not match." );
-       }
-   }
 ;
 
 rel 
@@ -430,72 +407,32 @@ rel_list
 ;
 
 join_clause
-scope {
-    int arity;
-}
-@init {
-    $join_clause::arity = 0;
-    boolean partitionerPresent = false;
-    int jt = HINT_DEFAULT;
-}
-    : ^( JOIN { sb.append($JOIN.text).append(" "); } join_sub_clause ( { sb.append(" USING "); } join_type { jt = $join_type.type; } )? 
-    ( partition_clause { partitionerPresent = true; } )? )
-   {
-       if( jt == HINT_SKEWED ) {
-           if( partitionerPresent ) {
-               throw new ParserValidationException( input, "Custom Partitioner is not supported for skewed join" );
-           }
-           
-           if( $join_sub_clause.inputCount != 2 ) {
-               throw new ParserValidationException( input, "Skewed join can only be applied for 2-way joins" );
-           }
-       } else if( jt == HINT_MERGE && $join_sub_clause.inputCount != 2 ) {
-           throw new ParserValidationException( input, "Merge join can only be applied for 2-way joins" );
-       } else if( jt == HINT_REPL && $join_sub_clause.right ) {
-           throw new ParserValidationException( input, "Replicated join does not support (right|full) outer joins" );
-       }
-   }
-;
-
-join_type returns[int type]
-    : HINT_REPL  { $type = HINT_REPL; sb.append($HINT_REPL.text); }
-    | HINT_MERGE { $type = HINT_MERGE; sb.append($HINT_MERGE.text); }
-    | HINT_SKEWED { $type = HINT_SKEWED; sb.append($HINT_SKEWED.text); }
-    | HINT_DEFAULT { $type = HINT_DEFAULT; sb.append($HINT_DEFAULT.text); }
-;
-
-join_sub_clause returns[int inputCount, boolean right, boolean left]
-@init {
-    $inputCount = 0;
-}
- : join_item ( LEFT { $left = true; sb.append(" ").append($LEFT.text); }
-             | RIGHT { $right = true; sb.append(" ").append($RIGHT.text); }
-             | FULL { $left = true; $right = true; sb.append(" ").append($FULL.text); }
+    : ^( JOIN { sb.append($JOIN.text).append(" "); } join_sub_clause ( { sb.append(" USING "); } join_type )? 
+    ( partition_clause )? )
+;
+
+join_type
+    : HINT_REPL  { sb.append($HINT_REPL.text); }
+    | HINT_MERGE { sb.append($HINT_MERGE.text); }
+    | HINT_SKEWED { sb.append($HINT_SKEWED.text); }
+    | HINT_DEFAULT { sb.append($HINT_DEFAULT.text); }
+;
+
+join_sub_clause
+ : join_item ( LEFT { sb.append(" ").append($LEFT.text); }
+             | RIGHT { sb.append(" ").append($RIGHT.text); }
+             | FULL { sb.append(" ").append($FULL.text); }
              ) (OUTER { sb.append(" ").append($OUTER.text); } )? { sb.append(", "); } join_item
-   { 
-       $inputCount = 2;
-   }
- | join_item { $inputCount++; } ( { sb.append(", "); } join_item { $inputCount++; } )*
+ | join_item ( { sb.append(", "); } join_item )*
 ;
 
 join_item
  : ^( JOIN_ITEM rel join_group_by_clause )
-   {
-       if( $join_clause::arity == 0 ) {
-           // For the first input
-           $join_clause::arity = $join_group_by_clause.exprCount;
-       } else if( $join_group_by_clause.exprCount != $join_clause::arity ) {
-           throw new ParserValidationException( input, "The arity of the join columns do not match." );
-       }
-   }
-;
-
-join_group_by_clause returns[int exprCount]
-@init {
-    $exprCount = 0;
-}
+;
+
+join_group_by_clause
     : ^( BY { sb.append(" ").append($BY.text).append(" ("); } 
-    join_group_by_expr { $exprCount++; } ( { sb.append(", "); } join_group_by_expr { $exprCount++; } )* { sb.append(")"); } )
+    join_group_by_expr ( { sb.append(", "); } join_group_by_expr )* { sb.append(")"); } )
 ;
 
 join_group_by_expr 
@@ -516,8 +453,6 @@ foreach_plan
 ;
 
 nested_blk
-scope { Set<String> ids; }
-@init{ $nested_blk::ids = new HashSet<String>(); }
     : { sb.append(" { "); } (nested_command { sb.append("; "); } )* generate_clause { sb.append("; } "); }
 ;
 
@@ -528,13 +463,7 @@ generate_clause
 
 nested_command
     : ^( NESTED_CMD IDENTIFIER { sb.append($IDENTIFIER.text).append(" = "); } nested_op )
-    {
-        $nested_blk::ids.add( $IDENTIFIER.text );
-    }
     | ^( NESTED_CMD_ASSI IDENTIFIER { sb.append($IDENTIFIER.text).append(" = "); } expr )
-    {
-        $nested_blk::ids.add( $IDENTIFIER.text );
-    }
 ;
 
 nested_op : nested_proj
diff --git a/src/org/apache/pig/parser/AstValidator.g b/src/org/apache/pig/parser/AstValidator.g
index 06c9ad903..2adf22b04 100644
--- a/src/org/apache/pig/parser/AstValidator.g
+++ b/src/org/apache/pig/parser/AstValidator.g
@@ -71,19 +71,26 @@ public String getErrorMessage(RecognitionException e, String[] tokenNames) {
     return msg;
 }
 
-private void validateSchemaAliasName(Set<String> fieldNames, String name)
+@Override
+public String getErrorHeader(RecognitionException ex) {
+	return QueryParserUtils.generateErrorHeader( ex );
+}
+
+private void validateSchemaAliasName(Set<String> fieldNames, Token t)
 throws DuplicatedSchemaAliasException {
+    String name = t.getText();
     if( fieldNames.contains( name ) ) {
-        throw new DuplicatedSchemaAliasException( input, name );
+        throw new DuplicatedSchemaAliasException( input, t, name );
     } else {
         fieldNames.add( name );
     }
 }
 
-private void validateAliasRef(Set<String> aliases, String alias)
+private void validateAliasRef(Set<String> aliases, Token t)
 throws UndefinedAliasException {
+    String alias = t.getText();
     if( !aliases.contains( alias ) ) {
-        throw new UndefinedAliasException( input, alias );
+        throw new UndefinedAliasException( input, t, alias );
     }
 }
 
@@ -113,7 +120,12 @@ general_statement : ^( STATEMENT ( alias { aliases.add( $alias.name ); } )? op_c
 parallel_clause : ^( PARALLEL INTEGER )
 ;
 
-alias returns[String name] : IDENTIFIER { $name = $IDENTIFIER.text; }
+alias returns[String name, Token token]
+ : IDENTIFIER
+   { 
+       $name = $IDENTIFIER.text;
+       $token = $IDENTIFIER.token;
+   }
 ;
 
 op_clause : define_clause 
@@ -173,7 +185,7 @@ as_clause: ^( AS field_def_list )
 ;
 
 field_def[Set<String> fieldNames] throws Exception
- : ^( FIELD_DEF IDENTIFIER { validateSchemaAliasName( fieldNames, $IDENTIFIER.text ); } type? )
+ : ^( FIELD_DEF IDENTIFIER { validateSchemaAliasName( fieldNames, $IDENTIFIER.token ); } type? )
 ;
 
 field_def_list
@@ -228,7 +240,8 @@ scope {
     {
         if( gt == HINT_COLLECTED ) {
             if( num_inputs > 1 ) {
-                throw new ParserValidationException( input, "Collected group is only supported for single input" );
+                throw new ParserValidationException( input, new SourceLocation( (CommonTree)$group_type.start ),
+                    "Collected group is only supported for single input" );
            } 
         }
     }
@@ -247,12 +260,13 @@ group_item
            // For the first input
            $group_clause::arity = $join_group_by_clause.exprCount;
        } else if( $join_group_by_clause.exprCount != $group_clause::arity ) {
-           throw new ParserValidationException( input, "The arity of the group by columns do not match." );
+           throw new ParserValidationException( input, new SourceLocation( (CommonTree)$group_item.start ),
+               "The arity of the group by columns do not match." );
        }
    }
 ;
 
-rel : alias {  validateAliasRef( aliases, $alias.name ); }
+rel : alias {  validateAliasRef( aliases, $alias.token ); }
     | op_clause
 ;
 
@@ -371,17 +385,24 @@ scope {
  : ^( JOIN join_sub_clause ( join_type { jt = $join_type.type; } )? ( partition_clause { partitionerPresent = true; } )? )
    {
        if( jt == HINT_SKEWED ) {
+           SourceLocation loc = new SourceLocation( (CommonTree)$join_type.start );
            if( partitionerPresent ) {
-               throw new ParserValidationException( input, "Custom Partitioner is not supported for skewed join" );
+               throw new ParserValidationException( input, loc, 
+                   "Custom Partitioner is not supported for skewed join" );
            }
            
            if( $join_sub_clause.inputCount != 2 ) {
-               throw new ParserValidationException( input, "Skewed join can only be applied for 2-way joins" );
+               throw new ParserValidationException( input, loc,
+                   "Skewed join can only be applied for 2-way joins" );
            }
        } else if( jt == HINT_MERGE && $join_sub_clause.inputCount != 2 ) {
-           throw new ParserValidationException( input, "Merge join can only be applied for 2-way joins" );
+           SourceLocation loc = new SourceLocation( (CommonTree)$join_type.start );
+           throw new ParserValidationException( input, loc,
+               "Merge join can only be applied for 2-way joins" );
        } else if( jt == HINT_REPL && $join_sub_clause.right ) {
-           throw new ParserValidationException( input, "Replicated join does not support (right|full) outer joins" );
+           SourceLocation loc = new SourceLocation( (CommonTree)$join_type.start );
+           throw new ParserValidationException( input, loc,
+               "Replicated join does not support (right|full) outer joins" );
        }
    }
 ;
@@ -414,7 +435,8 @@ join_item
            // For the first input
            $join_clause::arity = $join_group_by_clause.exprCount;
        } else if( $join_group_by_clause.exprCount != $join_clause::arity ) {
-           throw new ParserValidationException( input, "The arity of the join columns do not match." );
+           throw new ParserValidationException( input, new SourceLocation( (CommonTree)$join_item.start ),
+               "The arity of the join columns do not match." );
        }
    }
 ;
diff --git a/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java b/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java
index e97ef43a0..f1c1cb878 100644
--- a/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java
+++ b/src/org/apache/pig/parser/DuplicatedSchemaAliasException.java
@@ -19,20 +19,20 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.Token;
 
-public class DuplicatedSchemaAliasException extends RecognitionException {
+public class DuplicatedSchemaAliasException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private String alias;
     
-    public DuplicatedSchemaAliasException(IntStream input, String alias) {
-        super( input );
+    public DuplicatedSchemaAliasException(IntStream input, Token t, String alias) {
+        super( input, new SourceLocation( t ) );
         this.alias = alias;
     }
     
     public String toString() {
-        return "Duplicated alias in schema: " + alias;
+        return msgHeader() + "Duplicated alias in schema: " + alias;
     }
 
     public String getAlias() {
diff --git a/src/org/apache/pig/parser/InvalidCommandException.java b/src/org/apache/pig/parser/InvalidCommandException.java
index 057acf458..609ea6056 100644
--- a/src/org/apache/pig/parser/InvalidCommandException.java
+++ b/src/org/apache/pig/parser/InvalidCommandException.java
@@ -19,20 +19,19 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
 
-public class InvalidCommandException extends RecognitionException {
+public class InvalidCommandException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private String cmd;
     
-    public InvalidCommandException(IntStream input, String cmd) {
-        super( input );
+    public InvalidCommandException(IntStream input, SourceLocation loc, String cmd) {
+        super( input, loc );
         this.cmd = cmd;
     }
     
     public String toString() {
-        return "Ill-formed command line: " + cmd;
+        return msgHeader() + "Ill-formed command line: " + cmd;
     }
 
     public String getCmd() {
diff --git a/src/org/apache/pig/parser/InvalidPathException.java b/src/org/apache/pig/parser/InvalidPathException.java
index 3eece3049..a8fda64b3 100644
--- a/src/org/apache/pig/parser/InvalidPathException.java
+++ b/src/org/apache/pig/parser/InvalidPathException.java
@@ -21,20 +21,19 @@ package org.apache.pig.parser;
 import java.net.MalformedURLException;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
 
-public class InvalidPathException extends RecognitionException {
+public class InvalidPathException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private MalformedURLException ex;
     
-    public InvalidPathException(IntStream input, MalformedURLException ex) {
-        super( input );
+    public InvalidPathException(IntStream input, SourceLocation loc, MalformedURLException ex) {
+        super( input, loc );
         this.ex = ex;
     }
     
     public String toString() {
-        return "Malformed URL for JAR path in the command line: " + ex;
+        return msgHeader() + "Malformed URL for JAR path in the command line: " + ex;
     }
 
     public MalformedURLException getEx() {
diff --git a/src/org/apache/pig/parser/InvalidScalarProjectionException.java b/src/org/apache/pig/parser/InvalidScalarProjectionException.java
index bed906048..28bf9707b 100644
--- a/src/org/apache/pig/parser/InvalidScalarProjectionException.java
+++ b/src/org/apache/pig/parser/InvalidScalarProjectionException.java
@@ -19,22 +19,21 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
 import org.apache.pig.newplan.logical.expression.ScalarExpression;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 
-public class InvalidScalarProjectionException extends RecognitionException {
+public class InvalidScalarProjectionException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private ScalarExpression scalarExpr;
     
-    public InvalidScalarProjectionException(IntStream input, ScalarExpression expr) {
-        super( input );
+    public InvalidScalarProjectionException(IntStream input, SourceLocation loc, ScalarExpression expr) {
+        super( input, loc );
         this.scalarExpr = expr;
     }
     
     public String toString() {
-        return "Invalid scalar projection: " + 
+        return msgHeader() + "Invalid scalar projection: " + 
             ((LogicalRelationalOperator)scalarExpr.getImplicitReferencedOperator()).getAlias();
     }
 
diff --git a/src/org/apache/pig/parser/LogicalPlanBuilder.java b/src/org/apache/pig/parser/LogicalPlanBuilder.java
index ae24d7b60..c423dd8e8 100644
--- a/src/org/apache/pig/parser/LogicalPlanBuilder.java
+++ b/src/org/apache/pig/parser/LogicalPlanBuilder.java
@@ -201,7 +201,7 @@ public class LogicalPlanBuilder {
         return new LOSort( plan );
     }
     
-    String buildSortOp(LOSort sort, String alias, String inputAlias, List<LogicalExpressionPlan> plans, 
+    String buildSortOp(SourceLocation loc, LOSort sort, String alias, String inputAlias, List<LogicalExpressionPlan> plans, 
             List<Boolean> ascFlags, FuncSpec fs) throws ParserValidationException {
         sort.setSortColPlans( plans );
         sort.setUserFunc( fs );
@@ -214,7 +214,7 @@ public class LogicalPlanBuilder {
         try {
             (new ProjectStarExpander(sort.getPlan())).visit(sort);
         } catch (FrontendException e) {
-            throw new ParserValidationException(intStream, e);
+            throw new ParserValidationException( intStream, loc, e );
         }
         return alias;
     }
@@ -223,7 +223,7 @@ public class LogicalPlanBuilder {
         return new LOJoin( plan );
     }
 
-    String buildJoinOp(LOJoin op, String alias, List<String> inputAliases,
+    String buildJoinOp(SourceLocation loc, LOJoin op, String alias, List<String> inputAliases,
             MultiMap<Integer, LogicalExpressionPlan> joinPlans,
             JOINTYPE jt, List<Boolean> innerFlags, String partitioner)
     throws ParserValidationException {
@@ -250,7 +250,7 @@ public class LogicalPlanBuilder {
         try {
             (new ProjectStarExpander(op.getPlan())).visit(op);
         } catch (FrontendException e) {
-            throw new ParserValidationException(intStream, e);
+            throw new ParserValidationException( intStream, loc, e );
         }
         return alias;
     }
@@ -259,7 +259,7 @@ public class LogicalPlanBuilder {
         return new LOCogroup( plan );
     }
     
-    String buildGroupOp(LOCogroup op, String alias, List<String> inputAliases, 
+    String buildGroupOp(SourceLocation loc, LOCogroup op, String alias, List<String> inputAliases, 
         MultiMap<Integer, LogicalExpressionPlan> expressionPlans, GROUPTYPE gt, List<Boolean> innerFlags,
         String partitioner) throws ParserValidationException {
         if( gt == GROUPTYPE.COLLECTED ) {
@@ -268,7 +268,8 @@ public class LogicalPlanBuilder {
                 Iterator<Operator> it = exprPlan.getOperators();
                 while( it.hasNext() ) {
                     if( !( it.next() instanceof ProjectExpression ) ) {
-                        throw new ParserValidationException( intStream, "Collected group is only supported for columns or star projection" );
+                        throw new ParserValidationException( intStream, loc,
+                        		"Collected group is only supported for columns or star projection" );
                     }
                 }
             }
@@ -285,7 +286,7 @@ public class LogicalPlanBuilder {
         try {
             (new ProjectStarExpander(op.getPlan())).visit(op);
         } catch (FrontendException e) {
-            throw new ParserValidationException(intStream, e);
+            throw new ParserValidationException( intStream, loc, e );
         }
         return alias;
     }
@@ -311,13 +312,13 @@ public class LogicalPlanBuilder {
         return absolutePath;
     }
      
-    String buildLoadOp(String alias, String filename, FuncSpec funcSpec, LogicalSchema schema)
+    String buildLoadOp(SourceLocation loc, String alias, String filename, FuncSpec funcSpec, LogicalSchema schema)
     throws ParserValidationException {
         String absolutePath = filename;
         try {
             absolutePath = getAbolutePathForLoad( filename, funcSpec );
         } catch(Exception ex) {
-            throw new ParserValidationException( intStream, ex );
+            throw new ParserValidationException( intStream, loc, ex );
         }
         
         FileSpec loader = new FileSpec( absolutePath, funcSpec );
@@ -367,13 +368,13 @@ public class LogicalPlanBuilder {
         return absolutePath;
     }
 
-    String buildStoreOp(String alias, String inputAlias, String filename, FuncSpec funcSpec)
+    String buildStoreOp(SourceLocation loc, String alias, String inputAlias, String filename, FuncSpec funcSpec)
     throws ParserValidationException {
         String absPath = filename;
         try {
             absPath = getAbolutePathForStore( inputAlias, filename, funcSpec );
         } catch(Exception ex) {
-            throw new ParserValidationException( intStream, ex );
+            throw new ParserValidationException( intStream, loc, ex );
         }
         
         FileSpec fileSpec = new FileSpec( absPath, funcSpec );
@@ -385,14 +386,14 @@ public class LogicalPlanBuilder {
         return new LOForEach( plan );
     }
     
-    String buildForeachOp(LOForEach op, String alias, String inputAlias, LogicalPlan innerPlan)
+    String buildForeachOp(SourceLocation loc, LOForEach op, String alias, String inputAlias, LogicalPlan innerPlan)
     throws ParserValidationException {
         op.setInnerPlan( innerPlan );
         alias = buildOp( op, alias, inputAlias, null );
         try {
             (new ProjectStarExpander(op.getPlan())).visit(op);
         } catch (FrontendException e) {
-            throw new ParserValidationException(intStream, e);
+            throw new ParserValidationException( intStream, loc, e );
         }
         return alias;
     }
@@ -482,13 +483,13 @@ public class LogicalPlanBuilder {
         }
     }
     
-    Operator buildNestedOperatorInput(LogicalPlan innerPlan, LOForEach foreach, 
+    Operator buildNestedOperatorInput(SourceLocation loc, LogicalPlan innerPlan, LOForEach foreach, 
             Map<String, Operator> operators, LogicalExpression expr)
     throws NonProjectExpressionException {
         OperatorPlan plan = expr.getPlan();
         Iterator<Operator> it = plan.getOperators();
         if( !( it.next() instanceof ProjectExpression ) || it.hasNext() ) {
-            throw new NonProjectExpressionException( intStream, expr );
+            throw new NonProjectExpressionException( intStream, loc, expr );
         }
         Operator op = null;
         ProjectExpression projExpr = (ProjectExpression)expr;
@@ -506,12 +507,12 @@ public class LogicalPlanBuilder {
         return op;
     }
     
-    StreamingCommand buildCommand(String cmd, List<String> shipPaths, List<String> cachePaths,
+    StreamingCommand buildCommand(SourceLocation loc, String cmd, List<String> shipPaths, List<String> cachePaths,
             List<HandleSpec> inputHandleSpecs, List<HandleSpec> outputHandleSpecs,
             String logDir, Integer limit) throws RecognitionException {
         StreamingCommand command = null;
         try {
-            command = buildCommand( cmd );
+            command = buildCommand( loc, cmd );
             
             // Process ship paths
             if( shipPaths != null ) {
@@ -547,13 +548,13 @@ public class LogicalPlanBuilder {
             if( limit != null )
                 command.setLogFilesLimit( limit );
         } catch(IOException e) {
-            throw new PlanGenerationFailureException( intStream, e );
+            throw new PlanGenerationFailureException( intStream, loc, e );
         }
         
         return command;
     }
     
-    StreamingCommand buildCommand(String cmd) throws RecognitionException {
+    StreamingCommand buildCommand(SourceLocation loc, String cmd) throws RecognitionException {
         try {
             String[] args = StreamingCommandUtils.splitArgs( cmd );
             StreamingCommand command = new StreamingCommand( pigContext, args );
@@ -561,22 +562,22 @@ public class LogicalPlanBuilder {
             validator.checkAutoShipSpecs( command, args );
             return command;
         } catch (ParseException e) {
-            throw new InvalidCommandException( intStream, cmd );
+            throw new InvalidCommandException( intStream, loc, cmd );
         }
     }
     
-    String buildStreamOp(String alias, String inputAlias, StreamingCommand command,
+    String buildStreamOp(SourceLocation loc, String alias, String inputAlias, StreamingCommand command,
             LogicalSchema schema, IntStream input)
     throws RecognitionException {
         try {
             LOStream op = new LOStream( plan, pigContext.createExecutableManager(), command, schema );
             return buildOp( op, alias, inputAlias, null );
         } catch (ExecException ex) {
-            throw new PlanGenerationFailureException( input, ex );
+            throw new PlanGenerationFailureException( input, loc, ex );
         }
     }
     
-    String buildNativeOp(String inputJar, String cmd,
+    String buildNativeOp(SourceLocation loc, String inputJar, String cmd,
             List<String> paths, String storeAlias, String loadAlias, IntStream input)
     throws RecognitionException {
         LONative op;
@@ -592,9 +593,9 @@ public class LogicalPlanBuilder {
             plan.connect( op, load );
             return load.getAlias();
         } catch (ParseException e) {
-            throw new InvalidCommandException( input, cmd );
+            throw new InvalidCommandException( input, loc, cmd );
         } catch (MalformedURLException e) {
-            throw new InvalidPathException( input, e);
+            throw new InvalidPathException( input, loc, e);
         }
     }
     
@@ -615,14 +616,14 @@ public class LogicalPlanBuilder {
             op.setCustomPartitioner( partitioner );
     }
     
-    FuncSpec buildFuncSpec(String funcName, List<String> args, byte ft) throws RecognitionException {
+    FuncSpec buildFuncSpec(SourceLocation loc, String funcName, List<String> args, byte ft) throws RecognitionException {
         String[] argArray = new String[args.size()];
         FuncSpec funcSpec = new FuncSpec( funcName, args.size() == 0 ? null : args.toArray( argArray ) );
-        validateFuncSpec( funcSpec, ft );
+        validateFuncSpec( loc, funcSpec, ft );
         return funcSpec;
     }
     
-    private void validateFuncSpec(FuncSpec funcSpec, byte ft) throws RecognitionException {
+    private void validateFuncSpec(SourceLocation loc, FuncSpec funcSpec, byte ft) throws RecognitionException {
         switch( ft ) {
         case FunctionType.COMPARISONFUNC:
         case FunctionType.LOADFUNC:
@@ -633,7 +634,7 @@ public class LogicalPlanBuilder {
             try{
                 FunctionType.tryCasting( func, ft );
             } catch(Exception ex){
-                throw new ParserValidationException( intStream, ex );
+                throw new ParserValidationException( intStream, loc, ex );
             }
         }
     }
@@ -670,7 +671,7 @@ public class LogicalPlanBuilder {
      *  we will return whatever the expression alias represents.
      * @throws RecognitionException 
      */
-    LogicalExpression buildProjectExpr(LogicalExpressionPlan plan, LogicalRelationalOperator op,
+    LogicalExpression buildProjectExpr(SourceLocation loc, LogicalExpressionPlan plan, LogicalRelationalOperator op,
             Map<String, LogicalExpressionPlan> exprPlans, String colAlias, int col)
     throws RecognitionException {
         if( colAlias != null ) {
@@ -681,7 +682,7 @@ public class LogicalPlanBuilder {
                     planCopy = exprPlan.deepCopy();
                     plan.merge( planCopy );
                 } catch (FrontendException ex) {
-                    throw new PlanGenerationFailureException( intStream, ex );
+                    throw new PlanGenerationFailureException( intStream, loc, ex );
                 }
                 // The projected alias is actually expression alias, so the projections in the represented
                 // expression doesn't have any operator associated with it. We need to set it when we 
@@ -714,17 +715,16 @@ public class LogicalPlanBuilder {
         return new ProjectExpression( plan, input, col, relOp );
     }
     
-    LogicalExpression buildUDF(LogicalExpressionPlan plan, String funcName, List<LogicalExpression> args)
+    LogicalExpression buildUDF(SourceLocation loc, LogicalExpressionPlan plan, String funcName, List<LogicalExpression> args)
     throws RecognitionException {
         Object func;
         try {
             func = pigContext.instantiateFuncFromAlias( funcName );
             FunctionType.tryCasting( func, FunctionType.EVALFUNC );
         } catch (Exception e) {
-            throw new PlanGenerationFailureException( intStream, e );
+            throw new PlanGenerationFailureException( intStream, loc, e );
         }
         
-        
         FuncSpec funcSpec = pigContext.getFuncSpecFromAlias( funcName );
         if( funcSpec == null ) {
             funcName = func.getClass().getName();
diff --git a/src/org/apache/pig/parser/LogicalPlanGenerator.g b/src/org/apache/pig/parser/LogicalPlanGenerator.g
index 504730e86..c98bc53ea 100644
--- a/src/org/apache/pig/parser/LogicalPlanGenerator.g
+++ b/src/org/apache/pig/parser/LogicalPlanGenerator.g
@@ -147,6 +147,11 @@ public String getErrorMessage(RecognitionException e, String[] tokenNames) {
     return msg;
 }
 
+@Override
+public String getErrorHeader(RecognitionException ex) {
+	return QueryParserUtils.generateErrorHeader( ex );
+}
+
 } // End of @members
 
 @rulecatch {
@@ -227,10 +232,11 @@ cmd[String alias] returns[StreamingCommand command]
 @init {
     List<String> shipPaths = new ArrayList<String>();
     List<String> cachePaths = new ArrayList<String>();
+    SourceLocation loc = new SourceLocation( (CommonTree)$cmd.start );
 }
  : ^( EXECCOMMAND ( ship_clause[shipPaths] | cache_caluse[cachePaths] | input_clause | output_clause | error_clause )* )
    {
-       $command = builder.buildCommand( builder.unquote( $EXECCOMMAND.text ), shipPaths,
+       $command = builder.buildCommand( loc, builder.unquote( $EXECCOMMAND.text ), shipPaths,
            cachePaths, $input_clause.inputHandleSpecs, $output_clause.outputHandleSpecs,
            $error_clause.dir == null? $alias : $error_clause.dir, $error_clause.limit );
    }
@@ -303,7 +309,8 @@ error_clause returns[String dir, Integer limit]
 load_clause returns[String alias]
  : ^( LOAD filename func_clause[FunctionType.LOADFUNC]? as_clause? )
   {
-      $alias = builder.buildLoadOp( $statement::alias,
+      SourceLocation loc = new SourceLocation( (CommonTree)$load_clause.start );
+      $alias = builder.buildLoadOp( loc, $statement::alias,
           $filename.filename, $func_clause.funcSpec, $as_clause.logicalSchema  );
   }
 ;
@@ -410,11 +417,14 @@ map_type returns[LogicalSchema logicalSchema]
 ;
 
 func_clause[byte ft] returns[FuncSpec funcSpec]
+@init {
+    SourceLocation loc = new SourceLocation( (CommonTree)$func_clause.start );
+}
  : ^( FUNC_REF func_name )
    {
        $funcSpec = builder.lookupFunction( $func_name.funcName );
        if( $funcSpec == null )
-           $funcSpec = builder.buildFuncSpec( $func_name.funcName, new ArrayList<String>(), $ft );
+           $funcSpec = builder.buildFuncSpec( loc, $func_name.funcName, new ArrayList<String>(), $ft );
    }
  | ^( FUNC func_name func_args? )
    {
@@ -423,7 +433,7 @@ func_clause[byte ft] returns[FuncSpec funcSpec]
            List<String> argList = new ArrayList<String>();
            if( $func_args.args != null )
                argList = $func_args.args;
-           $funcSpec = builder.buildFuncSpec( $func_name.funcName, argList, $ft );
+           $funcSpec = builder.buildFuncSpec( loc, $func_name.funcName, argList, $ft );
        }
    }
 ;
@@ -457,16 +467,17 @@ scope GScope;
     $group_clause::inputAliases = new ArrayList<String>();
     $group_clause::innerFlags = new ArrayList<Boolean>();
     GROUPTYPE groupType = GROUPTYPE.REGULAR;
+    SourceLocation loc = new SourceLocation( (CommonTree)$group_clause.start );
 }
  : ^( GROUP group_item+ ( group_type { groupType = $group_type.type; ((LOCogroup)$GScope::currentOp).pinOption(LOCogroup.OPTION_GROUPTYPE); } )? partition_clause? )
    {
-       $alias = builder.buildGroupOp( (LOCogroup)$GScope::currentOp, $statement::alias, 
+       $alias = builder.buildGroupOp( loc, (LOCogroup)$GScope::currentOp, $statement::alias, 
            $group_clause::inputAliases, $group_clause::groupPlans, groupType, $group_clause::innerFlags,
            $partition_clause.partitioner );
    }
  | ^( COGROUP group_item+ ( group_type { groupType = $group_type.type;((LOCogroup)$GScope::currentOp).pinOption(LOCogroup.OPTION_GROUPTYPE); } )? partition_clause? )
    {
-       $alias = builder.buildGroupOp( (LOCogroup)$GScope::currentOp, $statement::alias, 
+       $alias = builder.buildGroupOp( loc, (LOCogroup)$GScope::currentOp, $statement::alias, 
            $group_clause::inputAliases, $group_clause::groupPlans, groupType, $group_clause::innerFlags,
            $partition_clause.partitioner );
    }
@@ -552,7 +563,8 @@ flatten_clause[LogicalExpressionPlan plan]
 store_clause returns[String alias]
  : ^( STORE rel filename func_clause[FunctionType.STOREFUNC]? )
    {
-       $alias= builder.buildStoreOp( $statement::alias,
+       SourceLocation loc = new SourceLocation( $STORE.token );
+       $alias= builder.buildStoreOp( loc, $statement::alias,
           $statement::inputAlias, $filename.filename, $func_clause.funcSpec );
    }
 ;
@@ -629,7 +641,8 @@ func_eval[LogicalExpressionPlan plan] returns[LogicalExpression expr]
 }
  : ^( FUNC_EVAL func_name ( real_arg[$plan] { args.add( $real_arg.expr ); } )* )
    {
-       $expr = builder.buildUDF( $plan, $func_name.funcName, args );
+       SourceLocation loc = new SourceLocation( (CommonTree)$func_eval.start );
+       $expr = builder.buildUDF( loc, $plan, $func_name.funcName, args );
    }
 ;
 
@@ -723,6 +736,7 @@ bag_type_cast returns[LogicalSchema logicalSchema]
 var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
 @init {
     List<Object> columns = null;
+    SourceLocation loc = new SourceLocation( (CommonTree)$var_expr.start );
 }
  : projectable_expr[$plan] { $expr = $projectable_expr.expr; }
    ( dot_proj 
@@ -732,7 +746,7 @@ var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
              // This is a scalar projection.
              ScalarExpression scalarExpr = (ScalarExpression)$expr;
              if( $dot_proj.cols.size() > 1 ) {
-                 throw new InvalidScalarProjectionException( input, scalarExpr );
+                 throw new InvalidScalarProjectionException( input, loc, scalarExpr );
              } else {
                  Object val = $dot_proj.cols.get( 0 );
                  int pos = -1;
@@ -741,18 +755,18 @@ var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
                  try {
                      schema = relOp.getSchema();
                  } catch(FrontendException e) {
-                     throw new PlanGenerationFailureException( input, e );
+                     throw new PlanGenerationFailureException( input, loc, e );
                  }
                  if( val instanceof Integer ) {
                      pos = (Integer)val;
                      if( schema != null && pos >= schema.size() ) {
-                         throw new InvalidScalarProjectionException( input, scalarExpr );
+                         throw new InvalidScalarProjectionException( input, loc, scalarExpr );
                      }
                  } else {
                      String colAlias = (String)val;
                      pos = schema.getFieldPosition( colAlias );
                      if( schema == null || pos == -1 ) {
-                         throw new InvalidScalarProjectionException( input, scalarExpr );
+                         throw new InvalidScalarProjectionException( input, loc, scalarExpr );
                      }
                  }
                  ConstantExpression constExpr = new ConstantExpression( $plan, pos);
@@ -776,7 +790,7 @@ var_expr[LogicalExpressionPlan plan] returns[LogicalExpression expr]
   )*
   {
       if( ( $expr instanceof ScalarExpression ) && columns == null ) {
-          throw new InvalidScalarProjectionException( input, (ScalarExpression)$expr );
+          throw new InvalidScalarProjectionException( input, loc, (ScalarExpression)$expr );
       }
   }
 ;
@@ -868,7 +882,8 @@ scope GScope;
 }
  : ^( ORDER rel order_by_clause func_clause[FunctionType.COMPARISONFUNC]? )
    {
-       $alias = builder.buildSortOp( (LOSort)$GScope::currentOp, $statement::alias,
+       SourceLocation loc = new SourceLocation( $ORDER.token );
+       $alias = builder.buildSortOp( loc, (LOSort)$GScope::currentOp, $statement::alias,
            $statement::inputAlias, $order_by_clause.plans, 
            $order_by_clause.ascFlags, $func_clause.funcSpec );
    }
@@ -944,7 +959,8 @@ scope GScope;
 }
  : ^( JOIN join_sub_clause join_type? partition_clause? )
    {
-       $alias = builder.buildJoinOp( (LOJoin)$GScope::currentOp, $statement::alias,
+       SourceLocation loc = new SourceLocation( $JOIN.token );
+       $alias = builder.buildJoinOp( loc, (LOJoin)$GScope::currentOp, $statement::alias,
           $join_clause::inputAliases, $join_clause::joinPlans,
           $join_type.type, $join_clause::innerFlags, $partition_clause.partitioner );
    }
@@ -1018,7 +1034,8 @@ scope GScope;
 }
  : ^( FOREACH rel foreach_plan )
    {
-       $alias = builder.buildForeachOp( $foreach_clause::foreachOp, $statement::alias,
+       SourceLocation loc = new SourceLocation( $FOREACH.token );
+       $alias = builder.buildForeachOp( loc, $foreach_clause::foreachOp, $statement::alias,
           $statement::inputAlias, $foreach_plan.plan );
    }
 ;
@@ -1165,7 +1182,8 @@ nested_op_input returns[Operator op]
 }
  : col_ref[plan]
    {
-       $op = builder.buildNestedOperatorInput( $foreach_plan::innerPlan,
+       SourceLocation loc = new SourceLocation( (CommonTree)$col_ref.start );
+       $op = builder.buildNestedOperatorInput( loc, $foreach_plan::innerPlan,
            $foreach_clause::foreachOp, $foreach_plan::operators, $col_ref.expr );
    }
  | nested_proj[null]
@@ -1177,19 +1195,21 @@ nested_op_input returns[Operator op]
 stream_clause returns[String alias]
 @init {
     StreamingCommand cmd = null;
+    SourceLocation loc = new SourceLocation( (CommonTree)$stream_clause.start );
 }
- : ^( STREAM rel ( EXECCOMMAND { cmd = builder.buildCommand( builder.unquote( $EXECCOMMAND.text ) ); } 
+ : ^( STREAM rel ( EXECCOMMAND { cmd = builder.buildCommand( loc, builder.unquote( $EXECCOMMAND.text ) ); } 
                  | IDENTIFIER 
                    { 
                        cmd = builder.lookupCommand( $IDENTIFIER.text );
                        if( cmd == null ) {
                            String msg = "Undefined command-alias [" + $IDENTIFIER.text + "]";
-                           throw new ParserValidationException( input, msg );
+                           throw new ParserValidationException( input, 
+                               new SourceLocation( $IDENTIFIER.token ), msg );
                        }
                    }
                  ) as_clause? )
    {
-       $alias = builder.buildStreamOp( $statement::alias,
+       $alias = builder.buildStreamOp( loc, $statement::alias,
           $statement::inputAlias, cmd, $as_clause.logicalSchema, input );
    }
 ;
@@ -1198,13 +1218,14 @@ mr_clause returns[String alias]
 @init {
     List<String> paths = new ArrayList<String>();
     String alias = $statement::alias;
+    SourceLocation loc = new SourceLocation( (CommonTree)$mr_clause.start );
 }
  : ^( MAPREDUCE QUOTEDSTRING path_list[paths]? 
      { $statement::alias = null; } store_clause 
      { $statement::alias = alias; } load_clause
      EXECCOMMAND? )
    {
-       $alias = builder.buildNativeOp(
+       $alias = builder.buildNativeOp( loc,
            builder.unquote( $QUOTEDSTRING.text ), builder.unquote( $EXECCOMMAND.text ), 
            paths, $store_clause.alias, $load_clause.alias, input );
    }
@@ -1241,13 +1262,14 @@ alias_col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
    }
  | scoped_alias_col_ref
    {
+       SourceLocation loc = new SourceLocation( (CommonTree)$scoped_alias_col_ref.start );
        String alias = $scoped_alias_col_ref.alias;
        Operator inOp = builder.lookupOperator( $statement::inputAlias );
        LogicalSchema schema;
        try {
            schema = ((LogicalRelationalOperator)inOp).getSchema();
        } catch (FrontendException e) {
-           throw new PlanGenerationFailureException( input, e );
+           throw new PlanGenerationFailureException( input, loc, e );
        }
        
        Operator op = builder.lookupOperator( alias );
@@ -1256,7 +1278,7 @@ alias_col_ref[LogicalExpressionPlan plan] returns[LogicalExpression expr]
                inForeachPlan ? $foreach_clause::foreachOp : $GScope::currentOp );
        } else {
            if( inForeachPlan ) {
-               $expr = builder.buildProjectExpr( $plan, $GScope::currentOp, 
+               $expr = builder.buildProjectExpr( loc, $plan, $GScope::currentOp, 
                    $foreach_plan::exprPlans, alias, 0 );
            } else {
                $expr = builder.buildProjectExpr( $plan, $GScope::currentOp, 
diff --git a/src/org/apache/pig/parser/NonProjectExpressionException.java b/src/org/apache/pig/parser/NonProjectExpressionException.java
index d88504ad5..40eff83a9 100644
--- a/src/org/apache/pig/parser/NonProjectExpressionException.java
+++ b/src/org/apache/pig/parser/NonProjectExpressionException.java
@@ -19,21 +19,20 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
 import org.apache.pig.newplan.logical.expression.LogicalExpression;
 
-public class NonProjectExpressionException extends RecognitionException {
+public class NonProjectExpressionException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private LogicalExpression expr;
     
-    public NonProjectExpressionException(IntStream input, LogicalExpression expr) {
-        super( input );
+    public NonProjectExpressionException(IntStream input, SourceLocation loc, LogicalExpression expr) {
+        super( input, loc );
         this.expr = expr;
     }
     
     public String toString() {
-        return "Expression is not a project expression: " + expr;
+        return msgHeader() + "expression is not a project expression: " + expr;
     }
 
     public LogicalExpression getExpression() {
diff --git a/src/org/apache/pig/parser/ParserValidationException.java b/src/org/apache/pig/parser/ParserValidationException.java
index 70ea78479..6bbfa2f50 100644
--- a/src/org/apache/pig/parser/ParserValidationException.java
+++ b/src/org/apache/pig/parser/ParserValidationException.java
@@ -19,27 +19,26 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
 
-public class ParserValidationException extends RecognitionException {
+public class ParserValidationException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private String cause;
     
     private Exception ex;
     
-    public ParserValidationException(IntStream input, String cause) {
-        super( input );
+    public ParserValidationException(IntStream input, SourceLocation loc, String cause) {
+        super( input, loc );
         this.cause = cause;
     }
     
-    public ParserValidationException(IntStream input, Exception ex) {
-        super( input );
+    public ParserValidationException(IntStream input, SourceLocation loc, Exception ex) {
+        super( input, loc );
         this.ex = ex;
     }
     
     public String toString() {
-        return "Pig script failed to validate: " + ( ex != null ? ex.toString() : cause  );
+        return msgHeader() + "pig script failed to validate: " + ( ex != null ? ex.toString() : cause  );
     }
 
 }
diff --git a/src/org/apache/pig/parser/PigRecognitionException.java b/src/org/apache/pig/parser/PigRecognitionException.java
new file mode 100644
index 000000000..36b05e7f7
--- /dev/null
+++ b/src/org/apache/pig/parser/PigRecognitionException.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.parser;
+
+import org.antlr.runtime.IntStream;
+import org.antlr.runtime.RecognitionException;
+
+/**
+ * Subclass of Antlr RecognitionException which should be the parent class of all parser related 
+ * exception classes. We need this layer because of the line number problem in tree parser in 
+ * Antlr-3.2. You will need a token where the exception occurs in order to instantiate an instance
+ * of this class.
+ *
+ */
+public abstract class PigRecognitionException extends RecognitionException {
+    private static final long serialVersionUID = 1L;
+    
+    public PigRecognitionException(IntStream input, SourceLocation loc) {
+        super( input );
+        this.line = loc.line();
+        this.charPositionInLine = loc.offset();
+    }
+    
+    protected String msgHeader() {
+        StringBuilder sb = new StringBuilder();
+        sb.append( "<line " + line );
+        if( charPositionInLine >= 0 )
+            sb.append( ", column " + charPositionInLine );
+        sb.append( "> " );
+        return sb.toString();
+    }
+
+}
diff --git a/src/org/apache/pig/parser/PlanGenerationFailureException.java b/src/org/apache/pig/parser/PlanGenerationFailureException.java
index e36603c58..5d90a9e89 100644
--- a/src/org/apache/pig/parser/PlanGenerationFailureException.java
+++ b/src/org/apache/pig/parser/PlanGenerationFailureException.java
@@ -19,20 +19,19 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
 
-public class PlanGenerationFailureException extends RecognitionException {
+public class PlanGenerationFailureException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private Exception ex;
     
-    public PlanGenerationFailureException(IntStream input, Exception ex) {
-        super( input );
+    public PlanGenerationFailureException(IntStream input, SourceLocation loc, Exception ex) {
+        super( input, loc );
         this.ex = ex;
     }
     
     public String toString() {
-        return "Failed to generate logical plan. Nested exception: " + ex;
+        return msgHeader() + "Failed to generate logical plan. Nested exception: " + ex;
     }
 
     public Exception getEx() {
diff --git a/src/org/apache/pig/parser/QueryLexer.g b/src/org/apache/pig/parser/QueryLexer.g
index 426e61fa6..4ea18ce6b 100644
--- a/src/org/apache/pig/parser/QueryLexer.g
+++ b/src/org/apache/pig/parser/QueryLexer.g
@@ -41,6 +41,20 @@ public void reportError(RecognitionException e) {
     throw new RuntimeException( sb.toString() );
 }
 
+@Override
+public String getErrorMessage(RecognitionException e, String[] tokenNames ) {
+    if( e instanceof NoViableAltException ) {
+        return "Unexpected character " + getCharErrorDisplay( e.c );
+    } else {
+        return super.getErrorMessage( e, tokenNames );
+    }
+}
+
+@Override
+public String getErrorHeader(RecognitionException ex) {
+	return QueryParserUtils.generateErrorHeader( ex );
+}
+
 } // End of members.
 
 DEFINE : 'DEFINE'
diff --git a/src/org/apache/pig/parser/QueryParser.g b/src/org/apache/pig/parser/QueryParser.g
index cddda4156..00f30a8c0 100644
--- a/src/org/apache/pig/parser/QueryParser.g
+++ b/src/org/apache/pig/parser/QueryParser.g
@@ -86,7 +86,11 @@ throws RecognitionException {
 
 public String getErrorMessage(RecognitionException e, String[] tokenNames ) {
     if( !log.isDebugEnabled() ) {
-        return super.getErrorMessage( e, tokenNames );
+        if( e instanceof NoViableAltException ) {
+            return "Syntax error, unexpected symbol at or near " + getTokenErrorDisplay( e.token );
+        } else {
+            return super.getErrorMessage( e, tokenNames );
+        }
     }
     
     List stack =  getRuleInvocationStack( e, this.getClass().getName() );
@@ -102,7 +106,12 @@ public String getErrorMessage(RecognitionException e, String[] tokenNames ) {
 }
 
 public String getTokenErrorDisplay(Token t) {
-    return "['" + t.getText() + "']";
+    return "'" + t.getText() + "'";
+}
+
+@Override
+public String getErrorHeader(RecognitionException ex) {
+	return QueryParserUtils.generateErrorHeader( ex );
 }
 
 } // End of @members
diff --git a/src/org/apache/pig/parser/QueryParserUtils.java b/src/org/apache/pig/parser/QueryParserUtils.java
index 8c6fbee82..4b36b3491 100644
--- a/src/org/apache/pig/parser/QueryParserUtils.java
+++ b/src/org/apache/pig/parser/QueryParserUtils.java
@@ -24,6 +24,7 @@ import java.net.URISyntaxException;
 import java.util.HashSet;
 import java.util.Set;
 
+import org.antlr.runtime.RecognitionException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.fs.Path;
@@ -41,17 +42,17 @@ import org.apache.pig.newplan.logical.relational.LOStore;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
 
 public class QueryParserUtils {
-	private static Log log = LogFactory.getLog( LogicalPlanGenerator.class );
+    private static Log log = LogFactory.getLog( LogicalPlanGenerator.class );
 
-	private static String removeQuotes(String str) {
+    private static String removeQuotes(String str) {
         if (str.startsWith("\u005c'") && str.endsWith("\u005c'"))
             return str.substring(1, str.length() - 1);
         else
             return str;
     }
 
-    public static void attachStorePlan(LogicalPlan lp, String fileName,	String func, 
-    		Operator input, String alias, PigContext pigContext) throws FrontendException {
+    public static void attachStorePlan(LogicalPlan lp, String fileName,    String func, 
+            Operator input, String alias, PigContext pigContext) throws FrontendException {
         if( func == null ) {
             func = PigStorage.class.getName();
         }
@@ -118,45 +119,49 @@ public class QueryParserUtils {
         }
     }
 
-	 static Set<String> getRemoteHosts(String absolutePath, String defaultHost) {
-	     String HAR_PREFIX = "hdfs-";
-	     Set<String> result = new HashSet<String>();
-	     String[] fnames = absolutePath.split(",");
-	     for (String fname: fnames) {
-	         // remove leading/trailing whitespace(s)
-	         fname = fname.trim();
-	         Path p = new Path(fname);
-	         URI uri = p.toUri();
-	         if(uri.isAbsolute()) {
-	             String scheme = uri.getScheme();
-	             if (scheme!=null && scheme.toLowerCase().equals("hdfs")||scheme.toLowerCase().equals("har")) {
-	                 if (uri.getHost()==null)
-	                     continue;
-	                 String thisHost = uri.getHost().toLowerCase();
-	                 if (scheme.toLowerCase().equals("har")) {
-	                     if (thisHost.startsWith(HAR_PREFIX)) {
-	                         thisHost = thisHost.substring(HAR_PREFIX.length());
-	                     }
-	                 }
-	                 if (!uri.getHost().isEmpty() && 
-	                         !thisHost.equals(defaultHost)) {
-	                     if (uri.getPort()!=-1)
-	                         result.add("hdfs://"+thisHost+":"+uri.getPort());
-	                     else
-	                         result.add("hdfs://"+thisHost);
-	                 }
-	             }
-	         }
-	     }
-	     return result;
-	 }
+     static Set<String> getRemoteHosts(String absolutePath, String defaultHost) {
+         String HAR_PREFIX = "hdfs-";
+         Set<String> result = new HashSet<String>();
+         String[] fnames = absolutePath.split(",");
+         for (String fname: fnames) {
+             // remove leading/trailing whitespace(s)
+             fname = fname.trim();
+             Path p = new Path(fname);
+             URI uri = p.toUri();
+             if(uri.isAbsolute()) {
+                 String scheme = uri.getScheme();
+                 if (scheme!=null && scheme.toLowerCase().equals("hdfs")||scheme.toLowerCase().equals("har")) {
+                     if (uri.getHost()==null)
+                         continue;
+                     String thisHost = uri.getHost().toLowerCase();
+                     if (scheme.toLowerCase().equals("har")) {
+                         if (thisHost.startsWith(HAR_PREFIX)) {
+                             thisHost = thisHost.substring(HAR_PREFIX.length());
+                         }
+                     }
+                     if (!uri.getHost().isEmpty() && 
+                             !thisHost.equals(defaultHost)) {
+                         if (uri.getPort()!=-1)
+                             result.add("hdfs://"+thisHost+":"+uri.getPort());
+                         else
+                             result.add("hdfs://"+thisHost);
+                     }
+                 }
+             }
+         }
+         return result;
+     }
 
-	 static String constructFileNameSignature(String fileName, FuncSpec funcSpec) {
-		 return fileName+"_"+funcSpec.toString();
-	 }
+     static String constructFileNameSignature(String fileName, FuncSpec funcSpec) {
+         return fileName + "_" + funcSpec.toString();
+     }
 
+     static String constructSignature(String alias, String filename, FuncSpec funcSpec) {
+         return alias + "_" + filename + "_" + funcSpec.toString();
+     }
+     
+     static String generateErrorHeader(RecognitionException ex) {
+         return "<line " + ex.line +", column " + ex.charPositionInLine + ">";
+     }
 
-	    static String constructSignature(String alias, String filename, FuncSpec funcSpec) {
-	        return alias+"_"+filename+"_"+funcSpec.toString();
-	    }
 }
diff --git a/src/org/apache/pig/parser/SourceLocation.java b/src/org/apache/pig/parser/SourceLocation.java
new file mode 100644
index 000000000..64486580d
--- /dev/null
+++ b/src/org/apache/pig/parser/SourceLocation.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.parser;
+
+import org.antlr.runtime.Token;
+import org.antlr.runtime.tree.CommonTree;
+
+public class SourceLocation {
+    private int line = -1; // line number, -1 if unknown.
+    private int offset = -1; // offset, -f if unknown.
+    
+    public SourceLocation(int line, int offset) {
+        this.line = line;
+        this.offset = offset;
+    }
+    
+    public SourceLocation(int line) {
+        this.line = line;
+    }
+    
+    public SourceLocation(Token token) {
+        this.line = token.getLine();
+        this.offset = token.getCharPositionInLine();
+    }
+    
+    public SourceLocation(CommonTree tree) {
+        this.line = tree.getLine();
+        this.offset = tree.getCharPositionInLine();
+    }
+    
+    public int line() {
+        return line;
+    }
+    
+    public int offset() {
+        return offset;
+    }
+    
+}
diff --git a/src/org/apache/pig/parser/UndefinedAliasException.java b/src/org/apache/pig/parser/UndefinedAliasException.java
index 8d4053a7b..f8e860470 100644
--- a/src/org/apache/pig/parser/UndefinedAliasException.java
+++ b/src/org/apache/pig/parser/UndefinedAliasException.java
@@ -19,20 +19,20 @@
 package org.apache.pig.parser;
 
 import org.antlr.runtime.IntStream;
-import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.Token;
 
-public class UndefinedAliasException extends RecognitionException {
+public class UndefinedAliasException extends PigRecognitionException {
     private static final long serialVersionUID = 1L;
     
     private String alias;
     
-    public UndefinedAliasException(IntStream input, String alias) {
-        super( input );
+    public UndefinedAliasException(IntStream input, Token t, String alias) {
+        super( input, new SourceLocation( t ) );
         this.alias = alias;
     }
     
     public String toString() {
-        return "Undefined alias: " + alias;
+        return msgHeader() + "Undefined alias: " + alias;
     }
 
     public String getAlias() {
diff --git a/test/org/apache/pig/parser/TestQueryLexer.java b/test/org/apache/pig/parser/TestQueryLexer.java
index 3c0457c8e..3f3ea1a7c 100644
--- a/test/org/apache/pig/parser/TestQueryLexer.java
+++ b/test/org/apache/pig/parser/TestQueryLexer.java
@@ -35,7 +35,7 @@ public class TestQueryLexer {
         QueryLexer lexer = new QueryLexer( input );
         int tokenCount = 0;
         Token token;
-        while( ( token = lexer.nextToken() )!= Token.EOF_TOKEN ) {
+        while( ( token = lexer.nextToken() ).getType() != Token.EOF ) {
             if( token.getChannel() == Token.HIDDEN_CHANNEL )
                 continue;
             tokenCount++;
@@ -52,4 +52,27 @@ public class TestQueryLexer {
         Assert.assertEquals( 0, lexer.getNumberOfSyntaxErrors() );
     }
     
+    @Test
+    public void test2() throws IOException {
+        String query = "A = load 'input' using PigStorage(';');" +
+                       "B = foreach ^ A generate string.concatsep( ';', $1, $2 );";
+        CharStream input = new QueryParserStringStream( query );
+        QueryLexer lexer = new QueryLexer( input );
+        Token token;
+        try {
+            while( ( token = lexer.nextToken() ).getType() != Token.EOF ) {
+                if( token.getChannel() == Token.HIDDEN_CHANNEL )
+                    continue;
+                if( token.getText().equals( ";" ) ) {
+                    System.out.println( token.getText() );
+                } else {
+                    System.out.print( token.getText() + "(" + token.getType() + ") " );
+                }
+            }
+        } catch(Exception ex) {
+            Assert.assertTrue( ex.getMessage().contains( "Unexpected character" ) );
+            return;
+        }
+        Assert.fail( "Query should fail." );
+    }
 }
diff --git a/test/org/apache/pig/test/TestCollectedGroup.java b/test/org/apache/pig/test/TestCollectedGroup.java
index 00033235d..6b35576e3 100644
--- a/test/org/apache/pig/test/TestCollectedGroup.java
+++ b/test/org/apache/pig/test/TestCollectedGroup.java
@@ -144,7 +144,7 @@ public class TestCollectedGroup {
             pigServer.openIterator( "C" );
             Assert.fail("Pig doesn't support multi-input collected group.");
         } catch (Exception e) {
-            String msg = "Pig script failed to validate: Collected group is only supported for single input";
+            String msg = "pig script failed to validate: Collected group is only supported for single input";
             Assert.assertTrue( e.getMessage().contains( msg ) );
         }
     }
@@ -160,7 +160,7 @@ public class TestCollectedGroup {
             pigServer.openIterator( "B" );
             Assert.fail("Pig doesn't support collected group all.");
         } catch (Exception e) {
-            String msg = "Pig script failed to validate: Collected group is only supported for columns or star projection";
+            String msg = "pig script failed to validate: Collected group is only supported for columns or star projection";
             Assert.assertTrue( e.getMessage().contains( msg ) );
         }
     }
@@ -176,7 +176,7 @@ public class TestCollectedGroup {
             pigServer.openIterator("B");
             Assert.fail("Pig doesn't support collected group by expression.");
         } catch (Exception e) {
-            String msg = "Pig script failed to validate: Collected group is only supported for columns or star projection";
+            String msg = "pig script failed to validate: Collected group is only supported for columns or star projection";
             Assert.assertTrue( e.getMessage().contains( msg ) );
         }
     }
