diff --git a/CHANGES.txt b/CHANGES.txt
index c06cad355..6d495b27b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,6 +26,8 @@ PIG-734:  Changed maps to only take strings as keys (gates).
 
 IMPROVEMENTS
 
+PIG-697: Proposed improvements to pig's optimizer, Phase5 (daijy)
+
 PIG-895: Default parallel for Pig (daijy)
 
 PIG-820: Change RandomSampleLoader to take a LoadFunc instead of extending
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 4ff01ab4b..6521d6b52 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -26,7 +26,6 @@ import java.net.URL;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.Collection;
-import java.util.Date;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -55,17 +54,13 @@ import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.LOCogroup;
-import org.apache.pig.impl.logicalLayer.LOFRJoin;
 import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LOLoad;
-import org.apache.pig.impl.logicalLayer.LOPrinter;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
 import org.apache.pig.impl.logicalLayer.LogicalPlanBuilder;
 import org.apache.pig.impl.logicalLayer.PlanSetter;
 import org.apache.pig.impl.logicalLayer.optimizer.LogicalOptimizer;
-import org.apache.pig.impl.logicalLayer.optimizer.TypeCastInserter;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.parser.QueryParser;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
@@ -75,7 +70,6 @@ import org.apache.pig.impl.plan.CompilationMessageCollector;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.CompilationMessageCollector.MessageType;
 import org.apache.pig.impl.streaming.StreamingCommand;
-import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.ObjectSerializer;
 import org.apache.pig.impl.util.PropertiesUtil;
 import org.apache.pig.impl.logicalLayer.LODefine;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index 4c0653865..58a8cf02a 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -744,14 +744,13 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 PlanWalker<LogicalOperator, LogicalPlan> childWalker = mCurrentWalker.spawnChildWalker(lp);
                 pushWalker(childWalker);
                 mCurrentWalker.walk(this);
-                exprPlans.add(currentPlan);
+                exprPlans.add((PhysicalPlan) currentPlan);
                 popWalker();
             }
             currentPlan = currentPlans.pop();
 			joinPlans.put(physOp, exprPlans);
 		}
 
-		// For skewed join, add a local rearrange operator to the plan
 		if (loj.getJoinType() == LOJoin.JOINTYPE.SKEWED) {
 			POSkewedJoin skj;
 			try {
@@ -778,15 +777,227 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 				}
 			}
 			LogToPhyMap.put(loj, skj);
+		} else if(loj.getJoinType() == LOJoin.JOINTYPE.REPLICATED) {
+	        String scope = loj.getOperatorKey().scope;
+	        inputs = loj.getInputs();
+	        List<List<PhysicalPlan>> ppLists = new ArrayList<List<PhysicalPlan>>();
+	        List<Byte> keyTypes = new ArrayList<Byte>();
+	        
+	        int fragment = 0;
+	        inp = new ArrayList<PhysicalOperator>();
+	        for (LogicalOperator op : inputs) {
+	            inp.add(LogToPhyMap.get(op));
+	            List<LogicalPlan> plans = (List<LogicalPlan>) loj.getJoinPlans()
+	                    .get(op);
+	            
+	            List<PhysicalPlan> exprPlans = new ArrayList<PhysicalPlan>();
+	            currentPlans.push(currentPlan);
+	            for (LogicalPlan lp : plans) {
+	                currentPlan = new PhysicalPlan();
+	                PlanWalker<LogicalOperator, LogicalPlan> childWalker = mCurrentWalker
+	                        .spawnChildWalker(lp);
+	                pushWalker(childWalker);
+	                mCurrentWalker.walk(this);
+	                exprPlans.add((PhysicalPlan) currentPlan);
+	                popWalker();
+
+	            }
+	            currentPlan = currentPlans.pop();
+	            ppLists.add(exprPlans);
+	            
+	            if (plans.size() > 1) {
+	                keyTypes.add(DataType.TUPLE);
+	            } else {
+	                keyTypes.add(exprPlans.get(0).getLeaves().get(0).getResultType());
+	            }
+	        }
+	        POFRJoin pfrj;
+	        try {
+	            pfrj = new POFRJoin(new OperatorKey(scope,nodeGen.getNextNodeId(scope)),loj.getRequestedParallelism(),
+	                                        inp, ppLists, keyTypes, null, fragment);
+	        } catch (ExecException e1) {
+	            int errCode = 2058;
+	            String msg = "Unable to set index on newly create POLocalRearrange.";
+	            throw new VisitorException(msg, errCode, PigException.BUG, e1);
+	        }
+	        pfrj.setResultType(DataType.TUPLE);
+	        currentPlan.add(pfrj);
+	        for (LogicalOperator op : inputs) {
+	            try {
+	                currentPlan.connect(LogToPhyMap.get(op), pfrj);
+	            } catch (PlanException e) {
+	                int errCode = 2015;
+	                String msg = "Invalid physical operators in the physical plan" ;
+	                throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
+	            }
+	        }
+	        LogToPhyMap.put(loj, pfrj);
+		} else if(loj.getJoinType() == LOJoin.JOINTYPE.REGULAR) {
+	        String scope = loj.getOperatorKey().scope;
+	        inputs = loj.getInputs();
+	        
+	        POGlobalRearrange poGlobal = new POGlobalRearrange(new OperatorKey(
+	                scope, nodeGen.getNextNodeId(scope)), loj
+	                .getRequestedParallelism());
+	        POPackage poPackage = new POPackage(new OperatorKey(scope, nodeGen
+	                .getNextNodeId(scope)), loj.getRequestedParallelism());
+
+	        currentPlan.add(poGlobal);
+	        currentPlan.add(poPackage);
+	        
+	        int count = 0;
+            Byte type = null;
+	        
+	        try {
+	            currentPlan.connect(poGlobal, poPackage);
+	            List<Boolean> flattenLst = Arrays.asList(true, true);
+
+	            for (LogicalOperator op : inputs) {
+	                List<LogicalPlan> plans = (List<LogicalPlan>) loj.getJoinPlans()
+	                        .get(op);
+	                POLocalRearrange physOp = new POLocalRearrange(new OperatorKey(
+	                        scope, nodeGen.getNextNodeId(scope)), loj
+	                        .getRequestedParallelism());
+	                List<PhysicalPlan> exprPlans = new ArrayList<PhysicalPlan>();
+	                currentPlans.push(currentPlan);
+	                for (LogicalPlan lp : plans) {
+	                    currentPlan = new PhysicalPlan();
+	                    PlanWalker<LogicalOperator, LogicalPlan> childWalker = mCurrentWalker
+	                            .spawnChildWalker(lp);
+	                    pushWalker(childWalker);
+	                    mCurrentWalker.walk(this);
+	                    exprPlans.add((PhysicalPlan) currentPlan);
+	                    popWalker();
+
+	                }
+	                currentPlan = currentPlans.pop();
+	                try {
+	                    physOp.setPlans(exprPlans);
+	                } catch (PlanException pe) {
+	                    int errCode = 2071;
+	                    String msg = "Problem with setting up local rearrange's plans.";
+	                    throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, pe);
+	                }
+	                try {
+	                    physOp.setIndex(count++);
+	                } catch (ExecException e1) {
+	                    int errCode = 2058;
+	                    String msg = "Unable to set index on newly create POLocalRearrange.";
+	                    throw new VisitorException(msg, errCode, PigException.BUG, e1);
+	                }
+	                if (plans.size() > 1) {
+	                    type = DataType.TUPLE;
+	                    physOp.setKeyType(type);
+	                } else {
+	                    type = exprPlans.get(0).getLeaves().get(0).getResultType();
+	                    physOp.setKeyType(type);
+	                }
+	                physOp.setResultType(DataType.TUPLE);
+
+	                currentPlan.add(physOp);
+
+	                try {
+	                    currentPlan.connect(LogToPhyMap.get(op), physOp);
+	                    currentPlan.connect(physOp, poGlobal);
+	                } catch (PlanException e) {
+	                    int errCode = 2015;
+	                    String msg = "Invalid physical operators in the physical plan" ;
+	                    throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
+	                }
+
+	            }
+	            
+	        } catch (PlanException e1) {
+	            int errCode = 2015;
+	            String msg = "Invalid physical operators in the physical plan" ;
+	            throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e1);
+	        }
+
+            poPackage.setKeyType(type);
+            poPackage.setResultType(DataType.TUPLE);
+            poPackage.setNumInps(count);
+                
+	        boolean inner[] = new boolean[count];
+	        for (int i=0;i<count;i++) {
+	            inner[i] = true;
+	        }
+	        poPackage.setInner(inner);
+	        
+	        List<PhysicalPlan> fePlans = new ArrayList<PhysicalPlan>();
+	        List<Boolean> flattenLst = new ArrayList<Boolean>();
+	        for(int i=1;i<=count;i++){
+	            PhysicalPlan fep1 = new PhysicalPlan();
+	            POProject feproj1 = new POProject(new OperatorKey(scope, nodeGen.getNextNodeId(scope)), loj.getRequestedParallelism(), i);
+	            feproj1.setResultType(DataType.BAG);
+	            feproj1.setOverloaded(false);
+	            fep1.add(feproj1);
+	            fePlans.add(fep1);
+	            flattenLst.add(true);
+	        }
+	        
+	        POForEach fe = new POForEach(new OperatorKey(scope, nodeGen.getNextNodeId(scope)), loj.getRequestedParallelism(), fePlans, flattenLst );
+	        currentPlan.add(fe);
+	        try{
+	            currentPlan.connect(poPackage, fe);
+	        }catch (PlanException e1) {
+	            int errCode = 2015;
+	            String msg = "Invalid physical operators in the physical plan" ;
+	            throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e1);
+	        }
+	        LogToPhyMap.put(loj, fe);   
 		}
 	}
 
 
+	/**
+     * Add a local rearrange operator to the plan 
+	 */
+/*
+	private void addLocalRearrange(LogicalOperator lo, PhysicalPlan &plan, List<PhysicalPlan> &exprPlans) throws VisitorException {
+        String scope = lo.getOperatorKey().scope;
+		POLocalRearrange physOp = new POLocalRearrange(new OperatorKey(
+				scope, nodeGen.getNextNodeId(scope)), lo.getRequestedParallelism());
+
+		try {
+			physOp.setPlans(exprPlans);
+		} catch (PlanException pe) {
+			int errCode = 2071;
+			String msg = "Problem with setting up local rearrange's plans.";
+			throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, pe);
+		}
+		try {
+			physOp.setIndex(count++);
+		} catch (ExecException e1) {
+			int errCode = 2058;
+			String msg = "Unable to set index on newly create POLocalRearrange.";
+			throw new VisitorException(msg, errCode, PigException.BUG, e1);
+		}
+		if (plans.size() > 1) {
+			type = DataType.TUPLE;
+			physOp.setKeyType(type);
+		} else {
+			type = exprPlans.get(0).getLeaves().get(0).getResultType();
+			physOp.setKeyType(type);
+		}
+		physOp.setResultType(DataType.TUPLE);
+
+		currentPlan.add(physOp);
+
+		try {
+			currentPlan.connect(LogToPhyMap.get(op), physOp);
+			currentPlan.connect(physOp, poGlobal);
+		} catch (PlanException e) {
+			int errCode = 2015;
+			String msg = "Invalid physical operators in the physical plan" ;
+			throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
+		}
+	}
+  */  
     /**
      * Create the inner plans used to configure the Local Rearrange operators(ppLists)
      * Extract the keytypes and create the POFRJoin operator.
      */
-    @Override
+/*    @Override
     protected void visit(LOFRJoin frj) throws VisitorException {
         String scope = frj.getOperatorKey().scope;
         List<LogicalOperator> inputs = frj.getInputs();
@@ -843,7 +1054,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         }
         LogToPhyMap.put(frj, pfrj);
     }
-
+*/
     private int findFrag(List<LogicalOperator> inputs, LogicalOperator fragOp) {
         int i=-1;
         for (LogicalOperator lop : inputs) {
diff --git a/src/org/apache/pig/impl/logicalLayer/DotLOPrinter.java b/src/org/apache/pig/impl/logicalLayer/DotLOPrinter.java
index ae436afa4..f90985846 100644
--- a/src/org/apache/pig/impl/logicalLayer/DotLOPrinter.java
+++ b/src/org/apache/pig/impl/logicalLayer/DotLOPrinter.java
@@ -87,8 +87,8 @@ public class DotLOPrinter extends DotPlanDumper<LogicalOperator, LogicalPlan,
         if(op instanceof LOCogroup){
             return  ((LOCogroup)op).getGroupByPlans();
         }
-        else if(op instanceof LOFRJoin){
-            return ((LOFRJoin)op).getJoinColPlans();
+        else if(op instanceof LOJoin){
+            return ((LOJoin)op).getJoinPlans();
         }
         else if(op instanceof LOJoin){
             return ((LOJoin)op).getJoinPlans();
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
deleted file mode 100644
index 90800e534..000000000
--- a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pig.impl.logicalLayer;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.List;
-import java.util.Set;
-import java.util.Map.Entry;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.pig.PigException;
-import org.apache.pig.data.DataType;
-import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
-import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
-import org.apache.pig.impl.plan.Operator;
-import org.apache.pig.impl.plan.OperatorKey;
-import org.apache.pig.impl.plan.PlanException;
-import org.apache.pig.impl.plan.ProjectionMap;
-import org.apache.pig.impl.plan.RequiredFields;
-import org.apache.pig.impl.plan.VisitorException;
-import org.apache.pig.impl.util.MultiMap;
-import org.apache.pig.impl.util.Pair;
-
-/**
- * This is the logical operator for the Fragment Replicate Join
- * It holds the user specified information and is responsible for 
- * the schema computation. This mimics the LOCogroup operator except
- * the schema computation.
- */
-public class LOFRJoin extends LogicalOperator {
-    private static final long serialVersionUID = 2L;
-    
-//    private boolean[] mIsInner;
-    private static Log log = LogFactory.getLog(LOFRJoin.class);
-    private MultiMap<LogicalOperator, LogicalPlan> mJoinColPlans;
-    private LogicalOperator fragOp;
-    
-    public LOFRJoin(
-            LogicalPlan plan,
-            OperatorKey k,
-            MultiMap<LogicalOperator, LogicalPlan> joinColPlans,
-            boolean[] isInner, LogicalOperator fragOp) {
-        super(plan, k);
-        mJoinColPlans = joinColPlans;
-//        mIsInner = isInner;
-        this.fragOp = fragOp;
-    }
-
-    @Override
-    /**
-     * Uses the schema from its input operators and dedups
-     * those fields that have the same alias and sets the
-     * schema for the join
-     */
-    public Schema getSchema() throws FrontendException {
-        List<LogicalOperator> inputs = mPlan.getPredecessors(this);
-        mType = DataType.BAG;//mType is from the super class
-        Hashtable<String, Integer> nonDuplicates = new Hashtable<String, Integer>();
-        if(!mIsSchemaComputed){
-            List<Schema.FieldSchema> fss = new ArrayList<Schema.FieldSchema>();
-            int i=-1;
-            for (LogicalOperator op : inputs) {
-                try {
-                    Schema cSchema = op.getSchema();
-                    if(cSchema!=null){
-                        
-                        for (FieldSchema schema : cSchema.getFields()) {
-                            ++i;
-                            FieldSchema newFS = null;
-                            if(schema.alias != null) {
-                                if(nonDuplicates.containsKey(schema.alias)) {
-                                        if(nonDuplicates.get(schema.alias)!=-1) {
-                                            nonDuplicates.remove(schema.alias);
-                                            nonDuplicates.put(schema.alias, -1);
-                                        }
-                                } else {
-                                    nonDuplicates.put(schema.alias, i);
-                                }
-                                newFS = new FieldSchema(op.getAlias()+"::"+schema.alias,schema.schema,schema.type);
-                            } else {
-                                newFS = new Schema.FieldSchema(null, DataType.BYTEARRAY);
-                            }
-                            newFS.setParent(schema.canonicalName, op);
-                            fss.add(newFS);
-                        }
-                    }
-                    else
-                        fss.add(new FieldSchema(null,DataType.BYTEARRAY));
-                } catch (FrontendException ioe) {
-                    mIsSchemaComputed = false;
-                    mSchema = null;
-                    throw ioe;
-                }
-            }
-            mIsSchemaComputed = true;
-            for (Entry<String, Integer> ent : nonDuplicates.entrySet()) {
-                int ind = ent.getValue();
-                if(ind==-1) continue;
-                FieldSchema prevSch = fss.get(ind);
-                fss.set(ind, new FieldSchema(ent.getKey(),prevSch.schema,prevSch.type));
-            }
-            mSchema = new Schema(fss);
-        }
-        return mSchema;
-    }
-
-    public MultiMap<LogicalOperator, LogicalPlan> getJoinColPlans() {
-        return mJoinColPlans;
-    }
-    
-    public void switchJoinColPlanOp(LogicalOperator oldOp,
-            LogicalOperator newOp) {
-        Collection<LogicalPlan> innerPlans = mJoinColPlans.removeKey(oldOp) ;
-        mJoinColPlans.put(newOp, innerPlans);
-        if(fragOp.getOperatorKey().equals(oldOp.getOperatorKey()))
-            fragOp = newOp;
-    }
-    
-    public void unsetSchema() throws VisitorException{
-        for(LogicalOperator input: getInputs()) {
-            Collection<LogicalPlan> grpPlans = mJoinColPlans.get(input);
-            if(grpPlans!=null)
-                for(LogicalPlan plan : grpPlans) {
-                    SchemaRemover sr = new SchemaRemover(plan);
-                    sr.visit();
-                }
-        }
-        super.unsetSchema();
-    }
-    
-    public List<LogicalOperator> getInputs() {
-        return mPlan.getPredecessors(this);
-    }
-    
-    @Override
-    public void visit(LOVisitor v) throws VisitorException {
-        v.visit(this);
-    }
-
-    @Override
-    public String name() {
-        return "FRJoin " + mKey.scope + "-" + mKey.id;
-    }
-
-    @Override
-    public boolean supportsMultipleInputs() {
-        return true;
-    }
-
-    public LogicalOperator getFragOp() {
-        return fragOp;
-    }
-
-    public void setFragOp(LogicalOperator fragOp) {
-        this.fragOp = fragOp;
-    }
-    
-    public boolean isTupleJoinCol() {
-        List<LogicalOperator> inputs = mPlan.getPredecessors(this);
-        if (inputs == null || inputs.size() == 0) {
-            throw new AssertionError("join.isTuplejoinCol() can be called "
-                                     + "after it has an input only") ;
-        }
-		// NOTE: we depend on the number of inner plans to determine
-		// if the join col is a tuple. This could be an issue when there
-		// is only one inner plan with Project(*). For that case if the
-		// corresponding input to the Project had a schema then the front end 
-		// would translate the single Project(*) (through ProjectStarTranslator)
-		// to many individual Projects. So the number of inner plans would then 
-		// be > 1 BEFORE reaching here. For the Project(*) case when the corresponding
-		// input for the Project has no schema, treating it as an atomic col join
-		// does not cause any problems since no casts need to be inserted in that case
-		// anyway.
-        return mJoinColPlans.get(inputs.get(0)).size() > 1 ;
-    }
-    public byte getAtomicJoinColType() throws FrontendException {
-        if (isTupleJoinCol()) {
-            int errCode = 1010;
-            String msg = "getAtomicGroupByType is used only when"
-                + " dealing with atomic join col";
-            throw new FrontendException(msg, errCode, PigException.INPUT, false, null) ;
-        }
-
-        byte joinColType = DataType.BYTEARRAY ;
-        // merge all the inner plan outputs so we know what type
-        // our join column should be
-        for(int i=0;i < getInputs().size(); i++) {
-            LogicalOperator input = getInputs().get(i) ;
-            List<LogicalPlan> innerPlans
-                        = new ArrayList<LogicalPlan>(getJoinColPlans().get(input)) ;
-            if (innerPlans.size() != 1) {
-                int errCode = 1012;
-                String msg = "Each join input has to have "
-                + "the same number of inner plans";
-                throw new FrontendException(msg, errCode, PigException.INPUT, false, null) ;
-            }
-            byte innerType = innerPlans.get(0).getSingleLeafPlanOutputType() ;
-            joinColType = DataType.mergeType(joinColType, innerType) ;
-        }
-
-        return joinColType ;
-    }
-
-    public Schema getTupleJoinColSchema() throws FrontendException {
-        if (!isTupleJoinCol()) {
-            int errCode = 1011;
-            String msg = "getTupleGroupBySchema is used only when"
-                + " dealing with tuple join col";
-            throw new FrontendException(msg, errCode, PigException.INPUT, false, null) ;
-        }
-
-        // this fsList represents all the columns in join tuple
-        List<Schema.FieldSchema> fsList = new ArrayList<Schema.FieldSchema>() ;
-
-        int outputSchemaSize = getJoinColPlans().get(getInputs().get(0)).size() ;
-
-        // by default, they are all bytearray
-        // for type checking, we don't care about aliases
-        for(int i=0; i<outputSchemaSize; i++) {
-            fsList.add(new Schema.FieldSchema(null, DataType.BYTEARRAY)) ;
-        }
-
-        // merge all the inner plan outputs so we know what type
-        // our join column should be
-        for(int i=0;i < getInputs().size(); i++) {
-            LogicalOperator input = getInputs().get(i) ;
-            List<LogicalPlan> innerPlans
-                        = new ArrayList<LogicalPlan>(getJoinColPlans().get(input)) ;
-
-            boolean seenProjectStar = false;
-            for(int j=0;j < innerPlans.size(); j++) {
-                byte innerType = innerPlans.get(j).getSingleLeafPlanOutputType() ;
-                ExpressionOperator eOp = (ExpressionOperator)innerPlans.get(j).getSingleLeafPlanOutputOp();
-
-                if(eOp instanceof LOProject) {
-                    if(((LOProject)eOp).isStar()) {
-                        seenProjectStar = true;
-                    }
-                }
-                        
-                Schema.FieldSchema joinFs = fsList.get(j);
-                joinFs.type = DataType.mergeType(joinFs.type, innerType) ;
-                Schema.FieldSchema fs = eOp.getFieldSchema();
-                if(null != fs) {
-                    joinFs.setParent(eOp.getFieldSchema().canonicalName, eOp);
-                } else {
-                    joinFs.setParent(null, eOp);
-                }
-            }
-
-            if(seenProjectStar && innerPlans.size() > 1) {                
-                int errCode = 1013;
-                String msg = "Join attributes can either be star (*) or a list of expressions, but not both.";
-                throw new FrontendException(msg, errCode, PigException.INPUT, false, null);
-                
-            }
-
-        }
-
-        return new Schema(fsList) ;
-    }
-
-    @Override
-    public ProjectionMap getProjectionMap() {
-        
-        if(mIsProjectionMapComputed) return mProjectionMap;
-        mIsProjectionMapComputed = true;
-        
-        Schema outputSchema;
-        
-        try {
-            outputSchema = getSchema();
-        } catch (FrontendException fee) {
-            mProjectionMap = null;
-            return mProjectionMap;
-        }
-        
-        if(outputSchema == null) {
-            mProjectionMap = null;
-            return mProjectionMap;
-        }
-        
-        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
-        if(predecessors == null) {
-            mProjectionMap = null;
-            return mProjectionMap;
-        }
-        
-        MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
-        List<Integer> addedFields = new ArrayList<Integer>();
-        boolean[] unknownSchema = new boolean[predecessors.size()];
-        boolean anyUnknownInputSchema = false;
-        int outputColumnNum = 0;
-        
-        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
-            LogicalOperator predecessor = predecessors.get(inputNum);
-            Schema inputSchema = null;        
-            
-            try {
-                inputSchema = predecessor.getSchema();
-            } catch (FrontendException fee) {
-                mProjectionMap = null;
-                return mProjectionMap;
-            }
-            
-            if(inputSchema == null) {
-                unknownSchema[inputNum] = true;
-                outputColumnNum++;
-                addedFields.add(inputNum);
-                anyUnknownInputSchema = true;
-            } else {
-                unknownSchema[inputNum] = false;
-                for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
-                    mapFields.put(outputColumnNum++, 
-                            new ProjectionMap.Column(new Pair<Integer, Integer>(inputNum, inputColumn)));
-                }
-            }
-        }
-        
-        //TODO
-        /*
-         * For now, if there is any input that has an unknown schema
-         * flag it and return a null ProjectionMap.
-         * In the future, when unknown schemas are handled
-         * mark inputs that have unknown schemas as output columns
-         * that have been added.
-         */
-
-        if(anyUnknownInputSchema) {
-            mProjectionMap = null;
-            return mProjectionMap;
-        }
-        
-        if(addedFields.size() == 0) {
-            addedFields = null;
-        }
-
-        mProjectionMap = new ProjectionMap(mapFields, null, addedFields);
-        return mProjectionMap;
-    }
-
-    @Override
-    public List<RequiredFields> getRequiredFields() {        
-        List<LogicalOperator> predecessors = mPlan.getPredecessors(this);
-        
-        if(predecessors == null) {
-            return null;
-        }
-        
-        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
-        
-        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
-            Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
-            Set<LOProject> projectSet = new HashSet<LOProject>();
-            boolean groupByStar = false;
-
-            for (LogicalPlan plan : this.getJoinColPlans().get(predecessors.get(inputNum))) {
-                TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(plan);
-                try {
-                    projectFinder.visit();
-                } catch (VisitorException ve) {
-                    requiredFields.clear();
-                    requiredFields.add(null);
-                    return requiredFields;
-                }
-                projectSet.addAll(projectFinder.getProjectSet());
-                if(projectFinder.getProjectStarSet() != null) {
-                    groupByStar = true;
-                }
-            }
-
-            if(groupByStar) {
-                requiredFields.add(new RequiredFields(true));
-            } else {                
-                for (LOProject project : projectSet) {
-                    for (int inputColumn : project.getProjection()) {
-                        fields.add(new Pair<Integer, Integer>(inputNum, inputColumn));
-                    }
-                }
-        
-                if(fields.size() == 0) {
-                    requiredFields.add(new RequiredFields(false, true));
-                } else {                
-                    requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
-                }
-            }
-        }
-        
-        return (requiredFields.size() == 0? null: requiredFields);
-    }
-
-    /* (non-Javadoc)
-     * @see org.apache.pig.impl.plan.Operator#rewire(org.apache.pig.impl.plan.Operator, org.apache.pig.impl.plan.Operator)
-     */
-    @Override
-    public void rewire(Operator oldPred, int oldPredIndex, Operator newPred, boolean useOldPred) throws PlanException {
-        super.rewire(oldPred, oldPredIndex, newPred, useOldPred);
-        LogicalOperator previous = (LogicalOperator) oldPred;
-        LogicalOperator current = (LogicalOperator) newPred;
-        Set<LogicalOperator> joinInputs = new HashSet<LogicalOperator>(mJoinColPlans.keySet()); 
-        for(LogicalOperator input: joinInputs) {
-            if(input.equals(previous)) {
-                //replace the references to the key(i.e., previous) in the values with current
-                for(LogicalPlan plan: mJoinColPlans.get(input)) {
-                    try {
-                        ProjectFixerUpper projectFixer = new ProjectFixerUpper(
-                                plan, previous, oldPredIndex, current, useOldPred, this);
-                        projectFixer.visit();
-                    } catch (VisitorException ve) {
-                        int errCode = 2144;
-                        String msg = "Problem while fixing project inputs during rewiring.";
-                        throw new PlanException(msg, errCode, PigException.BUG, ve);
-                    }
-                }
-                //remove the key and the values
-                List<LogicalPlan> plans = (List<LogicalPlan>)mJoinColPlans.get(previous);
-                mJoinColPlans.removeKey(previous);
-                
-                //reinsert new key and values
-                mJoinColPlans.put(current, plans);
-                
-                if(input.equals(fragOp)) {
-                   fragOp = current; 
-                }
-            }
-        }
-    }
-}
diff --git a/src/org/apache/pig/impl/logicalLayer/LOJoin.java b/src/org/apache/pig/impl/logicalLayer/LOJoin.java
index 7ef7a7037..1de4d97df 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOJoin.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOJoin.java
@@ -20,10 +20,8 @@ package org.apache.pig.impl.logicalLayer;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 import java.util.HashSet;
-import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map.Entry;
@@ -34,11 +32,9 @@ import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.VisitorException;
-import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
-import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pig.impl.util.MultiMap;
@@ -49,14 +45,14 @@ import org.apache.pig.impl.plan.ProjectionMap;
 public class LOJoin extends LogicalOperator {
     private static final long serialVersionUID = 2L;
 
-	/**
-	 * Enum for the type of join
-	 */
+    /**
+     * Enum for the type of join
+     */
 	public static enum JOINTYPE {
-								REGULAR, /// Regular join
-								REPLICATED, /// Fragment Replicated join
-								SKEWED /// Skewed Join
-							  };
+        REGULAR, // Regular join
+        REPLICATED, // Fragment Replicated join
+        SKEWED // Skewed Join
+    };
 
     /**
      * LOJoin contains a list of logical operators corresponding to the
@@ -67,7 +63,7 @@ public class LOJoin extends LogicalOperator {
     private static Log log = LogFactory.getLog(LOJoin.class);
     private MultiMap<LogicalOperator, LogicalPlan> mJoinPlans;
 
-	private JOINTYPE mJoinType;	// Retains the type of the join
+	private JOINTYPE mJoinType; // Retains the type of the join
 
     /**
      * 
@@ -77,7 +73,7 @@ public class LOJoin extends LogicalOperator {
      *            OperatorKey for this operator
      * @param joinPlans
      *            the join columns
-     * @param jt 
+     * @param jt
      *            indicates the type of join - regular, skewed or fragment replicated
      */
     public LOJoin(
@@ -99,16 +95,15 @@ public class LOJoin extends LogicalOperator {
     }    
 
     public void setJoinPlans(MultiMap<LogicalOperator, LogicalPlan> joinPlans) {
-System.out.println("#@ resetting join plans");
         mJoinPlans = joinPlans;
     }    
 
 	/**
      * Returns the type of join.
      */
-	public JOINTYPE getJoinType() {
-		return mJoinType;
-	}
+    public JOINTYPE getJoinType() {
+        return mJoinType;
+    }
 
     @Override
     public String name() {
@@ -135,22 +130,28 @@ System.out.println("#@ resetting join plans");
                         
                         for (FieldSchema schema : cSchema.getFields()) {
                             ++i;
-                            if(nonDuplicates.containsKey(schema.alias))
-                                {
-                                    if(nonDuplicates.get(schema.alias)!=-1) {
+                            FieldSchema newFS = null;
+                            if(schema.alias != null) {
+                                if(nonDuplicates.containsKey(schema.alias)) {
+                                    if (nonDuplicates.get(schema.alias) != -1) {
                                         nonDuplicates.remove(schema.alias);
                                         nonDuplicates.put(schema.alias, -1);
                                     }
+                                } else {
+                                    nonDuplicates.put(schema.alias, i);
                                 }
-                            else
-                                nonDuplicates.put(schema.alias, i);
-                            FieldSchema newFS = new FieldSchema(op.getAlias()+"::"+schema.alias,schema.schema,schema.type);
+                                newFS = new FieldSchema(op.getAlias()+"::"+schema.alias,schema.schema,schema.type);
+                            } else {
+                                newFS = new Schema.FieldSchema(null, DataType.BYTEARRAY);
+                            }
                             newFS.setParent(schema.canonicalName, op);
                             fss.add(newFS);
                         }
+                    } else {
+                        FieldSchema newFS = new FieldSchema(null, DataType.BYTEARRAY);
+                        newFS.setParent(null, op);
+                        fss.add(newFS);
                     }
-                    else
-                        fss.add(new FieldSchema(null,DataType.BYTEARRAY));
                 } catch (FrontendException ioe) {
                     mIsSchemaComputed = false;
                     mSchema = null;
@@ -162,7 +163,7 @@ System.out.println("#@ resetting join plans");
                 int ind = ent.getValue();
                 if(ind==-1) continue;
                 FieldSchema prevSch = fss.get(ind);
-                fss.set(ind, new FieldSchema(ent.getKey(),prevSch.schema,prevSch.type));
+                prevSch.alias = ent.getKey();
             }
             mSchema = new Schema(fss);
         }
@@ -428,7 +429,7 @@ System.out.println("#@ resetting join plans");
             Set<LOProject> projectSet = new HashSet<LOProject>();
             boolean groupByStar = false;
 
-            for (LogicalPlan plan : this.getJoinPlans().get(predecessors.get(inputNum))) {
+            for (LogicalPlan plan : mJoinPlans.get(predecessors.get(inputNum))) {
                 TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(plan);
                 try {
                     projectFinder.visit();
diff --git a/src/org/apache/pig/impl/logicalLayer/LOPrinter.java b/src/org/apache/pig/impl/logicalLayer/LOPrinter.java
index 096a2e091..a1f92dbb7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOPrinter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOPrinter.java
@@ -152,8 +152,8 @@ public class LOPrinter extends LOVisitor {
                     }
                 }
             }
-            else if(node instanceof LOFRJoin){
-                MultiMap<LogicalOperator, LogicalPlan> plans = ((LOFRJoin)node).getJoinColPlans();
+            else if(node instanceof LOJoin){
+                MultiMap<LogicalOperator, LogicalPlan> plans = ((LOJoin)node).getJoinPlans();
                 for (LogicalOperator lo : plans.keySet()) {
                     // Visit the associated plans
                     for (LogicalPlan plan : plans.get(lo)) {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOVisitor.java b/src/org/apache/pig/impl/logicalLayer/LOVisitor.java
index f17b6f6b7..e0a500510 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOVisitor.java
@@ -136,25 +136,6 @@ abstract public class LOVisitor extends
             }
         }
     }
-    
-    protected void visit(LOFRJoin frj) throws VisitorException {
-        // Visit each of the inputs of cogroup.
-        MultiMap<LogicalOperator, LogicalPlan> mapGByPlans = frj.getJoinColPlans();
-        for(LogicalOperator op: frj.getInputs()) {
-            for(LogicalPlan lp: mapGByPlans.get(op)) {
-                if (null != lp) {
-                    // TODO FIX - How do we know this should be a
-                    // DependencyOrderWalker?  We should be replicating the
-                    // walker the current visitor is using.
-                    PlanWalker w = new DependencyOrderWalker(lp);
-                    pushWalker(w);
-                    w.walk(this);
-                    popWalker();
-                }
-            }
-        }
-    }
-
 
     /**
      * 
@@ -164,7 +145,7 @@ abstract public class LOVisitor extends
      */
 	@SuppressWarnings("unchecked")
     protected void visit(LOJoin loj) throws VisitorException {
-        // Visit each of the inputs of cogroup.
+        // Visit each of the inputs of join.
         MultiMap<LogicalOperator, LogicalPlan> mapJoinPlans = loj.getJoinPlans();
         for(LogicalOperator op: loj.getInputs()) {
             for(LogicalPlan lp: mapJoinPlans.get(op)) {
diff --git a/src/org/apache/pig/impl/logicalLayer/PlanSetter.java b/src/org/apache/pig/impl/logicalLayer/PlanSetter.java
index 7ad4a1bbf..d2bf4250e 100644
--- a/src/org/apache/pig/impl/logicalLayer/PlanSetter.java
+++ b/src/org/apache/pig/impl/logicalLayer/PlanSetter.java
@@ -58,11 +58,6 @@ public class PlanSetter extends LOVisitor {
         super.visit(op);
     }
     
-    public void visit(LOFRJoin op) throws VisitorException {
-        op.setPlan(mCurrentWalker.getPlan());
-        super.visit(op);
-    }
-
     public void visit(LOJoin op) throws VisitorException {
         op.setPlan(mCurrentWalker.getPlan());
         super.visit(op);
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectStarTranslator.java b/src/org/apache/pig/impl/logicalLayer/ProjectStarTranslator.java
index 16330e555..64cbb173c 100644
--- a/src/org/apache/pig/impl/logicalLayer/ProjectStarTranslator.java
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectStarTranslator.java
@@ -75,42 +75,16 @@ public class ProjectStarTranslator extends
         }
     }
     
-    /* (non-Javadoc)
-     * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LOFRJoin)
-     */
-    @Override
-    protected void visit(LOFRJoin frj) throws VisitorException {
-        //get the attributes of LOFRJoin that are modified during the translation
-        
-        MultiMap<LogicalOperator, LogicalPlan> joinColPlans = frj.getJoinColPlans();
-
-        for(LogicalOperator op: frj.getInputs()) {
-            ArrayList<LogicalPlan> newPlansAfterTranslation = new ArrayList<LogicalPlan>();
-            for(LogicalPlan lp: joinColPlans.get(op)) {
-                if (checkPlanForProjectStar(lp)) {
-                    ArrayList<LogicalPlan> translatedPlans = translateProjectStarInPlan(lp);
-                    for(int j = 0; j < translatedPlans.size(); ++j) {
-                        newPlansAfterTranslation.add(translatedPlans.get(j));
-                    }
-                } else {
-                    newPlansAfterTranslation.add(lp);
-                }
-            }
-            joinColPlans.removeKey(op);
-            joinColPlans.put(op, newPlansAfterTranslation);
-        }
-    }
-
     /* (non-Javadoc)
      * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LOJoin)
      */
     @Override
-    protected void visit(LOJoin frj) throws VisitorException {
+    protected void visit(LOJoin join) throws VisitorException {
         //get the attributes of LOJoin that are modified during the translation
         
-        MultiMap<LogicalOperator, LogicalPlan> joinColPlans = frj.getJoinPlans();
+        MultiMap<LogicalOperator, LogicalPlan> joinColPlans = join.getJoinPlans();
 
-        for(LogicalOperator op: frj.getInputs()) {
+        for(LogicalOperator op: join.getInputs()) {
             ArrayList<LogicalPlan> newPlansAfterTranslation = new ArrayList<LogicalPlan>();
             for(LogicalPlan lp: joinColPlans.get(op)) {
                 if (checkPlanForProjectStar(lp)) {
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java b/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java
index b5c66dee7..e37bf7d36 100644
--- a/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectionMapCalculator.java
@@ -44,13 +44,13 @@ public class ProjectionMapCalculator extends
 
     /**
      * 
-     * @param frjoin
-     *            the logical fragment replicate join operator that has to be visited
+     * @param join
+     *            the logical join operator that has to be visited
      * @throws VisitorException
      */
-    protected void visit(LOFRJoin frjoin) throws VisitorException {
-        frjoin.getProjectionMap();
-        super.visit(frjoin);
+    protected void visit(LOJoin join) throws VisitorException {
+        join.getProjectionMap();
+        super.visit(join);
     }
     
     /**
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java b/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java
index 4263a5005..b5e94fac9 100644
--- a/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectionMapRemover.java
@@ -44,13 +44,13 @@ public class ProjectionMapRemover extends
 
     /**
      * 
-     * @param frjoin
-     *            the logical fragment replicate join operator that has to be visited
+     * @param join
+     *            the logical join operator that has to be visited
      * @throws VisitorException
      */
-    protected void visit(LOFRJoin frjoin) throws VisitorException {
-        frjoin.unsetProjectionMap();
-        super.visit(frjoin);
+    protected void visit(LOJoin join) throws VisitorException {
+        join.unsetProjectionMap();
+        super.visit(join);
     }
     
     /**
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
index 937d3a006..0ace1e03e 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
@@ -24,25 +24,20 @@ import java.util.Map;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
-import org.apache.pig.impl.plan.DepthFirstWalker;
 import org.apache.pig.impl.plan.PlanWalker;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.optimizer.Transformer;
-import org.apache.pig.impl.plan.optimizer.Transformer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.LOFRJoin;
+import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
 import org.apache.pig.impl.logicalLayer.LOCogroup;
 import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LOGenerate;
-import org.apache.pig.impl.logicalLayer.LOProject;
 import org.apache.pig.impl.logicalLayer.LOSort;
 import org.apache.pig.impl.logicalLayer.LOSplit;
 import org.apache.pig.impl.logicalLayer.LOSplitOutput;
-import org.apache.pig.impl.logicalLayer.LOVisitor;
 import org.apache.pig.impl.logicalLayer.ProjectFixerUpper;
 import org.apache.pig.impl.logicalLayer.ProjectionMapCalculator;
 import org.apache.pig.impl.logicalLayer.ProjectionMapRemover;
@@ -132,8 +127,8 @@ public abstract class LogicalTransformer extends Transformer<LogicalOperator, Lo
             LOCogroup cg = (LOCogroup) before ;
             cg.switchGroupByPlanOp(after, newNode);
         }
-        if (before instanceof LOFRJoin) {
-            LOFRJoin frj = (LOFRJoin) before ;
+        if (before instanceof LOJoin) {
+            LOJoin frj = (LOJoin) before ;
             frj.switchJoinColPlanOp(after, newNode);
         }
         if (before instanceof LOJoin) {
@@ -147,8 +142,8 @@ public abstract class LogicalTransformer extends Transformer<LogicalOperator, Lo
         List<LogicalPlan> plans = new ArrayList<LogicalPlan>();
         if (before instanceof LOCogroup) {
             plans.addAll((((LOCogroup)before).getGroupByPlans()).values());
-        } else if (before instanceof LOFRJoin) {
-            plans.addAll((((LOFRJoin)before).getJoinColPlans()).values());
+        } else if (before instanceof LOJoin) {
+            plans.addAll((((LOJoin)before).getJoinPlans()).values());
         } else if (before instanceof LOJoin) {
             plans.addAll((((LOJoin)before).getJoinPlans()).values());
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
index 53ba9d12e..5c50d3b27 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
@@ -36,7 +36,7 @@ import org.apache.pig.impl.logicalLayer.LOSort;
 import org.apache.pig.impl.logicalLayer.LOSplit;
 import org.apache.pig.impl.logicalLayer.LOSplitOutput;
 import org.apache.pig.impl.logicalLayer.LOUnion;
-import org.apache.pig.impl.logicalLayer.LOFRJoin;
+import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
@@ -138,7 +138,7 @@ public class OpLimitOptimizer extends LogicalTransformer {
             // Limit cannot be pushed up
             if (predecessor instanceof LOCogroup || predecessor instanceof LOFilter ||
             		predecessor instanceof LOLoad || predecessor instanceof LOSplit ||
-            		predecessor instanceof LOSplitOutput || predecessor instanceof LODistinct || predecessor instanceof LOFRJoin || predecessor instanceof LOJoin)
+            		predecessor instanceof LOSplitOutput || predecessor instanceof LODistinct || predecessor instanceof LOJoin)
             {
             	return;
             }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PushDownForeachFlatten.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PushDownForeachFlatten.java
index c76eafc59..7fdb56c7b 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/PushDownForeachFlatten.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PushDownForeachFlatten.java
@@ -28,8 +28,8 @@ import java.util.Set;
 import org.apache.pig.impl.logicalLayer.CastFinder;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.LOCross;
-import org.apache.pig.impl.logicalLayer.LOFRJoin;
 import org.apache.pig.impl.logicalLayer.LOForEach;
+import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LOProject;
 import org.apache.pig.impl.logicalLayer.LOSort;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
@@ -222,7 +222,7 @@ public class PushDownForeachFlatten extends LogicalTransformer {
                 mSwap = true;
                 return true;
             } else if (successor instanceof LOCross
-                    || successor instanceof LOFRJoin) {
+                    || successor instanceof LOJoin) {
                 
                 List<LogicalOperator> children = mPlan.getSuccessors(successor);
                 
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
index 0d1b388e9..3fc3a4d84 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
@@ -31,30 +31,24 @@ import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.LOCast;
 import org.apache.pig.impl.logicalLayer.LOCogroup;
 import org.apache.pig.impl.logicalLayer.LOCross;
-import org.apache.pig.impl.logicalLayer.LOFRJoin;
+import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOForEach;
 import org.apache.pig.impl.logicalLayer.LOLimit;
 import org.apache.pig.impl.logicalLayer.LOLoad;
 import org.apache.pig.impl.logicalLayer.LOSplit;
 import org.apache.pig.impl.logicalLayer.LOStore;
-import org.apache.pig.impl.logicalLayer.LOProject;
 import org.apache.pig.impl.logicalLayer.LOStream;
 import org.apache.pig.impl.logicalLayer.LOSplitOutput;
 import org.apache.pig.impl.logicalLayer.LOUnion;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
 import org.apache.pig.impl.logicalLayer.UDFFinder;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.DepthFirstWalker;
-import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.optimizer.OptimizerException;
-import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
-import org.apache.pig.impl.streaming.StreamingCommand;
-import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
 
@@ -182,7 +176,7 @@ public class PushUpFilter extends LogicalTransformer {
             if (predecessor instanceof LOCross
                     || predecessor instanceof LOUnion
                     || predecessor instanceof LOCogroup
-                    || predecessor instanceof LOFRJoin) {
+                    || predecessor instanceof LOJoin) {
 
                 // check if the filter's required fields in conjunction with the
                 // predecessor's projection map. If the filter needs more than
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java b/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java
index 633da3eea..211cddebc 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaCalculator.java
@@ -79,14 +79,14 @@ public class SchemaCalculator extends LOVisitor {
 
     /**
      * 
-     * @param frjoin
-     *            the logical fragment replicate join operator that has to be visited
+     * @param join
+     *            the logical join operator that has to be visited
      * @throws VisitorException
      */
-    protected void visit(LOFRJoin frjoin) throws VisitorException {
+    protected void visit(LOJoin join) throws VisitorException {
         try {
-            frjoin.getSchema();
-            super.visit(frjoin);
+            join.getSchema();
+            super.visit(join);
         } catch (FrontendException fe) {
             throw new VisitorException(fe);
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaRemover.java b/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaRemover.java
index 914996d5c..212e6a1fe 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaRemover.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/SchemaRemover.java
@@ -205,14 +205,8 @@ public class SchemaRemover extends LOVisitor {
         super.visit(project);
     }
 
-    @Override
-    protected void visit(LOFRJoin frj) throws VisitorException {
-        frj.unsetSchema();
-        super.visit(frj);
-    }
-    
-    protected void visit(LOJoin frj) throws VisitorException {
-        frj.unsetSchema();
-        super.visit(frj);
+    protected void visit(LOJoin join) throws VisitorException {
+        join.unsetSchema();
+        super.visit(join);
     }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 4a1d83f54..ee38af837 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -358,6 +358,7 @@ public class QueryParser {
 	/**
 	 * Mimicing parseCogroup as the parsing logic for FRJoin remains exactly the same.
 	 */
+	 /*
 	LogicalOperator parseFRJoin(ArrayList<CogroupInput> gis, LogicalPlan lp) throws ParseException, PlanException{
 		
 		log.trace("Entering parseCogroup");
@@ -407,6 +408,7 @@ public class QueryParser {
 		log.trace("Exiting parseFRJoin");
 		return frj;
 	}
+	*/
 			
 	/**
 	 * The join operator is translated to foreach 
@@ -1918,7 +1920,7 @@ LogicalOperator JoinClause(LogicalPlan lp) :
 	(gi = GroupItem(lp) { gis.add(gi); }
 	("," gi = GroupItem(lp) { gis.add(gi); })+
 	// The addition of using replicated to indicate FRJoin
-	([<USING> ("\"replicated\"" { frj = parseFRJoin(gis, lp); } | "\"repl\"" { frj=parseFRJoin(gis,lp);}
+	([<USING> ("\"replicated\"" { frj = parseJoin(gis, lp, LOJoin.JOINTYPE.REPLICATED); } | "\"repl\"" { frj=parseJoin(gis, lp, LOJoin.JOINTYPE.REPLICATED);}
     |"\"skewed\"" { skj = parseJoin(gis, lp, LOJoin.JOINTYPE.SKEWED); })] ))
 
 	{log.trace("Exiting JoinClause");
@@ -1929,7 +1931,8 @@ LogicalOperator JoinClause(LogicalPlan lp) :
 		return skj;
 	}
 	else {
-		return rewriteJoin(gis,lp);
+		//return rewriteJoin(gis,lp);
+		return parseJoin(gis, lp, LOJoin.JOINTYPE.REGULAR);
 	}}
 	
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index cb9f5d9ad..4aa29f793 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -2123,6 +2123,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     /**
      * Mimics the type checking of LOCogroup
      */
+    /*
     protected void visit(LOFRJoin frj) throws VisitorException {
         try {
             frj.regenerateSchema();
@@ -2244,13 +2245,13 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new TypeCheckerException(msg, errCode, PigException.INPUT, fe) ;
         }
     }
-
+*/
 	/**
      * LOJoin visitor
 	 */
-    protected void visit(LOJoin frj) throws VisitorException {
+    protected void visit(LOJoin join) throws VisitorException {
         try {
-            frj.regenerateSchema();
+            join.regenerateSchema();
         } catch (FrontendException fe) {
             int errCode = 1060;
             String msg = "Cannot resolve Join output schema" ;
@@ -2259,8 +2260,8 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
         
         MultiMap<LogicalOperator, LogicalPlan> joinColPlans
-                                                    = frj.getJoinPlans() ;
-        List<LogicalOperator> inputs = frj.getInputs() ;
+                                                    = join.getJoinPlans() ;
+        List<LogicalOperator> inputs = join.getInputs() ;
         
         // Type checking internal plans.
         for(int i=0;i < inputs.size(); i++) {
@@ -2287,13 +2288,13 @@ public class TypeCheckingVisitor extends LOVisitor {
         
         try {
 
-            if (!frj.isTupleJoinCol()) {
+            if (!join.isTupleJoinCol()) {
                 // merge all the inner plan outputs so we know what type
                 // our group column should be
 
                 // TODO: Don't recompute schema here
                 //byte groupType = schema.getField(0).type ;
-                byte groupType = frj.getAtomicJoinColType() ;
+                byte groupType = join.getAtomicJoinColType() ;
 
                 // go through all inputs again to add cast if necessary
                 for(int i=0;i < inputs.size(); i++) {
@@ -2304,7 +2305,7 @@ public class TypeCheckingVisitor extends LOVisitor {
                     byte innerType = innerPlans.get(0).getSingleLeafPlanOutputType() ;
                     if (innerType != groupType) {
                         insertAtomicCastForJoinInnerPlan(innerPlans.get(0),
-                                                            frj,
+                                                            join,
                                                             groupType) ;
                     }
                 }
@@ -2313,7 +2314,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
                 // TODO: Don't recompute schema here
                 //Schema groupBySchema = schema.getField(0).schema ;
-                Schema groupBySchema = frj.getTupleJoinSchema() ;
+                Schema groupBySchema = join.getTupleJoinSchema() ;
 
                 // go through all inputs again to add cast if necessary
                 for(int i=0;i < inputs.size(); i++) {
@@ -2345,7 +2346,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
                         if (innerType != expectedType) {
                             insertAtomicCastForJoinInnerPlan(innerPlan,
-                                                                frj,
+                                                                join,
                                                                 expectedType) ;
                         }
                     }
@@ -2360,7 +2361,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
 
         try {
-            Schema outputSchema = frj.regenerateSchema() ;
+            Schema outputSchema = join.regenerateSchema() ;
         }
         catch (FrontendException fe) {
             int errCode = 1060;
@@ -2370,6 +2371,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
     }
 
+
     /**
      * COGroup
      * All group by cols from all inputs have to be of the
@@ -2502,6 +2504,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
     }
     
+    /*
     private void insertAtomicCastForFRJInnerPlan(LogicalPlan innerPlan,
             LOFRJoin frj, byte toType) throws VisitorException {
         if (!DataType.isUsableType(toType)) {
@@ -2531,7 +2534,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
         this.visit(cast);
     }
-
+*/
     private void insertAtomicCastForJoinInnerPlan(LogicalPlan innerPlan,
             LOJoin frj, byte toType) throws VisitorException {
         if (!DataType.isUsableType(toType)) {
@@ -2562,6 +2565,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         this.visit(cast);
     }
 
+
     // This helps insert casting to atomic types in COGroup's inner plans
     // as a new leave of the plan
     private void insertAtomicCastForCOGroupInnerPlan(LogicalPlan innerPlan,
diff --git a/src/org/apache/pig/pen/LineageTrimmingVisitor.java b/src/org/apache/pig/pen/LineageTrimmingVisitor.java
index 52ca5ab7d..d56de7b0c 100644
--- a/src/org/apache/pig/pen/LineageTrimmingVisitor.java
+++ b/src/org/apache/pig/pen/LineageTrimmingVisitor.java
@@ -420,9 +420,11 @@ public class LineageTrimmingVisitor extends LOVisitor {
     }
 
     private void processOperator(LogicalOperator op) {
+        if (op instanceof LOLoad) return;
+        
         continueTrimming = checkCompleteness(op);
 
-        if (op instanceof LOLoad || continueTrimming == false)
+        if (continueTrimming == false)
             return;
 
         LogicalOperator childOp = plan.getPredecessors(op).get(0);
diff --git a/test/org/apache/pig/test/TestPigServer.java b/test/org/apache/pig/test/TestPigServer.java
index 152c332dc..06cc986c1 100644
--- a/test/org/apache/pig/test/TestPigServer.java
+++ b/test/org/apache/pig/test/TestPigServer.java
@@ -504,7 +504,7 @@ public class TestPigServer extends TestCase {
         InputStream fileWithStdOutContents = new DataInputStream( new BufferedInputStream( new FileInputStream(stdOutRedirectedFile)));
         BufferedReader reader = new BufferedReader(new InputStreamReader(fileWithStdOutContents));
         while ((s = reader.readLine()) != null) {
-            assertTrue(s.equals("c: {a::field1: int,a::field2: float,a::field3: chararray,b::field4: bytearray,b::field5: double,b::field6: chararray}") == true);
+            assertTrue(s.equals("c: {field1: int,field2: float,field3: chararray,field4: bytearray,field5: double,field6: chararray}") == true);
         }
         fileWithStdOutContents.close();
     }
diff --git a/test/org/apache/pig/test/TestProjectionMap.java b/test/org/apache/pig/test/TestProjectionMap.java
index ac8d923b5..bde24b0c9 100644
--- a/test/org/apache/pig/test/TestProjectionMap.java
+++ b/test/org/apache/pig/test/TestProjectionMap.java
@@ -758,8 +758,8 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap.changes() == false);
         
-        //check cross projection map
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        //check frjoin projection map
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
         assertTrue(frjoinProjectionMap == null);
         
@@ -779,55 +779,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap.changes() == false);
         
-        //check cogroup projection map
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
-        assertTrue(cogroupProjectionMap.changes() == true);
-        
-        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
-        assertTrue(cogroupMapFields != null);
-        
-        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 0);
-        assertTrue(mapValues.get(1).getInputColumn().first == 1);
-        assertTrue(mapValues.get(1).getInputColumn().second == 0);
-        
-        //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
-        
-        //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
-        assertTrue(cogroupAddedFields.size() == 2);
-        assertTrue(cogroupAddedFields.get(0) == 1);
-        assertTrue(cogroupAddedFields.get(1) == 2);
-        
-        //check that the foreach projection map has non-null mappedFields
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
-        assertTrue(foreachProjectionMap.changes() == true);
-        
-        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
-        assertTrue(foreachMapFields != null);
-        
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 1);
-        
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 2);
-
-        //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
-        assertTrue(foreachRemovedFields.size() == 1);
-        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
-        assertTrue(removedField.first == 0);
-        assertTrue(removedField.second == 0);
-        
-        //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
-        assertTrue(foreachAddedFields == null);
+        //check join projection map
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        ProjectionMap joinProjectionMap = join.getProjectionMap();
+        assertTrue(joinProjectionMap == null);
     }
     
     @Test
@@ -1219,8 +1174,8 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap.changes() == false);
         
-        //check cross projection map
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        //check frjoin projection map
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
         assertTrue(frjoinProjectionMap != null);
         
@@ -1267,73 +1222,37 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap.changes() == false);
         
-        //check cogroup projection map
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
-        assertTrue(cogroupProjectionMap.changes() == true);
-        
-        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
-        assertTrue(cogroupMapFields != null);
-        
-        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 0);
-        assertTrue(mapValues.get(1).getInputColumn().first == 1);
-        assertTrue(mapValues.get(1).getInputColumn().second == 0);
-        
-        //check that removed fields is not null
-        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
-        assertTrue(cogroupRemovedFields != null);
+        //check join projection map
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        ProjectionMap joinProjectionMap = join.getProjectionMap();
+        assertTrue(joinProjectionMap != null);
         
-        Pair<Integer, Integer> removedFields = cogroupRemovedFields.get(0);
-        assertTrue(removedFields.first == 0);
-        assertTrue(removedFields.second == 1);
-
-        removedFields = cogroupRemovedFields.get(1);
-        assertTrue(removedFields.first == 1);
-        assertTrue(removedFields.second == 1);
+        MultiMap<Integer, ProjectionMap.Column> joinMapFields = joinProjectionMap.getMappedFields();
+        assertTrue(joinMapFields != null);
 
-        //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
-        assertTrue(cogroupAddedFields.size() == 2);
-        assertTrue(cogroupAddedFields.get(0) == 1);
-        assertTrue(cogroupAddedFields.get(1) == 2);
-        
-        //check that the foreach projection map has non-null mappedFields
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
-        assertTrue(foreachProjectionMap.changes() == true);
+        List<ProjectionMap.Column> frjoinMapValues = (ArrayList<ProjectionMap.Column>)joinMapFields.get(0);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 0);
         
-        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
-        assertTrue(foreachMapFields != null);
+        frjoinMapValues = (ArrayList<ProjectionMap.Column>)joinMapFields.get(1);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 1);
         
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 1);
+        frjoinMapValues = (ArrayList<ProjectionMap.Column>)joinMapFields.get(2);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 1);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 0);
         
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 1);
-
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(2);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 2);
-
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(3);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 2);
-
+        frjoinMapValues = (ArrayList<ProjectionMap.Column>)joinMapFields.get(3);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 1);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 1);
         
-        //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
-        assertTrue(foreachRemovedFields.size() == 1);
-        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
-        assertTrue(removedField.first == 0);
-        assertTrue(removedField.second == 0);
+        //check that removed fields is null
+        List<Pair<Integer, Integer>> joinRemovedFields = joinProjectionMap.getRemovedFields();
+        assertTrue(joinRemovedFields == null);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
-        assertTrue(foreachAddedFields == null);
+        List<Integer> joinAddedFields = joinProjectionMap.getAddedFields();
+        assertTrue(joinAddedFields == null);
     }
 
     @Test
@@ -1390,8 +1309,8 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap.changes() == false);
         
-        //check cross projection map
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        //check frjoin projection map
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
         assertTrue(frjoinProjectionMap == null);
         
@@ -1411,65 +1330,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap.changes() == false);
         
-        //check cogroup projection map
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
-        assertTrue(cogroupProjectionMap.changes() == true);
-        
-        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
-        assertTrue(cogroupMapFields != null);
-        
-        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 0);
-        assertTrue(mapValues.get(1).getInputColumn().first == 1);
-        assertTrue(mapValues.get(1).getInputColumn().second == 0);
-        
-        //check that removed fields is not null
-        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
-        assertTrue(cogroupRemovedFields.size() == 1);
-        
-        Pair<Integer, Integer> removedFields = cogroupRemovedFields.get(0);
-        assertTrue(removedFields.first == 0);
-        assertTrue(removedFields.second == 1);
-
-        //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
-        assertTrue(cogroupAddedFields.size() == 2);
-        assertTrue(cogroupAddedFields.get(0) == 1);
-        assertTrue(cogroupAddedFields.get(1) == 2);
-        
-        //check that the foreach projection map has non-null mappedFields
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
-        assertTrue(foreachProjectionMap.changes() == true);
-        
-        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
-        assertTrue(foreachMapFields.size() == 3);
-        
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 1);
-        
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 1);
-
-        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(2);
-        assertTrue(mapValues.get(0).getInputColumn().first == 0);
-        assertTrue(mapValues.get(0).getInputColumn().second == 2);
-
-        
-        //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
-        assertTrue(foreachRemovedFields.size() == 1);
-        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
-        assertTrue(removedField.first == 0);
-        assertTrue(removedField.second == 0);
-        
-        //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
-        assertTrue(foreachAddedFields == null);
+        //check join projection map
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        ProjectionMap joinProjectionMap = join.getProjectionMap();
+        assertTrue(joinProjectionMap == null);
     }
     
 }
diff --git a/test/org/apache/pig/test/TestPushDownForeachFlatten.java b/test/org/apache/pig/test/TestPushDownForeachFlatten.java
index 705d8c66a..386bf3210 100644
--- a/test/org/apache/pig/test/TestPushDownForeachFlatten.java
+++ b/test/org/apache/pig/test/TestPushDownForeachFlatten.java
@@ -607,7 +607,7 @@ public class TestPushDownForeachFlatten extends junit.framework.TestCase {
 
         LOLoad load = (LOLoad) lp.getRoots().get(0);
         LOLimit limit = (LOLimit) lp.getLeaves().get(0);
-        LOFRJoin frjoin = (LOFRJoin)lp.getPredecessors(limit).get(0);
+        LOJoin frjoin = (LOJoin)lp.getPredecessors(limit).get(0);
         LOForEach foreach = (LOForEach) lp.getPredecessors(frjoin).get(0);
         
         Schema limitSchema = limit.getSchema();
@@ -656,7 +656,7 @@ public class TestPushDownForeachFlatten extends junit.framework.TestCase {
 
         LOLoad load = (LOLoad) lp.getRoots().get(1);
         LOLimit limit = (LOLimit) lp.getLeaves().get(0);
-        LOFRJoin frjoin = (LOFRJoin)lp.getPredecessors(limit).get(0);
+        LOJoin frjoin = (LOJoin)lp.getPredecessors(limit).get(0);
         LOForEach foreach = (LOForEach) lp.getPredecessors(frjoin).get(1);
         
         Schema limitSchema = limit.getSchema();
@@ -798,12 +798,38 @@ public class TestPushDownForeachFlatten extends junit.framework.TestCase {
         
         PushDownForeachFlatten pushDownForeach = new PushDownForeachFlatten(lp);
 
-        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOJoin join = (LOJoin)lp.getPredecessors(limit).get(0);
+        LOForEach foreach = (LOForEach) lp.getPredecessors(join).get(0);
         
-        assertTrue(!pushDownForeach.check(lp.getSuccessors(loada)));
+        Schema limitSchema = limit.getSchema();
+        
+        assertTrue(pushDownForeach.check(lp.getSuccessors(load)));
         assertTrue(pushDownForeach.getSwap() == false);
-        assertTrue(pushDownForeach.getInsertBetween() == false);
-        assertTrue(pushDownForeach.getFlattenedColumnMap() == null);
+        assertTrue(pushDownForeach.getInsertBetween() == true);
+        assertTrue(pushDownForeach.getFlattenedColumnMap() != null);
+
+        pushDownForeach.transform(lp.getSuccessors(load));
+        
+        planTester.rebuildSchema(lp);
+        
+        for(Boolean b: foreach.getFlatten()) {
+            assertEquals(b.booleanValue(), false);
+        }
+        
+        LOForEach newForeach = (LOForEach)lp.getSuccessors(join).get(0);
+        
+        
+        List<Boolean> newForeachFlatten = newForeach.getFlatten();
+        Map<Integer, Integer> remap = pushDownForeach.getFlattenedColumnMap();        
+        for(Integer key: remap.keySet()) {
+            Integer value = remap.get(key);
+            assertEquals(newForeachFlatten.get(value).booleanValue(), true);
+        }
+        
+        assertTrue(Schema.equals(limitSchema, limit.getSchema(), false, true));        
+
     }
     
     @Test
@@ -820,12 +846,38 @@ public class TestPushDownForeachFlatten extends junit.framework.TestCase {
         
         PushDownForeachFlatten pushDownForeach = new PushDownForeachFlatten(lp);
 
-        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        LOLoad load = (LOLoad) lp.getRoots().get(1);
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOJoin join = (LOJoin)lp.getPredecessors(limit).get(0);
+        LOForEach foreach = (LOForEach) lp.getPredecessors(join).get(1);
+        
+        Schema limitSchema = limit.getSchema();
         
-        assertTrue(!pushDownForeach.check(lp.getSuccessors(loadb)));
+        assertTrue(pushDownForeach.check(lp.getSuccessors(load)));
         assertTrue(pushDownForeach.getSwap() == false);
-        assertTrue(pushDownForeach.getInsertBetween() == false);
-        assertTrue(pushDownForeach.getFlattenedColumnMap() == null);
+        assertTrue(pushDownForeach.getInsertBetween() == true);
+        assertTrue(pushDownForeach.getFlattenedColumnMap() != null);
+
+        pushDownForeach.transform(lp.getSuccessors(load));
+        
+        planTester.rebuildSchema(lp);
+        
+        for(Boolean b: foreach.getFlatten()) {
+            assertEquals(b.booleanValue(), false);
+        }
+        
+        LOForEach newForeach = (LOForEach)lp.getSuccessors(join).get(0);
+        
+        
+        List<Boolean> newForeachFlatten = newForeach.getFlatten();
+        Map<Integer, Integer> remap = pushDownForeach.getFlattenedColumnMap();        
+        for(Integer key: remap.keySet()) {
+            Integer value = remap.get(key);
+            assertEquals(newForeachFlatten.get(value).booleanValue(), true);
+        }
+        
+        assertTrue(Schema.equals(limitSchema, limit.getSchema(), false, true));       
+
     }
 
 
diff --git a/test/org/apache/pig/test/TestPushUpFilter.java b/test/org/apache/pig/test/TestPushUpFilter.java
index 040b36b64..753cd76bc 100644
--- a/test/org/apache/pig/test/TestPushUpFilter.java
+++ b/test/org/apache/pig/test/TestPushUpFilter.java
@@ -868,7 +868,7 @@ public class TestPushUpFilter extends junit.framework.TestCase {
 
         LOLimit limit = (LOLimit) lp.getLeaves().get(0);
         LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
-        LOFRJoin frjoin = (LOFRJoin)lp.getPredecessors(filter).get(0);
+        LOJoin frjoin = (LOJoin)lp.getPredecessors(filter).get(0);
 
         assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
         assertTrue(pushUpFilter.getSwap() == false);
@@ -898,7 +898,7 @@ public class TestPushUpFilter extends junit.framework.TestCase {
 
         LOLimit limit = (LOLimit) lp.getLeaves().get(0);
         LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
-        LOFRJoin frjoin = (LOFRJoin)lp.getPredecessors(filter).get(0);
+        LOJoin frjoin = (LOJoin)lp.getPredecessors(filter).get(0);
 
         assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
         assertTrue(pushUpFilter.getSwap() == false);
@@ -957,19 +957,61 @@ public class TestPushUpFilter extends junit.framework.TestCase {
         planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
         planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
         planTester.buildPlan("C = join A by $0, B by $0;");        
-        LogicalPlan lp = planTester.buildPlan("D = filter C by $0 < 'name';");
+        planTester.buildPlan("D = filter C by $0 < 'name';");
+        LogicalPlan lp = planTester.buildPlan("E = limit D 10;");
         
         planTester.setPlan(lp);
         planTester.setProjectionMap(lp);
         
         PushUpFilter pushUpFilter = new PushUpFilter(lp);
         
-        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
+        LOJoin join = (LOJoin)lp.getPredecessors(filter).get(0);
+        
+        assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
         assertTrue(pushUpFilter.getSwap() == false);
-        assertTrue(pushUpFilter.getPushBefore() == false);
-        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        assertTrue(pushUpFilter.getPushBefore() == true);
+        assertTrue(pushUpFilter.getPushBeforeInput() == 0);
+
+        
+        pushUpFilter.transform(lp.getPredecessors(limit));
+        
+        assertEquals(join, lp.getPredecessors(limit).get(0));
+        assertEquals(filter, lp.getPredecessors(join).get(0));
         
     }
+
+    @Test
+    public void testFilterInnerJoin1() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0;");        
+        planTester.buildPlan("D = filter C by $4 < 'name';");
+        LogicalPlan lp = planTester.buildPlan("E = limit D 10;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
+        LOJoin join = (LOJoin)lp.getPredecessors(filter).get(0);
+        
+        assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == true);
+        assertTrue(pushUpFilter.getPushBeforeInput() == 1);
+
+        
+        pushUpFilter.transform(lp.getPredecessors(limit));
+        
+        assertEquals(join, lp.getPredecessors(limit).get(0));
+        assertEquals(filter, lp.getPredecessors(join).get(1));
+        
+    }
+
     
     @Test
     public void testFilterConstantConditionInnerJoin() throws Exception {
diff --git a/test/org/apache/pig/test/TestRequiredFields.java b/test/org/apache/pig/test/TestRequiredFields.java
index b37e71b1c..94ec89ed4 100644
--- a/test/org/apache/pig/test/TestRequiredFields.java
+++ b/test/org/apache/pig/test/TestRequiredFields.java
@@ -878,7 +878,7 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.getFields() == null);
 
         //check frjoin required fields
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
         assertTrue(frjoinRequiredFields.size() == 2);
         
@@ -926,12 +926,12 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.needAllFields() == false);
         assertTrue(requiredField.getFields() == null);
 
-        //check cogroup required fields
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
-        assertTrue(cogroupRequiredFields.size() == 2);
+        //check join required fields
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> joinRequiredFields = join.getRequiredFields();
+        assertTrue(joinRequiredFields.size() == 2);
         
-        requiredField = cogroupRequiredFields.get(0);
+        requiredField = joinRequiredFields.get(0);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
 
@@ -939,28 +939,16 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(fields.size() == 1);
         assertTrue(fields.get(0).first == 0);
         assertTrue(fields.get(0).second == 0);
-        
-        requiredField = cogroupRequiredFields.get(1);
+
+
+        requiredField = joinRequiredFields.get(1);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
-
+        
         fields = requiredField.getFields(); 
         assertTrue(fields.size() == 1);
         assertTrue(fields.get(0).first == 1);
         assertTrue(fields.get(0).second == 0);
-        
-        //check that the foreach required fields contain [<0, 1>, <0, 2>]
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
-        assertTrue(foreachRequiredFields.size() == 1);
-
-        requiredField = foreachRequiredFields.get(0);
-        fields = requiredField.getFields(); 
-        assertTrue(fields.size() == 2);
-        assertTrue(fields.get(0).first == 0);
-        assertTrue(fields.get(0).second == 1);
-        assertTrue(fields.get(1).first == 0);
-        assertTrue(fields.get(1).second == 2);
 
     }
 
@@ -1376,7 +1364,7 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.getFields() == null);
 
         //check frjoin required fields
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
         assertTrue(frjoinRequiredFields.size() == 2);
         
@@ -1425,12 +1413,12 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.needAllFields() == false);
         assertTrue(requiredField.getFields() == null);
 
-        //check cogroup required fields
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
-        assertTrue(cogroupRequiredFields.size() == 2);
+        //check join required fields
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> joinRequiredFields = join.getRequiredFields();
+        assertTrue(joinRequiredFields.size() == 2);
         
-        requiredField = cogroupRequiredFields.get(0);
+        requiredField = joinRequiredFields.get(0);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
 
@@ -1438,29 +1426,16 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(fields.size() == 1);
         assertTrue(fields.get(0).first == 0);
         assertTrue(fields.get(0).second == 0);
-        
-        requiredField = cogroupRequiredFields.get(1);
+
+
+        requiredField = joinRequiredFields.get(1);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
-
+        
         fields = requiredField.getFields(); 
         assertTrue(fields.size() == 1);
         assertTrue(fields.get(0).first == 1);
         assertTrue(fields.get(0).second == 0);
-        
-        //check that the foreach required fields contain [<0, 1>, <0, 2>]
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
-        assertTrue(foreachRequiredFields.size() == 1);
-
-        requiredField = foreachRequiredFields.get(0);
-        fields = requiredField.getFields(); 
-        assertTrue(fields.size() == 2);
-        assertTrue(fields.get(0).first == 0);
-        assertTrue(fields.get(0).second == 1);
-        assertTrue(fields.get(1).first == 0);
-        assertTrue(fields.get(1).second == 2);
-
     }
 
     @Test
@@ -1569,7 +1544,7 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.getFields() == null);
 
         //check frjoin required fields
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
         assertTrue(frjoinRequiredFields.size() == 2);
         
@@ -1618,12 +1593,12 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.needAllFields() == false);
         assertTrue(requiredField.getFields() == null);
 
-        //check cogroup required fields
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
-        assertTrue(cogroupRequiredFields.size() == 2);
+        //check join required fields
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> joinRequiredFields = join.getRequiredFields();
+        assertTrue(joinRequiredFields.size() == 2);
         
-        requiredField = cogroupRequiredFields.get(0);
+        requiredField = joinRequiredFields.get(0);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
 
@@ -1631,28 +1606,17 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(fields.size() == 1);
         assertTrue(fields.get(0).first == 0);
         assertTrue(fields.get(0).second == 0);
-        
-        requiredField = cogroupRequiredFields.get(1);
+
+
+        requiredField = joinRequiredFields.get(1);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
-
+        
         fields = requiredField.getFields(); 
         assertTrue(fields.size() == 1);
         assertTrue(fields.get(0).first == 1);
         assertTrue(fields.get(0).second == 0);
-        
-        //check that the foreach required fields contain [<0, 1>, <0, 2>]
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
-        assertTrue(foreachRequiredFields.size() == 1);
 
-        requiredField = foreachRequiredFields.get(0);
-        fields = requiredField.getFields(); 
-        assertTrue(fields.size() == 2);
-        assertTrue(fields.get(0).first == 0);
-        assertTrue(fields.get(0).second == 1);
-        assertTrue(fields.get(1).first == 0);
-        assertTrue(fields.get(1).second == 2);
     }
 
     @Test
@@ -1776,7 +1740,7 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.getFields() == null);
 
         //check frjoin required fields
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
         assertTrue(frjoinRequiredFields.size() == 2);
         
@@ -1816,33 +1780,21 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.needAllFields() == false);
         assertTrue(requiredField.getFields() == null);
 
-        //check cogroup required fields
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
-        assertTrue(cogroupRequiredFields.size() == 2);
+        //check join required fields
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> joinRequiredFields = join.getRequiredFields();
+        assertTrue(joinRequiredFields.size() == 2);
         
-        requiredField = cogroupRequiredFields.get(0);
+        requiredField = joinRequiredFields.get(0);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == true);
         assertTrue(requiredField.getFields() == null);
 
-        requiredField = cogroupRequiredFields.get(1);
+        requiredField = joinRequiredFields.get(1);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == true);
         assertTrue(requiredField.getFields() == null);
 
-        //check that the foreach required fields contain [<0, 1>, <0, 2>]
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
-        assertTrue(foreachRequiredFields.size() == 1);
-
-        requiredField = foreachRequiredFields.get(0);
-        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
-        assertTrue(fields.size() == 2);
-        assertTrue(fields.get(0).first == 0);
-        assertTrue(fields.get(0).second == 1);
-        assertTrue(fields.get(1).first == 0);
-        assertTrue(fields.get(1).second == 2);
     }
 
     @Test
@@ -2026,7 +1978,7 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.getFields() == null);
 
         //check frjoin required fields
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
         assertTrue(frjoinRequiredFields.size() == 2);
         
@@ -2078,12 +2030,12 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(requiredField.needAllFields() == false);
         assertTrue(requiredField.getFields() == null);
 
-        //check cogroup required fields
-        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
-        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
-        assertTrue(cogroupRequiredFields.size() == 2);
+        //check join required fields
+        LOJoin join = (LOJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> joinRequiredFields = join.getRequiredFields();
+        assertTrue(joinRequiredFields.size() == 2);
         
-        requiredField = cogroupRequiredFields.get(0);
+        requiredField = joinRequiredFields.get(0);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
 
@@ -2093,30 +2045,17 @@ public class TestRequiredFields extends junit.framework.TestCase {
         assertTrue(fields.get(0).second == 0);
         assertTrue(fields.get(1).first == 0);
         assertTrue(fields.get(1).second == 1);
-        
-        requiredField = cogroupRequiredFields.get(1);
+
+        requiredField = joinRequiredFields.get(1);
         assertTrue(requiredField.needNoFields() == false);
         assertTrue(requiredField.needAllFields() == false);
-
+        
         fields = requiredField.getFields(); 
         assertTrue(fields.size() == 2);
         assertTrue(fields.get(0).first == 1);
         assertTrue(fields.get(0).second == 0);
         assertTrue(fields.get(1).first == 1);
         assertTrue(fields.get(1).second == 1);
-        
-        //check that the foreach required fields contain [<0, 1>, <0, 2>]
-        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
-        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
-        assertTrue(foreachRequiredFields.size() == 1);
-
-        requiredField = foreachRequiredFields.get(0);
-        fields = requiredField.getFields(); 
-        assertTrue(fields.size() == 2);
-        assertTrue(fields.get(0).first == 0);
-        assertTrue(fields.get(0).second == 1);
-        assertTrue(fields.get(1).first == 0);
-        assertTrue(fields.get(1).second == 2);
 
     }
     
diff --git a/test/org/apache/pig/test/TestRewire.java b/test/org/apache/pig/test/TestRewire.java
index 21c673c8f..d5d20f771 100644
--- a/test/org/apache/pig/test/TestRewire.java
+++ b/test/org/apache/pig/test/TestRewire.java
@@ -259,7 +259,7 @@ public class TestRewire extends junit.framework.TestCase {
         planTester.setProjectionMap(lp);
         
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         LOFilter filter = (LOFilter)lp.getSuccessors(frjoin).get(0);
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         
@@ -277,7 +277,7 @@ public class TestRewire extends junit.framework.TestCase {
         assertTrue(filterProject.getCol() == 0);
         
         
-        LogicalPlan joinPlan = ((List<LogicalPlan>)(frjoin.getJoinColPlans().get(filter))).get(0);
+        LogicalPlan joinPlan = ((List<LogicalPlan>)(frjoin.getJoinPlans().get(filter))).get(0);
         LOProject joinProject = (LOProject)joinPlan.getRoots().get(0);
         assertTrue(joinProject.getExpression().equals(filter));
         
@@ -357,7 +357,7 @@ public class TestRewire extends junit.framework.TestCase {
         planTester.setProjectionMap(lp);
         
         LOLoad loada = (LOLoad) lp.getRoots().get(0);
-        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        LOJoin frjoin = (LOJoin)lp.getSuccessors(loada).get(0);
         LOFilter filter = (LOFilter)lp.getSuccessors(frjoin).get(0);
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         
