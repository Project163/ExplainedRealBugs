diff --git a/CHANGES.txt b/CHANGES.txt
index 0dd6ed23a..03793e45b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -157,6 +157,8 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-1289: PIG Join fails while doing a filter on joined data (daijy)
+
 PIG-1266: Show spill count on the pig console at the end of the job (sriranjan
 via rding)
 
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
index 5958adb28..ea0630b9d 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
@@ -31,6 +31,7 @@ import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.LOCast;
 import org.apache.pig.impl.logicalLayer.LOCogroup;
 import org.apache.pig.impl.logicalLayer.LOCross;
+import org.apache.pig.impl.logicalLayer.LOIsNull;
 import org.apache.pig.impl.logicalLayer.LOJoin;
 import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOForEach;
@@ -231,8 +232,32 @@ public class PushUpFilter extends LogicalTransformer {
                         return false;
                     }
                 }
-                mPushBefore = true;
+                
                 mPushBeforeInput = grandParentIndexes.iterator().next();
+                
+                if (predecessor instanceof LOJoin) {
+                    boolean otherBranchContainOuter = false;
+                    boolean sawInner = false;
+                    for (int i=0;i<=mPlan.getSuccessors(predecessor).size();i++) {
+                        // We do not push filter if any other branch is outer
+                        // See PIG-1289
+                        // Also in LOJoin, innerFlag==true indicate that branch is the outer join side
+                        // which has the exact opposite semantics
+                        // If all innerFlag is true, that implies a regular join
+                        if (i!=mPushBeforeInput && ((LOJoin)predecessor).getInnerFlags()[i]) {
+                            otherBranchContainOuter = true;
+                        }
+                        if (((LOJoin)predecessor).getInnerFlags()[i]==false) {
+                            sawInner = true;
+                        }
+                    }
+                    if (otherBranchContainOuter && sawInner) {
+                        mPushBeforeInput = -1;
+                        return false;
+                    }
+                }
+                
+                mPushBefore = true;
                 return true;
 
             } else if (predecessor instanceof LOForEach) {
diff --git a/test/org/apache/pig/test/TestPushUpFilter.java b/test/org/apache/pig/test/TestPushUpFilter.java
index d68b58a03..1c61697eb 100644
--- a/test/org/apache/pig/test/TestPushUpFilter.java
+++ b/test/org/apache/pig/test/TestPushUpFilter.java
@@ -1068,6 +1068,24 @@ public class TestPushUpFilter extends junit.framework.TestCase {
         assertTrue(pushUpFilter.getPushBefore() == false);
         assertTrue(pushUpFilter.getPushBeforeInput() == -1);
     }
+    
+    @Test
+    public void testOutJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name);");
+        planTester.buildPlan("C = join A by name LEFT OUTER, B by name;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by B::name is null;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+    }
 
 }
 
