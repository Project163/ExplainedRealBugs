diff --git a/CHANGES.txt b/CHANGES.txt
index aa55c8f54..2086cfc9a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -157,6 +157,8 @@ flatten correctly if flattened bag is not used later (daijy)
 PIG-1189: StoreFunc UDF should ship to the backend automatically without
 "register" (daijy)
 
+PIG-1212: LogicalPlan.replaceAndAddSucessors produce wrong result when successors are null (daijy)
+
 Release 0.6.0 - Unreleased
 
 INCOMPATIBLE CHANGES
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index 6eb3087e8..9ccc48883 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -864,7 +864,9 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
            }
        }
        mFromEdges.removeKey(node);
-       mFromEdges.put(node,newSuccessors);
+       if (!newSuccessors.isEmpty()) {
+           mFromEdges.put(node,newSuccessors);
+       }
     }    
 
     // removes entry  for predecessor in list of predecessors of node, 
@@ -885,7 +887,9 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
            }
        }
        mToEdges.removeKey(node);
-       mToEdges.put(node,newPredecessors);
+       if (!newPredecessors.isEmpty()) {
+           mToEdges.put(node,newPredecessors);
+       }
     }
     
     /**
diff --git a/test/org/apache/pig/test/TestOperatorPlan.java b/test/org/apache/pig/test/TestOperatorPlan.java
index 439cfd38e..1780d49ba 100644
--- a/test/org/apache/pig/test/TestOperatorPlan.java
+++ b/test/org/apache/pig/test/TestOperatorPlan.java
@@ -17,6 +17,8 @@
  */
 package org.apache.pig.test;
 
+import java.io.ByteArrayOutputStream;
+import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -2948,5 +2950,38 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         
     }
 
+    // See PIG-1212
+    @Test
+    public void testPushBefore2() throws Exception {
+        TPlan plan = new TPlan();
+        TOperator[] ops = new TOperator[6];
+        
+        ops[0] = new SingleOperator("Load0");
+        ops[1] = new SingleOperator("Load1");
+        ops[2] = new SingleOperator("ForEach0");
+        ops[3] = new SingleOperator("ForEach1");
+        ops[4] = new MultiOperator("Join");
+        ops[5] = new SingleOperator("Filter");
+        
+        for (int i=0;i<6;i++)
+        	plan.add(ops[i]);
+        
+        plan.connect(ops[0], ops[2]);
+        plan.connect(ops[1], ops[3]);
+        plan.connect(ops[2], ops[4]);
+        plan.connect(ops[3], ops[4]);
+        plan.connect(ops[4], ops[5]);
+        
+        try {
+            plan.pushBefore(ops[4], ops[5], 0);
+            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+            PrintStream ps = new PrintStream(baos);
+            PlanPrinter<TOperator, TPlan> planPrinter = new PlanPrinter<TOperator, TPlan>(ps, plan);
+            planPrinter.visit();
+            assertFalse(baos.toString().equals(""));
+        } catch (PlanException pe) {
+        }        
+    }
+
 }
 
