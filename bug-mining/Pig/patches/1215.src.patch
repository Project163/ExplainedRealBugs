diff --git a/CHANGES.txt b/CHANGES.txt
index 11b1c0157..2efe78b6b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -196,6 +196,8 @@ PIG-3013: BinInterSedes improve chararray sort performance (rohini)
 
 BUG FIXES
 
+PIG-3355: ColumnMapKeyPrune bug with distinct operator (jeremykarn via aniket486)
+
 PIG-3318: AVRO: 'default value' not honored when merging schemas on load with AvroStorage (viraj via rohini)
 
 PIG-3250: Pig dryrun generates wrong output in .expanded file for 'SPLIT....OTHERWISE...' command (dreambird via cheolsoo)
diff --git a/src/org/apache/pig/newplan/logical/rules/ColumnPruneHelper.java b/src/org/apache/pig/newplan/logical/rules/ColumnPruneHelper.java
index 19e7628a9..bfd816790 100644
--- a/src/org/apache/pig/newplan/logical/rules/ColumnPruneHelper.java
+++ b/src/org/apache/pig/newplan/logical/rules/ColumnPruneHelper.java
@@ -330,6 +330,8 @@ public class ColumnPruneHelper {
 
         @Override
         public void visit(LODistinct distinct) throws FrontendException {
+            setOutputUids(distinct);
+            
             Set<Long> input = new HashSet<Long>();
 
             // Every field is required
diff --git a/test/org/apache/pig/test/TestNewPlanColumnPrune.java b/test/org/apache/pig/test/TestNewPlanColumnPrune.java
index 4b4f4df69..cc485c1f1 100644
--- a/test/org/apache/pig/test/TestNewPlanColumnPrune.java
+++ b/test/org/apache/pig/test/TestNewPlanColumnPrune.java
@@ -20,11 +20,13 @@ package org.apache.pig.test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
@@ -418,6 +420,36 @@ public class TestNewPlanColumnPrune {
         }
     }
 
+    @Test
+    public void testDistinct() throws Exception {
+        //Test for bug where distinct wasn't being pruned properly causing union 
+        //to fail to get a schema since the distinct relation had an incompatible schema
+        //with the other relation being unioned.
+        
+        String testQuery = 
+                "a = load 'd.txt' as (id, v1, v2);" +
+                "b = load 'd.txt' as (id, v1, v2);" +
+                "c = distinct a;" +
+                "d = union b, c;" +
+                "e = foreach d generate id, v1;" +
+                "store e into 'empty';";
+        
+        //Generate optimized plan.
+        LogicalPlan newLogicalPlan = buildPlan(testQuery);
+        PlanOptimizer optimizer = new MyPlanOptimizer(newLogicalPlan, 3);
+        optimizer.optimize();
+        
+        Iterator<Operator> iter = newLogicalPlan.getOperators();
+        while (iter.hasNext()) {
+            Operator o = iter.next();
+            LogicalRelationalOperator lro = (LogicalRelationalOperator)o;
+            if (lro == null || lro.getAlias() == null) continue;
+            if (lro.getAlias().equals("d")) {
+                assertNotNull(lro.getSchema());
+            }
+        }
+    }
+
     public class MyPlanOptimizer extends LogicalPlanOptimizer {
 
         protected MyPlanOptimizer(OperatorPlan p,  int iterations) {
