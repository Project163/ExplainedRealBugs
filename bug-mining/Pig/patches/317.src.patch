diff --git a/CHANGES.txt b/CHANGES.txt
index 0fd18b246..06c2fd8f1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -256,6 +256,9 @@ PIG-1060: MultiQuery optimization throws error for multi-level splits (rding via
 PIG-1128: column pruning causing failure when foreach has user-specified
 schema (daijy)
 
+PIG-1127: Logical operator should contains individual copy of schema object
+(daijy)
+
 Release 0.5.0
 
 INCOMPATIBLE CHANGES
diff --git a/src/org/apache/pig/impl/logicalLayer/LODistinct.java b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
index 5776f6501..9dcae872e 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODistinct.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
@@ -75,9 +75,17 @@ public class LODistinct extends RelationalOperator {
                     } else {
                         fss.add(fs);
                         mSchema = new Schema(fss);
+                        for (int i=0;i<getInput().getSchema().size();i++)
+                            mSchema.getField(i).setParent(getInput().getSchema().getField(i).canonicalName, getInput());
                     }
                 } else {
-                    mSchema = op.getSchema();
+                    if (op.getSchema()!=null) {
+                        mSchema = new Schema(op.getSchema());
+                        for (int i=0;i<op.getSchema().size();i++)
+                            mSchema.getField(i).setParent(op.getSchema().getField(i).canonicalName, op);
+                    }
+                    else
+                        mSchema = null;
                 }
                 mIsSchemaComputed = true;
             } catch (FrontendException ioe) {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFilter.java b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
index d00dbc077..aa0050dd8 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
@@ -83,7 +83,13 @@ public class LOFilter extends RelationalOperator {
                         mSchema = new Schema(fss);
                     }
                 } else {
-                    mSchema = input.getSchema();
+                    if (getInput().getSchema()!=null) {
+                        mSchema = new Schema(input.getSchema());
+                        for (int i=0;i<getInput().getSchema().size();i++)
+                            mSchema.getField(i).setParent(getInput().getSchema().getField(i).canonicalName, getInput());
+                    }
+                    else
+                        mSchema = null;
                 }
                 mIsSchemaComputed = true;
             } catch (FrontendException ioe) {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLimit.java b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
index 32ffb5b2f..d50e21e67 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLimit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
@@ -63,7 +63,13 @@ public class LOLimit extends RelationalOperator {
     public Schema getSchema() throws FrontendException {
         if (!mIsSchemaComputed) {
             try {
-                mSchema = getInput().getSchema();
+                if (getInput().getSchema()!=null) {
+                    mSchema = new Schema(getInput().getSchema());
+                    for (int i=0;i<getInput().getSchema().size();i++)
+                        mSchema.getField(i).setParent(getInput().getSchema().getField(i).canonicalName, getInput());
+                }
+                else
+                    mSchema = null;
                 mIsSchemaComputed = true;
             } catch (FrontendException ioe) {
                 mSchema = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSort.java b/src/org/apache/pig/impl/logicalLayer/LOSort.java
index 342aad5b4..cc663ad47 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSort.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSort.java
@@ -155,7 +155,13 @@ public class LOSort extends RelationalOperator {
                         mSchema = new Schema(fss);
                     }
                 } else {
-                    mSchema = op.getSchema();
+                    if (getInput().getSchema()!=null) {
+                        mSchema = new Schema(op.getSchema());
+                        for (int i=0;i<getInput().getSchema().size();i++)
+                            mSchema.getField(i).setParent(getInput().getSchema().getField(i).canonicalName, getInput());
+                    }
+                    else
+                        mSchema = null;
                 }
                 mIsSchemaComputed = true;
             } catch (FrontendException ioe) {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplit.java b/src/org/apache/pig/impl/logicalLayer/LOSplit.java
index 1bb971dad..44ad1781f 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplit.java
@@ -86,7 +86,14 @@ public class LOSplit extends RelationalOperator {
                     String msg = "Could not find operator in plan";
                     throw new FrontendException(msg, errCode, PigException.INPUT, false, null);
                 }
-                mSchema = s.iterator().next().getSchema();
+                LogicalOperator input = s.iterator().next();
+                if (input.getSchema()!=null) {
+                    mSchema = new Schema(input.getSchema());
+                    for (int i=0;i<input.getSchema().size();i++)
+                        mSchema.getField(i).setParent(input.getSchema().getField(i).canonicalName, input);
+                }
+                else
+                    mSchema = null;
                 mIsSchemaComputed = true;
             } catch (FrontendException ioe) {
                 mSchema = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
index 24d49a0c9..ea978317e 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
@@ -89,7 +89,13 @@ public class LOSplitOutput extends RelationalOperator {
                     String msg = "Could not find operator in plan";
                     throw new FrontendException(msg, errCode, PigException.INPUT, false, null);
                 }
-                mSchema = input.getSchema();
+                if (input.getSchema()!=null) {
+                    mSchema = new Schema(input.getSchema());
+                    for (int i=0;i<input.getSchema().size();i++)
+                        mSchema.getField(i).setParent(input.getSchema().getField(i).canonicalName, input);
+                }
+                else
+                    mSchema = null;
                 mIsSchemaComputed = true;
             } catch (FrontendException fe) {
                 mSchema = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index d571c0905..acc74855b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -71,7 +71,10 @@ public class LOUnion extends RelationalOperator {
                     String msg = "Could not find operator in plan";
                     throw new FrontendException(msg, errCode, PigException.INPUT, false, null);
                 }
-                mSchema = op.getSchema();
+                if (op.getSchema()!=null)
+                    mSchema = new Schema(op.getSchema());
+                else
+                    mSchema = null;
                 while(iter.hasNext()) {
                     op = iter.next();
                     if(null != mSchema) {
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 4f3e70db8..d7825b75c 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -3126,14 +3126,6 @@ public class TypeCheckingVisitor extends LOVisitor {
                 HandleSpec streamOutputSpec = command.getOutputSpec(); 
                 FuncSpec streamLoaderSpec = new FuncSpec(streamOutputSpec.getSpec());
                 return streamLoaderSpec;
-            } else if ((op instanceof LOFilter)
-                    || (op instanceof LODistinct)
-                    || (op instanceof LOSort)
-                    || (op instanceof LOSplit)
-                    || (op instanceof LOSplitOutput)
-                    || (op instanceof LOLimit)) {
-                LogicalPlan lp = op.getPlan();
-                return getLoadFuncSpec(lp.getPredecessors(op).get(0), parentCanonicalName);        
             }
             
             Schema s = op.getSchema();
diff --git a/test/org/apache/pig/test/TestPruneColumn.java b/test/org/apache/pig/test/TestPruneColumn.java
index bd3145be1..b61e05d3b 100644
--- a/test/org/apache/pig/test/TestPruneColumn.java
+++ b/test/org/apache/pig/test/TestPruneColumn.java
@@ -53,6 +53,7 @@ public class TestPruneColumn extends TestCase {
     File tmpFile7;
     File tmpFile8;
     File tmpFile9;
+    File tmpFile10;
     File logFile;
     Logger logger;
 
@@ -139,6 +140,10 @@ public class TestPruneColumn extends TestCase {
         ps.println("2\t[key1#2,key2#4]\t[key3#8,key4#9]");
         ps.close();
 
+        tmpFile10 = File.createTempFile("prune", "txt");
+        ps = new PrintStream(new FileOutputStream(tmpFile10));
+        ps.println("1\t[1#1,2#1]\t2");
+        ps.close();
 
     }
     
@@ -1477,4 +1482,23 @@ public class TestPruneColumn extends TestCase {
         assertTrue(checkLogFileMessage(new String[]{"Columns pruned for A: $1", 
                 "No map keys pruned for A"}));
     }
+
+    // See PIG-1127
+    @Test
+    public void testSharedSchemaObject() throws Exception {
+        pigServer.registerQuery("A = load '"+ Util.generateURI(tmpFile10.toString()) + "' AS (a0, a1:map[], a2);");
+        pigServer.registerQuery("B = foreach A generate a1;");
+        pigServer.registerQuery("C = limit B 10;");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("C");
+        
+        assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+        assertTrue(t.toString().equals("([2#1,1#1])"));
+        
+        assertFalse(iter.hasNext());
+        
+        assertTrue(checkLogFileMessage(new String[]{"Columns pruned for A: $0, $2", 
+                "No map keys pruned for A"}));
+     } 
 }
