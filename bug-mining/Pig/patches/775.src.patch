diff --git a/CHANGES.txt b/CHANGES.txt
index e875b82b0..02592b47d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -60,6 +60,8 @@ PIG-2011: Speed up TestTypedMap.java (dvryaboy)
 
 BUG FIXES
 
+PIG-2144: ClassCastException when using IsEmpty(DIFF()) (thejas)
+
 PIG-2139: LogicalExpressionSimplifier optimizer rule should check if udf is
  deterministic while checking if they are equal (thejas)
 
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 68c3c57ae..cccdfa24f 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -1046,20 +1046,6 @@ public class PigServer {
                 return;
             }
             PhysicalPlan pp = compilePp();
-
-            HashSet<String> optimizerRules = null;
-            try {
-                optimizerRules = (HashSet<String>) ObjectSerializer.deserialize(
-                        pigContext.getProperties().getProperty("pig.optimizer.rules") );
-            } catch (IOException ioe) {
-                int errCode = 2110;
-                String msg = "Unable to deserialize optimizer rules.";
-                throw new FrontendException(msg, errCode, PigException.BUG, ioe);
-            }
-
-            LogicalPlanOptimizer optimizer = new LogicalPlanOptimizer( currDAG.lp, 3, optimizerRules );
-            optimizer.optimize();
-
             currDAG.lp.explain(lps, format, verbose);
 
             pp.explain(pps, format, verbose);
diff --git a/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java b/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
index 8fa53f689..70fdf5c41 100644
--- a/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
+++ b/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
@@ -265,8 +265,16 @@ class NOTConversionVisitor extends LogicalExpressionVisitor {
                 if (seen.add(suc)) {
                     if (suc instanceof NotExpression)
                         ((NOTConversionVisitor) visitor).flip();
-                    Collection<Operator> newSuccessors = Utils.mergeCollection(plan.getSuccessors(suc), plan.getSoftLinkSuccessors(suc));
-                    depthFirst(suc, newSuccessors, seen, visitor);
+                    if(suc instanceof AndExpression
+                            || suc instanceof NotExpression
+                            || suc instanceof OrExpression
+                    ){
+                        //visit successors of suc only if they are the boolean operators
+                        // the NOT conversion should be propagated only for 
+                        // their successors 
+                        Collection<Operator> newSuccessors = Utils.mergeCollection(plan.getSuccessors(suc), plan.getSoftLinkSuccessors(suc));
+                        depthFirst(suc, newSuccessors, seen, visitor);
+                    }
                     suc.accept(visitor);
                     if (suc instanceof NotExpression)
                         ((NOTConversionVisitor) visitor).flip();
diff --git a/test/org/apache/pig/test/TestFilterSimplification.java b/test/org/apache/pig/test/TestFilterSimplification.java
index 685581d4a..11624a235 100644
--- a/test/org/apache/pig/test/TestFilterSimplification.java
+++ b/test/org/apache/pig/test/TestFilterSimplification.java
@@ -21,6 +21,7 @@ package org.apache.pig.test;
 import java.util.*;
 
 import org.apache.pig.ExecType;
+import org.apache.pig.FilterFunc;
 import org.apache.pig.PigServer;
 import org.apache.pig.newplan.logical.optimizer.LogicalPlanOptimizer;
 import org.apache.pig.newplan.logical.relational.LOFilter;
@@ -31,6 +32,8 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.optimizer.PlanOptimizer;
 import org.apache.pig.newplan.optimizer.Rule;
+import org.apache.pig.test.TestPruneColumn.MyFilterFunc;
+import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.PigContext;
 
 import junit.framework.TestCase;
@@ -766,7 +769,33 @@ public class TestFilterSimplification extends TestCase {
         );
 
     }
+    
+    static public class MyFilterFunc extends FilterFunc {
+        
+        @Override
+        public Boolean exec(Tuple input) {
+            return true;
+        }
+    }
+
+    //PIG-2144
+    @Test
+    public void testNotConversionUdfArg() throws Exception{
+        //udf arg should not be changed
+        String query = "b = filter (load 'd.txt' as (a0, a1)) by " +
+        " NOT IsEmpty( " +  MyFilterFunc.class.getName() + "(a0,a1));" + 
+        "store b into 'empty';";
+        LogicalPlan newLogicalPlan = Util.buildLp(pigServer, query);;
 
+        PlanOptimizer optimizer = new MyPlanOptimizer(newLogicalPlan, 10);
+        optimizer.optimize();
+        
+        //expected plan is same as original plan
+        LogicalPlan expected = Util.buildLp(pigServer, query);;
+
+        assertTrue(expected.isEqual(newLogicalPlan));
+    }
+    
     public class MyPlanOptimizer extends LogicalPlanOptimizer {
 
         protected MyPlanOptimizer(OperatorPlan p, int iterations) {
