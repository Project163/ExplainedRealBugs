diff --git a/CHANGES.txt b/CHANGES.txt
index d99118c84..2048976ae 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -142,6 +142,8 @@ PIG-2228: support partial aggregation in map task (thejas)
 
 BUG FIXES
 
+PIG-2290: TOBAG wraps tuple parameters in another tuple (ryan.hoegg via thejas)
+
 PIG-2288: Pig 0.9 error message not useful as compared to 0.8 in case 
  of group by (vivekp via thejas)
 
diff --git a/src/org/apache/pig/builtin/TOBAG.java b/src/org/apache/pig/builtin/TOBAG.java
index 28e1558a9..abb18077f 100644
--- a/src/org/apache/pig/builtin/TOBAG.java
+++ b/src/org/apache/pig/builtin/TOBAG.java
@@ -36,6 +36,9 @@ import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
  * It's like saying this:
  * T = foreach U generate {($0), ($1), ($2)}
  * 
+ * All arguments that are not of tuple type are inserted into a tuple before
+ * being added to the bag. This is because bag is always a bag of tuples.
+ * 
  * Output schema:
  * The output schema for this udf depends on the schema of its arguments.
  * If all the arguments have same type and same inner 
@@ -81,9 +84,13 @@ public class TOBAG extends EvalFunc<DataBag> {
 
             for (int i = 0; i < input.size(); ++i) {
                 final Object object = input.get(i);
-                Tuple tp2 = TupleFactory.getInstance().newTuple(1);
-                tp2.set(0, object);
-                bag.add(tp2);
+                if (object instanceof Tuple) {
+                    bag.add( (Tuple) object);
+                } else {
+                    Tuple tp2 = TupleFactory.getInstance().newTuple(1);
+                    tp2.set(0, object);
+                    bag.add(tp2);
+                }
             }
 
             return bag;
diff --git a/test/org/apache/pig/test/TestBuiltin.java b/test/org/apache/pig/test/TestBuiltin.java
index bf6606a8c..df8f939b5 100644
--- a/test/org/apache/pig/test/TestBuiltin.java
+++ b/test/org/apache/pig/test/TestBuiltin.java
@@ -1660,8 +1660,7 @@ public class TestBuiltin {
     }
 
     @Test
-    public void testMiscFunc() throws Exception {
-        
+    public void testToBag() throws Exception {
         //TEST TOBAG
         TOBAG tb = new TOBAG();
 
@@ -1733,10 +1732,44 @@ public class TestBuiltin {
             assertTrue(s.contains(i));
         }
         assertTrue("null in tobag result", s.contains(null));
+    }
         
+    @Test
+    public void testTOBAGSupportsTuplesInInput() throws IOException {
+        String[][] expected = {
+                { "a", "b" },
+                { "c", "d" }
+        };
+        TOBAG function = new TOBAG();
+        Tuple input = TupleFactory.getInstance().newTuple(); // input represents a tuple of all the params sent to TOBAG
+        Tuple firstItem = TupleFactory.getInstance().newTuple(); // first item of the params is a Tuple
+        firstItem.append(expected[0][0]); // containing a and b
+        firstItem.append(expected[0][1]);
+        Tuple secondItem = TupleFactory.getInstance().newTuple(); // second item of the params is a Tuple
+        secondItem.append(expected[1][0]); // containing c and d
+        secondItem.append(expected[1][1]);
+
+        input.append(firstItem);
+        input.append(secondItem);
+
+        DataBag result = function.exec(input); // run TOBAG on ((a,b),(c,d))
+
+        assertEquals("number of tuples in the bag", 2, result.size()); // we should have 2 tuples in the output bag
+        int position = 0;
+        for (Tuple t : result) {
+            assertEquals("number of items in tuple " + position, 2, t.size()); // each tuple should contain 2 items
+            assertEquals("first item in tuple " + position, expected[position][0], t.get(0)); // check the items
+            assertEquals("second item in tuple " + position, expected[position][1], t.get(1));
+
+            position++;
+        }
+    }
+
+    @Test
+    public void testMiscFunc() throws Exception {
         TOTUPLE tt = new TOTUPLE();
 
-        input = TupleFactory.getInstance().newTuple();
+        Tuple input = TupleFactory.getInstance().newTuple();
         for (int i = 0; i < 100; ++i) {
             input.append(i);
         }
