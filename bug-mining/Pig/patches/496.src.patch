diff --git a/CHANGES.txt b/CHANGES.txt
index a3a82a3a7..4eed414d2 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,6 +26,9 @@ PIG-1249: Safe-guards against misconfigured Pig scripts without PARALLEL keyword
 
 IMPROVEMENTS
 
+PIG-1568: Optimization rule FilterAboveForeach is too restrictive and doesn't
+handle project * correctly (xuefuz via daijy)
+
 PIG-1574: Optimization rule PushUpFilter causes filter to be pushed up out joins (xuefuz via daijy)
 
 PIG-1515: Migrate logical optimization rule: PushDownForeachFlatten (xuefuz via daijy)
diff --git a/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java b/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java
index 6c670a7e2..18e26dd0a 100644
--- a/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java
+++ b/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java
@@ -138,30 +138,28 @@ public class FilterAboveForeach extends Rule {
                 LogicalExpressionPlan filterPlan = filter.getFilterPlan();
                 Iterator<Operator> iter = filterPlan.getOperators();            
                 Operator op = null;
-                boolean findProject = false;
                 while( iter.hasNext() ) {
                     op = iter.next();
                     if( op instanceof ProjectExpression ) {
-                        uids.add(((ProjectExpression)op).getFieldSchema().uid);
-                        types.add(((ProjectExpression)op).getFieldSchema().type);
-                        findProject = true;
-                    }
-                }
-                
-                // If we cannot find project, all fields will be projected, eg.
-                //   B = filter A by MyFilterFunction();
-                // The input for MyFilterFunction is whole A
-                if (!findProject) {
-                    LogicalRelationalOperator pred = (LogicalRelationalOperator)filter.getPlan().getPredecessors(filter).get(0);
-                    LogicalSchema predSchema = pred.getSchema();
-                    if (predSchema!=null) {
-                        for (int i=0;i<predSchema.size();i++) {
-                            uids.add(predSchema.getField(i).uid);
-                            types.add(predSchema.getField(i).type);
+                        ProjectExpression proj = (ProjectExpression)op;
+                        if( proj.isProjectStar() ) {
+                            LogicalRelationalOperator pred = (LogicalRelationalOperator)filter.getPlan().getPredecessors(filter).get(0);
+                            LogicalSchema predSchema = pred.getSchema();
+                            if (predSchema!=null) {
+                                for (int i=0;i<predSchema.size();i++) {
+                                    uids.add(predSchema.getField(i).uid);
+                                    types.add(predSchema.getField(i).type);
+                                }
+                            }
+                        } else {
+                            uids.add(proj.getFieldSchema().uid);
+                            types.add(proj.getFieldSchema().type);
                         }
                     }
                 }
+                
             }
+            
             Pair<List<Long>, List<Byte>> result = new Pair<List<Long>, List<Byte>>(uids, types);
             return result;
         }
diff --git a/test/org/apache/pig/test/TestFilterUDF.java b/test/org/apache/pig/test/TestFilterUDF.java
index 1020c13c8..1f9b2868c 100644
--- a/test/org/apache/pig/test/TestFilterUDF.java
+++ b/test/org/apache/pig/test/TestFilterUDF.java
@@ -116,7 +116,7 @@ public class TestFilterUDF {
         pigServer.registerQuery("A = LOAD '" 
                 + Util.generateURI(tmpFile.toString(), pigServer.getPigContext()) 
                 + "' as (x:int);");
-        pigServer.registerQuery("B = filter A by " + MyFilterFunction.class.getName() + "();");
+        pigServer.registerQuery("B = filter A by " + MyFilterFunction.class.getName() + "($0);");
         Iterator<Tuple> iter = pigServer.openIterator("B");
         if(!iter.hasNext()) fail("No Output received");
         int cnt = 0;
diff --git a/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java b/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java
index 0c201cd16..1e1b1b52b 100644
--- a/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java
+++ b/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java
@@ -21,975 +21,287 @@ package org.apache.pig.test;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Properties;
 import java.util.Set;
-import org.apache.pig.data.DataType;
+
+import org.apache.pig.ExecType;
+import org.apache.pig.impl.PigContext;
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.logical.expression.ConstantExpression;
-import org.apache.pig.newplan.logical.expression.EqualExpression;
-import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
-import org.apache.pig.newplan.logical.expression.ProjectExpression;
-import org.apache.pig.newplan.logical.optimizer.ProjectionPatcher;
-import org.apache.pig.newplan.logical.optimizer.SchemaPatcher;
+import org.apache.pig.newplan.logical.LogicalPlanMigrationVistor;
+import org.apache.pig.newplan.logical.optimizer.LogicalPlanOptimizer;
 import org.apache.pig.newplan.logical.relational.LOFilter;
 import org.apache.pig.newplan.logical.relational.LOForEach;
-import org.apache.pig.newplan.logical.relational.LOGenerate;
-import org.apache.pig.newplan.logical.relational.LOInnerLoad;
 import org.apache.pig.newplan.logical.relational.LOLoad;
-import org.apache.pig.newplan.logical.relational.LOStore;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
-import org.apache.pig.newplan.logical.relational.LogicalSchema;
-import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
 import org.apache.pig.newplan.logical.rules.FilterAboveForeach;
+import org.apache.pig.newplan.logical.rules.LoadTypeCastInserter;
 import org.apache.pig.newplan.optimizer.PlanOptimizer;
 import org.apache.pig.newplan.optimizer.PlanTransformListener;
 import org.apache.pig.newplan.optimizer.Rule;
+import org.apache.pig.test.utils.Identity;
+import org.apache.pig.test.utils.LogicalPlanTester;
+import org.junit.Assert;
+import org.junit.Test;
 
-import junit.framework.TestCase;
 
-public class TestNewPlanFilterAboveForeach extends TestCase {
+public class TestNewPlanFilterAboveForeach {
+    PigContext pc = new PigContext(ExecType.LOCAL, new Properties());
+    LogicalPlanTester planTester = new LogicalPlanTester(pc) ;
     
+    @Test
     public void testSimple() throws Exception {
-        
-        // Plan here is 
-        // Load (name, cuisines{t:(name)}) -> foreach gen name,flatten(cuisines) 
-        // -> filter name == 'joe' --> stor
-        
-        LogicalPlan plan = null;
-        LOLoad load = null;
-        LOForEach foreach = null;
-        LOFilter filter = null;
-        LOStore stor = null;
-        
-        plan = new LogicalPlan();
-        
-        LogicalSchema schema = new LogicalSchema();
-        schema.addField(new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY));
-        LogicalSchema bagSchema = new LogicalSchema();
-        LogicalSchema bagTupleSchema = new LogicalSchema();
-        bagTupleSchema.addField( new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY) );
-        bagSchema.addField( new LogicalSchema.LogicalFieldSchema( "t", bagTupleSchema, DataType.TUPLE ) );
-        schema.addField(new LogicalSchema.LogicalFieldSchema("cuisines", bagSchema, DataType.BAG));
-        
-        load = new LOLoad(null, schema, plan, null);
-        load.setAlias("A");
-        plan.add(load);
-        
-        foreach = new LOForEach(plan);
-        
-        LogicalPlan innerPlan = new LogicalPlan();
-        List<LogicalExpressionPlan> expPlans = new ArrayList<LogicalExpressionPlan>();
-        
-        boolean flatten[] = new boolean[2];
-        flatten[0] = false;
-        flatten[1] = true;
-        
-        LOGenerate generate = new LOGenerate(innerPlan, expPlans, flatten);        
-        
-        LOInnerLoad innerLoad = new LOInnerLoad(innerPlan, foreach, 0);
-        innerPlan.add(innerLoad);
-        
-        LOInnerLoad innerLoad2 = new LOInnerLoad(innerPlan, foreach, 1);
-        innerPlan.add(innerLoad2);
-        
-        LogicalExpressionPlan namePrj = new LogicalExpressionPlan();        
-        ProjectExpression prjName = new ProjectExpression(namePrj, 0, 0, generate);
-        namePrj.add(prjName);
-        
-        LogicalExpressionPlan cuisinesPrj = new LogicalExpressionPlan();
-        ProjectExpression prjCuisines = new ProjectExpression(cuisinesPrj, 1, 0, generate);
-        cuisinesPrj.add(prjCuisines);
-        
-        
-        expPlans.add(namePrj);
-        expPlans.add(cuisinesPrj);
-        
-        innerPlan.add(generate);
-        innerPlan.connect(innerLoad, generate);
-        innerPlan.connect(innerLoad2, generate);
-        
-        foreach.setInnerPlan(innerPlan);
-        foreach.setAlias("B");
-        plan.add(foreach);
-        
-        plan.connect(load, foreach);
-        
-        filter = new LOFilter(plan);
-        LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-        ProjectExpression namePrj2 = new ProjectExpression(filterPlan, 0, 0, filter);
-        filterPlan.add(namePrj2);
-        ConstantExpression constExp = new ConstantExpression(filterPlan, "joe", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filterPlan.add(constExp);
-        EqualExpression equal = new EqualExpression(filterPlan, namePrj2, constExp);
-        filterPlan.add(equal);
-        
-        filter.setFilterPlan(filterPlan);
-        filter.setAlias("C");
-        plan.add(filter);
-        
-        plan.connect(foreach, filter);
-        
-        stor = new LOStore(plan);
-        stor.setAlias("D");
-        plan.add(stor);
-        plan.connect(filter,stor);
-        
-        // run filter rule
-        Rule r = new FilterAboveForeach("FilterAboveFlatten");
-        Set<Rule> s = new HashSet<Rule>();
-        s.add(r);
-        List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
-        ls.add(s);
-        
-        // Test Plan before optimizing
-        List<Operator> list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
-        // Run the optimizer
-        MyPlanOptimizer optimizer = new MyPlanOptimizer(plan, ls, 3);
-        optimizer.addPlanTransformListener(new SchemaPatcher());
-        optimizer.addPlanTransformListener(new ProjectionPatcher());
-        optimizer.optimize();
-        
-        // Test after optimization
-        list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(foreach) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(load) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        assertEquals( load.getSchema().getField(0).uid, namePrj2.getFieldSchema().uid );
-        assertEquals( namePrj2.getFieldSchema().uid, prjName.getFieldSchema().uid );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(filter) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (name, cuisines:bag{ t : ( cuisine ) } );" );
+        lpt.buildPlan( "B = FOREACH A GENERATE name, flatten(cuisines);" );
+        lpt.buildPlan( "C = FILTER B BY name == 'joe';" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "D = STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
+
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator filter = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator fe1 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
     }
     
+    @Test
     public void testMultipleFilter() throws Exception {
-        
-        // Plan here is 
-        // Load (name, cuisines{t:(name)}) -> foreach gen name,flatten(cuisines) 
-        // -> filter $1 == 'joe' --> filter name == 'joe' --> stor
-        
-        LogicalPlan plan = null;
-        LOLoad load = null;
-        LOForEach foreach = null;
-        LOFilter filter = null;
-        LOStore stor = null;
-        
-        plan = new LogicalPlan();
-        
-        LogicalSchema schema = new LogicalSchema();
-        schema.addField(new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY));
-        LogicalSchema bagSchema = new LogicalSchema();
-        LogicalSchema bagTupleSchema = new LogicalSchema();
-        bagTupleSchema.addField( new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY) );
-        bagSchema.addField( new LogicalSchema.LogicalFieldSchema( "t", bagTupleSchema, DataType.TUPLE ) );
-        schema.addField(new LogicalSchema.LogicalFieldSchema("cuisines", bagSchema, DataType.BAG));
-        
-        load = new LOLoad(null, schema, plan, null);
-        load.setAlias("A");
-        plan.add(load);
-        
-        foreach = new LOForEach(plan);
-        
-        LogicalPlan innerPlan = new LogicalPlan();
-        List<LogicalExpressionPlan> expPlans = new ArrayList<LogicalExpressionPlan>();
-        
-        boolean flatten[] = new boolean[2];
-        flatten[0] = false;
-        flatten[1] = true;
-        
-        LOGenerate generate = new LOGenerate(innerPlan, expPlans, flatten);        
-        
-        LOInnerLoad innerLoad = new LOInnerLoad(innerPlan, foreach, 0);
-        innerPlan.add(innerLoad);
-        
-        LOInnerLoad innerLoad2 = new LOInnerLoad(innerPlan, foreach, 1);
-        innerPlan.add(innerLoad2);
-        
-        LogicalExpressionPlan namePrj = new LogicalExpressionPlan();        
-        ProjectExpression prjName = new ProjectExpression(namePrj, 0, 0, generate);
-        namePrj.add(prjName);
-        
-        LogicalExpressionPlan cuisinesPrj = new LogicalExpressionPlan();
-        ProjectExpression prjCuisines = new ProjectExpression(cuisinesPrj, 1, 0, generate);
-        cuisinesPrj.add(prjCuisines);
-        
-        
-        expPlans.add(namePrj);
-        expPlans.add(cuisinesPrj);
-        
-        innerPlan.add(generate);
-        innerPlan.connect(innerLoad, generate);
-        innerPlan.connect(innerLoad2, generate);
-        
-        foreach.setInnerPlan(innerPlan);
-        foreach.setAlias("B");
-        plan.add(foreach);
-        
-        plan.connect(load, foreach);
-        
-        filter = new LOFilter(plan);
-        LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-        ProjectExpression namePrj2 = new ProjectExpression(filterPlan, 0, 0, filter);
-        filterPlan.add(namePrj2);
-        ConstantExpression constExp = new ConstantExpression(filterPlan, "joe", 
-            new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filterPlan.add(constExp);
-        EqualExpression equal = new EqualExpression(filterPlan, namePrj2, constExp);
-        filterPlan.add(equal);
-        
-        filter.setFilterPlan(filterPlan);
-        filter.setAlias("C");
-        plan.add(filter);
-        
-        LOFilter filter2 = new LOFilter(plan);
-        LogicalExpressionPlan filter2Plan = new LogicalExpressionPlan();
-        ProjectExpression name2Prj2 = new ProjectExpression(filter2Plan, 0, 1, filter2);
-        filter2Plan.add(name2Prj2);
-        ConstantExpression const2Exp = new ConstantExpression(filter2Plan, "joe", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filter2Plan.add(const2Exp);
-        EqualExpression equal2 = new EqualExpression(filter2Plan, namePrj2, constExp);
-        filter2Plan.add(equal2);
-        
-        filter2.setFilterPlan(filter2Plan);
-        filter2.setAlias("C1");
-        plan.add(filter2);
-        
-        plan.connect(foreach, filter2);
-        plan.connect(filter2, filter);
-        
-        stor = new LOStore(plan);
-        stor.setAlias("D");
-        plan.add(stor);
-        plan.connect(filter,stor);
-        
-        // run filter rule
-        Rule r = new FilterAboveForeach("FilterAboveFlatten");
-        Set<Rule> s = new HashSet<Rule>();
-        s.add(r);
-        List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
-        ls.add(s);
-        
-        // Test Plan before optimizing
-        List<Operator> list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter2).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter2).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(load) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(filter2) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
-        // Run the optimizer
-        MyPlanOptimizer optimizer = new MyPlanOptimizer(plan, ls, 3);
-        optimizer.addPlanTransformListener(new SchemaPatcher());
-        optimizer.addPlanTransformListener(new ProjectionPatcher());
-        optimizer.optimize();
-        
-        // Test after optimization
-        list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter2) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter2).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter2).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(filter) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(load) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        assertEquals( load.getSchema().getField(0).uid, namePrj2.getFieldSchema().uid );
-        assertEquals( namePrj2.getFieldSchema().uid, prjName.getFieldSchema().uid );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (name, cuisines : bag{ t : ( cuisine ) } );" );
+        lpt.buildPlan( "B = FOREACH A GENERATE name, flatten(cuisines);" );
+        lpt.buildPlan( "C = FILTER B BY $1 == 'french';" );
+        lpt.buildPlan( "D = FILTER C BY name == 'joe';" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "E = STORE D INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
+        
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator filter = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator fe1 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+        Operator filter2 = newLogicalPlan.getSuccessors( fe2 ).get( 0 );
+        Assert.assertTrue( filter2 instanceof LOFilter );
     }
     
+    @Test
     public void testMultipleFilter2() throws Exception {
-        
-        // Plan here is 
-        // Load (name, cuisines{t:(name)}) -> foreach gen name,cuisines 
-        // -> filter name == 'joe2' --> filter name == 'joe' --> stor
-        
-        LogicalPlan plan = null;
-        LOLoad load = null;
-        LOForEach foreach = null;
-        LOFilter filter = null;
-        LOStore stor = null;
-        
-        plan = new LogicalPlan();
-        
-        LogicalSchema schema = new LogicalSchema();
-        schema.addField(new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY));
-        LogicalSchema bagSchema = new LogicalSchema();
-        LogicalSchema bagTupleSchema = new LogicalSchema();
-        bagTupleSchema.addField( new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY) );
-        bagSchema.addField( new LogicalSchema.LogicalFieldSchema( "t", bagTupleSchema, DataType.TUPLE ) );
-        schema.addField(new LogicalSchema.LogicalFieldSchema("cuisines", bagSchema, DataType.BAG));
-        
-        load = new LOLoad(null, schema, plan, null);
-        load.setAlias("A");
-        plan.add(load);
-        
-        foreach = new LOForEach(plan);
-        
-        LogicalPlan innerPlan = new LogicalPlan();
-        
-        List<LogicalExpressionPlan> expPlans = new ArrayList<LogicalExpressionPlan>();
-        
-        boolean flatten[] = new boolean[2];
-        flatten[0] = false;
-        flatten[1] = true;
-        
-        LOGenerate generate = new LOGenerate(innerPlan, expPlans, flatten);
-        LOInnerLoad innerLoad = new LOInnerLoad(innerPlan, foreach, 0);
-        innerPlan.add(innerLoad);
-        
-        LOInnerLoad innerLoad2 = new LOInnerLoad(innerPlan, foreach, 1);
-        innerPlan.add(innerLoad2);
-        
-        LogicalExpressionPlan namePrj = new LogicalExpressionPlan();        
-        ProjectExpression prjName = new ProjectExpression(namePrj, 0, 0, generate);
-        namePrj.add(prjName);
-        
-        LogicalExpressionPlan cuisinesPrj = new LogicalExpressionPlan();
-        ProjectExpression prjCuisines = new ProjectExpression(cuisinesPrj, 1, 0, generate);
-        cuisinesPrj.add(prjCuisines);
-        
-        
-        expPlans.add(namePrj);
-        expPlans.add(cuisinesPrj);
-        
-        
-        innerPlan.add(generate);
-        innerPlan.connect(innerLoad, generate);
-        innerPlan.connect(innerLoad2, generate);
-        
-        foreach.setInnerPlan(innerPlan);
-        foreach.setAlias("B");
-        plan.add(foreach);
-        
-        plan.connect(load, foreach);
-        
-        filter = new LOFilter(plan);
-        LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-        ProjectExpression namePrj2 = new ProjectExpression(filterPlan, 0, 0, filter);
-        filterPlan.add(namePrj2);
-        ConstantExpression constExp = new ConstantExpression(filterPlan, "joe", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filterPlan.add(constExp);
-        EqualExpression equal = new EqualExpression(filterPlan, namePrj2, constExp);
-        filterPlan.add(equal);
-        
-        filter.setFilterPlan(filterPlan);
-        filter.setAlias("C");
-        plan.add(filter);
-        
-        LOFilter filter2 = new LOFilter(plan);
-        LogicalExpressionPlan filter2Plan = new LogicalExpressionPlan();
-        ProjectExpression name2Prj2 = new ProjectExpression(filter2Plan, 0, 0, filter2);
-        filter2Plan.add(name2Prj2);
-        ConstantExpression const2Exp = new ConstantExpression(filter2Plan, "joe2", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filter2Plan.add(const2Exp);
-        EqualExpression equal2 = new EqualExpression(filter2Plan, namePrj2, constExp);
-        filter2Plan.add(equal2);
-        
-        filter2.setFilterPlan(filter2Plan);
-        filter2.setAlias("C1");
-        plan.add(filter2);
-        
-        plan.connect(foreach, filter2);
-        plan.connect(filter2, filter);
-        
-        stor = new LOStore(plan);
-        stor.setAlias("D");
-        plan.add(stor);
-        plan.connect(filter,stor);
-        
-        // run filter rule
-        Rule r = new FilterAboveForeach("FilterAboveFlatten");
-        Set<Rule> s = new HashSet<Rule>();
-        s.add(r);
-        List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
-        ls.add(s);
-        
-        // Test Plan before optimizing
-        List<Operator> list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter2).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter2).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(load) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(filter2) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
-        // Run the optimizer
-        MyPlanOptimizer optimizer = new MyPlanOptimizer(plan, ls, 3);
-        optimizer.addPlanTransformListener(new SchemaPatcher());
-        optimizer.addPlanTransformListener(new ProjectionPatcher());
-        optimizer.optimize();
-        
-        // Test after optimization
-        list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(foreach) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter2).contains(load) );
-        assertEquals( 1, plan.getPredecessors(filter2).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(filter) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(filter2) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertEquals( load.getSchema().getField(0).uid, namePrj2.getFieldSchema().uid );
-        assertEquals( namePrj2.getFieldSchema().uid, name2Prj2.getFieldSchema().uid );
-        assertEquals( name2Prj2.getFieldSchema().uid, prjName.getFieldSchema().uid );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );        
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (name, age, cuisines : bag{ t : ( cuisine ) } );" );
+        lpt.buildPlan( "B = FOREACH A GENERATE name, age, flatten(cuisines);" );
+        lpt.buildPlan( "C = FILTER B BY name == 'joe';" );
+        lpt.buildPlan( "D = FILTER C BY age == 30;" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "E = STORE D INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
+        
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator filter = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator filter2 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( filter2 instanceof LOFilter );
+        Operator fe1 = newLogicalPlan.getSuccessors( filter2 ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
     }
     
-public void testMultipleFilterNotPossible() throws Exception {
-        
-        // Plan here is 
-        // Load (name, cuisines{t:(name)}) -> foreach gen name,cuisines 
-        // -> filter $1 == 'joe2' --> filter $1 == 'joe' --> stor
-        
-        LogicalPlan plan = null;
-        LOLoad load = null;
-        LOForEach foreach = null;
-        LOFilter filter = null;
-        LOStore stor = null;
-        
-        plan = new LogicalPlan();
-        
-        LogicalSchema schema = new LogicalSchema();
-        schema.addField(new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY));
-        LogicalSchema bagSchema = new LogicalSchema();
-        LogicalSchema bagTupleSchema = new LogicalSchema();
-        bagTupleSchema.addField( new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY) );
-        bagSchema.addField( new LogicalSchema.LogicalFieldSchema( "t", bagTupleSchema, DataType.TUPLE ) );
-        schema.addField(new LogicalSchema.LogicalFieldSchema("cuisines", bagSchema, DataType.BAG));
-        
-        load = new LOLoad(null, schema, plan, null);
-        load.setAlias("A");
-        plan.add(load);
-        
-        foreach = new LOForEach(plan);
-        
-        LogicalPlan innerPlan = new LogicalPlan();
-        List<LogicalExpressionPlan> expPlans = new ArrayList<LogicalExpressionPlan>();
-        
-        boolean flatten[] = new boolean[2];
-        flatten[0] = false;
-        flatten[1] = true;
-        
-        LOGenerate generate = new LOGenerate(innerPlan, expPlans, flatten);        
-        
-        
-        LOInnerLoad innerLoad = new LOInnerLoad(innerPlan, foreach, 0);
-        innerPlan.add(innerLoad);
-        
-        LOInnerLoad innerLoad2 = new LOInnerLoad(innerPlan, foreach, 1);
-        innerPlan.add(innerLoad2);
-        
-        LogicalExpressionPlan namePrj = new LogicalExpressionPlan();        
-        ProjectExpression prjName = new ProjectExpression(namePrj, 0, 0, generate);
-        namePrj.add(prjName);
-        
-        LogicalExpressionPlan cuisinesPrj = new LogicalExpressionPlan();
-        ProjectExpression prjCuisines = new ProjectExpression(cuisinesPrj, 1, 0, generate);
-        cuisinesPrj.add(prjCuisines);
-        
-        expPlans.add(namePrj);
-        expPlans.add(cuisinesPrj);
-        
-        innerPlan.add(generate);
-        innerPlan.connect(innerLoad, generate);
-        innerPlan.connect(innerLoad2, generate);
-        
-        foreach.setInnerPlan(innerPlan);
-        foreach.setAlias("B");
-        plan.add(foreach);
-        
-        plan.connect(load, foreach);
-        
-        filter = new LOFilter(plan);
-        LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-        ProjectExpression namePrj2 = new ProjectExpression(filterPlan, 0, 1, filter);
-        filterPlan.add(namePrj2);
-        ConstantExpression constExp = new ConstantExpression(filterPlan, "joe", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filterPlan.add(constExp);
-        EqualExpression equal = new EqualExpression(filterPlan, namePrj2, constExp);
-        filterPlan.add(equal);
-        
-        filter.setFilterPlan(filterPlan);
-        filter.setAlias("C");
-        plan.add(filter);
-        
-        LOFilter filter2 = new LOFilter(plan);
-        LogicalExpressionPlan filter2Plan = new LogicalExpressionPlan();
-        ProjectExpression name2Prj2 = new ProjectExpression(filter2Plan, 0, 1, filter2);
-        filter2Plan.add(name2Prj2);
-        ConstantExpression const2Exp = new ConstantExpression(filter2Plan, "joe2", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filter2Plan.add(const2Exp);
-        EqualExpression equal2 = new EqualExpression(filter2Plan, namePrj2, constExp);
-        filter2Plan.add(equal2);
-        
-        filter2.setFilterPlan(filter2Plan);
-        filter2.setAlias("C1");
-        plan.add(filter2);
-        
-        plan.connect(foreach, filter2);
-        plan.connect(filter2, filter);
-        
-        stor = new LOStore(plan);
-        stor.setAlias("D");
-        plan.add(stor);
-        plan.connect(filter,stor);
-        
-        // run filter rule
-        Rule r = new FilterAboveForeach("FilterAboveFlatten");
-        Set<Rule> s = new HashSet<Rule>();
-        s.add(r);
-        List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
-        ls.add(s);
-        
-        // Test Plan before optimizing
-        List<Operator> list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter2).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter2).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(load) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(filter2) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
-        // Run the optimizer
-        MyPlanOptimizer optimizer = new MyPlanOptimizer(plan, ls, 3);
-        optimizer.addPlanTransformListener(new SchemaPatcher());
-        optimizer.addPlanTransformListener(new ProjectionPatcher());
-        optimizer.optimize();
-        
-        // Test after optimization
-        list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter2).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter2).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(load) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertFalse( prjCuisines.getFieldSchema().uid == namePrj2.getFieldSchema().uid );
-        assertFalse( prjCuisines.getFieldSchema().uid == name2Prj2.getFieldSchema().uid );
-        
-        assertTrue( plan.getPredecessors(filter).contains(filter2) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );    
+    @Test
+    public void testMultipleFilterNotPossible() throws Exception {
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (name, cuisines : bag{ t : ( cuisine, region ) } );" );
+        lpt.buildPlan( "B = FOREACH A GENERATE name, flatten(cuisines);" );
+        lpt.buildPlan( "C = FILTER B BY $1 == 'French';" );
+        lpt.buildPlan( "D = FILTER C BY $2 == 'Europe';" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "E = STORE D INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
+
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator fe1 = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+        Operator filter = newLogicalPlan.getSuccessors( fe2 ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator filter2 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( filter2 instanceof LOFilter );
     }
     
+    @Test
     public void testNotPossibleFilter() throws Exception {
-        // Plan here is 
-        // Load (name, cuisines{t:(name)}) -> foreach gen name,flatten(cuisines) 
-        // -> filter $1 == 'joe' --> stor
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (name, cuisines:bag{ t : ( cuisine ) } );" );
+        lpt.buildPlan( "B = FOREACH A GENERATE name, flatten(cuisines);" );
+        lpt.buildPlan( "C = FILTER B BY cuisine == 'French';" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "D = STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
 
-        LogicalPlan plan = null;
-        LOLoad load = null;
-        LOForEach foreach = null;
-        LOFilter filter = null;
-        LOStore stor = null;
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator fe1 = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+        Operator filter = newLogicalPlan.getSuccessors( fe2 ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+    }
+    
+    @Test
+    public void testSimple2() throws Exception {
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (name, cuisines:bag{ t : ( cuisine ) } );" );
+        lpt.buildPlan( "B = FOREACH A GENERATE name, cuisines;" );
+        lpt.buildPlan( "C = FILTER B BY name == 'joe';" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "D = STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
 
-        plan = new LogicalPlan();
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator filter = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator fe1 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+    }
+    
+    /**
+     * Normal test case: all fields from Foreach are used by exhaustive list.
+     * Optimization should kick in.
+     */
+    @Test
+    public void test1() throws FrontendException {
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (a(u,v), b, c);" );
+        lpt.buildPlan( "B = FOREACH A GENERATE $0, b;" );
+        lpt.buildPlan( "C = FILTER B BY " + Identity.class.getName() +"($0, $1) > 5;" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
 
-        LogicalSchema schema = new LogicalSchema();
-        schema.addField(new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY));
-        LogicalSchema bagSchema = new LogicalSchema();
-        LogicalSchema bagTupleSchema = new LogicalSchema();
-        bagTupleSchema.addField( new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY) );
-        bagSchema.addField( new LogicalSchema.LogicalFieldSchema( "t", bagTupleSchema, DataType.TUPLE ) );
-        schema.addField(new LogicalSchema.LogicalFieldSchema("cuisines", bagSchema, DataType.BAG));
-        
-        load = new LOLoad(null, schema, plan, null);
-        load.setAlias("A");
-        plan.add(load);
-        
-        foreach = new LOForEach(plan);
-        
-        LogicalPlan innerPlan = new LogicalPlan();
-        boolean flatten[] = new boolean[2];
-        flatten[0] = false;
-        flatten[1] = true;
-        
-        List<LogicalExpressionPlan> expPlans = new ArrayList<LogicalExpressionPlan>();
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator fe1 = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator filter = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator fe2 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+    }
+    
+    /**
+     * Identical to test1() except that it use project *.
+     */
+    @Test
+    public void test2() throws FrontendException {
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (a(u,v), b, c);" );
+        lpt.buildPlan( "B = FOREACH A GENERATE $0, b;" );
+        lpt.buildPlan( "C = FILTER B BY " + Identity.class.getName() +"(*) > 5;" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
 
-        LOGenerate generate = new LOGenerate(innerPlan, expPlans, flatten);        
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator fe1 = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator filter = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator fe2 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+    }
 
-        LOInnerLoad innerLoad = new LOInnerLoad(innerPlan, foreach, 0);
-        innerPlan.add(innerLoad);
-        
-        LOInnerLoad innerLoad2 = new LOInnerLoad(innerPlan, foreach, 1);
-        innerPlan.add(innerLoad2);
-        
-        LogicalExpressionPlan namePrj = new LogicalExpressionPlan();        
-        ProjectExpression prjName = new ProjectExpression(namePrj, 0, 0, generate);
-        namePrj.add(prjName);
-        
-        LogicalExpressionPlan cuisinesPrj = new LogicalExpressionPlan();
-        ProjectExpression prjCuisines = new ProjectExpression(cuisinesPrj, 1, 0, generate);
-        cuisinesPrj.add(prjCuisines);
-        
-        expPlans.add(namePrj);
-        expPlans.add(cuisinesPrj);
-        
-        innerPlan.add(generate);
-        innerPlan.connect(innerLoad, generate);
-        innerPlan.connect(innerLoad2, generate);
-        
-        foreach.setInnerPlan(innerPlan);
-        foreach.setAlias("B");
-        plan.add(foreach);
-        
-        plan.connect(load, foreach);
-        
-        filter = new LOFilter(plan);
-        LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-        ProjectExpression namePrj2 = new ProjectExpression(filterPlan, 0, 1, filter);
-        filterPlan.add(namePrj2);
-        ConstantExpression constExp = new ConstantExpression(filterPlan, "joe", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filterPlan.add(constExp);
-        EqualExpression equal = new EqualExpression(filterPlan, namePrj2, constExp);
-        filterPlan.add(equal);
-        
-        filter.setFilterPlan(filterPlan);
-        filter.setAlias("C");
-        plan.add(filter);
-        
-        plan.connect(foreach, filter);
-        
-        stor = new LOStore(plan);
-        stor.setAlias("D");
-        plan.add(stor);
-        plan.connect(filter,stor);
-        
-        // run filter rule
-        Rule r = new FilterAboveForeach("FilterAboveFlatten");
-        Set<Rule> s = new HashSet<Rule>();
-        s.add(r);
-        List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
-        ls.add(s);
-        
-        // Test Plan before optimizing
-        List<Operator> list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
-        // Run the optimizer
-        MyPlanOptimizer optimizer = new MyPlanOptimizer(plan, ls, 3);
-        optimizer.addPlanTransformListener(new SchemaPatcher());
-        optimizer.addPlanTransformListener(new ProjectionPatcher());
-        optimizer.optimize();
-        
-        // Test after optimization
-        list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertFalse( prjCuisines.getFieldSchema().uid == namePrj2.getFieldSchema().uid );
-        
-        assertTrue( plan.getPredecessors(filter).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
+    /**
+     * No fields are used in filter condition at all.
+     */
+    @Test
+    public void test3() throws FrontendException {
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (a(u,v), b, c);" );
+        lpt.buildPlan( "B = FOREACH A GENERATE $0, b;" );
+        lpt.buildPlan( "C = FILTER B BY 8 > 5;" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
+
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator filter = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+        Operator fe1 = newLogicalPlan.getSuccessors( filter ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
     }
     
-    public void testSimple2() throws Exception {
-        
-        // Plan here is 
-        // Load (name, cuisines{t:(name)}) -> foreach gen name,cuisines 
-        // -> filter name == 'joe' --> stor
-        
-        LogicalPlan plan = null;
-        LOLoad load = null;
-        LOForEach foreach = null;
-        LOFilter filter = null;
-        LOStore stor = null;
-        
-        plan = new LogicalPlan();
-        
-        LogicalSchema schema = new LogicalSchema();
-        schema.addField(new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY));
-        LogicalSchema bagSchema = new LogicalSchema();
-        LogicalSchema bagTupleSchema = new LogicalSchema();
-        bagTupleSchema.addField( new LogicalSchema.LogicalFieldSchema("name", null, DataType.CHARARRAY) );
-        bagSchema.addField( new LogicalSchema.LogicalFieldSchema( "t", bagTupleSchema, DataType.TUPLE ) );
-        schema.addField(new LogicalSchema.LogicalFieldSchema("cuisines", bagSchema, DataType.BAG));
-        
-        load = new LOLoad(null, schema, plan, null);
-        load.setAlias("A");
-        plan.add(load);
-        
-        foreach = new LOForEach(plan);
-        
-        LogicalPlan innerPlan = new LogicalPlan();
-
-        List<LogicalExpressionPlan> expPlans = new ArrayList<LogicalExpressionPlan>();
-        
-        boolean flatten[] = new boolean[2];
-        flatten[0] = false;
-        flatten[1] = false;
-        
-        LOGenerate generate = new LOGenerate(innerPlan, expPlans, flatten);        
+    /**
+     * Similar to test2, but not all fields are available from the operator before foreach.
+     * Optimziation doesn't kick in.
+     */
+    @Test
+    public void test4() throws FrontendException {
+        LogicalPlanTester lpt = new LogicalPlanTester( pc );
+        lpt.buildPlan( "A = LOAD 'file.txt' AS (a(u,v), b, c);" );
+        lpt.buildPlan( "B = FOREACH A GENERATE $0, b, flatten(1);" );
+        lpt.buildPlan( "C = FILTER B BY " + Identity.class.getName() +"(*) > 5;" );
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan( "STORE C INTO 'empty';" );  
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
 
-        LOInnerLoad innerLoad = new LOInnerLoad(innerPlan, foreach, 0);
-        innerPlan.add(innerLoad);
-        
-        LOInnerLoad innerLoad2 = new LOInnerLoad(innerPlan, foreach, 1);
-        innerPlan.add(innerLoad2);
-        
-        LogicalExpressionPlan namePrj = new LogicalExpressionPlan();        
-        ProjectExpression prjName = new ProjectExpression(namePrj, 0, 0, generate);
-        namePrj.add(prjName);
-        
-        LogicalExpressionPlan cuisinesPrj = new LogicalExpressionPlan();
-        ProjectExpression prjCuisines = new ProjectExpression(cuisinesPrj, 1, 0, generate);
-        cuisinesPrj.add(prjCuisines);
-        
-        expPlans.add(namePrj);
-        expPlans.add(cuisinesPrj);
-        
-        innerPlan.add(generate);
-        innerPlan.connect(innerLoad, generate);
-        innerPlan.connect(innerLoad2, generate);
-        
-        foreach.setInnerPlan(innerPlan);
-        foreach.setAlias("B");
-        plan.add(foreach);
-        
-        plan.connect(load, foreach);
-        
-        filter = new LOFilter(plan);
-        LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-        ProjectExpression namePrj2 = new ProjectExpression(filterPlan, 0, 0, filter);
-        filterPlan.add(namePrj2);
-        ConstantExpression constExp = new ConstantExpression(filterPlan, "joe", 
-                new LogicalFieldSchema(null, null, DataType.CHARARRAY));
-        filterPlan.add(constExp);
-        EqualExpression equal = new EqualExpression(filterPlan, namePrj2, constExp);
-        filterPlan.add(equal);
-        
-        filter.setFilterPlan(filterPlan);
-        filter.setAlias("C");
-        plan.add(filter);
-        
-        plan.connect(foreach, filter);
-        
-        stor = new LOStore(plan);
-        stor.setAlias("D");
-        plan.add(stor);
-        plan.connect(filter,stor);
-        
-        // run filter rule
-        Rule r = new FilterAboveForeach("FilterAboveFlatten");
-        Set<Rule> s = new HashSet<Rule>();
-        s.add(r);
-        List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
-        ls.add(s);
-        
-        // Test Plan before optimizing
-        List<Operator> list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(filter) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(foreach) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
-        
-        // Run the optimizer
-        MyPlanOptimizer optimizer = new MyPlanOptimizer(plan, ls, 3);
-        optimizer.addPlanTransformListener(new SchemaPatcher());
-        optimizer.addPlanTransformListener(new ProjectionPatcher());
+        Operator load = newLogicalPlan.getSources().get( 0 );
+        Assert.assertTrue( load instanceof LOLoad );
+        Operator fe1 = newLogicalPlan.getSuccessors( load ).get( 0 );
+        Assert.assertTrue( fe1 instanceof LOForEach );
+        Operator fe2 = newLogicalPlan.getSuccessors( fe1 ).get( 0 );
+        Assert.assertTrue( fe2 instanceof LOForEach );
+        Operator filter = newLogicalPlan.getSuccessors( fe2 ).get( 0 );
+        Assert.assertTrue( filter instanceof LOFilter );
+    }
+    
+    private LogicalPlan migrateAndOptimizePlan(org.apache.pig.impl.logicalLayer.LogicalPlan plan) throws FrontendException {
+        LogicalPlan newLogicalPlan = migratePlan( plan );
+        PlanOptimizer optimizer = new MyPlanOptimizer( newLogicalPlan, 3 );
         optimizer.optimize();
-        
-        // Test after optimization
-        list = plan.getSinks();
-        assertTrue( list.contains(stor) );
-        
-        list = plan.getSources();
-        assertTrue( list.contains(load) );
-        
-        assertTrue( plan.getPredecessors(stor).contains(foreach) ); 
-        assertEquals( 1, plan.getPredecessors(stor).size() );
-        
-        assertTrue( plan.getPredecessors(filter).contains(load) );
-        assertEquals( 1, plan.getPredecessors(filter).size() );
-        
-        assertTrue( plan.getPredecessors(foreach).contains(filter) );
-        assertEquals( 1, plan.getPredecessors(foreach).size() );
-        
-        assertEquals( load.getSchema().getField(0).uid , namePrj2.getFieldSchema().uid );
-        assertEquals( namePrj2.getFieldSchema().uid, prjName.getFieldSchema().uid );
-        
-        assertTrue( foreach.getInnerPlan().getSinks().contains(generate) );
-        assertEquals( 1, foreach.getInnerPlan().getSinks().size() );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad) );
-        assertTrue( foreach.getInnerPlan().getSources().contains(innerLoad2) );
-        assertEquals( 2, foreach.getInnerPlan().getSources().size() );
+        return newLogicalPlan;
     }
     
-    public class MyPlanOptimizer extends PlanOptimizer {
+    private LogicalPlan migratePlan(org.apache.pig.impl.logicalLayer.LogicalPlan lp) throws VisitorException{
+        LogicalPlanMigrationVistor visitor = new LogicalPlanMigrationVistor(lp);        
+        visitor.visit();
+        org.apache.pig.newplan.logical.relational.LogicalPlan newPlan = visitor.getNewLogicalPlan();
+        return newPlan;
+    }
 
-        protected MyPlanOptimizer(OperatorPlan p, List<Set<Rule>> rs,
-                int iterations) {
-            super(p, rs, iterations);           
+    public class MyPlanOptimizer extends LogicalPlanOptimizer {
+        protected MyPlanOptimizer(OperatorPlan p,  int iterations) {
+            super(p, iterations, new HashSet<String>());
         }
         
         public void addPlanTransformListener(PlanTransformListener listener) {
             super.addPlanTransformListener(listener);
         }
         
-    }
+       protected List<Set<Rule>> buildRuleSets() {            
+            List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
+            
+            Set<Rule> s = new HashSet<Rule>();
+            // add split filter rule
+            Rule r = new LoadTypeCastInserter( "TypeCastInserter" );
+            s.add(r);
+            ls.add(s);
+             
+            s = new HashSet<Rule>();
+            r = new FilterAboveForeach( "FilterAboveForeach" );
+            s.add(r);            
+            ls.add(s);
+            
+            return ls;
+        }
+    }    
 }
