diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 927479c66..ae6eff9ff 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -398,7 +398,11 @@ public class PigServer {
             if(null == op) {
                 throw new IOException("Unable to find an operator for alias " + alias);
             }
-            LogicalPlan lp = compileLp(getPlanFromAlias(alias, op.getClass().getName()), "explain");
+            LogicalPlan storePlan = QueryParser.generateStorePlan(opTable,
+                scope, getPlanFromAlias(alias, op.getClass().getName()),
+                "fakefile", PigStorage.class.getName(), aliasOp.get(alias),
+                aliases);
+            LogicalPlan lp = compileLp(storePlan, "explain");
             stream.println("Logical Plan:");
             LOPrinter lv = new LOPrinter(stream, lp);
             lv.visit();
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java
index 3242afc51..331de4acc 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java
@@ -167,7 +167,6 @@ public class PigMapReduce {
                         return;
                     }
                     
-                    log.info("Attaching " + packRes + " to " + rp.getRoots());
                     rp.attachInput(packRes);
 
                     List<PhysicalOperator> leaves = rp.getLeaves();
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
index c42b9835a..289d2196c 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
@@ -21,6 +21,9 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
 import org.apache.pig.impl.plan.DepthFirstWalker;
 import org.apache.pig.impl.plan.PlanWalker;
 import org.apache.pig.impl.plan.VisitorException;
@@ -41,6 +44,8 @@ import org.apache.pig.impl.logicalLayer.LOVisitor;
 
 public abstract class LogicalTransformer extends Transformer<LogicalOperator, LogicalPlan> {
 
+    private final Log log = LogFactory.getLog(getClass());
+
     protected LogicalTransformer(
             LogicalPlan plan,
             PlanWalker<LogicalOperator, LogicalPlan> walker) {
@@ -185,8 +190,19 @@ public abstract class LogicalTransformer extends Transformer<LogicalOperator, Lo
             plans.addAll(((LOSort)before).getSortColPlans());
         } else if (before instanceof LOFilter) {
             plans.add(((LOFilter)before).getComparisonPlan());
-        } else if (before instanceof LOSplitOutput) {
-            plans.add(((LOSplitOutput)before).getConditionPlan());
+        } else if (before instanceof LOSplit) {
+            // In this case we have to find each of the Split outputs, and
+            // add their plans.
+            List<LogicalOperator> splitOutputs = mPlan.getSuccessors(before);
+            for (LogicalOperator so : splitOutputs) {
+                if (!(so instanceof LOSplitOutput)) {
+                    String msg = "Found an LOSplit with an operator other " 
+                        + "than LOSplitOutput after it!";
+                    log.error(msg);
+                    throw new VisitorException(msg);
+                }
+                plans.add(((LOSplitOutput)so).getConditionPlan());
+            }
         } else if (before instanceof LOForEach) {
             plans.addAll(((LOForEach)before).getForEachPlans());
         }
