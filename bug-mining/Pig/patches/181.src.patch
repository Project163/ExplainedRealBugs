diff --git a/CHANGES.txt b/CHANGES.txt
index a18c4c879..7da7b70cf 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -31,6 +31,9 @@ PIG-700: To automate the pig patch test process (gkesavan via sms)
 PIG-712: Added utility functions to create schemas for tuples and bags (zjffdu
 via gates).
 
+PIG-775: PORelationToExprProject should create a NonSpillableDataBag to create
+empty bags (pradeepkth)
+
 BUG FIXES
 
 PIG-733: Order by sampling dumps entire sample to hdfs which causes dfs
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORelationToExprProject.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORelationToExprProject.java
index 7b580ce21..6b50e9a5e 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORelationToExprProject.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORelationToExprProject.java
@@ -25,6 +25,7 @@ import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataType;
+import org.apache.pig.data.NonSpillableDataBag;
 import org.apache.pig.impl.plan.NodeIdGenerator;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
@@ -109,7 +110,7 @@ public class PORelationToExprProject extends POProject {
                 // we received an EOP from the predecessor
                 // since the successor in the pipeline is
                 // expecting a bag, send an empty bag
-                input.result = bagFactory.newDefaultBag();
+                input.result = new NonSpillableDataBag();
                 input.returnStatus = POStatus.STATUS_OK;
                 // we should send EOP the next time we are called
                 // if the foreach in which this operator is present
diff --git a/src/org/apache/pig/data/DefaultAbstractBag.java b/src/org/apache/pig/data/DefaultAbstractBag.java
index e86535d51..e1713de31 100644
--- a/src/org/apache/pig/data/DefaultAbstractBag.java
+++ b/src/org/apache/pig/data/DefaultAbstractBag.java
@@ -188,7 +188,7 @@ public abstract class DefaultAbstractBag implements DataBag {
                 while (i.hasNext()) thisClone.add(i.next());
             }
             if (other instanceof SortedDataBag ||
-                    this instanceof DistinctDataBag) {
+                    other instanceof DistinctDataBag) {
                 otherClone = bOther;
             } else {
                 otherClone = new SortedDataBag(null);
diff --git a/src/org/apache/pig/data/NonSpillableDataBag.java b/src/org/apache/pig/data/NonSpillableDataBag.java
index 54d3fc8ab..ffe8e8031 100644
--- a/src/org/apache/pig/data/NonSpillableDataBag.java
+++ b/src/org/apache/pig/data/NonSpillableDataBag.java
@@ -203,8 +203,26 @@ public class NonSpillableDataBag implements DataBag {
                 else return -1;
             }
 
-            Iterator<Tuple> thisIt = this.iterator();
-            Iterator<Tuple> otherIt = bOther.iterator();
+            // Ugh, this is bogus.  But I have to know if two bags have the
+            // same tuples, regardless of order.  Hopefully most of the
+            // time the size check above will prevent this.
+            // If either bag isn't already sorted, create a sorted bag out
+            // of it so I can guarantee order.
+            DataBag thisClone;
+            DataBag otherClone;
+            thisClone = new SortedDataBag(null);
+            Iterator<Tuple> i = iterator();
+            while (i.hasNext()) thisClone.add(i.next());
+            if (other instanceof SortedDataBag ||
+                    other instanceof DistinctDataBag) {
+                otherClone = bOther;
+            } else {
+                otherClone = new SortedDataBag(null);
+                i = bOther.iterator();
+                while (i.hasNext()) otherClone.add(i.next());
+            }
+            Iterator<Tuple> thisIt = thisClone.iterator();
+            Iterator<Tuple> otherIt = otherClone.iterator();
             while (thisIt.hasNext() && otherIt.hasNext()) {
                 Tuple thisT = thisIt.next();
                 Tuple otherT = otherIt.next();
diff --git a/test/org/apache/pig/test/TestDataBag.java b/test/org/apache/pig/test/TestDataBag.java
index 1362eda80..bdaffc549 100644
--- a/test/org/apache/pig/test/TestDataBag.java
+++ b/test/org/apache/pig/test/TestDataBag.java
@@ -729,6 +729,68 @@ public class TestDataBag extends junit.framework.TestCase {
 
         BagFactory.resetSelf();
     }
+    
+    @Test
+    public void testNonSpillableDataBagEquals1() throws Exception {
+        String[][] tupleContents = new String[][] {{"a", "b"},{"c", "d" }, { "e", "f"} };
+        NonSpillableDataBag bg1 = new NonSpillableDataBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg1.add(Util.createTuple(tupleContents[i]));
+        }
+        NonSpillableDataBag bg2 = new NonSpillableDataBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg2.add(Util.createTuple(tupleContents[i]));
+        }
+        assertEquals(bg1, bg2);
+    }
+    
+    @Test
+    public void testNonSpillableDataBagEquals2() throws Exception {
+        String[][] tupleContents = new String[][] {{"a", "b"},{"c", "d" }, { "e", "f"} };
+        NonSpillableDataBag bg1 = new NonSpillableDataBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg1.add(Util.createTuple(tupleContents[i]));
+        }
+        tupleContents = new String[][] {{"c", "d" }, {"a", "b"},{ "e", "f"} };
+        NonSpillableDataBag bg2 = new NonSpillableDataBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg2.add(Util.createTuple(tupleContents[i]));
+        }
+        assertEquals(bg1, bg2);
+    }
+    
+    @Test
+    public void testDefaultDataBagEquals1() throws Exception {
+        String[][] tupleContents = new String[][] {{"a", "b"},{"c", "d" }, { "e", "f"} };
+        TestMemoryManager mgr = new TestMemoryManager();
+        LocalBagFactory factory = new LocalBagFactory(mgr);
+        DataBag bg1 = factory.newDefaultBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg1.add(Util.createTuple(tupleContents[i]));
+        }
+        DataBag bg2 = factory.newDefaultBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg2.add(Util.createTuple(tupleContents[i]));
+        }
+        assertEquals(bg1, bg2);
+    }
+    
+    @Test
+    public void testDefaultDataBagEquals2() throws Exception {
+        String[][] tupleContents = new String[][] {{"a", "b"},{"c", "d" }, { "e", "f"} };
+        TestMemoryManager mgr = new TestMemoryManager();
+        LocalBagFactory factory = new LocalBagFactory(mgr);
+        DataBag bg1 = factory.newDefaultBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg1.add(Util.createTuple(tupleContents[i]));
+        }
+        tupleContents = new String[][] {{"c", "d" }, {"a", "b"},{ "e", "f"} };
+        DataBag bg2 = factory.newDefaultBag();
+        for (int i = 0; i < tupleContents.length; i++) {
+            bg2.add(Util.createTuple(tupleContents[i]));
+        }
+        assertEquals(bg1, bg2);
+    }
 }
 
 
