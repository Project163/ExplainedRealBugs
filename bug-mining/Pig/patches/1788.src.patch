diff --git a/CHANGES.txt b/CHANGES.txt
index 711a4bd20..0c9d87638 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -79,6 +79,8 @@ PIG-4639: Add better parser for Apache HTTPD access log (nielsbasjes via daijy)
 
 BUG FIXES
 
+PIG-4773: [Pig on Tez] Secondary key descending sort in nested foreach after union does ascending instead (rohini)
+
 PIG-4774: Fix NPE in SUM,AVG,MIN,MAX UDFs for null bag input (rohini)
 
 PIG-4757: Job stats on successfully read/output records wrong with multiple inputs/outputs (rohini)
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigSecondaryKeyComparator.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigSecondaryKeyComparator.java
index cb86f3cd0..0b349d834 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigSecondaryKeyComparator.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigSecondaryKeyComparator.java
@@ -17,19 +17,18 @@
  */
 package org.apache.pig.backend.hadoop.executionengine.mapReduceLayer;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.conf.Configurable;
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.io.WritableComparable;
 import org.apache.hadoop.io.WritableComparator;
-import org.apache.hadoop.mapred.JobConf;
+import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.data.TupleRawComparator;
 import org.apache.pig.impl.io.NullableTuple;
 import org.apache.pig.impl.io.PigNullableWritable;
 
 public class PigSecondaryKeyComparator extends WritableComparator implements Configurable {
-    private final Log mLog = LogFactory.getLog(getClass());
+
     private TupleRawComparator mComparator=null;
 
     @Override
@@ -54,6 +53,7 @@ public class PigSecondaryKeyComparator extends WritableComparator implements Con
         return null;
     }
 
+    @Override
     public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {
 
         // the last byte of a NullableTuple is its Index
@@ -87,4 +87,45 @@ public class PigSecondaryKeyComparator extends WritableComparator implements Con
         }
         return rc;
     }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public int compare(WritableComparable a, WritableComparable b)
+    {
+        PigNullableWritable wa = (PigNullableWritable)a;
+        PigNullableWritable wb = (PigNullableWritable)b;
+
+        if ((wa.getIndex() & PigNullableWritable.mqFlag) != 0) { // this is a multi-query index
+            if ((wa.getIndex() & PigNullableWritable.idxSpace) < (wb.getIndex() & PigNullableWritable.idxSpace))
+                return -1;
+            else if ((wa.getIndex() & PigNullableWritable.idxSpace) > (wb.getIndex() & PigNullableWritable.idxSpace))
+                return 1;
+            // If equal, we fall through
+        }
+
+        int rc = 0;
+        // If either are null, handle differently.
+        if (!wa.isNull() && !wb.isNull()) {
+            rc = mComparator.compare((Tuple) wa.getValueAsPigType(), (Tuple) wb.getValueAsPigType());
+            // handle PIG-927
+            // if tuples are equal but any field inside tuple is null, then we do not merge keys
+            if (rc == 0 && mComparator.hasComparedTupleNull())
+                rc = (wa.getIndex() & PigNullableWritable.idxSpace) - (wb.getIndex() & PigNullableWritable.idxSpace);
+        } else {
+            // Two nulls are equal if indices are same
+            if (wa.isNull() && wb.isNull()) {
+                if ((wa.getIndex() & PigNullableWritable.idxSpace) < (wb.getIndex() & PigNullableWritable.idxSpace))
+                    rc = -1;
+                else if ((wa.getIndex() & PigNullableWritable.idxSpace) > (wb.getIndex() & PigNullableWritable.idxSpace))
+                    rc = 1;
+                else
+                    rc = 0;
+            }
+            else if (wa.isNull())
+                rc = -1;
+            else
+                rc = 1;
+        }
+        return rc;
+    }
 }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/tez/TezDagBuilder.java b/src/org/apache/pig/backend/hadoop/executionengine/tez/TezDagBuilder.java
index e1c2dfc5d..290747ee1 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/tez/TezDagBuilder.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/tez/TezDagBuilder.java
@@ -584,6 +584,7 @@ public class TezDagBuilder extends TezOpPlanVisitor {
             // the inputs that are attached to the POShuffleTezLoad in the
             // backend.
             Map<Integer, String> localRearrangeMap = new TreeMap<Integer, String>();
+            TezOperator from = null;
             for (TezOperator pred : mPlan.getPredecessors(tezOp)) {
                 if (tezOp.getSampleOperator() != null && tezOp.getSampleOperator() == pred) {
                     // skip sample vertex input
@@ -603,6 +604,7 @@ public class TezDagBuilder extends TezOpPlanVisitor {
                             if (isVertexGroup) {
                                 isMergedInput = true;
                             }
+                            from = pred;
                         }
                     }
                 }
@@ -619,6 +621,16 @@ public class TezDagBuilder extends TezOpPlanVisitor {
 
             //POShuffleTezLoad accesses the comparator setting
             selectKeyComparator(keyType, payloadConf, tezOp, isMergedInput);
+
+            if (tezOp.isUseSecondaryKey()) {
+                TezEdgeDescriptor edge = tezOp.inEdges.get(from.getOperatorKey());
+                // Currently only PigSecondaryKeyGroupingComparator is used in POShuffleTezLoad.
+                // When PIG-4685: SecondaryKeyOptimizerTez does not optimize cogroup is fixed
+                // in future, PigSecondaryKeyComparator will have to be used and that will require this.
+                payloadConf.set("pig.secondarySortOrder", ObjectSerializer
+                        .serialize(edge.getSecondarySortOrder()));
+            }
+
         }
 
         // set parent plan in all operators. currently the parent plan is really
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/tez/plan/optimizer/SecondaryKeyOptimizerTez.java b/src/org/apache/pig/backend/hadoop/executionengine/tez/plan/optimizer/SecondaryKeyOptimizerTez.java
index bb9e3af67..c56f83fdf 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/tez/plan/optimizer/SecondaryKeyOptimizerTez.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/tez/plan/optimizer/SecondaryKeyOptimizerTez.java
@@ -56,12 +56,13 @@ public class SecondaryKeyOptimizerTez extends TezOpPlanVisitor implements Second
             return;
         }
 
+        // TODO: PIG-4685: SecondaryKeyOptimizerTez does not optimize cogroup
         // Current code does not handle more than one predecessors
         // even though it is possible. The problem is when we
         // process the first predecessor, we remove the foreach inner
         // operators from the reduce side, and the second predecessor
         // cannot see them
-        if (predecessors.size()>1) {
+        if (predecessors.size() > 1) {
             return;
         }
         TezOperator from = predecessors.get(0);
diff --git a/src/org/apache/pig/data/BinInterSedes.java b/src/org/apache/pig/data/BinInterSedes.java
index 66f9890ca..2737f4dfd 100644
--- a/src/org/apache/pig/data/BinInterSedes.java
+++ b/src/org/apache/pig/data/BinInterSedes.java
@@ -1072,7 +1072,7 @@ public class BinInterSedes implements InterSedes {
                         // we have a compound tuple key (main_key, secondary_key). Each key has its own sort order, so
                         // we have to deal with them separately. We delegate it to the first invocation of
                         // compareDatum()
-                        assert (tsz1 == 3); // main_key, secondary_key, value
+                        assert (tsz1 == 2); // main_key, secondary_key
                         result = compareDatum(t1.get(0), t2.get(0), mAsc);
                         if (result == 0)
                             result = compareDatum(t1.get(1), t2.get(1), mSecondaryAsc);
diff --git a/test/e2e/pig/tests/nightly.conf b/test/e2e/pig/tests/nightly.conf
index 1bac9f4aa..2afc52ad5 100644
--- a/test/e2e/pig/tests/nightly.conf
+++ b/test/e2e/pig/tests/nightly.conf
@@ -1424,8 +1424,11 @@ store e into ':OUTPATH:';\,
 b = load ':INPATH:/singlefile/studentcolon10k' using PigStorage(':') as (name, age, gpa);
 c = union a, b;
 d = group c by name;
-e = foreach d { f = order c by $1,$2; generate group, f; };
-store e into ':OUTPATH:';\,
+d1 = group c by name; -- Two separate groupbys to ensure secondary key partitioner
+e = foreach d { f = order c by age, gpa ; g = limit f 1; generate g; };
+h = foreach d1 { i = order c by age asc, gpa desc; j = limit i 1; generate j; };
+store e into ':OUTPATH:.1';
+store h into ':OUTPATH:.2';\,
             },
             {
             # Union + Orderby
