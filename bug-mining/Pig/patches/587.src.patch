diff --git a/CHANGES.txt b/CHANGES.txt
index dd45a038c..5089b96c4 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -220,6 +220,8 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1729: New logical plan: Dereference does not add into plan after deepCopy (daijy)
+
 PIG-1721: New logical plan: script fail when reuse foreach inner alias (daijy)
 
 PIG-1716: New logical plan: LogToPhyTranslationVisitor should translate the structure for regex optimization (daijy)
diff --git a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
index fa7b149fe..c9e6587fe 100644
--- a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
@@ -55,12 +55,14 @@ public class DereferenceExpression extends ColumnExpression {
         super( "Dereference", plan );
         columns = new ArrayList<Integer>();
         columns.add(colNum);
+        plan.add(this);
     }
 
     public DereferenceExpression(OperatorPlan plan, List<Integer> columnNums) {
         super( "Dereference", plan );
         columns = new ArrayList<Integer>();
         columns.addAll(columnNums);
+        plan.add(this);
     }
 
     /**
diff --git a/src/org/apache/pig/newplan/logical/rules/GroupByConstParallelSetter.java b/src/org/apache/pig/newplan/logical/rules/GroupByConstParallelSetter.java
index 883659d15..463c3d94b 100644
--- a/src/org/apache/pig/newplan/logical/rules/GroupByConstParallelSetter.java
+++ b/src/org/apache/pig/newplan/logical/rules/GroupByConstParallelSetter.java
@@ -55,8 +55,7 @@ public class GroupByConstParallelSetter extends Rule {
     }
     private final static Log log = LogFactory.getLog(GroupByConstParallelSetter.class);
 
-    public static class GroupAllParallelSetterTransformer extends Transformer {
-        private OperatorPlan plan;
+    public class GroupAllParallelSetterTransformer extends Transformer {
 
         @Override
         public boolean check(OperatorPlan matched) throws FrontendException {
@@ -84,7 +83,6 @@ public class GroupByConstParallelSetter extends Rule {
 
         @Override
         public void transform(OperatorPlan plan) throws FrontendException {
-            this.plan = ((OperatorSubPlan) plan).getBasePlan();
             Iterator<Operator> iter = plan.getOperators();
             while (iter.hasNext()) {
                 Operator op = iter.next();
@@ -103,7 +101,7 @@ public class GroupByConstParallelSetter extends Rule {
  
         @Override
         public OperatorPlan reportChanges() {
-            return plan;
+            return new OperatorSubPlan(currentPlan);
         }
     }
 
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index db697eefc..3d04db2b9 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -842,4 +842,32 @@ public class TestEvalPipeline2 extends TestCase {
         
         assertFalse(iter.hasNext());
     }
+    
+    // See PIG-1729
+    @Test
+    public void testDereferenceInnerPlan() throws Exception{
+        String[] input1 = {
+                "1\t2\t3"
+        };
+        
+        String[] input2 = {
+                "1\t1"
+        };
+        
+        Util.createInputFile(cluster, "table_testDereferenceInnerPlan1", input1);
+        Util.createInputFile(cluster, "table_testDereferenceInnerPlan2", input2);
+        pigServer.registerQuery("a = load 'table_testDereferenceInnerPlan1' as (a0:int, a1:int, a2:int);");
+        pigServer.registerQuery("b = load 'table_testDereferenceInnerPlan2' as (b0:int, b1:int);");
+        pigServer.registerQuery("c = cogroup a by a0, b by b0;");
+        pigServer.registerQuery("d = foreach c generate ((COUNT(a)==0L)?null : a.a0) as d0;");
+        pigServer.registerQuery("e = foreach d generate flatten(d0);");
+        pigServer.registerQuery("f = group e all;");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("f");
+        
+        Tuple t = iter.next();
+        assertTrue(t.toString().equals("(all,{(1)})"));
+        
+        assertFalse(iter.hasNext());
+    }
 }
