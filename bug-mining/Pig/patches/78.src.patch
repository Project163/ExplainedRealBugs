diff --git a/CHANGES.txt b/CHANGES.txt
index 006d0091c..df39edd39 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -190,8 +190,9 @@ Trunk (unreleased changes)
 
     PIG-422: cross is broken (shravanmn via olgan)
 
-    PIG-407: need to clone operators (pradeepk vi olgan)
+    PIG-407: need to clone operators (pradeepk via olgan)
 
     PIG-428: TypeCastInserter does not replace projects in inner plans
     correctly (pradeepk vi olgan)
 
+    PIG-421: error with complex nested plan (sms via olgan)
diff --git a/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java b/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java
index 2dc986e0c..02aeb45ae 100644
--- a/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/ExpressionOperator.java
@@ -20,6 +20,7 @@ package org.apache.pig.impl.logicalLayer;
 import java.util.List;
 import java.util.ArrayList;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.plan.OperatorKey;
@@ -100,6 +101,11 @@ public abstract class ExpressionOperator extends LogicalOperator {
         mIsFieldSchemaComputed = false;
         mFieldSchema = null;
     }
+    
+    public Schema.FieldSchema regenerateFieldSchema() throws FrontendException {
+        unsetFieldSchema();
+        return getFieldSchema();
+    }
 
     void setFieldSchemaComputed(boolean b) {
         mIsFieldSchemaComputed = b;
@@ -109,5 +115,24 @@ public abstract class ExpressionOperator extends LogicalOperator {
         return mIsFieldSchemaComputed;
     }
 
+    @Override
+    public byte getType() {                         
+        // Called to make sure we've constructed the field schema before trying
+        // to read it.
+        try {
+            getFieldSchema();
+        } catch (FrontendException fe) {
+            return DataType.UNKNOWN;
+        }
+
+        if (mFieldSchema != null){
+            return mFieldSchema.type ;
+        }
+        else {
+            return DataType.UNKNOWN ;
+        }
+    }
+
+
 }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOAdd.java b/src/org/apache/pig/impl/logicalLayer/LOAdd.java
index e2094167b..7827ed487 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOAdd.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOAdd.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,13 +54,14 @@ public class LOAdd extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
-        // TODO When tuple addition is implemented, getSchema should
-        // compute the schema, store the computed schema and return
-        // the computed schema
-
+        if(!mIsFieldSchemaComputed) {
+            mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mIsFieldSchemaComputed = true;
+        }
         return mFieldSchema;
     }
 
+
     @Override
     public void visit(LOVisitor v) throws VisitorException {
         v.visit(this);
diff --git a/src/org/apache/pig/impl/logicalLayer/LOAnd.java b/src/org/apache/pig/impl/logicalLayer/LOAnd.java
index 26334e611..12c80d88a 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOAnd.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOAnd.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOAnd extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index 4b73dabec..7caaa08c8 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -29,6 +29,7 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
@@ -185,6 +186,7 @@ public class LOCogroup extends LogicalOperator {
                                         } else {
                                             groupByFss.add(new Schema.FieldSchema(alias, null, DataType.BYTEARRAY));
                                         }
+                                        break;
                                     } else {
                                         if(j < aliases.length) {
                                             continue;
@@ -225,11 +227,31 @@ public class LOCogroup extends LogicalOperator {
             groupBySchema = new Schema(groupByFss);
 
             if(1 == arity) {
-                byte groupByType = groupByFss.get(0).type;
+                byte groupByType = getAtomicGroupByType();
                 Schema groupSchema = groupByFss.get(0).schema;
                 fss.add(new Schema.FieldSchema("group", groupSchema, groupByType));
             } else {
-                fss.add(new Schema.FieldSchema("group", groupBySchema));
+                Schema mergedGroupSchema = getTupleGroupBySchema();
+                if(mergedGroupSchema.size() != groupBySchema.size()) {
+                    mSchema = null;
+                    mIsSchemaComputed = false;
+                    throw new FrontendException("Internal error. Mismatch in group by arities. Expected: " + mergedGroupSchema + ". Found: " + groupBySchema);
+                } else {
+                    for(int i = 0; i < mergedGroupSchema.size(); ++i) {
+                        try {
+                            Schema.FieldSchema mergedFs = mergedGroupSchema.getField(i);
+                            Schema.FieldSchema groupFs = groupBySchema.getField(i);
+                            mergedFs.alias = groupFs.alias;
+                            mergedGroupSchema.addAlias(mergedFs.alias, mergedFs);
+                        } catch (ParseException pe) {
+                            mSchema = null;
+                            mIsSchemaComputed = false;
+                            throw new FrontendException(pe.getMessage());
+                        }
+                    }
+                }
+                
+                fss.add(new Schema.FieldSchema("group", mergedGroupSchema));
             }
             for (LogicalOperator op : inputs) {
                 try {
@@ -244,6 +266,7 @@ public class LOCogroup extends LogicalOperator {
             }
             mIsSchemaComputed = true;
             mSchema = new Schema(fss);
+            mType = DataType.BAG;//mType is from the super class
         }
         return mSchema;
     }
@@ -281,14 +304,82 @@ public class LOCogroup extends LogicalOperator {
         mGroupByPlans.put(newOp, innerPlans);
     }
 
-    public void resetSchema() throws VisitorException{
+    public void unsetSchema() throws VisitorException{
         for(LogicalOperator input: getInputs()) {
             for(LogicalPlan plan: mGroupByPlans.get(input)) {
                 SchemaRemover sr = new SchemaRemover(plan);
                 sr.visit();
             }
         }
-        unsetSchema();
+        super.unsetSchema();
+    }
+
+    /**
+     * This can be used to get the merged type of output group col
+     * only when the group col is of atomic type
+     * TODO: This doesn't work with group by complex type
+     * @return The type of the group by
+     */
+    public byte getAtomicGroupByType() throws FrontendException {
+        if (isTupleGroupCol()) {
+            throw new FrontendException("getAtomicGroupByType is used only when"
+                                     + " dealing with atomic group col") ;
+        }
+        byte groupType = DataType.BYTEARRAY ;
+        // merge all the inner plan outputs so we know what type
+        // our group column should be
+        for(int i=0;i < getInputs().size(); i++) {
+            LogicalOperator input = getInputs().get(i) ;
+            List<LogicalPlan> innerPlans
+                        = new ArrayList<LogicalPlan>(getGroupByPlans().get(input)) ;
+            if (innerPlans.size() != 1) {
+                throw new FrontendException("Each COGroup input has to have "
+                                         + "the same number of inner plans") ;
+            }
+            byte innerType = innerPlans.get(0).getSingleLeafPlanOutputType() ;
+            groupType = DataType.mergeType(groupType, innerType) ;
+        }
+
+        return groupType ;
+    }
+
+    /*
+        This implementation is based on the assumption that all the
+        inputs have the same group col tuple arity.
+        TODO: This doesn't work with group by complex type
+     */
+    public Schema getTupleGroupBySchema() throws FrontendException {
+        if (!isTupleGroupCol()) {
+            throw new FrontendException("getTupleGroupBySchema is used only when"
+                                     + " dealing with tuple group col") ;
+        }
+
+        // this fsList represents all the columns in group tuple
+        List<Schema.FieldSchema> fsList = new ArrayList<Schema.FieldSchema>() ;
+
+        int outputSchemaSize = getGroupByPlans().get(getInputs().get(0)).size() ;
+
+        // by default, they are all bytearray
+        // for type checking, we don't care about aliases
+        for(int i=0; i<outputSchemaSize; i++) {
+            fsList.add(new Schema.FieldSchema(null, DataType.BYTEARRAY)) ;
+        }
+
+        // merge all the inner plan outputs so we know what type
+        // our group column should be
+        for(int i=0;i < getInputs().size(); i++) {
+            LogicalOperator input = getInputs().get(i) ;
+            List<LogicalPlan> innerPlans
+                        = new ArrayList<LogicalPlan>(getGroupByPlans().get(input)) ;
+
+            for(int j=0;j < innerPlans.size(); j++) {
+                byte innerType = innerPlans.get(j).getSingleLeafPlanOutputType() ;
+                fsList.get(j).type = DataType.mergeType(fsList.get(j).type,
+                                                        innerType) ;
+            }
+        }
+
+        return new Schema(fsList) ;
     }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCross.java b/src/org/apache/pig/impl/logicalLayer/LOCross.java
index edacc0dcd..88b91b7b0 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCross.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCross.java
@@ -104,8 +104,9 @@ public class LOCross extends LogicalOperator {
                         }
                     }
                 } else {
-                    Schema.FieldSchema newFs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
-                    fss.add(newFs);
+                    mSchema = null;
+                    mIsSchemaComputed = true;
+                    return mSchema;
                 }
             }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LODivide.java b/src/org/apache/pig/impl/logicalLayer/LODivide.java
index 872d215f8..b514024e3 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODivide.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODivide.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,9 +54,10 @@ public class LODivide extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
-        // TODO When tuple division by a scalar is implemented, getFieldSchema should
-        // compute the schema, store and return the computed schema 
-
+        if(!mIsFieldSchemaComputed) {
+            mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mIsFieldSchemaComputed = true;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOEqual.java b/src/org/apache/pig/impl/logicalLayer/LOEqual.java
index f8705baa1..667b4474b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOEqual.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOEqual extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFilter.java b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
index ab48ab1ce..385a9b749 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
@@ -25,6 +25,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -107,4 +108,11 @@ public class LOFilter extends LogicalOperator {
         return DataType.BAG ;
     }
 
+    public void unsetSchema() throws VisitorException{
+        SchemaRemover sr = new SchemaRemover(mComparisonPlan);
+        sr.visit();
+        super.unsetSchema();
+    }
+
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 7824f8f79..dde924fe2 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -328,12 +328,12 @@ public class LOForEach extends LogicalOperator {
         return mSchema;
     }
 
-    public void resetSchema() throws VisitorException{
+    public void unsetSchema() throws VisitorException{
         for(LogicalPlan plan: mForEachPlans) {
             SchemaRemover sr = new SchemaRemover(plan);
             sr.visit();
         }
-        unsetSchema();
+        super.unsetSchema();
     }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java b/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
index 644267139..fcf535caf 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOGreaterThan extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java b/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
index 24d1bc784..0d86ac543 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOGreaterThanEqual extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOIsNull.java b/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
index 188bc365d..5cd65773c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -51,6 +52,10 @@ public class LOIsNull extends UnaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java b/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
index 733d6e67e..a644ba108 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOLesserThan extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java b/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
index 8058452be..289efffc8 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOLesserThanEqual extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMod.java b/src/org/apache/pig/impl/logicalLayer/LOMod.java
index 351d2ce21..731e1cb54 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMod.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMod.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOMod extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mIsFieldSchemaComputed = true;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMultiply.java b/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
index 1306fad2b..c0bfe09da 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,9 +54,10 @@ public class LOMultiply extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
-        // TODO When tuple multiplication is implemented, getFieldSchema should
-        // compute the schema, store and return the computed schema
-
+        if(!mIsFieldSchemaComputed) {
+            mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mIsFieldSchemaComputed = true;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LONegative.java b/src/org/apache/pig/impl/logicalLayer/LONegative.java
index 16e7286f1..ebd12f521 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONegative.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONegative.java
@@ -48,6 +48,10 @@ public class LONegative extends UnaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsSchemaComputed) {
+            mFieldSchema = new Schema.FieldSchema(null, getOperand().getType());
+            mIsFieldSchemaComputed = true;
+        }
         return mFieldSchema;
     }
 
@@ -61,12 +65,5 @@ public class LONegative extends UnaryExpressionOperator {
         return "Negative " + mKey.scope + "-" + mKey.id;
     }
 
-    // Return type is the same as input
-    // This might not be a number type which is wrong
-    // but the post-parsing logic will eventually detect it.
-    @Override
-    public byte getType() {
-        return mOperand.getType() ;
-    }
     
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LONot.java b/src/org/apache/pig/impl/logicalLayer/LONot.java
index 09bc95068..8158a20c5 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONot.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONot.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -51,6 +52,10 @@ public class LONot extends UnaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LONotEqual.java b/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
index 06ca799df..fc8625a80 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LONotEqual extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOOr.java b/src/org/apache/pig/impl/logicalLayer/LOOr.java
index 144a954be..3731422c2 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOOr.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOOr.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,6 +54,10 @@ public class LOOr extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOProject.java b/src/org/apache/pig/impl/logicalLayer/LOProject.java
index a875ff254..2954b574b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOProject.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOProject.java
@@ -301,6 +301,34 @@ public class LOProject extends ExpressionOperator {
             }
         }
 
+        if(null != mFieldSchema) {
+            mType = mFieldSchema.type;
+        }
+        
+        List<LogicalOperator> succList = mPlan.getSuccessors(this) ;
+        List<LogicalOperator> predList = mPlan.getPredecessors(this) ;
+        if((null != succList) && !(succList.get(0) instanceof ExpressionOperator)) {
+            if(!DataType.isSchemaType(mType)) {
+                Schema pjSchema = new Schema(mFieldSchema);
+                mFieldSchema = new Schema.FieldSchema(getAlias(), pjSchema, DataType.TUPLE);
+            } else {
+                mFieldSchema.type = DataType.TUPLE;
+            }
+            setOverloaded(true);
+            setType(DataType.TUPLE);
+        } else if(null != predList) {
+            LogicalOperator projectInput = getExpression();
+            if(((projectInput instanceof LOProject) || !(predList.get(0) instanceof ExpressionOperator)) && (projectInput.getType() == DataType.BAG)) {
+                if(!DataType.isSchemaType(mType)) {
+                    Schema pjSchema = new Schema(mFieldSchema);
+                    mFieldSchema = new Schema.FieldSchema(getAlias(), pjSchema, DataType.BAG);
+                } else {
+                    mFieldSchema.type = DataType.BAG;
+                }
+                setType(DataType.BAG);
+            }
+        }
+        
         log.debug("Exiting getFieldSchema");
         return mFieldSchema;
     }
@@ -314,24 +342,6 @@ public class LOProject extends ExpressionOperator {
         v.visit(this);
     }
 
-    @Override
-    public byte getType() {                         
-        // Called to make sure we've constructed the field schema before trying
-        // to read it.
-        try {
-            getFieldSchema();
-        } catch (FrontendException fe) {
-            return DataType.UNKNOWN;
-        }
-
-        if (mFieldSchema != null){
-            return mFieldSchema.type ;
-        }
-        else {
-            return DataType.UNKNOWN ;
-        }
-    }
-
     @Override
     public Schema getSchema() throws FrontendException{
         // Called to make sure we've constructed the field schema before trying
diff --git a/src/org/apache/pig/impl/logicalLayer/LORegexp.java b/src/org/apache/pig/impl/logicalLayer/LORegexp.java
index 71d62da50..4a91ff827 100644
--- a/src/org/apache/pig/impl/logicalLayer/LORegexp.java
+++ b/src/org/apache/pig/impl/logicalLayer/LORegexp.java
@@ -94,6 +94,10 @@ public class LORegexp extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
+        if(!mIsFieldSchemaComputed) {
+            Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
+            mFieldSchema = fs;
+        }
         return mFieldSchema;
     }
 
@@ -102,9 +106,5 @@ public class LORegexp extends BinaryExpressionOperator {
         v.visit(this);
     }
 
-    @Override
-    public byte getType() {
-        return DataType.BOOLEAN ;
-    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
index dbb9bef8c..563e2482d 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
@@ -28,6 +28,7 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 
 
 public class LOSplitOutput extends LogicalOperator {
@@ -62,21 +63,19 @@ public class LOSplitOutput extends LogicalOperator {
     
     @Override
     public String name() {
-        return "SplitOutput " + mKey.scope + "-" + mKey.id;
+        return "SplitOutput[" + getAlias() + "] " + mKey.scope + "-" + mKey.id;
     }
 
     @Override
     public Schema getSchema() throws FrontendException{
         if (!mIsSchemaComputed) {
             // get our parent's schema
-            Collection<LogicalOperator> s = mPlan.getPredecessors(this);
-            if(s==null) return null;
             try {
-                LogicalOperator op = s.iterator().next();
-                if (null == op) {
+                LogicalOperator input = mPlan.getPredecessors(this).get(0);
+                if (null == input) {
                     throw new FrontendException("Could not find operator in plan");
                 }
-                mSchema = s.iterator().next().getSchema();
+                mSchema = input.getSchema();
                 mIsSchemaComputed = true;
             } catch (FrontendException fe) {
                 mSchema = null;
@@ -103,4 +102,11 @@ public class LOSplitOutput extends LogicalOperator {
     public byte getType() {
         return DataType.BAG ;
     }
+
+    public void unsetSchema() throws VisitorException{
+        SchemaRemover sr = new SchemaRemover(mCondPlan);
+        sr.visit();
+        super.unsetSchema();
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSubtract.java b/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
index 12f2b64b9..17009ec16 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
@@ -22,6 +22,7 @@ import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -53,10 +54,10 @@ public class LOSubtract extends BinaryExpressionOperator {
 
     @Override
     public Schema.FieldSchema getFieldSchema() {
-        // TODO When tuple subtraction is implemented, getSchema should
-        // compute the schema, store the computed schema and return
-        // the computed schema
-
+        if(!mIsFieldSchemaComputed) {
+            mFieldSchema = new Schema.FieldSchema(null, DataType.mergeType(getLhsOperand().getType(), getRhsOperand().getType()));
+            mIsFieldSchemaComputed = true;
+        }
         return mFieldSchema;
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
index f42489733..3fa71a1d3 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
@@ -19,9 +19,13 @@ package org.apache.pig.impl.logicalLayer;
 
 import java.util.List;
 
+import org.apache.pig.EvalFunc;
 import org.apache.pig.FuncSpec;
+import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 
@@ -75,14 +79,41 @@ public class LOUserFunc extends ExpressionOperator {
     }
 
     @Override
-    public Schema.FieldSchema getFieldSchema() {
-        if (!mIsFieldSchemaComputed) {
-            mFieldSchema = new Schema.FieldSchema(null, mType);
+    public Schema.FieldSchema getFieldSchema() throws FrontendException {
+        Schema inputSchema = new Schema();
+        for(ExpressionOperator op: mArgs) {
+            if (!DataType.isUsableType(op.getType())) {
+                String msg = "Problem with input of User-defined function" ;
+                mFieldSchema = null;
+                mIsFieldSchemaComputed = false;
+                throw new FrontendException(msg) ;
+            }
+            inputSchema.add(op.getFieldSchema());    
+        }
+
+        EvalFunc<?> ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(mFuncSpec);
+        Schema udfSchema = ef.outputSchema(inputSchema);
+
+        if (null != udfSchema) {
+            Schema.FieldSchema fs;
+            try {
+                fs = udfSchema.getField(0);
+            } catch (ParseException pe) {
+                throw new FrontendException(pe.getMessage());
+            }
+            setType(fs.type);
+            mFieldSchema = fs;
+            mIsFieldSchemaComputed = true;
+        } else {
+            byte returnType = DataType.findType(ef.getReturnType());
+            setType(returnType);
+            mFieldSchema = new Schema.FieldSchema(null, null, returnType);
             mIsFieldSchemaComputed = true;
         }
         return mFieldSchema;
     }
 
+
     @Override
     public void visit(LOVisitor v) throws VisitorException {
         v.visit(this);
@@ -94,4 +125,5 @@ public class LOUserFunc extends ExpressionOperator {
     public void setFuncSpec(FuncSpec funcSpec) {
         mFuncSpec = funcSpec;
     }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOVisitor.java b/src/org/apache/pig/impl/logicalLayer/LOVisitor.java
index 0e6ce3dcb..ca43a1a83 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOVisitor.java
@@ -92,8 +92,10 @@ abstract public class LOVisitor extends
         // operand
         //
 
+        /*
         binOp.getLhsOperand().visit(this);
         binOp.getRhsOperand().visit(this);
+        */
     }
 
     /**
@@ -105,7 +107,9 @@ abstract public class LOVisitor extends
     protected void visit(UnaryExpressionOperator uniOp) throws VisitorException {
         // Visit the operand
 
+        /*
         uniOp.getOperand().visit(this);
+        */
     }
 
     /**
@@ -194,9 +198,11 @@ abstract public class LOVisitor extends
      */
     protected void visit(LOSplit split) throws VisitorException {
         // Visit each of split's conditions
+        /*
         for(LogicalOperator logicalOp: split.getOutputs()) {
             logicalOp.visit(this);
         }
+        */
     }
 
     /**
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
index 7a4cb35b2..166ccf80c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
@@ -151,10 +151,15 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
      * Unset the schema as if it had not been calculated.  This is used by
      * anyone who reorganizes the tree and needs to have schemas recalculated.
      */
-    public void unsetSchema() {
+    public void unsetSchema() throws VisitorException {
         mIsSchemaComputed = false;
         mSchema = null;
     }
+
+    public Schema regenerateSchema() throws FrontendException, VisitorException {
+        unsetSchema();
+        return getSchema();
+    }
     
     /**
      * Calculate canonical names for all fields in the schema.  This should
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index e46ff4998..9c670f0e2 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -153,51 +153,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     protected void visit(LOProject pj) throws VisitorException {
         resolveLOProjectType(pj) ;
-
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-        List<LogicalOperator> succList = currentPlan.getSuccessors(pj) ;
-        List<LogicalOperator> predList = currentPlan.getPredecessors(pj) ;
-        if((null != succList) && !(succList.get(0) instanceof ExpressionOperator)) {
-            try {
-                Schema.FieldSchema pjFs = pj.getFieldSchema();
-                if(!DataType.isSchemaType(pj.getType())) {
-                    Schema pjSchema = new Schema(pj.getFieldSchema());
-                    pj.setFieldSchema(new Schema.FieldSchema(pj.getAlias(), pjSchema, DataType.TUPLE));
-                } else {
-                    pjFs.type = DataType.TUPLE;
-                    pj.setFieldSchema(pjFs);
-                }
-                pj.setOverloaded(true);
-                pj.setType(DataType.TUPLE);
-            } catch (FrontendException fe) {
-                String msg = "Error getting LOProject's input schema" ;
-                msgCollector.collect(msg, MessageType.Error);
-                VisitorException vse = new VisitorException(msg) ;
-                vse.initCause(fe) ;
-                throw new VisitorException(msg) ;
-             }
-        } else if(null != predList) {
-            LogicalOperator projectInput = pj.getExpression();
-            if(((projectInput instanceof LOProject) || !(predList.get(0) instanceof ExpressionOperator)) && (projectInput.getType() == DataType.BAG)) {
-                try {
-                    Schema.FieldSchema pjFs = pj.getFieldSchema();
-                    if(!DataType.isSchemaType(pj.getType())) {
-                        Schema pjSchema = new Schema(pj.getFieldSchema());
-                        pj.setFieldSchema(new Schema.FieldSchema(pj.getAlias(), pjSchema, DataType.BAG));
-                    } else {
-                        pjFs.type = DataType.BAG;
-                        pj.setFieldSchema(pjFs);
-                    }
-                    pj.setType(DataType.BAG);
-                } catch (FrontendException fe) {
-                    String msg = "Error getting LOProject's input schema" ;
-                    msgCollector.collect(msg, MessageType.Error);
-                    VisitorException vse = new VisitorException(msg) ;
-                    vse.initCause(fe) ;
-                    throw new VisitorException(msg) ;
-                }
-            }
-        }
     }
 
     private void resolveLOProjectType(LOProject pj) throws VisitorException {
@@ -403,16 +358,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
-
     }
 
     @Override
@@ -431,15 +376,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
@@ -449,7 +385,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
 
         if ( DataType.isNumberType(lhsType) &&
              DataType.isNumberType(rhsType) ) {
@@ -464,27 +399,20 @@ public class TypeCheckingVisitor extends LOVisitor {
             else if (rhsType != biggerType) {
                 insertRightCastForBinaryOp(binOp, biggerType) ;
             }
-            fs.type = biggerType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(rhsType)) ) {
             insertLeftCastForBinaryOp(binOp, rhsType) ;
-            // Set output type
-            fs.type = rhsType;
         }
         else if ( (rhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(lhsType)) ) {
             insertRightCastForBinaryOp(binOp, lhsType) ;
-            // Set output type
-            fs.type = lhsType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (rhsType == DataType.BYTEARRAY) ) {
             // Cast both operands to double
             insertLeftCastForBinaryOp(binOp, DataType.DOUBLE) ;
             insertRightCastForBinaryOp(binOp, DataType.DOUBLE) ;
-            // Set output type
-            fs.type = DataType.DOUBLE;
         }
         else {
             String msg = "Cannot evaluate output type of Mul/Div Operator" ;
@@ -493,7 +421,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
 
         try {
-            binOp.setFieldSchema(fs);
+            binOp.regenerateFieldSchema();
         } catch (FrontendException fe) {
             String msg = "Could not set LOSubtract field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -510,7 +438,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
 
         if ( DataType.isNumberType(lhsType) &&
              DataType.isNumberType(rhsType) ) {
@@ -525,27 +452,20 @@ public class TypeCheckingVisitor extends LOVisitor {
             else if (rhsType != biggerType) {
                 insertRightCastForBinaryOp(binOp, biggerType) ;
             }
-            fs.type = biggerType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(rhsType)) ) {
             insertLeftCastForBinaryOp(binOp, rhsType) ;
-            // Set output type
-            fs.type = rhsType;
         }
         else if ( (rhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(lhsType)) ) {
             insertRightCastForBinaryOp(binOp, lhsType) ;
-            // Set output type
-            fs.type = lhsType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (rhsType == DataType.BYTEARRAY) ) {
             // Cast both operands to double
             insertLeftCastForBinaryOp(binOp, DataType.DOUBLE) ;
             insertRightCastForBinaryOp(binOp, DataType.DOUBLE) ;
-            // Set output type
-            fs.type = DataType.DOUBLE;
         }
         else {
             String msg = "Cannot evaluate output type of Mul/Div Operator" ;
@@ -554,7 +474,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
 
         try {
-            binOp.setFieldSchema(fs);
+            binOp.regenerateFieldSchema();
         } catch (FrontendException fe) {
             String msg = "Could not set LOSubtract field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -571,7 +491,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
 
         if ( DataType.isNumberType(lhsType) &&
              DataType.isNumberType(rhsType) ) {
@@ -586,27 +505,20 @@ public class TypeCheckingVisitor extends LOVisitor {
             else if (rhsType != biggerType) {
                 insertRightCastForBinaryOp(binOp, biggerType) ;
             }
-            fs.type = biggerType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(rhsType)) ) {
             insertLeftCastForBinaryOp(binOp, rhsType) ;
-            // Set output type
-            fs.type = rhsType;
         }
         else if ( (rhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(lhsType)) ) {
             insertRightCastForBinaryOp(binOp, lhsType) ;
-            // Set output type
-            fs.type = lhsType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (rhsType == DataType.BYTEARRAY) ) {
             // Cast both operands to double
             insertLeftCastForBinaryOp(binOp, DataType.DOUBLE) ;
             insertRightCastForBinaryOp(binOp, DataType.DOUBLE) ;
-            // Set output type
-            fs.type = DataType.DOUBLE;
         }
         else {
             String msg = "Cannot evaluate output type of Add/Subtract Operator" ;
@@ -614,7 +526,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
         try {
-            binOp.setFieldSchema(fs);
+            binOp.regenerateFieldSchema();
         } catch (FrontendException fe) {
             String msg = "Could not set LOSubtract field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -631,7 +543,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
 
         if ( DataType.isNumberType(lhsType) &&
                 DataType.isNumberType(rhsType) ) {
@@ -646,27 +557,20 @@ public class TypeCheckingVisitor extends LOVisitor {
             else if (rhsType != biggerType) {
                 insertRightCastForBinaryOp(binOp, biggerType) ;
             }
-            fs.type = biggerType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                 (DataType.isNumberType(rhsType)) ) {
             insertLeftCastForBinaryOp(binOp, rhsType) ;
-            // Set output type
-            fs.type = rhsType;
         }
         else if ( (rhsType == DataType.BYTEARRAY) &&
                   (DataType.isNumberType(lhsType)) ) {
             insertRightCastForBinaryOp(binOp, lhsType) ;
-            // Set output type
-            fs.type = lhsType;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   (rhsType == DataType.BYTEARRAY) ) {
             // Cast both operands to double
             insertLeftCastForBinaryOp(binOp, DataType.DOUBLE) ;
             insertRightCastForBinaryOp(binOp, DataType.DOUBLE) ;
-            // Set output type
-            fs.type = DataType.DOUBLE;
         }
         else {
             String msg = "Cannot evaluate output type of Add/Subtract Operator" ;
@@ -674,7 +578,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
         try {
-            binOp.setFieldSchema(fs);
+            binOp.regenerateFieldSchema();
         } catch (FrontendException fe) {
             String msg = "Could not set LOSubtract field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -693,7 +597,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
 
         if ( DataType.isNumberType(lhsType) &&
              DataType.isNumberType(rhsType) ) {
@@ -737,15 +640,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
@@ -755,7 +649,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
 
         if ( DataType.isNumberType(lhsType) &&
              DataType.isNumberType(rhsType) ) {
@@ -799,15 +692,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
@@ -817,7 +701,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
         if ( DataType.isNumberType(lhsType) &&
                 DataType.isNumberType(rhsType) ) {
             // If not the same type, we cast them to the same
@@ -860,15 +743,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
@@ -878,7 +752,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
 
         if ( DataType.isNumberType(lhsType) &&
                 DataType.isNumberType(rhsType) ) {
@@ -922,15 +795,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
 
@@ -942,7 +806,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
 
         if ( DataType.isNumberType(lhsType) &&
                 DataType.isNumberType(rhsType) ) {
@@ -992,15 +855,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
@@ -1010,7 +864,6 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
 
 
         if ( DataType.isNumberType(lhsType) &&
@@ -1061,15 +914,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            binOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
@@ -1079,12 +923,11 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         byte lhsType = lhs.getType() ;
         byte rhsType = rhs.getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
 
         if ( (lhsType == DataType.INTEGER) &&
              (rhsType == DataType.INTEGER)
            ) {
-            fs.type = DataType.INTEGER;
+           //do nothing
         }
         else if ( (lhsType == DataType.LONG) &&
                   ( (rhsType == DataType.INTEGER) || (rhsType == DataType.LONG) )
@@ -1092,13 +935,11 @@ public class TypeCheckingVisitor extends LOVisitor {
             if (rhsType == DataType.INTEGER) {
                 insertRightCastForBinaryOp(binOp, DataType.LONG) ;
             }
-            fs.type = DataType.LONG;
         }
         else if ( (lhsType == DataType.BYTEARRAY) &&
                   ( (rhsType == DataType.INTEGER) || (rhsType == DataType.LONG) )
                 ) {
             insertLeftCastForBinaryOp(binOp, rhsType) ;
-            fs.type = rhsType;
         }
         else {
             String msg = "Cannot evaluate output type of Mod Operator" ;
@@ -1106,7 +947,7 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
         try {
-            binOp.setFieldSchema(fs);
+            binOp.regenerateFieldSchema();
         } catch (FrontendException fe) {
             String msg = "Could not set LOSubtract field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -1120,15 +961,13 @@ public class TypeCheckingVisitor extends LOVisitor {
     @Override
     public void visit(LONegative uniOp) throws VisitorException {
         byte type = uniOp.getOperand().getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BYTEARRAY);
 
 
         if (DataType.isNumberType(type)) {
-            fs.type = type;
+            //do nothing
         }
         else if (type == DataType.BYTEARRAY) {
             insertCastForUniOp(uniOp, DataType.DOUBLE) ;
-            fs.type = DataType.DOUBLE;
         }
         else {
             String msg = "NEG can be used with numbers or Bytearray only" ;
@@ -1137,7 +976,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         }
 
         try {
-            uniOp.setFieldSchema(fs);
+            uniOp.regenerateFieldSchema();
         } catch (FrontendException fe) {
             String msg = "Could not set LOSubtract field schema";
             msgCollector.collect(msg, MessageType.Error);
@@ -1150,7 +989,6 @@ public class TypeCheckingVisitor extends LOVisitor {
     @Override
     public void visit(LONot uniOp) throws VisitorException {
         byte type = uniOp.getOperand().getType() ;
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
 
         if (type != DataType.BOOLEAN) {
             String msg = "NOT can be used with boolean only" ;
@@ -1158,29 +996,10 @@ public class TypeCheckingVisitor extends LOVisitor {
             throw new VisitorException(msg) ;
         }
 
-        try {
-            uniOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     @Override
     public void visit(LOIsNull uniOp) throws VisitorException {
-        Schema.FieldSchema fs = new Schema.FieldSchema(null, DataType.BOOLEAN);
-        try {
-            uniOp.setFieldSchema(fs);
-        } catch (FrontendException fe) {
-            String msg = "Could not set LOSubtract field schema";
-            msgCollector.collect(msg, MessageType.Error);
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(fe) ;
-            throw new VisitorException(msg) ;
-        }
     }
 
     private void insertLeftCastForBinaryOp(BinaryExpressionOperator binOp,
@@ -1196,6 +1015,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             currentPlan.connect(binOp.getLhsOperand(), cast) ;
             currentPlan.connect(cast, binOp) ;
+            binOp.setLhsOperand(cast);
         }
         catch (PlanException ioe) {
             AssertionError err =  new AssertionError("Explicit casting insertion") ;
@@ -1218,6 +1038,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             currentPlan.connect(binOp.getRhsOperand(), cast) ;
             currentPlan.connect(cast, binOp) ;
+            binOp.setRhsOperand(cast);
         }
         catch (PlanException ioe) {
             AssertionError err =  new AssertionError("Explicit casting insertion") ;
@@ -1371,36 +1192,17 @@ public class TypeCheckingVisitor extends LOVisitor {
                 throw new VisitorException(sb.toString());
             } else {
                 func.setFuncSpec(matchingSpec);
-                ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(matchingSpec);
-                setUdfSchema(func, ef, s);
             }
-        } else {
-            setUdfSchema(func, ef, s);
-        }
-        /*
-        while (iterator.hasNext()) {
-            iterator.next().visit(this);          
         }
-        */
-    }
 
-    private void setUdfSchema(LOUserFunc func, EvalFunc ef, Schema inputSchema) throws VisitorException {
-        Schema udfSchema = ef.outputSchema(inputSchema);
-        if (null != udfSchema) {
-            Schema.FieldSchema fs;
-            try {
-                fs = udfSchema.getField(0);
-            } catch (ParseException pe) {
-                throw new VisitorException(pe.getMessage());
-            }
-            func.setType(fs.type);
-            try {
-                func.setFieldSchema(fs);
-            } catch (FrontendException fe) {
-                throw new VisitorException(fe.getMessage());
-            }
-        } else {
-            func.setType(DataType.findType(ef.getReturnType()));
+        try {
+            func.regenerateSchema();
+        } catch (FrontendException fee) {
+            String msg = "Could not set LOUserFunc field schema";
+            msgCollector.collect(msg, MessageType.Error);
+            VisitorException vse = new VisitorException(msg) ;
+            vse.initCause(fee) ;
+            throw new VisitorException(msg) ;
         }
     }
 
@@ -1445,39 +1247,29 @@ public class TypeCheckingVisitor extends LOVisitor {
             insertRightCastForBinCond(binCond, lhsType);
             binCond.setType(DataType.mergeType(lhsType, rhsType));
         }
-        // Matching schemas if we're working with tuples
-        else if (lhsType == DataType.TUPLE) {            
-            try {
-                if (!binCond.getLhsOp().getSchema().equals(binCond.getRhsOp().getSchema())) {
-                    String msg = "Two inputs of BinCond must have compatible schemas" ;
-                    msgCollector.collect(msg, MessageType.Error) ;
-                    throw new VisitorException(msg) ;
-                }
-                // TODO: We may have to merge the schema here
-                //       if the previous check is not exact match
-                //       Is Schema.reconcile good enough?
+        else if (lhsType == rhsType) {
+            // Matching schemas if we're working with tuples
+            if (DataType.isSchemaType(lhsType)) {            
                 try {
-                    binCond.setSchema(binCond.getLhsOp().getSchema()) ;
-                }
-                catch (ParseException pe) {
-                    String msg = "Problem during setting BinCond output schema" ;
+                    if (!Schema.equals(binCond.getLhsOp().getSchema(), binCond.getRhsOp().getSchema(), false, true)) {
+                        String msg = "Two inputs of BinCond must have compatible schemas" ;
+                        msgCollector.collect(msg, MessageType.Error) ;
+                        throw new VisitorException(msg) ;
+                    }
+                    // TODO: We may have to merge the schema here
+                    //       if the previous check is not exact match
+                    //       Is Schema.reconcile good enough?
+                } 
+                catch (FrontendException ioe) {
+                    String msg = "Problem during evaluating BinCond output type" ;
                     msgCollector.collect(msg, MessageType.Error) ;
                     VisitorException vse = new VisitorException(msg) ;
-                    vse.initCause(pe) ;
+                    vse.initCause(ioe) ;
                     throw vse ;
                 }
-            } 
-            catch (FrontendException ioe) {
-                String msg = "Problem during evaluating BinCond output type" ;
-                msgCollector.collect(msg, MessageType.Error) ;
-                VisitorException vse = new VisitorException(msg) ;
-                vse.initCause(ioe) ;
-                throw vse ;
+                binCond.setType(DataType.TUPLE) ;
             }
-            binCond.setType(DataType.TUPLE) ;
-        }
         
-        else if (lhsType == rhsType) {
             binCond.setType(lhsType);
         }
         else {
@@ -1502,6 +1294,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             currentPlan.connect(binCond.getLhsOp(), cast) ;
             currentPlan.connect(cast, binCond) ;
+            binCond.setLhsOp(cast);
         } 
         catch (PlanException ioe) {
             AssertionError err =  new AssertionError("Explicit casting insertion") ;
@@ -1526,6 +1319,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             currentPlan.connect(binCond.getRhsOp(), cast) ;
             currentPlan.connect(cast, binCond) ;
+            binCond.setRhsOp(cast);
         } 
         catch (PlanException ioe) {
             AssertionError err =  new AssertionError("Explicit casting insertion") ;
@@ -1566,7 +1360,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         } catch(FrontendException fee) {
             throw new VisitorException(fee.getMessage());
         }
-        boolean castable = castable = Schema.FieldSchema.castable(castFs, inputFs);
+        boolean castable = Schema.FieldSchema.castable(castFs, inputFs);
         if(!castable) {
             String msg = "Cannot cast "
                            + DataType.findTypeName(inputType)
@@ -1677,6 +1471,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     @Override
     protected void visit(LOSplitOutput op) throws VisitorException {
+        op.unsetSchema();
         LogicalPlan currentPlan =  mCurrentWalker.getPlan() ;
 
         // LOSplitOutput can only have 1 input
@@ -1761,20 +1556,6 @@ public class TypeCheckingVisitor extends LOVisitor {
         try {
             // Compute the schema
             cs.getSchema() ;
-
-            boolean foundNullSchema = false ;
-            for(LogicalOperator op: inputs) {
-                // All of inputs are relational operators
-                // so we can access getSchema()
-                Schema inputSchema = op.getSchema() ;
-                if (inputSchema == null) {
-                    // force to null if one input has null schema
-                    cs.forceSchema(null);
-                    break ;
-                }
-
-            }
-
         }
         catch (FrontendException fe) {
             String msg = "Problem while reading"
@@ -1849,7 +1630,7 @@ public class TypeCheckingVisitor extends LOVisitor {
               
         byte innerCondType = comparisonPlan.getLeaves().get(0).getType() ;
         if (innerCondType != DataType.BOOLEAN) {
-            String msg = "Filter's condition must evaluate to boolean" ;
+            String msg = "Filter's condition must evaluate to boolean. Found: " + DataType.findTypeName(innerCondType);
             msgCollector.collect(msg, MessageType.Error) ;
             throw new VisitorException(msg) ;
         }       
@@ -1901,9 +1682,8 @@ public class TypeCheckingVisitor extends LOVisitor {
      * same type
      */
     protected void visit(LOCogroup cg) throws VisitorException {
-        cg.resetSchema();
         try {
-            cg.getSchema();
+            cg.regenerateSchema();
         } catch (FrontendException fe) {
             String msg = "Cannot resolve COGroup output schema" ;
             msgCollector.collect(msg, MessageType.Error) ;
@@ -1938,10 +1718,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
         }
 
-        Schema schema = null ;
         try {
-            // Compute the schema
-            schema = cg.getSchema() ;
 
             if (!cg.isTupleGroupCol()) {
                 // merge all the inner plan outputs so we know what type
@@ -1949,7 +1726,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
                 // TODO: Don't recompute schema here
                 //byte groupType = schema.getField(0).type ;
-                byte groupType = getAtomicGroupByType(cg) ;
+                byte groupType = cg.getAtomicGroupByType() ;
 
                 // go through all inputs again to add cast if necessary
                 for(int i=0;i < inputs.size(); i++) {
@@ -1969,7 +1746,7 @@ public class TypeCheckingVisitor extends LOVisitor {
 
                 // TODO: Don't recompute schema here
                 //Schema groupBySchema = schema.getField(0).schema ;
-                Schema groupBySchema = getTupleGroupBySchema(cg) ;
+                Schema groupBySchema = cg.getTupleGroupBySchema() ;
 
                 // go through all inputs again to add cast if necessary
                 for(int i=0;i < inputs.size(); i++) {
@@ -2016,43 +1793,13 @@ public class TypeCheckingVisitor extends LOVisitor {
             vse.initCause(fe) ;
             throw vse ;
         }
-        /*
-        catch (ParseException pe) {
-            String msg = "Cannot resolve COGroup output schema" ;
-            msgCollector.collect(msg, MessageType.Error) ;
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(pe) ;
-            throw vse ;
-        }
-        */
-
 
         // TODO: Don't recompute schema here. Remove all from here!
         // Generate output schema based on the schema generated from
         // COGroup itself
 
         try {
-
-            Schema outputSchema = cg.getSchema() ;
-
-            // if the "group" col is atomic
-            if (!cg.isTupleGroupCol()) {
-                outputSchema.getField(0).type = getAtomicGroupByType(cg) ;
-            }
-            else {
-                outputSchema.getField(0).type = DataType.TUPLE ;
-                outputSchema.getField(0).schema = getTupleGroupBySchema(cg) ;
-            }
-
-            for(int i=0; i< inputs.size(); i++) {
-                FieldSchema fs = outputSchema.getField(i+1) ;
-                fs.type = DataType.BAG ;
-                fs.schema = inputs.get(i).getSchema() ;
-            }
-
-            cg.setType(DataType.BAG) ;
-            cg.setSchema(outputSchema) ;
-
+            Schema outputSchema = cg.regenerateSchema() ;
         }
         catch (FrontendException fe) {
             String msg = "Cannot resolve COGroup output schema" ;
@@ -2061,13 +1808,6 @@ public class TypeCheckingVisitor extends LOVisitor {
             vse.initCause(fe) ;
             throw vse ;
         }
-        catch (ParseException pe) {
-            String msg = "Cannot resolve COGroup output schema" ;
-            msgCollector.collect(msg, MessageType.Error) ;
-            VisitorException vse = new VisitorException(msg) ;
-            vse.initCause(pe) ;
-            throw vse ;
-        }
     }
 
 
@@ -2076,6 +1816,10 @@ public class TypeCheckingVisitor extends LOVisitor {
     private void insertAtomicCastForCOGroupInnerPlan(LogicalPlan innerPlan,
                                                      LOCogroup cg,
                                                      byte toType) {
+        if(!DataType.isUsableType(toType)) {
+            throw new AssertionError("Cannot cast to type " + DataType.findTypeName(toType));
+        }
+        
         List<LogicalOperator> leaves = innerPlan.getLeaves() ;
         if (leaves.size() > 1) {
             throw new AssertionError("insertAtomicForCOGroupInnerPlan cannot be"
@@ -2207,7 +1951,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         List<LogicalPlan> plans = f.getForEachPlans() ;
         List<Boolean> flattens = f.getFlatten() ;
 
-        f.resetSchema();
+        f.unsetSchema();
         try {
 
             // Have to resolve all inner plans before calling getSchema
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidator.java b/test/org/apache/pig/test/TestTypeCheckingValidator.java
index bd7cffd72..a0e9d2ade 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidator.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidator.java
@@ -642,9 +642,9 @@ public class TestTypeCheckingValidator extends TestCase {
         plan.connect(constant1, mul1) ;
         plan.connect(constant2, mul1) ;       
         
-        // Before type checking
+        // Before type checking its set correctly - PIG-421
         System.out.println(DataType.findTypeName(mul1.getType())) ;
-        assertEquals(DataType.UNKNOWN, mul1.getType()) ;    
+        assertEquals(DataType.DOUBLE, mul1.getType()) ;    
         
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
@@ -663,7 +663,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
         constant1.setType(DataType.INTEGER) ;
-        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20D) ;
+        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
 
         LONegative neg1 = new LONegative(plan, genNewOperatorKey(), constant1) ;
@@ -681,8 +681,8 @@ public class TestTypeCheckingValidator extends TestCase {
         plan.connect(neg1, subtract1) ;
         plan.connect(constant2, subtract1) ;
 
-        // Before type checking
-        assertEquals(DataType.UNKNOWN, subtract1.getType()) ;
+        // Before type checking its set correctly = PIG-421
+        assertEquals(DataType.LONG, subtract1.getType()) ;
 
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
@@ -705,7 +705,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
         constant1.setType(DataType.BYTEARRAY) ;
-        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20D) ;
+        LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
 
         LOMod mod1 = new LOMod(plan, genNewOperatorKey(), constant1, constant2) ;
@@ -717,8 +717,8 @@ public class TestTypeCheckingValidator extends TestCase {
         plan.connect(constant1, mod1) ;
         plan.connect(constant2, mod1) ;
 
-        // Before type checking
-        assertEquals(DataType.UNKNOWN, mod1.getType()) ;
+        // Before type checking its set correctly = PIG-421
+        assertEquals(DataType.LONG, mod1.getType()) ;
 
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
@@ -2264,7 +2264,7 @@ public class TestTypeCheckingValidator extends TestCase {
         // Create expression inner plan #2
         LogicalPlan innerPlan12 = new LogicalPlan() ;
         LOConst const121 = new LOConst(innerPlan12, genNewOperatorKey(), 26) ;
-        const121.setType(DataType.CHARARRAY);
+        const121.setType(DataType.INTEGER);
         innerPlan12.add(const121) ;
 
         // Create Cogroup
@@ -2309,7 +2309,7 @@ public class TestTypeCheckingValidator extends TestCase {
         Schema endResultSchema = cogroup1.getSchema() ;
 
         // Tuple group column
-        assertEquals(endResultSchema.getField(0).type, DataType.BYTEARRAY) ;
+        assertEquals(endResultSchema.getField(0).type, DataType.FLOAT) ;
 
         assertEquals(endResultSchema.getField(1).type, DataType.BAG) ;
         assertEquals(endResultSchema.getField(2).type, DataType.BAG) ;
@@ -2325,8 +2325,8 @@ public class TestTypeCheckingValidator extends TestCase {
         assertEquals(innerSchema2.getField(1).type, DataType.INTEGER);
 
         // check group by col end result
-        assertEquals(innerPlan11.getSingleLeafPlanOutputType(), DataType.BYTEARRAY) ;
-        assertEquals(innerPlan12.getSingleLeafPlanOutputType(), DataType.BYTEARRAY) ;
+        assertEquals(innerPlan11.getSingleLeafPlanOutputType(), DataType.FLOAT) ;
+        assertEquals(innerPlan12.getSingleLeafPlanOutputType(), DataType.FLOAT) ;
     }
 
     // Positive test
diff --git a/test/org/apache/pig/test/data/GoldenFiles/Arithmetic.gld b/test/org/apache/pig/test/data/GoldenFiles/Arithmetic.gld
index f8f8f6414..f63f39301 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/Arithmetic.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/Arithmetic.gld
@@ -1,8 +1,8 @@
 New For Each(false,false,false)[bag] - Test-Plan-Builder-86
 |   |
-|   Add[Unknown] - Test-Plan-Builder-79
+|   Add[chararray] - Test-Plan-Builder-79
 |   |
-|   |---Add[Unknown] - Test-Plan-Builder-77
+|   |---Add[bytearray] - Test-Plan-Builder-77
 |   |   |
 |   |   |---Project[bytearray][0] - Test-Plan-Builder-75
 |   |   |
@@ -10,9 +10,9 @@ New For Each(false,false,false)[bag] - Test-Plan-Builder-86
 |   |
 |   |---Constant(5) - Test-Plan-Builder-78
 |   |
-|   Subtract[Unknown] - Test-Plan-Builder-84
+|   Subtract[chararray] - Test-Plan-Builder-84
 |   |
-|   |---Subtract[Unknown] - Test-Plan-Builder-82
+|   |---Subtract[chararray] - Test-Plan-Builder-82
 |   |   |
 |   |   |---Project[bytearray][0] - Test-Plan-Builder-80
 |   |   |
diff --git a/test/org/apache/pig/test/data/GoldenFiles/BinCond.gld b/test/org/apache/pig/test/data/GoldenFiles/BinCond.gld
index dd62d47dc..d15c3ffa3 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/BinCond.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/BinCond.gld
@@ -1,6 +1,6 @@
 New For Each(false)[bag] - Test-Plan-Builder-137
 |   |
-|   POBinCond[Unknown] - Test-Plan-Builder-136
+|   POBinCond[bytearray] - Test-Plan-Builder-136
 |   |
 |   |---Equal To[boolean] - Test-Plan-Builder-129
 |   |   |
@@ -8,13 +8,13 @@ New For Each(false)[bag] - Test-Plan-Builder-137
 |   |   |
 |   |   |---Constant(3) - Test-Plan-Builder-128
 |   |
-|   |---Add[Unknown] - Test-Plan-Builder-132
+|   |---Add[bytearray] - Test-Plan-Builder-132
 |   |   |
 |   |   |---Project[bytearray][2] - Test-Plan-Builder-130
 |   |   |
 |   |   |---Project[bytearray][3] - Test-Plan-Builder-131
 |   |
-|   |---Subtract[Unknown] - Test-Plan-Builder-135
+|   |---Subtract[bytearray] - Test-Plan-Builder-135
 |       |
 |       |---Project[bytearray][2] - Test-Plan-Builder-133
 |       |
diff --git a/test/org/apache/pig/test/data/GoldenFiles/Cogroup.gld b/test/org/apache/pig/test/data/GoldenFiles/Cogroup.gld
index 6823a6f1d..9ec46f3ed 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/Cogroup.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/Cogroup.gld
@@ -4,13 +4,13 @@ Package[tuple]{tuple} - Test-Plan-Builder-45
     |
     |---Local Rearrange[tuple]{tuple}(false) - Test-Plan-Builder-46
     |   |   |
-    |   |   Add[Unknown] - Test-Plan-Builder-49
+    |   |   Add[bytearray] - Test-Plan-Builder-49
     |   |   |
     |   |   |---Project[bytearray][0] - Test-Plan-Builder-47
     |   |   |
     |   |   |---Project[bytearray][1] - Test-Plan-Builder-48
     |   |   |
-    |   |   Subtract[Unknown] - Test-Plan-Builder-52
+    |   |   Subtract[bytearray] - Test-Plan-Builder-52
     |   |   |
     |   |   |---Project[bytearray][0] - Test-Plan-Builder-50
     |   |   |
@@ -20,13 +20,13 @@ Package[tuple]{tuple} - Test-Plan-Builder-45
     |
     |---Local Rearrange[tuple]{tuple}(false) - Test-Plan-Builder-53
         |   |
-        |   Add[Unknown] - Test-Plan-Builder-56
+        |   Add[bytearray] - Test-Plan-Builder-56
         |   |
         |   |---Project[bytearray][0] - Test-Plan-Builder-54
         |   |
         |   |---Project[bytearray][1] - Test-Plan-Builder-55
         |   |
-        |   Subtract[Unknown] - Test-Plan-Builder-59
+        |   Subtract[bytearray] - Test-Plan-Builder-59
         |   |
         |   |---Project[bytearray][0] - Test-Plan-Builder-57
         |   |
diff --git a/test/org/apache/pig/test/data/GoldenFiles/Comparison.gld b/test/org/apache/pig/test/data/GoldenFiles/Comparison.gld
index 6acbd9029..7b0181a76 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/Comparison.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/Comparison.gld
@@ -2,21 +2,21 @@ Filter[bag] - Test-Plan-Builder-101
 |   |
 |   Greater Than[boolean] - Test-Plan-Builder-112
 |   |
-|   |---Add[Unknown] - Test-Plan-Builder-104
+|   |---Add[bytearray] - Test-Plan-Builder-104
 |   |   |
 |   |   |---Project[bytearray][0] - Test-Plan-Builder-102
 |   |   |
 |   |   |---Project[bytearray][1] - Test-Plan-Builder-103
 |   |
-|   |---Multiply[Unknown] - Test-Plan-Builder-111
+|   |---Multiply[chararray] - Test-Plan-Builder-111
 |       |
-|       |---Subtract[Unknown] - Test-Plan-Builder-107
+|       |---Subtract[bytearray] - Test-Plan-Builder-107
 |       |   |
 |       |   |---Project[bytearray][0] - Test-Plan-Builder-105
 |       |   |
 |       |   |---Project[bytearray][1] - Test-Plan-Builder-106
 |       |
-|       |---Divide[Unknown] - Test-Plan-Builder-110
+|       |---Divide[chararray] - Test-Plan-Builder-110
 |           |
 |           |---Constant(4) - Test-Plan-Builder-108
 |           |
diff --git a/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld b/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld
index 1a6181f77..6bd09fba4 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/ComplexForeach.gld
@@ -1,6 +1,6 @@
-New For Each(true)[bag] - Test-Plan-Builder-16
+New For Each(false)[bag] - Test-Plan-Builder-16
 |   |
-|   Project[tuple][*] - Test-Plan-Builder-15
+|   Project[bag][*] - Test-Plan-Builder-15
 |   |
 |   |---Filter[bag] - Test-Plan-Builder-11
 |       |   |
@@ -10,6 +10,6 @@ New For Each(true)[bag] - Test-Plan-Builder-16
 |       |   |
 |       |   |---Project[bytearray][2] - Test-Plan-Builder-13
 |       |
-|       |---Project[bytearray][0] - Test-Plan-Builder-10
+|       |---Project[tuple][0] - Test-Plan-Builder-10
 |
 |---Load(a:org.apache.pig.builtin.PigStorage) - Test-Plan-Builder-9
\ No newline at end of file
diff --git a/test/org/apache/pig/test/data/GoldenFiles/Generate.gld b/test/org/apache/pig/test/data/GoldenFiles/Generate.gld
index 7b1268379..3d9efbd91 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/Generate.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/Generate.gld
@@ -1,30 +1,30 @@
 New For Each(false,false,false,false,false,false)[bag] - Test-Plan-Builder-176
 |   |
-|   Add[Unknown] - Test-Plan-Builder-161
+|   Add[bytearray] - Test-Plan-Builder-161
 |   |
 |   |---Project[bytearray][1] - Test-Plan-Builder-159
 |   |
 |   |---Project[bytearray][2] - Test-Plan-Builder-160
 |   |
-|   Subtract[Unknown] - Test-Plan-Builder-164
+|   Subtract[bytearray] - Test-Plan-Builder-164
 |   |
 |   |---Project[bytearray][1] - Test-Plan-Builder-162
 |   |
 |   |---Project[bytearray][2] - Test-Plan-Builder-163
 |   |
-|   Multiply[Unknown] - Test-Plan-Builder-167
+|   Multiply[bytearray] - Test-Plan-Builder-167
 |   |
 |   |---Project[bytearray][1] - Test-Plan-Builder-165
 |   |
 |   |---Project[bytearray][2] - Test-Plan-Builder-166
 |   |
-|   Divide[Unknown] - Test-Plan-Builder-170
+|   Divide[bytearray] - Test-Plan-Builder-170
 |   |
 |   |---Project[bytearray][1] - Test-Plan-Builder-168
 |   |
 |   |---Project[bytearray][2] - Test-Plan-Builder-169
 |   |
-|   Mod[Unknown] - Test-Plan-Builder-173
+|   Mod[bytearray] - Test-Plan-Builder-173
 |   |
 |   |---Project[bytearray][1] - Test-Plan-Builder-171
 |   |
