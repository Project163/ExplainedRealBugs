diff --git a/CHANGES.txt b/CHANGES.txt
index 38d170da5..761628884 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -209,6 +209,8 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1669: PushUpFilter fail when filter condition contains scalar (daijy)
+
 PIG-1672: order of relations in replicated join gets switched in a query where
  first relation has two mergeable foreach statements (thejas)
 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
index d9ad4107b..4acf46399 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
@@ -771,6 +771,16 @@ public class MRCompiler extends PhyPlanVisitor {
                     mergedMap.scalars.add(physOp);
                 }
             }
+            Set<PhysicalOperator> opsToChange = new HashSet<PhysicalOperator>();
+            for (Map.Entry<PhysicalOperator, MapReduceOper> entry : phyToMROpMap.entrySet()) {
+                if (entry.getValue()==rmro) {
+                    opsToChange.add(entry.getKey());
+                }
+            }
+            for (PhysicalOperator op : opsToChange) {
+                phyToMROpMap.put(op, mergedMap);
+            }
+            
             MRPlan.remove(rmro);
         }
         return ret;
diff --git a/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java b/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java
index 8eed0e36a..18e26dd0a 100644
--- a/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java
+++ b/src/org/apache/pig/newplan/logical/rules/FilterAboveForeach.java
@@ -260,8 +260,13 @@ public class FilterAboveForeach extends Rule {
              *  -- And ForEach is FilterPred 
              */
             
-            currentPlan.removeAndReconnect(filter);
-            currentPlan.insertBetween(forEachPred, filter, foreach);
+            Pair<Integer, Integer> forEachPredPlaces = currentPlan.disconnect(forEachPred, foreach);
+            Pair<Integer, Integer> filterPredPlaces = currentPlan.disconnect(filterPred, filter);
+            Pair<Integer, Integer> filterSucPlaces = currentPlan.disconnect(filter, filterSuc);
+            
+            currentPlan.connect(forEachPred, forEachPredPlaces.first, filter, filterPredPlaces.second);
+            currentPlan.connect(filter, filterSucPlaces.first, foreach, forEachPredPlaces.second);
+            currentPlan.connect(filterPred, filterPredPlaces.first, filterSuc, filterSucPlaces.second);
             
             subPlan.add(forEachPred);
             subPlan.add(foreach);
diff --git a/src/org/apache/pig/newplan/logical/rules/MergeFilter.java b/src/org/apache/pig/newplan/logical/rules/MergeFilter.java
index 3e7b40674..5eb1d2fea 100644
--- a/src/org/apache/pig/newplan/logical/rules/MergeFilter.java
+++ b/src/org/apache/pig/newplan/logical/rules/MergeFilter.java
@@ -17,6 +17,7 @@
  */
 package org.apache.pig.newplan.logical.rules;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
@@ -82,7 +83,12 @@ public class MergeFilter extends Rule {
                 }
 
                 // Since we remove next, we need to merge soft link into filter
-                List<Operator> nextSoftPreds = currentPlan.getSoftLinkPredecessors(next);
+                List<Operator> nextSoftPreds = null;
+                if (currentPlan.getSoftLinkPredecessors(next)!=null) {
+                    nextSoftPreds = new ArrayList<Operator>();
+                    nextSoftPreds.addAll(currentPlan.getSoftLinkPredecessors(next));
+                }
+                
                 if (nextSoftPreds!=null) {
                     for (Operator softPred : nextSoftPreds) {
                         currentPlan.removeSoftLink(softPred, next);
diff --git a/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java b/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
index ed82a324e..819b5724f 100644
--- a/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
+++ b/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
@@ -110,6 +110,10 @@ public class PartitionFilterOptimizer extends Rule {
                 return false;
             loFilter =  (LOFilter)succeds.get(0);
             
+            // Filter has dependency other than load, skip optimization
+            if (currentPlan.getSoftLinkPredecessors(loFilter)!=null)
+                return false;
+            
             // we have to check more only if LoadFunc implements LoadMetada
             loadFunc = loLoad.getLoadFunc();
             if(!( loadFunc instanceof LoadMetadata ) ) {
diff --git a/src/org/apache/pig/newplan/logical/rules/PushDownForEachFlatten.java b/src/org/apache/pig/newplan/logical/rules/PushDownForEachFlatten.java
index e4e06ca8d..a22e3f0ab 100644
--- a/src/org/apache/pig/newplan/logical/rules/PushDownForEachFlatten.java
+++ b/src/org/apache/pig/newplan/logical/rules/PushDownForEachFlatten.java
@@ -211,14 +211,18 @@ public class PushDownForEachFlatten extends Rule {
             LOForEach foreach = (LOForEach)matched.getSources().get(0);
             Operator next = currentPlan.getSuccessors( foreach ).get(0);
             if( next instanceof LOSort ) {
-                currentPlan.removeAndReconnect(foreach);
-                
-                List<Operator> succs = currentPlan.getSuccessors( next );
+                Operator pred = currentPlan.getPredecessors( foreach ).get( 0 );
+                List<Operator> succs = new ArrayList<Operator>();
+                succs.addAll(currentPlan.getSuccessors( next ));
+                Pair<Integer, Integer> pos1 = currentPlan.disconnect( pred, foreach );
+                Pair<Integer, Integer> pos2 = currentPlan.disconnect( foreach, next );
+                currentPlan.connect( pred, pos1.first, next, pos2.second );
+
                 if( succs != null ) {
-                    List<Operator> succsCopy = new ArrayList<Operator>();
-                    succsCopy.addAll(succs);
-                    for( Operator succ : succsCopy ) {
-                        currentPlan.insertBetween(next, foreach, succ);
+                    for( Operator succ : succs ) {
+                        Pair<Integer, Integer> pos = currentPlan.disconnect( next, succ );
+                        currentPlan.connect( next, pos.first, foreach, 0 );
+                        currentPlan.connect( foreach, 0, succ, pos.second );
                     }
                 } else {
                     currentPlan.connect( next, foreach );
@@ -268,10 +272,10 @@ public class PushDownForEachFlatten extends Rule {
                 
                 newForeach.setAlias(((LogicalRelationalOperator)next).getAlias());
                 
-                currentPlan.add( newForeach );
                 Operator opAfterX = null;
                 List<Operator> succs = currentPlan.getSuccessors( next );
                 if( succs == null || succs.size() == 0 ) {
+                    currentPlan.add( newForeach );
                     currentPlan.connect( next, newForeach );
                 } else {
                     opAfterX = succs.get( 0 );
diff --git a/src/org/apache/pig/newplan/logical/rules/PushUpFilter.java b/src/org/apache/pig/newplan/logical/rules/PushUpFilter.java
index 7389c537c..ea9476616 100644
--- a/src/org/apache/pig/newplan/logical/rules/PushUpFilter.java
+++ b/src/org/apache/pig/newplan/logical/rules/PushUpFilter.java
@@ -207,6 +207,8 @@ public class PushUpFilter extends Rule {
             Operator predecessor = this.findNonFilterPredecessor( filter );
             subPlan.add( predecessor) ;
             
+            // Disconnect the filter in the plan without removing it from the plan.
+            Operator predec = currentPlan.getPredecessors( filter ).get( 0 );
             Operator succed;
             
             if (currentPlan.getSuccessors(filter)!=null)
@@ -214,12 +216,13 @@ public class PushUpFilter extends Rule {
             else
                 succed = null;
             
+            Pair<Integer, Integer> p1 = currentPlan.disconnect(predec, filter);
             if (succed!=null) {
                 subPlan.add(succed);
+                Pair<Integer, Integer> p2 = currentPlan.disconnect(filter, succed);
+                currentPlan.connect(predec, p1.first, succed, p2.second);
             }
             
-            currentPlan.removeAndReconnect(filter);
-            
             if( predecessor instanceof LOSort || predecessor instanceof LODistinct ||
                 ( predecessor instanceof LOCogroup && currentPlan.getPredecessors( predecessor ).size() == 1 ) ) {
                 // For sort, put the filter in front of it.
@@ -318,7 +321,9 @@ public class PushUpFilter extends Rule {
         // Insert the filter in between the given two operators.
         private void insertFilter(Operator prev, Operator predecessor, LOFilter filter)
         throws FrontendException {
-            currentPlan.insertBetween(prev, filter, predecessor);
+            Pair<Integer, Integer> p3 = currentPlan.disconnect( prev, predecessor );
+            currentPlan.connect( prev, p3.first, filter, 0 );
+            currentPlan.connect( filter, 0, predecessor, p3.second );
         }
         
         // Identify those among preds that will need to have a filter between it and the predecessor.
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index 524c8eca2..496a99ca6 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -745,4 +745,35 @@ public class TestEvalPipeline2 extends TestCase {
         
         assertFalse(iter.hasNext());
     }
+    
+    // See PIG-1669
+    @Test
+    public void testPushUpFilterScalar() throws Exception{
+        String[] input1 = {
+                "jason\t14\t4.7",
+                "jack\t18\t4.6"
+        };
+        
+        String[] input2 = {
+                "jason\t14",
+                "jack\t18"
+        };
+        
+        Util.createInputFile(cluster, "table_PushUpFilterScalar1", input1);
+        Util.createInputFile(cluster, "table_PushUpFilterScalar2", input2);
+        pigServer.registerQuery("A = load 'table_PushUpFilterScalar1' as (name, age, gpa);");
+        pigServer.registerQuery("B = load 'table_PushUpFilterScalar2' as (name, age);");
+        pigServer.registerQuery("C = filter A by age < 20;");
+        pigServer.registerQuery("D = filter B by age < 20;");
+        pigServer.registerQuery("simple_scalar = limit D 1;");
+        pigServer.registerQuery("E = join C by name, D by name;");
+        pigServer.registerQuery("F = filter E by C::age==(int)simple_scalar.age;");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("F");
+        
+        Tuple t = iter.next();
+        assertTrue(t.toString().equals("(jason,14,4.7,jason,14)"));
+        
+        assertFalse(iter.hasNext());
+    }
 }
diff --git a/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java b/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java
index c6505a6e4..fa31a92e7 100644
--- a/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java
+++ b/test/org/apache/pig/test/TestNewPlanFilterAboveForeach.java
@@ -379,7 +379,7 @@ public class TestNewPlanFilterAboveForeach {
         Operator store = newLogicalPlan.getSuccessors( fe ).get( 0 );
         Assert.assertTrue( store instanceof LOStore );
     }
-
+    
     @Test
     public void testFilterForeachFlatten() throws Exception {
         planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
@@ -398,6 +398,23 @@ public class TestNewPlanFilterAboveForeach {
         Operator store = newLogicalPlan.getSuccessors( fe ).get( 0 );
         Assert.assertTrue( store instanceof LOStore );
     }
+    
+    // See PIG-1669
+    @Test
+    public void testPushUpFilterWithScalar() throws Exception {
+        planTester.buildPlan("a = load 'studenttab10k' as (name, age, gpa);");
+        planTester.buildPlan("b = group a all;");
+        planTester.buildPlan("c = foreach b generate AVG(a.age) as age;");
+        planTester.buildPlan("d = foreach a generate name, age;");
+        planTester.buildPlan("e = filter d by age > c.age;");
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = planTester.buildPlan("f = store e into 'empty';");
+
+        LogicalPlan newLogicalPlan = migrateAndOptimizePlan( plan );
+
+        Operator store = newLogicalPlan.getSinks().get( 0 );
+        Operator foreach = newLogicalPlan.getPredecessors(store).get(0);
+        Assert.assertTrue( foreach instanceof LOForEach );
+    }
 
     private LogicalPlan migrateAndOptimizePlan(org.apache.pig.impl.logicalLayer.LogicalPlan plan) throws FrontendException {
         LogicalPlan newLogicalPlan = migratePlan( plan );
