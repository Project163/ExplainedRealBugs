diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index b2ffd9ff7..46b3be592 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -949,14 +949,16 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         p.setResultType(func.getType());
         currentPlan.add(p);
         List<LogicalOperator> fromList = func.getPlan().getPredecessors(func);
-        for (LogicalOperator op : fromList) {
-            PhysicalOperator from = LogToPhyMap.get(op);
-            try {
-                currentPlan.connect(from, p);
-            } catch (PlanException e) {
-                log.error("Invalid physical operator in the plan"
-                        + e.getMessage());
-                throw new VisitorException(e);
+        if(fromList!=null){
+            for (LogicalOperator op : fromList) {
+                PhysicalOperator from = LogToPhyMap.get(op);
+                try {
+                    currentPlan.connect(from, p);
+                } catch (PlanException e) {
+                    log.error("Invalid physical operator in the plan"
+                            + e.getMessage());
+                    throw new VisitorException(e);
+                }
             }
         }
         LogToPhyMap.put(func, p);
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java
index 86ddc2945..6d39497f2 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java
@@ -55,7 +55,9 @@ public class POFilter extends PhysicalOperator {
     PhysicalPlan plan;
 
     // The root comparison operator of the expression plan
-    ComparisonOperator comOp;
+//    ComparisonOperator comOp;
+    PhysicalOperator comOp;
+    
 
     // The operand type for the comparison operator needed
     // to call the comparison operators getNext with the
@@ -176,8 +178,8 @@ public class POFilter extends PhysicalOperator {
 
     public void setPlan(PhysicalPlan plan) {
         this.plan = plan;
-        comOp = (ComparisonOperator) (plan.getLeaves()).get(0);
-        compOperandType = comOp.getOperandType();
+        comOp = plan.getLeaves().get(0);
+//        compOperandType = comOp.getOperandType();
     }
 
     public PhysicalPlan getPlan() {
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 30a32692b..33b5e7262 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -1325,22 +1325,24 @@ public class TypeCheckingVisitor extends LOVisitor {
         // without this
 
         // Assuming all aggregates has only one argument at this stage
-        ExpressionOperator tmpExp = func.getArguments().get(0) ;
-        if ( (ef instanceof Algebraic)
-             && (tmpExp instanceof LOProject)
-             && (((LOProject)tmpExp).getSentinel())) {
-
-            FieldSchema tmpField ;
-
-            try {
-                // embed the schema above inside a bag
-                tmpField = new FieldSchema(null, s, DataType.BAG) ;
-            }
-            catch (FrontendException e) {
-                throw new VisitorException(e) ;
+        if(func.getArguments()!=null && func.getArguments().size()>0){
+            ExpressionOperator tmpExp = func.getArguments().get(0) ;
+            if ( (ef instanceof Algebraic)
+                 && (tmpExp instanceof LOProject)
+                 && (((LOProject)tmpExp).getSentinel())) {
+    
+                FieldSchema tmpField ;
+    
+                try {
+                    // embed the schema above inside a bag
+                    tmpField = new FieldSchema(null, s, DataType.BAG) ;
+                }
+                catch (FrontendException e) {
+                    throw new VisitorException(e) ;
+                }
+    
+                s = new Schema(tmpField) ;
             }
-
-            s = new Schema(tmpField) ;
         }
         
         // ask the EvalFunc what types of inputs it can handle
@@ -2302,6 +2304,9 @@ public class TypeCheckingVisitor extends LOVisitor {
             else if (op instanceof LOConst) {
                 // don't have to do anything
             }
+            else if (op instanceof LOUserFunc){
+                visit((LOUserFunc)op);
+            }
             else {
                 String msg = "Unsupported root operator in inner plan:"
                              + op.getClass().getSimpleName() ;
diff --git a/test/org/apache/pig/test/TestFilterUDF.java b/test/org/apache/pig/test/TestFilterUDF.java
new file mode 100644
index 000000000..c441de6d1
--- /dev/null
+++ b/test/org/apache/pig/test/TestFilterUDF.java
@@ -0,0 +1,75 @@
+package org.apache.pig.test;
+
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.PrintWriter;
+import java.util.Iterator;
+import java.util.Random;
+
+import junit.framework.TestCase;
+
+import org.apache.pig.EvalFunc;
+import org.apache.pig.ExecType;
+import org.apache.pig.PigServer;
+import org.apache.pig.backend.executionengine.ExecException;
+import org.apache.pig.data.DataBag;
+import org.apache.pig.data.DataType;
+import org.apache.pig.data.Tuple;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class TestFilterUDF extends TestCase {
+    private PigServer pigServer;
+    
+    @Before
+    public void setUp() throws Exception {
+        pigServer = new PigServer(ExecType.LOCAL);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+    
+    static public class MyFilterFunction extends EvalFunc<Boolean>{
+
+        @Override
+        public Boolean exec(Tuple input) throws IOException {
+            try {
+                int col = (Integer)input.get(0);
+                if(col>10)
+                    return true;
+            } catch (ExecException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+            }
+            return false;
+        }
+        
+    }
+    
+    @Test
+    public void testFilterUDF() throws Exception{
+        int LOOP_SIZE = 20;
+        File tmpFile = File.createTempFile("test", "txt");
+        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        for(int i = 1; i <= LOOP_SIZE; i++) {
+            ps.println(i);
+        }
+        ps.close();
+        pigServer.registerQuery("A = LOAD 'file:" + tmpFile + "' as (x:int);");
+        pigServer.registerQuery("B = filter A by " + MyFilterFunction.class.getName() + "();");
+        Iterator<Tuple> iter = pigServer.openIterator("B");
+        if(!iter.hasNext()) fail("No Output received");
+        int cnt = 0;
+        while(iter.hasNext()){
+            Tuple t = iter.next();
+            assertEquals(true,(Integer)t.get(0)>10);
+            ++cnt;
+        }
+        assertEquals(10, cnt);
+    }
+}
