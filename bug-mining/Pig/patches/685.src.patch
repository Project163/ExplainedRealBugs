diff --git a/CHANGES.txt b/CHANGES.txt
index 6639d37f1..ba01cd0c3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -147,6 +147,10 @@ PIG-1696: Performance: Use System.arraycopy() instead of manually copying the by
 
 BUG FIXES
 
+PIG-1929:Type checker failed to catch invalid type comparison (thejas)
+
+PIG-1928: Type Checking, incorrect error message (thejas)
+
 PIG-1979: New logical plan failing with ERROR 2229: Couldn't find matching uid -1 (daijy)
 
 PIG-1897: multiple star projection in a statement does not produce 
diff --git a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
index 5b5f50caa..d19d0771b 100644
--- a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
@@ -226,9 +226,9 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         LogicalFieldSchema rhsFs = binOp.getRhs().getFieldSchema();
         
         msg = msg + "incompatible types in " + binOp.getName() + " Operator"
-        + " left hand side:" + DataType.findTypeName(lhsFs) 
+        + " left hand side:" + DataType.findTypeName(lhsFs.type) 
         + (lhsFs.schema == null ? "" : " " + lhsFs.schema.toString(false) + " ") 
-        + " right hand side:" + DataType.findTypeName(rhsFs) 
+        + " right hand side:" + DataType.findTypeName(rhsFs.type) 
         + (rhsFs.schema == null ? "" : " " + rhsFs.schema.toString(false) + " ") ;
         return msg;
     }
@@ -309,42 +309,43 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
     @Override
     public void visit(LessThanExpression binOp)
     throws FrontendException {
-        addCastsToCompareBinaryExp(binOp);
+        addCastsToCompareBinaryExp(binOp, false /*not equality op*/);
     }
     
     @Override
     public void visit(LessThanEqualExpression binOp)
     throws FrontendException {
-        addCastsToCompareBinaryExp(binOp);
+        addCastsToCompareBinaryExp(binOp, false /*not equality op*/);
     }
     
 
     @Override
     public void visit(GreaterThanExpression binOp)
     throws FrontendException {
-        addCastsToCompareBinaryExp(binOp);
+        addCastsToCompareBinaryExp(binOp, false /*not equality op*/);
     }
     
     @Override
     public void visit(GreaterThanEqualExpression binOp)
     throws FrontendException {
-        addCastsToCompareBinaryExp(binOp);
+        addCastsToCompareBinaryExp(binOp, false /*not equality op*/);
     }
     
 
     @Override
     public void visit(EqualExpression binOp)
     throws FrontendException {
-        addCastsToCompareBinaryExp(binOp);
+        addCastsToCompareBinaryExp(binOp, true /*equality op*/);
     }
 
     @Override
     public void visit(NotEqualExpression binOp)
     throws FrontendException {
-        addCastsToCompareBinaryExp(binOp);
+        addCastsToCompareBinaryExp(binOp, true /*equality op*/);
     }
     
-    private void addCastsToCompareBinaryExp(BinaryExpression binOp) throws FrontendException {
+    private void addCastsToCompareBinaryExp(BinaryExpression binOp, boolean isEquality)
+    throws FrontendException {
         LogicalExpression lhs = binOp.getLhs() ;
         LogicalExpression rhs = binOp.getRhs() ;
 
@@ -382,34 +383,47 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         ) {
             // Cast byte array to the type on lhs
             insertCast(binOp, lhsType, binOp.getRhs());
-        }else if ( (lhsType == DataType.TUPLE) &&
-                (rhsType == DataType.TUPLE) ) {
-            // good
-        }
-        else if ( (lhsType == DataType.MAP) &&
-                (rhsType == DataType.MAP) ) {
-            // good
+        }else if (isEquality){
+            
+            //in case of equality condition, allow tuples and maps as args
+            if((lhsType == DataType.TUPLE) &&
+                    (rhsType == DataType.TUPLE) ) {
+                // good
+            }
+            else if ( (lhsType == DataType.MAP) &&
+                    (rhsType == DataType.MAP) ) {
+                // good
+            }
+            else if (lhsType == DataType.BYTEARRAY && 
+                    (rhsType == DataType.MAP || rhsType == DataType.TUPLE)){
+                // Cast byte array to the type on lhs
+                insertCast(binOp, rhsType, binOp.getLhs());
+            }
+            else if(rhsType == DataType.BYTEARRAY &&
+                    (lhsType == DataType.MAP || lhsType == DataType.TUPLE)){
+                // Cast byte array to the type on lhs
+                insertCast(binOp, lhsType, binOp.getRhs());
+            }
+            else {
+                throwIncompatibleTypeError(binOp);
+            }
         }
-        // A constant null is always bytearray - so cast it
-        // to rhs type
-        else if (binOp.getLhs() instanceof ConstantExpression
-                && ((ConstantExpression) binOp.getLhs()).getValue() == null) {
-            insertCast(binOp, rhsType, binOp.getLhs());
-        } else if (binOp.getRhs() instanceof ConstantExpression
-                && ((ConstantExpression) binOp.getRhs()).getValue() == null) {
-            insertCast(binOp, lhsType, binOp.getRhs());
-        } 
         else {
-            int errCode = 1039;
-            String msg = generateIncompatibleTypesMessage(binOp);
-            msgCollector.collect(msg, MessageType.Error) ;
-            throw new TypeCheckerException(binOp, msg, errCode, PigException.INPUT) ;
+            throwIncompatibleTypeError(binOp);
         }
         //input types might have changed, regenerate field schema
         binOp.resetFieldSchema();
         binOp.getFieldSchema();
     }
 
+    private void throwIncompatibleTypeError(BinaryExpression binOp)
+    throws FrontendException {
+        int errCode = 1039;
+        String msg = generateIncompatibleTypesMessage(binOp);
+        msgCollector.collect(msg, MessageType.Error) ;
+        throw new TypeCheckerException(binOp, msg, errCode, PigException.INPUT);
+    }
+
     private void insertCastsForNullToBoolean(BinaryExpression binOp)
     throws FrontendException {
         if (binOp.getLhs() instanceof ConstantExpression
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java b/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
index 60b307f06..c02023a27 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidatorNewLP.java
@@ -401,7 +401,10 @@ public class TestTypeCheckingValidatorNewLP {
             fail("Exception expected") ;
         }
         catch (TypeCheckerException pve) {
-            // good
+            String msg = "In alias dummy, incompatible types in " +
+            "Add Operator left hand side:chararray right hand side:long";
+            
+            checkMessageInException(pve, msg);
         }
         printMessageCollector(collector) ;
         //printTypeGraph(plan) ;
@@ -2416,22 +2419,19 @@ public class TestTypeCheckingValidatorNewLP {
 
         private CastExpression getCastFromExpPlan( LogicalExpressionPlan expPlan) {
             
-            if(expPlan.getSources().size() == 1 && expPlan.getSinks().size() == 1 ){
-                // looking for explicit cast . eg, foreach .. generate (int)a;
-                Operator out = expPlan.getSources().get(0);
-                Operator in = expPlan.getSinks().get(0);
-                if(in instanceof ProjectExpression && out instanceof CastExpression){
-                    return (CastExpression)out;
+            CastExpression castExpr = null;
+            Iterator<Operator> opsIter = expPlan.getOperators();
+            while(opsIter.hasNext()){
+                Operator op = opsIter.next();
+                if(op instanceof CastExpression){
+                    if(castExpr != null){
+                        fail("more than one cast found in plan");
+                    }
+                    castExpr = (CastExpression) op;
                 }
-
             }
-                        
-            LogicalExpression exOp = (LogicalExpression) expPlan.getSinks().get(0);
-    
-            if(! (exOp instanceof ProjectExpression)) exOp = (LogicalExpression) expPlan.getSinks().get(1);
-    
-            assertNotNull(expPlan.getPredecessors(exOp));
-            return (CastExpression)expPlan.getPredecessors(exOp).get(0);
+            return castExpr;
+
         }
 
         private LOForEach getForeachFromPlan(String query) throws FrontendException {
@@ -2448,7 +2448,30 @@ public class TestTypeCheckingValidatorNewLP {
             }
             return foreach;
         }
+        
+        private CastExpression getCastFromLastFilter(String query) throws FrontendException {
+            LOFilter filter = getFilterFromPlan(query);
+            
+            LogicalExpressionPlan filterPlan = filter.getFilterPlan();
+            return getCastFromExpPlan(filterPlan);
+        }
+        
 
+        private LOFilter getFilterFromPlan(String query) throws FrontendException {
+            LogicalPlan plan = createAndProcessLPlan(query);
+            LOFilter filter = null;
+            
+            for(Operator op : plan.getSinks()){
+                if(op instanceof LOFilter){
+                    if(filter != null){
+                        fail("more than one sink foreach found in plan");
+                    }
+                    filter = (LOFilter) op;
+                }
+            }
+            return filter;
+        }
+        
         private LogicalPlan createAndProcessLPlan(String query) throws FrontendException {
             LogicalPlan plan = generateLogicalPlan(query);
             
@@ -3494,9 +3517,12 @@ public class TestTypeCheckingValidatorNewLP {
         public void testMapLookupLineage() throws Throwable {
             String query =  "a = load 'a' using PigStorage('a') as (field1, field2: float, field3: chararray );"
             + "b = foreach a generate field1#'key1' as map1;"
-            + "c = foreach b generate map1#'key2' + 1 ;";
+            + "c = foreach b generate map1#'key2' as keyval;";
+            checkLastForeachCastLoadFunc(query, "PigStorage('a')", 0);
             
+            query += "d = foreach c generate keyval + 1 ;";
             checkLastForeachCastLoadFunc(query, "PigStorage('a')", 0);
+
         }
         
         
@@ -3504,8 +3530,10 @@ public class TestTypeCheckingValidatorNewLP {
         public void testMapLookupLineageNoSchema() throws Throwable {
             String query =  "a = load 'a' using PigStorage('a') ;"
             + "b = foreach a generate $0#'key1';"
-            + "c = foreach b generate $0#'key2' + 1 ;";
+            + "c = foreach b generate $0#'key2' ;";
+            checkLastForeachCastLoadFunc(query, "PigStorage('a')", 0);
             
+            query += "d = foreach c generate $0 + 1;";
             checkLastForeachCastLoadFunc(query, "PigStorage('a')", 0);
   
         }
@@ -3538,8 +3566,10 @@ public class TestTypeCheckingValidatorNewLP {
         public void testMapLookupLineage3() throws Throwable {
             String query = "a= load 'a' as (s, m, l);"
                 + "b = foreach a generate flatten(l#'viewinfo') as viewinfo ;"
-                + "c = foreach b generate (chararray)viewinfo#'pos' as position;";
+                + "c = foreach b generate viewinfo#'pos' as position;";
+            checkLastForeachCastLoadFunc(query, "org.apache.pig.builtin.PigStorage", 0);
             
+            query +=  "d = foreach c generate (chararray)position;";
             checkLastForeachCastLoadFunc(query, "org.apache.pig.builtin.PigStorage", 0);
 
         }
@@ -3910,5 +3940,112 @@ public class TestTypeCheckingValidatorNewLP {
             LogicalPlan plan = createAndProcessLPlan(query);
             checkLoaderInCasts(plan, PigStorage.class.getName());
         }
+        
+        // See PIG-1929
+        @Test
+        public void testCompareTupleFail() throws Throwable {
+           
+            String query = "a = load 'a' as (t : (i : int, j : int)) ;"
+            + "b = filter a by t > (1,2);";
+
+            String exMsg= "In alias b, incompatible types in GreaterThan Operator" +
+            		" left hand side:tuple i:int,j:int " +
+            		" right hand side:tuple :int,:int";
+
+            checkExceptionMessage(query, "b", exMsg);
+        }
+        
+        @Test
+        public void testCompareEqualityTupleCast() throws Throwable {
+            //test if bytearray col gets casted to tuple
+            String query = "a = load 'a' as (t : (i : int, j : int), col) ;"
+            + "b = filter a by t == col;";
+            
+            CastExpression castExp = getCastFromLastFilter(query);
+            assertNotNull("cast ", castExp);
+            assertEquals("cast type", castExp.getType(), DataType.TUPLE);
+        }
+        
+        @Test
+        public void testCompareEqualityMapCast() throws Throwable {
+            //test if bytearray col gets casted to map
+            String query = "a = load 'a' as (t : map[], col) ;"
+            + "b = filter a by t != col;";
+            
+            CastExpression castExp = getCastFromLastFilter(query);
+            assertNotNull("cast ", castExp);
+            assertEquals("cast type", castExp.getType(), DataType.MAP);
+        }
+        
+        @Test
+        public void testCompareEqualityMapIntegerFail() throws Throwable {
+            //test if failure is reported on use of incompatible type
+            String query = "a = load 'a' as (t1 :map[], t2 : int) ;"
+                + "b = filter a by t1 == t2;";
+
+                String exMsg= "In alias b, incompatible types in Equal " +
+                "Operator left hand side:map right hand side:int";
+                checkExceptionMessage(query, "b", exMsg);
+        }
+        
+        
+        // See PIG-1929
+        @Test
+        public void testCompareMapFail() throws Throwable {
+           
+            String query = "a = load 'a' as (t1 :map[], t2 : map[]) ;"
+            + "b = filter a by t1 <= t2;";
+
+            String exMsg= "In alias b, incompatible types in LessThanEqual " +
+            "Operator left hand side:map right hand side:map";
+            checkExceptionMessage(query, "b", exMsg);
+        }
+        
+        // See PIG-1929
+        @Test
+        public void testCompareBagFail() throws Throwable {
+           
+            String query = "a = load 'a' as (t1 :bag{()}, t2 : bag{()}) ;"
+            + "b = filter a by t1 <= t2;";
+
+            String exMsg= "In alias b, incompatible types in LessThanEqual " +
+            "Operator left hand side:bag :tuple()  right hand side:bag :tuple()";
+            checkExceptionMessage(query, "b", exMsg);
+        }
+
+        // See PIG-1929
+        @Test
+        public void testCompareNULL() throws Throwable {
+           
+            {
+                //equality & null
+                String query = "a = load 'a' as (t1 : int) ;"
+                    + "b = filter a by null == t1;";
+
+                CastExpression castExp = getCastFromLastFilter(query);
+                assertNotNull("cast ", castExp);
+                assertEquals("cast type", castExp.getType(), DataType.INTEGER);
+            }
+            {
+                //equality & null & complex type
+                String query = "a = load 'a' as (t1 : (i : int)) ;"
+                    + "b = filter a by null == t1;";
 
+                CastExpression castExp = getCastFromLastFilter(query);
+                assertNotNull("cast ", castExp);
+                assertEquals("cast type", castExp.getType(), DataType.TUPLE);
+            }
+            {
+                String query = "a = load 'a' as (t1 : int) ;"
+                    + "b = filter a by t1 <= null;";
+
+                CastExpression castExp = getCastFromLastFilter(query);
+                assertNotNull("cast ", castExp);
+                assertEquals("cast type", castExp.getType(), DataType.INTEGER);
+            }
+                        
+        }
+        
+        
+        
 }
diff --git a/test/org/apache/pig/test/Util.java b/test/org/apache/pig/test/Util.java
index 3d79d2c6c..a5370d616 100644
--- a/test/org/apache/pig/test/Util.java
+++ b/test/org/apache/pig/test/Util.java
@@ -481,13 +481,8 @@ public class Util {
              Util.registerMultiLineQuery(pig, query);
              pig.explain(alias, System.out);
          }catch(FrontendException e){
-             PigException pigEx = LogUtils.getPigException(e);
              foundEx = true;
-             if(!pigEx.getMessage().contains(expectedErr)){
-                 String msg = "Expected exception message matching '" 
-                     + expectedErr + "' but got '" + pigEx.getMessage() + "'" ;
-                 fail(msg);
-             }
+             checkMessageInException(e, expectedErr);
          }
 
          if(!foundEx)
@@ -495,7 +490,17 @@ public class Util {
 
      }
 
-	/**
+     public static void checkMessageInException(FrontendException e,
+             String expectedErr) {
+         PigException pigEx = LogUtils.getPigException(e);
+         if(!pigEx.getMessage().contains(expectedErr)){
+             String msg = "Expected exception message matching '" 
+                 + expectedErr + "' but got '" + pigEx.getMessage() + "'" ;
+             fail(msg);
+         }
+     }
+
+    /**
 	 * Utility method to copy a file form local filesystem to the dfs on
 	 * the minicluster for testing in mapreduce mode
 	 * @param cluster a reference to the minicluster
