diff --git a/CHANGES.txt b/CHANGES.txt
index de79dac98..5b7d6f829 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -66,6 +66,8 @@ PIG-3013: BinInterSedes improve chararray sort performance (rohini)
 
 BUG FIXES
 
+PIG-2433: Jython import module not working if module path is in classpath (rohini)
+
 PIG-2769 a simple logic causes very long compiling time on pig 0.10.0 (nwhite via gates)
 
 PIG-2251: PIG leaks Zookeeper connections when using HBaseStorage (jamarkha via cheolsoo)
diff --git a/build.xml b/build.xml
index 2c53b0899..afc669e3a 100644
--- a/build.xml
+++ b/build.xml
@@ -525,6 +525,11 @@
             <path refid="mr-apps-test-ivy.classpath"/>
         </path>
         <property name="mr-apps-classpath" refid="mr-apps-test.classpath" />
+        <!-- Remove jython jar from mrapp-generated-classpath -->
+        <script language="javascript">
+          project.setProperty('mr-apps-classpath', project.getProperty('mr-apps-classpath').
+           replace(":" + project.getProperty('ivy.default.ivy.user.dir') + "/cache/org.python/jython-standalone/jars/jython-standalone-2.5.2.jar", ""));
+        </script>
         <echo file="${test.build.classes}/mrapp-generated-classpath" message="${mr-apps-classpath}" />
     </target>
 
diff --git a/src/org/apache/pig/scripting/jython/JythonScriptEngine.java b/src/org/apache/pig/scripting/jython/JythonScriptEngine.java
index c80676747..1a8f94939 100644
--- a/src/org/apache/pig/scripting/jython/JythonScriptEngine.java
+++ b/src/org/apache/pig/scripting/jython/JythonScriptEngine.java
@@ -24,10 +24,13 @@ import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.regex.Pattern;
 
 import org.apache.commons.logging.Log;
@@ -41,6 +44,7 @@ import org.apache.pig.impl.util.Utils;
 import org.apache.pig.parser.ParserException;
 import org.apache.pig.scripting.ScriptEngine;
 import org.apache.pig.tools.pigstats.PigStats;
+import org.python.core.ClasspathPyImporter;
 import org.python.core.Py;
 import org.python.core.PyException;
 import org.python.core.PyFrame;
@@ -52,6 +56,7 @@ import org.python.core.PyString;
 import org.python.core.PyStringMap;
 import org.python.core.PySystemState;
 import org.python.core.PyTuple;
+import org.python.modules.zipimport.zipimporter;
 import org.python.util.PythonInterpreter;
 
 /**
@@ -194,6 +199,19 @@ public class JythonScriptEngine extends ScriptEngine {
 
                 // determine the current module state
                 Map<String, String> before = pigContext != null ? getModuleState() : null;
+                if (before != null) {
+                    // os.py, stax.py and posixpath.py are part of the initial state
+                    // if Lib directory is present and without including os.py, modules
+                    // which import os fail
+                    Set<String> includePyModules = new HashSet<String>();
+                    for (String key : before.keySet()) {
+                        // $py.class is created if Lib folder is writable
+                        if (key.endsWith(".py") || key.endsWith("$py.class")) {
+                            includePyModules.add(key);
+                        }
+                    }
+                    before.keySet().removeAll(includePyModules);
+                }
 
                 // exec the code, arbitrary imports are processed
                 interpreter.execfile(script, path);
@@ -256,10 +274,10 @@ public class JythonScriptEngine extends ScriptEngine {
                 PyTuple tuple = (PyTuple) kvp;
                 String name = tuple.get(0).toString();
                 Object value = tuple.get(1);
-
                 // inspect the module to determine file location and status
                 try {
                     Object fileEntry = null;
+                    Object loader = null;
                     if (value instanceof PyJavaPackage ) {
                         fileEntry = ((PyJavaPackage) value).__file__;
                     } else if (value instanceof PyObject) {
@@ -267,11 +285,12 @@ public class JythonScriptEngine extends ScriptEngine {
                         PyObject dict = ((PyObject) value).getDict();
                         if (dict != null) {
                             fileEntry = dict.__finditem__("__file__");
+                            loader = dict.__finditem__("__loader__");
                         } // else built-in
                     }   // else some system module?
 
                     if (fileEntry != null) {
-                        File file = new File(fileEntry.toString());
+                        File file = resolvePyModulePath(fileEntry.toString(), loader);
                         if (file.exists()) {
                             String apath = file.getAbsolutePath();
                             if (apath.endsWith(".jar") || apath.endsWith(".zip")) {
@@ -297,6 +316,26 @@ public class JythonScriptEngine extends ScriptEngine {
             return files;
         }
     }
+    
+    private static File resolvePyModulePath(String path, Object loader) {
+        File file = new File(path);
+        if (!file.exists() && loader != null) {
+            if(path.startsWith(ClasspathPyImporter.PYCLASSPATH_PREFIX) && loader instanceof ClasspathPyImporter) {
+                path = path.replaceFirst(ClasspathPyImporter.PYCLASSPATH_PREFIX, "");
+                URL resource = ScriptEngine.class.getResource(path);
+                if (resource == null) {
+                    resource = ScriptEngine.class.getResource(File.separator + path);
+                }
+                if (resource != null) {
+                    return new File(resource.getFile());
+                }
+            } else if (loader instanceof zipimporter) {
+                zipimporter importer = (zipimporter) loader;
+                return new File(importer.archive);
+            } //JavaImporter??
+        }
+        return file;
+    }
 
     @Override
     public void registerFunctions(String path, String namespace, PigContext pigContext)
diff --git a/test/org/apache/pig/test/TestScriptUDF.java b/test/org/apache/pig/test/TestScriptUDF.java
index 16b456392..9ed3d3545 100644
--- a/test/org/apache/pig/test/TestScriptUDF.java
+++ b/test/org/apache/pig/test/TestScriptUDF.java
@@ -19,7 +19,6 @@ package org.apache.pig.test;
 
 import java.io.File;
 import java.util.Iterator;
-import java.util.Map;
 import java.util.Random;
 
 import junit.framework.Assert;
@@ -27,8 +26,6 @@ import junit.framework.Assert;
 import org.apache.pig.ExecType;
 import org.apache.pig.PigServer;
 import org.apache.pig.data.BagFactory;
-import org.apache.pig.data.DataBag;
-import org.apache.pig.data.DataByteArray;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.io.FileLocalizer;
@@ -141,15 +138,13 @@ public class TestScriptUDF{
         Assert.assertFalse(iter.hasNext());
     }
 
-    /** See Pig-1824
+    /** See Pig-1824, PIG-2433
      * test importing a second module/file from the local fs from within
      * the first module.
      *
-     * NOTE: this unit test also covers the "import re" test case.
-     * not all users have a jython install, so there is no explicit unit test
-     * for "import re".
      * to use a jython install, the Lib dir must be in the jython search path
-     * via env variable JYTHON_HOME=jy_home or JYTHON_PATH=jy_home/Lib:...
+     * via env variable JYTHON_HOME=jy_home or JYTHON_PATH=jy_home/Lib:... or
+     * jython-standalone.jar should be in the classpath
      * 
      * Left in for now as we don't have paths to include other scripts in a
      * script in the e2e harness.
@@ -157,57 +152,126 @@ public class TestScriptUDF{
      * @throws Exception
      */
     @Test
-    public void testPythonNestedImport() throws Exception {
-        // Skip for hadoop 23 until PIG-2433 fixed
-        if (Util.isHadoop23() || Util.isHadoop2_0())
-            return;
-        
-        String[] scriptA = {
+    public void testPythonNestedImportCwdInClassPath() throws Exception {
+        testPythonNestedImport(".", "scriptA.py", "scriptB.py");
+    }
+
+    @Test
+    public void testPythonNestedImportClassPath() throws Exception {
+        // Use different names for the script as PythonInterpreter is static in JythonScriptEngine 
+        testPythonNestedImport("build/classes", "scriptC.py", "scriptD.py");
+    }
+
+    public void testPythonNestedImport(String importScriptLocation, String script1Name,
+            String script2Name) throws Exception {
+        String[] script1 = {
                 "#!/usr/bin/python",
                 "def square(number):" ,
                 " return (number * number)"
         };
-        String[] scriptB = {
+        String script1ModuleName = script1Name.replace(".py", "");
+        String[] script2 = {
                 "#!/usr/bin/python",
-                "import scriptA",
+                "import " + script1ModuleName,
                 "@outputSchema(\"x:{t:(num:double)}\")",
                 "def sqrt(number):" ,
                 " return (number ** .5)",
                 "@outputSchema(\"x:{t:(num:long)}\")",
                 "def square(number):" ,
-                " return long(scriptA.square(number))"
+                " return long(" + script1ModuleName + ".square(number))"
         };
         String[] input = {
                 "1\t3",
                 "2\t4",
                 "3\t5"
         };
-
+        Util.deleteFile(cluster, "table_testPythonNestedImport");
         Util.createInputFile(cluster, "table_testPythonNestedImport", input);
-        Util.createLocalInputFile("scriptA.py", scriptA);
-        File scriptFileB = Util.createLocalInputFile("scriptB.py", scriptB);
+        Util.createLocalInputFile(importScriptLocation + "/" + script1Name, script1);
+        String script2FilePath = Util.createLocalInputFile(script2Name, script2).getAbsolutePath();
 
-        // Test the namespace: import B, which, in turn, imports A
-        pigServer.registerCode(scriptFileB.getAbsolutePath(), "jython", "pig");
+        // Test the namespace: import file2, which, in turn, imports file1
+        pigServer.registerCode(script2FilePath, "jython", "pig");
         pigServer.registerQuery("A = LOAD 'table_testPythonNestedImport' as (a0:long, a1:long);");
         pigServer.registerQuery("B = foreach A generate pig.square(a0);");
 
         Iterator<Tuple> iter = pigServer.openIterator("B");
         Assert.assertTrue(iter.hasNext());
         Tuple t = iter.next();
-
         Assert.assertTrue(t.toString().equals("(1)"));
-
         Assert.assertTrue(iter.hasNext());
         t = iter.next();
-
         Assert.assertTrue(t.toString().equals("(4)"));
+        Assert.assertTrue(iter.hasNext());
+        t = iter.next();
+        Assert.assertTrue(t.toString().equals("(9)"));
+        Assert.assertFalse(iter.hasNext());
+    }
+
+    @Test
+    public void testPythonBuiltinModuleImport1() throws Exception {
+        String[] script = {
+                "#!/usr/bin/python",
+                "import os",
+                "@outputSchema(\"env:chararray\")",
+                "def getEnv(envkey):" ,
+                " return os.getenv(envkey);"
+        };
+        String[] input = {
+                "USER",
+                "PATH"
+        };
+
+        Util.createInputFile(cluster, "testPythonBuiltinModuleImport1", input);
+        File scriptFile = Util.createLocalInputFile("importos.py", script);
+
+        pigServer.registerCode(scriptFile.getAbsolutePath(), "jython", "pig");
+        pigServer.registerQuery("A = LOAD 'testPythonBuiltinModuleImport1' as (a0:chararray);");
+        pigServer.registerQuery("B = foreach A generate pig.getEnv(a0);");
 
+        Iterator<Tuple> iter = pigServer.openIterator("B");
+        Assert.assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+        Assert.assertTrue(t.get(0).toString().equals(System.getenv(input[0])));
         Assert.assertTrue(iter.hasNext());
         t = iter.next();
+        Assert.assertTrue(t.get(0).toString().equals(System.getenv(input[1])));
+        Assert.assertFalse(iter.hasNext());
+    }
 
-        Assert.assertTrue(t.toString().equals("(9)"));
-        
+    @Test
+    public void testPythonBuiltinModuleImport2() throws Exception {
+        String[] script = {
+                "#!/usr/bin/python",
+                "import re",
+                "@outputSchema(\"word:chararray\")",
+                "def resplit(content,regex,index):" ,
+                " return re.compile(regex).split(content)[index];"
+        };
+        String[] input = {
+                "Hello world",
+                "The quick brown fox jumps over the lazy dog"
+        };
+
+        Util.createInputFile(cluster, "testPythonBuiltinModuleImport2", input);
+        File scriptFile = Util.createLocalInputFile("importre.py", script);
+
+        String[] pigScript = {
+                "register '" + scriptFile.getAbsolutePath() + "' using jython as pig;",
+                "A = LOAD 'testPythonBuiltinModuleImport2' as (a0:chararray);",
+                "B = foreach A generate pig.resplit(a0, '\\\\s+', 0);"
+        };
+
+        String pigScriptFile = Util.createLocalInputFile("importre.pig", pigScript).getPath();
+        pigServer.registerScript(pigScriptFile);
+
+        Iterator<Tuple> iter = pigServer.openIterator("B");
+        Assert.assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+        Assert.assertTrue(t.get(0).toString().equals(input[0].split("\\s+")[0]));
+        Assert.assertTrue(iter.hasNext());
+        t = iter.next();
+        Assert.assertTrue(t.get(0).toString().equals(input[1].split("\\s+")[0]));
         Assert.assertFalse(iter.hasNext());
     }
 }
