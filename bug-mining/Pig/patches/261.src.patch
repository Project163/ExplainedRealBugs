diff --git a/CHANGES.txt b/CHANGES.txt
index e8bbb88bf..56f8c3be8 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,6 +26,9 @@ INCOMPATIBLE CHANGES
 
 IMPROVEMENTS
 
+PIG-1018: FINDBUGS: NM_FIELD_NAMING_CONVENTION: Field names should start with
+a lower case letter (olgan)
+
 PIG-1023: FINDBUGS: exclude CN_IDIOM_NO_SUPER_CALL (olgan)
 
 PIG-1019: added findbugs exclusion file (olgan)
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index 45feb1198..04ed17274 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -66,7 +66,7 @@ import org.apache.pig.impl.util.MultiMap;
 
 public class LogToPhyTranslationVisitor extends LOVisitor {
 
-    protected Map<LogicalOperator, PhysicalOperator> LogToPhyMap;
+    protected Map<LogicalOperator, PhysicalOperator> logToPhyMap;
 
     Random r = new Random();
 
@@ -88,7 +88,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 
         currentPlans = new Stack<PhysicalPlan>();
         currentPlan = new PhysicalPlan();
-        LogToPhyMap = new HashMap<LogicalOperator, PhysicalOperator>();
+        logToPhyMap = new HashMap<LogicalOperator, PhysicalOperator>();
     }
 
     public void setPigContext(PigContext pc) {
@@ -107,19 +107,19 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 scope, nodeGen.getNextNodeId(scope)), op
                 .getRequestedParallelism());
         exprOp.setOperandType(op.getLhsOperand().getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
 
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 // currentExprPlan.connect(from, exprOp);
                 currentPlan.connect(from, exprOp);
@@ -138,19 +138,19 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 scope, nodeGen.getNextNodeId(scope)), op
                 .getRequestedParallelism());
         exprOp.setOperandType(op.getLhsOperand().getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
 
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -168,18 +168,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 scope, nodeGen.getNextNodeId(scope)), op
                 .getRequestedParallelism());
         exprOp.setOperandType(op.getLhsOperand().getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -197,18 +197,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 scope, nodeGen.getNextNodeId(scope)), op
                 .getRequestedParallelism());
         exprOp.setOperandType(op.getLhsOperand().getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -226,18 +226,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 scope, nodeGen.getNextNodeId(scope)), op
                 .getRequestedParallelism());
         exprOp.setOperandType(op.getLhsOperand().getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -255,18 +255,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 scope, nodeGen.getNextNodeId(scope)), op
                 .getRequestedParallelism());
         exprOp.setOperandType(op.getLhsOperand().getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -283,18 +283,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         BinaryComparisonOperator exprOp =
             new PORegexp(new OperatorKey(scope, nodeGen.getNextNodeId(scope)),
             op.getRequestedParallelism());
-        exprOp.setLhs((ExpressionOperator)LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator)LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator)logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator)logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -311,18 +311,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         BinaryExpressionOperator exprOp = new Add(new OperatorKey(scope,
                 nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
         exprOp.setResultType(op.getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -339,18 +339,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         BinaryExpressionOperator exprOp = new Subtract(new OperatorKey(scope,
                 nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
         exprOp.setResultType(op.getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -367,18 +367,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         BinaryExpressionOperator exprOp = new Multiply(new OperatorKey(scope,
                 nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
         exprOp.setResultType(op.getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -395,18 +395,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         BinaryExpressionOperator exprOp = new Divide(new OperatorKey(scope,
                 nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
         exprOp.setResultType(op.getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -423,18 +423,18 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         BinaryExpressionOperator exprOp = new Mod(new OperatorKey(scope,
                 nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
         exprOp.setResultType(op.getType());
-        exprOp.setLhs((ExpressionOperator) LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator) LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator) logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator) logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
 
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if (predecessors == null)
             return;
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -449,17 +449,17 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
     public void visit(LOAnd op) throws VisitorException {
         String scope = op.getOperatorKey().scope;
         BinaryComparisonOperator exprOp = new POAnd(new OperatorKey(scope, nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
-        exprOp.setLhs((ExpressionOperator)LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator)LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator)logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator)logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
         
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
         
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if(predecessors == null) return;
         for(LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -474,17 +474,17 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
     public void visit(LOOr op) throws VisitorException {
         String scope = op.getOperatorKey().scope;
         BinaryComparisonOperator exprOp = new POOr(new OperatorKey(scope, nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
-        exprOp.setLhs((ExpressionOperator)LogToPhyMap.get(op.getLhsOperand()));
-        exprOp.setRhs((ExpressionOperator)LogToPhyMap.get(op.getRhsOperand()));
+        exprOp.setLhs((ExpressionOperator)logToPhyMap.get(op.getLhsOperand()));
+        exprOp.setRhs((ExpressionOperator)logToPhyMap.get(op.getRhsOperand()));
         LogicalPlan lp = op.getPlan();
         
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
         
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if(predecessors == null) return;
         for(LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -499,15 +499,15 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
     public void visit(LONot op) throws VisitorException {
         String scope = op.getOperatorKey().scope;
         UnaryComparisonOperator exprOp = new PONot(new OperatorKey(scope, nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
-        exprOp.setExpr((ExpressionOperator)LogToPhyMap.get(op.getOperand()));
+        exprOp.setExpr((ExpressionOperator)logToPhyMap.get(op.getOperand()));
         LogicalPlan lp = op.getPlan();
         
         currentPlan.add(exprOp);
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
         
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
         if(predecessors == null) return;
-        PhysicalOperator from = LogToPhyMap.get(predecessors.get(0));
+        PhysicalOperator from = logToPhyMap.get(predecessors.get(0));
         try {
             currentPlan.connect(from, exprOp);
         } catch (PlanException e) {
@@ -538,7 +538,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             List<Boolean> flattenLst = Arrays.asList(true, true);
             
             for (LogicalOperator op : inputs) {
-                List<PhysicalOperator> pop = Arrays.asList(LogToPhyMap.get(op));
+                List<PhysicalOperator> pop = Arrays.asList(logToPhyMap.get(op));
                 PhysicalPlan fep1 = new PhysicalPlan();
                 ConstantExpression ce1 = new ConstantExpression(new OperatorKey(scope, nodeGen.getNextNodeId(scope)),cs.getRequestedParallelism());
                 ce1.setValue(inputs.size());
@@ -575,7 +575,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 
                 POForEach fe = new POForEach(new OperatorKey(scope, nodeGen.getNextNodeId(scope)), cs.getRequestedParallelism(), fePlans, flattenLst );
                 currentPlan.add(fe);
-                currentPlan.connect(LogToPhyMap.get(op), fe);
+                currentPlan.connect(logToPhyMap.get(op), fe);
                 
                 POLocalRearrange physOp = new POLocalRearrange(new OperatorKey(
                         scope, nodeGen.getNextNodeId(scope)), cs
@@ -640,7 +640,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e1);
         }
-        LogToPhyMap.put(cs, fe);
+        logToPhyMap.put(cs, fe);
     }
     
     @Override
@@ -713,7 +713,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             currentPlan.add(physOp);
 
             try {
-                currentPlan.connect(LogToPhyMap.get(op), physOp);
+                currentPlan.connect(logToPhyMap.get(op), physOp);
                 currentPlan.connect(physOp, poGlobal);
             } catch (PlanException e) {
                 int errCode = 2015;
@@ -726,7 +726,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         poPackage.setResultType(DataType.TUPLE);
         poPackage.setNumInps(count);
         poPackage.setInner(cg.getInner());
-        LogToPhyMap.put(cg, poPackage);
+        logToPhyMap.put(cg, poPackage);
     }
     
 	@Override
@@ -750,7 +750,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         List<List<Byte>> keyTypes = new ArrayList<List<Byte>>();
 
         for (LogicalOperator op : inputs) {
-			PhysicalOperator physOp = LogToPhyMap.get(op);
+			PhysicalOperator physOp = logToPhyMap.get(op);
             inp.add(physOp);
             List<LogicalPlan> plans = (List<LogicalPlan>) loj.getJoinPlans().get(op);
             List<PhysicalPlan> exprPlans = new ArrayList<PhysicalPlan>();
@@ -791,14 +791,14 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 
 			for (LogicalOperator op : inputs) {
 				try {
-					currentPlan.connect(LogToPhyMap.get(op), skj);
+					currentPlan.connect(logToPhyMap.get(op), skj);
 				} catch (PlanException e) {
 					int errCode = 2015;
 					String msg = "Invalid physical operators in the physical plan" ;
 					throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
 				}
 			}
-			LogToPhyMap.put(loj, skj);
+			logToPhyMap.put(loj, skj);
 		} 
 		
 		else if(loj.getJoinType() == LOJoin.JOINTYPE.REPLICATED) {
@@ -817,14 +817,14 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 	        currentPlan.add(pfrj);
 	        for (LogicalOperator op : inputs) {
 	            try {
-	                currentPlan.connect(LogToPhyMap.get(op), pfrj);
+	                currentPlan.connect(logToPhyMap.get(op), pfrj);
 	            } catch (PlanException e) {
 	                int errCode = 2015;
 	                String msg = "Invalid physical operators in the physical plan" ;
 	                throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
 	            }
 	        }
-	        LogToPhyMap.put(loj, pfrj);
+	        logToPhyMap.put(loj, pfrj);
 		}
 		
 		else if (loj.getJoinType() == LOJoin.JOINTYPE.MERGE && validateMergeJoin(loj)) {
@@ -844,14 +844,14 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 
             for (LogicalOperator op : inputs) {
                 try {
-                    currentPlan.connect(LogToPhyMap.get(op), smj);
+                    currentPlan.connect(logToPhyMap.get(op), smj);
                 } catch (PlanException e) {
                     int errCode = 2015;
                     String msg = "Invalid physical operators in the physical plan" ;
                     throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
                 }
             }
-            LogToPhyMap.put(loj, smj);
+            logToPhyMap.put(loj, smj);
             return;
         }
 		else if (loj.getJoinType() == LOJoin.JOINTYPE.REGULAR){
@@ -914,7 +914,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 	                currentPlan.add(physOp);
 
 	                try {
-	                    currentPlan.connect(LogToPhyMap.get(op), physOp);
+	                    currentPlan.connect(logToPhyMap.get(op), physOp);
 	                    currentPlan.connect(physOp, poGlobal);
 	                } catch (PlanException e) {
 	                    int errCode = 2015;
@@ -967,7 +967,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
     	                loj.getRequestedParallelism(), fePlans, flattenLst );
     	        currentPlan.add(fe);
 	            currentPlan.connect(poPackage, fe);
-	            LogToPhyMap.put(loj, fe);
+	            logToPhyMap.put(loj, fe);
 	        }catch (PlanException e1) {
 	            int errCode = 2015;
 	            String msg = "Invalid physical operators in the physical plan" ;
@@ -1106,7 +1106,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 .getNextNodeId(scope)), filter.getRequestedParallelism());
         poFilter.setResultType(filter.getType());
         currentPlan.add(poFilter);
-        LogToPhyMap.put(filter, poFilter);
+        logToPhyMap.put(filter, poFilter);
         currentPlans.push(currentPlan);
 
         currentPlan = new PhysicalPlan();
@@ -1124,7 +1124,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 
         PhysicalOperator from;
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Filter." ;
@@ -1147,13 +1147,13 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 .getNextNodeId(scope)), stream.getExecutableManager(), 
                 stream.getStreamingCommand(), this.pc.getProperties());
         currentPlan.add(poStream);
-        LogToPhyMap.put(stream, poStream);
+        logToPhyMap.put(stream, poStream);
         
         List<LogicalOperator> op = stream.getPlan().getPredecessors(stream);
 
         PhysicalOperator from;
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
         } else {                
             int errCode = 2051;
             String msg = "Did not find a predecessor for Stream." ;
@@ -1185,7 +1185,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         exprOp.setStar(op.isStar());
         exprOp.setOverloaded(op.getOverloaded());
         LogicalPlan lp = op.getPlan();
-        LogToPhyMap.put(op, exprOp);
+        logToPhyMap.put(op, exprOp);
         currentPlan.add(exprOp);
 
         List<LogicalOperator> predecessors = lp.getPredecessors(op);
@@ -1195,7 +1195,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             return;
 
         for (LogicalOperator lo : predecessors) {
-            PhysicalOperator from = LogToPhyMap.get(lo);
+            PhysicalOperator from = logToPhyMap.get(lo);
             try {
                 currentPlan.connect(from, exprOp);
             } catch (PlanException e) {
@@ -1231,7 +1231,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 .getNextNodeId(scope)), g.getRequestedParallelism(), innerPlans,
                 g.getFlatten());
         poFE.setResultType(g.getType());
-        LogToPhyMap.put(g, poFE);
+        logToPhyMap.put(g, poFE);
         currentPlan.add(poFE);
 
         // generate cannot have multiple inputs
@@ -1241,7 +1241,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         if (op == null)
             return;
 
-        PhysicalOperator from = LogToPhyMap.get(op.get(0));
+        PhysicalOperator from = logToPhyMap.get(op.get(0));
         try {
             currentPlan.connect(from, poFE);
         } catch (PlanException e) {
@@ -1287,13 +1287,13 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         }
         sort.setLimit(s.getLimit());
         // sort.setRequestedParallelism(s.getType());
-        LogToPhyMap.put(s, sort);
+        logToPhyMap.put(s, sort);
         currentPlan.add(sort);
         List<LogicalOperator> op = s.getPlan().getPredecessors(s); 
         PhysicalOperator from;
         
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Sort." ;
@@ -1321,14 +1321,14 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         PhysicalOperator physOp = new PODistinct(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), op.getRequestedParallelism());
         physOp.setResultType(op.getType());
-        LogToPhyMap.put(op, physOp);
+        logToPhyMap.put(op, physOp);
         currentPlan.add(physOp);
         // Distinct will only have a single input
         List<LogicalOperator> inputs = op.getPlan().getPredecessors(op);
         PhysicalOperator from; 
         
         if(inputs != null) {
-            from = LogToPhyMap.get(inputs.get(0));
+            from = logToPhyMap.get(inputs.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Distinct." ;
@@ -1371,7 +1371,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
 
         }
         ((POSplit)physOp).setSplitStore(splStrFile);
-        LogToPhyMap.put(split, physOp);
+        logToPhyMap.put(split, physOp);
 
         currentPlan.add(physOp);
 
@@ -1379,7 +1379,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         PhysicalOperator from;
         
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Split." ;
@@ -1400,7 +1400,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         String scope = split.getOperatorKey().scope;
         PhysicalOperator physOp = new POFilter(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), split.getRequestedParallelism());
-        LogToPhyMap.put(split, physOp);
+        logToPhyMap.put(split, physOp);
 
         currentPlan.add(physOp);
         currentPlans.push(currentPlan);
@@ -1419,7 +1419,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         PhysicalOperator from;
         
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Split Output." ;
@@ -1454,7 +1454,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         List<org.apache.pig.impl.logicalLayer.ExpressionOperator> fromList = func.getArguments();
         if(fromList!=null){
             for (LogicalOperator op : fromList) {
-                PhysicalOperator from = LogToPhyMap.get(op);
+                PhysicalOperator from = logToPhyMap.get(op);
                 try {
                     currentPlan.connect(from, p);
                 } catch (PlanException e) {
@@ -1464,7 +1464,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 }
             }
         }
-        LogToPhyMap.put(func, p);
+        logToPhyMap.put(func, p);
 
     }
 
@@ -1477,7 +1477,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         load.setPc(pc);
         load.setResultType(loLoad.getType());
         currentPlan.add(load);
-        LogToPhyMap.put(loLoad, load);
+        logToPhyMap.put(loLoad, load);
         this.load = loLoad.getLoadFunc();
 
         // Load is typically a root operator, but in the multiquery
@@ -1486,7 +1486,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         PhysicalOperator from;
         
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
 
             try {
                 currentPlan.connect(from, load);
@@ -1525,7 +1525,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         PhysicalOperator from;
         
         if(op != null) {
-            from = LogToPhyMap.get(op.get(0));
+            from = logToPhyMap.get(op.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Store." ;
@@ -1539,7 +1539,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
-        LogToPhyMap.put(loStore, store);
+        logToPhyMap.put(loStore, store);
     }
 
     @Override
@@ -1551,7 +1551,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         ce.setResultType(op.getType());
         //this operator doesn't have any predecessors
         currentPlan.add(ce);
-        LogToPhyMap.put(op, ce);
+        logToPhyMap.put(op, ce);
     }
 
     @Override
@@ -1559,15 +1559,15 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         String scope = op.getOperatorKey().scope;
         ExpressionOperator physOp = new POBinCond(new OperatorKey(scope,
                 nodeGen.getNextNodeId(scope)), op.getRequestedParallelism());
-        LogToPhyMap.put(op, physOp);
+        logToPhyMap.put(op, physOp);
         POBinCond phy = (POBinCond) physOp;
-        ExpressionOperator cond = (ExpressionOperator) LogToPhyMap.get(op
+        ExpressionOperator cond = (ExpressionOperator) logToPhyMap.get(op
                 .getCond());
         phy.setCond(cond);
-        ExpressionOperator lhs = (ExpressionOperator) LogToPhyMap.get(op
+        ExpressionOperator lhs = (ExpressionOperator) logToPhyMap.get(op
                 .getLhsOp());
         phy.setLhs(lhs);
-        ExpressionOperator rhs = (ExpressionOperator) LogToPhyMap.get(op
+        ExpressionOperator rhs = (ExpressionOperator) logToPhyMap.get(op
                 .getRhsOp());
         phy.setRhs(rhs);
         phy.setResultType(op.getType());
@@ -1576,7 +1576,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         List<LogicalOperator> ops = op.getPlan().getPredecessors(op);
 
         for (LogicalOperator l : ops) {
-            ExpressionOperator from = (ExpressionOperator) LogToPhyMap.get(l);
+            ExpressionOperator from = (ExpressionOperator) logToPhyMap.get(l);
             try {
                 currentPlan.connect(from, physOp);
             } catch (PlanException e) {
@@ -1596,13 +1596,13 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 null);
         currentPlan.add(physOp);
 
-        LogToPhyMap.put(op, physOp);
+        logToPhyMap.put(op, physOp);
 
         List<LogicalOperator> inputs = op.getPlan().getPredecessors(op); 
         ExpressionOperator from;
         
         if(inputs != null) {
-            from = (ExpressionOperator)LogToPhyMap.get(inputs.get(0));
+            from = (ExpressionOperator)logToPhyMap.get(inputs.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Negative." ;
@@ -1631,7 +1631,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         ExpressionOperator from;
         
         if(inputs != null) {
-            from = (ExpressionOperator)LogToPhyMap.get(inputs.get(0));
+            from = (ExpressionOperator)logToPhyMap.get(inputs.get(0));
         } else {
             int errCode = 2051;
             String msg = "Did not find a predecessor for Null." ;
@@ -1642,7 +1642,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         physOp.setOperandType(op.getOperand().getType());
         currentPlan.add(physOp);
 
-        LogToPhyMap.put(op, physOp);
+        logToPhyMap.put(op, physOp);
 
         
         ((POIsNull) physOp).setExpr(from);
@@ -1665,9 +1665,9 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         physOp.setResultType(op.getType());
         currentPlan.add(physOp);
 
-        LogToPhyMap.put(op, physOp);
+        logToPhyMap.put(op, physOp);
 
-        ExpressionOperator from = (ExpressionOperator) LogToPhyMap.get(op
+        ExpressionOperator from = (ExpressionOperator) logToPhyMap.get(op
                 .getMap());
         try {
             currentPlan.connect(from, physOp);
@@ -1686,8 +1686,8 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 .getNextNodeId(scope)), op.getRequestedParallelism());
         currentPlan.add(physOp);
 
-        LogToPhyMap.put(op, physOp);
-        ExpressionOperator from = (ExpressionOperator) LogToPhyMap.get(op
+        logToPhyMap.put(op, physOp);
+        ExpressionOperator from = (ExpressionOperator) logToPhyMap.get(op
                 .getExpression());
         physOp.setResultType(op.getType());
         FuncSpec lfSpec = op.getLoadFuncSpec();
@@ -1711,13 +1711,13 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             poLimit.setResultType(limit.getType());
             poLimit.setLimit(limit.getLimit());
             currentPlan.add(poLimit);
-            LogToPhyMap.put(limit, poLimit);
+            logToPhyMap.put(limit, poLimit);
 
             List<LogicalOperator> op = limit.getPlan().getPredecessors(limit);
 
             PhysicalOperator from;
             if(op != null) {
-                from = LogToPhyMap.get(op.get(0));
+                from = logToPhyMap.get(op.get(0));
             } else {
                 int errCode = 2051;
                 String msg = "Did not find a predecessor for Limit." ;
@@ -1739,11 +1739,11 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
                 .getNextNodeId(scope)), op.getRequestedParallelism());
         currentPlan.add(physOp);
         physOp.setResultType(op.getType());
-        LogToPhyMap.put(op, physOp);
+        logToPhyMap.put(op, physOp);
         List<LogicalOperator> ops = op.getInputs();
 
         for (LogicalOperator l : ops) {
-            PhysicalOperator from = LogToPhyMap.get(l);
+            PhysicalOperator from = logToPhyMap.get(l);
             try {
                 currentPlan.connect(from, physOp);
             } catch (PlanException e) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POForEach.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POForEach.java
index 159f9baae..2d68266ae 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POForEach.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POForEach.java
@@ -69,7 +69,7 @@ public class POForEach extends PhysicalOperator {
     //This holds the outputs given out by the input expressions of any datatype
     protected Object [] bags = null;
     
-    //This is the template whcih contains tuples and is flattened out in CreateTuple() to generate the final output
+    //This is the template whcih contains tuples and is flattened out in createTuple() to generate the final output
     protected Object[] data = null;
     
     // store result types of the plan leaves
@@ -333,8 +333,8 @@ public class POForEach extends PhysicalOperator {
                     
                 }
                 if(reporter!=null) reporter.progress();
-                //CreateTuple(data);
-                res.result = CreateTuple(data);
+                //createTuple(data);
+                res.result = createTuple(data);
                 res.returnStatus = POStatus.STATUS_OK;
                 return res;
             } else {
@@ -344,7 +344,7 @@ public class POForEach extends PhysicalOperator {
                     if(its[index] != null && isToBeFlattenedArray[index]) {
                         if(its[index].hasNext()) {
                             data[index] =  its[index].next();
-                            res.result = CreateTuple(data);
+                            res.result = createTuple(data);
                             res.returnStatus = POStatus.STATUS_OK;
                             return res;
                         }
@@ -370,7 +370,7 @@ public class POForEach extends PhysicalOperator {
      * @param data array that is the template for the final flattened tuple
      * @return the final flattened tuple
      */
-    protected Tuple CreateTuple(Object[] data) throws ExecException {
+    protected Tuple createTuple(Object[] data) throws ExecException {
         Tuple out =  mTupleFactory.newTuple();
         for(int i = 0; i < data.length; ++i) {
             Object in = data[i];
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/util/operatorHelper.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/util/operatorHelper.java
deleted file mode 100644
index d97bdb802..000000000
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/util/operatorHelper.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.pig.backend.hadoop.executionengine.physicalLayer.util;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.pig.data.DataType;
-
-public class operatorHelper {
-    public static int numTypes(){
-        byte[] types = genAllTypes();
-        return types.length;
-    }
-    public static byte[] genAllTypes(){
-        byte[] types = { DataType.BAG, DataType.BOOLEAN, DataType.BYTEARRAY, DataType.CHARARRAY, 
-                DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG, DataType.MAP, DataType.TUPLE};
-        return types;
-    }
-    
-    private static String[] genAllTypeNames(){
-        String[] names = { "BAG", "BOOLEAN", "BYTEARRAY", "CHARARRAY", "DOUBLE", "FLOAT", "INTEGER", "LONG", 
-                "MAP", "TUPLE" };
-        return names;
-    }
-    
-    public static Map<Byte, String> genTypeToNameMap(){
-        byte[] types = genAllTypes();
-        String[] names = genAllTypeNames();
-        Map<Byte,String> ret = new HashMap<Byte, String>();
-        for(int i=0;i<types.length;i++){
-            ret.put(types[i], names[i]);
-        }
-        return ret;
-    }
-}
diff --git a/src/org/apache/pig/backend/local/executionengine/physicalLayer/LocalLogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/local/executionengine/physicalLayer/LocalLogToPhyTranslationVisitor.java
index 96480c490..54d7a1c56 100644
--- a/src/org/apache/pig/backend/local/executionengine/physicalLayer/LocalLogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/local/executionengine/physicalLayer/LocalLogToPhyTranslationVisitor.java
@@ -68,7 +68,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
     }
     
     public Map<LogicalOperator, PhysicalOperator> getLogToPhyMap() {
-	return LogToPhyMap;
+	return logToPhyMap;
     }
     
     @Override
@@ -123,7 +123,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
             currentPlan.add(physOp);
 
             try {
-                currentPlan.connect(LogToPhyMap.get(lo), physOp);
+                currentPlan.connect(logToPhyMap.get(lo), physOp);
                 currentPlan.connect(physOp, poc);
             } catch (PlanException e) {
                 log.error("Invalid physical operators in the physical plan"
@@ -132,7 +132,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
             }
             
         }
-        LogToPhyMap.put(cg, poc);
+        logToPhyMap.put(cg, poc);
     }
     
     @Override
@@ -192,7 +192,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
             currentPlan.add(physOp);
 
             try {
-                currentPlan.connect(LogToPhyMap.get(lo), physOp);
+                currentPlan.connect(logToPhyMap.get(lo), physOp);
                 currentPlan.connect(physOp, poc);
             } catch (PlanException e) {
                 log.error("Invalid physical operators in the physical plan"
@@ -239,7 +239,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
         fe.setResultType(DataType.BAG);
 
         currentPlan.add(fe);
-        LogToPhyMap.put(join, fe);
+        logToPhyMap.put(join, fe);
         try {
             currentPlan.connect(poc, fe);
         } catch (PlanException e) {
@@ -255,10 +255,10 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
         PhysicalOperator physOp = new POSplit(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), split.getRequestedParallelism());
         
-        LogToPhyMap.put(split, physOp);
+        logToPhyMap.put(split, physOp);
 
         currentPlan.add(physOp);
-        PhysicalOperator from = LogToPhyMap.get(split.getPlan()
+        PhysicalOperator from = logToPhyMap.get(split.getPlan()
                 .getPredecessors(split).get(0));
         try {
             currentPlan.connect(from, physOp);
@@ -273,7 +273,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
 	String scope = split.getOperatorKey().scope;
         PhysicalOperator physOp = new POSplitOutput(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), split.getRequestedParallelism());
-        LogToPhyMap.put(split, physOp);
+        logToPhyMap.put(split, physOp);
 
         currentPlan.add(physOp);
         currentPlans.push(currentPlan);
@@ -287,7 +287,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
         ((POSplitOutput) physOp).setPlan((PhysicalPlan) currentPlan);
         currentPlan = currentPlans.pop();
         currentPlan.add(physOp);
-        PhysicalOperator from = LogToPhyMap.get(split.getPlan()
+        PhysicalOperator from = logToPhyMap.get(split.getPlan()
                 .getPredecessors(split).get(0));
         try {
             currentPlan.connect(from, physOp);
@@ -304,11 +304,11 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
                 .getNextNodeId(scope)), stream.getExecutableManager(), 
                 stream.getStreamingCommand(), pc.getProperties());
         currentPlan.add(poStream);
-        LogToPhyMap.put(stream, poStream);
+        logToPhyMap.put(stream, poStream);
         
         List<LogicalOperator> op = stream.getPlan().getPredecessors(stream);
 
-        PhysicalOperator from = LogToPhyMap.get(op.get(0));
+        PhysicalOperator from = logToPhyMap.get(op.get(0));
         try {
             currentPlan.connect(from, poStream);
         } catch (PlanException e) {
@@ -323,12 +323,12 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
         String scope = cross.getOperatorKey().scope;
         
         POCross pocross = new POCross(new OperatorKey(scope, nodeGen.getNextNodeId(scope)));
-        LogToPhyMap.put(cross, pocross);
+        logToPhyMap.put(cross, pocross);
         currentPlan.add(pocross);
         
         
         for(LogicalOperator in : cross.getInputs()) {
-            PhysicalOperator from = LogToPhyMap.get(in);
+            PhysicalOperator from = logToPhyMap.get(in);
             try {
                 currentPlan.connect(from, pocross);
             } catch (PlanException e) {
@@ -363,7 +363,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
         }
         //store.setPc(pc);
         currentPlan.add(store);
-        PhysicalOperator from = LogToPhyMap.get(loStore
+        PhysicalOperator from = logToPhyMap.get(loStore
                 .getPlan().getPredecessors(loStore).get(0));
         
         POCounter counter = new POCounter(new OperatorKey(scope, nodeGen.getNextNodeId(scope)));
@@ -376,7 +376,7 @@ public class LocalLogToPhyTranslationVisitor extends LogToPhyTranslationVisitor
             String msg = "Invalid physical operators in the physical plan" ;
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG, e);
         }
-        LogToPhyMap.put(loStore, store);
+        logToPhyMap.put(loStore, store);
         
     }
 
diff --git a/src/org/apache/pig/pen/DerivedDataVisitor.java b/src/org/apache/pig/pen/DerivedDataVisitor.java
index ec28a1d3b..e83c1c6dc 100644
--- a/src/org/apache/pig/pen/DerivedDataVisitor.java
+++ b/src/org/apache/pig/pen/DerivedDataVisitor.java
@@ -190,7 +190,7 @@ public class DerivedDataVisitor extends LOVisitor {
 
         try {
             Collection<IdentityHashSet<Tuple>> eq = EquivalenceClasses
-                    .GetEquivalenceClasses(cg, derivedData);
+                    .getEquivalenceClasses(cg, derivedData);
             EqClasses.addAll(eq);
             OpToEqClasses.put(cg, eq);
         } catch (ExecException e) {
@@ -241,7 +241,7 @@ public class DerivedDataVisitor extends LOVisitor {
         derivedData.put(load, baseData.get(load));
 
         Collection<IdentityHashSet<Tuple>> eq = EquivalenceClasses
-                .GetEquivalenceClasses(load, derivedData);
+                .getEquivalenceClasses(load, derivedData);
         EqClasses.addAll(eq);
         OpToEqClasses.put(load, eq);
 
@@ -366,7 +366,7 @@ public class DerivedDataVisitor extends LOVisitor {
 
         try {
             Collection<IdentityHashSet<Tuple>> eq = EquivalenceClasses
-                    .GetEquivalenceClasses(op, derivedData);
+                    .getEquivalenceClasses(op, derivedData);
             EqClasses.addAll(eq);
             OpToEqClasses.put(op, eq);
         } catch (ExecException e) {
diff --git a/src/org/apache/pig/pen/EquivalenceClasses.java b/src/org/apache/pig/pen/EquivalenceClasses.java
index 38e6e8dad..186851855 100644
--- a/src/org/apache/pig/pen/EquivalenceClasses.java
+++ b/src/org/apache/pig/pen/EquivalenceClasses.java
@@ -40,27 +40,27 @@ import org.apache.pig.impl.util.IdentityHashSet;
 //These methods are used to generate equivalence classes given the operator name and the output from the operator
 //For example, it gives out 2 eq. classes for filter, one that passes the filter and one that doesn't
 public class EquivalenceClasses {
-    public static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(
+    public static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(
             LogicalOperator op, Map<LogicalOperator, DataBag> derivedData)
             throws ExecException {
         if (op instanceof LOCogroup)
-            return GetEquivalenceClasses((LOCogroup) op, derivedData);
+            return getEquivalenceClasses((LOCogroup) op, derivedData);
         else if (op instanceof LOForEach)
-            return GetEquivalenceClasses((LOForEach) op, derivedData);
+            return getEquivalenceClasses((LOForEach) op, derivedData);
         else if (op instanceof LOFilter)
-            return GetEquivalenceClasses((LOFilter) op, derivedData);
+            return getEquivalenceClasses((LOFilter) op, derivedData);
         else if (op instanceof LOSort)
-            return GetEquivalenceClasses((LOSort) op, derivedData);
+            return getEquivalenceClasses((LOSort) op, derivedData);
         else if (op instanceof LOSplit)
-            return GetEquivalenceClasses((LOSplit) op, derivedData);
+            return getEquivalenceClasses((LOSplit) op, derivedData);
         else if (op instanceof LOUnion)
-            return GetEquivalenceClasses((LOUnion) op, derivedData);
+            return getEquivalenceClasses((LOUnion) op, derivedData);
         else if (op instanceof LOLoad)
-            return GetEquivalenceClasses((LOLoad) op, derivedData);
+            return getEquivalenceClasses((LOLoad) op, derivedData);
             throw new RuntimeException("Unrecognized logical operator.");
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(LOLoad op,
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(LOLoad op,
             Map<LogicalOperator, DataBag> derivedData) {
         // Since its a load, all the tuples belong to a single equivalence class
         Collection<IdentityHashSet<Tuple>> equivClasses = new LinkedList<IdentityHashSet<Tuple>>();
@@ -79,7 +79,7 @@ public class EquivalenceClasses {
         return equivClasses;
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(
             LOCogroup op, Map<LogicalOperator, DataBag> derivedData)
             throws ExecException {
         Collection<IdentityHashSet<Tuple>> equivClasses = new LinkedList<IdentityHashSet<Tuple>>();
@@ -112,7 +112,7 @@ public class EquivalenceClasses {
         return equivClasses;
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(
             LOForEach op, Map<LogicalOperator, DataBag> derivedData) {
         Collection<IdentityHashSet<Tuple>> equivClasses = new LinkedList<IdentityHashSet<Tuple>>();
 
@@ -126,7 +126,7 @@ public class EquivalenceClasses {
         return equivClasses;
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(
             LOFilter op, Map<LogicalOperator, DataBag> derivedData) {
         Collection<IdentityHashSet<Tuple>> equivClasses = new LinkedList<IdentityHashSet<Tuple>>();
 
@@ -155,7 +155,7 @@ public class EquivalenceClasses {
 
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(LOSort op,
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(LOSort op,
             Map<LogicalOperator, DataBag> derivedData) {
         //We don't create any eq. class for sort
         IdentityHashSet<Tuple> temp = new IdentityHashSet<Tuple>();
@@ -164,13 +164,13 @@ public class EquivalenceClasses {
         return output;
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(LOSplit op,
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(LOSplit op,
             Map<LogicalOperator, DataBag> derivedData) {
         throw new RuntimeException(
                 "LOSplit not supported yet in example generator.");
     }
 
-    static Collection<IdentityHashSet<Tuple>> GetEquivalenceClasses(LOUnion op,
+    static Collection<IdentityHashSet<Tuple>> getEquivalenceClasses(LOUnion op,
             Map<LogicalOperator, DataBag> derivedData) {
 
         // make one equivalence class per input relation
diff --git a/src/org/apache/pig/pen/ExampleGenerator.java b/src/org/apache/pig/pen/ExampleGenerator.java
index 830be03fc..4095dc5bf 100644
--- a/src/org/apache/pig/pen/ExampleGenerator.java
+++ b/src/org/apache/pig/pen/ExampleGenerator.java
@@ -139,9 +139,9 @@ public class ExampleGenerator {
                     + e.getMessage());
         }
 
-        // DisplayExamples.PrintSimple(plan.getLeaves().get(0),
+        // DisplayExamples.printSimple(plan.getLeaves().get(0),
         // derivedData.derivedData);
-        System.out.println(DisplayExamples.PrintTabular(plan,
+        System.out.println(DisplayExamples.printTabular(plan,
                 derivedData.derivedData));
         return derivedData.derivedData;
     }
@@ -232,4 +232,4 @@ public class ExampleGenerator {
         return plan;
 
     }
-}
\ No newline at end of file
+}
diff --git a/src/org/apache/pig/pen/util/DisplayExamples.java b/src/org/apache/pig/pen/util/DisplayExamples.java
index 87b7a3199..94f877767 100644
--- a/src/org/apache/pig/pen/util/DisplayExamples.java
+++ b/src/org/apache/pig/pen/util/DisplayExamples.java
@@ -35,10 +35,10 @@ import org.apache.pig.impl.util.IdentityHashSet;
 //Class containing some generic printing methods to print example data in a simple/tabular form
 public class DisplayExamples {
 
-    public static StringBuffer Result = new StringBuffer();
+    //public static StringBuffer result = new StringBuffer();
     public static final int MAX_DATAATOM_LENGTH = 25;
 
-    static void PrintMetrics(
+    static void printMetrics(
             LogicalOperator op,
             Map<LogicalOperator, DataBag> derivedData,
             Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses) {
@@ -61,27 +61,27 @@ public class DisplayExamples {
                         OperatorToEqClasses, true) + "\n");
     }
 
-    public static String PrintTabular(LogicalPlan lp,
+    public static String printTabular(LogicalPlan lp,
             Map<LogicalOperator, DataBag> exampleData) {
         StringBuffer output = new StringBuffer();
 
         LogicalOperator currentOp = lp.getLeaves().get(0);
-        PrintTabular(currentOp, exampleData, output);
+        printTabular(currentOp, exampleData, output);
         return output.toString();
     }
 
-    static void PrintTabular(LogicalOperator op,
+    static void printTabular(LogicalOperator op,
             Map<LogicalOperator, DataBag> exampleData, StringBuffer output) {
         DataBag bag = exampleData.get(op);
 
         List<LogicalOperator> inputs = op.getPlan().getPredecessors(op);
         if (inputs != null) { // to avoid an exception when op == LOLoad
             for (LogicalOperator Op : inputs) {
-                PrintTabular(Op, exampleData, output);
+                printTabular(Op, exampleData, output);
             }
         }
         if (op.getAlias() != null) {
-            // PrintTable(op, bag, output);
+            // printTable(op, bag, output);
             try {
                 DisplayTable(MakeArray(op, bag), op, bag, output);
             } catch (FrontendException e) {
@@ -95,18 +95,18 @@ public class DisplayExamples {
 
     }
 
-    public static void PrintSimple(LogicalOperator op,
+    public static void printSimple(LogicalOperator op,
             Map<LogicalOperator, DataBag> exampleData) {
         DataBag bag = exampleData.get(op);
 
         List<LogicalOperator> inputs = op.getPlan().getPredecessors(op);
         if (inputs != null) {
             for (LogicalOperator lOp : inputs) {
-                PrintSimple(lOp, exampleData);
+                printSimple(lOp, exampleData);
             }
         }
         if (op.getAlias() != null) {
-            // PrintTable(op, bag, output);
+            // printTable(op, bag, output);
             // DisplayTable(MakeArray(op, bag), op, bag, output);
             System.out.println(op.getAlias() + " : " + bag);
         }
diff --git a/test/findbugsExcludeFile.xml b/test/findbugsExcludeFile.xml
index 5b4b88d67..5b3e23d37 100644
--- a/test/findbugsExcludeFile.xml
+++ b/test/findbugsExcludeFile.xml
@@ -13,7 +13,10 @@
         <Class name="org.apache.pig.tools.parameters.JavaCharStream" />
     </Match>
     <Match>
-        <Class name="org.apache.pig.tools.parameters.Token*" />
+        <Class name="org.apache.pig.tools.parameters.Token" />
+    </Match>
+    <Match>
+        <Class name="org.apache.pig.tools.parameters.TokenMgrError" />
     </Match>
     <Match>
         <Class name="org.apache.pig.tools.parameters.ParamLoader" />
@@ -69,4 +72,11 @@
         <Bug pattern="CN_IDIOM_NO_SUPER_CALL" />
     </Match>
 
+    <Match>
+        <Class name="org.apache.pig.impl.util.WrappedIOException" />
+        <Bug pattern="NM_CLASS_NOT_EXCEPTION" />
+    </Match>
+    
+
+
 </FindBugsFilter>
