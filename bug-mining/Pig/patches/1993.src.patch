diff --git a/test/e2e/pig/tests/cmdline.conf b/test/e2e/pig/tests/cmdline.conf
index 14593731c..72769fa0e 100644
--- a/test/e2e/pig/tests/cmdline.conf
+++ b/test/e2e/pig/tests/cmdline.conf
@@ -44,7 +44,7 @@ $cfg = {
 			'pig' => q\ 
 A= load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
 describe A;\,
-                        'expected_out_regex' => "A: {name: bytearray,age: bytearray,gpa: bytearray}",
+                        'expected_out_regex' => "A: \{name: bytearray,age: bytearray,gpa: bytearray}",
 			},
                         #JIRA[PIG-19], Commented out until fixed.
 #			{
@@ -52,7 +52,7 @@ describe A;\,
 #			'pig' => q\ 
 #A=load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name, age, gpa);
 #describe A;\,
-#                        'expected_out_regex' => "A: {name: bytearray,age: bytearray,gpa: bytearray}",
+#                        'expected_out_regex' => "A: \{name: bytearray,age: bytearray,gpa: bytearray}",
 #			},
                         #JIRA[PIG-373]
 			{
@@ -60,7 +60,7 @@ describe A;\,
 			'pig' => q\
 A= load ':INPATH:/singlefile/studenttab10k' using PigStorage() as (name:chararray, age:int, gpa:double);
 describe A;\,
-                        'expected_out_regex' => "A: {name: chararray,age: int,gpa: double}",
+                        'expected_out_regex' => "A: \{name: chararray,age: int,gpa: double}",
 			},
 #********************************************************
 #QUESTION: S/B SQL VERIFIER for DUMP statement?
@@ -85,7 +85,7 @@ describe A;\,
 			'pig' => q\ 
 A = load ':INPATH:/singlefile/studenttabcomplex10k' using PigStorage() as (m:map[],x,y);
 describe A;\,
-                        'expected_out_regex' =>"A: {m: map\\[\\],x: bytearray,y: bytearray}",
+                        'expected_out_regex' =>"A: \{m: map\\[\\],x: bytearray,y: bytearray}",
 			},
 
 			#JIRA[PIG-373]
@@ -100,7 +100,7 @@ describe B;\,
                         #Expect
                         # A : { m:map, x:bytearray, y:bytearray } 
                         # B : { m :map } 
-                         'expected_out_regex' => "A: {m: map\\[\\],x: bytearray,y: bytearray}\nB: {m: map\\[\\]}",
+                         'expected_out_regex' => "A: \{m: map\\[\\],x: bytearray,y: bytearray}\nB: \{m: map\\[\\]}",
 			},
 			#JIRA[PIG-373]
                         #JIRA[PIG-405]
@@ -114,7 +114,7 @@ describe B;\,
                         #Expect
                         # A : { m:map, x:bytearray, y:bytearray } 
                         # B : { m :map } 
-                         'expected_out_regex' => "A: {m: map\\[\\],x: bytearray,y: bytearray}\nB: {m: map\\[\\]}",
+                         'expected_out_regex' => "A: \{m: map\\[\\],x: bytearray,y: bytearray}\nB: \{m: map\\[\\]}",
 			},
 			#JIRA[PIG-373]
                         #JIRA[PIG-405]
@@ -128,13 +128,13 @@ describe A;\,
                         #Expect
                         # A : { m:map, x:bytearray, y:bytearray } 
                         # B : { m :map } 
-                         'expected_out_regex' => "B: {m: map\\[\\]}\nA: {m: map\\[\\],x: bytearray,y: bytearray}",
+                         'expected_out_regex' => "B: \{m: map\\[\\]}\nA: \{m: map\\[\\],x: bytearray,y: bytearray}",
 			},
                         {
 			'num' => 14,
 			'pig' => q\A = load ':INPATH:/singlefile/allscalar10k' using PigStorage() as (name:chararray, age:int, gpa:double, instate:boolean);
 describe A;\,
-                        'expected_out_regex' => "A: {name: chararray,age: int,gpa: double,instate: boolean}",
+                        'expected_out_regex' => "A: \{name: chararray,age: int,gpa: double,instate: boolean}",
 			},
 
                         #JIRA[PIG-379]
@@ -150,12 +150,12 @@ describe C;
 D= group C by name;
 describe D;\,
                         # EXPECT
-                        # A: {name: chararray,age: integer,gpa: double}
-                        # B: {name: chararray,age: integer}
-                        # C: {name: chararray,age: integer}
-                        # D: {group: chararray C: {name: chararray,age: integer}}
+                        # A: \{name: chararray,age: integer,gpa: double}
+                        # B: \{name: chararray,age: integer}
+                        # C: \{name: chararray,age: integer}
+                        # D: \{group: chararray C: \{name: chararray,age: integer}}
                         'expected_out_regex' => 
-"A: {name: chararray,age: int,gpa: float}\nB: {name: chararray,age: int}\nC: {name: chararray,age: int}\nD: {group: chararray,C: {\\(name: chararray,age: int\\)}}",
+"A: \{name: chararray,age: int,gpa: float}\nB: \{name: chararray,age: int}\nC: \{name: chararray,age: int}\nD: \{group: chararray,C: \{\\(name: chararray,age: int\\)}}",
 
 			},
 			{
@@ -170,12 +170,12 @@ describe B;
 describe C;
 describe D;\,
                         # EXPECT
-                        # A: {name: chararray,age: integer,gpa: double}
-                        # B: {name: chararray,age: integer}
-                        # C: {name: chararray,age: integer}
-                        # D: {group: chararray C: {name: chararray,age: integer}}
+                        # A: \{name: chararray,age: integer,gpa: double}
+                        # B: \{name: chararray,age: integer}
+                        # C: \{name: chararray,age: integer}
+                        # D: \{group: chararray C: \{name: chararray,age: integer}}
                         'expected_out_regex' => 
-"A: {name: chararray,age: int,gpa: float}\nB: {name: chararray,age: int}\nC: {name: chararray,age: int}\nD: {group: chararray,C: {\\(name: chararray,age: int\\)}}\n",
+"A: \{name: chararray,age: int,gpa: float}\nB: \{name: chararray,age: int}\nC: \{name: chararray,age: int}\nD: \{group: chararray,C: \{\\(name: chararray,age: int\\)}}\n",
 
 			},
 			{
@@ -190,12 +190,12 @@ describe C;
 describe B;
 describe A;\,
                         # EXPECT
-                        # A: {name: chararray,age: integer,gpa: double}
-                        # B: {name: chararray,age: integer}
-                        # C: {name: chararray,age: integer}
-                        # D: {group: chararray C: {name: chararray,age: integer}}
+                        # A: \{name: chararray,age: integer,gpa: double}
+                        # B: \{name: chararray,age: integer}
+                        # C: \{name: chararray,age: integer}
+                        # D: \{group: chararray C: \{name: chararray,age: integer}}
                         'expected_out_regex' => 
-"D: {group: chararray,C: {\\(name: chararray,age: int\\)}}\nC: {name: chararray,age: int}\nB: {name: chararray,age: int}\nA: {name: chararray,age: int,gpa: float}",
+"D: \{group: chararray,C: \{\\(name: chararray,age: int\\)}}\nC: \{name: chararray,age: int}\nB: \{name: chararray,age: int}\nA: \{name: chararray,age: int,gpa: float}",
 
 			},
 			{
@@ -211,10 +211,10 @@ describe C;
 describe B;
 describe A;\,
                         # EXPECT
-                        # A: {name: chararray,age: integer,gpa: double}
-                        # B: {name: chararray,age: integer}
-                        # C: {name: chararray,age: integer}
-                        # D: {group: chararray C: {name: chararray,age: integer}}
+                        # A: \{name: chararray,age: integer,gpa: double}
+                        # B: \{name: chararray,age: integer}
+                        # C: \{name: chararray,age: integer}
+                        # D: \{group: chararray C: \{name: chararray,age: integer}}
                         'expected_err_regex' => "ERROR 1003: Unable to find an operator for alias X" 
 
 			},
@@ -227,8 +227,8 @@ C = COGROUP A BY name, B BY name;
 D = FOREACH C GENERATE group, flatten((not IsEmpty(A) ? A : (bag{tuple(chararray, int, float)}){(null, null, null)})), flatten((not IsEmpty(B) ? B : (bag{tuple(chararray, int, chararray, float)}){(null,null,null, null)}));
 describe D;\,
                         # EXPECT
-                        # D: {group: chararray,A::name: chararray,A::age: int,A::gpa: float,B::name: chararray,B::age: int,B::registration: chararray,B::contributions: float}
-                        'expected_out_regex' => "D: {group: chararray,A::name: chararray,A::age: int,A::gpa: float,B::name: chararray,B::age: int,B::registration: chararray,B::contributions: float}" 
+                        # D: \{group: chararray,A::name: chararray,A::age: int,A::gpa: float,B::name: chararray,B::age: int,B::registration: chararray,B::contributions: float}
+                        'expected_out_regex' => "D: \{group: chararray,A::name: chararray,A::age: int,A::gpa: float,B::name: chararray,B::age: int,B::registration: chararray,B::contributions: float}" 
 
 			}
 		],
@@ -330,7 +330,7 @@ B = group A by name;
 C = foreach B { D = distinct A.age; generate COUNT(D), group;}
 describe C::D;
 \,
-                          ,'expected_out_regex' => "D: {age: bytearray}"
+                          ,'expected_out_regex' => "D: \{age: bytearray}"
 
                       },{
 # 2 Test that a nested foreach gives instant feedback: as part of execution: when we run this foreach statement, we will dump the schema for the nested alias 	 	 
@@ -342,7 +342,7 @@ B = group A by name;
 C = foreach B { D = distinct A.age; E= filter D by age > 1000; generate COUNT(E), group;}
 describe C;
 \,
-                          ,'expected_out_regex' => "C: {long,group: bytearray}"
+                          ,'expected_out_regex' => "C: \{long,group: bytearray}"
 
 
                       },{
@@ -358,7 +358,7 @@ B = group A by name;
 C = foreach B { D = distinct A.$1; generate COUNT(D), group;}
 describe C::D;
 \,
-                          ,'expected_out_regex' => "D: {age: bytearray}"
+                          ,'expected_out_regex' => "D: \{age: bytearray}"
 
 
                       },
diff --git a/test/e2e/pig/tests/macro.conf b/test/e2e/pig/tests/macro.conf
index e73bdec37..bbd66569e 100644
--- a/test/e2e/pig/tests/macro.conf
+++ b/test/e2e/pig/tests/macro.conf
@@ -309,7 +309,7 @@ $cfg = {
                      b = test(a);
                      describe b;\,
           'rc' => 0,
-          'expected_out_regex'=> "b: {name: chararray,age: int,gpa: double}"
+          'expected_out_regex'=> "b: \{name: chararray,age: int,gpa: double}"
         },
         {
           # macro that does change the schema
@@ -322,7 +322,7 @@ $cfg = {
                      b = test(a);
                      describe b;\,
           'rc' => 0,
-          'expected_out_regex'=> "b: {name: chararray}"
+          'expected_out_regex'=> "b: \{name: chararray}"
         }
       ]
     },
diff --git a/test/e2e/pig/tests/nightly.conf b/test/e2e/pig/tests/nightly.conf
index 4eb3ae10a..2c654dcf8 100644
--- a/test/e2e/pig/tests/nightly.conf
+++ b/test/e2e/pig/tests/nightly.conf
@@ -2445,7 +2445,7 @@ store A into ':OUTPATH:';\,
 A = load 'sample' as (line:chararray);
 B = foreach A generate flatten(STRSPLIT(line)) as (i0, i1, i2);
 describe B;\,
-                        'expected_out_regex'  => 'B: {i0: bytearray,i1: bytearray,i2: bytearray}',
+                        'expected_out_regex'  => 'B: \{i0: bytearray,i1: bytearray,i2: bytearray}',
 			},
 		],
 		},
@@ -4588,14 +4588,14 @@ describe T4;
 describe T5;
 describe T6;
 ?
-                         ,'expected_out_regex'  => 'B1: {{int}}'
-                         ,'expected_out_regex'  => 'B3: {{int}}'
-                         ,'expected_out_regex'  => 'T1: {org.apache.pig.builtin.totuple_id_.*: (intnum1000: int,id: int,intnum5: int)}'
-                         ,'expected_out_regex'  => 'T2: {org.apache.pig.builtin.totuple_id_.*: (intnum1000: int,id: int,intnum5: int)}'
-                         ,'expected_out_regex'  => 'T3: {org.apache.pig.builtin.totuple_intnum1000.*: (intnum1000: int,intnum1000: int,intnum1000: int)}'
-                         ,'expected_out_regex'  => 'T4: {{int},org.apache.pig.builtin.totuple_intnum100.*: (intnum100: int,intnum: int,longnum: long),floatnum: float,doublenum: double}'
-                         ,'expected_out_regex'  => 'T5: {intnum1000: int,id: int,org.apache.pig.builtin.totuple_intnum100.*: (intnum5: int,intnum100: int,intnum: int).*{NULL}.*doublenum: double}'
-                         ,'expected_out_regex'  => "T6: {intnum1000: int,org.apache.pig.builtin.totuple_intnum1000.*: \\(intnum1000: int,intnum1000: int,intnum1000: int\\),{\\(int\\)},duplicate: int}"
+                         ,'expected_out_regex'  => 'B1: \{\{int}}'
+                         ,'expected_out_regex'  => 'B3: \{\{int}}'
+                         ,'expected_out_regex'  => 'T1: \{org.apache.pig.builtin.totuple_id_.*: (intnum1000: int,id: int,intnum5: int)}'
+                         ,'expected_out_regex'  => 'T2: \{org.apache.pig.builtin.totuple_id_.*: (intnum1000: int,id: int,intnum5: int)}'
+                         ,'expected_out_regex'  => 'T3: \{org.apache.pig.builtin.totuple_intnum1000.*: (intnum1000: int,intnum1000: int,intnum1000: int)}'
+                         ,'expected_out_regex'  => 'T4: \{\{int},org.apache.pig.builtin.totuple_intnum100.*: (intnum100: int,intnum: int,longnum: long),floatnum: float,doublenum: double}'
+                         ,'expected_out_regex'  => 'T5: \{intnum1000: int,id: int,org.apache.pig.builtin.totuple_intnum100.*: (intnum5: int,intnum100: int,intnum: int).*{NULL}.*doublenum: double}'
+                         ,'expected_out_regex'  => "T6: \{intnum1000: int,org.apache.pig.builtin.totuple_intnum1000.*: \\(intnum1000: int,intnum1000: int,intnum1000: int\\),\{\\(int\\)},duplicate: int}"
                         }, {
 # TEST : bag of mixed data types
 # TEST : Order 
@@ -4614,11 +4614,11 @@ describe E;
 describe F;
 describe G;
 ?
-                         ,'expected_out_regex'  => 'C: {{\\(NULL\\)}}'
-                         ,'expected_out_regex'  => 'D: {{\\(int\\)}}'
-                         ,'expected_out_regex'  => 'E: {{\\(float\\)}}'
-                         ,'expected_out_regex'  => 'F: {{\\(long\\)}}'
-                         ,'expected_out_regex'  => 'G: {{\\(double\\)}}'
+                         ,'expected_out_regex'  => 'C: \{\{\\(NULL\\)}}'
+                         ,'expected_out_regex'  => 'D: \{\{\\(int\\)}}'
+                         ,'expected_out_regex'  => 'E: \{\{\\(float\\)}}'
+                         ,'expected_out_regex'  => 'F: \{\{\\(long\\)}}'
+                         ,'expected_out_regex'  => 'G: \{\{\\(double\\)}}'
 
 			}, {
 # TEST : TOBAG/TOTUPLE with simple types
diff --git a/test/e2e/pig/tests/turing_jython.conf b/test/e2e/pig/tests/turing_jython.conf
index 414c1de58..6f1f1bc15 100644
--- a/test/e2e/pig/tests/turing_jython.conf
+++ b/test/e2e/pig/tests/turing_jython.conf
@@ -508,7 +508,7 @@ store F into '$out2';
 result = P.bind({'in1':input1, 'in2':input2, 'max':maximum, 'out1':output1, 'out2':output2 }).describe('A');
 \
                        ,'rc'=> 0
-                       ,'expected_out_regex' => "A:.*{name:.*bytearray,age:.*bytearray,gpa:.*bytearray}"
+                       ,'expected_out_regex' => "A:.*\{name:.*bytearray,age:.*bytearray,gpa:.*bytearray}"
 	}, {
                 # describe() on an undefined alias 
 		'num' => 4
