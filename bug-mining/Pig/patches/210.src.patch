diff --git a/src/org/apache/pig/impl/logicalLayer/CastFinder.java b/src/org/apache/pig/impl/logicalLayer/CastFinder.java
new file mode 100644
index 000000000..83dfd4685
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/CastFinder.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.logicalLayer;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.ArrayList;
+
+import org.apache.pig.FuncSpec;
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor to track the casts in a plan.
+ */
+public class CastFinder extends LOVisitor {
+
+    List<LOCast> mCastList = new ArrayList<LOCast>();
+
+    /**
+     * 
+     * @param plan
+     *            logical plan to query the presence of UDFs
+     */
+    public CastFinder(LogicalPlan plan) {
+        super(plan, new DepthFirstWalker<LogicalOperator, LogicalPlan>(plan));
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.
+     * logicalLayer.LOUserFunc)
+     */
+    @Override
+    protected void visit(LOCast cast) throws VisitorException {
+        mCastList.add(cast);
+    }
+
+    /**
+     * 
+     * @return list of casts found in the plan
+     */
+    public List<LOCast> getCastList() {
+        return mCastList;
+    }
+
+    /**
+     * 
+     * @return set of casts found in the plan
+     */
+    public Set<LOCast> getCastSet() {
+        return new HashSet<LOCast>(mCastList);
+    }
+
+    /**
+     * 
+     * @return true if the plan contained any Casts; false otherwise
+     */
+    public boolean foundAnyCast() {
+        return (mCastList.size() == 0 ? false : true);
+    }
+
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index aee10cf2c..a3efd2de8 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -557,7 +557,7 @@ public class LOCogroup extends LogicalOperator {
         MultiMap<LogicalOperator, LogicalPlan> groupByPlans = getGroupByPlans();
         
         boolean groupByAdded = false;
-        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
         List<Pair<Integer, Integer>> removedFields = new ArrayList<Pair<Integer, Integer>>();
         
         for(int inputNum = 0; (inputNum < predecessors.size()) && (!groupByAdded); ++inputNum) {
@@ -575,10 +575,22 @@ public class LOCogroup extends LogicalOperator {
                 
                 if(leaves.get(0) instanceof LOProject) {
                     //find out if this project is a chain of projects
-                    LOProject topProject = LogicalPlan.chainOfProjects(predecessorPlan);
-                    if(topProject != null) {
-                        inputColumn = topProject.getCol();
-                        mapFields.put(0, new Pair<Integer, Integer>(inputNum, inputColumn));
+                    Pair<LOProject, LOCast> pair = LogicalPlan.chainOfProjects(predecessorPlan);
+                    if (pair != null) {
+                        LOProject topProject = pair.first;
+                        if (topProject != null) {
+                            inputColumn = topProject.getCol();
+                            LOCast cast = pair.second;
+                            if (cast != null) {
+                                mapFields.put(0, 
+                                        new ProjectionMap.Column(
+                                                new Pair<Integer, Integer>(inputNum, inputColumn), true, cast.getType()
+                                        )
+                                );
+                            } else {
+                                mapFields.put(0, new ProjectionMap.Column(new Pair<Integer, Integer>(inputNum, inputColumn)));
+                            }
+                        }
                     }
                 } else {
                     groupByAdded = true;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCross.java b/src/org/apache/pig/impl/logicalLayer/LOCross.java
index d44092fb2..6199cc656 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCross.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCross.java
@@ -214,7 +214,7 @@ public class LOCross extends LogicalOperator {
             return mProjectionMap;
         }
         
-        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
         List<Integer> addedFields = new ArrayList<Integer>();
         boolean[] unknownSchema = new boolean[predecessors.size()];
         boolean anyUnknownInputSchema = false;
@@ -239,7 +239,7 @@ public class LOCross extends LogicalOperator {
             } else {
                 unknownSchema[inputNum] = false;
                 for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
-                    mapFields.put(outputColumnNum++, new Pair<Integer, Integer>(inputNum, inputColumn));
+                    mapFields.put(outputColumnNum++, new ProjectionMap.Column(new Pair<Integer, Integer>(inputNum, inputColumn)));
                 }
             }
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
index 60a49fecf..cb2e24ff0 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
@@ -302,7 +302,7 @@ public class LOFRJoin extends LogicalOperator {
             return mProjectionMap;
         }
         
-        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
         List<Integer> addedFields = new ArrayList<Integer>();
         boolean[] unknownSchema = new boolean[predecessors.size()];
         boolean anyUnknownInputSchema = false;
@@ -327,7 +327,8 @@ public class LOFRJoin extends LogicalOperator {
             } else {
                 unknownSchema[inputNum] = false;
                 for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
-                    mapFields.put(outputColumnNum++, new Pair<Integer, Integer>(inputNum, inputColumn));
+                    mapFields.put(outputColumnNum++, 
+                            new ProjectionMap.Column(new Pair<Integer, Integer>(inputNum, inputColumn)));
                 }
             }
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 3e1e94573..6900d377b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -492,7 +492,7 @@ public class LOForEach extends LogicalOperator {
         List<LogicalPlan> foreachPlans = getForEachPlans();
         List<Boolean> flattenList = getFlatten();
         
-        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
         List<Integer> addedFields = new ArrayList<Integer>();
         int outputColumn = 0;
         
@@ -506,14 +506,19 @@ public class LOForEach extends LogicalOperator {
             
             int inputColumn = -1;
             boolean mapped = false;
+            LOCast cast = null;
             
             
             if(leaves.get(0) instanceof LOProject || leaves.get(0) instanceof LOCast) {
                 //find out if this project is a chain of projects
-                LOProject topProject = LogicalPlan.chainOfProjects(foreachPlan);
-                if(topProject != null) {
-                    inputColumn = topProject.getCol();
+                Pair<LOProject, LOCast> pair = LogicalPlan.chainOfProjects(foreachPlan);
+                if (pair != null) {
+                    LOProject topProject = pair.first;
+                    cast = pair.second;
+                    if (topProject != null) {
+                        inputColumn = topProject.getCol();
                         mapped = true;
+                    }
                 }
             }
             
@@ -567,7 +572,17 @@ public class LOForEach extends LogicalOperator {
                         for(int j = 0; j < innerSchema.size(); ++j) {
                             if(mapped) {
                                 //map each flattened column to the original column
-                                mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                                if (cast != null) {
+                                    mapFields.put(outputColumn++,
+                                            new ProjectionMap.Column(
+                                                    new Pair<Integer, Integer>(0, inputColumn), true, cast.getType()
+                                            )
+                                    );
+                                } else {
+                                    mapFields.put(outputColumn++,
+                                            new ProjectionMap.Column(new Pair<Integer, Integer>(0, inputColumn))
+                                    );
+                                }
                             } else {
                                 addedFields.add(outputColumn++);
                             }
@@ -578,12 +593,32 @@ public class LOForEach extends LogicalOperator {
                             //flattening a null schema results in a bytearray
                             if(mapped) {
                                 //map each flattened column to the original column
-                                mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                                if (cast != null) {
+                                    mapFields.put(outputColumn++,
+                                            new ProjectionMap.Column(
+                                                    new Pair<Integer, Integer>(0, inputColumn), true, cast.getType()
+                                            )
+                                    );
+                                } else {
+                                    mapFields.put(outputColumn++,
+                                            new ProjectionMap.Column(new Pair<Integer, Integer>(0, inputColumn))
+                                    );
+                                }
                             } else {
                                 addedFields.add(outputColumn++);
                             }
                         } else {
-                            mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                        	if (cast != null) {
+                                mapFields.put(outputColumn++,
+                                        new ProjectionMap.Column(
+                                                new Pair<Integer, Integer>(0, inputColumn), true, cast.getType()
+                                        )
+                                );
+                            } else {
+                                mapFields.put(outputColumn++,
+                                        new ProjectionMap.Column(new Pair<Integer, Integer>(0, inputColumn))
+                                );
+                            }
                         }
                     }
                 } else {
@@ -592,18 +627,48 @@ public class LOForEach extends LogicalOperator {
                         //flattening a null schema results in a bytearray
                         if(mapped) {
                             //map each flattened column to the original column
-                            mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                            if (cast != null) {
+                                mapFields.put(outputColumn++,
+                                        new ProjectionMap.Column(
+                                                new Pair<Integer, Integer>(0, inputColumn), true, cast.getType()
+                                        )
+                                );
+                            } else {
+                                mapFields.put(outputColumn++,
+                                        new ProjectionMap.Column(new Pair<Integer, Integer>(0, inputColumn))
+                                );
+                            }
                         } else {
                             addedFields.add(outputColumn++);
                         }
                     } else {
-                        mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                    	if (cast != null) {
+                            mapFields.put(outputColumn++,
+                                    new ProjectionMap.Column(
+                                            new Pair<Integer, Integer>(0, inputColumn), true, cast.getType()
+                                    )
+                            );
+                        } else {
+                            mapFields.put(outputColumn++,
+                                    new ProjectionMap.Column(new Pair<Integer, Integer>(0, inputColumn))
+                            );
+                        }
                     }
                 }
             } else {
                 //not a flattened column
                 if(mapped) {
-                    mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                	if (cast != null) {
+                        mapFields.put(outputColumn++, 
+                                new ProjectionMap.Column(
+                                        new Pair<Integer, Integer>(0, inputColumn), true, cast.getType()
+                                )
+                        );
+                    } else {
+                        mapFields.put(outputColumn++, 
+                                new ProjectionMap.Column(new Pair<Integer, Integer>(0, inputColumn))
+                        );
+                    }
                 } else {
                     addedFields.add(outputColumn++);
                 }
@@ -637,9 +702,9 @@ public class LOForEach extends LogicalOperator {
             if(mapFields != null) {
                 Set<Integer> mappedSet = new HashSet<Integer>();
                 for(Integer key: mapFields.keySet()) {
-                    List<Pair<Integer, Integer>> values = (ArrayList<Pair<Integer, Integer>>)mapFields.get(key);
-                    for(Pair<Integer, Integer> value: values) {
-                        mappedSet.add(value.second);
+                    List<ProjectionMap.Column> values = (ArrayList<ProjectionMap.Column>) mapFields.get(key);
+                    for (ProjectionMap.Column value : values) {
+                        mappedSet.add(value.getInputColumn().second);
                     }
                 }
                 removedSet.removeAll(mappedSet);
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLoad.java b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
index 34484cf84..e9c120004 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLoad.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
@@ -275,10 +275,10 @@ public class LOLoad extends LogicalOperator {
             mProjectionMap = new ProjectionMap(false);
             return mProjectionMap;
         } else {
-            MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+            MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
             //compute the mapping assuming its a prefix projection
             for(int i = 0; i < inputSchema.size(); ++i) {
-                mapFields.put(i, new Pair<Integer, Integer>(0, i));
+                mapFields.put(i, new ProjectionMap.Column(new Pair<Integer, Integer>(0, i)));
             }
             
             mProjectionMap = new ProjectionMap(mapFields, null, null); 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index 19236e070..e66b2dabb 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -161,7 +161,7 @@ public class LOUnion extends LogicalOperator {
             return mProjectionMap;
         }
         
-        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        MultiMap<Integer, ProjectionMap.Column> mapFields = new MultiMap<Integer, ProjectionMap.Column>();
         
         for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
             LogicalOperator predecessor = predecessors.get(inputNum);
@@ -179,8 +179,7 @@ public class LOUnion extends LogicalOperator {
                 return mProjectionMap;
             } else {
                 for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
-                    mapFields.put(inputColumn, new Pair<Integer, Integer>(inputNum, inputColumn));
-                    //removedFields.add(new Pair<Integer, Integer>(inputNum, inputColumn));
+                    mapFields.put(inputColumn, new ProjectionMap.Column(new Pair<Integer, Integer>(inputNum, inputColumn)));
                 }
             }
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java b/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
index ed56840ea..a22aba264 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
@@ -32,6 +32,7 @@ import java.util.Collection;
 import org.apache.pig.impl.plan.OperatorPlan;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.PlanException;
+import org.apache.pig.impl.util.Pair;
 
 public class LogicalPlan extends OperatorPlan<LogicalOperator> {
     private static final long serialVersionUID = 2L;
@@ -156,12 +157,14 @@ public class LogicalPlan extends OperatorPlan<LogicalOperator> {
      * 
      * @param plan
      *            input plan
-     * @return the top most projection operator if there is a chain of
-     *         projection operators with or without casts; null otherwise
+     * @return a pair consisting of the top most projection operator and the
+     *         cast (if present) if there is a chain of projection operators
+     *         with or without casts; null otherwise
      */
-    public static LOProject chainOfProjects(LogicalPlan plan) {
+    public static Pair<LOProject, LOCast> chainOfProjects(LogicalPlan plan) {
 
         LOProject topProject = null;
+        LOCast cast = null;
 
         if (plan == null) {
             return null;
@@ -181,14 +184,14 @@ public class LogicalPlan extends OperatorPlan<LogicalOperator> {
 
         while (true) {
             if (node == null) {
-                //a node cannot be null
+                // a node cannot be null
                 return null;
             }
 
             if (node instanceof LOProject) {
                 topProject = (LOProject) node;
             } else if (node instanceof LOCast) {
-                // continue
+                cast = (LOCast) node;
             } else {
                 // not a projection or a cast return null
                 return null;
@@ -198,7 +201,7 @@ public class LogicalPlan extends OperatorPlan<LogicalOperator> {
 
             if (predecessors == null) {
                 // we have reached the root
-                return topProject;
+                return new Pair<LOProject, LOCast>(topProject, cast);
             }
 
             if (predecessors.size() > 1) {
diff --git a/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java b/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java
index ddb25df26..41837616d 100644
--- a/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java
+++ b/src/org/apache/pig/impl/logicalLayer/ProjectFixerUpper.java
@@ -144,7 +144,7 @@ public class ProjectFixerUpper extends LOVisitor {
                             return;
                         }
 
-                        MultiMap<Integer, Pair<Integer, Integer>> oldNodeMappedFields = oldNodeMap
+                        MultiMap<Integer, ProjectionMap.Column> oldNodeMappedFields = oldNodeMap
                                 .getMappedFields();
                         if (oldNodeMappedFields == null) {
                             // there is no mapping available bail out
@@ -155,9 +155,9 @@ public class ProjectFixerUpper extends LOVisitor {
 
                         }
 
-                        List<Pair<Integer, Integer>> pairs = (List<Pair<Integer, Integer>>) oldNodeMappedFields
-                                .get(oldNodeColumn);
-                        if (pairs == null) {
+                        List<ProjectionMap.Column> columns = (List<ProjectionMap.Column>) oldNodeMappedFields.get(oldNodeColumn);
+                        
+                        if (columns == null) {
                             // there is no mapping for oldNodeColumn
                             // it could be an added field; bail out
                             int errCode = 2148;
@@ -167,7 +167,8 @@ public class ProjectFixerUpper extends LOVisitor {
                         }
 
                         boolean foundMapping = false;
-                        for (Pair<Integer, Integer> pair : pairs) {
+                        for (ProjectionMap.Column column : columns) {
+                        	Pair<Integer, Integer> pair = column.getInputColumn();
                             if (pair.first.equals(mPredecessorIndex)) {
                                 ArrayList<Integer> newColumns = new ArrayList<Integer>();
                                 newColumns.add(pair.second);
@@ -209,7 +210,7 @@ public class ProjectFixerUpper extends LOVisitor {
                             return;
                         }
 
-                        MultiMap<Integer, Pair<Integer, Integer>> newNodeMappedFields = newNodeMap
+                        MultiMap<Integer, ProjectionMap.Column> newNodeMappedFields = newNodeMap
                                 .getMappedFields();
                         if (newNodeMappedFields == null) {
                             // there is no mapping available bail out
@@ -223,9 +224,9 @@ public class ProjectFixerUpper extends LOVisitor {
                         boolean foundMapping = false;
                         for (Integer key : newNodeMappedFields.keySet()) {
 
-                            List<Pair<Integer, Integer>> pairs = (List<Pair<Integer, Integer>>) newNodeMappedFields
+                            List<ProjectionMap.Column> columns = (List<ProjectionMap.Column>) newNodeMappedFields
                                     .get(key);
-                            if (pairs == null) {
+                            if (columns == null) {
                                 // should not happen
                                 int errCode = 2152;
                                 String msg = "Error during fixing projections. Could not locate mapping for column: "
@@ -234,7 +235,8 @@ public class ProjectFixerUpper extends LOVisitor {
                                         PigException.BUG);
                             }
 
-                            for (Pair<Integer, Integer> pair : pairs) {
+                            for (ProjectionMap.Column column : columns) {
+                            	Pair<Integer, Integer> pair = column.getInputColumn();
                                 if (pair.first.equals(mPredecessorIndex)
                                         && pair.second.equals(oldNodeColumn)) {
                                     ArrayList<Integer> newColumns = new ArrayList<Integer>();
diff --git a/src/org/apache/pig/impl/logicalLayer/UDFFinder.java b/src/org/apache/pig/impl/logicalLayer/UDFFinder.java
new file mode 100644
index 000000000..1ed46f456
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/UDFFinder.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.logicalLayer;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.ArrayList;
+
+import org.apache.pig.FuncSpec;
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor to track the UDFs in a plan.
+ */
+public class UDFFinder extends LOVisitor {
+
+    List<FuncSpec> mUDFList = new ArrayList<FuncSpec>();
+
+    /**
+     * 
+     * @param plan
+     *            logical plan to query the presence of UDFs
+     */
+    public UDFFinder(LogicalPlan plan) {
+        super(plan, new DepthFirstWalker<LogicalOperator, LogicalPlan>(plan));
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see
+     * org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.
+     * logicalLayer.LOUserFunc)
+     */
+    @Override
+    protected void visit(LOUserFunc udf) throws VisitorException {
+        mUDFList.add(udf.getFuncSpec());
+    }
+
+    /**
+     * 
+     * @return list of function specifications found in the plan
+     */
+    public List<FuncSpec> getUDFList() {
+        return mUDFList;
+    }
+
+    /**
+     * 
+     * @return set of function specifications found in the plan
+     */
+    public Set<FuncSpec> getUDFSet() {
+        return new HashSet<FuncSpec>(mUDFList);
+    }
+
+    /**
+     * 
+     * @return true if the plan had any UDFs; false otherwise
+     */
+    public boolean foundAnyUDF() {
+        return (mUDFList.size() == 0 ? false : true);
+    }
+
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
index eeca96652..a15955c2d 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalOptimizer.java
@@ -23,6 +23,7 @@ import java.util.Set;
 import org.apache.pig.ExecType;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOLimit;
 import org.apache.pig.impl.logicalLayer.LOLoad;
 import org.apache.pig.impl.logicalLayer.LOPrinter;
@@ -107,24 +108,35 @@ public class LogicalOptimizer extends
         mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan, new TypeCastInserter(plan,
                 LOStream.class.getName()), "StreamTypeCastInserter"));
 
-        // Optimize when LOAD precedes STREAM and the loader class
-        // is the same as the serializer for the STREAM.
-        // Similarly optimize when STREAM is followed by store and the
-        // deserializer class is same as the Storage class.
         if(!turnAllRulesOff) {
-            Rule rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan, new StreamOptimizer(plan,
-                    LOStream.class.getName()), "StreamOptimizer");
+            /*
+             * Optimize when LOAD precedes STREAM and the loader class is the
+             * same as the serializer for the STREAM. Similarly optimize when
+             * STREAM is followed by store and the deserializer class is same as
+             * the Storage class.
+             */
+
+            Rule rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                    new StreamOptimizer(plan, LOStream.class.getName()),
+                    "StreamOptimizer");
             checkAndAddRule(rule);
-        }
 
-        // Push up limit where ever possible.
-        if(!turnAllRulesOff) {
+            // Push up limit wherever possible.
             rulePlan = new RulePlan();
-            RuleOperator loLimit = new RuleOperator(LOLimit.class, 
+            RuleOperator loLimit = new RuleOperator(LOLimit.class,
+					new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+			rulePlan.add(loLimit);
+            rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+					new OpLimitOptimizer(plan, mode), "LimitOptimizer");
+            checkAndAddRule(rule);
+            
+            // Push filters up wherever possible
+            rulePlan = new RulePlan();
+            RuleOperator loFilter = new RuleOperator(LOFilter.class,
                     new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
-            rulePlan.add(loLimit);
-            Rule rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan,
-                    new OpLimitOptimizer(plan, mode), "LimitOptimizer");
+            rulePlan.add(loFilter);
+            rule = new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                    new PushUpFilter(plan), "PushUpFilter");
             checkAndAddRule(rule);
         }
         
@@ -178,6 +190,7 @@ public class LogicalOptimizer extends
                             }
 
                         }
+                        rule.getTransformer().reset();
                     }
                 }
             }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
index 038c6aaba..5bca6e3e8 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/LogicalTransformer.java
@@ -270,5 +270,10 @@ public abstract class LogicalTransformer extends Transformer<LogicalOperator, Lo
     	// Now rebuild the schemas
         // rebuildSchemas();
     }
-    
+
+    @Override
+    public void reset() {
+        // do nothing
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
index d3df8704d..fa759e551 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/OpLimitOptimizer.java
@@ -77,7 +77,9 @@ public class OpLimitOptimizer extends LogicalTransformer {
             LogicalOperator lo = nodes.get(0);
             if (lo == null || !(lo instanceof LOLimit)) {
                 int errCode = 2005;
-                String msg = "Expected " + LOLimit.class.getSimpleName() + ", got " + lo.getClass().getSimpleName();
+                String msg = "Expected " + LOLimit.class.getSimpleName()
+                        + ", got "
+                        + (lo == null ? lo : lo.getClass().getSimpleName());
                 throw new OptimizerException(msg, errCode, PigException.BUG);
             }
         } catch (Exception e) {
@@ -168,7 +170,7 @@ public class OpLimitOptimizer extends LogicalTransformer {
             		else
             		{
             		    int errCode = 2010;
-            		    String msg = "LOFilter should have one input";
+            		    String msg = "LOForEach should have one input";
             			throw new OptimizerException(msg, errCode, PigException.BUG);
             		}
                     // we can move LOLimit even further, recursively optimize LOLimit
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
new file mode 100644
index 000000000..504fbdc83
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
@@ -0,0 +1,425 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.impl.logicalLayer.optimizer;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.CastFinder;
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.logicalLayer.LOCast;
+import org.apache.pig.impl.logicalLayer.LOCogroup;
+import org.apache.pig.impl.logicalLayer.LOCross;
+import org.apache.pig.impl.logicalLayer.LOFRJoin;
+import org.apache.pig.impl.logicalLayer.LOFilter;
+import org.apache.pig.impl.logicalLayer.LOForEach;
+import org.apache.pig.impl.logicalLayer.LOLimit;
+import org.apache.pig.impl.logicalLayer.LOLoad;
+import org.apache.pig.impl.logicalLayer.LOSplit;
+import org.apache.pig.impl.logicalLayer.LOStore;
+import org.apache.pig.impl.logicalLayer.LOProject;
+import org.apache.pig.impl.logicalLayer.LOStream;
+import org.apache.pig.impl.logicalLayer.LOSplitOutput;
+import org.apache.pig.impl.logicalLayer.LOUnion;
+import org.apache.pig.impl.logicalLayer.LogicalOperator;
+import org.apache.pig.impl.logicalLayer.LogicalPlan;
+import org.apache.pig.impl.logicalLayer.UDFFinder;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
+import org.apache.pig.impl.plan.optimizer.OptimizerException;
+import org.apache.pig.FuncSpec;
+import org.apache.pig.PigException;
+import org.apache.pig.impl.streaming.StreamingCommand;
+import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
+
+/**
+ * A visitor to discover if a filter can be pushed as high up the tree as
+ * possible.
+ */
+public class PushUpFilter extends LogicalTransformer {
+
+    // boolean to remember if the filter has to be swapped
+    private boolean mSwap = false;
+
+    // boolean to remember if the filter has to be pushed into one of the
+    // filter's predecessor's inputs
+    private boolean mPushBefore = false;
+
+    // the input of the predecessor where the filter has to be pushed
+    private int mPushBeforeInput = -1;
+
+    public PushUpFilter(LogicalPlan plan) {
+        super(plan, new DepthFirstWalker<LogicalOperator, LogicalPlan>(plan));
+    }
+
+    /**
+     * 
+     * @return true if the filter has to swapped; false otherwise
+     */
+    public boolean getSwap() {
+        return mSwap;
+    }
+
+    /**
+     * 
+     * @return true if the filter has to be pushed before its predecessor; false
+     *         otherwise
+     */
+    public boolean getPushBefore() {
+        return mPushBefore;
+    }
+
+    /**
+     * 
+     * @return return the input of the predecessor where the filter has to be
+     *         pushed
+     */
+    public int getPushBeforeInput() {
+        return mPushBeforeInput;
+    }
+
+    @Override
+    public boolean check(List<LogicalOperator> nodes) throws OptimizerException {
+        try {
+            LOFilter filter = (LOFilter) getOperator(nodes);
+            List<LogicalOperator> predecessors = (mPlan.getPredecessors(filter) == null ? null
+                    : new ArrayList<LogicalOperator>(mPlan
+                            .getPredecessors(filter)));
+
+            // if there are no predecessors return false
+            if (predecessors == null) {
+                return false;
+            }
+
+            // if the filter has no predecessors or more than one predecessor
+            // return false
+            if (predecessors.size() == 0 || predecessors.size() > 1) {
+                return false;
+            }
+                
+            LogicalOperator predecessor = predecessors.get(0);
+
+            // if the predecessor is one of LOLoad/LOStore/LOStream/LOLimit
+            // return false
+            if (predecessor instanceof LOLoad || predecessor instanceof LOStore
+                    || predecessor instanceof LOStream
+                    || predecessor instanceof LOLimit) {
+                return false;
+            }
+            
+            // TODO
+            // for now filters cannot be combined
+            // remove this check when filters can be combined
+            if (predecessor instanceof LOFilter)
+                return false;
+
+            // TODO
+            // same rule as filters
+            if (predecessor instanceof LOSplitOutput) {
+                return false;
+            }
+            if (predecessor instanceof LOSplit) {
+                return false;
+            }
+
+            UDFFinder udfFinder = new UDFFinder(filter.getComparisonPlan());
+            udfFinder.visit();
+
+            // if the filter's inner plan contains any UDF then return false
+            if (udfFinder.foundAnyUDF()) {
+                return false;
+            }
+
+            CastFinder castFinder = new CastFinder(filter.getComparisonPlan());
+            castFinder.visit();
+
+            // if the filter's inner plan contains any casts then return false
+            if (castFinder.foundAnyCast()) {
+                return false;
+            }
+
+            List<RequiredFields> filterRequiredFields = filter
+                    .getRequiredFields();
+            if (filterRequiredFields == null) {
+                return false;
+            }
+            RequiredFields requiredField = filterRequiredFields.get(0);
+
+            // the filter's conditions contain constant expression
+            // return false
+            if (requiredField.needNoFields()) {
+                return false;
+            }
+
+            // if the predecessor is a multi-input operator then detailed
+            // checks are required
+            if (predecessor instanceof LOCross
+                    || predecessor instanceof LOUnion
+                    || predecessor instanceof LOCogroup
+                    || predecessor instanceof LOFRJoin) {
+
+                // check if the filter's required fields in conjunction with the
+                // predecessor's projection map. If the filter needs more than
+                // one input then the filter's expressions have to be split
+
+                List<LogicalOperator> grandParents = mPlan
+                        .getPredecessors(predecessor);
+
+                // if the predecessor does not have predecessors return false
+                if (grandParents == null || grandParents.size() == 0) {
+                    return false;
+                }
+                
+                // check if the predecessor is a group by
+                if (grandParents.size() == 1) {
+                    if (predecessor instanceof LOCogroup) {
+                        mSwap = true;
+                        return true;
+                    } else {
+                        // only a group by can have a single input
+                        return false;
+                    }
+                }
+
+                if (requiredField.needAllFields()) {
+                    return false;
+                }
+
+                Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());
+                boolean mapped = mappingResult.first;
+                Set<Integer> grandParentIndexes = mappingResult.second;
+                if (!mapped) {
+                    return false;
+                }
+                
+                // TODO
+                // the filter's conditions requires more than one input of its
+                // predecessor
+                // when the filter's conditions are splittable return true
+                if ((grandParentIndexes == null)
+                        || (grandParentIndexes.size() == 0)
+                        || (grandParentIndexes.size() > 1)) {
+                    return false;
+                }
+
+                if (predecessor instanceof LOCogroup) {
+                    // check for outer
+                    if (isAnyOuter((LOCogroup) predecessor)) {
+                        return false;
+                    }
+                }
+                mPushBefore = true;
+                mPushBeforeInput = grandParentIndexes.iterator().next();
+                return true;
+
+            } else if (predecessor instanceof LOForEach) {
+
+                LOForEach loForEach = (LOForEach) predecessor;
+                List<Boolean> mFlatten = loForEach.getFlatten();
+                boolean hasFlatten = false;
+                for (Boolean b : mFlatten) {
+                    if (b.equals(true)) {
+                        hasFlatten = true;
+                    }
+                }
+
+                // TODO
+                // A better check is to examine each column in the filter's
+                // required fields. If the column is the result of a flatten
+                // then
+                // return false else return true
+
+                // for now if the foreach has a flatten then return false
+                if (hasFlatten) {
+                    return false;
+                }
+
+                Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());
+                boolean mapped = mappingResult.first;
+                if (!mapped) {
+                    return false;
+                }
+            }
+
+            mSwap = true;
+            return true;
+        } catch (OptimizerException oe) {
+            throw oe;
+        } catch (Exception e) {
+            int errCode = 2149;
+            String msg = "Internal error while trying to check if filters can be pushed up.";
+            throw new OptimizerException(msg, errCode, PigException.BUG, e);
+        }
+    }
+
+    private LogicalOperator getOperator(List<LogicalOperator> nodes)
+            throws FrontendException {
+        if ((nodes == null) || (nodes.size() <= 0)) {
+            int errCode = 2052;
+            String msg = "Internal error. Cannot retrieve operator from null or empty list.";
+            throw new OptimizerException(msg, errCode, PigException.BUG);
+        }
+
+        LogicalOperator lo = nodes.get(0);
+        if (lo == null || !(lo instanceof LOFilter)) {
+            // we should never be called with any other operator class name
+            int errCode = 1101;
+            String msg = "Expected " + LOFilter.class.getSimpleName()
+                    + ", got "
+                    + (lo == null ? lo : lo.getClass().getSimpleName());
+            throw new OptimizerException(msg, errCode, PigException.INPUT);
+        } else {
+            return lo;
+        }
+
+    }
+
+    @Override
+    public void transform(List<LogicalOperator> nodes)
+            throws OptimizerException {
+        try {
+            LOFilter filter = (LOFilter) getOperator(nodes);
+            LogicalOperator predecessor = mPlan.getPredecessors(filter).get(0);
+            if (mSwap) {
+                mPlan.swap(predecessor, filter);
+            } else if (mPushBefore) {
+                if (mPushBeforeInput == -1) {
+                    // something is wrong!
+                    int errCode = 2150;
+                    String msg = "Internal error. The push before input is not set.";
+                    throw new OptimizerException(msg, errCode, PigException.BUG);
+                }
+                mPlan.pushBefore(predecessor, filter, mPushBeforeInput);
+            }
+        } catch (OptimizerException oe) {
+            throw oe;
+        } catch (Exception e) {
+            int errCode = 2151;
+            String msg = "Internal error while pushing filters up.";
+            throw new OptimizerException(msg, errCode, PigException.BUG, e);
+        }
+    }
+
+    @Override
+    public void reset() {
+        mPushBefore = false;
+        mPushBeforeInput = -1;
+        mSwap = false;
+    }
+
+    /**
+     * 
+     * A method to check if there any grouping column has the outer clause in a
+     * grouping operator
+     * 
+     * @param cogroup
+     *            the cogroup operator to be examined for presence of outer
+     *            clause
+     * @return true if the cogroup contains any input that has an outer clause;
+     *         false otherwise
+     */
+    private boolean isAnyOuter(LOCogroup cogroup) {
+        boolean[] innerList = cogroup.getInner();
+        for (boolean inner : innerList) {
+            if (!inner) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * A method to check if the required field contains elements that are mapped
+     * in the predecessor's inputs without a cast
+     * 
+     * @param requiredField
+     *            the required field of the operator
+     * @param predProjectionMap
+     *            the projection map of the predecessor
+     * @return a pair of boolean and a set of integers; the first element of the
+     *         pair is true if the field is mapped without a cast; false
+     *         otherwise; the second element of the pair is the set of
+     *         predecessor's inputs that are required for the mapping
+     */
+    private Pair<Boolean, Set<Integer>> isRequiredFieldMapped(RequiredFields requiredField,
+            ProjectionMap predProjectionMap) {
+        
+        if(requiredField == null)  {
+            return new Pair<Boolean, Set<Integer>>(false, null);
+        }
+
+        // if predecessor projection map is null then return false
+        if (predProjectionMap == null) {
+            return new Pair<Boolean, Set<Integer>>(false, null);
+        }
+
+        // if the predecessor does not change its output return true
+        if (!predProjectionMap.changes()) {
+            return new Pair<Boolean, Set<Integer>>(true, null);
+        }
+
+        MultiMap<Integer, ProjectionMap.Column> mappedFields = predProjectionMap
+                .getMappedFields();
+        // if there is no mapping in the predecessor then return false
+        if (mappedFields == null) {
+            return new Pair<Boolean, Set<Integer>>(false, null);
+        }
+
+        Set<Integer> predInputs = new HashSet<Integer>();
+        for (Pair<Integer, Integer> pair : requiredField.getFields()) {
+            predInputs.add(pair.second);
+        }
+
+        boolean mapped = false;
+        Set<Integer> grandParentIndexes = new HashSet<Integer>();
+
+        for (Integer input : predInputs) {
+            List<ProjectionMap.Column> inputList = (List<ProjectionMap.Column>) mappedFields
+                    .get(input);
+            for (ProjectionMap.Column column : inputList) {
+                // TODO
+                // Check if the column has a cast
+                // if a cast is not used then consider it as mapped
+                // in the future this should go away and the cast
+                // type should be used to move around the projections
+                if (!column.cast()) {
+                    mapped = true;
+                }
+                Pair<Integer, Integer> pair = column.getInputColumn();
+                grandParentIndexes.add(pair.first);
+            }
+        }
+
+        if (!mapped) {
+            return new Pair<Boolean, Set<Integer>>(false, null);
+        }
+
+        return new Pair<Boolean, Set<Integer>>(true, grandParentIndexes);
+    }
+}
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/StreamOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/StreamOptimizer.java
index 08392ae41..7bf513797 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/StreamOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/StreamOptimizer.java
@@ -75,7 +75,9 @@ public class StreamOptimizer extends LogicalTransformer {
         LogicalOperator lo = nodes.get(0);
         if (lo == null || !(lo instanceof LOStream)) {
             int errCode = 2005;
-            String msg = "Expected " + LOStream.class.getSimpleName() + ", got " + lo.getClass().getSimpleName();
+            String msg = "Expected " + LOStream.class.getSimpleName()
+                    + ", got "
+                    + (lo == null ? lo : lo.getClass().getSimpleName());
             throw new OptimizerException(msg, errCode, PigException.BUG);            
         }
         LOStream stream = (LOStream)lo;
@@ -231,6 +233,12 @@ public class StreamOptimizer extends LogicalTransformer {
             throw new OptimizerException(msg, errCode, PigException.BUG, e);
         }
     }
+    
+    @Override
+    public void reset() {
+        mOptimizeLoad = false;
+        mOptimizeStore = false;
+    }
 }
 
  
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
index 20529174c..6697a67e1 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
@@ -108,7 +108,9 @@ public class TypeCastInserter extends LogicalTransformer {
         if(LOLoad.class.getName().equals(operatorClassName)) {
             if (lo == null || !(lo instanceof LOLoad)) {
                 int errCode = 2005;
-                String msg = "Expected " + LOLoad.class.getSimpleName() + ", got " + lo.getClass().getSimpleName();
+                String msg = "Expected " + LOLoad.class.getSimpleName()
+                        + ", got "
+                        + (lo == null ? lo : lo.getClass().getSimpleName());
                 throw new OptimizerException(msg, errCode, PigException.BUG);
             }
     
@@ -116,7 +118,9 @@ public class TypeCastInserter extends LogicalTransformer {
         } else if(LOStream.class.getName().equals(operatorClassName)){
             if (lo == null || !(lo instanceof LOStream)) {
                 int errCode = 2005;
-                String msg = "Expected " + LOStream.class.getSimpleName() + ", got " + lo.getClass().getSimpleName();
+                String msg = "Expected " + LOStream.class.getSimpleName()
+                        + ", got "
+                        + (lo == null ? lo : lo.getClass().getSimpleName());
                 throw new OptimizerException(msg, errCode, PigException.BUG);
             }
     
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index 1a4edbe3b..a0305ff19 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -1128,7 +1128,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             throw new PlanException(msg, errCode, PigException.INPUT);
         }
         
-        List<E> firstNodeSuccessors = (ArrayList<E>)mFromEdges.get(firstNode);
+        List<E> firstNodeSuccessors = (mFromEdges.get(firstNode) == null? null : new ArrayList<E>(mFromEdges.get(firstNode)));
         
         if(firstNodeSuccessors == null) {
             int errCode = 1088;
@@ -1217,10 +1217,8 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
         //Rewire is used within reconnectPredecessors. However, rewire is explicitly turned off in insertBetween
         //The rewiring is done explicitly here to avoid exceptions that are generated due to precondition
         //violations in insertBetween
-        IndexHelper<E> indexHelper = new IndexHelper<E>(secondNodePredecessors);
-        secondNode.rewire(firstNode, indexHelper.getIndex(firstNode), firstNodePredecessors.get(inputNum), true);
+        secondNode.rewire(firstNode, inputNum, firstNodePredecessors.get(inputNum), true);
         secondNode.regenerateProjectionMap();
-        //firstNode.rewire(firstNodePredecessors.get(inputNum), inputNum, secondNode, false);
         firstNode.rewire(firstNodePredecessors.get(inputNum), 0, secondNode, false);
 
         markDirty();
diff --git a/src/org/apache/pig/impl/plan/ProjectionMap.java b/src/org/apache/pig/impl/plan/ProjectionMap.java
index cae2e8451..5f15e69e5 100644
--- a/src/org/apache/pig/impl/plan/ProjectionMap.java
+++ b/src/org/apache/pig/impl/plan/ProjectionMap.java
@@ -21,6 +21,7 @@ package org.apache.pig.impl.plan;
 import java.lang.StringBuilder;
 import java.util.List;
 
+import org.apache.pig.data.DataType;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
 
@@ -35,11 +36,12 @@ public class ProjectionMap {
 
     /**
      * Map of field changes, with keys being the output fields of the operator
-     * and values being the input fields. Fields are numbered from 0. So for a
-     * foreach operator derived from 'B = foreach A generate $0, $2, $3,
-     * udf($1)' would produce a mapping of 0->(0, 0), 2->(0, 1), 3->(0, 2)
+     * and values being the projection map columns. Fields are numbered from 0.
+     * So for a foreach operator derived from 'B = foreach A generate $0, $2,
+     * (int)$3, udf($1)' would produce a mapping of 0->(0, 0), 2->(0, 1),
+     * 3->[(0, 2), DataType.INTEGER]
      */
-    private MultiMap<Integer, Pair<Integer, Integer>> mMappedFields;
+    private MultiMap<Integer, Column> mMappedFields;
 
     /**
      * List of fields removed from the input. This includes fields that were
@@ -73,7 +75,7 @@ public class ProjectionMap {
      * @param addedFields
      *            the list of columns that are added to the output
      */
-    public ProjectionMap(MultiMap<Integer, Pair<Integer, Integer>> mapFields,
+    public ProjectionMap(MultiMap<Integer, Column> mapFields,
             List<Pair<Integer, Integer>> removedFields,
             List<Integer> addedFields) {
         this(mapFields, removedFields, addedFields, true);
@@ -90,7 +92,7 @@ public class ProjectionMap {
      * @param changes
      *            to indicate if this projection map changes its input or not
      */
-    private ProjectionMap(MultiMap<Integer, Pair<Integer, Integer>> mapFields,
+    private ProjectionMap(MultiMap<Integer, Column> mapFields,
             List<Pair<Integer, Integer>> removedFields,
             List<Integer> addedFields, boolean changes) {
         mMappedFields = mapFields;
@@ -103,7 +105,7 @@ public class ProjectionMap {
      * 
      * @return the mapping of input column to output column
      */
-    public MultiMap<Integer, Pair<Integer, Integer>> getMappedFields() {
+    public MultiMap<Integer, Column> getMappedFields() {
         return mMappedFields;
     }
 
@@ -112,7 +114,7 @@ public class ProjectionMap {
      * @param fields
      *            the mapping of input column to output column
      */
-    public void setMappedFields(MultiMap<Integer, Pair<Integer, Integer>> fields) {
+    public void setMappedFields(MultiMap<Integer, Column> fields) {
         mMappedFields = fields;
     }
 
@@ -185,4 +187,95 @@ public class ProjectionMap {
         sb.append(" removed fields: " + mRemovedFields);
         return sb.toString();
     }
+
+	/**
+     * 
+     * A wrapper for projection map columns to contain the input number, input
+     * column. Additionally, if a cast is used, record the type of the cast
+     * 
+     */
+    public static class Column {
+        private Pair<Integer, Integer> mInputColumn;
+        private boolean mCast = false;
+        private byte mCastType = DataType.UNKNOWN;
+
+        /**
+         * 
+         * @param inputColumn
+         *            A pair of integers representing the input number and the
+         *            input column number
+         */
+        public Column(Pair<Integer, Integer> inputColumn) {
+            this(inputColumn, false, DataType.UNKNOWN);
+        }
+
+        /**
+         * 
+         * @param inputColumn
+         *            A pair of integers representing the input number and the
+         *            input column number
+         * @param cast
+         *            true if the input column has a cast
+         * @param castType
+         *            the data type of the cast
+         */
+        public Column(Pair<Integer, Integer> inputColumn, boolean cast,
+                byte castType) {
+            mInputColumn = inputColumn;
+            mCast = cast;
+            mCastType = castType;
+        }
+
+        /**
+         * 
+         * Get the mapped column details
+         * 
+         * @return A pair of integers representing the input number and the
+         *         input column number
+         */
+        public Pair<Integer, Integer> getInputColumn() {
+            return mInputColumn;
+        }
+
+        /**
+         * 
+         * Check if the column is cast
+         * 
+         * @return true if the input column has a cast; false otherwise
+         */
+        public boolean getCast() {
+            return mCast;
+        }
+
+        
+        /**
+         * 
+         * Check if the column is cast
+         * 
+         * @return true if the input column has a cast; false otherwise
+         */
+        public boolean cast() {
+            return getCast();
+        }
+
+        /**
+         * 
+         * Get the data type of the cast
+         * 
+         * @return the data type of the cast
+         */
+        public byte getCastType() {
+            return mCastType;
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+            sb.append(mInputColumn);
+            if (mCast) {
+                sb.append(" cast to: " + DataType.findTypeName(mCastType));
+            }
+            return sb.toString();
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java b/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
index 5870f6245..2323301a4 100644
--- a/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
+++ b/src/org/apache/pig/impl/plan/optimizer/PlanOptimizer.java
@@ -89,6 +89,7 @@ public abstract class PlanOptimizer<O extends Operator, P extends OperatorPlan<O
     	                    sawMatch = true;
     	                    rule.getTransformer().transform(match);
     	                }
+    	                rule.getTransformer().reset();
                     }
                 }
             }
diff --git a/src/org/apache/pig/impl/plan/optimizer/Transformer.java b/src/org/apache/pig/impl/plan/optimizer/Transformer.java
index 97061cd48..a04f446b5 100644
--- a/src/org/apache/pig/impl/plan/optimizer/Transformer.java
+++ b/src/org/apache/pig/impl/plan/optimizer/Transformer.java
@@ -60,6 +60,13 @@ public abstract class Transformer<O extends Operator, P extends OperatorPlan<O>>
      * @throws OptimizerException
      */
     public abstract void transform(List<O> nodes) throws OptimizerException;
+    
+    /**
+     * Reset any internal state after the transformation.
+     * 
+     * @throws OptimizerException
+     */
+    public abstract void reset() throws OptimizerException;
 
 }
 
diff --git a/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java b/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java
index 83691b6b6..3d49cafba 100644
--- a/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java
+++ b/src/org/apache/pig/pen/util/FunctionalLogicalOptimizer.java
@@ -23,6 +23,7 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOLoad;
 import org.apache.pig.impl.logicalLayer.LOStream;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
@@ -85,6 +86,15 @@ public class FunctionalLogicalOptimizer extends
         rulePlan.add(loStream);
         mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan, new TypeCastInserter(plan,
                 LOStream.class.getName()), "StreamTypeCastInserter"));
+        
+        // Push up filters as far as we can
+        rulePlan = new RulePlan();
+        RuleOperator loFilter = new RuleOperator(LOFilter.class,
+                new OperatorKey(SCOPE, nodeIdGen.getNextNodeId(SCOPE)));
+        rulePlan.add(loFilter);
+        mRules.add(new Rule<LogicalOperator, LogicalPlan>(rulePlan,
+                new TypeCastInserter(plan, LOFilter.class.getName()),
+                "PushUpFilter"));
 
     }
 
diff --git a/test/org/apache/pig/test/TestOperatorPlan.java b/test/org/apache/pig/test/TestOperatorPlan.java
index c45dd56c6..2cc0047a1 100644
--- a/test/org/apache/pig/test/TestOperatorPlan.java
+++ b/test/org/apache/pig/test/TestOperatorPlan.java
@@ -286,6 +286,10 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         public int getNumberOfChecks() {
             return mNumChecks;
         }
+        
+        @Override
+        public void reset() {
+        }
     }
 
     class NeverTransform extends Transformer<TOperator, TPlan> {
@@ -308,6 +312,10 @@ public class TestOperatorPlan extends junit.framework.TestCase {
         public int getNumberOfChecks() {
             return mNumChecks;
         }
+        
+        @Override
+        public void reset() {
+        }
     }
 
     @Test
diff --git a/test/org/apache/pig/test/TestProjectionMap.java b/test/org/apache/pig/test/TestProjectionMap.java
index a2b09750a..ac8d923b5 100644
--- a/test/org/apache/pig/test/TestProjectionMap.java
+++ b/test/org/apache/pig/test/TestProjectionMap.java
@@ -70,16 +70,16 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
 
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 2);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 2);
         
         assertTrue(foreachProjectionMap.getRemovedFields() == null);
         assertTrue(foreachProjectionMap.getAddedFields() == null);
@@ -102,12 +102,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
 
         assertTrue(foreachProjectionMap.getRemovedFields() == null);
         
@@ -136,14 +136,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
-        assertTrue(mapValues.get(1).first == 1);
-        assertTrue(mapValues.get(1).second == 1);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
+        assertTrue(mapValues.get(1).getInputColumn().first == 1);
+        assertTrue(mapValues.get(1).getInputColumn().second == 1);
         
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -190,7 +190,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields == null);
         
         //check the cogroup removed fields is null
@@ -206,12 +206,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMappedFields = foreachProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> foreachMappedFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMappedFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMappedFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)foreachMappedFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
 
 
         //check that removed fields has all the columns from the input cogroup
@@ -242,12 +242,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
 
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -262,12 +262,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);        
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 0);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 0);
 
 
         //check that removed fields has all the columns from the input cogroup
@@ -304,14 +304,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
-        assertTrue(mapValues.get(1).first == 1);
-        assertTrue(mapValues.get(1).second == 1);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
+        assertTrue(mapValues.get(1).getInputColumn().first == 1);
+        assertTrue(mapValues.get(1).getInputColumn().second == 1);
         
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -327,16 +327,16 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 2);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 2);
 
         //check that removed fields has all the group column from the input cogroup
         List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
@@ -365,14 +365,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
 
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 6);
-        assertTrue(mapValues.get(1).first == 0);
-        assertTrue(mapValues.get(1).second == 7);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 6);
+        assertTrue(mapValues.get(1).getInputColumn().first == 0);
+        assertTrue(mapValues.get(1).getInputColumn().second == 7);
         
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -387,16 +387,16 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 0);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 0);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 0);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 0);
 
         //check that removed fields has all the group column from the input cogroup
         List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
@@ -581,14 +581,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(cogroupMapValues.get(0).first == 0);
-        assertTrue(cogroupMapValues.get(0).second == 1);
-        assertTrue(cogroupMapValues.get(1).first == 1);
-        assertTrue(cogroupMapValues.get(1).second == 1);
+        List<ProjectionMap.Column> cogroupMapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(cogroupMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(cogroupMapValues.get(0).getInputColumn().second == 1);
+        assertTrue(cogroupMapValues.get(1).getInputColumn().first == 1);
+        assertTrue(cogroupMapValues.get(1).getInputColumn().second == 1);
         
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -604,17 +604,17 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
-        List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 1);
+        List<ProjectionMap.Column> foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 1);
         
         for(int i = 1; i < 4; ++i) {
-            foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(i);
-            assertTrue(foreachMapValues.get(0).first == 0);
-            assertTrue(foreachMapValues.get(0).second == 2);
+            foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(i);
+            assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+            assertTrue(foreachMapValues.get(0).getInputColumn().second == 2);
         }
         
         //check that removed fields has all the group column from the input cogroup
@@ -654,14 +654,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(cogroupMapValues.get(0).first == 0);
-        assertTrue(cogroupMapValues.get(0).second == 1);
-        assertTrue(cogroupMapValues.get(1).first == 1);
-        assertTrue(cogroupMapValues.get(1).second == 1);
+        List<ProjectionMap.Column> cogroupMapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(cogroupMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(cogroupMapValues.get(0).getInputColumn().second == 1);
+        assertTrue(cogroupMapValues.get(1).getInputColumn().first == 1);
+        assertTrue(cogroupMapValues.get(1).getInputColumn().second == 1);
         
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -677,12 +677,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
-        List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 1);
+        List<ProjectionMap.Column> foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 1);
         
         //check that removed fields has all the columns from the input cogroup
         List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
@@ -784,14 +784,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 0);
-        assertTrue(mapValues.get(1).first == 1);
-        assertTrue(mapValues.get(1).second == 0);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 0);
+        assertTrue(mapValues.get(1).getInputColumn().first == 1);
+        assertTrue(mapValues.get(1).getInputColumn().second == 0);
         
         //check the cogroup removed fields is null
         assertTrue(cogroupProjectionMap.getRemovedFields() == null);
@@ -807,16 +807,16 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 2);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 2);
 
         //check that removed fields has all the group column from the input cogroup
         List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
@@ -1006,14 +1006,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(cogroupMapValues.get(0).first == 0);
-        assertTrue(cogroupMapValues.get(0).second == 0);
-        assertTrue(cogroupMapValues.get(1).first == 1);
-        assertTrue(cogroupMapValues.get(1).second == 0);
+        List<ProjectionMap.Column> cogroupMapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(cogroupMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(cogroupMapValues.get(0).getInputColumn().second == 0);
+        assertTrue(cogroupMapValues.get(1).getInputColumn().first == 1);
+        assertTrue(cogroupMapValues.get(1).getInputColumn().second == 0);
         
         //check that removed fields has hitCount from a and rank from b
         List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
@@ -1038,28 +1038,28 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
-        List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 0);
+        List<ProjectionMap.Column> foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 0);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 1);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 1);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 1);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(2);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 1);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(3);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 2);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(3);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 2);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(4);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 2);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(4);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 2);
         
         //check that removed fields is null
         List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
@@ -1078,25 +1078,25 @@ public class TestProjectionMap extends junit.framework.TestCase {
         foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 0);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 0);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 1);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 1);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 3);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(2);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 3);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(3);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 4);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(3);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 4);
         
-        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(4);
-        assertTrue(foreachMapValues.get(0).first == 0);
-        assertTrue(foreachMapValues.get(0).second == 4);
+        foreachMapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(4);
+        assertTrue(foreachMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(foreachMapValues.get(0).getInputColumn().second == 4);
         
         //check that removed fields is null
         foreachRemovedFields = foreachProjectionMap.getRemovedFields();
@@ -1131,24 +1131,24 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap crossProjectionMap = cross.getProjectionMap();
         assertTrue(crossProjectionMap != null);
         
-        MultiMap<Integer, Pair<Integer, Integer>> crossMapFields = crossProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> crossMapFields = crossProjectionMap.getMappedFields();
         assertTrue(crossMapFields != null);
         
-        List<Pair<Integer, Integer>> crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(0);
-        assertTrue(crossMapValues.get(0).first == 0);
-        assertTrue(crossMapValues.get(0).second == 0);
+        List<ProjectionMap.Column> crossMapValues = (ArrayList<ProjectionMap.Column>)crossMapFields.get(0);
+        assertTrue(crossMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(crossMapValues.get(0).getInputColumn().second == 0);
         
-        crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(1);
-        assertTrue(crossMapValues.get(0).first == 0);
-        assertTrue(crossMapValues.get(0).second == 1);
+        crossMapValues = (ArrayList<ProjectionMap.Column>)crossMapFields.get(1);
+        assertTrue(crossMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(crossMapValues.get(0).getInputColumn().second == 1);
         
-        crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(2);
-        assertTrue(crossMapValues.get(0).first == 1);
-        assertTrue(crossMapValues.get(0).second == 0);
+        crossMapValues = (ArrayList<ProjectionMap.Column>)crossMapFields.get(2);
+        assertTrue(crossMapValues.get(0).getInputColumn().first == 1);
+        assertTrue(crossMapValues.get(0).getInputColumn().second == 0);
         
-        crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(3);
-        assertTrue(crossMapValues.get(0).first == 1);
-        assertTrue(crossMapValues.get(0).second == 1);
+        crossMapValues = (ArrayList<ProjectionMap.Column>)crossMapFields.get(3);
+        assertTrue(crossMapValues.get(0).getInputColumn().first == 1);
+        assertTrue(crossMapValues.get(0).getInputColumn().second == 1);
         
         //check that removed fields is null
         List<Pair<Integer, Integer>> crossRemovedFields = crossProjectionMap.getRemovedFields();
@@ -1178,22 +1178,22 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap unionProjectionMap = union.getProjectionMap();
         assertTrue(unionProjectionMap != null);
         
-        MultiMap<Integer, Pair<Integer, Integer>> unionMapFields = unionProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> unionMapFields = unionProjectionMap.getMappedFields();
         assertTrue(unionMapFields != null);
 
-        List<Pair<Integer, Integer>> unionMapValues = (ArrayList<Pair<Integer, Integer>>)unionMapFields.get(0);
-        assertTrue(unionMapValues.get(0).first == 0);
-        assertTrue(unionMapValues.get(0).second == 0);
+        List<ProjectionMap.Column> unionMapValues = (ArrayList<ProjectionMap.Column>)unionMapFields.get(0);
+        assertTrue(unionMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(unionMapValues.get(0).getInputColumn().second == 0);
         
-        assertTrue(unionMapValues.get(1).first == 1);
-        assertTrue(unionMapValues.get(1).second == 0);
+        assertTrue(unionMapValues.get(1).getInputColumn().first == 1);
+        assertTrue(unionMapValues.get(1).getInputColumn().second == 0);
         
-        unionMapValues = (ArrayList<Pair<Integer, Integer>>)unionMapFields.get(1);
-        assertTrue(unionMapValues.get(0).first == 0);
-        assertTrue(unionMapValues.get(0).second == 1);
+        unionMapValues = (ArrayList<ProjectionMap.Column>)unionMapFields.get(1);
+        assertTrue(unionMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(unionMapValues.get(0).getInputColumn().second == 1);
         
-        assertTrue(unionMapValues.get(1).first == 1);
-        assertTrue(unionMapValues.get(1).second == 1);
+        assertTrue(unionMapValues.get(1).getInputColumn().first == 1);
+        assertTrue(unionMapValues.get(1).getInputColumn().second == 1);
         
         //check that removed fields is null
         List<Pair<Integer, Integer>> unionRemovedFields = unionProjectionMap.getRemovedFields();
@@ -1224,24 +1224,24 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
         assertTrue(frjoinProjectionMap != null);
         
-        MultiMap<Integer, Pair<Integer, Integer>> frjoinMapFields = frjoinProjectionMap.getMappedFields();
+        MultiMap<Integer, ProjectionMap.Column> frjoinMapFields = frjoinProjectionMap.getMappedFields();
         assertTrue(frjoinMapFields != null);
 
-        List<Pair<Integer, Integer>> frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(0);
-        assertTrue(frjoinMapValues.get(0).first == 0);
-        assertTrue(frjoinMapValues.get(0).second == 0);
+        List<ProjectionMap.Column> frjoinMapValues = (ArrayList<ProjectionMap.Column>)frjoinMapFields.get(0);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 0);
         
-        frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(1);
-        assertTrue(frjoinMapValues.get(0).first == 0);
-        assertTrue(frjoinMapValues.get(0).second == 1);
+        frjoinMapValues = (ArrayList<ProjectionMap.Column>)frjoinMapFields.get(1);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 0);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 1);
         
-        frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(2);
-        assertTrue(frjoinMapValues.get(0).first == 1);
-        assertTrue(frjoinMapValues.get(0).second == 0);
+        frjoinMapValues = (ArrayList<ProjectionMap.Column>)frjoinMapFields.get(2);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 1);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 0);
         
-        frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(3);
-        assertTrue(frjoinMapValues.get(0).first == 1);
-        assertTrue(frjoinMapValues.get(0).second == 1);
+        frjoinMapValues = (ArrayList<ProjectionMap.Column>)frjoinMapFields.get(3);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().first == 1);
+        assertTrue(frjoinMapValues.get(0).getInputColumn().second == 1);
         
         //check that removed fields is null
         List<Pair<Integer, Integer>> frjoinRemovedFields = frjoinProjectionMap.getRemovedFields();
@@ -1272,14 +1272,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 0);
-        assertTrue(mapValues.get(1).first == 1);
-        assertTrue(mapValues.get(1).second == 0);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 0);
+        assertTrue(mapValues.get(1).getInputColumn().first == 1);
+        assertTrue(mapValues.get(1).getInputColumn().second == 0);
         
         //check that removed fields is not null
         List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
@@ -1304,24 +1304,24 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
 
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 2);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(2);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 2);
 
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(3);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 2);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(3);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 2);
 
         
         //check that removed fields has all the group column from the input cogroup
@@ -1416,14 +1416,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
-        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 0);
-        assertTrue(mapValues.get(1).first == 1);
-        assertTrue(mapValues.get(1).second == 0);
+        List<ProjectionMap.Column> mapValues = (ArrayList<ProjectionMap.Column>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 0);
+        assertTrue(mapValues.get(1).getInputColumn().first == 1);
+        assertTrue(mapValues.get(1).getInputColumn().second == 0);
         
         //check that removed fields is not null
         List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
@@ -1444,20 +1444,20 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
+        MultiMap<Integer, ProjectionMap.Column> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields.size() == 3);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
         
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 1);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 1);
 
-        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
-        assertTrue(mapValues.get(0).first == 0);
-        assertTrue(mapValues.get(0).second == 2);
+        mapValues = (ArrayList<ProjectionMap.Column>)foreachMapFields.get(2);
+        assertTrue(mapValues.get(0).getInputColumn().first == 0);
+        assertTrue(mapValues.get(0).getInputColumn().second == 2);
 
         
         //check that removed fields has all the group column from the input cogroup
diff --git a/test/org/apache/pig/test/TestPushUpFilter.java b/test/org/apache/pig/test/TestPushUpFilter.java
new file mode 100644
index 000000000..3576869d0
--- /dev/null
+++ b/test/org/apache/pig/test/TestPushUpFilter.java
@@ -0,0 +1,995 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.test;
+
+
+import org.apache.pig.FilterFunc;
+import org.apache.pig.data.Tuple;
+import org.apache.pig.impl.logicalLayer.*;
+import org.apache.pig.impl.logicalLayer.optimizer.*;
+import org.apache.pig.test.utils.LogicalPlanTester;
+import org.apache.pig.impl.plan.optimizer.OptimizerException;
+
+import org.junit.Test;
+import org.junit.Before;
+
+/**
+ * Test the logical optimizer.
+ */
+
+public class TestPushUpFilter extends junit.framework.TestCase {
+
+    final String FILE_BASE_LOCATION = "test/org/apache/pig/test/data/DotFiles/" ;
+    static final int MAX_SIZE = 100000;
+
+    LogicalPlanTester planTester = new LogicalPlanTester() ;
+
+    private static final String simpleEchoStreamingCommand;
+    static {
+        if (System.getProperty("os.name").toUpperCase().startsWith("WINDOWS"))
+            simpleEchoStreamingCommand = "perl -ne 'print \\\"$_\\\"'";
+        else
+            simpleEchoStreamingCommand = "perl -ne 'print \"$_\"'";
+    }
+
+    
+    @Before
+    public void tearDown() {
+        planTester.reset();
+    }
+
+    /**
+     * 
+     * A simple filter UDF for testing
+     *
+     */
+    static public class MyFilterFunc extends FilterFunc {
+    	
+    	@Override
+    	public Boolean exec(Tuple input) {
+    		return false;
+    	}
+    }
+    
+    @Test
+    //Test to ensure that the right exception is thrown when the input list is empty
+    public void testErrorEmptyInput() throws Exception {
+        LogicalPlan lp = new LogicalPlan();
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        try {
+            pushUpFilter.check(lp.getRoots());
+            fail("Exception Expected!");
+        } catch(Exception e) {
+            assertTrue(((OptimizerException)e).getErrorCode() == 2052);
+        }
+    }
+
+    @Test
+    //Test to ensure that the right exception is thrown when the input list is empty
+    public void testErrorNonFilterInput() throws Exception {
+        LogicalPlan lp = planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");;
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        try {
+            pushUpFilter.check(lp.getRoots());
+            fail("Exception Expected!");
+        } catch(Exception e) {
+            assertTrue(((OptimizerException)e).getErrorCode() == 1101);
+        }
+    }
+    
+    @Test
+    public void testFilterLoad() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        LogicalPlan lp = planTester.buildPlan("B = filter A by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterStreaming() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = stream A through `" + simpleEchoStreamingCommand + "`;");
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterSort() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = order A by $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == true);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+        LOFilter filter = (LOFilter) lp.getLeaves().get(0);
+        LOSort sort = (LOSort)lp.getPredecessors(filter).get(0);
+        
+        pushUpFilter.transform(lp.getLeaves());
+        
+        assertEquals(sort, lp.getLeaves().get(0));
+        assertEquals(filter, lp.getPredecessors(sort).get(0));
+        
+    }
+
+    @Test
+    public void testFilterConstantConditionSort() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = order A by $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterUDFSort() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = order A by $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter B by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterDistinct() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = distinct A;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == true);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+
+        LOFilter filter = (LOFilter) lp.getLeaves().get(0);
+        LODistinct distinct = (LODistinct)lp.getPredecessors(filter).get(0);
+
+        pushUpFilter.transform(lp.getLeaves());
+        
+        assertEquals(distinct, lp.getLeaves().get(0));
+        assertEquals(filter, lp.getPredecessors(distinct).get(0));
+
+    }
+
+    @Test
+    public void testFilterConstantConditionDistinct() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = distinct A;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterUDFDistinct() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = distinct A;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter B by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterForeach() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = foreach A generate $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $0 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == true);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+        LOFilter filter = (LOFilter) lp.getLeaves().get(0);
+        LOForEach foreach = (LOForEach)lp.getPredecessors(filter).get(0);
+        
+        pushUpFilter.transform(lp.getLeaves());
+        
+        assertEquals(foreach, lp.getLeaves().get(0));
+        assertEquals(filter, lp.getPredecessors(foreach).get(0));
+        
+    }
+
+    @Test
+    public void testFilterForeachCast() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = foreach A generate (chararray)$1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $0 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterCastForeach() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = foreach A generate $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by (int)$0 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    
+    @Test
+    public void testFilterConstantConditionForeach() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = foreach A generate $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterUDFForeach() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = foreach A generate $1, $2;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter B by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterForeachFlatten() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = foreach A generate $1, flatten($2);");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $0 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterFilter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = filter A by $0 != 'name';");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterSplitOutput() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("split A into B if $1 < 18, C if $1 >= 18;");
+        LogicalPlan lp = planTester.buildPlan("D = filter B by $1 < 10;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterLimit() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = limit A 10;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    
+    @Test
+    public void testFilterUnion() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = union A, B;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by $1 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterConstantConditionUnion() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = union A, B;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFUnion() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = union A, B;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterCross() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cross A, B;");
+        planTester.buildPlan("D = filter C by $5 < 18;");
+        LogicalPlan lp = planTester.buildPlan("E = limit D 10;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
+        LOCross cross = (LOCross)lp.getPredecessors(filter).get(0);
+
+        
+        assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == true);
+        assertTrue(pushUpFilter.getPushBeforeInput() == 1);
+
+        pushUpFilter.transform(lp.getPredecessors(limit));
+        
+        assertEquals(cross, lp.getPredecessors(limit).get(0));
+        assertEquals(filter, lp.getPredecessors(cross).get(1));
+        
+    }
+
+    @Test
+    public void testFilterCross1() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cross A, B;");
+        planTester.buildPlan("D = filter C by $1 < 18;");
+        LogicalPlan lp = planTester.buildPlan("E = limit D 10;");
+
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
+        LOCross cross = (LOCross)lp.getPredecessors(filter).get(0);
+
+        
+        assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == true);
+        assertTrue(pushUpFilter.getPushBeforeInput() == 0);
+
+        pushUpFilter.transform(lp.getPredecessors(limit));
+        
+        assertEquals(cross, lp.getPredecessors(limit).get(0));
+        assertEquals(filter, lp.getPredecessors(cross).get(0));
+        
+    }
+
+    
+    @Test
+    public void testFilterCross2() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cross A, B;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by $1 < 18 and $5 < 18;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterConstantConditionCross() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cross A, B;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFCross() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cross A, B;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterCogroup() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cogroup A by $0, B by $0;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by $0 < 'name';");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterConstantConditionCogroup() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cogroup A by $0, B by $0;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFCogroup() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cogroup A by $0, B by $0;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterCogroupOuter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cogroup A by $0, B by $0 outer;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by $0 < 'name';");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterConstantConditionCogroupOuter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cogroup A by $0, B by $0 outer;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFCogroupOuter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = cogroup A by $0, B by $0 outer;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterGroupBy() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by $0;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $0 < 'name';");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == true);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+
+        LOFilter filter = (LOFilter) lp.getLeaves().get(0);
+        LOCogroup groupBy = (LOCogroup)lp.getPredecessors(filter).get(0);
+
+        pushUpFilter.transform(lp.getLeaves());
+        
+        assertEquals(groupBy, lp.getLeaves().get(0));
+        assertEquals(filter, lp.getPredecessors(groupBy).get(0));
+    }
+    
+    @Test
+    public void testFilterConstantConditionGroupBy() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by $0;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFGroupBy() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by $0;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by " + MyFilterFunc.class.getName() + "() ;");
+
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterGroupByOuter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by $0 outer;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by $0 < 'name';");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == true);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+        LOFilter filter = (LOFilter) lp.getLeaves().get(0);
+        LOCogroup groupBy = (LOCogroup)lp.getPredecessors(filter).get(0);
+
+        pushUpFilter.transform(lp.getLeaves());
+        
+        assertEquals(groupBy, lp.getLeaves().get(0));
+        assertEquals(filter, lp.getPredecessors(groupBy).get(0));
+        
+    }
+    
+    @Test
+    public void testFilterConstantConditionGroupByOuter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by $0 outer;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by 1 == 1;");
+
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFGroupByOuter() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by $0 outer;");        
+        LogicalPlan lp = planTester.buildPlan("C = filter B by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+    @Test
+    public void testFilterFRJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0 using \"replicated\";");        
+        planTester.buildPlan("D = filter C by $0 < 'name';");
+        LogicalPlan lp = planTester.buildPlan("E = limit D 10;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
+        LOFRJoin frjoin = (LOFRJoin)lp.getPredecessors(filter).get(0);
+
+        assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == true);
+        assertTrue(pushUpFilter.getPushBeforeInput() == 0);
+
+        
+        pushUpFilter.transform(lp.getPredecessors(limit));
+        
+        assertEquals(frjoin, lp.getPredecessors(limit).get(0));
+        assertEquals(filter, lp.getPredecessors(frjoin).get(0));
+
+    }
+    
+    @Test
+    public void testFilterFRJoin1() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0 using \"replicated\";");        
+        planTester.buildPlan("D = filter C by $4 < 'name';");
+        LogicalPlan lp = planTester.buildPlan("E = limit D 10;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+
+        LOLimit limit = (LOLimit) lp.getLeaves().get(0);
+        LOFilter filter = (LOFilter) lp.getPredecessors(limit).get(0);
+        LOFRJoin frjoin = (LOFRJoin)lp.getPredecessors(filter).get(0);
+
+        assertTrue(pushUpFilter.check(lp.getPredecessors(limit)));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == true);
+        assertTrue(pushUpFilter.getPushBeforeInput() == 1);
+
+        
+        pushUpFilter.transform(lp.getPredecessors(limit));
+        
+        assertEquals(frjoin, lp.getPredecessors(limit).get(0));
+        assertEquals(filter, lp.getPredecessors(frjoin).get(1));
+
+    }
+    
+    
+    @Test
+    public void testFilterConstantConditionFRJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0 using \"replicated\";");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFFRJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0 using \"replicated\";");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterInnerJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by $0 < 'name';");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterConstantConditionInnerJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by 1 == 1;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+    
+    @Test
+    public void testFilterUDFInnerJoin() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = load 'anotherfile' as (name, age, preference);");
+        planTester.buildPlan("C = join A by $0, B by $0;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by " + MyFilterFunc.class.getName() + "() ;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+        
+    }
+
+}
+
