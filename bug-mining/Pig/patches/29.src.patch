diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 863558e21..491f0a3c9 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -1224,12 +1224,14 @@ LogicalOperator OrderClause(LogicalPlan lp) :
 ExpressionOperator SortCol(Schema over, LogicalPlan lp, LogicalOperator op, ArrayList<Boolean> ascOrder, ArrayList<LogicalPlan> sortColPlans) : 
 {
 	ExpressionOperator col; 
+    int colNum;
 	boolean asc = true; 
 	LogicalPlan sortColPlan = new LogicalPlan(); 
 	log.trace("Entering SortCol");}
 {
 	(
-		col = ColOrSpec(op.getSchema(), null, sortColPlan, op) [<ASC> | <DESC> {asc = false;}]
+		//col = ColOrSpec(op.getSchema(), null, sortColPlan, op) [<ASC> | <DESC> {asc = false;}]
+		colNum = ColNameOrNum(op.getSchema()) [<ASC> | <DESC> {asc = false;}]
 		{
 			if(asc) {
 				log.debug("Ascending");
@@ -1238,11 +1240,14 @@ ExpressionOperator SortCol(Schema over, LogicalPlan lp, LogicalOperator op, Arra
 				log.debug("Descending");	
 				ascOrder.add(false);
 			}
+            col = new LOProject(sortColPlan, new OperatorKey(scope, getNextId()), op, colNum);
+            sortColPlan.add(col);
 			sortColPlans.add(sortColPlan);
 		}
 		|
 		( 
-			"(" col = ColOrSpec(op.getSchema(), null, sortColPlan, op) ")" [<ASC> | <DESC> {asc = false;}]
+			//"(" col = ColOrSpec(op.getSchema(), null, sortColPlan, op) ")" [<ASC> | <DESC> {asc = false;}]
+			"(" colNum = ColNameOrNum(op.getSchema()) ")" [<ASC> | <DESC> {asc = false;}]
 			{
 				if(asc) {
 					log.debug("Ascending");
@@ -1251,6 +1256,8 @@ ExpressionOperator SortCol(Schema over, LogicalPlan lp, LogicalOperator op, Arra
 					log.debug("Descending");	
 					ascOrder.add(false);
 				}
+                col = new LOProject(sortColPlan, new OperatorKey(scope, getNextId()), op, colNum);
+                sortColPlan.add(col);
 				sortColPlans.add(sortColPlan);
 			}
 		)
@@ -1261,10 +1268,10 @@ ExpressionOperator SortCol(Schema over, LogicalPlan lp, LogicalOperator op, Arra
 	}	
 }
 
-int ColName(Schema over) : 
+int ColNameOrNum(Schema over) : 
 {
 	Token t; 
-	log.trace("Entering ColName");
+	log.trace("Entering ColNameOrNum");
 }
 {
 	(
@@ -1277,7 +1284,7 @@ int ColName(Schema over) :
 			throw new ParseException("Invalid alias: " + t.image + " in " + over);
 		} 
 		
-		log.trace("Exiting ColName");
+		log.trace("Exiting ColNameOrNum");
 		return i;
 	}
 	)
@@ -1528,8 +1535,8 @@ LogicalOperator NestedProject(Schema over, Map<String, LogicalOperator> specs, L
     }
     "." 
     (
-    i = ColName(subSchema) {colList.add(i);}
-|   "(" i = ColName(subSchema) {colList.add(i);} ("," i = ColName(over) {colList.add(i);})* ")"
+    i = ColNameOrNum(subSchema) {colList.add(i);}
+|   "(" i = ColNameOrNum(subSchema) {colList.add(i);} ("," i = ColNameOrNum(over) {colList.add(i);})* ")"
     )
     {
         ArrayList<LogicalPlan> foreachPlans = new ArrayList<LogicalPlan>();
@@ -2513,8 +2520,8 @@ ExpressionOperator SimpleProj(Schema over, LogicalPlan lp, LogicalOperator eOp):
 	log.trace("Entering SimpleProj");
 }
 {
-	i = ColName(over) {colList.add(i);}	
-		("," i = ColName(over) {colList.add(i);})*
+	i = ColNameOrNum(over) {colList.add(i);}	
+		("," i = ColNameOrNum(over) {colList.add(i);})*
 	{
 		ExpressionOperator project = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, colList);
 		lp.add(project);
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index f1d4231e3..6e6edc0ec 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -1048,6 +1048,30 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
 
     }
 
+    @Test
+    public void testQuery87() {
+        buildPlan("a = load 'myfile';");
+        buildPlan("b = group a by $0;");
+        LogicalPlan lp = buildPlan("c = foreach b {c1 = order $1 by $1; generate flatten(c1); };");
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        LogicalPlan nestedPlan = foreach.getForEachPlans().get(0);
+        LOProject sortInput = (LOProject)nestedPlan.getRoots().get(0);
+        LOSort nestedSort = (LOSort)nestedPlan.getSuccessors(sortInput).get(0);
+        LogicalPlan sortPlan = nestedSort.getSortColPlans().get(0);
+        assertTrue(sortPlan.getLeaves().size() == 1);
+    }
+
+    @Test
+    public void testQuery88() {
+        buildPlan("a = load 'myfile';");
+        buildPlan("b = group a by $0;");
+        LogicalPlan lp = buildPlan("c = order b by $1 ;");
+        LOSort sort = (LOSort)lp.getLeaves().get(0);
+        LOProject project1 = (LOProject) sort.getSortColPlans().get(0).getLeaves().get(0) ;
+        LOCogroup cogroup = (LOCogroup) lp.getPredecessors(sort).get(0) ;
+        assertEquals(project1.getExpression(), cogroup) ;
+    }
+
     private void printPlan(LogicalPlan lp) {
         LOPrinter graphPrinter = new LOPrinter(System.err, lp);
         System.err.println("Printing the logical plan");
