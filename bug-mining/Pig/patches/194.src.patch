diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index e200fb267..f4524aba0 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -30,6 +30,7 @@ import org.apache.pig.PigException;
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
@@ -553,7 +554,6 @@ public class LOCogroup extends LogicalOperator {
         for(int inputNum = 0; (inputNum < predecessors.size()) && (!groupByAdded); ++inputNum) {
             LogicalOperator predecessor = predecessors.get(inputNum);
 
-            
             List<LogicalPlan> predecessorPlans = (ArrayList<LogicalPlan>) groupByPlans.get(predecessor);
 
             int inputColumn = -1;
@@ -612,4 +612,54 @@ public class LOCogroup extends LogicalOperator {
         return new ProjectionMap(mapFields, removedFields, addedFields);
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<LogicalOperator> predecessors = mPlan.getPredecessors(this);
+        
+        if(predecessors == null) {
+            return null;
+        }
+
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
+            Set<LOProject> projectSet = new HashSet<LOProject>();
+            boolean groupByStar = false;
+
+            for (LogicalPlan plan : getGroupByPlans().get(predecessors.get(inputNum))) {
+                TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(plan);
+                try {
+                    projectFinder.visit();
+                } catch (VisitorException ve) {
+                    requiredFields.clear();
+                    requiredFields.add(null);
+                    return requiredFields;
+                }
+                projectSet.addAll(projectFinder.getProjectSet());
+                if(projectFinder.getProjectStarSet() != null) {
+                    groupByStar = true;
+                }
+            }
+
+            if(groupByStar) {
+                requiredFields.add(new RequiredFields(true));
+            } else {                
+                for (LOProject project : projectSet) {
+                    for (int inputColumn : project.getProjection()) {
+                        fields.add(new Pair<Integer, Integer>(inputNum, inputColumn));
+                    }
+                }
+        
+                if(fields.size() == 0) {
+                    requiredFields.add(new RequiredFields(false, true));
+                } else {                
+                    requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
+                }
+            }
+        }
+        
+        return (requiredFields.size() == 0? null: requiredFields);
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCross.java b/src/org/apache/pig/impl/logicalLayer/LOCross.java
index 4efb613da..b24fda70d 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCross.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCross.java
@@ -33,6 +33,7 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
@@ -255,4 +256,21 @@ public class LOCross extends LogicalOperator {
         return new ProjectionMap(mapFields, null, addedFields);
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<LogicalOperator> predecessors = mPlan.getPredecessors(this);
+        
+        if(predecessors == null) {
+            return null;
+        }
+
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            requiredFields.add(new RequiredFields(true));
+        }
+        
+        return (requiredFields.size() == 0? null: requiredFields);
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LODistinct.java b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
index b49d30f3d..616fa2ac4 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODistinct.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
@@ -27,7 +27,9 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -156,5 +158,12 @@ public class LODistinct extends LogicalOperator {
             return null;
         }
     }
+    
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        requiredFields.add(new RequiredFields(false, true));
+        return requiredFields;
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
index 715a815ba..2450040cb 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
@@ -19,8 +19,10 @@ package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.List;
+import java.util.Set;
 import java.util.Map.Entry;
 
 import org.apache.commons.logging.Log;
@@ -32,6 +34,7 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
@@ -339,4 +342,54 @@ public class LOFRJoin extends LogicalOperator {
         return new ProjectionMap(mapFields, null, addedFields);
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {        
+        List<LogicalOperator> predecessors = mPlan.getPredecessors(this);
+        
+        if(predecessors == null) {
+            return null;
+        }
+        
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
+            Set<LOProject> projectSet = new HashSet<LOProject>();
+            boolean groupByStar = false;
+
+            for (LogicalPlan plan : this.getJoinColPlans().get(predecessors.get(inputNum))) {
+                TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(plan);
+                try {
+                    projectFinder.visit();
+                } catch (VisitorException ve) {
+                    requiredFields.clear();
+                    requiredFields.add(null);
+                    return requiredFields;
+                }
+                projectSet.addAll(projectFinder.getProjectSet());
+                if(projectFinder.getProjectStarSet() != null) {
+                    groupByStar = true;
+                }
+            }
+
+            if(groupByStar) {
+                requiredFields.add(new RequiredFields(true));
+            } else {                
+                for (LOProject project : projectSet) {
+                    for (int inputColumn : project.getProjection()) {
+                        fields.add(new Pair<Integer, Integer>(inputNum, inputColumn));
+                    }
+                }
+        
+                if(fields.size() == 0) {
+                    requiredFields.add(new RequiredFields(false, true));
+                } else {                
+                    requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
+                }
+            }
+        }
+        
+        return (requiredFields.size() == 0? null: requiredFields);
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFilter.java b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
index ff6e34cd4..fdc005fed 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
@@ -17,14 +17,18 @@
  */
 package org.apache.pig.impl.logicalLayer;
 
+import java.util.HashSet;
 import java.util.List;
 import java.util.ArrayList;
+import java.util.Set;
 
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.commons.logging.Log;
@@ -165,4 +169,38 @@ public class LOFilter extends LogicalOperator {
         }
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
+        TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(
+                mComparisonPlan);
+        try {
+            projectFinder.visit();
+        } catch (VisitorException ve) {
+            requiredFields.clear();
+            requiredFields.add(null);
+            return requiredFields;
+        }
+        Set<LOProject> projectStarSet = projectFinder.getProjectStarSet();
+
+        if (projectStarSet != null) {
+            requiredFields.add(new RequiredFields(true));
+            return requiredFields;
+        } else {
+            for (LOProject project : projectFinder.getProjectSet()) {
+                for (int inputColumn : project.getProjection()) {
+                    fields.add(new Pair<Integer, Integer>(0,
+                            inputColumn));
+                }
+            }
+            if(fields.size() == 0) {
+                requiredFields.add(new RequiredFields(false, true));
+            } else {                
+                requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
+            }
+            return (requiredFields.size() == 0? null: requiredFields);
+        }
+    }
+    
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 6a02060f0..9d5b47ee7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -18,6 +18,7 @@
 package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -30,13 +31,11 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.plan.OperatorKey;
-import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
-import org.apache.pig.impl.logicalLayer.parser.QueryParser ;
-import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -644,4 +643,46 @@ public class LOForEach extends LogicalOperator {
         return new ProjectionMap(mapFields, removedFields, addedFields);
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
+        Set<LOProject> projectSet = new HashSet<LOProject>();
+        boolean starRequired = false;
+
+        for (LogicalPlan plan : getForEachPlans()) {
+            TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(
+                    plan);
+            try {
+                projectFinder.visit();
+            } catch (VisitorException ve) {
+                requiredFields.clear();
+                requiredFields.add(null);
+                return requiredFields;
+            }
+            projectSet.addAll(projectFinder.getProjectSet());
+            if(projectFinder.getProjectStarSet() != null) {
+                starRequired = true;
+            }
+        }
+
+        if(starRequired) {
+            requiredFields.add(new RequiredFields(true));
+            return requiredFields;
+        } else {
+            for (LOProject project : projectSet) {
+                for (int inputColumn : project.getProjection()) {
+                    fields.add(new Pair<Integer, Integer>(0, inputColumn));
+                }
+            }
+    
+            if(fields.size() == 0) {
+                requiredFields.add(new RequiredFields(false, true));
+            } else {                
+                requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
+            }
+            return (requiredFields.size() == 0? null: requiredFields);
+        }
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLimit.java b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
index e05eb3ca3..89559df6b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLimit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
@@ -17,11 +17,16 @@
  */
 package org.apache.pig.impl.logicalLayer;
 
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.parser.QueryParser;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POLimit;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 
 public class LOLimit extends LogicalOperator {
@@ -109,4 +114,51 @@ public class LOLimit extends LogicalOperator {
         LOLimit limitClone = (LOLimit)super.clone();
         return limitClone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a distinct have to match!
+            return null;
+        }
+    }
+    
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        requiredFields.add(new RequiredFields(false, true));
+        return requiredFields;
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLoad.java b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
index ded51011c..ca7483097 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLoad.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
@@ -21,9 +21,10 @@ import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-
+import java.util.Set;
 import org.apache.pig.ExecType;
 import org.apache.pig.LoadFunc;
 import org.apache.pig.PigException;
@@ -33,6 +34,7 @@ import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
@@ -273,4 +275,11 @@ public class LOLoad extends LogicalOperator {
         }
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        requiredFields.add(new RequiredFields(false, true));
+        return requiredFields;
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSort.java b/src/org/apache/pig/impl/logicalLayer/LOSort.java
index 576600ca7..d4356a5f7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSort.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSort.java
@@ -19,17 +19,21 @@ package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Iterator;
+import java.util.Set;
 
 import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -242,5 +246,47 @@ public class LOSort extends LogicalOperator {
             return null;
         }
     }
+    
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
+        Set<LOProject> projectSet = new HashSet<LOProject>();
+        boolean orderByStar = false;
+
+        for (LogicalPlan plan : getSortColPlans()) {
+            TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(
+                    plan);
+            try {
+                projectFinder.visit();
+            } catch (VisitorException ve) {
+                requiredFields.clear();
+                requiredFields.add(null);
+                return requiredFields;
+            }
+            projectSet.addAll(projectFinder.getProjectSet());
+            if(projectFinder.getProjectStarSet() != null) {
+                orderByStar = true;
+            }
+        }
+
+        if(orderByStar) {
+            requiredFields.add(new RequiredFields(true));
+            return requiredFields;
+        } else {
+            for (LOProject project : projectSet) {
+                for (int inputColumn : project.getProjection()) {
+                    fields.add(new Pair<Integer, Integer>(0, inputColumn));
+                }
+            }
+    
+            if(fields.size() == 0) {
+                requiredFields.add(new RequiredFields(false, true));
+            } else {                
+                requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
+            }
+            return (requiredFields.size() == 0? null: requiredFields);
+        }
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplit.java b/src/org/apache/pig/impl/logicalLayer/LOSplit.java
index e0b84acfc..8ac6a443c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplit.java
@@ -27,6 +27,8 @@ import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
@@ -121,4 +123,50 @@ public class LOSplit extends LogicalOperator {
         LOSplit splitClone = (LOSplit)super.clone();
         return splitClone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a distinct have to match!
+            return null;
+        }
+    }
+    
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        requiredFields.add(new RequiredFields(false, true));
+        return requiredFields;
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
index efc53c51b..2aae791a9 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSplitOutput.java
@@ -19,15 +19,21 @@
 package org.apache.pig.impl.logicalLayer;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 
@@ -125,4 +131,77 @@ public class LOSplitOutput extends LogicalOperator {
         return splitOutputClone;
     }
 
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a split output have to match!
+            return null;
+        }
+    }
+
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        Set<Pair<Integer, Integer>> fields = new HashSet<Pair<Integer, Integer>>();
+        TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(
+                mCondPlan);
+        try {
+            projectFinder.visit();
+        } catch (VisitorException ve) {
+            requiredFields.clear();
+            requiredFields.add(null);
+            return requiredFields;
+        }
+        Set<LOProject> projectStarSet = projectFinder.getProjectStarSet();
+
+        if (projectStarSet != null) {
+            requiredFields.add(new RequiredFields(true));
+            return requiredFields;
+        } else {
+            for (LOProject project : projectFinder.getProjectSet()) {
+                for (int inputColumn : project.getProjection()) {
+                    fields.add(new Pair<Integer, Integer>(0,
+                            inputColumn));
+                }
+            }
+            if(fields.size() == 0) {
+                requiredFields.add(new RequiredFields(false, true));
+            } else {                
+                requiredFields.add(new RequiredFields(new ArrayList<Pair<Integer, Integer>>(fields)));
+            }
+            return (requiredFields.size() == 0? null: requiredFields);
+        }
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOStore.java b/src/org/apache/pig/impl/logicalLayer/LOStore.java
index 983c81a48..a66aef7b3 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOStore.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOStore.java
@@ -29,6 +29,7 @@ import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.PlanVisitor;
@@ -166,4 +167,11 @@ public class LOStore extends LogicalOperator {
         }
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        requiredFields.add(new RequiredFields(false, true));
+        return requiredFields;
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOStream.java b/src/org/apache/pig/impl/logicalLayer/LOStream.java
index 3300be2fe..a5ee2c425 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOStream.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOStream.java
@@ -20,13 +20,21 @@
  */
 package org.apache.pig.impl.logicalLayer;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.streaming.ExecutableManager;
 import org.apache.pig.impl.streaming.StreamingCommand;
 import org.apache.pig.impl.streaming.StreamingCommand.Handle;
 import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 
 /**
  * {@link LOStream} represents the specification of an external
@@ -169,4 +177,55 @@ public class LOStream extends LogicalOperator {
         return executableManager;
     }
 
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+                return null;
+        }
+        
+        List<Integer> addedFields = new ArrayList<Integer>();
+        List<Pair<Integer, Integer>> removedFields = new ArrayList<Pair<Integer, Integer>>();
+        
+        for(int i = 0; i < outputSchema.size(); ++i) {
+            //add all the elements of the output schema to the added fields
+            addedFields.add(i);
+        }
+        
+        if(inputSchema != null) {
+            //add all the elements of the input schema to the removed fields
+            for(int i = 0; i < inputSchema.size(); ++i) {
+                removedFields.add(new Pair<Integer, Integer>(0, i));
+            }
+        }
+        return new ProjectionMap(null, (removedFields.size() == 0? null: removedFields), addedFields);
+    }
+
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        requiredFields.add(new RequiredFields(true, false));
+        return requiredFields;
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index bf24c2757..114dbb535 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -29,6 +29,7 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
@@ -178,4 +179,21 @@ public class LOUnion extends LogicalOperator {
         return new ProjectionMap(mapFields, null, null);
     }
 
+    @Override
+    public List<RequiredFields> getRequiredFields() {
+        List<LogicalOperator> predecessors = mPlan.getPredecessors(this);
+        
+        if(predecessors == null) {
+            return null;
+        }
+
+        List<RequiredFields> requiredFields = new ArrayList<RequiredFields>();
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            requiredFields.add(new RequiredFields(true));
+        }
+        
+        return (requiredFields.size() == 0? null: requiredFields);
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
index e0e6495f9..7aa11421f 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
@@ -29,6 +29,7 @@ import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.Pair;
 import org.apache.commons.logging.Log;
@@ -292,15 +293,16 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
     };
 
     /**
-     * Get a list of fields that this operator requires.  This is not necessarily
-     * equivalent to the list of fields the operator projects.  For example,
-     * a filter will project anything passed to it, but requires only the fields
-     * explicitly referenced in its filter expression.
-     * @return list of fields, numbered from 0.
-     */
-    public List<Pair<Integer, Integer>> getRequiredFields()
-    {
-        return null;
-    }
+	 * Get a list of fields that this operator requires. This is not necessarily
+	 * equivalent to the list of fields the operator projects. For example, a
+	 * filter will project anything passed to it, but requires only the fields
+	 * explicitly referenced in its filter expression.
+	 * 
+	 * @return list of RequiredFields null indicates that the operator does not need any
+	 *         fields from its input.
+	 */
+	public List<RequiredFields> getRequiredFields() {
+		return null;
+	}
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java b/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java
new file mode 100644
index 000000000..b7bb28a66
--- /dev/null
+++ b/src/org/apache/pig/impl/logicalLayer/TopLevelProjectFinder.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.impl.logicalLayer;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.ArrayList;
+
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor to track the top-level projection operators in a plan.
+ * If there is a $1.$0 then only $1 is tracked 
+ */
+public class TopLevelProjectFinder extends
+        LOVisitor {
+	
+	List<LOProject> mProjectList = new ArrayList<LOProject>();
+
+    public TopLevelProjectFinder(LogicalPlan plan) {
+        super(plan, new DepthFirstWalker<LogicalOperator, LogicalPlan>(plan));
+    }
+
+
+    
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LODistinct)
+     */
+    @Override
+    protected void visit(LODistinct dt) throws VisitorException {
+    }
+
+
+
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LOFilter)
+     */
+    @Override
+    protected void visit(LOFilter filter) throws VisitorException {
+    }
+
+
+
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LOForEach)
+     */
+    @Override
+    protected void visit(LOForEach forEach) throws VisitorException {
+    }
+
+
+
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LOSort)
+     */
+    @Override
+    protected void visit(LOSort s) throws VisitorException {
+    }
+
+
+
+    /* (non-Javadoc)
+     * @see org.apache.pig.impl.logicalLayer.LOVisitor#visit(org.apache.pig.impl.logicalLayer.LOProject)
+     */
+    @Override
+    protected void visit(LOProject project) throws VisitorException {
+        //If the project is a root then add it to the list
+    	List<LogicalOperator> projectPreds = this.getPlan().getPredecessors(project);
+    	if(projectPreds == null) {
+        	//check if the project's predecessor is null then add it to the list
+    		mProjectList.add(project);
+    	} /*else if (!(projectPreds.get(0) instanceof LOProject)) {
+    		//check if the project's predecessor is not a project then add it to the list
+    		mProjectList.add(project);
+    	}*/
+    }
+    
+    public List<LOProject> getProjectList() {
+    	return mProjectList;
+    }
+    
+    public Set<LOProject> getProjectSet() {
+    	return new HashSet<LOProject>(mProjectList);
+    }
+    
+    public Set<LOProject> getProjectStarSet() {
+    	Set<LOProject> projectStarSet = new HashSet<LOProject>();
+    	
+    	for(LOProject project: getProjectSet()) {
+    		if(project.isStar() && (this.getPlan().getPredecessors(project) == null)) {
+    			projectStarSet.add(project);
+    		}
+    	}
+    	
+    	return (projectStarSet.size() == 0? null : projectStarSet);
+    }
+}
diff --git a/src/org/apache/pig/impl/plan/ProjectionMap.java b/src/org/apache/pig/impl/plan/ProjectionMap.java
index 019a4039b..cae2e8451 100644
--- a/src/org/apache/pig/impl/plan/ProjectionMap.java
+++ b/src/org/apache/pig/impl/plan/ProjectionMap.java
@@ -18,13 +18,9 @@
 
 package org.apache.pig.impl.plan;
 
-import java.io.Serializable;
 import java.lang.StringBuilder;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Map;
 
-import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
 
@@ -107,7 +103,7 @@ public class ProjectionMap {
      * 
      * @return the mapping of input column to output column
      */
-    public MultiMap<Integer, Pair<Integer, Integer>> getMappedFileds() {
+    public MultiMap<Integer, Pair<Integer, Integer>> getMappedFields() {
         return mMappedFields;
     }
 
@@ -116,7 +112,7 @@ public class ProjectionMap {
      * @param fields
      *            the mapping of input column to output column
      */
-    public void setMappedFileds(MultiMap<Integer, Pair<Integer, Integer>> fields) {
+    public void setMappedFields(MultiMap<Integer, Pair<Integer, Integer>> fields) {
         mMappedFields = fields;
     }
 
@@ -124,7 +120,7 @@ public class ProjectionMap {
      * 
      * @return the list of input columns that are removed
      */
-    public List<Pair<Integer, Integer>> getRemovedFileds() {
+    public List<Pair<Integer, Integer>> getRemovedFields() {
         return mRemovedFields;
     }
 
@@ -133,7 +129,7 @@ public class ProjectionMap {
      * @param fields
      *            the list of input columns that are removed
      */
-    public void setRemovedFileds(List<Pair<Integer, Integer>> fields) {
+    public void setRemovedFields(List<Pair<Integer, Integer>> fields) {
         mRemovedFields = fields;
     }
 
@@ -141,7 +137,7 @@ public class ProjectionMap {
      * 
      * @return the list of columns that are added to the output
      */
-    public List<Integer> getAddedFileds() {
+    public List<Integer> getAddedFields() {
         return mAddedFields;
     }
 
@@ -150,7 +146,7 @@ public class ProjectionMap {
      * @param fields
      *            the list of columns that are added to the output
      */
-    public void setAddedFileds(List<Integer> fields) {
+    public void setAddedFields(List<Integer> fields) {
         mAddedFields = fields;
     }
 
diff --git a/src/org/apache/pig/impl/plan/RequiredFields.java b/src/org/apache/pig/impl/plan/RequiredFields.java
new file mode 100644
index 000000000..d75f98c6e
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/RequiredFields.java
@@ -0,0 +1,185 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.impl.plan;
+
+import java.lang.StringBuilder;
+import java.util.List;
+
+import org.apache.pig.impl.util.Pair;
+
+/**
+ * A struct detailing how a projection is altered by an operator.
+ */
+public class RequiredFields {
+    /**
+     * Quick way for an operator to note that all columns from an input are required.
+     */
+    private boolean mNeedAllFields = false;
+    
+    /**
+     * Quick way for an operator to note that no columns from an input are required.
+     */
+    private boolean mNeedNoFields = false;
+
+
+    /**
+     * List of fields required from the input. This includes fields that are
+     * transformed, and thus are no longer the same fields. Using the example 'B
+     * = foreach A generate $0, $2, $3, udf($1)' would produce the list (0, 0),
+     * (0, 2), (0, 3), (0, 1). Note that the order is not guaranteed.
+     */
+    private List<Pair<Integer, Integer>> mFields;
+
+    /**
+     * 
+     * @param needAllFields
+     *            to indicate if this required fields needs all the fields from
+     *            its input
+     */
+    public RequiredFields(boolean needAllFields) {
+        this(null, needAllFields, false);
+    }
+    
+    /**
+     * 
+     * @param needAllFields
+     *            to indicate if this required fields needs no fields from
+     *            its input
+     */
+    public RequiredFields(boolean needAllFields, boolean needNoFields) {
+        this(null, needAllFields, needNoFields);
+    }
+
+    /**
+     * 
+     * @param fields
+     *            the list of input columns that are required
+     */
+    public RequiredFields(List<Pair<Integer, Integer>> fields) {
+        this(fields, false, false);
+    }
+
+    /**
+     * 
+     * @param fields
+     *            the list of input columns that are required
+     * @param needAllFields
+     *            to indicate if this required fields needs all the fields from
+     *            its input; cannot be true if needNoFields is true
+     * @param needNoFields
+     *            to indicate if this required fields needs no fields from
+     *            its input; cannot be true if needAllFields is true
+     */
+    private RequiredFields(List<Pair<Integer, Integer>> removedFields,
+            boolean needAllFields,
+            boolean needNoFields) {
+        mFields = removedFields;
+        if(needAllFields && needNoFields) {
+            //both cannot be true
+            //set both of them to false
+            mNeedAllFields = false;
+            mNeedNoFields = false;
+        } else {
+            mNeedAllFields = needAllFields;
+            mNeedNoFields = needNoFields;
+        }
+    }
+
+    /**
+     * 
+     * @return the list of input columns that are required
+     */
+    public List<Pair<Integer, Integer>> getFields() {
+        return mFields;
+    }
+
+    /**
+     * 
+     * @param fields
+     *            the list of input columns that are required
+     */
+    public void setFields(List<Pair<Integer, Integer>> fields) {
+        mFields = fields;
+    }
+
+    /**
+     * 
+     * @return if this required fields needs all the fields from its input(s)
+     */
+    public boolean needAllFields() {
+        return getNeedAllFields();
+    }
+
+    /**
+     * 
+     * @return if this required fields needs all the fields from its input(s)
+     */
+    public boolean getNeedAllFields() {
+        return mNeedAllFields;
+    }
+
+    /**
+     * 
+     * @param needAllFields
+     *            to indicate if this required fields needs all the fields from
+     *            its input; cannot be true if needNoFields() is true
+     */
+    public void setNeedAllFields(boolean needAllFields) {
+        if(needAllFields && needNoFields()) return;
+        mNeedAllFields = needAllFields;
+    }
+
+    /**
+     * 
+     * @return if this required fields needs no fields from its input(s)
+     */
+    public boolean needNoFields() {
+        return getNeedNoFields();
+    }
+
+    /**
+     * 
+     * @return if this required fields needs no fields from its input(s)
+     */
+    public boolean getNeedNoFields() {
+        return mNeedNoFields;
+    }
+
+    /**
+     * 
+     * @param needNoFields
+     *            to indicate if this required fields needs no fields from
+     *            its input; cannot be true if needAllFields() is true
+     */
+    public void setNeedNoFields(boolean needNoFields) {
+        if(needNoFields && needAllFields()) return;
+        mNeedNoFields = needNoFields;
+    }
+    
+
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("needAllFields: " + mNeedAllFields);
+        sb.append(" needNoFields: " + mNeedNoFields);
+        sb.append(" fields: " + mFields);
+        return sb.toString();
+    }
+}
\ No newline at end of file
diff --git a/src/org/apache/pig/impl/util/Pair.java b/src/org/apache/pig/impl/util/Pair.java
index 51ae63749..eaf739bde 100644
--- a/src/org/apache/pig/impl/util/Pair.java
+++ b/src/org/apache/pig/impl/util/Pair.java
@@ -42,4 +42,45 @@ public class Pair<T, U> implements Serializable {
     public String toString() {
         return "[" + first.toString() +"," + second.toString() + "]";
     }
+
+    @Override
+    public int hashCode() {
+        return (((this.first == null ? 1 : this.first.hashCode()) * 17)
+                + (this.second == null ? 1 : this.second.hashCode()) * 19);
+    }
+    
+    @Override
+    public boolean equals(Object other) {
+        if(other == null) {
+            return false;
+        }
+        
+        if(! (other instanceof Pair)) {
+            return false;
+        }
+        
+        Pair otherPair = (Pair) other;
+        
+        if(this.first == null) {
+            if(otherPair.first != null) {
+                return false;
+            } else {
+                return true;
+            }
+        }
+        
+        if(this.second == null) {
+            if(otherPair.second != null) {
+                return false;
+            } else {
+                return true;
+            }
+        }
+        
+        if(this.first.equals(otherPair.first) && this.second.equals(otherPair.second)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
 }
diff --git a/test/org/apache/pig/test/TestProjectionMap.java b/test/org/apache/pig/test/TestProjectionMap.java
index 4d130d2b9..e8e9389da 100644
--- a/test/org/apache/pig/test/TestProjectionMap.java
+++ b/test/org/apache/pig/test/TestProjectionMap.java
@@ -17,51 +17,21 @@
  */
 package org.apache.pig.test;
 
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Random;
-import java.net.URL;
 import java.util.List;
 import java.util.ArrayList;
-import java.util.Set;
 
-import junit.framework.AssertionFailedError;
 
 import org.junit.After;
-import org.junit.Before;
 import org.junit.Test;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.pig.LoadFunc;
-import org.apache.pig.FuncSpec;
-import org.apache.pig.PigServer;
-import org.apache.pig.backend.datastorage.DataStorage;
 import org.apache.pig.builtin.PigStorage;
-import org.apache.pig.data.DataBag;
-import org.apache.pig.data.Tuple;
-import org.apache.pig.data.TupleFactory;
-import org.apache.pig.impl.PigContext;
-import org.apache.pig.ExecType;
-import org.apache.pig.impl.builtin.GFAny;
-import org.apache.pig.impl.io.BufferedPositionedInputStream;
-import org.apache.pig.impl.io.FileLocalizer;
-import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.logicalLayer.*;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
-import org.apache.pig.data.DataType;
-import org.apache.pig.impl.logicalLayer.parser.ParseException ;
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
-import org.apache.pig.test.utils.Identity;
 import org.apache.pig.test.utils.LogicalPlanTester;
-import org.apache.pig.impl.util.LogUtils;
-import org.apache.pig.PigException;
 
 
 public class TestProjectionMap extends junit.framework.TestCase {
@@ -75,6 +45,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         planTester.reset(); 
     }
 
+    private static final String simpleEchoStreamingCommand;
+    static {
+        if (System.getProperty("os.name").toUpperCase().startsWith("WINDOWS"))
+            simpleEchoStreamingCommand = "perl -ne 'print \\\"$_\\\"'";
+        else
+            simpleEchoStreamingCommand = "perl -ne 'print \"$_\"'";
+    }
+
     
     @Test
     public void testQueryForeach1() {
@@ -91,11 +69,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        assertTrue(foreachProjectionMap.getMappedFileds() == null);
-        assertTrue(foreachProjectionMap.getRemovedFileds() == null);
+        assertTrue(foreachProjectionMap.getMappedFields() == null);
+        assertTrue(foreachProjectionMap.getRemovedFields() == null);
         
         //check that added fields contain [0, 1]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields.size() == 2);
         assertTrue(foreachAddedFields.get(0) == 0);
         assertTrue(foreachAddedFields.get(1) == 1);
@@ -116,11 +94,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        assertTrue(foreachProjectionMap.getMappedFileds() == null);
-        assertTrue(foreachProjectionMap.getRemovedFileds() == null);
+        assertTrue(foreachProjectionMap.getMappedFields() == null);
+        assertTrue(foreachProjectionMap.getRemovedFields() == null);
         
         //check that added fields contain [0, 1]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields.size() == 2);
         assertTrue(foreachAddedFields.get(0) == 0);
         assertTrue(foreachAddedFields.get(1) == 1);
@@ -136,7 +114,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
         assertTrue(loadaProjectionMap == null);
         
-        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap == null);
 
@@ -145,7 +123,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -155,10 +133,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(1).second == 1);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -167,11 +145,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        assertTrue(foreachProjectionMap.getMappedFileds() == null);
+        assertTrue(foreachProjectionMap.getMappedFields() == null);
 
         //check that removed fields has all the columns from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
-        assertTrue(foreachProjectionMap.getRemovedFileds().size() == 3);
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
+        assertTrue(foreachProjectionMap.getRemovedFields().size() == 3);
         int expectedColumn = 0;
         for(Pair<Integer, Integer> removedField: foreachRemovedFields) {
             assertTrue(removedField.first == 0);
@@ -179,7 +157,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         }
         
         //check that added fields contain [0]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields.size() == 1);
         assertTrue(foreachAddedFields.get(0) == 0);
     }
@@ -194,23 +172,19 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
         assertTrue(loadaProjectionMap == null);
         
-        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
-        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
-
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields == null);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [0, 1]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 0);
         assertTrue(cogroupAddedFields.get(1) == 1);
@@ -219,7 +193,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMappedFields = foreachProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMappedFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMappedFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMappedFields.get(0);
@@ -228,7 +202,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
 
 
         //check that removed fields has all the columns from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
 
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
@@ -236,7 +210,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(removedField.second == 0);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
 
@@ -250,16 +224,12 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
         assertTrue(loadaProjectionMap == null);
         
-        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
-        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
-        assertTrue(loadbProjectionMap == null);
-
         //check cogroup projection map
         LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -267,10 +237,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(0).second == 1);
 
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [0, 1]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 1);
         assertTrue(cogroupAddedFields.get(0) == 1);
         
@@ -279,7 +249,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);        
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
         mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -288,7 +258,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
 
 
         //check that removed fields has all the columns from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
 
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
@@ -296,7 +266,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(removedField.second == 1);
         
         //check that added fields contain [1]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields != null);
         assertTrue(foreachAddedFields.size() == 1);
         assertTrue(foreachAddedFields.get(0) == 1);
@@ -312,7 +282,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap loadaProjectionMap = loada.getProjectionMap();
         assertTrue(loadaProjectionMap == null);
         
-        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
         ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
         assertTrue(loadbProjectionMap == null);
 
@@ -321,7 +291,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -331,10 +301,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(1).second == 1);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -344,7 +314,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
         mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -356,14 +326,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(0).second == 2);
 
         //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 0);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
 
@@ -382,7 +352,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
 
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -392,10 +362,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(1).second == 7);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 1);
         assertTrue(cogroupAddedFields.get(0) == 1);
         
@@ -404,7 +374,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
         mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -416,14 +386,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(0).second == 0);
 
         //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 1);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
 
     }
@@ -444,6 +414,30 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(filterProjectionMap == null);
     }
     
+    @Test
+    public void testQuerySplitNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("split a into b if $0 == '3', c if $1 == '3';");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the split projection map has null mappedFields
+        LOSplit split = (LOSplit)lp.getSuccessors(load).get(0);
+        ProjectionMap splitProjectionMap = split.getProjectionMap();
+        assertTrue(splitProjectionMap == null);
+        
+        LOSplitOutput splitb = (LOSplitOutput)lp.getSuccessors(split).get(0);
+        ProjectionMap splitbProjectionMap = splitb.getProjectionMap();
+        assertTrue(splitbProjectionMap == null);
+        
+        LOSplitOutput splitc = (LOSplitOutput)lp.getSuccessors(split).get(1);
+        ProjectionMap splitcProjectionMap = splitc.getProjectionMap();
+        assertTrue(splitcProjectionMap == null);
+    }
+    
     @Test
     public void testQueryOrderByNoSchema() {
         planTester.buildPlan("a = load 'a';");
@@ -460,6 +454,28 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(sortProjectionMap == null);
     }
     
+    @Test
+    public void testQueryLimitNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        planTester.buildPlan("b = order a by $1;");
+        LogicalPlan lp = planTester.buildPlan("c = limit b 10;");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the order by projection map is not null
+        LOSort sort = (LOSort)lp.getSuccessors(load).get(0);
+        ProjectionMap sortProjectionMap = sort.getProjectionMap();
+        assertTrue(sortProjectionMap == null);
+        
+        //check that the limit projection map is null
+        LOLimit limit = (LOLimit)lp.getLeaves().get(0);
+        ProjectionMap limitProjectionMap = limit.getProjectionMap();
+        assertTrue(limitProjectionMap == null);
+    }
+    
     @Test
     public void testQueryDistinctNoSchema() {
         planTester.buildPlan("a = load 'a';");
@@ -476,6 +492,38 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(distinctProjectionMap == null);
     }
     
+    @Test
+    public void testQueryStreamingNoSchema() {
+        String query = "stream (load 'a') through `" + simpleEchoStreamingCommand + "`;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the stream projection map is null
+        LOStream stream = (LOStream)lp.getLeaves().get(0);
+        ProjectionMap streamProjectionMap = stream.getProjectionMap();
+        assertTrue(streamProjectionMap == null);
+    }
+    
+    @Test
+    public void testQueryStreamingNoSchema1() {
+        String query = "stream (load 'a' as (url, hitCount)) through `" + simpleEchoStreamingCommand + "` ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the stream projection map is null
+        LOStream stream = (LOStream)lp.getLeaves().get(0);
+        ProjectionMap streamProjectionMap = stream.getProjectionMap();
+        assertTrue(streamProjectionMap == null);
+    }
+    
     @Test
     public void testQueryForeach3() {
         String query = "foreach (load 'a') generate ($1 == '3'? $2 : $3) ;";
@@ -491,11 +539,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
-        assertTrue(foreachProjectionMap.getMappedFileds() == null);
-        assertTrue(foreachProjectionMap.getRemovedFileds() == null);
+        assertTrue(foreachProjectionMap.getMappedFields() == null);
+        assertTrue(foreachProjectionMap.getRemovedFields() == null);
         
         //check that added fields contain [0]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields.size() == 1);
         assertTrue(foreachAddedFields.get(0) == 0);
     }
@@ -520,7 +568,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -530,10 +578,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(cogroupMapValues.get(1).second == 1);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -543,7 +591,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
         List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -557,14 +605,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         }
         
         //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
-        assertTrue(foreachProjectionMap.getRemovedFileds().size() == 1);
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
+        assertTrue(foreachProjectionMap.getRemovedFields().size() == 1);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 0);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
     
@@ -593,7 +641,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -603,10 +651,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(cogroupMapValues.get(1).second == 1);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -616,7 +664,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
         List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -624,8 +672,8 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(foreachMapValues.get(0).second == 1);
         
         //check that removed fields has all the columns from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
-        assertTrue(foreachProjectionMap.getRemovedFileds().size() == 2);
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
+        assertTrue(foreachProjectionMap.getRemovedFields().size() == 2);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 0);
@@ -635,7 +683,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(removedField.second == 2);
 
         //check that added fields contain [0]
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields.size() == 1);
         assertTrue(foreachAddedFields.get(0) == 1);
     }
@@ -723,7 +771,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -733,10 +781,10 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(1).second == 0);
         
         //check the cogroup removed fields is null
-        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        assertTrue(cogroupProjectionMap.getRemovedFields() == null);
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -746,7 +794,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
         mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -758,14 +806,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(0).second == 2);
 
         //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 0);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
     
@@ -786,6 +834,30 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(filterProjectionMap.changes() == false);
     }
     
+    @Test
+    public void testQuerySplitWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        LogicalPlan lp = planTester.buildPlan("split a into b if url == '3', c if hitCount == '3';");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the split projection map has null mappedFields
+        LOSplit split = (LOSplit)lp.getSuccessors(load).get(0);
+        ProjectionMap splitProjectionMap = split.getProjectionMap();
+        assertTrue(splitProjectionMap.changes() == false);
+        
+        LOSplitOutput splitb = (LOSplitOutput)lp.getSuccessors(split).get(0);
+        ProjectionMap splitbProjectionMap = splitb.getProjectionMap();
+        assertTrue(splitbProjectionMap.changes() == false);
+        
+        LOSplitOutput splitc = (LOSplitOutput)lp.getSuccessors(split).get(1);
+        ProjectionMap splitcProjectionMap = splitc.getProjectionMap();
+        assertTrue(splitcProjectionMap.changes() == false);
+    }
+    
     @Test
     public void testQueryOrderByWithSchema() {
         planTester.buildPlan("a = load 'a' as (url,hitCount);");
@@ -803,6 +875,30 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(sortProjectionMap.changes() == false);
     }
     
+    @Test
+    public void testQueryLimitWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        planTester.buildPlan("b = order a by $1;");
+        LogicalPlan lp = planTester.buildPlan("c = limit b 10;");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the order by projection map is not null
+        LOSort sort = (LOSort)lp.getSuccessors(load).get(0);
+        ProjectionMap sortProjectionMap = sort.getProjectionMap();
+        assertTrue(sortProjectionMap != null);
+        assertTrue(sortProjectionMap.changes() == false);
+        
+        //check that the limit projection map is not null
+        LOLimit limit = (LOLimit)lp.getLeaves().get(0);
+        ProjectionMap limitProjectionMap = limit.getProjectionMap();
+        assertTrue(limitProjectionMap != null);
+        assertTrue(limitProjectionMap.changes() == false);
+    }
+    
     @Test
     public void testQueryDistinctWithSchema() {
         planTester.buildPlan("a = load 'a' as (url,hitCount);");
@@ -820,6 +916,61 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(distinctProjectionMap.changes() == false);
     }
 
+    @Test
+    public void testQueryStreamingWithSchema() {
+        String query = "stream (load 'a') through `" + simpleEchoStreamingCommand + "` as (x, y);";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the stream projection map is null
+        LOStream stream = (LOStream)lp.getLeaves().get(0);
+        ProjectionMap streamProjectionMap = stream.getProjectionMap();
+        assertTrue(streamProjectionMap.changes() == true);
+        assertTrue(streamProjectionMap.getMappedFields() == null);
+        assertTrue(streamProjectionMap.getRemovedFields() == null);
+        
+        List<Integer> streamAddedFields = streamProjectionMap.getAddedFields();
+        assertTrue(streamAddedFields.size() == 2);
+        assertTrue(streamAddedFields.get(0) == 0);
+        assertTrue(streamAddedFields.get(1) == 1);
+    }
+
+    @Test
+    public void testQueryStreamingWithSchema1() {
+        String query = "stream (load 'a' as (url, hitCount)) through `" + simpleEchoStreamingCommand + "` as (x, y);";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the stream projection map is null
+        LOStream stream = (LOStream)lp.getLeaves().get(0);
+        ProjectionMap streamProjectionMap = stream.getProjectionMap();
+        assertTrue(streamProjectionMap.changes() == true);
+        assertTrue(streamProjectionMap.getMappedFields() == null);
+        
+        //check that removed fields has all the columns from the input load
+        List<Pair<Integer, Integer>> streamRemovedFields = streamProjectionMap.getRemovedFields();
+        assertTrue(streamRemovedFields.size() == 2);
+        Pair<Integer, Integer> removedField = streamRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        removedField = streamRemovedFields.get(1);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 1);
+        
+        List<Integer> streamAddedFields = streamProjectionMap.getAddedFields();
+        assertTrue(streamAddedFields.size() == 2);
+        assertTrue(streamAddedFields.get(0) == 0);
+        assertTrue(streamAddedFields.get(1) == 1);
+    }
     
     @Test
     public void testQueryImplicitJoinWithSchema() {
@@ -842,7 +993,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -852,7 +1003,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(cogroupMapValues.get(1).second == 0);
         
         //check that removed fields has hitCount from a and rank from b
-        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
         assertTrue(cogroupRemovedFields.size() == 2);
         Pair<Integer, Integer> removedField = cogroupRemovedFields.get(0);
         assertTrue(removedField.first == 0);
@@ -864,7 +1015,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
 
         
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -874,7 +1025,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
         List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -898,11 +1049,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(foreachMapValues.get(0).second == 2);
         
         //check that removed fields is null
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields == null);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
         
         lp = planTester.buildPlan("e = foreach d generate group, a::url, b::url, b::rank, rank;");
@@ -911,7 +1062,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        foreachMapFields = foreachProjectionMap.getMappedFileds();
+        foreachMapFields = foreachProjectionMap.getMappedFields();
         assertTrue(foreachMapFields != null);
         
         foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -935,7 +1086,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(foreachMapValues.get(0).second == 4);
         
         //check that removed fields is null
-        foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields != null);
         assertTrue(foreachRemovedFields.size() == 1);
         
@@ -944,7 +1095,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(removedField.second == 2);
         
         //check that added fields is null
-        foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
     
@@ -967,7 +1118,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap crossProjectionMap = cross.getProjectionMap();
         assertTrue(crossProjectionMap != null);
         
-        MultiMap<Integer, Pair<Integer, Integer>> crossMapFields = crossProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> crossMapFields = crossProjectionMap.getMappedFields();
         assertTrue(crossMapFields != null);
         
         List<Pair<Integer, Integer>> crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(0);
@@ -987,11 +1138,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(crossMapValues.get(0).second == 1);
         
         //check that removed fields is null
-        List<Pair<Integer, Integer>> crossRemovedFields = crossProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> crossRemovedFields = crossProjectionMap.getRemovedFields();
         assertTrue(crossRemovedFields == null);
         
         //check that added fields is null
-        List<Integer> crossAddedFields = crossProjectionMap.getAddedFileds();
+        List<Integer> crossAddedFields = crossProjectionMap.getAddedFields();
         assertTrue(crossAddedFields == null);
     }
     
@@ -1014,7 +1165,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap unionProjectionMap = union.getProjectionMap();
         assertTrue(unionProjectionMap != null);
         
-        MultiMap<Integer, Pair<Integer, Integer>> unionMapFields = unionProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> unionMapFields = unionProjectionMap.getMappedFields();
         assertTrue(unionMapFields != null);
 
         List<Pair<Integer, Integer>> unionMapValues = (ArrayList<Pair<Integer, Integer>>)unionMapFields.get(0);
@@ -1032,11 +1183,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(unionMapValues.get(1).second == 1);
         
         //check that removed fields is null
-        List<Pair<Integer, Integer>> unionRemovedFields = unionProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> unionRemovedFields = unionProjectionMap.getRemovedFields();
         assertTrue(unionRemovedFields == null);
         
         //check that added fields is null
-        List<Integer> unionAddedFields = unionProjectionMap.getAddedFileds();
+        List<Integer> unionAddedFields = unionProjectionMap.getAddedFields();
         assertTrue(unionAddedFields == null);
 
     }
@@ -1060,7 +1211,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
         assertTrue(frjoinProjectionMap != null);
         
-        MultiMap<Integer, Pair<Integer, Integer>> frjoinMapFields = frjoinProjectionMap.getMappedFileds();
+        MultiMap<Integer, Pair<Integer, Integer>> frjoinMapFields = frjoinProjectionMap.getMappedFields();
         assertTrue(frjoinMapFields != null);
 
         List<Pair<Integer, Integer>> frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(0);
@@ -1080,11 +1231,11 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(frjoinMapValues.get(0).second == 1);
         
         //check that removed fields is null
-        List<Pair<Integer, Integer>> frjoinRemovedFields = frjoinProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> frjoinRemovedFields = frjoinProjectionMap.getRemovedFields();
         assertTrue(frjoinRemovedFields == null);
         
         //check that added fields is null
-        List<Integer> frjoinAddedFields = frjoinProjectionMap.getAddedFileds();
+        List<Integer> frjoinAddedFields = frjoinProjectionMap.getAddedFields();
         assertTrue(frjoinAddedFields == null);
 
     }
@@ -1108,7 +1259,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -1118,7 +1269,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(1).second == 0);
         
         //check that removed fields is not null
-        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
         assertTrue(cogroupRemovedFields != null);
         
         Pair<Integer, Integer> removedFields = cogroupRemovedFields.get(0);
@@ -1130,7 +1281,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(removedFields.second == 1);
 
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -1140,7 +1291,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields != null);
         
         mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -1161,14 +1312,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
 
         
         //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 0);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
 
@@ -1252,7 +1403,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
         assertTrue(cogroupProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFields(); 
         assertTrue(cogroupMapFields != null);
         
         List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
@@ -1262,7 +1413,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(mapValues.get(1).second == 0);
         
         //check that removed fields is not null
-        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFields();
         assertTrue(cogroupRemovedFields.size() == 1);
         
         Pair<Integer, Integer> removedFields = cogroupRemovedFields.get(0);
@@ -1270,7 +1421,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         assertTrue(removedFields.second == 1);
 
         //check that cogroup added fields contain [1, 2]
-        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFields();
         assertTrue(cogroupAddedFields.size() == 2);
         assertTrue(cogroupAddedFields.get(0) == 1);
         assertTrue(cogroupAddedFields.get(1) == 2);
@@ -1280,7 +1431,7 @@ public class TestProjectionMap extends junit.framework.TestCase {
         ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
         assertTrue(foreachProjectionMap.changes() == true);
         
-        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFields(); 
         assertTrue(foreachMapFields.size() == 3);
         
         mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
@@ -1297,14 +1448,14 @@ public class TestProjectionMap extends junit.framework.TestCase {
 
         
         //check that removed fields has all the group column from the input cogroup
-        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFields();
         assertTrue(foreachRemovedFields.size() == 1);
         Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
         assertTrue(removedField.first == 0);
         assertTrue(removedField.second == 0);
         
         //check that added fields is null
-        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFields();
         assertTrue(foreachAddedFields == null);
     }
     
diff --git a/test/org/apache/pig/test/TestRequiredFields.java b/test/org/apache/pig/test/TestRequiredFields.java
new file mode 100644
index 000000000..5410421eb
--- /dev/null
+++ b/test/org/apache/pig/test/TestRequiredFields.java
@@ -0,0 +1,2350 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.test;
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Set;
+
+import org.junit.After;
+import org.junit.Test;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.pig.builtin.PigStorage;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.plan.RequiredFields;
+import org.apache.pig.impl.logicalLayer.*;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
+import org.apache.pig.test.utils.LogicalPlanTester;
+
+
+public class TestRequiredFields extends junit.framework.TestCase {
+
+    private final Log log = LogFactory.getLog(getClass());
+    LogicalPlanTester planTester = new LogicalPlanTester();
+    
+    @After
+    @Override
+    public void tearDown() throws Exception{
+        planTester.reset(); 
+    }
+
+    private static final String simpleEchoStreamingCommand;
+    static {
+        if (System.getProperty("os.name").toUpperCase().startsWith("WINDOWS"))
+            simpleEchoStreamingCommand = "perl -ne 'print \\\"$_\\\"'";
+        else
+            simpleEchoStreamingCommand = "perl -ne 'print \"$_\"'";
+    }
+
+    @Test
+    public void testQueryForeach1() {
+        String query = "foreach (load 'a') generate $1,$2;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load required fields is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadRequiredFields = load.getRequiredFields();
+        assertTrue(loadRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+        
+    }
+
+    @Test
+    public void testQueryForeach2() {
+        String query = "foreach (load 'a' using " + PigStorage.class.getName() + "(':')) generate $1, 'aoeuaoeu' ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load required fields is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadRequiredFields = load.getRequiredFields();
+        assertTrue(loadRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryCogroup1() {
+        String query = "foreach (cogroup (load 'a') by $1, (load 'b') by $1) generate org.apache.pig.builtin.AVG($1) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 1);
+        
+        //check that the foreach required fields contain [<0, 1>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryGroupAll() throws Exception {
+        String query = "foreach (group (load 'a') ALL) generate $1 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 1);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryGroup2() {
+        String query = "foreach (group (load 'a') by $1) generate group, '1' ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 1);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        
+        //check that the foreach required fields contain [<0, 0>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+    }
+
+    @Test
+    public void testQueryCogroup2() {
+        String query = "foreach (cogroup (load 'a') by ($1), (load 'b') by ($1)) generate $1.$1, $2.$1 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 1);
+        
+        //check that the foreach required fields contain [<0, 1>, <0,2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+    }
+
+    @Test
+    public void testQueryGroup3() {
+        String query = "foreach (group (load 'a') by ($6, $7)) generate flatten(group) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 1);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 6);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 7);
+        
+        //check that the foreach required fields contain [<0, 0>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+    }
+
+    @Test
+    public void testQueryFilterNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = filter a by $1 == '3';");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check filter required fields
+        LOFilter filter = (LOFilter)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> filterRequiredFields = filter.getRequiredFields();
+        assertTrue(filterRequiredFields.size() == 1);
+        
+        requiredField = filterRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+    
+    @Test
+    public void testQuerySplitNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("split a into b if $0 == '3', c if $1 == '3';");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOSplit split = (LOSplit)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> splitRequiredFields = split.getRequiredFields();
+        assertTrue(splitRequiredFields.size() == 1);
+        
+        requiredField = splitRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check split outputs' required fields
+        LOSplitOutput splitb = (LOSplitOutput)lp.getSuccessors(split).get(0);
+        List<RequiredFields> splitbRequiredFields = splitb.getRequiredFields();
+        assertTrue(splitbRequiredFields.size() == 1);
+        
+        requiredField = splitbRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        LOSplitOutput splitc = (LOSplitOutput)lp.getSuccessors(split).get(1);
+        List<RequiredFields> splitcRequiredFields = splitc.getRequiredFields();
+        assertTrue(splitcRequiredFields.size() == 1);
+        
+        requiredField = splitcRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryOrderByNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = order a by $1;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check order by required fields
+        LOSort sort = (LOSort)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> sortRequiredFields = sort.getRequiredFields();
+        assertTrue(sortRequiredFields.size() == 1);
+        
+        requiredField = sortRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+    
+    @Test
+    public void testQueryLimitNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        planTester.buildPlan("b = order a by $1;");
+        LogicalPlan lp = planTester.buildPlan("c = limit b 10;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check order by required fields
+        LOSort sort = (LOSort)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> sortRequiredFields = sort.getRequiredFields();
+        assertTrue(sortRequiredFields.size() == 1);
+        
+        requiredField = sortRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+
+        //check limit required fields
+        LOLimit limit = (LOLimit)lp.getLeaves().get(0);
+        List<RequiredFields> limitRequiredFields = limit.getRequiredFields();
+        assertTrue(limitRequiredFields.size() == 1);
+        
+        requiredField = limitRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+
+    @Test
+    public void testQueryDistinctNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = distinct a;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check distinct required fields
+        LODistinct distinct = (LODistinct)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> distinctRequiredFields = distinct.getRequiredFields();
+        assertTrue(distinctRequiredFields.size() == 1);
+        
+        requiredField = distinctRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+
+    @Test
+    public void testQueryStreamingNoSchema() {
+        String query = "stream (load 'a') through `" + simpleEchoStreamingCommand + "`;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check streaming required fields
+        LOStream stream = (LOStream)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> streamRequiredFields = stream.getRequiredFields();
+        assertTrue(streamRequiredFields.size() == 1);
+        
+        requiredField = streamRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+    
+    @Test
+    public void testQueryStreamingNoSchema1() {
+        String query = "stream (load 'a' as (url, hitCount)) through `" + simpleEchoStreamingCommand + "` ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check streaming required fields
+        LOStream stream = (LOStream)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> streamRequiredFields = stream.getRequiredFields();
+        assertTrue(streamRequiredFields.size() == 1);
+        
+        requiredField = streamRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+    
+    @Test
+    public void testQueryForeach3() {
+        String query = "foreach (load 'a') generate ($1 == '3'? $2 : $3) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>, <0,3>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 3);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+        assertTrue(fields.get(2).first == 0);
+        assertTrue(fields.get(2).second == 3);
+    }
+
+    @Test
+    public void testQueryForeach4() {
+        planTester.buildPlan("A = load 'a';");
+        planTester.buildPlan("B = load 'b';");
+        LogicalPlan lp = planTester.buildPlan("foreach (cogroup A by ($1), B by ($1)) generate A, flatten(B.($1, $2, $3));");
+        
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 1);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+    }
+
+    @Test
+    public void testForeach5() {
+        planTester.buildPlan("A = load 'a';");
+        planTester.buildPlan("B = load 'b';");
+        planTester.buildPlan("C = cogroup A by ($1), B by ($1);");
+        String query = "foreach C { " +
+                "B = order B by $0; " +
+                "generate FLATTEN(A), B.($1, $2, $3) ;" +
+                "};" ;
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 1);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+
+    }
+
+    @Test
+    public void testQueryCrossNoSchema(){
+        String query = "c = cross (load 'a'), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cross required fields
+        LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> crossRequiredFields = cross.getRequiredFields();
+        assertTrue(crossRequiredFields.size() == 2);
+        
+        requiredField = crossRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = crossRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+
+    @Test
+    public void testQueryUnionNoSchema(){
+        String query = "c = union (load 'a'), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check union required fields
+        LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> unionRequiredFields = union.getRequiredFields();
+        assertTrue(unionRequiredFields.size() == 2);
+        
+        requiredField = unionRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = unionRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+
+    @Test
+    public void testQueryFRJoinNoSchema(){
+        String query = "c = join (load 'a') by $0, (load 'b') by $0 using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check frjoin required fields
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
+        assertTrue(frjoinRequiredFields.size() == 2);
+        
+        requiredField = frjoinRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+
+
+        requiredField = frjoinRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+        
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+    }
+
+    @Test
+    public void testQueryJoinNoSchema(){
+        String query = "c = join (load 'a') by $0, (load 'b') by $0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+
+    }
+
+    @Test
+    public void testQueryFilterWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = filter a by $1 == '3';");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check filter required fields
+        LOFilter filter = (LOFilter)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> filterRequiredFields = filter.getRequiredFields();
+        assertTrue(filterRequiredFields.size() == 1);
+        
+        requiredField = filterRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+    
+    
+    @Test
+    public void testQuerySplitWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        LogicalPlan lp = planTester.buildPlan("split a into b if url == '3', c if hitCount == '3';");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOSplit split = (LOSplit)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> splitRequiredFields = split.getRequiredFields();
+        assertTrue(splitRequiredFields.size() == 1);
+        
+        requiredField = splitRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check split outputs' required fields
+        LOSplitOutput splitb = (LOSplitOutput)lp.getSuccessors(split).get(0);
+        List<RequiredFields> splitbRequiredFields = splitb.getRequiredFields();
+        assertTrue(splitbRequiredFields.size() == 1);
+        
+        requiredField = splitbRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        LOSplitOutput splitc = (LOSplitOutput)lp.getSuccessors(split).get(1);
+        List<RequiredFields> splitcRequiredFields = splitc.getRequiredFields();
+        assertTrue(splitcRequiredFields.size() == 1);
+        
+        requiredField = splitcRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+
+    @Test
+    public void testQueryOrderByWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = order a by $1;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check order by required fields
+        LOSort sort = (LOSort)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> sortRequiredFields = sort.getRequiredFields();
+        assertTrue(sortRequiredFields.size() == 1);
+        
+        requiredField = sortRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryLimitWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        planTester.buildPlan("b = order a by $1;");
+        LogicalPlan lp = planTester.buildPlan("c = limit b 10;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check order by required fields
+        LOSort sort = (LOSort)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> sortRequiredFields = sort.getRequiredFields();
+        assertTrue(sortRequiredFields.size() == 1);
+        
+        requiredField = sortRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+
+        //check limit required fields
+        LOLimit limit = (LOLimit)lp.getLeaves().get(0);
+        List<RequiredFields> limitRequiredFields = limit.getRequiredFields();
+        assertTrue(limitRequiredFields.size() == 1);
+        
+        requiredField = limitRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+    
+    @Test
+    public void testQueryDistinctWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = distinct a;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check distinct required fields
+        LODistinct distinct = (LODistinct)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> distinctRequiredFields = distinct.getRequiredFields();
+        assertTrue(distinctRequiredFields.size() == 1);
+        
+        requiredField = distinctRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+
+    @Test
+    public void testQueryStreamingWithSchema() {
+        String query = "stream (load 'a') through `" + simpleEchoStreamingCommand + "` as (x, y);";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check streaming required fields
+        LOStream stream = (LOStream)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> streamRequiredFields = stream.getRequiredFields();
+        assertTrue(streamRequiredFields.size() == 1);
+        
+        requiredField = streamRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+
+    @Test
+    public void testQueryStreamingWithSchema1() {
+        String query = "stream (load 'a' as (url, hitCount)) through `" + simpleEchoStreamingCommand + "` as (x, y);";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check streaming required fields
+        LOStream stream = (LOStream)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> streamRequiredFields = stream.getRequiredFields();
+        assertTrue(streamRequiredFields.size() == 1);
+        
+        requiredField = streamRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+    
+    @Test
+    public void testQueryImplicitJoinWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        planTester.buildPlan("b = load 'b' as (url,rank);");
+        planTester.buildPlan("c = cogroup a by url, b by url;");
+        LogicalPlan lp = planTester.buildPlan("d = foreach c generate group,flatten(a),flatten(b);");
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        
+        //check that the foreach required fields contain [<0, 0>, <0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 3);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+        assertTrue(fields.get(2).first == 0);
+        assertTrue(fields.get(2).second == 2);
+
+    }
+    
+    @Test
+    public void testQueryCrossWithSchema(){
+        String query = "c = cross (load 'a' as (url, hitcount)), (load 'b' as (url, rank));";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cross required fields
+        LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> crossRequiredFields = cross.getRequiredFields();
+        assertTrue(crossRequiredFields.size() == 2);
+        
+        requiredField = crossRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = crossRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+
+    @Test
+    public void testQueryUnionWithSchema(){
+        String query = "c = union (load 'a' as (url, hitcount)), (load 'b' as (url, rank));";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check union required fields
+        LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> unionRequiredFields = union.getRequiredFields();
+        assertTrue(unionRequiredFields.size() == 2);
+        
+        requiredField = unionRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = unionRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+
+    @Test
+    public void testQueryFRJoinWithSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b' as (url, rank)) by $0 using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check frjoin required fields
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
+        assertTrue(frjoinRequiredFields.size() == 2);
+        
+        requiredField = frjoinRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+
+
+        requiredField = frjoinRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+        
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+
+    }
+
+    @Test
+    public void testQueryJoinWithSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b' as (url, rank)) by $0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+
+    }
+
+    @Test
+    public void testQueryCrossWithMixedSchema(){
+        String query = "c = cross (load 'a' as (url, hitcount)), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cross required fields
+        LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> crossRequiredFields = cross.getRequiredFields();
+        assertTrue(crossRequiredFields.size() == 2);
+        
+        requiredField = crossRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = crossRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+
+    @Test
+    public void testQueryUnionWithMixedSchema(){
+        String query = "c = union (load 'a' as (url, hitcount)), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check union required fields
+        LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> unionRequiredFields = union.getRequiredFields();
+        assertTrue(unionRequiredFields.size() == 2);
+        
+        requiredField = unionRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = unionRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+
+    @Test
+    public void testQueryFRJoinWithMixedSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b') by $0 using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check frjoin required fields
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
+        assertTrue(frjoinRequiredFields.size() == 2);
+        
+        requiredField = frjoinRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+
+
+        requiredField = frjoinRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+        
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        
+    }
+    
+    @Test
+    public void testQueryJoinWithMixedSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b') by $0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+    }
+
+    @Test
+    public void testQueryFilterWithStarNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = filter a by COUNT(*) == 3;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check filter required fields
+        LOFilter filter = (LOFilter)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> filterRequiredFields = filter.getRequiredFields();
+        assertTrue(filterRequiredFields.size() == 1);
+        
+        requiredField = filterRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+
+    @Test
+    public void testQueryOrderByStarNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = order a by *;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check order by required fields
+        LOSort sort = (LOSort)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> sortRequiredFields = sort.getRequiredFields();
+        assertTrue(sortRequiredFields.size() == 1);
+        
+        requiredField = sortRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+    
+    @Test
+    public void testQueryGroupByStarNoSchema() throws Exception {
+        String query = "foreach (group (load 'a') by *) generate $1 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 1);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryFRJoinOnStarNoSchema(){
+        String query = "c = join (load 'a') by *, (load 'b') by * using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check frjoin required fields
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
+        assertTrue(frjoinRequiredFields.size() == 2);
+        
+        requiredField = frjoinRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = frjoinRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+    
+    @Test
+    public void testQueryJoinOnStarNoSchema(){
+        String query = "c = join (load 'a') by *, (load 'b') by *;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+    }
+
+    @Test
+    public void testQueryFilterStarWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = filter a by COUNT(*) == 3;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check filter required fields
+        LOFilter filter = (LOFilter)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> filterRequiredFields = filter.getRequiredFields();
+        assertTrue(filterRequiredFields.size() == 1);
+        
+        requiredField = filterRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+    
+    @Test
+    public void testQuerySplitWithStarSchema() {
+        planTester.buildPlan("a = load 'a' as (url, hitCount);");
+        LogicalPlan lp = planTester.buildPlan("split a into b if url == '3', c if COUNT(*) == '3';");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOSplit split = (LOSplit)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> splitRequiredFields = split.getRequiredFields();
+        assertTrue(splitRequiredFields.size() == 1);
+        
+        requiredField = splitRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check split outputs' required fields
+        LOSplitOutput splitb = (LOSplitOutput)lp.getSuccessors(split).get(0);
+        List<RequiredFields> splitbRequiredFields = splitb.getRequiredFields();
+        assertTrue(splitbRequiredFields.size() == 1);
+        
+        requiredField = splitbRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        
+        LOSplitOutput splitc = (LOSplitOutput)lp.getSuccessors(split).get(1);
+        List<RequiredFields> splitcRequiredFields = splitc.getRequiredFields();
+        assertTrue(splitcRequiredFields.size() == 1);
+        
+        requiredField = splitcRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+    }
+    
+    @Test
+    public void testQueryOrderByStarWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = order a by *;");
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check order by required fields
+        LOSort sort = (LOSort)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> sortRequiredFields = sort.getRequiredFields();
+        assertTrue(sortRequiredFields.size() == 1);
+        
+        requiredField = sortRequiredFields.get(0);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.needNoFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields();
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+    }
+    
+    @Test
+    public void testQueryGroupByStarWithSchema() throws Exception {
+        String query = "foreach (group (load 'a' as (url, hitCount)) by *) generate $1 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 1);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+        
+        //check that the foreach required fields contain [<0, 1>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 1);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+    }
+
+    @Test
+    public void testQueryFRJoinOnStarWithSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by *, (load 'b' as (url, rank)) by * using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check frjoin required fields
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> frjoinRequiredFields = frjoin.getRequiredFields();
+        assertTrue(frjoinRequiredFields.size() == 2);
+        
+        requiredField = frjoinRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+
+        requiredField = frjoinRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+        
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 1);
+        assertTrue(fields.get(1).second == 1);
+
+    }
+
+    @Test
+    public void testQueryJoinOnStarWithSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by *, (load 'b' as (url, rank)) by *;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        List<RequiredFields> loadbRequiredFields = loadb.getRequiredFields();
+        assertTrue(loadbRequiredFields.size() == 1);
+        
+        requiredField = loadbRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+
+        //check cogroup required fields
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        List<RequiredFields> cogroupRequiredFields = cogroup.getRequiredFields();
+        assertTrue(cogroupRequiredFields.size() == 2);
+        
+        requiredField = cogroupRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+        
+        requiredField = cogroupRequiredFields.get(1);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 1);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 1);
+        assertTrue(fields.get(1).second == 1);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 1);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 2);
+
+    }
+    
+    @Test
+    public void testQueryForeachGenerateStarNoSchema() {
+        String query = "foreach (load 'a') generate * ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 3>, <0,2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+
+    @Test
+    public void testQueryForeachGenerateCountStarNoSchema() {
+        String query = "foreach (load 'a') generate COUNT(*) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 3>, <0,2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+
+    }
+    
+    @Test
+    public void testQueryForeachGenerateStarNoSchema1() {
+        String query = "foreach (load 'a') generate *, COUNT(*) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 3>, <0,2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+
+    @Test
+    public void testQueryForeachGenerateStarNoSchema2() {
+        String query = "foreach (load 'a') generate *, $0 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 3>, <0,2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+    
+    @Test
+    public void testQueryForeachGenerateStarWithSchema() {
+        String query = "foreach (load 'a' as (url, hitCount)) generate * ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 1>, <0, 3>, <0,2>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+
+    }
+
+    @Test
+    public void testQueryForeachGenerateCountStarWithSchema() {
+        String query = "foreach (load 'a' as (url, hitCount)) generate COUNT(*) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check the foreach required fields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+        
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+
+    @Test
+    public void testQueryForeachGenerateStarWithSchema1() {
+        String query = "foreach (load 'a' as (url, hitCount)) generate *, COUNT(*) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check the foreach required fields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == true);
+        assertTrue(requiredField.getFields() == null);
+    }
+
+    @Test
+    public void testQueryForeachGenerateStarWithSchema2() {
+        String query = "foreach (load 'a' as (url, hitCount)) generate *, url ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load's required fields is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        List<RequiredFields> loadaRequiredFields = loada.getRequiredFields();
+        assertTrue(loadaRequiredFields.size() == 1);
+        
+        RequiredFields requiredField = loadaRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == true);
+        assertTrue(requiredField.needAllFields() == false);
+        assertTrue(requiredField.getFields() == null);
+        
+        //check that the foreach required fields contain [<0, 0>, <0, 1>]
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        List<RequiredFields> foreachRequiredFields = foreach.getRequiredFields();
+        assertTrue(foreachRequiredFields.size() == 1);
+
+        requiredField = foreachRequiredFields.get(0);
+        assertTrue(requiredField.needNoFields() == false);
+        assertTrue(requiredField.needAllFields() == false);
+        
+        List<Pair<Integer, Integer>> fields = requiredField.getFields(); 
+        assertTrue(fields.size() == 2);
+        assertTrue(fields.get(0).first == 0);
+        assertTrue(fields.get(0).second == 0);
+        assertTrue(fields.get(1).first == 0);
+        assertTrue(fields.get(1).second == 1);
+    }
+
+}
