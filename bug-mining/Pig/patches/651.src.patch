diff --git a/CHANGES.txt b/CHANGES.txt
index 5b7192e9c..0f016ea22 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -351,6 +351,9 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1892: Bug in new logical plan : No output generated even though there are
+valid records (daijy)
+
 PIG-1808: Error message in 0.8 not much helpful as compared to 0.7 (daijy)
 
 PIG-1850: Order by is failing with ClassCastException if schema is undefined
diff --git a/src/org/apache/pig/newplan/logical/rules/MapKeysPruneHelper.java b/src/org/apache/pig/newplan/logical/rules/MapKeysPruneHelper.java
index 16a1ebbf7..f421c6d04 100644
--- a/src/org/apache/pig/newplan/logical/rules/MapKeysPruneHelper.java
+++ b/src/org/apache/pig/newplan/logical/rules/MapKeysPruneHelper.java
@@ -44,6 +44,7 @@ import org.apache.pig.newplan.logical.relational.LOGenerate;
 import org.apache.pig.newplan.logical.relational.LOJoin;
 import org.apache.pig.newplan.logical.relational.LOLoad;
 import org.apache.pig.newplan.logical.relational.LOSort;
+import org.apache.pig.newplan.logical.relational.LOSplitOutput;
 import org.apache.pig.newplan.logical.relational.LOStore;
 import org.apache.pig.newplan.logical.relational.LOUnion;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
@@ -256,6 +257,26 @@ public class MapKeysPruneHelper {
             }
         }
         
+        
+        @Override
+        public void visit(LOSplitOutput splitOutput) throws FrontendException {
+            super.visit(splitOutput);
+            if (splitOutput.getSchema()!=null) {
+                for (LogicalFieldSchema fs : splitOutput.getSchema().getFields()) {
+                    long inputUid = splitOutput.getInputUids(fs.uid);
+                    if( inputUid!=-1) {
+                        Set<String> mapKeySet = inputUids.get(fs.uid);
+                        if (mapKeySet!=null) {
+                            if (inputUids.containsKey(inputUid))
+                                inputUids.get(inputUid).addAll(mapKeySet);
+                            else
+                                inputUids.put(inputUid, mapKeySet);
+                        }
+                    }
+                }
+            }
+        }
+        
         private void mergeUidKeys( Map<Long, Set<String> > inputMap ) {
             for( Map.Entry<Long, Set<String>> entry : inputMap.entrySet() ) {
                 if( inputUids.containsKey(entry.getKey()) ) {
@@ -302,7 +323,7 @@ public class MapKeysPruneHelper {
         Set<Long> fullMapUids = new HashSet<Long>();
 
         protected FullMapCollector(OperatorPlan plan, Set<Long> fullMapUids) throws FrontendException {
-            super(plan, new DependencyOrderWalker(plan));
+            super(plan, new ReverseDependencyOrderWalker(plan));
             this.fullMapUids = fullMapUids;
         }
         
@@ -340,6 +361,17 @@ public class MapKeysPruneHelper {
                 }
             }
         }
+        
+        @Override
+        public void visit(LOSplitOutput splitOutput) throws FrontendException {
+            super.visit(splitOutput);
+            if (splitOutput.getSchema()!=null) {
+                for (LogicalFieldSchema fs : splitOutput.getSchema().getFields()) {
+                    if (fullMapUids.contains(fs.uid) && splitOutput.getInputUids(fs.uid)!=-1)
+                        fullMapUids.add(splitOutput.getInputUids(fs.uid));
+                }
+            }
+        }
 
         @Override
         protected LogicalExpressionVisitor getVisitor(LogicalExpressionPlan expr)
diff --git a/test/org/apache/pig/test/TestPruneColumn.java b/test/org/apache/pig/test/TestPruneColumn.java
index 0dafbe48d..95192f4a7 100644
--- a/test/org/apache/pig/test/TestPruneColumn.java
+++ b/test/org/apache/pig/test/TestPruneColumn.java
@@ -29,6 +29,7 @@ import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.hadoop.fs.Path;
 import org.apache.log4j.FileAppender;
@@ -60,6 +61,7 @@ public class TestPruneColumn extends TestCase {
     File tmpFile9;
     File tmpFile10;
     File tmpFile11;
+    File tmpFile12;
     File logFile;
 
     private static final String simpleEchoStreamingCommand;
@@ -156,6 +158,12 @@ public class TestPruneColumn extends TestCase {
         ps.println("1\t3\t2");
         ps.println("2\t5\t2");
         ps.close();
+        
+        tmpFile12 = File.createTempFile("prune", "txt");
+        ps = new PrintStream(new FileOutputStream(tmpFile12));
+        ps.println("[key1#1,key2#2,cond#1]");
+        ps.println("[key1#2,key2#3,cond#1]");
+        ps.close();
     }
     
     @After
@@ -171,6 +179,8 @@ public class TestPruneColumn extends TestCase {
         tmpFile8.delete();
         tmpFile9.delete();
         tmpFile10.delete();
+        tmpFile11.delete();
+        tmpFile12.delete();
         logFile.delete();
     }
     
@@ -1250,6 +1260,52 @@ public class TestPruneColumn extends TestCase {
         assertTrue(checkLogFileMessage(new String[]{"Map key required for A: $1->[key1]"}));
     }
     
+    @Test
+    public void testMapKeyInSplit1() throws Exception {
+        pigServer.registerQuery("A = load '"+ Util.generateURI(tmpFile12.toString(), pigServer.getPigContext()) + "' as (m:map[]);");
+        pigServer.registerQuery("B = foreach A generate m#'key1' as key1;");
+        pigServer.registerQuery("C = foreach A generate m#'key2' as key2;");
+        pigServer.registerQuery("D = join B by key1, C by key2;");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("D");
+        
+        assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+        assertTrue(t.size()==2);
+        assertTrue(t.get(0).toString().equals("2"));
+        assertTrue(t.get(1).toString().equals("2"));
+        
+        assertFalse(iter.hasNext());
+        
+        assertTrue(checkLogFileMessage(new String[]{"Map key required for A: $0->[key2, key1]"}));
+    }
+    
+    @SuppressWarnings("rawtypes")
+    @Test
+    public void testMapKeyInSplit2() throws Exception {
+        pigServer.registerQuery("A = load '"+ Util.generateURI(tmpFile12.toString(), pigServer.getPigContext()) + "' as (m:map[]);");
+        pigServer.registerQuery("B = filter A by m#'cond'==1;");
+        pigServer.registerQuery("C = filter B by m#'key1'==1;");
+        pigServer.registerQuery("D = filter B by m#'key2'==2;");
+        pigServer.registerQuery("E = join C by m#'key1', D by m#'key1';");
+        
+        Iterator<Tuple> iter = pigServer.openIterator("E");
+        
+        assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+        assertTrue(t.size()==2);
+        assertTrue(((Map)t.get(0)).get("key1").toString().equals("1"));
+        assertTrue(((Map)t.get(0)).get("key2").toString().equals("2"));
+        assertTrue(((Map)t.get(0)).get("cond").toString().equals("1"));
+        assertTrue(((Map)t.get(1)).get("key1").toString().equals("1"));
+        assertTrue(((Map)t.get(1)).get("key2").toString().equals("2"));
+        assertTrue(((Map)t.get(1)).get("cond").toString().equals("1"));
+        
+        assertFalse(iter.hasNext());
+        
+        assertTrue(this.emptyLogFileMessage());
+    }
+    
     @Test
     public void testConstantPlan() throws Exception {
         pigServer.registerQuery("A = load '"+ Util.generateURI(tmpFile1.toString(), pigServer.getPigContext()) + "' as (a0, a1, a2);");
