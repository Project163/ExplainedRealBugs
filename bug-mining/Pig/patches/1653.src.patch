diff --git a/CHANGES.txt b/CHANGES.txt
index 7c4cb0deb..c7d78f53d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -42,6 +42,9 @@ PIG-4333: Split BigData tests into multiple groups (rohini)
  
 BUG FIXES
 
+PIG-4376: NullPointerException accessing a field of an invalid bag from a nested foreach
+ (kspringborn via daijy)
+
 PIG-4355: Piggybank: XPath cant handle namespace in xpath, nor can it return more than one match
  (cavanaug via daijy)
 
diff --git a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
index bb903bbc2..89ebe14f4 100644
--- a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
@@ -206,7 +206,7 @@ public class DereferenceExpression extends ColumnExpression {
             	    throw new FrontendException("Index "+rawColumn + " out of range in schema:" + schema.toString(false), 1127);
             	}
                 columns.add( (Integer)rawColumn );
-            } else {
+            } else if (schema!=null) {
                 int pos = schema.getFieldPosition((String)rawColumn);
                 if( pos != -1) {
                     columns.add( pos );
diff --git a/test/org/apache/pig/parser/TestColumnAliasConversion.java b/test/org/apache/pig/parser/TestColumnAliasConversion.java
index 22f6e3d96..291a81c69 100644
--- a/test/org/apache/pig/parser/TestColumnAliasConversion.java
+++ b/test/org/apache/pig/parser/TestColumnAliasConversion.java
@@ -159,6 +159,22 @@ public class TestColumnAliasConversion {
         Assert.fail( "Query should fail to validate." );
     }
 
+    @Test
+    public void testInvalidNestedProjection() throws Exception {
+        String query = "A = load 'x' as (field);" +
+                       "B = foreach A {" +
+                       "  C = LIMIT invalidName 1;" +
+                       "  generate C.foo;" +
+                       "};";
+        try {
+            validate( query );
+        } catch(PlanValidationException ex) {
+            System.out.println(ex.getMessage());
+            return;
+        }
+        Assert.fail( "Query should fail to validate." );
+    }
+
     private LogicalPlan validate(String query) throws RecognitionException, ParsingFailureException, IOException {
         LogicalPlan plan = ParserTestingUtils.generateLogicalPlan( query );
         ColumnAliasConversionVisitor visitor = new ColumnAliasConversionVisitor( plan );
