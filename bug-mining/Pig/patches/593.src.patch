diff --git a/CHANGES.txt b/CHANGES.txt
index 3e64416b4..8f6ba8014 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -220,6 +220,8 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1741: Lineage fail when flatten a bag (daijy)
+
 PIG-1739: zero status is returned when pig script fails (yanz)
 
 PIG-1738: New logical plan: Optimized UserFuncExpression.getFieldSchema (daijy)
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 7b863d8d4..7f5e21ed2 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -3111,6 +3111,9 @@ public class TypeCheckingVisitor extends LOVisitor {
             }            
             Schema.FieldSchema fs = ((ExpressionOperator)op).getFieldSchema();
             if( parentCanonicalName != null ) {
+                // The following line is a work around for PIG-1741. Ideal fix should be to 
+                // find why the canonical map is empty and create the map
+                if (!fs.findFieldSchema( parentCanonicalName ).getCanonicalMap().isEmpty())
             	fs = fs.findFieldSchema( parentCanonicalName );
             }
             getLoadFuncSpec( fs, loadFuncSpecMap );
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidator.java b/test/org/apache/pig/test/TestTypeCheckingValidator.java
index ab04208df..87754820a 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidator.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidator.java
@@ -5936,4 +5936,34 @@ public class TestTypeCheckingValidator extends TestCase {
         assertTrue(cast.getLoadFuncSpec().getClassName().startsWith("PigStorage"));
     }
     
+    @Test
+    // See PIG-1741
+    public void testBagDereference() throws FrontendException {
+        planTester.buildPlan("a = load '1.txt' as (a0);");
+        planTester.buildPlan("b = foreach a generate flatten((bag{tuple(map[])})a0) as b0:map[];");
+        LogicalPlan plan = planTester.buildPlan("c = foreach b generate (long)b0#'key1';");
+
+        // validate
+        CompilationMessageCollector collector = new CompilationMessageCollector() ;
+        TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
+        typeValidator.validate(plan, collector) ;
+
+        printMessageCollector(collector) ;
+        printTypeGraph(plan) ;
+        planTester.printPlan(plan, TypeCheckingTestUtil.getCurrentMethodName());
+
+        if (collector.hasError()) {
+            throw new AssertionError("Expect no  error") ;
+        }
+
+        LOForEach foreach = (LOForEach)plan.getLeaves().get(0);
+        LogicalPlan foreachPlan = foreach.getForEachPlans().get(0);
+        List<LogicalOperator> projs = foreachPlan.getRoots();
+        LogicalOperator proj = projs.get(0);
+        LogicalOperator maplookup = foreachPlan.getSuccessors( proj ).get( 0 );
+        LogicalOperator cast = foreachPlan.getSuccessors( maplookup ).get( 0 );
+        
+        assertTrue(((LOCast)cast).getLoadFuncSpec().getClassName().equals(PigStorage.class.getName()));
+    }
+    
 }
