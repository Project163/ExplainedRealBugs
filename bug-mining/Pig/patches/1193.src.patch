diff --git a/CHANGES.txt b/CHANGES.txt
index 92ef4d67d..6b331bb5b 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -170,6 +170,8 @@ PIG-3013: BinInterSedes improve chararray sort performance (rohini)
 
 BUG FIXES
 
+PIG-3304: XMLLoader in piggybank does not work with inline closed tags (aseldawy via daijy)
+
 PIG-3028: testGrunt dev test needs some command filters to run correctly without cygwin (jgordon via gates)
 
 PIG-3290: TestLogicalPlanBuilder.testQuery85 fail in trunk (daijy)
diff --git a/contrib/piggybank/java/src/main/java/org/apache/pig/piggybank/storage/XMLLoader.java b/contrib/piggybank/java/src/main/java/org/apache/pig/piggybank/storage/XMLLoader.java
index 589a54517..7b1a75c9a 100644
--- a/contrib/piggybank/java/src/main/java/org/apache/pig/piggybank/storage/XMLLoader.java
+++ b/contrib/piggybank/java/src/main/java/org/apache/pig/piggybank/storage/XMLLoader.java
@@ -194,36 +194,24 @@ class XMLLoaderBufferedPositionedInputStream extends BufferedPositionedInputStre
 
       //@todo use the charset and get the charset encoding from the xml encoding.
       byte[] tmp = tagName.getBytes();
-      byte[] tag = new byte[tmp.length + 3];
-      tag[0] = (byte)'<';
-      tag[1] = (byte)'/';
-      for (int i = 0; i < tmp.length; ++i) {
-        tag[2+i] = tmp[i];
-      }
-      tag[tmp.length+2] = (byte)'>';
-      
+      ByteArrayOutputStream collectBuf = new ByteArrayOutputStream(1024);
+      // Levels of elements we went inside matched node
+      int depth = 0;
       
-      // Create a start tag bytes to handle nested tags
-      byte[] startTag = new byte[tmp.length + 1];
-      startTag[0] = (byte)'<';
-      for (int i = 0; i < tmp.length; ++i) {
-         startTag[1+i] = tmp[i];
-       }
-      //startTag[tmp.length+1] = (byte)'>';
+      //Since skipToTag was called before this function, we know that we are
+      //currently inside the matched tag. Assuming the XML file is well
+      //structured, we read till we encounter the first close tag. Since
+      //the matched element might contain nested element, we keep track of the
+      //current depth and terminate only when we encounter a closing tag at
+      //level zero
       
+      // A flag to indicate the parsing is currently inside a (start/end) tag
+      boolean insideTag = false;
+      // A flag to indicate that the current tag is a closing (end) tag
+      boolean closingTag = false;
       
-
-      ByteArrayOutputStream collectBuf = new ByteArrayOutputStream(1024);
-      int idxTagChar = 0;
-      int idxStartTagChar = 0;
-      boolean startTagMatched = false;
-      /*
-       * Read till an end tag is found.It need not check for any condition since it 
-       * tries to read it till end.One issue that may happen is that if the xml 
-       * content is very huge; or if the end tag is not there in a huge file, 
-       * then it may blow up the memory. 
-       */
-      int nestedTags = 0;
+      // Last byte read
+      int last_b = -1;
       while (true) {
         int b = -1;
         try {
@@ -237,42 +225,32 @@ class XMLLoaderBufferedPositionedInputStream extends BufferedPositionedInputStre
           collectBuf.write((byte)(b));
 
           // Check if the start tag has matched except for the last char
-          if(startTagMatched )
-          {
-             startTagMatched = false;
-             idxStartTagChar = 0;
-             if (b == ' ' || b == '\t' || b == '>')
-                ++nestedTags;// increment the nesting count
-          }
-          
-          if (b == startTag[idxStartTagChar]){
-             ++idxStartTagChar;
-             if(idxStartTagChar == startTag.length)
-                startTagMatched = true ; // Set the flag as true if start tag matches
-          }else
-             idxStartTagChar = 0;
-            
-          
-          
-          // start to match the target close tag
-          if (b == tag[idxTagChar]) {
-            ++idxTagChar;
-            if (idxTagChar == tag.length) {
-               if(nestedTags==0) // Break the loop if there were no nested tags
-                  break;
-               else{
-                  --nestedTags; // Else decrement the count
-                  idxTagChar = 0; // Reset the index
-               }
+          if (b == '<') {
+            insideTag = true;
+            closingTag = false;
+          } else if (b == '>') {
+            // Detect the pattern />
+            if (last_b == '/')
+              closingTag = true;
+            insideTag = false;
+            if (closingTag) {
+              if (depth == 0)
+                break;
+              depth--;
             }
-          } else 
-            idxTagChar = 0; 
-          
+          } else if (b == '/' && last_b == '<') {
+            // Detected the pattern </
+            closingTag = true;
+          } else if (insideTag && last_b == '<') {
+            // First character after '<' which is not a '/'
+            depth++;
+          }
         }
         catch (IOException e) {
           this.setReadable(false);
           return null;
         }
+        last_b = b;
       }
       return collectBuf.toByteArray();
     }
@@ -339,7 +317,7 @@ class XMLLoaderBufferedPositionedInputStream extends BufferedPositionedInputStre
               break;
             case S_MATCH_PREFIX:
               // tag match iff next character is whitespaces or close tag mark
-              if (b == ' ' || b == '\t' || b == '>') {
+              if (Character.isWhitespace(b) || b == '/' || b == '>') {
                 matchBuf.write((byte)(b));
                 state = S_MATCH_TAG;
               } else {
@@ -355,7 +333,7 @@ class XMLLoaderBufferedPositionedInputStream extends BufferedPositionedInputStre
             default:
               throw new IllegalArgumentException("Invalid state: " + state);
           }
-          if (state == S_MATCH_TAG && b == '>') {
+          if (state == S_MATCH_TAG && (b == '>' || Character.isWhitespace(b))) {
             break;
           }
           if (state != S_MATCH_TAG && this.getPosition() > limit) {
@@ -406,6 +384,12 @@ class XMLLoaderBufferedPositionedInputStream extends BufferedPositionedInputStre
     byte[] collectTag(String tagName, long limit) throws IOException {
        ByteArrayOutputStream collectBuf = new ByteArrayOutputStream(1024);
        byte[] beginTag = skipToTag(tagName, limit);
+       
+       // Check if the tag is closed inline
+       if (beginTag.length > 2 && beginTag[beginTag.length - 2] == '/' &&
+           beginTag[beginTag.length-1] == '>') {
+         return beginTag;
+       }
 
        // No need to search for the end tag if the start tag is not found
        if(beginTag.length > 0 ){ 
diff --git a/contrib/piggybank/java/src/test/java/org/apache/pig/piggybank/test/storage/TestXMLLoader.java b/contrib/piggybank/java/src/test/java/org/apache/pig/piggybank/test/storage/TestXMLLoader.java
index 4adc9cd78..762a84610 100644
--- a/contrib/piggybank/java/src/test/java/org/apache/pig/piggybank/test/storage/TestXMLLoader.java
+++ b/contrib/piggybank/java/src/test/java/org/apache/pig/piggybank/test/storage/TestXMLLoader.java
@@ -15,10 +15,14 @@ package org.apache.pig.piggybank.test.storage;
 
 import static org.apache.pig.ExecType.LOCAL;
 
+import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Iterator;
 
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
 import junit.framework.TestCase;
 
 import org.apache.pig.ExecType;
@@ -75,6 +79,16 @@ public class TestXMLLoader extends TestCase {
      nestedTags.add(new String[] { "</events>"});
   }
   
+  public static ArrayList<String[]> inlineClosedTags = new ArrayList<String[]>();
+  static {
+    inlineClosedTags.add(new String[] { "<events>"});
+    inlineClosedTags.add(new String[] { "<event id='3423'/>"});
+    inlineClosedTags.add(new String[] { "<event/>"});
+    inlineClosedTags.add(new String[] { "<event><event/></event>"});
+    inlineClosedTags.add(new String[] { "<event id='33'><tag k='a' v='b'/></event>"});
+    inlineClosedTags.add(new String[] { "</events>"});
+  }
+  
   public void testShouldReturn0TupleCountIfSearchTagIsNotFound () throws Exception
   {
     String filename = TestHelper.createTempFile(data, "");
@@ -333,5 +347,47 @@ public class TestXMLLoader extends TestCase {
       assertEquals(3, tupleCount);  
    }
    
-   
+
+   public void testXMLLoaderShouldWorkWithInlineClosedTags() throws Exception {
+     String filename = TestHelper.createTempFile(inlineClosedTags, "");
+     PigServer pig = new PigServer(LOCAL);
+     filename = filename.replace("\\", "\\\\");
+     patternString = patternString.replace("\\", "\\\\");
+     String query = "A = LOAD 'file:" + filename + "' USING org.apache.pig.piggybank.storage.XMLLoader('event') as (doc:chararray);";
+     pig.registerQuery(query);
+     Iterator<?> it = pig.openIterator("A");
+     int tupleCount = 0;
+     while (it.hasNext()) {
+       Tuple tuple = (Tuple) it.next();
+       if (tuple == null)
+         break;
+       else {
+         if (tuple.size() > 0) {
+             tupleCount++;
+         }
+       }
+     }
+     assertEquals(4, tupleCount);  
+   }
+
+   public void testXMLLoaderShouldReturnValidXML() throws Exception {
+     String filename = TestHelper.createTempFile(inlineClosedTags, "");
+     PigServer pig = new PigServer(LOCAL);
+     filename = filename.replace("\\", "\\\\");
+     patternString = patternString.replace("\\", "\\\\");
+     String query = "A = LOAD 'file:" + filename + "' USING org.apache.pig.piggybank.storage.XMLLoader('event') as (doc:chararray);";
+     pig.registerQuery(query);
+     Iterator<?> it = pig.openIterator("A");
+     while (it.hasNext()) {
+       Tuple tuple = (Tuple) it.next();
+       if (tuple == null)
+         break;
+       else {
+         // Test it returns a valid XML
+         DocumentBuilder docBuilder =
+           DocumentBuilderFactory.newInstance().newDocumentBuilder();
+         docBuilder.parse(new ByteArrayInputStream(((String)tuple.get(0)).getBytes()));
+       }
+     }
+   }
 }
