diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java
index 467840628..c5b59e527 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java
@@ -366,9 +366,13 @@ public class JobControlCompiler{
                 jobConf.setOutputValueClass(NullableTuple.class);
             }
         
-            if(mro.isGlobalSort()){
-                jobConf.set("pig.quantilesFile", mro.getQuantFile());
-                jobConf.setPartitionerClass(SortPartitioner.class);
+            if(mro.isGlobalSort() || mro.isLimitAfterSort()){
+                // Only set the quantiles file and sort partitioner if we're a
+                // global sort, not for limit after sort.
+                if (mro.isGlobalSort()) {
+                    jobConf.set("pig.quantilesFile", mro.getQuantFile());
+                    jobConf.setPartitionerClass(SortPartitioner.class);
+                }
                 if(mro.UDFs.size()==1){
                     String compFuncSpec = mro.UDFs.get(0);
                     Class comparator = PigContext.resolveClassName(compFuncSpec);
@@ -469,9 +473,10 @@ public class JobControlCompiler{
         // raw comparator.
         
         // An operator has an order by if global sort is set or if it's successor has
-        // global sort set (because in that case it's the sampling job). 
+        // global sort set (because in that case it's the sampling job) or if
+        // it's a limit after a sort. 
         boolean hasOrderBy = false;
-        if (mro.isGlobalSort()) {
+        if (mro.isGlobalSort() || mro.isLimitAfterSort()) {
             hasOrderBy = true;
         } else {
             List<MapReduceOper> succs = plan.getSuccessors(mro);
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
index d394e2b4b..913e506de 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MRCompiler.java
@@ -1302,6 +1302,11 @@ public class MRCompiler extends PhyPlanVisitor {
                 st.setSFile(oldSpec);
                 limitAdjustMROp.reducePlan.addAsLeaf(st);
                 limitAdjustMROp.requestedParallelism = -1;
+                // If the operator we're following has global sort set, we
+                // need to indicate that this is a limit after a sort.
+                // This will assure that we get the right sort comparator
+                // set.  Otherwise our order gets wacked (PIG-461).
+                if (mr.isGlobalSort()) limitAdjustMROp.setLimitAfterSort(true);
                 
                 List<MapReduceOper> successorList = MRPlan.getSuccessors(mr);
                 MapReduceOper successors[] = null;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
index 3b659e86d..bfbea42a3 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
@@ -77,6 +77,9 @@ public class MapReduceOper extends Operator<MROpPlanVisitor> {
     //Indicates if this job is an order by job
     boolean globalSort = false;
 
+    // Indicates if this is a limit after a sort
+    boolean limitAfterSort = false;
+
     // If true, putting an identity combine in this
     // mapreduce job will speed things up.
     boolean needsDistinctCombiner = false;
@@ -227,6 +230,14 @@ public class MapReduceOper extends Operator<MROpPlanVisitor> {
         this.globalSort = globalSort;
     }
 
+    public boolean isLimitAfterSort() {
+        return limitAfterSort;
+    }
+
+    public void setLimitAfterSort(boolean las) {
+        limitAfterSort = las;
+    }
+
     public boolean needsDistinctCombiner() { 
         return needsDistinctCombiner;
     }
