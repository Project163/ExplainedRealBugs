diff --git a/CHANGES.txt b/CHANGES.txt
index a8736b07a..8dd4f1b03 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -218,4 +218,7 @@ Trunk (unreleased changes)
     PIG-440: Exceptions from UDFs inside a foreach are not captured (pradeepk
     via olgan)
 
+    PIG-442: Disambiguated alias after a foreach flatten is not accessible a
+    couple of statements after the foreach (sms via olgan)
+
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 13570473a..1dba3309a 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -325,9 +325,6 @@ public class LOForEach extends LogicalOperator {
 				log.debug("alias: " + alias);
 				if((null != alias) && (count == 1)) {
 					mSchema.addAlias(alias, fs);
-					// alias is unambiguous - so set it
-					// as the alias in the field schema
-					fs.alias = alias;
 				}
 			}
             mIsSchemaComputed = true;
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 07614e472..fb345a02a 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -1550,9 +1550,13 @@ int ColNameOrNum(Schema over) :
 	t = <IDENTIFIER> 
 	{	int i;
 		
-		if ( over == null ||  (i = over.getPosition(t.image)) == -1) {
-			throw new ParseException("Invalid alias: " + t.image + " in " + over);
-		} 
+        try {
+		    if ( over == null ||  (i = over.getPosition(t.image)) == -1) {
+			    throw new ParseException("Invalid alias: " + t.image + " in " + over);
+		    } 
+        } catch (FrontendException fee) {
+            throw new ParseException(fee.getMessage());
+        }
 		
 		log.trace("Exiting ColNameOrNum");
 		return i;
@@ -2011,9 +2015,13 @@ LogicalOperator NestedProject(Schema over, Map<String, LogicalOperator> specs, L
             foreachInput = specs.get(t.image);
         }
         if(null == foreachInput) {
-			if ((null == over) ||  (i = over.getPosition(t.image)) == -1) {
-				throw new ParseException("Invalid alias: " + t.image + " in " + over);
-			}
+            try {
+			    if ((null == over) ||  (i = over.getPosition(t.image)) == -1) {
+				    throw new ParseException("Invalid alias: " + t.image + " in " + over);
+			    }
+            } catch (FrontendException fee) {
+                throw new ParseException(fee.getMessage());
+            }
             foreachInput = new LOProject(lp, new OperatorKey(scope, getNextId()), input, i);
         }
 
@@ -3243,14 +3251,18 @@ ExpressionOperator AliasFieldOrSpec(Schema over, Map<String, LogicalOperator> sp
 		if (item == null){
 			log.debug("item == null");
 			if (null == over) log.debug("over is null");
-			if ( over == null ||  (i = over.getPosition(t1.image)) == -1) {
-				log.debug("Invalid alias: " + t1.image + " in " + over);
-				if(null != over) {
-					log.debug("Printing out the aliases in the schema");
-					over.printAliases();
-				}
-				throw new ParseException("Invalid alias: " + t1.image + " in " + over);
-			}
+            try {
+			    if ( over == null ||  (i = over.getPosition(t1.image)) == -1) {
+				    log.debug("Invalid alias: " + t1.image + " in " + over);
+				    if(null != over) {
+					    log.debug("Printing out the aliases in the schema");
+					    over.printAliases();
+				    }
+				    throw new ParseException("Invalid alias: " + t1.image + " in " + over);
+			    }
+            } catch (FrontendException fee) {
+                throw new ParseException(fee.getMessage());
+            }
 			log.debug("Position of " + t1.image + " = " + i);
 			if(null != over) {
 				log.debug("Printing out the aliases in the schema");
diff --git a/src/org/apache/pig/impl/logicalLayer/schema/Schema.java b/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
index 19031cf37..c1540e37e 100644
--- a/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
+++ b/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
@@ -464,8 +464,53 @@ public class Schema implements Serializable, Cloneable {
      * @param alias Alias to look up.
      * @return FieldSchema, or null if no such alias is in this tuple.
      */
-    public FieldSchema getField(String alias) {
-        return mAliases.get(alias);
+    public FieldSchema getField(String alias) throws FrontendException {
+        FieldSchema fs = mAliases.get(alias);
+        if(null == fs) {
+            String cocoPrefix = new String("::" + alias);
+            Map<String, Integer> aliasMatches = new HashMap<String, Integer>();
+            //build the map of aliases that have cocoPrefix as the suffix
+            for(String key: mAliases.keySet()) {
+                if(key.endsWith(cocoPrefix)) {
+                    Integer count = aliasMatches.get(key);
+                    if(null == count) {
+                        aliasMatches.put(key, 1);
+                    } else {
+                        aliasMatches.put(key, ++count);
+                    }
+                }
+            }
+            //process the map to check if
+            //1. are there multiple keys with count == 1
+            //2. are there keys with count > 1 --> should never occur
+            //3. if thers is a single key with count == 1 we have our match
+
+            if(aliasMatches.keySet().size() == 0) {
+                return null;
+            }
+            if(aliasMatches.keySet().size() == 1) {
+                Object[] keys = aliasMatches.keySet().toArray();
+                String key = (String)keys[0];
+                if(aliasMatches.get(key) > 1) {
+                    throw new FrontendException("Found duplicate aliases: " + key);
+                }
+                return mAliases.get(key);
+            } else {
+                boolean hasNext = false;
+                StringBuilder sb = new StringBuilder("Found more than one match: ");
+                for (String key: aliasMatches.keySet()) {
+                    if(hasNext) {
+                        sb.append(", ");
+                    } else {
+                        hasNext = true;
+                    }
+                    sb.append(key);
+                }
+                throw new FrontendException(sb.toString());
+            }
+        } else {
+            return fs;
+        }
     }
 
     /**
@@ -722,7 +767,7 @@ public class Schema implements Serializable, Cloneable {
      *            alias of the FieldSchema.
      * @return position of the FieldSchema.
      */
-    public int getPosition(String alias) {
+    public int getPosition(String alias) throws FrontendException{
 
         FieldSchema fs = getField(alias);
 
diff --git a/test/org/apache/pig/test/TestEvalPipeline.java b/test/org/apache/pig/test/TestEvalPipeline.java
index d4b94272f..665440cb8 100644
--- a/test/org/apache/pig/test/TestEvalPipeline.java
+++ b/test/org/apache/pig/test/TestEvalPipeline.java
@@ -375,7 +375,7 @@ System.out.println(last + " " + t.get(0));
         
     }
     
-    /*public void testNestedPlan() throws Exception{
+    public void testNestedPlan() throws Exception{
         int LOOP_COUNT = 10;
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
@@ -484,7 +484,7 @@ System.out.println(last + " " + t.get(0));
             ++numIdentity;
         }
         assertEquals(5, numIdentity);
-    }*/
+    }
     
 
 }
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index 13a672138..f8813700a 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -1318,12 +1318,8 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         buildPlan("b = group a by name;");
         buildPlan("c = foreach b generate flatten(a);");
         buildPlan("d = foreach c generate name;");
-        // test that we can refer to "name" field and not a::name
-        try {
-            buildPlan("e = foreach d generate a::name;");
-        } catch (AssertionFailedError e) {
-            assertTrue(e.getMessage().contains("Invalid alias: a::name in {name: bytearray}"));
-        }
+        // test that we can refer to "name" field and a::name
+        buildPlan("e = foreach d generate a::name;");
     }
     
     @Test
@@ -1350,7 +1346,7 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         try {
             buildPlan("e = foreach d generate name;");
         } catch (AssertionFailedError e) {
-            assertTrue(e.getMessage().contains("Invalid alias: name in {a::name: bytearray"));
+            assertTrue(e.getMessage().contains("Found more than one match:"));
         }
     }
 
