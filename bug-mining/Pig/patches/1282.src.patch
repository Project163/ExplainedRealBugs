diff --git a/CHANGES.txt b/CHANGES.txt
index fc461f397..2b4312301 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -60,6 +60,8 @@ Release 0.12.1 (unreleased changes)
 
 BUG FIXES
 
+PIG-3492: ColumnPrune dropping used column due to LogicalRelationalOperator.fixDuplicateUids changes not propagating (knoguchi via daijy)
+
 PIG-3325: Adding a tuple to a bag is slow (dvryaboy via aniket486)
 
 PIG-3512: Reducer estimater is broken by PIG-3497
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index bd6f849a2..c0826eaa6 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -87,6 +87,8 @@ import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.visitor.CastLineageSetter;
 import org.apache.pig.newplan.logical.visitor.ColumnAliasConversionVisitor;
+import org.apache.pig.newplan.logical.visitor.DuplicateForEachColumnRewriteVisitor;
+import org.apache.pig.newplan.logical.visitor.ImplicitSplitInsertVisitor;
 import org.apache.pig.newplan.logical.visitor.ScalarVariableValidator;
 import org.apache.pig.newplan.logical.visitor.ScalarVisitor;
 import org.apache.pig.newplan.logical.visitor.SchemaAliasVisitor;
@@ -1685,8 +1687,14 @@ public class PigServer {
             new SchemaAliasVisitor(lp).visit();
             new ScalarVisitor(lp, pigContext, scope).visit();
 
-            // TODO: move optimizer here from HExecuteEngine.
-            // TODO: input/output validation visitor
+            // ImplicitSplitInsertVisitor has to be called before
+            // DuplicateForEachColumnRewriteVisitor.  Detail at pig-1766
+            new ImplicitSplitInsertVisitor(lp).visit();
+
+            // DuplicateForEachColumnRewriteVisitor should be before
+            // TypeCheckingRelVisitor which does resetSchema/getSchema
+            // heavily
+            new DuplicateForEachColumnRewriteVisitor(lp).visit();
 
             CompilationMessageCollector collector = new CompilationMessageCollector() ;
 
diff --git a/src/org/apache/pig/newplan/logical/optimizer/AllSameRalationalNodesVisitor.java b/src/org/apache/pig/newplan/logical/optimizer/AllSameRalationalNodesVisitor.java
index ccc7daaf0..1780578c1 100644
--- a/src/org/apache/pig/newplan/logical/optimizer/AllSameRalationalNodesVisitor.java
+++ b/src/org/apache/pig/newplan/logical/optimizer/AllSameRalationalNodesVisitor.java
@@ -23,11 +23,14 @@ import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanWalker;
 import org.apache.pig.newplan.logical.relational.LOCogroup;
 import org.apache.pig.newplan.logical.relational.LOCross;
+import org.apache.pig.newplan.logical.relational.LOCube;
 import org.apache.pig.newplan.logical.relational.LODistinct;
 import org.apache.pig.newplan.logical.relational.LOFilter;
 import org.apache.pig.newplan.logical.relational.LOForEach;
 import org.apache.pig.newplan.logical.relational.LOJoin;
+import org.apache.pig.newplan.logical.relational.LOLimit;
 import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LONative;
 import org.apache.pig.newplan.logical.relational.LORank;
 import org.apache.pig.newplan.logical.relational.LOSort;
 import org.apache.pig.newplan.logical.relational.LOSplit;
@@ -129,4 +132,19 @@ public abstract class AllSameRalationalNodesVisitor extends LogicalRelationalNod
     public void visit(LOStream stream) throws FrontendException {
         execute(stream);
     }
+    
+    @Override
+    public void visit(LOLimit limit) throws FrontendException {
+        execute(limit);
+    }
+    
+    @Override
+    public void visit(LONative loNative) throws FrontendException {
+        execute(loNative);
+    }
+    
+    @Override
+    public void visit(LOCube cube) throws FrontendException {
+        execute(cube);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/optimizer/LogicalPlanOptimizer.java b/src/org/apache/pig/newplan/logical/optimizer/LogicalPlanOptimizer.java
index 4609eed1a..463d09554 100644
--- a/src/org/apache/pig/newplan/logical/optimizer/LogicalPlanOptimizer.java
+++ b/src/org/apache/pig/newplan/logical/optimizer/LogicalPlanOptimizer.java
@@ -31,10 +31,8 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.logical.rules.AddForEach;
 import org.apache.pig.newplan.logical.rules.ColumnMapKeyPrune;
-import org.apache.pig.newplan.logical.rules.DuplicateForEachColumnRewrite;
 import org.apache.pig.newplan.logical.rules.FilterAboveForeach;
 import org.apache.pig.newplan.logical.rules.GroupByConstParallelSetter;
-import org.apache.pig.newplan.logical.rules.ImplicitSplitInserter;
 import org.apache.pig.newplan.logical.rules.LimitOptimizer;
 import org.apache.pig.newplan.logical.rules.LoadTypeCastInserter;
 import org.apache.pig.newplan.logical.rules.LogicalExpressionSimplifier;
@@ -77,27 +75,10 @@ public class LogicalPlanOptimizer extends PlanOptimizer {
     protected List<Set<Rule>> buildRuleSets() {
         List<Set<Rule>> ls = new ArrayList<Set<Rule>>();
 
-        // ImplicitSplitInserter set
-        // This set of rules Insert Foreach dedicated for casting after load
-        Set<Rule> s = new HashSet<Rule>();
-        Rule r = new ImplicitSplitInserter("ImplicitSplitInserter");
-        checkAndAddRule(s, r);
-        if (!s.isEmpty())
-            ls.add(s);
-
-        // DuplicateForEachColumnRewrite set
-        // This insert Identity UDF in the case foreach duplicate field.
-        // This is because we need unique uid through out the plan
-        s = new HashSet<Rule>();
-        r = new DuplicateForEachColumnRewrite("DuplicateForEachColumnRewrite");
-        checkAndAddRule(s, r);
-        if (!s.isEmpty())
-            ls.add(s);
-
         // Logical expression simplifier
-        s = new HashSet<Rule>();
+        Set <Rule> s = new HashSet<Rule>();
         // add logical expression simplification rule
-        r = new LogicalExpressionSimplifier("FilterLogicExpressionSimplifier");
+        Rule r = new LogicalExpressionSimplifier("FilterLogicExpressionSimplifier");
         checkAndAddRule(s, r);
         ls.add(s);
 
diff --git a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
index 20627db53..6c054beb5 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
@@ -193,10 +193,6 @@ public class LOGenerate extends LogicalRelationalOperator {
             outputPlanSchemas = null;
         }
         
-        if (schema != null) {
-            LogicalRelationalOperator.fixDuplicateUids(schema.getFields());
-        }
-        
         return schema;
     }
 
diff --git a/src/org/apache/pig/newplan/logical/relational/LOJoin.java b/src/org/apache/pig/newplan/logical/relational/LOJoin.java
index 1f23c40d9..d1d5d8c98 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOJoin.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOJoin.java
@@ -156,8 +156,6 @@ public class LOJoin extends LogicalRelationalOperator {
             }
         }
 
-        LogicalRelationalOperator.fixDuplicateUids(fss);
-
         schema = new LogicalSchema();
         for(LogicalSchema.LogicalFieldSchema fieldSchema: fss) {
             schema.addField(fieldSchema);
diff --git a/src/org/apache/pig/newplan/logical/rules/DuplicateForEachColumnRewrite.java b/src/org/apache/pig/newplan/logical/rules/DuplicateForEachColumnRewrite.java
deleted file mode 100644
index 70915873e..000000000
--- a/src/org/apache/pig/newplan/logical/rules/DuplicateForEachColumnRewrite.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.pig.newplan.logical.rules;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.pig.FuncSpec;
-import org.apache.pig.data.DataType;
-import org.apache.pig.impl.builtin.IdentityColumn;
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.util.Pair;
-import org.apache.pig.newplan.Operator;
-import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.OperatorSubPlan;
-import org.apache.pig.newplan.logical.expression.LogicalExpression;
-import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
-import org.apache.pig.newplan.logical.expression.ProjectExpression;
-import org.apache.pig.newplan.logical.expression.UserFuncExpression;
-import org.apache.pig.newplan.logical.optimizer.SchemaResetter;
-import org.apache.pig.newplan.logical.optimizer.UidResetter;
-import org.apache.pig.newplan.logical.relational.LOCross;
-import org.apache.pig.newplan.logical.relational.LOForEach;
-import org.apache.pig.newplan.logical.relational.LOGenerate;
-import org.apache.pig.newplan.logical.relational.LOInnerLoad;
-import org.apache.pig.newplan.logical.relational.LOJoin;
-import org.apache.pig.newplan.logical.relational.LOSort;
-import org.apache.pig.newplan.logical.relational.LogicalPlan;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
-import org.apache.pig.newplan.logical.relational.LogicalSchema;
-import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
-import org.apache.pig.newplan.logical.rules.PushDownForEachFlatten.PushDownForEachFlattenTransformer;
-import org.apache.pig.newplan.optimizer.Rule;
-import org.apache.pig.newplan.optimizer.Transformer;
-
-/*
- * This rule rewrite duplicate column projection into Identity UDF.
- * So that we can generate different uid for each column
- */
-public class DuplicateForEachColumnRewrite extends Rule {
-
-    public DuplicateForEachColumnRewrite(String n) {
-        super(n, true);
-        // See comments in ImplicitSplitInserter for the reason to skip listener 
-        setSkipListener(true);
-    }
-
-    @Override
-    protected OperatorPlan buildPattern() {
-        LogicalPlan plan = new LogicalPlan();
-        LogicalRelationalOperator foreach = new LOForEach(plan);
-        plan.add( foreach );
-        return plan;
-    }
-
-    @Override
-    public Transformer getNewTransformer() {
-        return new DuplicateForEachColumnRewriteTransformer();
-    }
-
-    class DuplicateForEachColumnRewriteTransformer extends Transformer {
-        private List<LogicalExpressionPlan> expPlansToInsertIdentity = new ArrayList<LogicalExpressionPlan>();
-        
-        @Override
-        public boolean check(OperatorPlan matched) throws FrontendException {
-            
-            LOForEach foreach = (LOForEach)matched.getSources().get(0);
-            LOGenerate gen = (LOGenerate)foreach.getInnerPlan().getSinks().get(0);
-            
-            List<LogicalExpressionPlan> expPlans = gen.getOutputPlans();
-            boolean[] flattens = gen.getFlattenFlags();
-            
-            List<Long> uidSeen = new ArrayList<Long>();
-            
-            for (int i=0;i<expPlans.size();i++) {
-                LogicalExpressionPlan expPlan = expPlans.get(i);
-                boolean flatten = flattens[i];
-                LogicalExpression exp = (LogicalExpression)expPlan.getSources().get(0);
-                if (exp.getFieldSchema()!=null) {
-                    if (flatten && (exp.getFieldSchema().type == DataType.BAG || exp.getFieldSchema().type == DataType.TUPLE)) {
-                        List<LogicalFieldSchema> innerFieldSchemas = null;
-                        if (exp.getFieldSchema().type == DataType.BAG) {
-                            if (exp.getFieldSchema().schema!=null) {
-                                if (exp.getFieldSchema().type == DataType.BAG) {
-                                    //  assert(fieldSchema.schema.size() == 1 && fieldSchema.schema.getField(0).type == DataType.TUPLE)
-                                    if (exp.getFieldSchema().schema.getField(0).schema!=null)
-                                        innerFieldSchemas = exp.getFieldSchema().schema.getField(0).schema.getFields();
-                                } else {
-                                    if (exp.getFieldSchema().schema!=null)
-                                        innerFieldSchemas = exp.getFieldSchema().schema.getFields();
-                                }
-                            }
-                        }
-                        else { // DataType.TUPLE
-                            if (exp.getFieldSchema().schema!=null)
-                                innerFieldSchemas = exp.getFieldSchema().schema.getFields();
-                        }
-                        if (innerFieldSchemas != null) {
-                            for (LogicalFieldSchema innerFieldSchema : innerFieldSchemas) {
-                                long uid = innerFieldSchema.uid;
-                                if (checkAndAdd(uid, uidSeen)) {
-                                    // Seen before
-                                    expPlansToInsertIdentity.add(expPlan);
-                                    break;
-                                }
-                            }
-                        }
-                    }
-                    else {
-                        long uid = exp.getFieldSchema().uid;
-                        if (checkAndAdd(uid, uidSeen)) {
-                            // Seen before
-                            expPlansToInsertIdentity.add(expPlan);
-                        }
-                    }
-                }
-            }
-            
-            if (expPlansToInsertIdentity.isEmpty())
-                return false;
-            
-            return true;
-        }
-        
-        private boolean checkAndAdd(long uid, List<Long> uidSeen) {
-            if (uidSeen.contains(uid))
-                return true;
-            uidSeen.add(uid);
-            return false;
-        }
-        
-        @Override
-        public OperatorPlan reportChanges() {
-            return currentPlan;
-        }
-
-        @Override
-        public void transform(OperatorPlan matched) throws FrontendException {
-            for (LogicalExpressionPlan expPlan : expPlansToInsertIdentity) {
-                LogicalExpression oldRoot = (LogicalExpression)expPlan.getSources().get(0);
-                UserFuncExpression userFuncExpression = new UserFuncExpression(expPlan, new FuncSpec(IdentityColumn.class.getName()));
-                expPlan.connect(userFuncExpression, oldRoot);
-            }
-            expPlansToInsertIdentity.clear();
-
-            // Since we adjust the uid layout, clear all cached uids
-            UidResetter uidResetter = new UidResetter(currentPlan);
-            uidResetter.visit();
-            
-            // Manually regenerate schema since we skip listener
-            // skip duplicate uid check in schema as it would be fixed in 
-            // only portion of the plan
-            SchemaResetter schemaResetter = new SchemaResetter(currentPlan, true);
-            schemaResetter.visit();
-        }
-    }
-}
diff --git a/src/org/apache/pig/newplan/logical/rules/ImplicitSplitInserter.java b/src/org/apache/pig/newplan/logical/rules/ImplicitSplitInserter.java
deleted file mode 100644
index 9ac4c559e..000000000
--- a/src/org/apache/pig/newplan/logical/rules/ImplicitSplitInserter.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.pig.newplan.logical.rules;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Iterator;
-
-import org.apache.pig.data.DataType;
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.util.Pair;
-import org.apache.pig.newplan.Operator;
-import org.apache.pig.newplan.logical.optimizer.SchemaResetter;
-import org.apache.pig.newplan.logical.optimizer.UidResetter;
-import org.apache.pig.newplan.logical.relational.LogicalPlan;
-import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
-import org.apache.pig.newplan.logical.expression.ConstantExpression;
-import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
-import org.apache.pig.newplan.optimizer.Rule;
-import org.apache.pig.newplan.optimizer.Transformer;
-import org.apache.pig.newplan.logical.relational.LOSplit;
-import org.apache.pig.newplan.logical.relational.LOStore;
-import org.apache.pig.newplan.logical.relational.LOSplitOutput;
-import org.apache.pig.newplan.logical.relational.LogicalSchema;
-
-
-/**
- * Super class for all rules that operates on the whole plan. It doesn't look for
- * a specific pattern. An example of such kind rule is ColumnPrune.
- *
- */
-public class ImplicitSplitInserter extends Rule {
-
-    public ImplicitSplitInserter(String n) {
-        super(n, true);
-        // Skip listener, especially, skip ProjectionPatcher so that we can keep column reference for 
-        // ProjectExpression (Once ProjectionPatcher is invoked, column reference will be gone in favor of uid reference).
-        // There is no need for ProjectionPatcher in this rule since we don't swap columns; however, uid conflict is not solved
-        // at this moment (until after DuplicateForEachColumnRewrite), so keep column reference for now
-        setSkipListener(true);
-    }
-
-    @Override
-    public List<OperatorPlan> match(OperatorPlan plan) throws FrontendException {
-        // Look to see if this is a non-split node with two outputs.  If so
-        // it matches.
-        currentPlan = plan;
-        List<OperatorPlan> ll = new ArrayList<OperatorPlan>();
-        Iterator<Operator> ops = plan.getOperators();
-        while (ops.hasNext()) {
-            Operator op = ops.next();
-            if (op instanceof LOSplit || op instanceof LOStore)
-                continue;
-            List<Operator> succs = plan.getSuccessors(op);
-            if (succs != null && succs.size() >= 2) {
-                OperatorPlan match = new LogicalPlan();
-                match.add(op);
-                ll.add(match);
-            }
-        }
-        return ll;
-    }
-    
-    @Override
-    public Transformer getNewTransformer() {
-      return new ImplicitSplitInserterTransformer();
-    }
-    
-    public class ImplicitSplitInserterTransformer extends Transformer {
-      @Override
-      public boolean check(OperatorPlan matched) throws FrontendException {
-        return true;
-      }
-      
-      @Override 
-      public void transform(OperatorPlan matched) throws FrontendException {
-        if (matched == null || matched instanceof LOSplit || matched instanceof LOStore
-            || matched.size() != 1)
-          throw new FrontendException("Invalid match in ImplicitSplitInserter rule.", 2244);
-
-        // For two successors of op here is a pictorial
-        // representation of the change required:
-        // BEFORE:
-        // Succ1  Succ2
-        //  \       /
-        //      op
-        
-        //  SHOULD BECOME:
-        
-        // AFTER:
-        // Succ1          Succ2
-        //   |              |
-        // SplitOutput SplitOutput
-        //      \       /
-        //        Split
-        //          |
-        //          op
-        
-        Operator op = matched.getSources().get(0);
-        List<Operator> succs = currentPlan.getSuccessors(op);
-        if (succs == null || succs.size() < 2)
-          throw new FrontendException("Invalid match in ImplicitSplitInserter rule.", 2243);
-        LOSplit splitOp = new LOSplit(currentPlan);
-        splitOp.setAlias(((LogicalRelationalOperator) op).getAlias());
-        Operator[] sucs = succs.toArray(new Operator[0]);
-        currentPlan.add(splitOp);
-        currentPlan.connect(op, splitOp);
-        for (Operator suc : sucs) {
-          // position is remembered in order to maintain the order of the successors
-          Pair<Integer, Integer> pos = currentPlan.disconnect(op, suc);
-          LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
-          new ConstantExpression(filterPlan, Boolean.valueOf(true));
-          LOSplitOutput splitOutput = new LOSplitOutput((LogicalPlan) currentPlan, filterPlan);
-          splitOutput.setAlias(splitOp.getAlias());
-          currentPlan.add(splitOutput);
-          currentPlan.connect(splitOp, splitOutput);
-          currentPlan.connect(splitOutput, pos.first, suc, pos.second);
-        }
-        
-        // Since we adjust the uid layout, clear all cached uids
-        UidResetter uidResetter = new UidResetter(currentPlan);
-        uidResetter.visit();
-
-        // Manually regenerate schema since we skip listener
-        SchemaResetter schemaResetter = new SchemaResetter(currentPlan, true);
-        schemaResetter.visit();
-      }
-      
-      @Override
-      public OperatorPlan reportChanges() {
-        return currentPlan;
-      }
-    }
-    
-    @Override
-    protected OperatorPlan buildPattern() {
-        return null;
-    }
-}
diff --git a/src/org/apache/pig/newplan/logical/visitor/DuplicateForEachColumnRewriteVisitor.java b/src/org/apache/pig/newplan/logical/visitor/DuplicateForEachColumnRewriteVisitor.java
new file mode 100644
index 000000000..e169bfe28
--- /dev/null
+++ b/src/org/apache/pig/newplan/logical/visitor/DuplicateForEachColumnRewriteVisitor.java
@@ -0,0 +1,154 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.newplan.logical.visitor;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.pig.FuncSpec;
+import org.apache.pig.data.DataType;
+import org.apache.pig.impl.builtin.IdentityColumn;
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.util.Pair;
+import org.apache.pig.newplan.DependencyOrderWalker;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.OperatorSubPlan;
+import org.apache.pig.newplan.logical.expression.LogicalExpression;
+import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
+import org.apache.pig.newplan.logical.expression.ProjectExpression;
+import org.apache.pig.newplan.logical.expression.UserFuncExpression;
+import org.apache.pig.newplan.logical.optimizer.SchemaResetter;
+import org.apache.pig.newplan.logical.optimizer.UidResetter;
+import org.apache.pig.newplan.logical.relational.LOCross;
+import org.apache.pig.newplan.logical.relational.LOForEach;
+import org.apache.pig.newplan.logical.relational.LOGenerate;
+import org.apache.pig.newplan.logical.relational.LOInnerLoad;
+import org.apache.pig.newplan.logical.relational.LOJoin;
+import org.apache.pig.newplan.logical.relational.LOSort;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.newplan.logical.relational.LogicalSchema.LogicalFieldSchema;
+
+public class DuplicateForEachColumnRewriteVisitor
+             extends LogicalRelationalNodesVisitor {
+
+    public DuplicateForEachColumnRewriteVisitor (OperatorPlan plan)
+        throws FrontendException {
+        super(plan, new DependencyOrderWalker(plan));
+    }
+
+    @Override
+    public void visit(LOForEach foreach) throws FrontendException {
+        List <LogicalExpressionPlan> expPlansToInsertIdentity
+                                = findAllExpPlansToInsertIdentity(foreach);
+        if( expPlansToInsertIdentity.isEmpty() ) {
+          return;
+        }
+
+
+        // Following section is moved from
+        // newplan/logical/rules/DuplicateForEachColumnRewrite.transform()
+
+        for (LogicalExpressionPlan expPlan : expPlansToInsertIdentity) {
+            LogicalExpression oldRoot = (LogicalExpression)expPlan.getSources().get(0);
+            UserFuncExpression userFuncExpression = new UserFuncExpression(expPlan, new FuncSpec(IdentityColumn.class.getName()));
+            expPlan.connect(userFuncExpression, oldRoot);
+        }
+        expPlansToInsertIdentity.clear();
+
+        // Since we adjust the uid layout, clear all cached uids
+        UidResetter uidResetter = new UidResetter(plan);
+        uidResetter.visit();
+
+        // Manually regenerate schema
+        // skip duplicate uid check in schema as it would be fixed in
+        // only portion of the plan
+        SchemaResetter schemaResetter = new SchemaResetter(plan, true);
+        schemaResetter.visit();
+    }
+
+    // moved from newplan/logical/rules/DuplicateForEachColumnRewrite.check()
+    private List<LogicalExpressionPlan> findAllExpPlansToInsertIdentity(LOForEach foreach) throws FrontendException {
+
+        LOGenerate gen = (LOGenerate)foreach.getInnerPlan().getSinks().get(0);
+
+        List<LogicalExpressionPlan> expPlans = gen.getOutputPlans();
+        boolean[] flattens = gen.getFlattenFlags();
+
+        List<LogicalExpressionPlan> expPlansToInsertIdentity = new ArrayList<LogicalExpressionPlan>();
+        List<Long> uidSeen = new ArrayList<Long>();
+
+        for (int i=0;i<expPlans.size();i++) {
+            LogicalExpressionPlan expPlan = expPlans.get(i);
+            boolean flatten = flattens[i];
+            LogicalExpression exp = (LogicalExpression)expPlan.getSources().get(0);
+            if (exp.getFieldSchema()!=null) {
+                if (flatten && (exp.getFieldSchema().type == DataType.BAG || exp.getFieldSchema().type == DataType.TUPLE)) {
+                    List<LogicalFieldSchema> innerFieldSchemas = null;
+                    if (exp.getFieldSchema().type == DataType.BAG) {
+                        if (exp.getFieldSchema().schema!=null) {
+                            if (exp.getFieldSchema().type == DataType.BAG) {
+                                //  assert(fieldSchema.schema.size() == 1 && fieldSchema.schema.getField(0).type == DataType.TUPLE)
+                                if (exp.getFieldSchema().schema.getField(0).schema!=null)
+                                    innerFieldSchemas = exp.getFieldSchema().schema.getField(0).schema.getFields();
+                            } else {
+                                if (exp.getFieldSchema().schema!=null)
+                                    innerFieldSchemas = exp.getFieldSchema().schema.getFields();
+                            }
+                        }
+                    }
+                    else { // DataType.TUPLE
+                        if (exp.getFieldSchema().schema!=null)
+                            innerFieldSchemas = exp.getFieldSchema().schema.getFields();
+                    }
+                    if (innerFieldSchemas != null) {
+                        for (LogicalFieldSchema innerFieldSchema : innerFieldSchemas) {
+                            long uid = innerFieldSchema.uid;
+                            if (checkAndAdd(uid, uidSeen)) {
+                                // Seen before
+                                expPlansToInsertIdentity.add(expPlan);
+                                break;
+                            }
+                        }
+                    }
+                }
+                else {
+                    long uid = exp.getFieldSchema().uid;
+                    if (checkAndAdd(uid, uidSeen)) {
+                        // Seen before
+                        expPlansToInsertIdentity.add(expPlan);
+                    }
+                }
+            }
+        }
+        return expPlansToInsertIdentity;
+    }
+
+    private boolean checkAndAdd(long uid, List<Long> uidSeen) {
+        if (uidSeen.contains(uid))
+            return true;
+        uidSeen.add(uid);
+        return false;
+    }
+
+}
+
diff --git a/src/org/apache/pig/newplan/logical/visitor/ImplicitSplitInsertVisitor.java b/src/org/apache/pig/newplan/logical/visitor/ImplicitSplitInsertVisitor.java
new file mode 100644
index 000000000..0e009194a
--- /dev/null
+++ b/src/org/apache/pig/newplan/logical/visitor/ImplicitSplitInsertVisitor.java
@@ -0,0 +1,114 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.newplan.logical.visitor;
+
+import java.util.List;
+
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.util.Pair;
+import org.apache.pig.newplan.DependencyOrderWalker;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.logical.expression.ConstantExpression;
+import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
+import org.apache.pig.newplan.logical.optimizer.AllSameRalationalNodesVisitor;
+import org.apache.pig.newplan.logical.optimizer.SchemaResetter;
+import org.apache.pig.newplan.logical.optimizer.UidResetter;
+import org.apache.pig.newplan.logical.relational.LOSplit;
+import org.apache.pig.newplan.logical.relational.LOSplitOutput;
+import org.apache.pig.newplan.logical.relational.LOStore;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
+
+
+public class ImplicitSplitInsertVisitor extends AllSameRalationalNodesVisitor {
+
+    public ImplicitSplitInsertVisitor(LogicalPlan plan) throws FrontendException {
+        super(plan, new DependencyOrderWalker(plan));
+    }
+
+    // Look to see if this is a non-split node with two outputs.  If so
+    // it matches.
+    private boolean nodeHasTwoOutputs(LogicalRelationalOperator op) {
+        if (op instanceof LOSplit || op instanceof LOStore) {
+            return false;
+        }
+        List<Operator> succs = plan.getSuccessors(op);
+        if (succs != null && succs.size() >= 2) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public void execute(LogicalRelationalOperator op) throws FrontendException {
+        if(!nodeHasTwoOutputs(op) )  {
+            return;
+        }
+
+        // For two successors of op here is a pictorial
+        // representation of the change required:
+        // BEFORE:
+        // Succ1  Succ2
+        //  \       /
+        //      op
+
+        //  SHOULD BECOME:
+
+        // AFTER:
+        // Succ1          Succ2
+        //   |              |
+        // SplitOutput SplitOutput
+        //      \       /
+        //        Split
+        //          |
+        //          op
+
+        List<Operator> succs = plan.getSuccessors(op);
+        if (succs == null || succs.size() < 2) {
+            throw new FrontendException("Invalid match in ImplicitSplitInserter rule.", 2243);
+        }
+        LOSplit splitOp = new LOSplit(plan);
+        splitOp.setAlias(((LogicalRelationalOperator) op).getAlias());
+        Operator[] sucs = succs.toArray(new Operator[0]);
+        plan.add(splitOp);
+        plan.connect(op, splitOp);
+        for (Operator suc : sucs) {
+            // position is remembered in order to maintain the order of the successors
+            Pair<Integer, Integer> pos = plan.disconnect(op, suc);
+            LogicalExpressionPlan filterPlan = new LogicalExpressionPlan();
+            new ConstantExpression(filterPlan, Boolean.valueOf(true));
+            LOSplitOutput splitOutput = new LOSplitOutput((LogicalPlan) plan, filterPlan);
+            splitOutput.setAlias(splitOp.getAlias());
+            plan.add(splitOutput);
+            plan.connect(splitOp, splitOutput);
+            plan.connect(splitOutput, pos.first, suc, pos.second);
+        }
+
+        // Since we adjust the uid layout, clear all cached uids
+        UidResetter uidResetter = new UidResetter(plan);
+        uidResetter.visit();
+
+        // Manually regenerate schema
+        SchemaResetter schemaResetter = new SchemaResetter(plan, true);
+        schemaResetter.visit();
+    }
+}
diff --git a/src/org/apache/pig/parser/LogicalPlanBuilder.java b/src/org/apache/pig/parser/LogicalPlanBuilder.java
index 59506940e..e55a2e3ff 100644
--- a/src/org/apache/pig/parser/LogicalPlanBuilder.java
+++ b/src/org/apache/pig/parser/LogicalPlanBuilder.java
@@ -319,7 +319,13 @@ public class LogicalPlanBuilder {
         }
         sort.setAscendingCols( ascFlags );
         alias = buildOp( loc, sort, alias, inputAlias, null );
-        expandAndResetVisitor(loc, sort);
+        try {
+            (new ProjectStarExpander(sort.getPlan())).visit(sort);
+            (new ProjStarInUdfExpander(sort.getPlan())).visit(sort);
+            new SchemaResetter(sort.getPlan(), true).visit(sort);
+        } catch (FrontendException e ) {
+            throw new ParserValidationException( intStream, loc, e );
+        }
         return alias;
     }
 
@@ -339,7 +345,13 @@ public class LogicalPlanBuilder {
         rank.setAscendingCol(ascFlags);
 
         buildOp( loc, rank, alias, inputAlias, null );
-        expandAndResetVisitor(loc, rank);
+        try {
+            (new ProjectStarExpander(rank.getPlan())).visit(rank);
+            (new ProjStarInUdfExpander(rank.getPlan())).visit(rank);
+            new SchemaResetter(rank.getPlan(), true).visit(rank);
+        } catch (FrontendException e ) {
+            throw new ParserValidationException( intStream, loc, e );
+        }
 
         return alias;
     }
@@ -396,20 +408,16 @@ public class LogicalPlanBuilder {
         op.setInnerFlags( flags );
         op.setJoinPlans( joinPlans );
         alias = buildOp( loc, op, alias, inputAliases, partitioner );
-        expandAndResetVisitor(loc, op);
+        try {
+            (new ProjectStarExpander(op.getPlan())).visit(op);
+            (new ProjStarInUdfExpander(op.getPlan())).visit(op);
+            new SchemaResetter(op.getPlan(), true).visit(op);
+        } catch (FrontendException e ) {
+            throw new ParserValidationException( intStream, loc, e );
+        }
         return alias;
     }
 
-    private void expandAndResetVisitor(SourceLocation loc,
-	    LogicalRelationalOperator lrop) throws ParserValidationException {
-        try {
-	    (new ProjectStarExpander(lrop.getPlan())).visit();
-	    (new ProjStarInUdfExpander(lrop.getPlan())).visit();
-	    new SchemaResetter(lrop.getPlan(), true).visit();
-	} catch (FrontendException e) {
-	    throw new ParserValidationException(intStream, loc, e);
-	}
-    }
 
     LOCube createCubeOp() {
 	return new LOCube(plan);
@@ -426,7 +434,13 @@ public class LogicalPlanBuilder {
 	op.setExpressionPlans(expressionPlans);
 	op.setOperations(operations);
 	buildOp(loc, op, alias, inputAlias, null);
-	expandAndResetVisitor(loc, op);
+        try {
+            (new ProjectStarExpander(op.getPlan())).visit(op);
+            (new ProjStarInUdfExpander(op.getPlan())).visit(op);
+            new SchemaResetter(op.getPlan(), true).visit(op);
+        } catch (FrontendException e ) {
+            throw new ParserValidationException( intStream, loc, e );
+        }
 	try {
 	    alias = convertCubeToFGPlan(loc, op, inputAlias, operations, expressionPlans);
 	} catch (FrontendException e) {
@@ -822,7 +836,13 @@ public class LogicalPlanBuilder {
         op.setGroupType( gt );
         op.setInnerFlags( flags );
         alias = buildOp( loc, op, alias, inputAliases, partitioner );
-        expandAndResetVisitor(loc, op);
+        try {
+            (new ProjectStarExpander(op.getPlan())).visit(op);
+            (new ProjStarInUdfExpander(op.getPlan())).visit(op);
+            new SchemaResetter(op.getPlan(), true).visit(op);
+        } catch (FrontendException e ) {
+            throw new ParserValidationException( intStream, loc, e );
+        }
 
         return alias;
     }
@@ -976,7 +996,13 @@ public class LogicalPlanBuilder {
     throws ParserValidationException {
         op.setInnerPlan( innerPlan );
         alias = buildOp( loc, op, alias, inputAlias, null );
-        expandAndResetVisitor(loc, op);
+        try {
+            (new ProjectStarExpander(op.getPlan())).visit(op);
+            (new ProjStarInUdfExpander(op.getPlan())).visit(op);
+            new SchemaResetter(op.getPlan(), true).visit(op);
+        } catch (FrontendException e ) {
+            throw new ParserValidationException( intStream, loc, e );
+        }
         return alias;
     }
 
diff --git a/src/org/apache/pig/pen/LineageTrimmingVisitor.java b/src/org/apache/pig/pen/LineageTrimmingVisitor.java
index 917073c7b..51139bcc6 100644
--- a/src/org/apache/pig/pen/LineageTrimmingVisitor.java
+++ b/src/org/apache/pig/pen/LineageTrimmingVisitor.java
@@ -49,6 +49,7 @@ import org.apache.pig.newplan.logical.relational.LOLimit;
 import org.apache.pig.newplan.logical.relational.LOLoad;
 import org.apache.pig.newplan.logical.relational.LOSort;
 import org.apache.pig.newplan.logical.relational.LOSplit;
+import org.apache.pig.newplan.logical.relational.LOSplitOutput;
 import org.apache.pig.newplan.logical.relational.LOUnion;
 import org.apache.pig.newplan.logical.relational.LOStore;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
@@ -211,6 +212,13 @@ public class LineageTrimmingVisitor extends LogicalRelationalNodesVisitor {
 
     }
 
+    @Override
+    public void visit(LOSplitOutput split) throws FrontendException {
+        if(continueTrimming)
+            processOperator(split);
+
+    }
+
     @Override
     public void visit(LOUnion u) throws FrontendException {
         if(continueTrimming)
diff --git a/test/org/apache/pig/test/TestMultiQueryCompiler.java b/test/org/apache/pig/test/TestMultiQueryCompiler.java
index 1ac58bec9..a24021d9d 100644
--- a/test/org/apache/pig/test/TestMultiQueryCompiler.java
+++ b/test/org/apache/pig/test/TestMultiQueryCompiler.java
@@ -111,7 +111,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("store D1 into '/tmp/output1';");
             myPig.registerQuery("store D2 into '/tmp/output2';");
             
-            LogicalPlan lp = checkLogicalPlan(1, 2, 9);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 12);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 15);
 
@@ -168,7 +168,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("p4 = foreach g4 generate group, COUNT(f4.gid);");
             myPig.registerQuery("store p4 into '/tmp/output4';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 4, 17);
+            LogicalPlan lp = checkLogicalPlan(1, 4, 26);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 4, 35);
 
@@ -203,7 +203,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("e = foreach d generate group, COUNT(c), COUNT(b);");
             myPig.registerQuery("store e into '/tmp/output1';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 1, 6);
+            LogicalPlan lp = checkLogicalPlan(1, 1, 9);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 1, 13);
 
@@ -235,7 +235,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("g1 = foreach g generate group, COUNT(d), COUNT(e);");
             myPig.registerQuery("store g1 into '/tmp/output2';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 2, 11);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 16);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 23);
 
@@ -268,7 +268,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("h = foreach g generate group, COUNT(f.uid);");
             myPig.registerQuery("store h into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 11);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 17);
 
             // NOTE: old way seemingly generated a useless foreach operator. Now we have one less operator. Reason unknow.
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 19);
@@ -333,7 +333,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d2 = foreach d1 generate group, AVG(d.uid);");            
             myPig.registerQuery("store d2 into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
 
@@ -365,7 +365,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("f1 = foreach f generate group, SUM(d.c::uid);");
             myPig.registerQuery("store f1 into '/tmp/output2';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 2, 10);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 16);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 25);
 
@@ -401,7 +401,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d2 = foreach d1 generate group, MAX(d.uid) - MIN(d.uid);");
             myPig.registerQuery("store d2 into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
 
@@ -437,7 +437,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d2 = foreach d1 generate group, d.uname, MAX(d.uid) - MIN(d.uid);");
             myPig.registerQuery("store d2 into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
 
@@ -473,7 +473,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d2 = foreach d1 generate group, COUNT(d.uid);");
             myPig.registerQuery("store d2 into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
 
@@ -507,7 +507,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("H = foreach G generate group, COUNT(A1);");          
             myPig.registerQuery("store H into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 15);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 24);
 
@@ -603,7 +603,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("e = join c by gid, d by gid using 'repl';");
             myPig.registerQuery("store e into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(2, 3, 8);
+            LogicalPlan lp = checkLogicalPlan(2, 3, 14);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 2, 3, 16);
 
@@ -632,7 +632,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d = foreach e generate flatten(c), flatten(b);");
             myPig.registerQuery("store d into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 9);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 15);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 19);
 
@@ -663,7 +663,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d = foreach c generate flatten(group), flatten($1), flatten($2);");
             myPig.registerQuery("store d into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 11);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 17);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 21);
 
@@ -720,7 +720,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("f = filter e by b::uid < 1000;");
             myPig.registerQuery("store f into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 9);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 22);
 
@@ -753,7 +753,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("store g into '/tmp/output1';");
             myPig.registerQuery("store h into '/tmp/output2';");
             
-            LogicalPlan lp = checkLogicalPlan(2, 2, 10);
+            LogicalPlan lp = checkLogicalPlan(2, 2, 13);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 2, 2, 20);
 
@@ -782,7 +782,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("e = filter d by $1 > 5;");
             myPig.registerQuery("store e into '/tmp/output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 7);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 10);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 13);
 
@@ -813,7 +813,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("g = foreach f generate group, SUM(e.$0);");
             myPig.registerQuery("store g into '/tmp/output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 9);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 12);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 17);
 
@@ -847,7 +847,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("f2 = foreach f1 generate group, COUNT(f.$0);");
             myPig.registerQuery("store f2 into '/tmp/output2';");
             
-            LogicalPlan lp = checkLogicalPlan(1, 2, 12);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 15);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 22);
 
@@ -887,7 +887,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("f5 = foreach f4 generate group, COUNT(f3.$0);");
             myPig.registerQuery("store f5 into '/tmp/output2';");
             
-            LogicalPlan lp = checkLogicalPlan(1, 2, 18);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 21);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 32);
 
@@ -923,7 +923,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d2 = foreach d1 generate group, COUNT(d.uid);");
             myPig.registerQuery("store d2 into '/tmp/output3';");
              
-            LogicalPlan lp = checkLogicalPlan(1, 3, 14);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 18);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 25);
 
@@ -950,7 +950,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("c = group b by gid;");
             myPig.registerQuery("store c into '/tmp/output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 5);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 8);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 11);
 
@@ -979,7 +979,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("d = filter c by uid > 15;");
             myPig.registerQuery("store d into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 7);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 13);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 14);
 
@@ -1010,7 +1010,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("e = cogroup c by uid, d by uid;");
             myPig.registerQuery("store e into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(2, 3, 8);
+            LogicalPlan lp = checkLogicalPlan(2, 3, 14);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 2, 3, 19);
 
@@ -1079,7 +1079,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("g = group f by $0;");
             myPig.registerQuery("store g into '/tmp/output4';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 10);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 13);
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 20);
             MROperPlan mp = checkMRPlan(pp, 1, 2, 3);
 
@@ -1191,7 +1191,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("store b into '/tmp/output2';");
             myPig.registerQuery("store b into '/tmp/output3';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 5);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 9);
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 10);
             MROperPlan mp = checkMRPlan(pp, 1, 1, 1);
 
@@ -1384,7 +1384,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("STORE c INTO 'output1';");
             myPig.registerQuery("STORE l INTO 'output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 6);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 9);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 12);
 
@@ -1420,7 +1420,7 @@ public class TestMultiQueryCompiler {
             myPig.registerQuery("STORE c1 INTO 'output1';");
             myPig.registerQuery("STORE c2 INTO 'output2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 7);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 10);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 15);
 
diff --git a/test/org/apache/pig/test/TestMultiQueryLocal.java b/test/org/apache/pig/test/TestMultiQueryLocal.java
index b7eddfbd7..9b7354285 100644
--- a/test/org/apache/pig/test/TestMultiQueryLocal.java
+++ b/test/org/apache/pig/test/TestMultiQueryLocal.java
@@ -96,7 +96,7 @@ public class TestMultiQueryLocal {
             myPig.registerQuery("c = group b by gid;");
             myPig.registerQuery("store c into '" + TMP_DIR + "/Pig-TestMultiQueryLocal2';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 2, 5);
+            LogicalPlan lp = checkLogicalPlan(1, 2, 8);
 
             // XXX Physical plan has one less node in the local case
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 2, 11);
@@ -197,7 +197,7 @@ public class TestMultiQueryLocal {
             myPig.registerQuery("d = filter c by uid > 15;");
             myPig.registerQuery("store d into '" + TMP_DIR + "/Pig-TestMultiQueryLocal3';");
 
-            LogicalPlan lp = checkLogicalPlan(1, 3, 7);
+            LogicalPlan lp = checkLogicalPlan(1, 3, 13);
 
             PhysicalPlan pp = checkPhysicalPlan(lp, 1, 3, 14);
 
@@ -258,7 +258,7 @@ public class TestMultiQueryLocal {
             myPig.registerQuery("e = cogroup c by uid, d by uid;");
             myPig.registerQuery("store e into '" + TMP_DIR + "/Pig-TestMultiQueryLocal3';");
 
-            LogicalPlan lp = checkLogicalPlan(2, 3, 8);
+            LogicalPlan lp = checkLogicalPlan(2, 3, 14);
 
             // XXX the total number of ops is one less in the local case
             PhysicalPlan pp = checkPhysicalPlan(lp, 2, 3, 19);
diff --git a/test/org/apache/pig/test/TestOptimizeLimit.java b/test/org/apache/pig/test/TestOptimizeLimit.java
index c948d9cfd..3085c1cbf 100644
--- a/test/org/apache/pig/test/TestOptimizeLimit.java
+++ b/test/org/apache/pig/test/TestOptimizeLimit.java
@@ -225,8 +225,7 @@ public class TestOptimizeLimit {
         optimizePlan(newLogicalPlan);
         LOStore store = (LOStore)newLogicalPlan.getSinks().get(0);
         LOForEach foreach1 = (LOForEach)newLogicalPlan.getPredecessors(store).get(0);
-        LOForEach foreach2 = (LOForEach)newLogicalPlan.getPredecessors(foreach1).get(0);
-        LOLimit limit = (LOLimit)newLogicalPlan.getPredecessors(foreach2).get(0);
+        LOLimit limit = (LOLimit)newLogicalPlan.getPredecessors(foreach1).get(0);
         Assert.assertTrue(newLogicalPlan.getSoftLinkPredecessors(limit).get(0) instanceof LOStore);
     }
 
diff --git a/test/org/apache/pig/test/TestPruneColumn.java b/test/org/apache/pig/test/TestPruneColumn.java
index 579ec0950..d47f03e8d 100644
--- a/test/org/apache/pig/test/TestPruneColumn.java
+++ b/test/org/apache/pig/test/TestPruneColumn.java
@@ -54,6 +54,7 @@ import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;
 import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigTextInputFormat;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
+import org.apache.pig.impl.PigImplConstants;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.ObjectSerializer;
@@ -78,6 +79,7 @@ public class TestPruneColumn {
     File tmpFile10;
     File tmpFile11;
     File tmpFile12;
+    File tmpFile13;
     File logFile;
 
     private static final String simpleEchoStreamingCommand;
@@ -179,6 +181,16 @@ public class TestPruneColumn {
         ps.println("[key1#1,key2#2,cond#1]");
         ps.println("[key1#2,key2#3,cond#1]");
         ps.close();
+        
+        tmpFile13 = File.createTempFile("prune", "txt");
+        ps = new PrintStream(new FileOutputStream(tmpFile13));
+        ps.println("3\ti");
+        ps.println("3\ti");
+        ps.println("1\ti");
+        ps.println("2\ti");
+        ps.println("2\ti");
+        ps.println("3\ti");
+        ps.close();
     }
 
     @After
@@ -1548,6 +1560,41 @@ public class TestPruneColumn {
         assertTrue(checkLogFileMessage(new String[]{"Columns pruned for A: $1",
                 "Columns pruned for B: $1"}));
     }
+    
+    @Test
+    public void testComplex2() throws Exception {
+        HashSet<String> optimizerRules = new HashSet<String>();
+        optimizerRules.add("PushUpFilter");
+        pigServer.getPigContext().getProperties().setProperty(
+                PigImplConstants.PIG_OPTIMIZER_RULES_KEY,
+                ObjectSerializer.serialize(optimizerRules));
+        pigServer.registerQuery("A = load '"+ Util.generateURI(Util.encodeEscape(tmpFile13.toString()), pigServer.getPigContext()) + "' as (a:int, b:chararray);");
+        pigServer.registerQuery("B = FOREACH A generate a;");
+        pigServer.registerQuery("C = GROUP B by a;");
+        pigServer.registerQuery("D = filter C by group > 0 and group < 100;");
+        pigServer.registerQuery("E = FOREACH D {F = LIMIT B 1 ;GENERATE B.a as mya, FLATTEN(F.a) as setting;}");
+        pigServer.registerQuery("G = FOREACH E GENERATE mya, setting as setting;");
+
+        Iterator<Tuple> iter = pigServer.openIterator("G");
+
+        assertTrue(iter.hasNext());
+        Tuple t = iter.next();
+        assertEquals("({(1)},1)", t.toString());
+        
+        assertTrue(iter.hasNext());
+        t = iter.next();
+        assertEquals("({(2),(2)},2)", t.toString());
+        
+        assertTrue(iter.hasNext());
+        t = iter.next();
+        assertEquals("({(3),(3),(3)},3)", t.toString());
+
+        assertFalse(iter.hasNext());
+
+        assertTrue(checkLogFileMessage(new String[]{"Columns pruned for A: $1"}));
+        
+        pigServer.getPigContext().getProperties().remove(PigImplConstants.PIG_OPTIMIZER_RULES_KEY);
+    }
 
     @Test
     public void testCoGroup8() throws Exception {
