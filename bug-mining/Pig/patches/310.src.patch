diff --git a/CHANGES.txt b/CHANGES.txt
index 130609d91..c9fca8232 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -45,6 +45,10 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-1068:  COGROUP fails with 'Type mismatch in key from map: expected
+		   org.apache.pig.impl.io.NullableText, recieved
+		   org.apache.pig.impl.io.NullableTuple' (rding via gates)
+
 PIG-1113: Diamond query optimization throws error in JOIN (rding via olgan)
 
 PIG-1116: Remove redundant map-reduce job for merge join (pradeepkth)
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java
index a0e0c46c5..c1861c997 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java
@@ -662,9 +662,10 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
                 pkg.addPackage(p);
                 pkCount++;
             }
+            pkg.addIsKeyWrappedList(((POMultiQueryPackage)pk).getIsKeyWrappedList());
             addShiftedKeyInfoIndex(initial, current, (POMultiQueryPackage)pk);
         } else {
-            pkg.addPackage(pk);
+            pkg.addPackage(pk, mapKeyType);
             pkCount = 1;
         }
         
@@ -673,8 +674,6 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
             String msg = "Internal Error. Inconsistency in key index found during optimization.";
             throw new OptimizerException(msg, errCode, PigException.BUG);
         }
-
-        boolean[] keyPos = pk.getKeyPositionsInTuple();
         
         PODemux demux = (PODemux)to.getLeaves().get(0);
         int plCount = 0;
@@ -685,12 +684,11 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
             // operator, then it's the only operator in the plan.
             List<PhysicalPlan> pls = ((PODemux)root).getPlans();
             for (PhysicalPlan pl : pls) {
-                demux.addPlan(pl, keyPos);
+                demux.addPlan(pl);
                 plCount++;
             }
-            demux.addIsKeyWrappedList(((PODemux)root).getIsKeyWrappedList());
         } else {
-            demux.addPlan(from, mapKeyType, keyPos);
+            demux.addPlan(from);
             plCount = 1;
         }
         
@@ -700,11 +698,11 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
             throw new OptimizerException(msg, errCode, PigException.BUG);
         }
 
-        if (demux.isSameMapKeyType()) {
+        if (pkg.isSameMapKeyType()) {
             pkg.setKeyType(pk.getKeyType());
         } else {
             pkg.setKeyType(DataType.TUPLE);
-        }                
+        }            
     }
     
     private void addShiftedKeyInfoIndex(int index, POPackage pkg) throws OptimizerException {
@@ -785,11 +783,11 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
         from.remove(cpk);
         
         PODemux demux = (PODemux)to.getLeaves().get(0);
-        
-        boolean isSameKeyType = demux.isSameMapKeyType();
-        
+                
         POMultiQueryPackage pkg = (POMultiQueryPackage)to.getRoots().get(0);
         
+        boolean isSameKeyType = pkg.isSameMapKeyType();
+        
         // if current > initial + 1, it means we had
         // a split in the map of the MROper we are trying to
         // merge. In that case we would have changed the indices
@@ -818,6 +816,8 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
             pkCount = 1;
         }
 
+        pkg.setSameMapKeyType(isSameKeyType);
+        
         if (pkCount != total) {
             int errCode = 2146;
             String msg = "Internal Error. Inconsistency in key index found during optimization.";
@@ -831,8 +831,6 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
         
         pkg.setKeyType(cpk.getKeyType());
         
-        boolean[] keyPos = cpk.getKeyPositionsInTuple();
-        
         // See comment above for why we flatten the Packages
         // in the from plan - for the same reason, we flatten
         // the inner plans of Demux operator now.
@@ -841,7 +839,7 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
         if (leaf instanceof PODemux) {
             List<PhysicalPlan> pls = ((PODemux)leaf).getPlans();
             for (PhysicalPlan pl : pls) {
-                demux.addPlan(pl, mapKeyType, keyPos);
+                demux.addPlan(pl);
                 POLocalRearrange lr = (POLocalRearrange)pl.getLeaves().get(0);
                 try {
                     lr.setMultiQueryIndex(initial + plCount++);            
@@ -858,7 +856,7 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
                 }
             }
         } else {
-            demux.addPlan(from, mapKeyType, keyPos);
+            demux.addPlan(from);
             POLocalRearrange lr = (POLocalRearrange)from.getLeaves().get(0);
             try {
                 lr.setMultiQueryIndex(initial + plCount++);            
@@ -895,8 +893,8 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
        
     private PhysicalPlan createDemuxPlan(boolean sameKeyType, boolean isCombiner) 
         throws VisitorException {
-        PODemux demux = getDemux(sameKeyType, isCombiner);
-        POMultiQueryPackage pkg= getMultiQueryPackage();
+        PODemux demux = getDemux(isCombiner);
+        POMultiQueryPackage pkg= getMultiQueryPackage(sameKeyType, isCombiner);
         
         PhysicalPlan pl = new PhysicalPlan();
         pl.add(pkg);
@@ -1135,14 +1133,17 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
         return new POStore(new OperatorKey(scope, nig.getNextNodeId(scope)));
     } 
      
-    private PODemux getDemux(boolean sameMapKeyType, boolean inCombiner){
+    private PODemux getDemux(boolean inCombiner){
         PODemux demux = new PODemux(new OperatorKey(scope, nig.getNextNodeId(scope)));
-        demux.setSameMapKeyType(sameMapKeyType);
         demux.setInCombiner(inCombiner);
         return demux;
     } 
     
-    private POMultiQueryPackage getMultiQueryPackage(){
-        return new POMultiQueryPackage(new OperatorKey(scope, nig.getNextNodeId(scope)));
+    private POMultiQueryPackage getMultiQueryPackage(boolean sameMapKeyType, boolean inCombiner){
+        POMultiQueryPackage pkg =  
+            new POMultiQueryPackage(new OperatorKey(scope, nig.getNextNodeId(scope)));
+        pkg.setInCombiner(inCombiner);
+        pkg.setSameMapKeyType(sameMapKeyType);
+        return pkg;
     }   
 }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/PODemux.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/PODemux.java
index 100ac8070..8afc269ed 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/PODemux.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/PODemux.java
@@ -68,26 +68,6 @@ public class PODemux extends PhysicalOperator {
      */
     private ArrayList<PhysicalPlan> myPlans = new ArrayList<PhysicalPlan>();
     
-    /**
-     * If the POLocalRearranges corresponding to the reduce plans in 
-     * myPlans (the list of inner plans of the demux) have different key types
-     * then the MultiQueryOptimizer converts all the keys to be of type tuple
-     * by wrapping any non-tuple keys into Tuples (keys which are already tuples
-     * are left alone).
-     * The list below is a list of booleans indicating whether extra tuple wrapping
-     * was done for the key in the corresponding POLocalRearranges and if we need
-     * to "unwrap" the tuple to get to the key
-     */
-    private ArrayList<Boolean> isKeyWrapped = new ArrayList<Boolean>();
-    
-    /**
-     * The list tracks the field position of the key in the input tuple so that
-     * the right values are "unwrapped" to get the key. 
-     * The tuples emitted from POCombinerPackages always have keys in a fixed 
-     * position, but this position varies depending on the Pig Latin scripts.
-     */
-    private ArrayList<boolean[]> keyPositions = new ArrayList<boolean[]>();
-    
     /*
      * Flag indicating when a new pull should start 
      */
@@ -105,14 +85,6 @@ public class PODemux extends PhysicalOperator {
      */
     private PhysicalOperator curLeaf = null;
     
-    /*
-     * Indicating if all the inner plans have the same
-     * map key type. If not, the keys passed in are 
-     * wrapped inside tuples and need to be extracted
-     * out during the reduce phase 
-     */
-    private boolean sameMapKeyType = true;
-    
     /*
      * Indicating if this operator is in a combiner. 
      * If not, this operator is in a reducer and the key
@@ -172,7 +144,7 @@ public class PODemux extends PhysicalOperator {
 
     @Override
     public String name() {
-        return "Demux" + isKeyWrapped + " - " + mKey.toString();
+        return "Demux [" + myPlans.size() + "] "+ mKey.toString();
     }
 
     @Override
@@ -194,46 +166,15 @@ public class PODemux extends PhysicalOperator {
         return myPlans;
     }
     
-    /**
-     * Returns the list of booleans that indicates if the 
-     * key needs to unwrapped for the corresponding plan.
-     * 
-     * @return the list of isKeyWrapped boolean values
-     */
-    public List<Boolean> getIsKeyWrappedList() {
-        return Collections.unmodifiableList(isKeyWrapped);
-    }
-    
-    /**
-     * Adds a list of IsKeyWrapped boolean values
-     * 
-     * @param lst the list of boolean values to add
-     */
-    public void addIsKeyWrappedList(List<Boolean> lst) {
-        for (Boolean b : lst) {
-            isKeyWrapped.add(b);
-        }
-    }
-    
     /**
      * Appends the specified plan at the end of the list.
      * 
      * @param inPlan plan to be appended to the inner plan list
      */
-    public void addPlan(PhysicalPlan inPlan, byte mapKeyType, boolean[] keyPos) {  
-        myPlans.add(inPlan);
-        processedSet.set(myPlans.size()-1);
-        // if mapKeyType is already a tuple, we will NOT
-        // be wrapping it in an extra tuple. If it is not
-        // a tuple, we will wrap into in a tuple
-        isKeyWrapped.add(mapKeyType == DataType.TUPLE ? false : true);
-        keyPositions.add(keyPos);
-    }
     
-    public void addPlan(PhysicalPlan inPlan, boolean[] keyPos) {  
+    public void addPlan(PhysicalPlan inPlan) {  
         myPlans.add(inPlan);
         processedSet.set(myPlans.size()-1);
-        keyPositions.add(keyPos);
     }
    
     @Override
@@ -364,51 +305,12 @@ public class PODemux extends PhysicalOperator {
         
         PhysicalPlan pl = myPlans.get(index);
         if (!(pl.getRoots().get(0) instanceof PODemux)) {                             
-            if (!sameMapKeyType && !inCombiner && isKeyWrapped.get(index)) {                                       
-                
-                // unwrap the keys
-                boolean[] keys = keyPositions.get(index);
-                for (int pos = 0; pos < keys.length; pos++) {
-                    if (keys[pos]) {
-                        Tuple tup = (pos == 0) ? 
-                                (Tuple)fld.getValueAsPigType() : (Tuple)res.get(pos);
-                        res.set(pos, tup.get(0));
-                    } 
-                    else if (pos == 0) {                 
-                        res.set(0, fld.getValueAsPigType());
-                    }
-                }
-                
-            } else {
-                res.set(0, fld.getValueAsPigType());
-            }
+            res.set(0, fld.getValueAsPigType());
         }
     
         myPlans.get(index).attachInput(res);
         return myPlans.get(index).getLeaves().get(0);
     }
-    
-    /**
-     * Sets a flag indicating if all inner plans have 
-     * the same map key type. 
-     * 
-     * @param sameMapKeyType true if all inner plans have 
-     * the same map key type; otherwise false
-     */
-    public void setSameMapKeyType(boolean sameMapKeyType) {
-        this.sameMapKeyType = sameMapKeyType;
-    }
-
-    /**
-     * Returns a flag indicating if all inner plans 
-     * have the same map key type 
-     * 
-     * @return true if all inner plans have 
-     * the same map key type; otherwise false
-     */
-    public boolean isSameMapKeyType() {
-        return sameMapKeyType;
-    }
 
     /**
      * Sets a flag indicating if this operator is 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POMultiQueryPackage.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POMultiQueryPackage.java
index cbb4686e1..0770bab07 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POMultiQueryPackage.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POMultiQueryPackage.java
@@ -18,6 +18,7 @@
 package org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 
@@ -28,6 +29,7 @@ import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
+import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.io.NullableTuple;
 import org.apache.pig.impl.io.NullableUnknownWritable;
@@ -63,6 +65,34 @@ public class POMultiQueryPackage extends POPackage {
     
     private List<POPackage> packages = new ArrayList<POPackage>();
 
+    /**
+     * If the POLocalRearranges corresponding to the reduce plans in 
+     * myPlans (the list of inner plans of the demux) have different key types
+     * then the MultiQueryOptimizer converts all the keys to be of type tuple
+     * by wrapping any non-tuple keys into Tuples (keys which are already tuples
+     * are left alone).
+     * The list below is a list of booleans indicating whether extra tuple wrapping
+     * was done for the key in the corresponding POLocalRearranges and if we need
+     * to "unwrap" the tuple to get to the key
+     */
+    private ArrayList<Boolean> isKeyWrapped = new ArrayList<Boolean>();
+    
+    /*
+     * Indicating if all the inner plans have the same
+     * map key type. If not, the keys passed in are 
+     * wrapped inside tuples and need to be extracted
+     * out during the reduce phase 
+     */
+    private boolean sameMapKeyType = true;
+    
+    /*
+     * Indicating if this operator is in a combiner. 
+     * If not, this operator is in a reducer and the key
+     * values must first be extracted from the tuple-wrap
+     * before writing out to the disk
+     */
+    private boolean inCombiner = false;
+    
     transient private PigNullableWritable myKey;
 
     /**
@@ -109,7 +139,7 @@ public class POMultiQueryPackage extends POPackage {
 
     @Override
     public String name() {
-        return "MultiQuery Package  - " +  getOperatorKey().toString();
+        return "MultiQuery Package [" + isKeyWrapped + "] - " +  getOperatorKey().toString();
     }
 
     @Override
@@ -148,6 +178,21 @@ public class POMultiQueryPackage extends POPackage {
     public void addPackage(POPackage pack) {
         packages.add(pack);        
     }
+    
+    /**
+     * Appends the specified package object to the end of 
+     * the package list.
+     * 
+     * @param pack package to be appended to the list
+     * @param mapKeyType the map key type associated with the package
+     */
+    public void addPackage(POPackage pack, byte mapKeyType) {
+        packages.add(pack);        
+        // if mapKeyType is already a tuple, we will NOT
+        // be wrapping it in an extra tuple. If it is not
+        // a tuple, we will wrap into in a tuple
+        isKeyWrapped.add(mapKeyType == DataType.TUPLE ? false : true);
+    }
 
     /**
      * Returns the list of packages.
@@ -179,10 +224,20 @@ public class POMultiQueryPackage extends POPackage {
                 + " should be in the range between 0 and " + packages.size();
             throw new ExecException(msg, errCode, PigException.BUG);
         }
-               
+                  
         POPackage pack = packages.get(index);
-
-        pack.attachInput(myKey, tupIter);
+        
+        // check to see if we need to unwrap the key. The keys may be
+        // wrapped inside a tuple by LocalRearrange operator when jobs  
+        // with different map key types are merged
+        PigNullableWritable curKey = myKey;
+        if (!sameMapKeyType && !inCombiner && isKeyWrapped.get(index)) {                                       
+            Tuple tup = (Tuple)myKey.getValueAsPigType();
+            curKey = HDataType.getWritableComparableTypes(tup.get(0), pack.getKeyType());
+            curKey.setIndex(origIndex);
+        }
+            
+        pack.attachInput(curKey, tupIter);
 
         Result res = pack.getNext(t);
         
@@ -218,4 +273,41 @@ public class POMultiQueryPackage extends POPackage {
         return res;
     }
 
+    /**
+     * Returns the list of booleans that indicates if the 
+     * key needs to unwrapped for the corresponding plan.
+     * 
+     * @return the list of isKeyWrapped boolean values
+     */
+    public List<Boolean> getIsKeyWrappedList() {
+        return Collections.unmodifiableList(isKeyWrapped);
+    }
+    
+    /**
+     * Adds a list of IsKeyWrapped boolean values
+     * 
+     * @param lst the list of boolean values to add
+     */
+    public void addIsKeyWrappedList(List<Boolean> lst) {
+        for (Boolean b : lst) {
+            isKeyWrapped.add(b);
+        }
+    }
+    
+    public void setInCombiner(boolean inCombiner) {
+        this.inCombiner = inCombiner;
+    }
+
+    public boolean isInCombiner() {
+        return inCombiner;
+    }
+
+    public void setSameMapKeyType(boolean sameMapKeyType) {
+        this.sameMapKeyType = sameMapKeyType;
+    }
+
+    public boolean isSameMapKeyType() {
+        return sameMapKeyType;
+    }
+
 }
diff --git a/test/org/apache/pig/test/TestMultiQuery.java b/test/org/apache/pig/test/TestMultiQuery.java
index 067b19d0b..2d0836009 100644
--- a/test/org/apache/pig/test/TestMultiQuery.java
+++ b/test/org/apache/pig/test/TestMultiQuery.java
@@ -88,6 +88,67 @@ public class TestMultiQuery extends TestCase {
         myPig = null;
     }
     
+    public void testMultiQueryJiraPig1068() {
+
+        // test case: COGROUP fails with 'Type mismatch in key from map: 
+        // expected org.apache.pig.impl.io.NullableText, recieved org.apache.pig.impl.io.NullableTuple'
+
+        String INPUT_FILE = "pig-1068.txt";
+
+        try {
+
+            PrintWriter w = new PrintWriter(new FileWriter(INPUT_FILE));
+            w.println("10\tapple\tlogin\tjar");
+            w.println("20\torange\tlogin\tbox");
+            w.println("30\tstrawberry\tquit\tbot");
+
+            w.close();
+
+            Util.copyFromLocalToCluster(cluster, INPUT_FILE, INPUT_FILE);
+
+            myPig.setBatchOn();
+
+            myPig.registerQuery("logs = load '" + INPUT_FILE 
+                    + "' as (ts:int, id:chararray, command:chararray, comments:chararray);");
+            myPig.registerQuery("SPLIT logs INTO logins IF command == 'login', all_quits IF command == 'quit';");
+            myPig.registerQuery("login_info = FOREACH logins { GENERATE id as id, comments AS client; };");  
+            myPig.registerQuery("logins_grouped = GROUP login_info BY (id, client);");
+            myPig.registerQuery("count_logins_by_client = FOREACH logins_grouped "
+                    + "{ generate group.id AS id, group.client AS client, COUNT($1) AS count; };");
+            myPig.registerQuery("all_quits_grouped = GROUP all_quits BY id; ");
+            myPig.registerQuery("quits = FOREACH all_quits_grouped { GENERATE FLATTEN(all_quits); };");
+            myPig.registerQuery("joined_session_info = COGROUP quits BY id, count_logins_by_client BY id;");
+            
+            Iterator<Tuple> iter = myPig.openIterator("joined_session_info");
+
+            List<Tuple> expectedResults = Util.getTuplesFromConstantTupleStrings(
+                    new String[] { 
+                            "('apple',{},{('apple','jar',1L)})",
+                            "('orange',{},{('orange','box',1L)})",
+                            "('strawberry',{(30,'strawberry','quit','bot')},{})"
+                    });
+            
+            int counter = 0;
+            while (iter.hasNext()) {
+                assertEquals(expectedResults.get(counter++).toString(), iter.next().toString());                
+            }
+
+            assertEquals(expectedResults.size(), counter);
+
+        } catch (Exception e) {
+            e.printStackTrace();
+            Assert.fail();
+        } finally {
+            new File(INPUT_FILE).delete();
+            try {
+                Util.deleteFile(cluster, INPUT_FILE);
+            } catch (IOException e) {
+                e.printStackTrace();
+                Assert.fail();
+            }
+        }
+    }
+    
     @Test
     public void testMultiQueryJiraPig1108() {
         
