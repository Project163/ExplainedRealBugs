diff --git a/CHANGES.txt b/CHANGES.txt
index c9a5123cd..5cd76a696 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -28,6 +28,9 @@ PIG-700: To automate the pig patch test process (gkesavan via sms)
 
 BUG FIXES
 
+PIG-693: Parameter to UDF which is an alias returned in another UDF in nested
+foreach causes incorrect results (thejas via sms)
+
 PIG-725: javadoc: warning - Multiple sources of package comments found for
 package "org.apache.commons.logging" (gkesavan via sms)
 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index d4c9a34e5..0bfdb3e16 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -1137,7 +1137,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         }
         p.setResultType(func.getType());
         currentPlan.add(p);
-        List<LogicalOperator> fromList = func.getPlan().getPredecessors(func);
+        List<org.apache.pig.impl.logicalLayer.ExpressionOperator> fromList = func.getArguments();
         if(fromList!=null){
             for (LogicalOperator op : fromList) {
                 PhysicalOperator from = LogToPhyMap.get(op);
@@ -1283,10 +1283,6 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
         String scope = op.getOperatorKey().scope;
         UnaryComparisonOperator physOp = new POIsNull(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), op.getRequestedParallelism(), null);
-        physOp.setOperandType(op.getOperand().getType());
-        currentPlan.add(physOp);
-
-        LogToPhyMap.put(op, physOp);
 
         List<LogicalOperator> inputs = op.getPlan().getPredecessors(op); 
         ExpressionOperator from;
@@ -1299,6 +1295,13 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             throw new LogicalToPhysicalTranslatorException(msg, errCode, PigException.BUG);            
         }
 
+        
+        physOp.setOperandType(op.getOperand().getType());
+        currentPlan.add(physOp);
+
+        LogToPhyMap.put(op, physOp);
+
+        
         ((POIsNull) physOp).setExpr(from);
         try {
             currentPlan.connect(from, physOp);
diff --git a/src/org/apache/pig/impl/logicalLayer/BinaryExpressionOperator.java b/src/org/apache/pig/impl/logicalLayer/BinaryExpressionOperator.java
index 89ec0fe4f..2f9b65ce8 100644
--- a/src/org/apache/pig/impl/logicalLayer/BinaryExpressionOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/BinaryExpressionOperator.java
@@ -18,6 +18,8 @@
 
 package org.apache.pig.impl.logicalLayer;
 
+import java.util.List;
+
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
@@ -33,8 +35,6 @@ import org.apache.commons.logging.LogFactory;
 
 public abstract class BinaryExpressionOperator extends ExpressionOperator {
     private static final long serialVersionUID = 2L;
-    private ExpressionOperator mLhsOperand; //left hand side operand
-    private ExpressionOperator mRhsOperand; //right hand side operand
     private static Log log = LogFactory.getLog(BinaryExpressionOperator.class);
 
     /**
@@ -45,16 +45,9 @@ public abstract class BinaryExpressionOperator extends ExpressionOperator {
      * @param rp
      *            degree of requested parallelism with which to execute this
      *            node.
-     * @param lhsOperand
-     *            ExpressionOperator the left hand side operand
-     * @param rhsOperand
-     *            ExpressionOperator the right hand side operand
      */
-    public BinaryExpressionOperator(LogicalPlan plan, OperatorKey k, int rp,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
+    public BinaryExpressionOperator(LogicalPlan plan, OperatorKey k, int rp) {
         super(plan, k, rp);
-        mLhsOperand = lhsOperand;
-        mRhsOperand = rhsOperand;
     }
 
     /**
@@ -62,34 +55,25 @@ public abstract class BinaryExpressionOperator extends ExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            ExpressionOperator the left hand side operand
-     * @param rhsOperand
-     *            ExpressionOperator the right hand side operand
      */
-    public BinaryExpressionOperator(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
+    public BinaryExpressionOperator(LogicalPlan plan, OperatorKey k) {
         super(plan, k);
-        mLhsOperand = lhsOperand;
-        mRhsOperand = rhsOperand;
     }
     
     public ExpressionOperator getLhsOperand() {
-        return mLhsOperand;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(0);
     }
 
     public ExpressionOperator getRhsOperand() {
-        return mRhsOperand;
-    }
-    
-    public void setLhsOperand(ExpressionOperator lhs) {
-        mLhsOperand = lhs ;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(1);
     }
-
-    public void setRhsOperand(ExpressionOperator rhs) {
-        mRhsOperand = rhs ;
-    }
-    
+        
     @Override
     public void visit(LOVisitor v) throws VisitorException {
         v.visit(this);
diff --git a/src/org/apache/pig/impl/logicalLayer/LOAdd.java b/src/org/apache/pig/impl/logicalLayer/LOAdd.java
index bcbccda2a..ae3e3c593 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOAdd.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOAdd.java
@@ -37,14 +37,9 @@ public class LOAdd extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOAdd(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOAdd(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOAnd.java b/src/org/apache/pig/impl/logicalLayer/LOAnd.java
index 20b41f27c..7a53cc535 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOAnd.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOAnd.java
@@ -37,14 +37,9 @@ public class LOAnd extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOAnd(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOAnd(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOBinCond.java b/src/org/apache/pig/impl/logicalLayer/LOBinCond.java
index 2ce49dd69..d7ca93a43 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOBinCond.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOBinCond.java
@@ -19,6 +19,8 @@
 package org.apache.pig.impl.logicalLayer;
 
 
+import java.util.List;
+
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
@@ -31,58 +33,40 @@ public class LOBinCond extends ExpressionOperator {
     // is executed else the second nested query is executed
 
     private static final long serialVersionUID = 2L;
-    private ExpressionOperator mCond;
-    private ExpressionOperator mLhsOp;
-    private ExpressionOperator mRhsOp;
-
+ 
     /**
      * 
      * @param plan
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param cond
-     *            ExpressionOperator the expression specifying condition
-     * @param lhsOp
-     *            ExpressionOperator query to be executed when condition is true
-     * @param rhsOp
-     *            ExpressionOperator query to be executed when condition is
-     *            false
      */
-    public LOBinCond(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator cond, ExpressionOperator lhsOp,
-            ExpressionOperator rhsOp) {
+    public LOBinCond(LogicalPlan plan, OperatorKey k) {
         super(plan, k);
-        mCond = cond;
-        mLhsOp = lhsOp;
-        mRhsOp = rhsOp;
-
     }// End Constructor LOBinCond
 
     public ExpressionOperator getCond() {
-        return mCond;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(0);
     }
 
     public ExpressionOperator getLhsOp() {
-        return mLhsOp;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(1);
     }
 
     public ExpressionOperator getRhsOp() {
-        return mRhsOp;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(2);
     }
     
-    public void setCond(ExpressionOperator cond) {
-        mCond = cond;
-    }
-
-    public void setLhsOp(ExpressionOperator op) {
-        mLhsOp = op ;
-    }
-
-    public void setRhsOp(ExpressionOperator op) {
-        mRhsOp = op;
-    }
-
+    
     @Override
     public void visit(LOVisitor v) throws VisitorException {
         v.visit(this);
@@ -99,7 +83,7 @@ public class LOBinCond extends ExpressionOperator {
         //The type checker perform this task
         if (!mIsFieldSchemaComputed) {
             try {
-                mFieldSchema = mLhsOp.getFieldSchema();
+                mFieldSchema = getLhsOp().getFieldSchema();
                 mIsFieldSchemaComputed = true;
             } catch (FrontendException fee) {
                 mFieldSchema = null;
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCast.java b/src/org/apache/pig/impl/logicalLayer/LOCast.java
index 8af5cfc39..12c95d215 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCast.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCast.java
@@ -18,6 +18,8 @@
 
 package org.apache.pig.impl.logicalLayer;
 
+import java.util.List;
+
 import org.apache.pig.FuncSpec;
 import org.apache.pig.LoadFunc;
 import org.apache.pig.impl.plan.OperatorKey;
@@ -31,7 +33,6 @@ public class LOCast extends ExpressionOperator {
     // Cast has an expression that has to be converted to a specified type
 
     private static final long serialVersionUID = 2L;
-    private ExpressionOperator mExpr;
     private FuncSpec mLoadFuncSpec = null;
 
     /**
@@ -40,24 +41,19 @@ public class LOCast extends ExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param expr
-     *            the expression whose type has to be cast
      * @param type
      *            the type to which the expression is cast
      */
-    public LOCast(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator expr, byte type) {
+    public LOCast(LogicalPlan plan, OperatorKey k, byte type) {
         super(plan, k);
-        mExpr = expr;
         mType = type;
     }// End Constructor LOCast
 
     public ExpressionOperator getExpression() {
-        return mExpr;
-    }
-
-    public void setExpression(ExpressionOperator expr) {
-        mExpr = expr;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(0);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOConst.java b/src/org/apache/pig/impl/logicalLayer/LOConst.java
index 568f90e4e..9f75f8296 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOConst.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOConst.java
@@ -79,7 +79,7 @@ public class LOConst extends ExpressionOperator {
 
     @Override
     public String name() {
-        return "Const " + mKey.scope + "-" + mKey.id;
+        return "Const " + mKey.scope + "-" + mKey.id + "( " + mValue + " )";
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LODivide.java b/src/org/apache/pig/impl/logicalLayer/LODivide.java
index 3f6037a9a..42e208cdc 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODivide.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODivide.java
@@ -37,14 +37,9 @@ public class LODivide extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LODivide(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LODivide(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOEqual.java b/src/org/apache/pig/impl/logicalLayer/LOEqual.java
index 2c58c5c11..1570a28b3 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOEqual.java
@@ -37,14 +37,9 @@ public class LOEqual extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOEqual(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOEqual(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java b/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
index f41c4deb9..b0982310e 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGreaterThan.java
@@ -37,14 +37,9 @@ public class LOGreaterThan extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOGreaterThan(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOGreaterThan(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java b/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
index f5cd598f2..67c483a14 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOGreaterThanEqual.java
@@ -37,14 +37,9 @@ public class LOGreaterThanEqual extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOGreaterThanEqual(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOGreaterThanEqual(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOIsNull.java b/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
index 00a48d2ed..55638dbfc 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOIsNull.java
@@ -37,12 +37,9 @@ public class LOIsNull extends UnaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param operand
-     *            the only operand for a unary operator
      */
-    public LOIsNull(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator operand) {
-        super(plan, k, operand);
+    public LOIsNull(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
     
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java b/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
index 8ee13c799..e7d1ee8fa 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLesserThan.java
@@ -37,14 +37,9 @@ public class LOLesserThan extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOLesserThan(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOLesserThan(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java b/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
index 868aabdce..83dc255a7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLesserThanEqual.java
@@ -37,14 +37,9 @@ public class LOLesserThanEqual extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOLesserThanEqual(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOLesserThanEqual(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java b/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
index 6af6ff86e..a51b32269 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMapLookup.java
@@ -36,7 +36,6 @@ public class LOMapLookup extends ExpressionOperator {
      * The key to lookup along with the type and schema corresponding to the
      * type and schema of the value linked to the key
      */
-    private ExpressionOperator mMap;
     private Object mMapKey;
     private byte mValueType;
     private Schema mValueSchema;
@@ -48,8 +47,6 @@ public class LOMapLookup extends ExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param key
      *            Operator key to assign to this node.
-     * @param map
-     *            the map expression
      * @param mapKey
      *            key to look up in the map. The key is of atomic type
      * @param valueType
@@ -57,7 +54,7 @@ public class LOMapLookup extends ExpressionOperator {
      * @param valueSchema
      *            schema of the value if the type is tuple
      */
-    public LOMapLookup(LogicalPlan plan, OperatorKey key, ExpressionOperator map,
+    public LOMapLookup(LogicalPlan plan, OperatorKey key,
             Object mapKey, byte valueType, Schema valueSchema)
             throws ParseException {
         super(plan, key);
@@ -66,7 +63,6 @@ public class LOMapLookup extends ExpressionOperator {
             throw new ParseException("Map key " + mapKey.toString()
                     + " is not atomic");
         }
-        mMap = map;
         mMapKey = mapKey;
         mValueType = valueType;
         mValueSchema = valueSchema;
@@ -74,11 +70,10 @@ public class LOMapLookup extends ExpressionOperator {
     }
 
     public ExpressionOperator getMap() {
-        return mMap;
-    }
-
-    public void setMap(ExpressionOperator map) {
-        mMap = map;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(0);
     }
 
     public Object getLookUpKey() {
@@ -112,7 +107,8 @@ public class LOMapLookup extends ExpressionOperator {
             } else {
                 mFieldSchema = new Schema.FieldSchema(null, mValueType);
             }
-            mFieldSchema.setParent(mMap.getFieldSchema().canonicalName, mMap);
+            ExpressionOperator map = getMap();
+            mFieldSchema.setParent(map.getFieldSchema().canonicalName, map);
 
             mIsFieldSchemaComputed = true;
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMod.java b/src/org/apache/pig/impl/logicalLayer/LOMod.java
index 3035c84b8..ba6f17704 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMod.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMod.java
@@ -37,14 +37,9 @@ public class LOMod extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOMod(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOMod(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOMultiply.java b/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
index d5a102072..47729d077 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOMultiply.java
@@ -37,14 +37,9 @@ public class LOMultiply extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOMultiply(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOMultiply(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LONegative.java b/src/org/apache/pig/impl/logicalLayer/LONegative.java
index 6a08d20c1..270445374 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONegative.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONegative.java
@@ -33,12 +33,9 @@ public class LONegative extends UnaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param operand
-     *            the only operand for a unary operator
      */
-    public LONegative(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator operand) {
-        super(plan, k, operand);
+    public LONegative(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LONot.java b/src/org/apache/pig/impl/logicalLayer/LONot.java
index 50de7af4c..fa75572d2 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONot.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONot.java
@@ -37,12 +37,9 @@ public class LONot extends UnaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param operand
-     *            the only operand for a unary operator
      */
-    public LONot(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator operand) {
-        super(plan, k, operand);
+    public LONot(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
     
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LONotEqual.java b/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
index 40075a9e4..5b8d9969d 100644
--- a/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
+++ b/src/org/apache/pig/impl/logicalLayer/LONotEqual.java
@@ -37,14 +37,9 @@ public class LONotEqual extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LONotEqual(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LONotEqual(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOOr.java b/src/org/apache/pig/impl/logicalLayer/LOOr.java
index 5d31e441d..bc0bc8773 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOOr.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOOr.java
@@ -37,14 +37,9 @@ public class LOOr extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOOr(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOOr(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
     
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LORegexp.java b/src/org/apache/pig/impl/logicalLayer/LORegexp.java
index d8c3cfa83..75efd4714 100644
--- a/src/org/apache/pig/impl/logicalLayer/LORegexp.java
+++ b/src/org/apache/pig/impl/logicalLayer/LORegexp.java
@@ -43,24 +43,15 @@ public class LORegexp extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param key
      *            Operator key to assign to this node.
-     * @param operand
-     *            input expression to be tested against
-     * @param regexp
-     *            regular expression to match
      */
-    public LORegexp(LogicalPlan plan, OperatorKey key,
-            ExpressionOperator operand, ExpressionOperator regexp) {
-        super(plan, key, operand, regexp);
+    public LORegexp(LogicalPlan plan, OperatorKey key) {
+        super(plan, key);
     }
 
     public ExpressionOperator getOperand() {
         return getLhsOperand();
     }
 
-    public void setOperand(ExpressionOperator op) {
-        setLhsOperand(op) ;
-    }
-
     public String getRegexp() {
         ExpressionOperator op = getRhsOperand();
         if (!(op instanceof LOConst)) {
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSubtract.java b/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
index 3125adde3..d3562c164 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSubtract.java
@@ -37,14 +37,9 @@ public class LOSubtract extends BinaryExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param lhsOperand
-     *            the left hand side operand
-     * @param rhsOperand
-     *            the right hand side operand
      */
-    public LOSubtract(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator lhsOperand, ExpressionOperator rhsOperand) {
-        super(plan, k, lhsOperand, rhsOperand);
+    public LOSubtract(LogicalPlan plan, OperatorKey k) {
+        super(plan, k);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
index 9efe190a4..257c5f7d4 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
@@ -35,8 +35,7 @@ public class LOUserFunc extends ExpressionOperator {
     private static final long serialVersionUID = 2L;
 
     private FuncSpec mFuncSpec;
-    private List<ExpressionOperator> mArgs;
-
+    
     /**
      * @param plan
      *            LogicalPlan this operator is a part of.
@@ -44,16 +43,13 @@ public class LOUserFunc extends ExpressionOperator {
      *            OperatorKey for this operator.
      * @param funcSpec
      *            name of the user defined function.
-     * @param args
-     *            List of expressions that form the arguments for this function.
      * @param returnType
      *            return type of this function.
      */
     public LOUserFunc(LogicalPlan plan, OperatorKey k, FuncSpec funcSpec,
-            List<ExpressionOperator> args, byte returnType) {
+            byte returnType) {
         super(plan, k, -1);
         mFuncSpec = funcSpec;
-        mArgs = args;
         mType = returnType;
     }
 
@@ -62,11 +58,15 @@ public class LOUserFunc extends ExpressionOperator {
     }
 
     public List<ExpressionOperator> getArguments() {
-        return mArgs;
-    }
-
-    public void setArguments(List<ExpressionOperator> args) {
-        mArgs = args;
+        List<LogicalOperator> preds = getPlan().getPredecessors(this);
+        List<ExpressionOperator> args = new ArrayList<ExpressionOperator>();
+        if(preds == null)
+                return args;
+            
+        for(LogicalOperator lo : preds){
+            args.add((ExpressionOperator)lo);
+        }
+        return args;
     }
 
     @Override
@@ -88,7 +88,8 @@ public class LOUserFunc extends ExpressionOperator {
     public Schema.FieldSchema getFieldSchema() throws FrontendException {
         if(!mIsFieldSchemaComputed) {
             Schema inputSchema = new Schema();
-            for(ExpressionOperator op: mArgs) {
+            List<ExpressionOperator> args = getArguments();
+            for(ExpressionOperator op: args) {
                 if (!DataType.isUsableType(op.getType())) {
                     mFieldSchema = null;
                     mIsFieldSchemaComputed = false;
@@ -141,10 +142,6 @@ public class LOUserFunc extends ExpressionOperator {
         mFuncSpec = funcSpec;
     }
 
-    public void setMArgs(List<ExpressionOperator> args) {
-        mArgs = args;
-    }
-
     /**
      * @see org.apache.pig.impl.logicalLayer.ExpressionOperator#clone()
      * Do not use the clone method directly. Operators are cloned when logical plans
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalPlanCloneHelper.java b/src/org/apache/pig/impl/logicalLayer/LogicalPlanCloneHelper.java
index 75e840df9..5af250237 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalPlanCloneHelper.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalPlanCloneHelper.java
@@ -92,14 +92,6 @@ public class LogicalPlanCloneHelper extends LOVisitor {
     
     @Override
     public void visit(BinaryExpressionOperator binOp) {
-        ExpressionOperator lhsOperandClone = (ExpressionOperator)mOpToCloneMap.get(binOp.getLhsOperand());
-        if(lhsOperandClone != null) {
-            binOp.setLhsOperand(lhsOperandClone);
-        }
-        ExpressionOperator rhsOperandClone = (ExpressionOperator)mOpToCloneMap.get(binOp.getRhsOperand());
-        if(rhsOperandClone != null) {
-            binOp.setRhsOperand(rhsOperandClone);
-        }
     }
 
     /**
@@ -123,20 +115,6 @@ public class LogicalPlanCloneHelper extends LOVisitor {
      */
     @Override
     protected void visit(LOBinCond binCond) throws VisitorException {
-        ExpressionOperator condClone = (ExpressionOperator)mOpToCloneMap.get(binCond.getCond());
-        if(condClone != null) {
-            binCond.setCond(condClone);
-        }
-
-        ExpressionOperator lhsOpClone = (ExpressionOperator)mOpToCloneMap.get(binCond.getLhsOp());
-        if(lhsOpClone != null) {
-            binCond.setLhsOp(lhsOpClone);
-        }
-
-        ExpressionOperator rhsOpClone = (ExpressionOperator)mOpToCloneMap.get(binCond.getRhsOp());
-        if(rhsOpClone != null) {
-            binCond.setRhsOp(rhsOpClone);
-        }
     }
 
     /**
@@ -144,10 +122,6 @@ public class LogicalPlanCloneHelper extends LOVisitor {
      */
     @Override
     protected void visit(LOCast cast) throws VisitorException {
-        ExpressionOperator exprClone = (ExpressionOperator)mOpToCloneMap.get(cast.getExpression());
-        if(exprClone != null) {
-            cast.setExpression(exprClone);
-        }
     }
 
     /**
@@ -302,10 +276,6 @@ public class LogicalPlanCloneHelper extends LOVisitor {
      */
     @Override
     public void visit(LOMapLookup op) throws VisitorException {
-        ExpressionOperator mapClone = (ExpressionOperator)mOpToCloneMap.get(op.getMap());
-        if(mapClone != null) {
-            op.setMap(mapClone);
-        }
     }
 
     /**
@@ -448,17 +418,6 @@ public class LogicalPlanCloneHelper extends LOVisitor {
      */
     @Override
     protected void visit(LOUserFunc func) throws VisitorException {
-        List<ExpressionOperator> args = func.getArguments();
-        List<ExpressionOperator> argsClone = new ArrayList<ExpressionOperator>(args.size());
-        for(ExpressionOperator arg: args) {
-            ExpressionOperator argClone = (ExpressionOperator)mOpToCloneMap.get(arg);
-            if(argClone != null) {
-                argsClone.add(argClone);
-            } else {
-                argsClone.add(arg);
-            }
-        }
-        func.setArguments(argsClone);
     }
 
     /**
@@ -466,10 +425,6 @@ public class LogicalPlanCloneHelper extends LOVisitor {
      */
     @Override
     protected void visit(UnaryExpressionOperator uniOp) throws VisitorException {
-        ExpressionOperator operandClone = (ExpressionOperator)mOpToCloneMap.get(uniOp.getOperand());
-        if(operandClone != null) {
-            uniOp.setOperand(operandClone);
-        }
     }
     
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java b/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java
index f5546a634..a2ecfb0b4 100644
--- a/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java
+++ b/src/org/apache/pig/impl/logicalLayer/RemoveRedundantOperators.java
@@ -17,12 +17,14 @@
  */
 package org.apache.pig.impl.logicalLayer;
 
+import java.util.Collection;
 import java.util.List;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.Map;
 import java.util.ArrayList;
 
+import org.apache.commons.el.RelationalOperator;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.PlanWalker;
 import org.apache.pig.impl.plan.DepthFirstWalker;
@@ -54,102 +56,74 @@ public class RemoveRedundantOperators extends
     protected void visit(LOProject project) throws VisitorException {
         LogicalPlan currentPlan = (LogicalPlan)mCurrentWalker.getPlan();
         
-        //if the project is a project(*) and if there are predecessors and successors that are
+        //if the project is a project(*) and if there are predecessors 
+        // and successors that are
         //1. both relational operators OR
         //2. both expression operators
-        //then the project(*) can be removed and the input and outputs short circuited, i.e. directly connected
+        //then the project(*) can be removed and the input and outputs
+        // short circuited, i.e. directly connected
         if(project.isStar()) {
 
-            List<LogicalOperator> projectSuccessors = currentPlan.getSuccessors(project);
-            List<LogicalOperator> projectPredecessors = currentPlan.getPredecessors(project);
-
-            if(((projectSuccessors != null) && (projectSuccessors.size() > 0)) 
-                && ((projectPredecessors != null) && (projectPredecessors.size() > 0))) {
-
-                //Making copies to avoid concurrent modification exceptions
-                List<LogicalOperator> successors = new ArrayList(currentPlan.getSuccessors(project));
-                List<LogicalOperator> predecessors = new ArrayList(currentPlan.getPredecessors(project));
-
-                //if the project(*) cannot be removed
-                boolean removeProject = true;
-
-                for(LogicalOperator projectPred: predecessors) {
-                    for(LogicalOperator projectSucc: successors) {
-                        if (((projectPred instanceof ExpressionOperator) && (projectSucc instanceof ExpressionOperator))
-                            || (!(projectPred instanceof ExpressionOperator) && !(projectSucc instanceof ExpressionOperator))) {
-                            try {
-                                currentPlan.disconnect(projectPred, project);
-                                currentPlan.disconnect(project, projectSucc);
-                                currentPlan.connect(projectPred, projectSucc);
-                                patchInputReference(projectSucc, project, projectPred);
-                            } catch (PlanException pe) {
-                                throw new VisitorException(pe.getMessage(), pe);
-                            }
-                        } else {
-                            removeProject = false;
-                        }
-                    }
+            List<LogicalOperator> prSuccessors = 
+                    currentPlan.getSuccessors(project);
+            
+            List<LogicalOperator> prPredecessors = 
+                    currentPlan.getPredecessors(project);
+            
+            if( ((prSuccessors != null) && (prSuccessors.size() > 0)) 
+                    /* prPredecessors.size() == 1 for project(*) */
+                    && ((prPredecessors != null) && (prPredecessors.size() == 1)) ){
+                
+                LogicalOperator pred =  prPredecessors.get(0);
+                
+                
+                //check if either all pred and succ oper are ExpressionOperator
+                // or if all of them are relationalOperators (ie != ExpressionOperator)
+                boolean allExpressionOp = true;
+                boolean allRelationalOp = true;
+                if(pred instanceof ExpressionOperator)
+                    allRelationalOp = false;
+                else 
+                    allExpressionOp = false;
+                
+                for(LogicalOperator op: prSuccessors){
+                    if (op instanceof ExpressionOperator) 
+                        allRelationalOp = false;
+                    else 
+                        allExpressionOp = false;
+                    
+                    if(allExpressionOp == false && allRelationalOp == false)
+                        break;
                 }
-                if(removeProject) {
-                    currentPlan.remove(project);
+                
+                // remove project if either condition is met
+                if(allExpressionOp == true || allRelationalOp == true){
+                    try{
+                        currentPlan.removeAndReconnectMultiSucc(project);
+                        patchInputReference(pred, project, prSuccessors);
+                    }catch (PlanException pe){
+                        String msg = new String("Error while removing redundant project in plan");
+                        throw new VisitorException(msg,pe);
+                    }
                 }
+                
             }
-        }
+        }       
     }
-
-    private void patchInputReference(LogicalOperator op, LogicalOperator prevInput, LogicalOperator newInput) {
-        //TODO
-        //Using reference comparison here as operators do not have equals() method yet
-        //Depending on the successor of prevInput, fix the referenes to point to newInput
-        if(op instanceof BinaryExpressionOperator) {
-            BinaryExpressionOperator binOp = (BinaryExpressionOperator)op;
-            if(prevInput == binOp.getLhsOperand()) {
-                binOp.setLhsOperand((ExpressionOperator)newInput);
-            } else if(prevInput == binOp.getRhsOperand()) {
-                binOp.setRhsOperand((ExpressionOperator)newInput);
-            }
-        } else if (op instanceof UnaryExpressionOperator) {
-            UnaryExpressionOperator uniOp = (UnaryExpressionOperator)op;
-            if(prevInput == uniOp.getOperand()) {
-                uniOp.setOperand((ExpressionOperator)newInput);
-            }
-        } else if (op instanceof LOBinCond) {
-            LOBinCond binCond = (LOBinCond)op;
-            if(prevInput == binCond.getLhsOp()) {
-                binCond.setLhsOp((ExpressionOperator)newInput);
-            } else if(prevInput == binCond.getRhsOp()) {
-                binCond.setRhsOp((ExpressionOperator)newInput);
-            } else if(prevInput == binCond.getCond()) {
-                binCond.setCond((ExpressionOperator)newInput);
-            }
-        } else if (op instanceof LOCast) {
-            LOCast cast = (LOCast)op;
-            if(prevInput == cast.getExpression()) {
-                cast.setExpression((ExpressionOperator)newInput);
-            }
-        } else if (op instanceof LOMapLookup) {
-            LOMapLookup map = (LOMapLookup)op;
-            if(prevInput == map.getMap()) {
-                map.setMap((ExpressionOperator)newInput);
-            }
-        } else if (op instanceof LOUserFunc) {
-            LOUserFunc userFunc = (LOUserFunc)op;
-            List<ExpressionOperator> args = userFunc.getArguments();
-            ArrayList<ExpressionOperator> newArgs = new ArrayList<ExpressionOperator>(args.size());
-            for(ExpressionOperator expOp: args) {
-                if(prevInput == expOp) {
-                    newArgs.add((ExpressionOperator)newInput);
-                } else {
-                    newArgs.add(expOp);
+    
+    
+    private void patchInputReference(LogicalOperator pred, LogicalOperator current, List<LogicalOperator> succs) {
+        for(LogicalOperator n : succs){
+            // special handling of LOProject because its getExpression() does
+            // need not be same as getPredecessors(LOProject)
+            if(n instanceof LOProject){
+                LOProject lop = (LOProject)n;
+                if(current == lop.getExpression()){
+                    lop.setExpression((LogicalOperator)pred);
                 }
             }
-            userFunc.setArguments(newArgs);
-        } else if (op instanceof LOProject) {
-            LOProject proj = (LOProject)op;
-            if(prevInput == proj.getExpression()) {
-                proj.setExpression(newInput);
-            }
         }
     }
-
+    
+    
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/UnaryExpressionOperator.java b/src/org/apache/pig/impl/logicalLayer/UnaryExpressionOperator.java
index de502a331..adefafe46 100644
--- a/src/org/apache/pig/impl/logicalLayer/UnaryExpressionOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/UnaryExpressionOperator.java
@@ -18,6 +18,8 @@
 
 package org.apache.pig.impl.logicalLayer;
 
+import java.util.List;
+
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.impl.plan.VisitorException;
@@ -32,7 +34,6 @@ import org.apache.commons.logging.LogFactory;
  */
 public abstract class UnaryExpressionOperator extends ExpressionOperator {
     private static final long serialVersionUID = 2L;
-    protected ExpressionOperator mOperand; // operand
     private static Log log = LogFactory.getLog(UnaryExpressionOperator.class);
 
     /**
@@ -43,13 +44,9 @@ public abstract class UnaryExpressionOperator extends ExpressionOperator {
      * @param rp
      *            degree of requested parallelism with which to execute this
      *            node.
-     * @param operand
-     *            ExpressionOperator the left hand side operand
      */
-    public UnaryExpressionOperator(LogicalPlan plan, OperatorKey k, int rp,
-            ExpressionOperator operand) {
+    public UnaryExpressionOperator(LogicalPlan plan, OperatorKey k, int rp) {
         super(plan, k, rp);
-        mOperand = operand;
     }
 
     /**
@@ -57,21 +54,17 @@ public abstract class UnaryExpressionOperator extends ExpressionOperator {
      *            Logical plan this operator is a part of.
      * @param k
      *            Operator key to assign to this node.
-     * @param operand
-     *            ExpressionOperator the left hand side operand
      */
-    public UnaryExpressionOperator(LogicalPlan plan, OperatorKey k,
-            ExpressionOperator operand) {
+    public UnaryExpressionOperator(LogicalPlan plan, OperatorKey k) {
         super(plan, k);
-        mOperand = operand;
+
     }
     
     public ExpressionOperator getOperand() {
-        return mOperand;
-    }
-
-    public void setOperand(ExpressionOperator eOp) {
-        mOperand = eOp;
+        List<LogicalOperator>preds = getPlan().getPredecessors(this);
+        if(preds == null)
+            return null;
+        return (ExpressionOperator)preds.get(0);
     }
 
     @Override
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
index 9da5daf4d..3988cc090 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/TypeCastInserter.java
@@ -165,8 +165,8 @@ public class TypeCastInserter extends LogicalTransformer {
                             // Either no schema was determined by loader OR the type 
                             // from the "determinedSchema" is different
                             // from the type specified - so we need to cast
-                            LOCast cast = new LOCast(p, OperatorKey.genOpKey(scope),
-                                proj, fs.type);
+                            LOCast cast = new LOCast(p, 
+                                        OperatorKey.genOpKey(scope), fs.type);
                             p.add(cast);
                             p.connect(proj, cast);
                             
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index a32973758..41153469f 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -1205,7 +1205,7 @@ ExpressionOperator POrCond(Schema over, Map<String, LogicalOperator> specs, Logi
 	(
 		<OR> rhsCond = PAndCond(over,specs,lp,input)
 		{
-			ExpressionOperator exprOp = new LOOr(lp, new OperatorKey(scope, getNextId()), lhsCond, rhsCond);
+			ExpressionOperator exprOp = new LOOr(lp, new OperatorKey(scope, getNextId()) );
 			lp.add(exprOp);
 			log.debug("POrCond: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
 			lp.connect(lhsCond, exprOp);
@@ -1234,7 +1234,7 @@ ExpressionOperator PAndCond(Schema over, Map<String, LogicalOperator> specs, Log
 	(
 		<AND> rhsCond = PUnaryCond(over,specs,lp,input)
 		{
-			ExpressionOperator exprOp = new LOAnd(lp, new OperatorKey(scope, getNextId()), lhsCond, rhsCond);
+			ExpressionOperator exprOp = new LOAnd(lp, new OperatorKey(scope, getNextId()) );
 			lp.add(exprOp);
 			log.debug("PAndCond: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
 			lp.connect(lhsCond, exprOp);
@@ -1280,28 +1280,28 @@ ExpressionOperator PUnaryCond(Schema over, Map<String, LogicalOperator> specs, L
             // numeric ops first
         case '=':
             if (op2 == '=') {
-                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()) );
             } else {
                 throw new ParseException("Internal error: Invalid filter operator: " + op);
             }
             break;
         case '<':
             if (op2 == '=') {
-                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
-                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()));
             }
             break;
         case '>':
             if (op2 == '=') {
-                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
-                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()));
             }
             break;
         case '!':
             if (op2 == '=') {
-                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
                 throw new ParseException("Internal error: Invalid filter operator: " + op);
             }
@@ -1309,28 +1309,28 @@ ExpressionOperator PUnaryCond(Schema over, Map<String, LogicalOperator> specs, L
             // now string ops
         case 'e':
             if (op2 == 'q') {
-                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
                 throw new ParseException("Internal error: Invalid filter operator: " + op);
             }
             break;
         case 'l':
             if (op2 == 't' && op3 == 'e') {
-                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
-                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()));
             }
             break;
         case 'g':
             if (op2 == 't' && op3 == 'e') {
-                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
-                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()));
             }
             break;
         case 'n':
             if (op2 == 'e' && op3 == 'q') {
-                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()));
             } else {
                 throw new ParseException("Internal error: Invalid filter operator: " + op);
             }
@@ -1352,7 +1352,7 @@ ExpressionOperator PUnaryCond(Schema over, Map<String, LogicalOperator> specs, L
 			{
                 LOConst rconst = new LOConst(lp, new OperatorKey(scope, getNextId()), unquote(t1.image));
                 rconst.setType(DataType.CHARARRAY);
-				cond = new LORegexp(lp, new OperatorKey(scope, getNextId()), lhs, rconst); 
+				cond = new LORegexp(lp, new OperatorKey(scope, getNextId())); 
 				lp.add(rconst); 
 				lp.add(cond); 
 				log.debug("PUnaryCond: Added operator " + cond.getClass().getName() + " " + cond + " to logical plan " + lp);
@@ -1377,7 +1377,7 @@ ExpressionOperator PNotCond(Schema over, Map<String, LogicalOperator> specs,Logi
 {
 	<NOT> c1=PUnaryCond(over,specs,lp,input)
 	{
-		ExpressionOperator eOp = new LONot(lp, new OperatorKey(scope, getNextId()), c1);
+		ExpressionOperator eOp = new LONot(lp, new OperatorKey(scope, getNextId()));
 		lp.add(eOp);
 		log.debug("PNotCond: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
 		lp.connect(c1, eOp);
@@ -1396,14 +1396,14 @@ ExpressionOperator PNullCond(Schema over, Map<String, LogicalOperator> specs,Log
 {
 	c1=InfixExpr(over,specs,lp,input) <IS> [<NOT> {not = true;}] <NULL>
 	{
-		ExpressionOperator eOp = new LOIsNull(lp, new OperatorKey(scope, getNextId()), c1);
+		ExpressionOperator eOp = new LOIsNull(lp, new OperatorKey(scope, getNextId()));
 		lp.add(eOp);
 		log.debug("PNullCond: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
 		lp.connect(c1, eOp);
 		log.debug("PNullCond: Connected operator " + eOp.getClass().getName() + " " + eOp + " to " + c1 + " logical plan " + lp);
         ExpressionOperator notNull = null;
         if (not) {
-            notNull = new LONot(lp, new OperatorKey(scope, getNextId()), eOp); 
+            notNull = new LONot(lp, new OperatorKey(scope, getNextId())); 
             lp.add(notNull);
 		    log.debug("PNullCond: Added operator " + notNull.getClass().getName() + " " + notNull + " to logical plan " + lp);
             lp.connect(eOp, notNull);
@@ -1475,7 +1475,7 @@ CogroupInput GroupItem(LogicalPlan lp) :
 					listPlans.add(groupByPlan);
 			}
 		|	<ANY> {
-					es = new LOUserFunc(groupByPlan = new LogicalPlan(), new OperatorKey(scope, getNextId()), new FuncSpec(GFAny.class.getName()), null, DataType.INTEGER); 
+					es = new LOUserFunc(groupByPlan = new LogicalPlan(), new OperatorKey(scope, getNextId()), new FuncSpec(GFAny.class.getName()), DataType.INTEGER); 
 					groupByPlan.add(es);
 					log.debug("GroupItem: Added operator " + es.getClass().getName() + " " + es + " to logical plan " + groupByPlan);
 					listPlans.add(groupByPlan);
@@ -2430,9 +2430,9 @@ ExpressionOperator AdditiveExpr(Schema over, Map<String, LogicalOperator> specs,
 			assertAtomic(lhs,true);
 			assertAtomic(rhs,true);
 			if (t.image.equals("+")){
-				exprOp = new LOAdd(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+				exprOp = new LOAdd(lp, new OperatorKey(scope, getNextId()));
 			}else{
-				exprOp = new LOSubtract(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+				exprOp = new LOSubtract(lp, new OperatorKey(scope, getNextId()));
 			}
 			lp.add(exprOp);
 			log.debug("AdditiveExpr: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
@@ -2465,11 +2465,11 @@ ExpressionOperator MultiplicativeExpr(Schema over, Map<String, LogicalOperator>
 			assertAtomic(lhs,true);
 			assertAtomic(rhs,true);
 			if (t.image.equals("*")){
-				exprOp = new LOMultiply(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+				exprOp = new LOMultiply(lp, new OperatorKey(scope, getNextId()));
 			}else if (t.image.equals("/")){
-				exprOp = new LODivide(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+				exprOp = new LODivide(lp, new OperatorKey(scope, getNextId()));
 			}else {
-				exprOp = new LOMod(lp, new OperatorKey(scope, getNextId()), lhs, rhs);
+				exprOp = new LOMod(lp, new OperatorKey(scope, getNextId()));
 			}
 			lp.add(exprOp);
 			log.debug("MultiplicativeExpr: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
@@ -2500,7 +2500,7 @@ ExpressionOperator CastExpr(Schema over, Map<String, LogicalOperator> specs,Logi
     [LOOKAHEAD(2)"(" fs = TypeFieldSchema() {castRequired = true;}")"] exprOp = UnaryExpr(over, specs, lp, input)
     {
         if(castRequired) {
-            cast = new LOCast(lp, new OperatorKey(scope, getNextId()), exprOp, fs.type);
+            cast = new LOCast(lp, new OperatorKey(scope, getNextId()), fs.type);
             fs.alias = exprOp.getFieldSchema().alias;
             cast.setFieldSchema(fs);
             lp.add(cast);
@@ -2539,7 +2539,7 @@ ExpressionOperator NegativeExpr(Schema over, Map<String, LogicalOperator> specs,
 {
 	"-" c1=CastExpr(over,specs,lp,input)
 	{
-		ExpressionOperator eOp = new LONegative(lp, new OperatorKey(scope, getNextId()), c1);
+		ExpressionOperator eOp = new LONegative(lp, new OperatorKey(scope, getNextId()));
 		lp.add(eOp);
 		log.debug("NegativeExpr: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
 		lp.connect(c1, eOp);
@@ -2586,7 +2586,7 @@ ExpressionOperator BaseEvalSpec(Schema over, Map<String, LogicalOperator> specs,
 		)
 |		( "#" key = AtomDatum() { 
 			assertAtomic(item, false);
-			ExpressionOperator mapLookup = new LOMapLookup(lp, new OperatorKey(scope, getNextId()), item, key, DataType.BYTEARRAY, null);
+			ExpressionOperator mapLookup = new LOMapLookup(lp, new OperatorKey(scope, getNextId()), key, DataType.BYTEARRAY, null);
 			lp.add(mapLookup);
 			log.debug("BaseEvalSpec: Added operator " + mapLookup.getClass().getName() + " " + mapLookup + " to logical plan " + lp);
 			lp.connect(item, mapLookup);
@@ -2618,8 +2618,7 @@ ExpressionOperator BinCond(Schema over, Map<String, LogicalOperator> specs, Logi
 	
 	)
 	{ 
-		//ExpressionOperator bincond = new LOBinCond(lp, new OperatorKey(scope, getNextId()), conditionPlan, truePlan, falsePlan);
-		ExpressionOperator bincond = new LOBinCond(lp, new OperatorKey(scope, getNextId()), cond, ifTrue, ifFalse);
+		ExpressionOperator bincond = new LOBinCond(lp, new OperatorKey(scope, getNextId()));
 		lp.add(bincond);
 		log.debug("BinCond: Added operator " + bincond.getClass().getName() + " " + bincond + " to logical plan " + lp);
 		lp.connect(cond, bincond);
@@ -2680,7 +2679,7 @@ ExpressionOperator EvalFuncSpec(Schema over, Map<String, LogicalOperator> specs,
             default:
                 throw new ParseException("Received an unknown function type: " + funcType);
             }
-			userFunc = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), funcSpec, args, type);
+			userFunc = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), funcSpec, type);
         } else {
             throw new ParseException("Could not instantiate function: " + funcNameAlias);
         }
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 1ee7d96bb..ead1b29bb 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -268,23 +268,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private void insertCastForRegexp(LORegexp rg) throws VisitorException {
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-        collectCastWarning(rg, DataType.BYTEARRAY, DataType.CHARARRAY) ;
-        OperatorKey newKey = genNewOperatorKey(rg) ;
-        LOCast cast = new LOCast(currentPlan, newKey, rg.getOperand(), DataType.CHARARRAY) ;
-        currentPlan.add(cast) ;
-        currentPlan.disconnect(rg.getOperand(), rg) ;
-        try {
-            currentPlan.connect(rg.getOperand(), cast) ;
-            currentPlan.connect(cast, rg) ;
-        }
-        catch (PlanException pe) {
-            int errCode = 2059;
-            String msg = "Problem with inserting cast operator for regular expression in plan.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
-        }
-        rg.setOperand(cast) ;
-        this.visit(cast);
+        insertCast(rg, DataType.CHARARRAY, rg.getOperand());
     }
 
     public void visit(LOAnd binOp) throws VisitorException {
@@ -1011,52 +995,37 @@ public class TypeCheckingVisitor extends LOVisitor {
 
     private void insertLeftCastForBinaryOp(BinaryExpressionOperator binOp,
                                            byte toType ) throws VisitorException {
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-        collectCastWarning(binOp,
-                           binOp.getLhsOperand().getType(),
-                           toType) ;
-        OperatorKey newKey = genNewOperatorKey(binOp) ;
-        LOCast cast = new LOCast(currentPlan, newKey, binOp.getLhsOperand(), toType) ;
-        currentPlan.add(cast) ;
-        currentPlan.disconnect(binOp.getLhsOperand(), binOp) ;
-        try {
-            currentPlan.connect(binOp.getLhsOperand(), cast) ;
-            currentPlan.connect(cast, binOp) ;
-            binOp.setLhsOperand(cast);
-        }
-        catch (PlanException pe) {
-            int errCode = 2059;
-            String msg = "Problem with inserting cast operator for binary conditional in plan.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
-        }
-        binOp.setLhsOperand(cast) ;
-        this.visit(cast);
+        insertCast(binOp, toType, binOp.getLhsOperand());
     }
 
     private void insertRightCastForBinaryOp(BinaryExpressionOperator binOp,
                                             byte toType ) throws VisitorException {
+        insertCast(binOp, toType, binOp.getRhsOperand());
+    }
+
+
+    private void insertCast(ExpressionOperator node,
+                            byte toType, ExpressionOperator predecessor) 
+    throws VisitorException {
         LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-        collectCastWarning(binOp,
-                           binOp.getRhsOperand().getType(),
-                           toType) ;
-        OperatorKey newKey = genNewOperatorKey(binOp) ;
-        LOCast cast = new LOCast(currentPlan, newKey, binOp.getRhsOperand(), toType) ;
+        collectCastWarning(node, predecessor.getType(), toType);
+
+        OperatorKey newKey = genNewOperatorKey(node);
+        LOCast cast = new LOCast(currentPlan, newKey, toType) ;
         currentPlan.add(cast) ;
-        currentPlan.disconnect(binOp.getRhsOperand(), binOp) ;
         try {
-            currentPlan.connect(binOp.getRhsOperand(), cast) ;
-            currentPlan.connect(cast, binOp) ;
-            binOp.setRhsOperand(cast);
+            currentPlan.insertBetween(predecessor, cast, node);
         }
         catch (PlanException pe) {
             int errCode = 2059;
-            String msg = "Problem with inserting cast operator for binary conditional in plan.";
+            String msg = "Problem with inserting cast operator for " + node + " in plan.";
             throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
         }
-        binOp.setRhsOperand(cast) ;
         this.visit(cast);
     }
 
+    
+    
     /**
      * Currently, there are two unaryOps: Neg and Not.
      */
@@ -1101,36 +1070,7 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private void insertCastForUniOp(UnaryExpressionOperator uniOp, byte toType) throws VisitorException {
-        collectCastWarning(uniOp,
-                           uniOp.getOperand().getType(),
-                           toType) ;
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-        List<LogicalOperator> list = currentPlan.getPredecessors(uniOp) ;
-        if (list==null) {
-            int errCode = 1080;
-            String msg = "Did not find inputs for operator: " + uniOp.getClass().getSimpleName();
-            throw new TypeCheckerException(msg, errCode, PigException.INPUT) ;
-        }
-        // All uniOps at the moment only work with Expression input
-        ExpressionOperator input = (ExpressionOperator) list.get(0) ;                
-        OperatorKey newKey = genNewOperatorKey(uniOp) ;
-        LOCast cast = new LOCast(currentPlan, newKey, input, toType) ;
-        
-        currentPlan.add(cast);
-        currentPlan.disconnect(input, uniOp) ;
-        try {
-            currentPlan.connect(input, cast) ;
-            currentPlan.connect(cast, uniOp) ;
-        } 
-        catch (PlanException pe) {
-            int errCode = 2059;
-            String msg = "Problem with inserting cast operator for unary operator in plan.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
-        }
-
-        uniOp.setOperand(cast);
-        this.visit(cast);
-
+        insertCast(uniOp, toType, uniOp.getOperand());
     }
     
     // Currently there is no input type information support in UserFunc
@@ -1688,35 +1628,10 @@ public class TypeCheckingVisitor extends LOVisitor {
             ++i;
             FieldSchema tFSch = tsLst.get(i); 
             if(fFSch.type==tFSch.type) {
-                newArgs.add(args.get(i));
                 continue;
             }
-            collectCastWarning(udf,
-                    fFSch.type,
-                    tFSch.type);
-            LogicalPlan currentPlan = (LogicalPlan) mCurrentWalker.getPlan();
-            /*List<LogicalOperator> list = currentPlan.getPredecessors(udf);
-            if (list == null) {
-                throw new AssertionError("No input for " + udf.getClass());
-            }*/
-            // All uniOps at the moment only work with Expression input
-            ExpressionOperator input = args.get(i);
-            OperatorKey newKey = genNewOperatorKey(udf);
-            LOCast cast = new LOCast(currentPlan, newKey, input, tFSch.type);
-            currentPlan.add(cast);
-            try {
-                currentPlan.insertBetween(input, cast, udf);
-                this.visit(cast);
-            } catch (PlanException pe) {
-                int errCode = 2059;
-                String msg = "Problem with inserting cast operator for user defined function in plan.";
-                throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
-            } catch (VisitorException ve) {
-                throw ve;
-            }
+            insertCast(udf, tFSch.type, args.get(i));
         }
-        udf.setMArgs(newArgs);
-
     }
 
     /**
@@ -1815,73 +1730,11 @@ public class TypeCheckingVisitor extends LOVisitor {
     }
 
     private void insertLeftCastForBinCond(LOBinCond binCond, byte toType) throws VisitorException {
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-
-        collectCastWarning(binCond,
-                           binCond.getLhsOp().getType(),
-                           toType) ;
-
-        OperatorKey newKey = genNewOperatorKey(binCond) ;
-        LOCast cast = new LOCast(currentPlan, newKey, binCond.getLhsOp(), toType) ;
-        // if we are casting a null constant, also set its field schema to the
-        // field schema of the other operator in the bincond
-        if (binCond.getLhsOp() instanceof LOConst
-                && ((LOConst) binCond.getLhsOp()).getValue() == null) {
-            try {
-                    cast.setFieldSchema(binCond.getRhsOp().getFieldSchema());
-            } catch (FrontendException e) {
-                int errCode = 1043;
-                String msg = "Unable to retrieve field schema of operator";
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT, e);
-            }
-        }
-        currentPlan.add(cast) ;
-        try {
-            currentPlan.insertBetween(binCond.getLhsOp(), cast, binCond);
-        } 
-        catch (PlanException pe) {
-            int errCode = 2059;
-            String msg = "Problem with inserting cast operator for binary conditional in plan.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
-        } 
-        binCond.setLhsOp(cast) ;
-        this.visit(cast);
-
+        insertCast(binCond, toType, binCond.getLhsOp());
     }
 
     private void insertRightCastForBinCond(LOBinCond binCond, byte toType) throws VisitorException {
-        LogicalPlan currentPlan =  (LogicalPlan) mCurrentWalker.getPlan() ;
-
-        collectCastWarning(binCond,
-                           binCond.getRhsOp().getType(),
-                           toType) ;
-
-        OperatorKey newKey = genNewOperatorKey(binCond) ;
-        LOCast cast = new LOCast(currentPlan, newKey, binCond.getRhsOp(), toType) ;
-        // if we are casting a null constant, also set its field schema to the
-        // field schema of the other operator in the bincond
-        if (binCond.getRhsOp() instanceof LOConst
-                && ((LOConst) binCond.getRhsOp()).getValue() == null) {
-            try {
-                cast.setFieldSchema(binCond.getLhsOp().getFieldSchema());
-            } catch (FrontendException e) {
-                int errCode = 1043;
-                String msg = "Unable to retrieve field schema of operator";
-                throw new TypeCheckerException(msg, errCode, PigException.INPUT, e);
-            }
-        }
-        currentPlan.add(cast) ;
-        try {
-            currentPlan.insertBetween(binCond.getRhsOp(), cast, binCond) ;
-        } 
-        catch (PlanException pe) {
-            int errCode = 2059;
-            String msg = "Problem with inserting cast operator for binary conditional in plan.";
-            throw new TypeCheckerException(msg, errCode, PigException.BUG, pe);
-        }               
-        binCond.setRhsOp(cast) ;
-        this.visit(cast);
-
+        insertCast(binCond, toType, binCond.getRhsOp());
     }
 
     /**
@@ -2542,7 +2395,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         ExpressionOperator currentOutput = (ExpressionOperator) leaves.get(0);
         collectCastWarning(frj, currentOutput.getType(), toType);
         OperatorKey newKey = genNewOperatorKey(currentOutput);
-        LOCast cast = new LOCast(innerPlan, newKey, currentOutput, toType);
+        LOCast cast = new LOCast(innerPlan, newKey, toType);
         innerPlan.add(cast);
         try {
             innerPlan.connect(currentOutput, cast);
@@ -2575,7 +2428,7 @@ public class TypeCheckingVisitor extends LOVisitor {
         ExpressionOperator currentOutput = (ExpressionOperator) leaves.get(0) ;
         collectCastWarning(cg, currentOutput.getType(), toType) ;
         OperatorKey newKey = genNewOperatorKey(currentOutput) ;
-        LOCast cast = new LOCast(innerPlan, newKey, currentOutput, toType) ;
+        LOCast cast = new LOCast(innerPlan, newKey, toType) ;
         innerPlan.add(cast) ;
         try {
             innerPlan.connect(currentOutput, cast) ;
@@ -2967,7 +2820,6 @@ public class TypeCheckingVisitor extends LOVisitor {
                 castNeededCounter++ ;
                 LOCast cast = new LOCast(genPlan,
                                          genNewOperatorKey(fromOp),
-                                         project,
                                          inputFieldType) ;
                 genPlan.add(cast) ;
                 try {
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index 166a1fce6..6bb0aa41b 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -172,7 +172,6 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable, Seri
             log.error(pe.getMessage());
             throw pe;
         }
-
         mFromEdges.put(from, to);
         mToEdges.put(to, from);
     }
@@ -189,7 +188,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable, Seri
      */
     public boolean disconnect(E from, E to) {
         markDirty();
-
+        
         boolean sawNull = false;
         if (mFromEdges.remove(from, to) == null) sawNull = true;
         if (mToEdges.remove(to, from) == null) sawNull = true;
@@ -410,6 +409,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable, Seri
 
     /**
      * Given two connected nodes add another node between them.
+     * 'newNode' will be placed in same position in predecessor list as 'before' (old node).
      * @param after Node to insert this node after
      * @param newNode new node to insert.  This node must have already been
      * added to the plan.
@@ -432,6 +432,7 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable, Seri
         mToEdges.put(newNode, after);
     }
 
+    // replaces (src -> dst) entry in multiMap with (src -> replacement)
     private boolean replaceNode(E src, E replacement, E dst, MultiMap<E, E> multiMap) {
         Collection c = multiMap.get(src);
         if (c == null) return false;
@@ -533,6 +534,104 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable, Seri
         if (pred != null && succ != null) connect(pred, succ);
     }
 
+    /**
+     * Remove a node in a way that connects the node's predecessor (if any)
+     * with the node's successors (if any).  This function handles the
+     * case where the node has *one* predecessor and one or more successors.
+     * It replaces the predecessor in same position as node was in
+     * each of the successors predecessor list(getPredecessors()), to 
+     * preserve input ordering 
+     * for eg, it is used to remove redundant project(*) from plan
+     * which will have only one predecessor,but can have multiple success
+     * @param node Node to be removed
+     * @throws PlanException if the node has more than one predecessor
+     */
+    public void removeAndReconnectMultiSucc(E node) throws PlanException {
+
+        // Before:
+        //    A (predecessor (only one) )
+        //  / |
+        // X  B(nodeB)  Y(some predecessor of a Cn)
+        //  / | \     / 
+        // C1 C2  C3 ... (Successors)
+        // should become
+        // After:
+        //    ___ A     Y
+        //   /  / | \  /
+        //  X  C1 C2 C3 ...
+        // the variable names are from above example
+
+    	E nodeB = node;
+        List<E> preds = getPredecessors(nodeB);
+        //checking pre-requisite conditions
+        if (preds == null || preds.size() != 1) {
+            Integer size = null;
+            if(preds != null)
+                size = preds.size();
+
+            PlanException pe = new PlanException("Attempt to remove " +
+                    " and reconnect for node with  " + size +
+            " predecessors.");
+            log.error(pe.getMessage());
+            throw pe;
+        }
+
+        //A and C
+        E nodeA = preds.get(0);
+        Collection<E> nodeC = mFromEdges.get(nodeB);
+
+        //checking pre-requisite conditions
+        if (nodeC == null || nodeC.size() == 0) {
+            PlanException pe = new PlanException("Attempt to remove " +
+            " and reconnect for node with no successors.");
+            log.error(pe.getMessage());
+            throw pe;
+        }   
+
+
+        // replace B in A.succesors and add B.successors(ie C) to it
+        replaceAndAddSucessors(nodeA, nodeB);
+        
+        // for all C(succs) , replace B(node) in predecessors, with A(pred)
+        for(E c: nodeC) {
+            Collection<E> sPreds = mToEdges.get(c);
+            ArrayList<E> newPreds = new ArrayList<E>(sPreds.size());
+            for(E p: sPreds){
+                if(p == nodeB){
+                    //replace
+                    newPreds.add(nodeA);
+                }
+                else{
+                    newPreds.add(p);
+                }
+            }
+            mToEdges.removeKey(c);
+            mToEdges.put(c,newPreds);
+            
+        }
+        remove(nodeB); 
+    }
+    
+    //removes entry  for succ in list of successors of nd, and adds successors
+    // of succ in its place
+    // @param nd - parent node whose entry for succ needs to be replaced
+    // @param succ - see above
+    private void replaceAndAddSucessors(E nd, E succ) throws PlanException {
+       Collection<E> oldSuccs = mFromEdges.get(nd);
+       Collection<E> repSuccs = mFromEdges.get(succ);
+       ArrayList<E> newSuccs = new ArrayList<E>(oldSuccs.size() - 1 + repSuccs.size() );
+       for(E s: oldSuccs){
+           if(s == succ){
+               newSuccs.addAll(repSuccs);
+           }else{
+               newSuccs.add(s);
+           }
+       }
+       mFromEdges.removeKey(nd);
+       mFromEdges.put(nd,newSuccs);
+    }
+    
+
     public void dump(PrintStream ps) {
         ps.println("Ops");
         for (E op : mOps.keySet()) {
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index de139e21a..7485c9c79 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -23,16 +23,21 @@ import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Random;
 
 import org.junit.Before;
 import org.junit.Test;
 
+import org.apache.pig.EvalFunc;
 import org.apache.pig.ExecType;
 import org.apache.pig.PigServer;
 import org.apache.pig.data.*;
 import org.apache.pig.impl.io.FileLocalizer;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.test.utils.Identity;
 import org.apache.pig.builtin.BinStorage;
 
@@ -54,6 +59,37 @@ public class TestEvalPipeline2 extends TestCase {
 //        pigServer = new PigServer(ExecType.LOCAL);
     }
     
+    
+    @Test
+    public void testUdfInputOrder() throws IOException {
+        String[] input = {
+                "(123)",
+                "((123)",
+                "(123123123123)",
+                "(asdf)"
+        };
+        
+        Util.createInputFile(cluster, "table_udfInp", input);
+        pigServer.registerQuery("a = load 'table_udfInp' as (i:int);");
+        pigServer.registerQuery("b = foreach a {dec = 'hello'; str1 = " +  Identity.class.getName() + 
+                    "(dec,'abc','def');" + 
+                    "generate dec,str1; };");
+        Iterator<Tuple> it = pigServer.openIterator("b");
+        
+        Tuple tup=null;
+
+        //tuple 1 
+        tup = it.next();
+        Tuple out = (Tuple)tup.get(1);
+
+        assertEquals( out.get(0).toString(), "hello");
+        assertEquals(out.get(1).toString(), "abc");
+        assertEquals(out.get(2).toString(), "def");
+        
+        Util.deleteFile(cluster, "table_udfInp");
+    }
+ 
+
     @Test
     public void testUDFwithStarInput() throws Exception {
         int LOOP_COUNT = 10;
@@ -255,5 +291,4 @@ public class TestEvalPipeline2 extends TestCase {
         Util.deleteFile(cluster, "table_bs_ac_clxt");
     }
 
-    
 }
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidator.java b/test/org/apache/pig/test/TestTypeCheckingValidator.java
index 2bddd1bd1..aa8a8ff8f 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidator.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidator.java
@@ -76,9 +76,9 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123f) ;
         constant3.setType(DataType.FLOAT) ;
         
-        LOAdd add1 = new LOAdd(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), constant3, DataType.DOUBLE) ;
-        LOMultiply mul1 = new LOMultiply(plan, genNewOperatorKey(), add1, cast1) ;
+        LOAdd add1 = new LOAdd(plan, genNewOperatorKey()) ;
+        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), DataType.DOUBLE) ;
+        LOMultiply mul1 = new LOMultiply(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -123,9 +123,9 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), "123") ;
         constant3.setType(DataType.CHARARRAY) ;
         
-        LOAdd add1 = new LOAdd(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), constant3, DataType.BYTEARRAY) ;
-        LOMultiply mul1 = new LOMultiply(plan, genNewOperatorKey(), add1, cast1) ;
+        LOAdd add1 = new LOAdd(plan, genNewOperatorKey()) ;
+        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), DataType.BYTEARRAY) ;
+        LOMultiply mul1 = new LOMultiply(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -169,10 +169,10 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant4 =  new LOConst(plan, genNewOperatorKey(), true) ;
         constant4.setType(DataType.BOOLEAN) ;
         
-        LOSubtract sub1 = new LOSubtract(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOGreaterThan gt1 = new LOGreaterThan(plan, genNewOperatorKey(), sub1, constant3) ;
-        LOAnd and1 = new LOAnd(plan, genNewOperatorKey(), gt1, constant4) ;
-        LONot not1 = new LONot(plan, genNewOperatorKey(), and1) ;
+        LOSubtract sub1 = new LOSubtract(plan, genNewOperatorKey()) ;
+        LOGreaterThan gt1 = new LOGreaterThan(plan, genNewOperatorKey()) ;
+        LOAnd and1 = new LOAnd(plan, genNewOperatorKey()) ;
+        LONot not1 = new LONot(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -229,8 +229,8 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123) ;
         constant3.setType(DataType.INTEGER) ;
         
-        LOMod mod1 = new LOMod(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey(), mod1, constant3) ;
+        LOMod mod1 = new LOMod(plan, genNewOperatorKey()) ;
+        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -273,9 +273,9 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123f) ;
         constant3.setType(DataType.FLOAT) ;
         
-        LODivide div1 = new LODivide(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), constant3, DataType.DOUBLE) ;
-        LONotEqual notequal1 = new LONotEqual(plan, genNewOperatorKey(), div1, cast1) ;
+        LODivide div1 = new LODivide(plan, genNewOperatorKey()) ;
+        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), DataType.DOUBLE) ;
+        LONotEqual notequal1 = new LONotEqual(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -321,9 +321,9 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), "123") ;
         constant3.setType(DataType.CHARARRAY) ;
         
-        LODivide div1 = new LODivide(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), constant3, DataType.BYTEARRAY) ;
-        LONotEqual notequal1 = new LONotEqual(plan, genNewOperatorKey(), div1, cast1) ;
+        LODivide div1 = new LODivide(plan, genNewOperatorKey()) ;
+        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), DataType.BYTEARRAY) ;
+        LONotEqual notequal1 = new LONotEqual(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -368,8 +368,8 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant4 =  new LOConst(plan, genNewOperatorKey(), 123D) ;
         constant4.setType(DataType.DOUBLE) ;
         
-        LOLesserThanEqual lesser1 = new LOLesserThanEqual(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOBinCond bincond1 = new LOBinCond(plan, genNewOperatorKey(), lesser1, constant3, constant4) ;
+        LOLesserThanEqual lesser1 = new LOLesserThanEqual(plan, genNewOperatorKey()) ;
+        LOBinCond bincond1 = new LOBinCond(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -415,7 +415,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
         
-        LOAdd add1 = new LOAdd(plan, genNewOperatorKey(), constant1, constant2) ;
+        LOAdd add1 = new LOAdd(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -452,8 +452,8 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant3 =  new LOConst(plan, genNewOperatorKey(), 123L) ;
         constant3.setType(DataType.LONG) ;        
         
-        LOGreaterThan gt1 = new LOGreaterThan(plan, genNewOperatorKey(), constant1, constant2) ;
-        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey(), gt1, constant3) ;
+        LOGreaterThan gt1 = new LOGreaterThan(plan, genNewOperatorKey()) ;
+        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -537,10 +537,10 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), tuple) ;
         constant2.setType(DataType.TUPLE) ;
         constant2.setFieldSchema(new Schema.FieldSchema(null, tupleSchema, DataType.TUPLE));
-        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), constant1, DataType.TUPLE) ;
+        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), DataType.TUPLE) ;
         cast1.setFieldSchema(new FieldSchema(null, castSchema, DataType.TUPLE));
         
-        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey(), cast1, constant2) ;
+        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -623,10 +623,10 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), tuple) ;
         constant2.setType(DataType.TUPLE) ;
         constant2.setFieldSchema(new Schema.FieldSchema(null, tupleSchema, DataType.TUPLE));
-        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), constant1, DataType.TUPLE) ;
+        LOCast cast1 = new LOCast(plan, genNewOperatorKey(), DataType.TUPLE) ;
         cast1.setFieldSchema(new FieldSchema(null, castSchema, DataType.TUPLE));
         
-        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey(), cast1, constant2) ;
+        LOEqual equal1 = new LOEqual(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -663,7 +663,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20D) ;
         constant2.setType(DataType.DOUBLE) ;
         
-        LOMultiply mul1 = new LOMultiply(plan, genNewOperatorKey(), constant1, constant2) ;
+        LOMultiply mul1 = new LOMultiply(plan, genNewOperatorKey()) ;
         
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -696,11 +696,8 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
 
-        LONegative neg1 = new LONegative(plan, genNewOperatorKey(), constant1) ;
-        LOSubtract subtract1 = new LOSubtract(plan,
-                                              genNewOperatorKey(),
-                                              neg1,
-                                              constant2) ;
+        LONegative neg1 = new LONegative(plan, genNewOperatorKey()) ;
+        LOSubtract subtract1 = new LOSubtract(plan, genNewOperatorKey()) ;
 
         plan.add(constant1) ;
         plan.add(neg1) ; 
@@ -738,7 +735,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst constant2 =  new LOConst(plan, genNewOperatorKey(), 20L) ;
         constant2.setType(DataType.LONG) ;
 
-        LOMod mod1 = new LOMod(plan, genNewOperatorKey(), constant1, constant2) ;
+        LOMod mod1 = new LOMod(plan, genNewOperatorKey()) ;
 
         plan.add(constant1) ;
         plan.add(constant2) ;
@@ -772,15 +769,17 @@ public class TestTypeCheckingValidator extends TestCase {
     public void testRegexTypeChecking1() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), "10") ;
+        LOConst constant2 = new LOConst(plan, genNewOperatorKey(), "Regex");
         constant1.setType(DataType.CHARARRAY) ;
 
-        LORegexp regex = new LORegexp(plan, genNewOperatorKey(), constant1,
-            new LOConst(plan, genNewOperatorKey(), "Regex")) ;
-
+        LORegexp regex = new LORegexp(plan, genNewOperatorKey()) ;
+        
         plan.add(constant1) ;
+        plan.add(constant2) ;
         plan.add(regex) ;
 
         plan.connect(constant1, regex) ;     
+        plan.connect(constant2, regex) ;     
 
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
@@ -799,15 +798,17 @@ public class TestTypeCheckingValidator extends TestCase {
     public void testRegexTypeChecking2() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), new DataByteArray()) ;
+        LOConst constant2 = new LOConst(plan, genNewOperatorKey(), "Regex");
         constant1.setType(DataType.BYTEARRAY) ;
 
-        LORegexp regex = new LORegexp(plan, genNewOperatorKey(), constant1,
-            new LOConst(plan, genNewOperatorKey(), "Regex"));
+        LORegexp regex = new LORegexp(plan, genNewOperatorKey());
 
         plan.add(constant1) ;
+        plan.add(constant2) ;
         plan.add(regex) ;
 
         plan.connect(constant1, regex) ;
+        plan.connect(constant2, regex) ;
 
         CompilationMessageCollector collector = new CompilationMessageCollector() ;
         TypeCheckingValidator typeValidator = new TypeCheckingValidator() ;
@@ -837,15 +838,17 @@ public class TestTypeCheckingValidator extends TestCase {
     public void testRegexTypeChecking3() throws Throwable {
         LogicalPlan plan = new LogicalPlan() ;
         LOConst constant1 = new LOConst(plan, genNewOperatorKey(), 10) ;
+        LOConst constant2 = new LOConst(plan, genNewOperatorKey(), "Regex");
         constant1.setType(DataType.INTEGER) ;
 
-        LORegexp regex = new LORegexp(plan, genNewOperatorKey(), constant1,
-            new LOConst(plan, genNewOperatorKey(), "Regex"));
-
+        LORegexp regex = new LORegexp(plan, genNewOperatorKey());
+        
         plan.add(constant1) ;
+        plan.add(constant2) ;
         plan.add(regex) ;
 
         plan.connect(constant1, regex) ;
+        plan.connect(constant2, regex) ;
 
         try {
             CompilationMessageCollector collector = new CompilationMessageCollector() ;
@@ -1316,9 +1319,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project2.setSentinel(true);
 
         LOGreaterThan gt1 = new LOGreaterThan(innerPlan,
-                                              genNewOperatorKey(),
-                                              project1,
-                                              project2) ;
+                                              genNewOperatorKey()) ;
 
         innerPlan.add(project1) ;
         innerPlan.add(project2) ;
@@ -1385,7 +1386,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOProject project2 = new LOProject(innerPlan, genNewOperatorKey(), load1, 1) ;
         project2.setSentinel(true);
 
-        LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey(), project1, project2) ;
+        LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey()) ;
 
         innerPlan.add(project1) ;
         innerPlan.add(project2) ;
@@ -1534,7 +1535,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LOMultiply mul1 = new LOMultiply(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LOMultiply mul1 = new LOMultiply(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -1549,7 +1550,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project21.setSentinel(true);
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26L) ;
         const21.setType(DataType.LONG);
-        LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey(), project21, const21) ;
+        LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -1632,7 +1633,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LOMultiply mul1 = new LOMultiply(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LOMultiply mul1 = new LOMultiply(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -1647,7 +1648,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project21.setSentinel(true);
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), "26") ;
         const21.setType(DataType.CHARARRAY);
-        LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey(), project21, const21) ;
+        LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -1727,7 +1728,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -1743,9 +1744,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
         const21.setType(DataType.LONG);
         LOLesserThanEqual lesser21 = new LOLesserThanEqual(innerPlan2,
-                                                           genNewOperatorKey(),
-                                                           project21,
-                                                           const21) ;
+                                                           genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -1855,7 +1854,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -1871,9 +1870,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
         const21.setType(DataType.LONG);
         LOSubtract subtract21 = new LOSubtract(innerPlan2,
-                                               genNewOperatorKey(),
-                                               project21,
-                                               const21) ;
+                                               genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -1973,9 +1970,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const111 = new LOConst(innerPlan11, genNewOperatorKey(), 26F) ;
         const111.setType(DataType.FLOAT);
         LOSubtract subtract111 = new LOSubtract(innerPlan11,
-                                                genNewOperatorKey(),
-                                                project111,
-                                                const111) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan11.add(project111) ;
         innerPlan11.add(const111) ;
@@ -1992,9 +1987,7 @@ public class TestTypeCheckingValidator extends TestCase {
         project212.setSentinel(true);
 
         LOAdd add211 = new LOAdd(innerPlan21,
-                                 genNewOperatorKey(),
-                                 project211,
-                                 project212) ;
+                                 genNewOperatorKey()) ;
 
         innerPlan21.add(project211) ;
         innerPlan21.add(project212) ;
@@ -2011,9 +2004,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const121 = new LOConst(innerPlan12, genNewOperatorKey(), 26) ;
         const121.setType(DataType.INTEGER);
         LOSubtract subtract121 = new LOSubtract(innerPlan12,
-                                                genNewOperatorKey(),
-                                                project121,
-                                                const121) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan12.add(project121) ;
         innerPlan12.add(const121) ;
@@ -2144,9 +2135,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const111 = new LOConst(innerPlan11, genNewOperatorKey(), 26F) ;
         const111.setType(DataType.FLOAT);
         LOSubtract subtract111 = new LOSubtract(innerPlan11,
-                                                genNewOperatorKey(),
-                                                project111,
-                                                const111) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan11.add(project111) ;
         innerPlan11.add(const111) ;
@@ -2162,9 +2151,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const121 = new LOConst(innerPlan12, genNewOperatorKey(), 26) ;
         const121.setType(DataType.INTEGER);
         LOSubtract subtract121 = new LOSubtract(innerPlan12,
-                                                genNewOperatorKey(),
-                                                project121,
-                                                const121) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan12.add(project121) ;
         innerPlan12.add(const121) ;
@@ -2283,9 +2270,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const111 = new LOConst(innerPlan11, genNewOperatorKey(), 26F) ;
         const111.setType(DataType.FLOAT);
         LOSubtract subtract111 = new LOSubtract(innerPlan11,
-                                                genNewOperatorKey(),
-                                                project111,
-                                                const111) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan11.add(project111) ;
         innerPlan11.add(const111) ;
@@ -2390,9 +2375,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const11 = new LOConst(innerPlan1, genNewOperatorKey(), 26F) ;
         const11.setType(DataType.FLOAT);
         LOSubtract subtract11 = new LOSubtract(innerPlan1,
-                                                genNewOperatorKey(),
-                                                project11,
-                                                const11) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(const11) ;
@@ -2403,14 +2386,12 @@ public class TestTypeCheckingValidator extends TestCase {
 
         // Create expression inner plan #2
         LogicalPlan innerPlan2 = new LogicalPlan() ;
-        LOProject project21 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 0) ;
+        LOProject project21 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 0) ;
         project21.setSentinel(true);
-        LOProject project22 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
+        LOProject project22 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 1) ;
         project21.setSentinel(true);
-        LOAdd add21 = new LOAdd(innerPlan1,
-                                genNewOperatorKey(),
-                                project21,
-                                project22) ;
+        LOAdd add21 = new LOAdd(innerPlan2,
+                                genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(project22) ;
@@ -2484,9 +2465,7 @@ public class TestTypeCheckingValidator extends TestCase {
         LOConst const11 = new LOConst(innerPlan1, genNewOperatorKey(), "26F") ;
         const11.setType(DataType.CHARARRAY);
         LOSubtract subtract11 = new LOSubtract(innerPlan1,
-                                                genNewOperatorKey(),
-                                                project11,
-                                                const11) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(const11) ;
@@ -2497,14 +2476,12 @@ public class TestTypeCheckingValidator extends TestCase {
 
         // Create expression inner plan #2
         LogicalPlan innerPlan2 = new LogicalPlan() ;
-        LOProject project21 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 0) ;
+        LOProject project21 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 0) ;
         project21.setSentinel(true);
-        LOProject project22 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
+        LOProject project22 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 1) ;
         project21.setSentinel(true);
-        LOAdd add21 = new LOAdd(innerPlan1,
-                                genNewOperatorKey(),
-                                project21,
-                                project22) ;
+        LOAdd add21 = new LOAdd(innerPlan2,
+                                genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(project22) ;
@@ -2700,14 +2677,12 @@ public class TestTypeCheckingValidator extends TestCase {
 
         // Create expression inner plan #1 of input #2
         LogicalPlan innerPlan2 = new LogicalPlan() ;
-        LOProject project21 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 0) ;
+        LOProject project21 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 0) ;
         project21.setSentinel(true);
-        LOProject project22 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
+        LOProject project22 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 1) ;
         project21.setSentinel(true);
-        LOAdd add21 = new LOAdd(innerPlan1,
-                                genNewOperatorKey(),
-                                project21,
-                                project22) ;
+        LOAdd add21 = new LOAdd(innerPlan2,
+                                genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(project22) ;
diff --git a/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java b/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java
index 489683f50..45e6059a2 100644
--- a/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java
+++ b/test/org/apache/pig/test/TestTypeCheckingValidatorNoSchema.java
@@ -147,7 +147,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -163,9 +163,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
         const21.setType(DataType.LONG);
         LOLesserThanEqual lesser21 = new LOLesserThanEqual(innerPlan2,
-                                                           genNewOperatorKey(),
-                                                           project21,
-                                                           const21) ;
+                                                           genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -246,7 +244,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LONotEqual notequal1 = new LONotEqual(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -261,10 +259,10 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project21.setSentinel(true);
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
         const21.setType(DataType.LONG);
-        LOAdd add21 = new LOAdd(innerPlan2, genNewOperatorKey(), project21, const21) ;
+        LOAdd add21 = new LOAdd(innerPlan2, genNewOperatorKey()) ;
         LOConst const22 = new LOConst(innerPlan2, genNewOperatorKey(), "hoho") ;
         const22.setType(DataType.CHARARRAY);
-        LOSubtract subtract21 = new LOSubtract(innerPlan2, genNewOperatorKey(), const22, add21) ;
+        LOSubtract subtract21 = new LOSubtract(innerPlan2, genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -376,7 +374,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project11.setSentinel(true);
         LOProject project12 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
         project11.setSentinel(true);
-        LOMultiply mul1 = new LOMultiply(innerPlan1, genNewOperatorKey(), project11, project12) ;
+        LOMultiply mul1 = new LOMultiply(innerPlan1, genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(project12) ;
@@ -391,7 +389,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project21.setSentinel(true);
         LOConst const21 = new LOConst(innerPlan2, genNewOperatorKey(), 26) ;
         const21.setType(DataType.LONG);
-        LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey(), project21, const21) ;
+        LOMod mod21 = new LOMod(innerPlan2, genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(const21) ;
@@ -456,14 +454,12 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project1.setSentinel(true);
         LOProject project2 = new LOProject(innerPlan, genNewOperatorKey(), load1, 1) ;
         project2.setSentinel(true);
-        LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey(), project1, project2) ;
+        LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey()) ;
         LOConst const1  = new LOConst(innerPlan, genNewOperatorKey(), 10) ;
         const1.setType(DataType.LONG);
 
         LOGreaterThan gt1 = new LOGreaterThan(innerPlan,
-                                              genNewOperatorKey(),
-                                              add1,
-                                              const1) ;
+                                              genNewOperatorKey()) ;
 
         innerPlan.add(project1) ;
         innerPlan.add(project2) ;
@@ -522,14 +518,12 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project1.setSentinel(true);
         LOProject project2 = new LOProject(innerPlan, genNewOperatorKey(), load1, 1) ;
         project2.setSentinel(true);
-        LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey(), project1, project2) ;
+        LOAdd add1 = new LOAdd(innerPlan, genNewOperatorKey()) ;
         LOConst const1  = new LOConst(innerPlan, genNewOperatorKey(), "10") ;
         const1.setType(DataType.CHARARRAY);
 
         LOGreaterThan gt1 = new LOGreaterThan(innerPlan,
-                                              genNewOperatorKey(),
-                                              add1,
-                                              const1) ;
+                                              genNewOperatorKey()) ;
 
         innerPlan.add(project1) ;
         innerPlan.add(project2) ;
@@ -684,9 +678,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOConst const111 = new LOConst(innerPlan11, genNewOperatorKey(), 26F) ;
         const111.setType(DataType.FLOAT);
         LOSubtract subtract111 = new LOSubtract(innerPlan11,
-                                                genNewOperatorKey(),
-                                                project111,
-                                                const111) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan11.add(project111) ;
         innerPlan11.add(const111) ;
@@ -702,9 +694,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOConst const121 = new LOConst(innerPlan12, genNewOperatorKey(), 26) ;
         const121.setType(DataType.INTEGER);
         LOSubtract subtract121 = new LOSubtract(innerPlan12,
-                                                genNewOperatorKey(),
-                                                project121,
-                                                const121) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan12.add(project121) ;
         innerPlan12.add(const121) ;
@@ -790,9 +780,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOConst const111 = new LOConst(innerPlan11, genNewOperatorKey(), 26F) ;
         const111.setType(DataType.FLOAT);
         LOSubtract subtract111 = new LOSubtract(innerPlan11,
-                                                genNewOperatorKey(),
-                                                project111,
-                                                const111) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan11.add(project111) ;
         innerPlan11.add(const111) ;
@@ -809,9 +797,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         project212.setSentinel(true);
 
         LOAdd add211 = new LOAdd(innerPlan21,
-                                 genNewOperatorKey(),
-                                 project211,
-                                 project212) ;
+                                 genNewOperatorKey()) ;
 
         innerPlan21.add(project211) ;
         innerPlan21.add(project212) ;
@@ -828,9 +814,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOConst const121 = new LOConst(innerPlan12, genNewOperatorKey(), 26) ;
         const121.setType(DataType.INTEGER);
         LOSubtract subtract121 = new LOSubtract(innerPlan12,
-                                                genNewOperatorKey(),
-                                                project121,
-                                                const121) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan12.add(project121) ;
         innerPlan12.add(const121) ;
@@ -928,9 +912,7 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
         LOConst const11 = new LOConst(innerPlan1, genNewOperatorKey(), 26F) ;
         const11.setType(DataType.FLOAT);
         LOSubtract subtract11 = new LOSubtract(innerPlan1,
-                                                genNewOperatorKey(),
-                                                project11,
-                                                const11) ;
+                                                genNewOperatorKey()) ;
 
         innerPlan1.add(project11) ;
         innerPlan1.add(const11) ;
@@ -941,14 +923,12 @@ public class TestTypeCheckingValidatorNoSchema  extends TestCase {
 
         // Create expression inner plan #2
         LogicalPlan innerPlan2 = new LogicalPlan() ;
-        LOProject project21 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 0) ;
+        LOProject project21 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 0) ;
         project21.setSentinel(true);
-        LOProject project22 = new LOProject(innerPlan1, genNewOperatorKey(), load1, 1) ;
+        LOProject project22 = new LOProject(innerPlan2, genNewOperatorKey(), load1, 1) ;
         project21.setSentinel(true);
-        LOAdd add21 = new LOAdd(innerPlan1,
-                                genNewOperatorKey(),
-                                project21,
-                                project22) ;
+        LOAdd add21 = new LOAdd(innerPlan2,
+                                genNewOperatorKey()) ;
 
         innerPlan2.add(project21) ;
         innerPlan2.add(project22) ;
