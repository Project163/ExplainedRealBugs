diff --git a/CHANGES.txt b/CHANGES.txt
index e1e347062..4150f1e52 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -24,6 +24,8 @@ INCOMPATIBLE CHANGES
 
 IMPROVEMENTS
 
+PIG-990:  Provide a way to pin LogicalOperator Options (dvryaboy via gates)
+
 PIG-1103: refactoring of commit tests (olgan)
 
 PIG-1101: Allow arugment to limit to be long in addition to int (ashutoshc via
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index e52e56dc2..fcc206b42 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -969,7 +969,7 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
             logToPhyMap.put(loj, smj);
             return;
         }
-		else if (loj.getJoinType() == LOJoin.JOINTYPE.REGULAR){
+		else if (loj.getJoinType() == LOJoin.JOINTYPE.HASH){
 	        POGlobalRearrange poGlobal = new POGlobalRearrange(new OperatorKey(
 	                scope, nodeGen.getNextNodeId(scope)), loj
 	                .getRequestedParallelism());
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index 30e35a07e..a0d145249 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -64,6 +64,11 @@ public class LOCogroup extends RelationalOperator {
     private MultiMap<LogicalOperator, LogicalPlan> mGroupByPlans;
     private GROUPTYPE mGroupType;
 
+    /** 
+     * static constant to refer to the option of selecting a group type
+     */
+    public final static Integer OPTION_GROUPTYPE = 1;
+
     /**
      * 
      * @param plan
diff --git a/src/org/apache/pig/impl/logicalLayer/LOJoin.java b/src/org/apache/pig/impl/logicalLayer/LOJoin.java
index 203697ad9..b43a02068 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOJoin.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOJoin.java
@@ -49,12 +49,13 @@ public class LOJoin extends RelationalOperator {
      * Enum for the type of join
      */
 	public static enum JOINTYPE {
-        REGULAR, // Regular join
+        HASH,    // Hash Join
         REPLICATED, // Fragment Replicated join
         SKEWED, // Skewed Join
         MERGE   // Sort Merge Join
     };
 
+    
     /**
      * LOJoin contains a list of logical operators corresponding to the
      * relational operators and a list of generates for each relational
@@ -66,7 +67,12 @@ public class LOJoin extends RelationalOperator {
     private boolean[] mInnerFlags;
 	private JOINTYPE mJoinType; // Retains the type of the join
 
-    /**
+	/** 
+	 * static constant to refer to the option of selecting a join type
+	 */
+	public final static Integer OPTION_JOIN = 1;
+	
+	/**
      * 
      * @param plan
      *            LogicalPlan this operator is a part of.
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
index 79df6352d..8c42981c4 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
@@ -19,6 +19,7 @@
 package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.io.IOException;
@@ -83,6 +84,13 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
      */
     protected boolean mIsProjectionMapComputed = false;
     
+    /**
+     * A HashSet to indicate whether an option (such a Join Type) was pinned
+     * by the user or can be chosen at runtime by the optimizer.
+     */
+    protected HashSet<Integer> mPinnedOptions = new HashSet<Integer>();
+
+    
     private static Log log = LogFactory.getLog(LogicalOperator.class);
 
     /**
@@ -218,6 +226,14 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
         mRequestedParallelism = newRequestedParallelism;
     }
 
+    public void pinOption(Integer opt) {
+        mPinnedOptions.add(opt);
+    }
+    
+    public boolean isPinnedOption(Integer opt) {
+        return mPinnedOptions.contains(opt);
+    }
+    
     @Override
     public String toString() {
         StringBuffer msg = new StringBuffer();
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index fa0958a9c..be6ce05a3 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -1476,10 +1476,10 @@ LogicalOperator LimitClause(LogicalPlan lp):
 {
         (
         input = NestedExpr(lp) {log.debug("Limit input: " + input);}
-       	 (
-       	    t = <INTEGER>     { l = Long.parseLong(t.image); }
+                (
+                   t = <INTEGER>     { l = Long.parseLong(t.image); }
           | t = <LONGINTEGER> { l = Long.parseLong(t.image.substring(0, t.image.length() - 1)); }
-         )
+                )
         )
         {
                 LogicalOperator limit = new LOLimit(lp, new OperatorKey(scope, getNextId()), l);
@@ -1748,6 +1748,11 @@ LogicalOperator CogroupClause(LogicalPlan lp) :
                     throw new ParseException("Collected group is only supported for columns or star projection");
                 }
                 cogroup = parseCogroup(gis, lp, LOCogroup.GROUPTYPE.COLLECTED);
+                cogroup.pinOption(LOCogroup.OPTION_GROUPTYPE);
+                }
+                |"\"regular\"" {
+                    cogroup = parseCogroup(gis, lp, LOCogroup.GROUPTYPE.REGULAR);
+                    cogroup.pinOption(LOCogroup.OPTION_GROUPTYPE);
                 }
                 )
             ]                                                                        
@@ -2044,9 +2049,7 @@ LogicalOperator JoinClause(LogicalPlan lp) :
 	ArrayList<CogroupInput> gis = new ArrayList<CogroupInput>(); 
 	log.trace("Entering JoinClause");
 	log.debug("LogicalPlan: " + lp);
-	LogicalOperator frj = null;
-	LogicalOperator skj = null;
-	LogicalOperator smj = null;
+	LogicalOperator joinOp = null;
 	boolean isLeftOuter = false;
 	boolean isRightOuter = false;
 	boolean isFullOuter = false;
@@ -2104,39 +2107,45 @@ LogicalOperator JoinClause(LogicalPlan lp) :
 	          if(isFullOuter || isRightOuter) {
 	              throw new ParseException("Replicated join does not support (right|full) outer joins");
 	          }
-				    frj = parseJoin(gis, lp, LOJoin.JOINTYPE.REPLICATED); 
+				    joinOp = parseJoin(gis, lp, LOJoin.JOINTYPE.REPLICATED); 
+				    joinOp.pinOption(LOJoin.OPTION_JOIN); 
 			    }
-			| "\"repl\"" { 
-				    if(isFullOuter || isRightOuter) {
+			| "\"repl\"" {
+                  if(isFullOuter || isRightOuter) {
 	                    throw new ParseException("Replicated join does not support (right|full) outer joins");
 	          }
-				    frj=parseJoin(gis, lp, LOJoin.JOINTYPE.REPLICATED);
-				}
+				    joinOp = parseJoin(gis, lp, LOJoin.JOINTYPE.REPLICATED);
+				    joinOp.pinOption(LOJoin.OPTION_JOIN);
+                  }
 		    |"\"skewed\"" {
-		    	    skj = parseJoin(gis, lp, LOJoin.JOINTYPE.SKEWED); 
+		    	    joinOp = parseJoin(gis, lp, LOJoin.JOINTYPE.SKEWED);
+		    	    joinOp.pinOption(LOJoin.OPTION_JOIN);
 		    	}
 		    |"\"merge\"" { 
 		    	    if(isOuter) {
                         throw new ParseException("Merge join does not support (left|right|full) outer joins");
                     }
-		    	    smj = parseJoin(gis, lp, LOJoin.JOINTYPE.MERGE); 
+		    	    joinOp = parseJoin(gis, lp, LOJoin.JOINTYPE.MERGE);
+		    	    joinOp.pinOption(LOJoin.OPTION_JOIN); 
+		    	}
+		    |"\"hash\"" {
+		    		joinOp = parseJoin(gis, lp, LOJoin.JOINTYPE.HASH);
+		    		joinOp.pinOption(LOJoin.OPTION_JOIN);
+		    	}
+		    |"\"default\"" {
+		    		joinOp = parseJoin(gis, lp, LOJoin.JOINTYPE.HASH);
+		    		joinOp.pinOption(LOJoin.OPTION_JOIN);
 		    	})
 	    ] 
     )
     )
 
 	{log.trace("Exiting JoinClause");
-	if (frj!=null) {
-		return frj;
-	}
-	else if (skj!=null) {
-		return skj;
+	if (joinOp!=null) {
+		return joinOp;
 	}
-	else if (smj!=null) {
-        return smj;
-    }
 	else {
-		return parseJoin(gis, lp, LOJoin.JOINTYPE.REGULAR);
+		return parseJoin(gis, lp, LOJoin.JOINTYPE.HASH);
 	}}
 	
 }
diff --git a/test/org/apache/pig/test/TestPinOptions.java b/test/org/apache/pig/test/TestPinOptions.java
new file mode 100644
index 000000000..fffc1286b
--- /dev/null
+++ b/test/org/apache/pig/test/TestPinOptions.java
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.test;
+
+import java.io.IOException;
+
+import org.apache.pig.PigServer;
+import org.apache.pig.impl.logicalLayer.LOCogroup;
+import org.apache.pig.impl.logicalLayer.LOJoin;
+import org.apache.pig.impl.logicalLayer.LogicalOperator;
+import org.apache.pig.impl.logicalLayer.LOJoin;
+import org.apache.pig.impl.logicalLayer.LogicalPlan;
+import org.apache.pig.test.utils.*;
+import org.junit.Before;
+import org.junit.Test;
+import static org.apache.pig.ExecType.LOCAL;
+
+import junit.framework.TestCase;
+
+public class TestPinOptions extends TestCase {
+
+    protected PigServer pigServer;
+    @Before
+    @Override
+    protected void setUp() throws Exception {
+        pigServer = new PigServer(LOCAL);
+    }
+        
+    @Test
+    public void testPinnedJoinOption() throws IOException {
+        String[] joinTypes = {"hash", "repl", "merge", "skewed", "default"};
+        String[] expectedJoinTypes = {"HASH", "REPLICATED", "MERGE", "SKEWED", "HASH"};
+        for (int i = 0; i < joinTypes.length; i++) {
+            pigServer.setBatchOn();
+            pigServer.registerQuery("a = load '/tmp' as (foo, bar);");
+            pigServer.registerQuery("b = load '/tmp' as (foo, bar);");
+            pigServer.registerQuery("c = join a by foo, b by foo using \""+joinTypes[i]+"\";");
+            LogicalOperator op = getOpByAlias(pigServer.getAliases().get("c"), "c");
+            assertTrue("did "+joinTypes[i]+" join get pinned? ", 
+                    op.isPinnedOption(LOJoin.OPTION_JOIN));
+            assertEquals("did the right join type get set? ",
+                    ((LOJoin) op).getJoinType().toString(), expectedJoinTypes[i]);
+            pigServer.discardBatch();
+        }
+    }
+    
+    @Test
+    public void testNotPinnedJinOption() throws IOException {
+        pigServer.registerQuery("a = load '/tmp' as (foo, bar);");
+        pigServer.registerQuery("b = load '/tmp' as (foo, bar);");
+        pigServer.registerQuery("c = join a by foo, b by foo;");
+        LogicalOperator op = getOpByAlias(pigServer.getAliases().get("c"), "c");
+        assertEquals("default join should be hash", 
+                ((LOJoin) op).getJoinType().toString(), "HASH");
+        assertFalse(op.isPinnedOption(LOJoin.OPTION_JOIN));
+    }
+    
+    @Test
+    public void testGroupOptions() throws IOException {
+        pigServer.setBatchOn();
+        pigServer.registerQuery("a = load '/tmp' as (foo, bar);");
+        pigServer.registerQuery("b = group a by foo;");
+        
+        LogicalOperator op = getOpByAlias(pigServer.getAliases().get("b"), "b");
+        assertFalse(op.isPinnedOption(LOCogroup.OPTION_GROUPTYPE));
+        pigServer.discardBatch();
+        
+        pigServer.setBatchOn();
+        pigServer.registerQuery("a = load '/tmp' as (foo, bar);");
+        pigServer.registerQuery("b = group a by foo using \"collected\";");
+        op = getOpByAlias(pigServer.getAliases().get("b"), "b");
+        assertTrue(op.isPinnedOption(LOCogroup.OPTION_GROUPTYPE));
+        pigServer.discardBatch();
+    }
+    
+    private LogicalOperator getOpByAlias(LogicalPlan lp, String alias) {
+        for (LogicalOperator op : lp) {
+            if (op.getAlias().equals(alias)) return op;
+        }
+        return null;
+    }
+    
+}
