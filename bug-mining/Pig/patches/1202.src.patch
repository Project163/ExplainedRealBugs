diff --git a/CHANGES.txt b/CHANGES.txt
index cd4efd47e..8689bc36a 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -186,6 +186,8 @@ PIG-3013: BinInterSedes improve chararray sort performance (rohini)
 
 BUG FIXES
 
+PIG-3313: pig job hang if the job tracker is bounced during execution (yu.chenjie via daijy)
+
 PIG-3297: Avro files with stringType set to String cannot be read by the AvroStorage LoadFunc (nielsbasjes via cheolsoo)
 
 PIG-3069: Native Windows Compatibility for Pig E2E Tests and Harness (anthony.murphy via daijy)
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
index 30d50fb94..f06b90a23 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
@@ -282,113 +282,120 @@ public class MapReduceLauncher extends Launcher{
             //All the setup done, now lets launch the jobs.
             jcThread.start();
             
-            // a flag whether to warn failure during the loop below, so users can notice failure earlier.
-            boolean warn_failure = true;
-            
-            // Now wait, till we are finished.
-            while(!jc.allFinished()){
-
-              try { jcThread.join(sleepTime); }
-            	catch (InterruptedException e) {}
-
-            	List<Job> jobsAssignedIdInThisRun = new ArrayList<Job>();
-
-            	for(Job job : jobsWithoutIds){
-            		if (job.getAssignedJobID() != null){
-
-            			jobsAssignedIdInThisRun.add(job);
-            			log.info("HadoopJobId: "+job.getAssignedJobID());
-            			
-                        // display the aliases being processed
-                        MapReduceOper mro = jcc.getJobMroMap().get(job);
-                        if (mro != null) {
-                            String alias = ScriptState.get().getAlias(mro);
-                            log.info("Processing aliases " + alias);
-                            String aliasLocation = ScriptState.get().getAliasLocation(mro);
-                            log.info("detailed locations: " + aliasLocation);
-                        }
-
-                        
-            			if(jobTrackerLoc != null){
-            				log.info("More information at: http://"+ jobTrackerLoc+
-            						"/jobdetails.jsp?jobid="+job.getAssignedJobID());
-            			}  
-
-                        // update statistics for this job so jobId is set
-                        PigStatsUtil.addJobStats(job);
-            			ScriptState.get().emitJobStartedNotification(
-                                job.getAssignedJobID().toString());                        
-            		}
-            		else{
-            			// This job is not assigned an id yet.
-            		}
-            	}
-            	jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
-
-            	double prog = (numMRJobsCompl+calculateProgress(jc, jobClient))/totalMRJobs;
-            	if (notifyProgress(prog, lastProg)) {
-                    lastProg = prog;
-                }
-
-            	// collect job stats by frequently polling of completed jobs (PIG-1829)
-            	PigStatsUtil.accumulateStats(jc);
-            	
-                // if stop_on_failure is enabled, we need to stop immediately when any job has failed
-                checkStopOnFailure(stop_on_failure);
-                // otherwise, we just display a warning message if there's any failure
-                if (warn_failure && !jc.getFailedJobs().isEmpty()) {
-                    // we don't warn again for this group of jobs
-                    warn_failure = false;
-                    log.warn("Ooops! Some job has failed! Specify -stop_on_failure if you "
-                            + "want Pig to stop immediately on failure.");
+            try {
+                // a flag whether to warn failure during the loop below, so users can notice failure earlier.
+                boolean warn_failure = true;
+                
+                // Now wait, till we are finished.
+                while(!jc.allFinished()){
+    
+                  try { jcThread.join(sleepTime); }
+                	catch (InterruptedException e) {}
+    
+                	List<Job> jobsAssignedIdInThisRun = new ArrayList<Job>();
+    
+                	for(Job job : jobsWithoutIds){
+                		if (job.getAssignedJobID() != null){
+    
+                			jobsAssignedIdInThisRun.add(job);
+                			log.info("HadoopJobId: "+job.getAssignedJobID());
+                			
+                            // display the aliases being processed
+                            MapReduceOper mro = jcc.getJobMroMap().get(job);
+                            if (mro != null) {
+                                String alias = ScriptState.get().getAlias(mro);
+                                log.info("Processing aliases " + alias);
+                                String aliasLocation = ScriptState.get().getAliasLocation(mro);
+                                log.info("detailed locations: " + aliasLocation);
+                            }
+    
+                            
+                			if(jobTrackerLoc != null){
+                				log.info("More information at: http://"+ jobTrackerLoc+
+                						"/jobdetails.jsp?jobid="+job.getAssignedJobID());
+                			}  
+    
+                            // update statistics for this job so jobId is set
+                            PigStatsUtil.addJobStats(job);
+                			ScriptState.get().emitJobStartedNotification(
+                                    job.getAssignedJobID().toString());                        
+                		}
+                		else{
+                			// This job is not assigned an id yet.
+                		}
+                	}
+                	jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
+    
+                	double prog = (numMRJobsCompl+calculateProgress(jc, jobClient))/totalMRJobs;
+                	if (notifyProgress(prog, lastProg)) {
+                        lastProg = prog;
+                    }
+    
+                	// collect job stats by frequently polling of completed jobs (PIG-1829)
+                	PigStatsUtil.accumulateStats(jc);
+                	
+                    // if stop_on_failure is enabled, we need to stop immediately when any job has failed
+                    checkStopOnFailure(stop_on_failure);
+                    // otherwise, we just display a warning message if there's any failure
+                    if (warn_failure && !jc.getFailedJobs().isEmpty()) {
+                        // we don't warn again for this group of jobs
+                        warn_failure = false;
+                        log.warn("Ooops! Some job has failed! Specify -stop_on_failure if you "
+                                + "want Pig to stop immediately on failure.");
+                    }
                 }
-            }
-            
-            //check for the jobControlException first
-            //if the job controller fails before launching the jobs then there are
-            //no jobs to check for failure
-            if (jobControlException != null) {
-                if (jobControlException instanceof PigException) {
-                    if (jobControlExceptionStackTrace != null) {
-                        LogUtils.writeLog("Error message from job controller",
-                                jobControlExceptionStackTrace, pc
-                                        .getProperties().getProperty(
-                                                "pig.logfile"), log);
+                
+                //check for the jobControlException first
+                //if the job controller fails before launching the jobs then there are
+                //no jobs to check for failure
+                if (jobControlException != null) {
+                    if (jobControlException instanceof PigException) {
+                        if (jobControlExceptionStackTrace != null) {
+                            LogUtils.writeLog("Error message from job controller",
+                                    jobControlExceptionStackTrace, pc
+                                            .getProperties().getProperty(
+                                                    "pig.logfile"), log);
+                        }
+                        throw jobControlException;
+                    } else {
+                        int errCode = 2117;
+                        String msg = "Unexpected error when launching map reduce job.";
+                        throw new ExecException(msg, errCode, PigException.BUG,
+                                jobControlException);
                     }
-                    throw jobControlException;
-                } else {
-                    int errCode = 2117;
-                    String msg = "Unexpected error when launching map reduce job.";
-                    throw new ExecException(msg, errCode, PigException.BUG,
-                            jobControlException);
                 }
-            }
-            
-            if (!jc.getFailedJobs().isEmpty() ) {
-                // stop if stop_on_failure is enabled
-                checkStopOnFailure(stop_on_failure);
                 
-                // If we only have one store and that job fail, then we sure 
-                // that the job completely fail, and we shall stop dependent jobs
-                for (Job job : jc.getFailedJobs()) {
-                    completeFailedJobsInThisRun.add(job);
-                    log.info("job " + job.getAssignedJobID() + " has failed! Stop running all dependent jobs"); 
+                if (!jc.getFailedJobs().isEmpty() ) {
+                    // stop if stop_on_failure is enabled
+                    checkStopOnFailure(stop_on_failure);
+                    
+                    // If we only have one store and that job fail, then we sure 
+                    // that the job completely fail, and we shall stop dependent jobs
+                    for (Job job : jc.getFailedJobs()) {
+                        completeFailedJobsInThisRun.add(job);
+                        log.info("job " + job.getAssignedJobID() + " has failed! Stop running all dependent jobs"); 
+                    }
+                    failedJobs.addAll(jc.getFailedJobs());
                 }
-                failedJobs.addAll(jc.getFailedJobs());
-            }
-            
-            int removedMROp = jcc.updateMROpPlan(completeFailedJobsInThisRun);
-            
-            numMRJobsCompl += removedMROp;
-
-            List<Job> jobs = jc.getSuccessfulJobs();
-            jcc.moveResults(jobs);
-            succJobs.addAll(jobs);
-                        
-            // collecting final statistics
-            PigStatsUtil.accumulateStats(jc);
-
-            jc.stop(); 
+                
+                int removedMROp = jcc.updateMROpPlan(completeFailedJobsInThisRun);
+                
+                numMRJobsCompl += removedMROp;
+    
+                List<Job> jobs = jc.getSuccessfulJobs();
+                jcc.moveResults(jobs);
+                succJobs.addAll(jobs);
+                            
+                // collecting final statistics
+                PigStatsUtil.accumulateStats(jc);
+
+        	}
+        	catch (Exception e) {
+        		throw e;
+        	}
+        	finally {
+            jc.stop();
+        	}
         }
 
         ScriptState.get().emitProgressUpdatedNotification(100);
