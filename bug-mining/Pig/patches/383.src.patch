diff --git a/CHANGES.txt b/CHANGES.txt
index 2f4807269..e5868da01 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -139,6 +139,8 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-1267: Problems with partition filter optimizer (rding)
+
 PIG-1079: Modify merge join to use distributed cache to maintain the index
 (rding)
 
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PartitionFilterOptimizer.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PartitionFilterOptimizer.java
index bcb6bb22b..fa970d36e 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/PartitionFilterOptimizer.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PartitionFilterOptimizer.java
@@ -19,10 +19,11 @@ package org.apache.pig.impl.logicalLayer.optimizer;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import org.apache.hadoop.mapreduce.Job;
 import org.apache.pig.Expression;
@@ -31,7 +32,6 @@ import org.apache.pig.LoadMetadata;
 import org.apache.pig.PigException;
 import org.apache.pig.Expression.BinaryExpression;
 import org.apache.pig.Expression.Column;
-import org.apache.pig.Expression.OpType;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOLoad;
@@ -69,9 +69,9 @@ public class PartitionFilterOptimizer extends
     private LOFilter loFilter;
     
     /**
-     * flag to ensure we only do the optimization once for performance reasons
+     * to ensure we only do the optimization once for performance reasons
      */
-    private boolean alreadyCalled = false;
+    private Set<LogicalOperator> alreadyChecked = new HashSet<LogicalOperator>();
     
     /**
      * a map between column names as reported in 
@@ -98,13 +98,6 @@ public class PartitionFilterOptimizer extends
     @Override
     public boolean check(List<LogicalOperator> nodes) throws OptimizerException 
     {
-        if(!alreadyCalled) {
-            // first call
-            alreadyCalled = true;
-        } else {
-            // already called, just return
-            return false; 
-        }
         if((nodes == null) || (nodes.size() <= 0)) {
             int errCode = 2052;
             String msg = "Internal error. Cannot retrieve operator from null " +
@@ -114,6 +107,9 @@ public class PartitionFilterOptimizer extends
         if(nodes.size() != 1|| !(nodes.get(0) instanceof LOLoad)) {
             return false;
         }
+        if (!alreadyChecked.add(nodes.get(0))) {
+            return false;
+        }
         loLoad = (LOLoad)nodes.get(0);
         List<LogicalOperator> sucs = mPlan.getSuccessors(loLoad);
         if(sucs == null || sucs.size() != 1 || !(sucs.get(0) instanceof LOFilter)) {
@@ -164,7 +160,7 @@ public class PartitionFilterOptimizer extends
                 updateMappedColNames(partitionFilter);
                 loadMetadata.setPartitionFilter(partitionFilter);
                 if(pColFilterFinder.isFilterRemovable()) {
-                    // remove this filter from the plan
+                    // remove this filter from the plan                  
                     mPlan.removeAndReconnect(loFilter);
                 }
             }
diff --git a/src/org/apache/pig/impl/plan/OperatorPlan.java b/src/org/apache/pig/impl/plan/OperatorPlan.java
index b86037eaa..9c6b3586d 100644
--- a/src/org/apache/pig/impl/plan/OperatorPlan.java
+++ b/src/org/apache/pig/impl/plan/OperatorPlan.java
@@ -669,7 +669,10 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
             pred = preds.get(0);
             disconnect(pred, node);
         }
-
+        
+        int oldPos = -1;
+        int newPos = -1;
+        
         List<E> succs = getSuccessors(node);
         E succ = null;
         if (succs != null) {
@@ -681,13 +684,51 @@ public abstract class OperatorPlan<E extends Operator> implements Iterable<E>, S
                 throw pe;
             }
             succ = succs.get(0);
+            List<E> plst = getPredecessors(succ);
+            for (int i=0; i<plst.size(); i++) {
+                if (plst.get(i).equals(node)) {
+                    oldPos = i;
+                }
+            }
             disconnect(node, succ);
         }
 
         remove(node);
         if (pred != null && succ != null) {
             connect(pred, succ);
-            succ.rewire(node, 0, pred, true);
+            List<E> plst = getPredecessors(succ);
+            for (int i=0; i<plst.size(); i++) {
+                if (plst.get(i).equals(pred)) {
+                    newPos = i;
+                }
+            }
+            
+            if (oldPos < 0 || newPos < 0) {
+                throw new PlanException("Invalid position index: " + oldPos                        
+                        + " : " + newPos);
+            }
+            
+            if (oldPos != newPos) {            
+                List<E> nlst = new ArrayList<E>();
+                for (int i=0; i<plst.size(); i++) {
+                    E nod = plst.get(i);
+                    if (i == oldPos) {
+                        nlst.add(pred);
+                    }
+                    if (i == newPos) continue;
+                    nlst.add(nod);
+                }
+                
+                if (nlst.size() != plst.size()) {
+                    throw new PlanException("Invalid list size: " + nlst.size()
+                            + " : " + plst.size());
+                }
+                         
+                mToEdges.removeKey(succ);
+                mToEdges.put(succ, nlst);
+            }
+            
+            succ.rewire(node, oldPos, pred, true);
         }
     }
 
diff --git a/test/org/apache/pig/test/TestPartitionFilterOptimization.java b/test/org/apache/pig/test/TestPartitionFilterOptimization.java
index 1e1a2f4ed..a96a4cb6e 100644
--- a/test/org/apache/pig/test/TestPartitionFilterOptimization.java
+++ b/test/org/apache/pig/test/TestPartitionFilterOptimization.java
@@ -45,6 +45,7 @@ import org.apache.pig.impl.logicalLayer.LOLoad;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
 import org.apache.pig.impl.logicalLayer.PColFilterExtractor;
+import org.apache.pig.impl.logicalLayer.PlanSetter;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.util.LogUtils;
@@ -420,6 +421,46 @@ public class TestPartitionFilterOptimization extends TestCase {
                 "((age >= 20) and (f3 == 15))", actual);
     }
     
+    /**
+     * Test PIG-1267
+     * @throws Exception
+     */
+    @Test
+    public void testColNameMapping5() throws Exception {
+        TestLoader.partFilter = null;
+        lpTester.buildPlan("a = load 'foo' using "
+            + TestLoader.class.getName() + 
+            "('mrkt:chararray, a1:chararray, a2:chararray, srcid:int, bcookie:chararray', " +
+            "'srcid');");
+        lpTester.buildPlan("b = load 'bar' using "
+                + TestLoader.class.getName() + 
+                "('dstid:int, b1:int, b2:int, srcid:int, bcookie:chararray, mrkt:chararray'," +
+                "'srcid');");
+        lpTester.buildPlan("a1 = filter a by srcid == 10;");
+        lpTester.buildPlan("b1 = filter b by srcid == 20;");
+        lpTester.buildPlan("c = join a1 by bcookie, b1 by bcookie;");
+        LogicalPlan lp = lpTester
+                .buildPlan("d = foreach c generate $4 as bcookie:chararray, " +
+                		"$5 as dstid:int, $0 as mrkt:chararray;");
+        
+        new PlanSetter(lp).visit();
+        
+        lpTester.typeCheckPlan(lp);
+        lpTester.optimizePlan(lp);
+ 
+        assertEquals("checking partition filter:",             
+                    "(srcid == 20)",
+                    TestLoader.partFilter.toString());
+        
+        int counter = 0;
+        Iterator<LogicalOperator> iter = lp.getKeys().values().iterator();
+        while (iter.hasNext()) {
+            assertTrue(!(iter.next() instanceof LOFilter));
+            counter++;
+        }      
+        assertEquals(counter, 6);
+    }
+    
     //// helper methods ///////
     
     private PColFilterExtractor test(LogicalPlan lp, List<String> partitionCols, 
