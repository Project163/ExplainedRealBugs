diff --git a/CHANGES.txt b/CHANGES.txt
index 28f8d4efc..952cd830e 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -120,6 +120,8 @@ PIG-1696: Performance: Use System.arraycopy() instead of manually copying the by
 
 BUG FIXES
 
+PIG-1927: Dereference partial name failed (daijy)
+
 PIG-1934: Fix zebra test TestCheckin1, TestCheckin4 (daijy)
 
 PIG-1931: Integrate Macro Expansion with New Parser (rding)
diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 4385f85c6..62ab49f33 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -1565,7 +1565,7 @@ public class PigServer {
                 int errCode = 1000;
                 String msg = "Error during parsing. "
                         + (pe == null ? ex.getMessage() : pe.getMessage());
-                throw new FrontendException (msg, errCode, PigException.INPUT );
+                throw new FrontendException (msg, errCode, PigException.INPUT , ex );
             }
         }
 
diff --git a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
index a29f45de0..d9d8f6acd 100644
--- a/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/DereferenceExpression.java
@@ -176,22 +176,17 @@ public class DereferenceExpression extends ColumnExpression {
         List<Integer> columns = new ArrayList<Integer>();
         for( Object rawColumn : rawColumns ) {
             if( rawColumn instanceof Integer ) {
-            	// TODO: need to check bound.
+            	if ((Integer)rawColumn>=schema.size() || (Integer)rawColumn<0) {
+            	    throw new FrontendException("Index "+rawColumn + " out of range in schema:" + schema.toString(false), 1127);
+            	}
                 columns.add( (Integer)rawColumn );
             } else {
-            	boolean found = false;
-            	
-                for( int i = 0; i < schema.size(); i++ ) {
-                    LogicalSchema.LogicalFieldSchema fs = schema.getField( i );
-                    if( fs.alias != null && fs.alias.equals( rawColumn ) ) {
-                        columns.add( i );
-                        found = true;
-                        break;
-                    }
-                }
-                
-                if( !found ) {
-                    throw new FrontendException("Cannot find field " + rawColumn + " in " + schema);
+                int pos = schema.getFieldPosition((String)rawColumn);
+                if( pos != -1) {
+                    columns.add( pos );
+                    continue;
+                } else {
+                    throw new FrontendException("Cannot find field " + rawColumn + " in " + schema.toString(false), 1128);
                 }
             }
         }
diff --git a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
index 9ef66f1f7..7c1a92ba5 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
@@ -92,24 +92,28 @@ public class LogicalSchema {
             if (verbose)
                 uidString="#" + uid;
             
+            String aliasToPrint = "";
+            if (alias!=null)
+                aliasToPrint = alias;
+            
             if( type == DataType.BAG ) {
                 if( schema == null ) {
-                    return ( alias + uidString + ":bag{}" );
+                    return ( aliasToPrint + uidString + ":bag{}" );
                 }
-                return ( alias + uidString + ":bag{" + schema.toString(verbose) + "}" );
+                return ( aliasToPrint + uidString + ":bag{" + schema.toString(verbose) + "}" );
             } else if( type == DataType.TUPLE ) {
                 if( schema == null ) {
-                    return ( alias + uidString + ":tuple{}" );
+                    return ( aliasToPrint + uidString + ":tuple{}" );
                 }
-                return ( alias + uidString + ":tuple(" + schema.toString(verbose) + ")" );
+                return ( aliasToPrint + uidString + ":tuple(" + schema.toString(verbose) + ")" );
             } else if (type == DataType.MAP) {
                 if (schema == null ) {
-                    return (alias + uidString + ":map");
+                    return (aliasToPrint + uidString + ":map");
                 } else {
-                    return (alias + uidString + ":map(" + schema.toString(verbose) + ")");
+                    return (aliasToPrint + uidString + ":map(" + schema.toString(verbose) + ")");
                 }
             }
-            return ( alias + uidString + ":" + DataType.findTypeName(type) );
+            return ( aliasToPrint + uidString + ":" + DataType.findTypeName(type) );
         }
         
         public String toString() {
diff --git a/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java b/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java
index 39c001fee..ddae1b7af 100644
--- a/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/ColumnAliasConversionVisitor.java
@@ -64,14 +64,14 @@ public class ColumnAliasConversionVisitor extends AllExpressionVisitor {
                     int colNum = inputSchema == null ? -1 : inputSchema.getFieldPosition( alias );
                     if( colNum == -1 ) {
                 		throw new PlanValidationException( "Invalid field projection. Projected field [" + 
-                    		alias + "] does not exist in schema: " + inputSchema + ".", 1025 );
+                    		alias + "] does not exist in schema: " + (inputSchema!=null?inputSchema.toString(false):"") + ".", 1025 );
                     }
                     expr.setColNum( colNum );
                 } else {
                     int col = expr.getColNum();
                     if( inputSchema != null && col >= inputSchema.size() ) {
                         throw new PlanValidationException( "Out of bound access. Trying to access non-existent column: " + 
-                                                      col + ". Schema " + inputSchema + " has " + inputSchema.size() + " column(s)." , 1000);
+                                                      col + ". Schema " + inputSchema.toString(false) + " has " + inputSchema.size() + " column(s)." , 1000);
                     }
                 }
             }
@@ -105,14 +105,14 @@ public class ColumnAliasConversionVisitor extends AllExpressionVisitor {
                     	col = (Integer)rc;
                     	if( schema != null && col >= schema.size() ) {
                             throw new PlanValidationException( "Out of bound access. Trying to access non-existent column: " + 
-                                    col + ". Schema " + schema + " has " + schema.size() + " column(s).", 1000 );
+                                    col + ". Schema " + schema.toString(false) + " has " + schema.size() + " column(s).", 1000 );
                     	}
                         cols.add( (Integer)rc );
                     } else {
                         col = schema == null ? -1 : schema.getFieldPosition( (String)rc );
                         if( col == -1 ) {
                             throw new PlanValidationException( "Invalid field reference. Referenced field [" + 
-                            		rc + "] does not exist in schema: " + schema + "." , 1000);
+                            		rc + "] does not exist in schema: " + (schema!=null?schema.toString(false):"") + "." , 1000);
                         }
                         cols.add( col );
                     }
diff --git a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
index 622007ffc..c1b9b2f11 100644
--- a/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
+++ b/src/org/apache/pig/newplan/logical/visitor/TypeCheckingExpVisitor.java
@@ -227,9 +227,9 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
         
         msg = msg + "incompatible types in " + binOp.getName() + " Operator"
         + " left hand side:" + DataType.findTypeName(lhsFs) 
-        + (lhsFs.schema == null ? "" : " " + lhsFs.schema + " ") 
+        + (lhsFs.schema == null ? "" : " " + lhsFs.schema.toString(false) + " ") 
         + " right hand side:" + DataType.findTypeName(rhsFs) 
-        + (rhsFs.schema == null ? "" : " " + rhsFs.schema + " ") ;
+        + (rhsFs.schema == null ? "" : " " + rhsFs.schema.toString(false) + " ") ;
         return msg;
     }
     
@@ -491,10 +491,10 @@ public class TypeCheckingExpVisitor extends LogicalExpressionVisitor{
             int errCode = 1052;
             String msg = "Cannot cast "
                            + DataType.findTypeName(inType)
-                           + ((DataType.isSchemaType(inType))? " with schema " + inFs : "")
+                           + ((DataType.isSchemaType(inType))? " with schema " + inFs.toString(false) : "")
                            + " to "
                            + DataType.findTypeName(outType)
-                           + ((DataType.isSchemaType(outType))? " with schema " + outFs: "");
+                           + ((DataType.isSchemaType(outType))? " with schema " + outFs.toString(false) : "");
             msgCollector.collect(msg, MessageType.Error) ;
             throw new TypeCheckerException(msg, errCode, PigException.INPUT) ; 
         }
diff --git a/test/org/apache/pig/test/TestEvalPipeline2.java b/test/org/apache/pig/test/TestEvalPipeline2.java
index 72290b1d9..a784968df 100644
--- a/test/org/apache/pig/test/TestEvalPipeline2.java
+++ b/test/org/apache/pig/test/TestEvalPipeline2.java
@@ -1401,4 +1401,19 @@ public class TestEvalPipeline2 {
         Assert.assertFalse(iter.hasNext());
         
     }
+    
+    // See PIG-1927
+    @Test
+    public void testDereferencePartialAlias() throws Exception{
+        
+        pigServer.registerQuery("a = load '1.txt' as (a0:int, a1);");
+        pigServer.registerQuery("b = group a by a0;");
+        pigServer.registerQuery("c = foreach b generate flatten(a);");
+        pigServer.registerQuery("d = cogroup c by (a0);");
+        pigServer.registerQuery("e = foreach d generate c.a0 as e0;");
+        pigServer.registerQuery("f = foreach e generate e0;");
+
+        // Shall not throw exception
+        pigServer.explain("f", System.out);
+    }
 }
diff --git a/test/org/apache/pig/test/TestUnionOnSchema.java b/test/org/apache/pig/test/TestUnionOnSchema.java
index c1e42d5aa..e6df98ecf 100644
--- a/test/org/apache/pig/test/TestUnionOnSchema.java
+++ b/test/org/apache/pig/test/TestUnionOnSchema.java
@@ -579,7 +579,7 @@ public class TestUnionOnSchema  {
     @Test
     public void testUnionOnSchemaNullAliasInFieldSchema() throws IOException, ParseException {
         String expectedErr = "Schema of relation f has a null fieldschema for " +
-        		"column(s). Schema :null:long,y:float";
+        		"column(s). Schema ::long,y:float";
         String query =
             "  l = load '" + INP_FILE_2NUMS + "' as (x : long, y : float);"
             + "f = foreach l generate x+1, y;"
