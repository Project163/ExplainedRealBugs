diff --git a/CHANGES.txt b/CHANGES.txt
index b80edc816..b47c59e73 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -161,3 +161,7 @@ Trunk (unreleased changes)
     PIG-378: fix for GENERATE + LIMIT
 
     PIG-362: don't push limit above generate with flatten
+
+    PIG-381: bincond does not handle null data
+
+    PIG-382: bincond throws typecast exception
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POBinCond.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POBinCond.java
index 72ff5174a..d45831aed 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POBinCond.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POBinCond.java
@@ -54,7 +54,7 @@ public class POBinCond extends ExpressionOperator {
     @Override
     public Result getNext(Boolean b) throws ExecException {
         Result res = cond.getNext(b);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(b) : rhs.getNext(b);
         
     }
@@ -62,63 +62,63 @@ public class POBinCond extends ExpressionOperator {
     @Override
     public Result getNext(DataBag db) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(db) : rhs.getNext(db);
     }
 
     @Override
     public Result getNext(DataByteArray ba) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(ba) : rhs.getNext(ba);
     }
 
     @Override
     public Result getNext(Double d) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(d) : rhs.getNext(d);
     }
 
     @Override
     public Result getNext(Float f) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(f) : rhs.getNext(f);
     }
 
     @Override
     public Result getNext(Integer i) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(i) : rhs.getNext(i);
     }
 
     @Override
     public Result getNext(Long l) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(l) : rhs.getNext(l);
     }
 
     @Override
     public Result getNext(Map m) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(m) : rhs.getNext(m);
     }
 
     @Override
     public Result getNext(String s) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(s) : rhs.getNext(s);
     }
 
     @Override
     public Result getNext(Tuple t) throws ExecException {
         Result res = cond.getNext(dummyBool);
-        if (res.returnStatus != POStatus.STATUS_OK) return res;
+        if (res.result==null || res.returnStatus != POStatus.STATUS_OK) return res;
         return ((Boolean)res.result) == true ? lhs.getNext(t) : rhs.getNext(t);
     }
 
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 0d08803e7..e2c9a71f0 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -1038,6 +1038,7 @@ ExpressionOperator PUnaryCond(Schema over, Map<String, LogicalOperator> specs, L
 		(lhs=InfixExpr(over,specs,lp,input) <MATCHES> t1=<QUOTEDSTRING> 
 			{
                 LOConst rconst = new LOConst(lp, new OperatorKey(scope, getNextId()), unquote(t1.image));
+                rconst.setType(DataType.CHARARRAY);
 				cond = new LORegexp(lp, new OperatorKey(scope, getNextId()), lhs, rconst); 
 				lp.add(rconst); 
 				lp.add(cond); 
diff --git a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
index 33b5e7262..c6f06b745 100644
--- a/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
+++ b/src/org/apache/pig/impl/logicalLayer/validators/TypeCheckingVisitor.java
@@ -1431,13 +1431,20 @@ public class TypeCheckingVisitor extends LOVisitor {
                 insertRightCastForBinCond(binCond, biggerType) ;
             }
             binCond.setType(biggerType) ;
-        }        
-        else if (lhsType != rhsType) {
-            String msg = "Two inputs of BinCond do not have compatible types" ;
-            msgCollector.collect(msg, MessageType.Error);
-            throw new VisitorException(msg) ;
+        } 
+        else if ((lhsType == DataType.BYTEARRAY)
+                && ((rhsType == DataType.CHARARRAY) || (DataType
+                        .isNumberType(rhsType)))) {
+            // Cast byte array to the type on rhs
+            insertLeftCastForBinCond(binCond, rhsType);
+            binCond.setType(DataType.mergeType(lhsType, rhsType));
+        } else if ((rhsType == DataType.BYTEARRAY)
+                && ((lhsType == DataType.CHARARRAY) || (DataType
+                        .isNumberType(lhsType)))) {
+            // Cast byte array to the type on lhs
+            insertRightCastForBinCond(binCond, lhsType);
+            binCond.setType(DataType.mergeType(lhsType, rhsType));
         }
-        
         // Matching schemas if we're working with tuples
         else if (lhsType == DataType.TUPLE) {            
             try {
@@ -1469,11 +1476,9 @@ public class TypeCheckingVisitor extends LOVisitor {
             }
             binCond.setType(DataType.TUPLE) ;
         }
-        else if (lhsType == DataType.BYTEARRAY) {   
-            binCond.setType(DataType.BYTEARRAY) ;
-        }
-        else if (lhsType == DataType.CHARARRAY) {   
-            binCond.setType(DataType.CHARARRAY) ;
+        
+        else if (lhsType == rhsType) {
+            binCond.setType(lhsType);
         }
         else {
             String msg = "Unsupported input type for BinCond" ;
