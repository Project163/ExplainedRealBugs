diff --git a/src/org/apache/pig/backend/hadoop/HDataType.java b/src/org/apache/pig/backend/hadoop/HDataType.java
index e1ed0fd0d..be1cbc9c0 100644
--- a/src/org/apache/pig/backend/hadoop/HDataType.java
+++ b/src/org/apache/pig/backend/hadoop/HDataType.java
@@ -33,51 +33,59 @@ import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.DataByteArray;
+import org.apache.pig.data.DefaultTupleFactory;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
+import org.apache.pig.impl.io.NullableBooleanWritable;
+import org.apache.pig.impl.io.NullableBytesWritable;
+import org.apache.pig.impl.io.NullableDoubleWritable;
+import org.apache.pig.impl.io.NullableFloatWritable;
+import org.apache.pig.impl.io.NullableIntWritable;
+import org.apache.pig.impl.io.NullableLongWritable;
+import org.apache.pig.impl.io.NullableText;
 
 /**
  * A class of helper methods for converting from pig data types to hadoop
  * data types, and vice versa.
  */
 public class HDataType {
-    static BooleanWritable boolWrit = new BooleanWritable();
-    static BytesWritable bytesWrit = new BytesWritable();
-    static Text stringWrit = new Text();
-    static FloatWritable floatWrit = new FloatWritable();
-    static DoubleWritable doubleWrit = new DoubleWritable();
-    static IntWritable intWrit = new IntWritable();
-    static LongWritable longWrit = new LongWritable();
+    static NullableBooleanWritable boolWrit = new NullableBooleanWritable();
+    static NullableBytesWritable bytesWrit = new NullableBytesWritable();
+    static NullableText stringWrit = new NullableText();
+    static NullableFloatWritable floatWrit = new NullableFloatWritable();
+    static NullableDoubleWritable doubleWrit = new NullableDoubleWritable();
+    static NullableIntWritable intWrit = new NullableIntWritable();
+    static NullableLongWritable longWrit = new NullableLongWritable();
     static DataBag defDB = BagFactory.getInstance().newDefaultBag();
     static Tuple defTup = TupleFactory.getInstance().newTuple();
     static Map<Byte, String> typeToName = null;
 
-    public static WritableComparable getWritableComparableTypes(Object o) throws ExecException{
+    public static WritableComparable getWritableComparableTypes(Object o, byte keyType) throws ExecException{
         byte type = DataType.findType(o);
         switch (type) {
         case DataType.BAG:
             return (DataBag)o;
 
         case DataType.BOOLEAN:
-            return new BooleanWritable((Boolean)o);
+            return new NullableBooleanWritable((Boolean)o);
 
         case DataType.BYTEARRAY:
-            return new BytesWritable(((DataByteArray)o).get());
+            return new NullableBytesWritable(((DataByteArray)o).get());
             
         case DataType.CHARARRAY:
-            return new Text((String)o);
+            return new NullableText((String)o);
             
         case DataType.DOUBLE:
-            return new DoubleWritable((Double)o);
+            return new NullableDoubleWritable((Double)o);
            
         case DataType.FLOAT:
-            return new FloatWritable((Float)o);
+            return new NullableFloatWritable((Float)o);
             
         case DataType.INTEGER:
-            return new IntWritable((Integer)o);
+            return new NullableIntWritable((Integer)o);
            
         case DataType.LONG:
-            return new LongWritable((Long)o);
+            return new NullableLongWritable((Long)o);
           
         case DataType.TUPLE:
             return (Tuple) o;
@@ -88,12 +96,59 @@ public class HDataType {
             // MapWritable
             // wcKey = new MapWritable();
 //            break;
+        case DataType.NULL:
+            switch (keyType) {
+            case DataType.BAG:
+                //TODO: create a null data bag
+                break;
+            case DataType.BOOLEAN:
+                NullableBooleanWritable nboolWrit = new NullableBooleanWritable();
+                nboolWrit.setNull(true);
+                return nboolWrit;
+            case DataType.BYTEARRAY:
+                NullableBytesWritable nBytesWrit = new NullableBytesWritable(); 
+                nBytesWrit.setNull(true);
+                return nBytesWrit;
+            case DataType.CHARARRAY:
+                NullableText nStringWrit = new NullableText();
+                nStringWrit.setNull(true);
+                return nStringWrit;
+            case DataType.DOUBLE:
+                NullableDoubleWritable nDoubleWrit = new NullableDoubleWritable();
+                nDoubleWrit.setNull(true);
+                return nDoubleWrit;
+            case DataType.FLOAT:
+                NullableFloatWritable nFloatWrit = new NullableFloatWritable();
+                nFloatWrit.setNull(true);
+                return nFloatWrit;
+            case DataType.INTEGER:
+                NullableIntWritable nIntWrit = new NullableIntWritable();
+                nIntWrit.setNull(true);
+                return nIntWrit;
+            case DataType.LONG:
+                NullableLongWritable nLongWrit = new NullableLongWritable();
+                nLongWrit.setNull(true);
+                return nLongWrit;
+            case DataType.TUPLE:
+                Tuple t = DefaultTupleFactory.getInstance().newTuple();
+                t.setNull(true);
+                return t;
+//            case DataType.MAP:
+                // Hmm, This is problematic
+                // Need a deep clone to convert a Map into
+                // MapWritable
+                // wcKey = new MapWritable();
+//                break;
+            }
+            break;
         default:
             if (typeToName == null) typeToName = DataType.genTypeToNameMap();
             throw new ExecException("The type "
                     + typeToName.get(type)
                     + " cannot be collected as a Key type");
         }
+        // should never come here
+        return null;
     }
     
     public static WritableComparable getWritableComparableTypes(byte type) throws ExecException{
@@ -142,24 +197,38 @@ public class HDataType {
     }
     
     public static Object convertToPigType(WritableComparable key) {
-        if ((key instanceof DataBag) || (key instanceof Tuple))
+        if ((key instanceof DataBag) )
             return key;
-        if (key instanceof BooleanWritable)
-            return ((BooleanWritable) key).get();
-        if (key instanceof BytesWritable) {
-            return new DataByteArray(((BytesWritable) key).get(), 0,
-                ((BytesWritable)key).getSize());
+        if(key instanceof Tuple)
+           return ((Tuple)key).isNull() ? null : key;     
+        if (key instanceof NullableBooleanWritable) {
+            NullableBooleanWritable bWrit = (NullableBooleanWritable)key;   
+            return bWrit.isNull() ? null :bWrit.get();
+        }
+        if (key instanceof NullableBytesWritable) {
+            NullableBytesWritable byWrit = (NullableBytesWritable) key; 
+            return byWrit.isNull() ? null : new DataByteArray(byWrit.get(), 0, byWrit.getSize());
+        }
+        if (key instanceof NullableText) {
+            NullableText tWrit =  (NullableText) key;
+            return tWrit.isNull() ? null :tWrit.toString();
+        }
+        if (key instanceof NullableFloatWritable) {
+            NullableFloatWritable fWrit = (NullableFloatWritable) key;
+            return fWrit == null ? null : fWrit.get();
+        }
+        if (key instanceof NullableDoubleWritable) {
+            NullableDoubleWritable dWrit = (NullableDoubleWritable) key;
+            return dWrit.isNull() ? null : dWrit.get();
+        }
+        if (key instanceof NullableIntWritable) {
+            NullableIntWritable iWrit = (NullableIntWritable) key;
+            return iWrit.isNull() ? null : iWrit.get();
+        }
+        if (key instanceof NullableLongWritable) {
+            NullableLongWritable lWrit = (NullableLongWritable) key;
+            return lWrit.isNull() ? null : lWrit.get();
         }
-        if (key instanceof Text)
-            return ((Text) key).toString();
-        if (key instanceof FloatWritable)
-            return ((FloatWritable) key).get();
-        if (key instanceof DoubleWritable)
-            return ((DoubleWritable) key).get();
-        if (key instanceof IntWritable)
-            return ((IntWritable) key).get();
-        if (key instanceof LongWritable)
-            return ((LongWritable) key).get();
         return null;
     }
 }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java
index db3bca83f..a3542ecc0 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/JobControlCompiler.java
@@ -248,6 +248,11 @@ public class JobControlCompiler{
             FileOutputFormat.setOutputPath(jobConf, new Path(outputPath));
             jobConf.set("pig.storeFunc", outputFuncSpec.toString());
             
+            // store map key type
+            // this is needed when the key is null to create
+            // an appropriate NullableXXXWritable object
+            jobConf.set("pig.map.keytype", ObjectSerializer.serialize(new byte[] { mro.mapKeyType }));
+            
             if(mro.reducePlan.isEmpty()){
                 //MapOnly Job
                 jobConf.setMapperClass(PigMapOnly.Map.class);
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/KeyTypeDiscoveryVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/KeyTypeDiscoveryVisitor.java
new file mode 100644
index 000000000..c71eddd8c
--- /dev/null
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/KeyTypeDiscoveryVisitor.java
@@ -0,0 +1,66 @@
+/**
+ * 
+ */
+package org.apache.pig.backend.hadoop.executionengine.mapReduceLayer;
+
+import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.plans.MROpPlanVisitor;
+import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.plans.MROperPlan;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhysicalPlan;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POLocalRearrange;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POPackage;
+import org.apache.pig.impl.plan.DepthFirstWalker;
+import org.apache.pig.impl.plan.PlanWalker;
+import org.apache.pig.impl.plan.VisitorException;
+
+/**
+ * A visitor to figure out the type of the key for the map plan
+ * this is needed when the key is null to create
+ * an appropriate NullableXXXWritable object
+ */
+public class KeyTypeDiscoveryVisitor extends MROpPlanVisitor {
+
+    
+    /* (non-Javadoc)
+     * @see org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor#visitLocalRearrange(org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POLocalRearrange)
+     */
+    /**
+     * @param plan The MROperPlan to visit to discover keyType
+     */
+    public KeyTypeDiscoveryVisitor(MROperPlan plan) {
+        super(plan, new DepthFirstWalker<MapReduceOper, MROperPlan>(plan));
+    }
+    
+    @Override
+    public void visitMROp(MapReduceOper mr) throws VisitorException {
+        PhyPlanKeyTypeVisitor kvisitor = new PhyPlanKeyTypeVisitor(mr.mapPlan, mr);
+        kvisitor.visit();
+    }
+    
+    class PhyPlanKeyTypeVisitor extends PhyPlanVisitor {
+        
+        private MapReduceOper mro;
+        
+        public PhyPlanKeyTypeVisitor(PhysicalPlan plan, MapReduceOper mro) {
+            super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
+            this.mro = mro;
+        }
+        
+        /* (non-Javadoc)
+         * @see org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor#visitPackage(org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POPackage)
+         */
+        @Override
+        public void visitPackage(POPackage pkg) throws VisitorException {
+            this.mro.mapKeyType = pkg.getKeyType();        
+        }
+    
+    
+        @Override
+        public void visitLocalRearrange(POLocalRearrange lr)
+                throws VisitorException {
+            this.mro.mapKeyType = lr.getKeyType();        
+        }
+    }
+
+}
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/LocalLauncher.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/LocalLauncher.java
index 9ec3174aa..a81effc52 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/LocalLauncher.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/LocalLauncher.java
@@ -111,6 +111,11 @@ public class LocalLauncher extends Launcher{
             CombinerOptimizer co = new CombinerOptimizer(plan);
             co.visit();
         }
+        // figure out the type of the key for the map plan
+        // this is needed when the key is null to create
+        // an appropriate NullableXXXWritable object
+        KeyTypeDiscoveryVisitor kdv = new KeyTypeDiscoveryVisitor(plan);
+        kdv.visit();
         return plan;
     }
 
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
index 84c3ed5e7..f63babc1e 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
@@ -128,6 +128,11 @@ public class MapReduceLauncher extends Launcher{
             CombinerOptimizer co = new CombinerOptimizer(plan);
             co.visit();
         }
+        // figure out the type of the key for the map plan
+        // this is needed when the key is null to create
+        // an appropriate NullableXXXWritable object
+        KeyTypeDiscoveryVisitor kdv = new KeyTypeDiscoveryVisitor(plan);
+        kdv.visit();     
         return plan;
     }
  
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
index e70e2a0de..f2f6f8eeb 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
@@ -53,6 +53,11 @@ public class MapReduceOper extends Operator<MROpPlanVisitor> {
     //by the optimizer.
     public PhysicalPlan combinePlan;
     
+    // key for the map plan
+    // this is needed when the key is null to create
+    // an appropriate NullableXXXWritable object
+    public byte mapKeyType;
+    
     //Indicates that the map plan creation
     //is complete
     boolean mapDone = false;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigCombiner.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigCombiner.java
index cd5c52ce4..cb60dea4f 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigCombiner.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigCombiner.java
@@ -45,7 +45,9 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.data.IndexedTuple;
 import org.apache.pig.data.TargetedTuple;
 import org.apache.pig.data.Tuple;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.ObjectSerializer;
+import org.apache.pig.impl.util.WrappedIOException;
 
 /**
  * This class is the static Mapper &amp; Reducer classes that
@@ -74,6 +76,8 @@ public class PigCombiner {
             implements
             Reducer<WritableComparable, IndexedTuple, WritableComparable, Writable> {
         private final Log log = LogFactory.getLog(getClass());
+
+        private byte keyType;
         
         //The reduce plan
         private PhysicalPlan cp;
@@ -107,6 +111,8 @@ public class PigCombiner {
                     cp.explain(baos);
                     log.debug(baos.toString());
                 }
+                
+                keyType = ((byte[])ObjectSerializer.deserialize(jConf.get("pig.map.keytype")))[0];
                 // till here
                 
                 long sleepTime = jConf.getLong("pig.reporter.sleep.time", 10000);
@@ -148,7 +154,7 @@ public class PigCombiner {
                     cp.attachInput(packRes);
 
                     List<PhysicalOperator> leaves = cp.getLeaves();
-                    
+
                     PhysicalOperator leaf = leaves.get(0);
                     while(true){
                         Result redRes = leaf.getNext(t);
@@ -157,7 +163,7 @@ public class PigCombiner {
                             Tuple tuple = (Tuple)redRes.result;
                             Object combKey = tuple.get(0);
                             IndexedTuple it = (IndexedTuple)tuple.get(1);
-                            WritableComparable wcKey = HDataType.getWritableComparableTypes(combKey);
+                            WritableComparable wcKey = HDataType.getWritableComparableTypes(combKey, this.keyType);
                             oc.collect(wcKey, it);
                             continue;
                         }
@@ -204,6 +210,20 @@ public class PigCombiner {
                 runnableReporter.setDone(true);*/
             PhysicalOperator.setReporter(null);
         }
+
+        /**
+         * @return the keyType
+         */
+        public byte getKeyType() {
+            return keyType;
+        }
+
+        /**
+         * @param keyType the keyType to set
+         */
+        public void setKeyType(byte keyType) {
+            this.keyType = keyType;
+        }
     }
     
 }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapBase.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapBase.java
index 13c71bab1..7e28e1400 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapBase.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapBase.java
@@ -17,17 +17,22 @@ import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.data.TargetedTuple;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhysicalPlan;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POLocalRearrange;
 import org.apache.pig.impl.util.ObjectSerializer;
 import org.apache.pig.impl.util.SpillableMemoryManager;
+import org.apache.pig.impl.util.WrappedIOException;
 
 public abstract class PigMapBase extends MapReduceBase{
     private final Log log = LogFactory.getLog(getClass());
+
+    protected byte keyType;
     
     //Map Plan
     protected PhysicalPlan mp;
@@ -68,6 +73,7 @@ public abstract class PigMapBase extends MapReduceBase{
                 mp.explain(baos);
                 log.debug(baos.toString());
             }
+            keyType = ((byte[])ObjectSerializer.deserialize(job.get("pig.map.keytype")))[0];
             // till here
             
             long sleepTime = job.getLong("pig.reporter.sleep.time", 10000);
@@ -115,8 +121,9 @@ public abstract class PigMapBase extends MapReduceBase{
         List<PhysicalOperator> leaves = mp.getLeaves();
         
         PhysicalOperator leaf = leaves.get(0);
+        
         try {
-            while(true){
+            while(true){                
                 Result res = leaf.getNext(inpTuple);
                 if(res.returnStatus==POStatus.STATUS_OK){
                     collect(oc,(Tuple)res.result);
@@ -143,5 +150,19 @@ public abstract class PigMapBase extends MapReduceBase{
     }
 
     abstract public void collect(OutputCollector<WritableComparable, Writable> oc, Tuple tuple) throws ExecException, IOException;
+
+    /**
+     * @return the keyType
+     */
+    public byte getKeyType() {
+        return keyType;
+    }
+
+    /**
+     * @param keyType the keyType to set
+     */
+    public void setKeyType(byte keyType) {
+        this.keyType = keyType;
+    }
     
 }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java
index 497cad005..a863143c5 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/PigMapReduce.java
@@ -79,7 +79,7 @@ public class PigMapReduce {
         public void collect(OutputCollector<WritableComparable, Writable> oc, Tuple tuple) throws ExecException, IOException {
             Object key = tuple.get(0);
             IndexedTuple it = (IndexedTuple)tuple.get(1);
-            WritableComparable wcKey = HDataType.getWritableComparableTypes(key);
+            WritableComparable wcKey = HDataType.getWritableComparableTypes(key, keyType);
             oc.collect(wcKey, it);
         }
     }
@@ -167,7 +167,6 @@ public class PigMapReduce {
                     PhysicalOperator leaf = leaves.get(0);
                     while(true){
                         Result redRes = leaf.getNext(t);
-                        
                         if(redRes.returnStatus==POStatus.STATUS_OK){
                             oc.collect(null, (Tuple)redRes.result);
                             continue;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
index eb9c77d98..2d54eaeb9 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/LogToPhyTranslationVisitor.java
@@ -37,6 +37,7 @@ import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOpe
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators.*;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators.ExpressionOperator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators.BinaryExpressionOperator;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators.UnaryExpressionOperator;
 import org.apache.pig.impl.logicalLayer.*;
 import org.apache.pig.impl.plan.DependencyOrderWalker;
 import org.apache.pig.impl.plan.DependencyOrderWalkerWOSeenChk;
@@ -935,8 +936,9 @@ public class LogToPhyTranslationVisitor extends LOVisitor {
     @Override
     public void visit(LOIsNull op) throws VisitorException {
         String scope = op.getOperatorKey().scope;
-        ExpressionOperator physOp = new POIsNull(new OperatorKey(scope, nodeGen
+        UnaryComparisonOperator physOp = new POIsNull(new OperatorKey(scope, nodeGen
                 .getNextNodeId(scope)), op.getRequestedParallelism(), null);
+        physOp.setOperandType(op.getOperand().getType());
         currentPlan.add(physOp);
 
         LogToPhyMap.put(op, physOp);
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/PhysicalOperator.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/PhysicalOperator.java
index adc39dd1a..05f8a4c3b 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/PhysicalOperator.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/PhysicalOperator.java
@@ -216,7 +216,7 @@ public abstract class PhysicalOperator extends Operator<PhyPlanVisitor> implemen
             return inputs.get(0).getNext(inpValue);
         } else {
             res.result = input;
-            res.returnStatus = POStatus.STATUS_OK;
+            res.returnStatus = (res.result == null ? POStatus.STATUS_NULL: POStatus.STATUS_OK);
             detachInput();
             return res;
         }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Add.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Add.java
index 210c6df03..3cea14d8a 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Add.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Add.java
@@ -58,14 +58,14 @@ public class Add extends BinaryExpressionOperator {
         Double left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Double) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Double) res.result;
@@ -81,14 +81,14 @@ public class Add extends BinaryExpressionOperator {
         Float left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Float) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Float) res.result;
@@ -104,14 +104,14 @@ public class Add extends BinaryExpressionOperator {
         Integer left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Integer) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Integer) res.result;
@@ -127,14 +127,14 @@ public class Add extends BinaryExpressionOperator {
         Long left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Long) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Long) res.result;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java
index 6ad5dd736..0a7e55adb 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java
@@ -58,14 +58,14 @@ public class Divide extends BinaryExpressionOperator {
         Double left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Double) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Double) res.result;
@@ -81,14 +81,14 @@ public class Divide extends BinaryExpressionOperator {
         Float left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Float) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Float) res.result;
@@ -104,14 +104,14 @@ public class Divide extends BinaryExpressionOperator {
         Integer left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Integer) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Integer) res.result;
@@ -127,14 +127,14 @@ public class Divide extends BinaryExpressionOperator {
         Long left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Long) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Long) res.result;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/EqualToExpr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/EqualToExpr.java
index 451e27fc3..9feb6befc 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/EqualToExpr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/EqualToExpr.java
@@ -110,6 +110,13 @@ public class EqualToExpr extends BinaryComparisonOperator {
         if (trueRef == null) initializeRefs();
         if (left.returnStatus != POStatus.STATUS_OK) return left;
         if (right.returnStatus != POStatus.STATUS_OK) return right;
+        // if either operand is null, the result should be
+        // null
+        if(left.result == null || right.result == null) {
+            left.result = null;
+            left.returnStatus = POStatus.STATUS_NULL;
+            return left;
+        }
         assert(left instanceof Comparable);
         assert(right instanceof Comparable);
         if (((Comparable)left.result).compareTo((Comparable)right.result) == 0) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GTOrEqualToExpr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GTOrEqualToExpr.java
index 3d3f065ef..2b1fbea35 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GTOrEqualToExpr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GTOrEqualToExpr.java
@@ -110,6 +110,13 @@ public class GTOrEqualToExpr extends BinaryComparisonOperator {
         if (trueRef == null) initializeRefs();
         if (left.returnStatus != POStatus.STATUS_OK) return left;
         if (right.returnStatus != POStatus.STATUS_OK) return right;
+        // if either operand is null, the result should be
+        // null
+        if(left.result == null || right.result == null) {
+            left.result = null;
+            left.returnStatus = POStatus.STATUS_NULL;
+            return left;
+        }
         assert(left instanceof Comparable);
         assert(right instanceof Comparable);
         if (((Comparable)left.result).compareTo((Comparable)right.result) >= 0) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GreaterThanExpr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GreaterThanExpr.java
index 3503fcdf3..0ad0c0d20 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GreaterThanExpr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/GreaterThanExpr.java
@@ -110,6 +110,13 @@ public class GreaterThanExpr extends BinaryComparisonOperator {
         if (trueRef == null) initializeRefs();
         if (left.returnStatus != POStatus.STATUS_OK) return left;
         if (right.returnStatus != POStatus.STATUS_OK) return right;
+        // if either operand is null, the result should be
+        // null
+        if(left.result == null || right.result == null) {
+            left.result = null;
+            left.returnStatus = POStatus.STATUS_NULL;
+            return left;
+        }
         assert(left instanceof Comparable);
         assert(right instanceof Comparable);
         if (((Comparable)left.result).compareTo((Comparable)right.result) > 0) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LTOrEqualToExpr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LTOrEqualToExpr.java
index 174cc3dca..9a54bd389 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LTOrEqualToExpr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LTOrEqualToExpr.java
@@ -110,6 +110,13 @@ public class LTOrEqualToExpr extends BinaryComparisonOperator {
         if (trueRef == null) initializeRefs();
         if (left.returnStatus != POStatus.STATUS_OK) return left;
         if (right.returnStatus != POStatus.STATUS_OK) return right;
+        // if either operand is null, the result should be
+        // null
+        if(left.result == null || right.result == null) {
+            left.result = null;
+            left.returnStatus = POStatus.STATUS_NULL;
+            return left;
+        }
         assert(left instanceof Comparable);
         assert(right instanceof Comparable);
         if (((Comparable)left.result).compareTo((Comparable)right.result) <= 0) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LessThanExpr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LessThanExpr.java
index ccb0960f5..1a228b428 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LessThanExpr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/LessThanExpr.java
@@ -110,6 +110,13 @@ public class LessThanExpr extends BinaryComparisonOperator {
         if (trueRef == null) initializeRefs();
         if (left.returnStatus != POStatus.STATUS_OK) return left;
         if (right.returnStatus != POStatus.STATUS_OK) return right;
+        // if either operand is null, the result should be
+        // null
+        if(left.result == null || right.result == null) {
+            left.result = null;
+            left.returnStatus = POStatus.STATUS_NULL;
+            return left;
+        }
         assert(left instanceof Comparable);
         assert(right instanceof Comparable);
         if (((Comparable)left.result).compareTo((Comparable)right.result) < 0) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Mod.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Mod.java
index 055762eca..c5de5bf2a 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Mod.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Mod.java
@@ -58,14 +58,14 @@ public class Mod extends BinaryExpressionOperator {
         Integer left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Integer) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Integer) res.result;
@@ -81,14 +81,14 @@ public class Mod extends BinaryExpressionOperator {
         Long left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Long) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Long) res.result;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Multiply.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Multiply.java
index aa7df9904..a61f323d4 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Multiply.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Multiply.java
@@ -58,14 +58,14 @@ public class Multiply extends BinaryExpressionOperator {
         Double left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Double) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Double) res.result;
@@ -81,14 +81,14 @@ public class Multiply extends BinaryExpressionOperator {
         Float left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Float) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Float) res.result;
@@ -104,14 +104,14 @@ public class Multiply extends BinaryExpressionOperator {
         Integer left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Integer) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Integer) res.result;
@@ -127,14 +127,14 @@ public class Multiply extends BinaryExpressionOperator {
         Long left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Long) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Long) res.result;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/NotEqualToExpr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/NotEqualToExpr.java
index b696f8300..c2118ef2b 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/NotEqualToExpr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/NotEqualToExpr.java
@@ -110,6 +110,13 @@ public class NotEqualToExpr extends BinaryComparisonOperator {
         if (trueRef == null) initializeRefs();
         if (left.returnStatus != POStatus.STATUS_OK) return left;
         if (right.returnStatus != POStatus.STATUS_OK) return right;
+        // if either operand is null, the result should be
+        // null
+        if(left.result == null || right.result == null) {
+            left.result = null;
+            left.returnStatus = POStatus.STATUS_NULL;
+            return left;
+        }
         assert(left instanceof Comparable);
         assert(right instanceof Comparable);
         if (((Comparable)left.result).compareTo((Comparable)right.result) != 0) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POAnd.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POAnd.java
index dd79a808b..5f81b8299 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POAnd.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POAnd.java
@@ -60,15 +60,22 @@ public class POAnd extends BinaryComparisonOperator {
     public Result getNext(Boolean b) throws ExecException {
         Result left;
         left = lhs.getNext(dummyBool);
-        if(left.returnStatus != POStatus.STATUS_OK) {
+        if(left.returnStatus != POStatus.STATUS_OK || left.result == null) {
             return left;
         }
-        // Short circuit.
+        
+        // Cannot short circuit since rhs could be null and then we should
+        // be returning null.
+        Result right = rhs.getNext(dummyBool);
+        if(right.returnStatus != POStatus.STATUS_OK || right.result == null) {
+        	return right;
+        }
+        
         if (!(((Boolean)left.result).booleanValue())) return left;
         
         // No matter what, what we get from the right side is what we'll
         // return, error, null, true, or false.
-        return rhs.getNext(dummyBool);
+        return right;
     }
 
     @Override
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
index e20574183..92f3b9993 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POCast.java
@@ -107,7 +107,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new Integer(Integer.valueOf((((DataByteArray)res.result).toString())));
         		dba = (DataByteArray) res.result;
         		try {
@@ -128,7 +128,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BOOLEAN : {
         	Boolean b = null;
         	Result res = in.getNext(b);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		if (((Boolean)res.result) == true) res.result = new Integer(1);
                 else res.result = new Integer(0);
         	}
@@ -143,7 +143,7 @@ public class POCast extends ExpressionOperator {
         case DataType.DOUBLE : {
         	Double d = null;
         	Result res = in.getNext(d);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = DataType.toInteger(res.result);
         		res.result = new Integer(((Double)res.result).intValue());
         	}
@@ -153,7 +153,7 @@ public class POCast extends ExpressionOperator {
         case DataType.LONG : {
         	Long l = null;
         	Result res = in.getNext(l);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Integer(((Long)res.result).intValue());
         	}
         	return res;
@@ -162,7 +162,7 @@ public class POCast extends ExpressionOperator {
         case DataType.FLOAT : {
         	Float f = null;
         	Result res = in.getNext(f);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Integer(((Float)res.result).intValue());
         	}
         	return res;
@@ -171,7 +171,7 @@ public class POCast extends ExpressionOperator {
         case DataType.CHARARRAY : {
         	String str = null;
         	Result res = in.getNext(str);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Integer(Integer.valueOf((String)res.result));
         	}
         	return res;
@@ -210,7 +210,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new Long(Long.valueOf((((DataByteArray)res.result).toString())));
         		dba = (DataByteArray) res.result;
         		try {
@@ -225,7 +225,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BOOLEAN : {
         	Boolean b = null;
         	Result res = in.getNext(b);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		if (((Boolean)res.result) == true) res.result = new Long(1);
                 else res.result = new Long(0);
         	}
@@ -234,7 +234,7 @@ public class POCast extends ExpressionOperator {
         case DataType.INTEGER : {
         	Integer dummyI = null;
         	Result res = in.getNext(dummyI);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Long(((Integer)res.result).longValue());
         	}
         	return res;
@@ -243,7 +243,7 @@ public class POCast extends ExpressionOperator {
         case DataType.DOUBLE : {
         	Double d = null;
         	Result res = in.getNext(d);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = DataType.toInteger(res.result);
         		res.result = new Long(((Double)res.result).longValue());
         	}
@@ -260,7 +260,7 @@ public class POCast extends ExpressionOperator {
         case DataType.FLOAT : {
         	Float f = null;
         	Result res = in.getNext(f);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Long(((Float)res.result).longValue());
         	}
         	return res;
@@ -269,7 +269,7 @@ public class POCast extends ExpressionOperator {
         case DataType.CHARARRAY : {
         	String str = null;
         	Result res = in.getNext(str);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Long(Long.valueOf((String)res.result));
         	}
         	return res;
@@ -308,7 +308,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new Double(Double.valueOf((((DataByteArray)res.result).toString())));
         		dba = (DataByteArray) res.result;
         		try {
@@ -323,7 +323,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BOOLEAN : {
         	Boolean b = null;
         	Result res = in.getNext(b);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		if (((Boolean)res.result) == true) res.result = new Double(1);
                 else res.result = new Double(0);
         	}
@@ -332,7 +332,7 @@ public class POCast extends ExpressionOperator {
         case DataType.INTEGER : {
         	Integer dummyI = null;
         	Result res = in.getNext(dummyI);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Double(((Integer)res.result).doubleValue());
         	}
         	return res;
@@ -348,7 +348,7 @@ public class POCast extends ExpressionOperator {
         case DataType.LONG : {
         	Long l = null;
         	Result res = in.getNext(l);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Double(((Long)res.result).doubleValue());
         	}
         	return res;
@@ -357,7 +357,7 @@ public class POCast extends ExpressionOperator {
         case DataType.FLOAT : {
         	Float f = null;
         	Result res = in.getNext(f);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Double(((Float)res.result).doubleValue());
         	}
         	return res;
@@ -366,7 +366,7 @@ public class POCast extends ExpressionOperator {
         case DataType.CHARARRAY : {
         	String str = null;
         	Result res = in.getNext(str);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Double(Double.valueOf((String)res.result));
         	}
         	return res;
@@ -405,7 +405,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new Float(Float.valueOf((((DataByteArray)res.result).toString())));
         		dba = (DataByteArray) res.result;
         		try {
@@ -420,7 +420,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BOOLEAN : {
         	Boolean b = null;
         	Result res = in.getNext(b);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		if (((Boolean)res.result) == true) res.result = new Float(1);
                 else res.result = new Float(0);
         	}
@@ -429,7 +429,7 @@ public class POCast extends ExpressionOperator {
         case DataType.INTEGER : {
         	Integer dummyI = null;
         	Result res = in.getNext(dummyI);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Float(((Integer)res.result).floatValue());
         	}
         	return res;
@@ -438,7 +438,7 @@ public class POCast extends ExpressionOperator {
         case DataType.DOUBLE : {
         	Double d = null;
         	Result res = in.getNext(d);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = DataType.toInteger(res.result);
         		res.result = new Float(((Double)res.result).floatValue());
         	}
@@ -449,7 +449,7 @@ public class POCast extends ExpressionOperator {
         	
         	Long l = null;
         	Result res = in.getNext(l);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Float(((Long)res.result).floatValue());
         	}
         	return res;
@@ -465,7 +465,7 @@ public class POCast extends ExpressionOperator {
         case DataType.CHARARRAY : {
         	String str = null;
         	Result res = in.getNext(str);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new Float(Float.valueOf((String)res.result));
         	}
         	return res;
@@ -504,7 +504,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new String(((DataByteArray)res.result).toString());
         		dba = (DataByteArray) res.result;
         		try {
@@ -519,7 +519,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BOOLEAN : {
         	Boolean b = null;
         	Result res = in.getNext(b);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		if (((Boolean)res.result) == true) res.result = new String("1");
                 else res.result = new String("1");
         	}
@@ -528,7 +528,7 @@ public class POCast extends ExpressionOperator {
         case DataType.INTEGER : {
         	Integer dummyI = null;
         	Result res = in.getNext(dummyI);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new String(((Integer)res.result).toString());
         	}
         	return res;
@@ -537,7 +537,7 @@ public class POCast extends ExpressionOperator {
         case DataType.DOUBLE : {
         	Double d = null;
         	Result res = in.getNext(d);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = DataType.toInteger(res.result);
         		res.result = new String(((Double)res.result).toString());
         	}
@@ -548,7 +548,7 @@ public class POCast extends ExpressionOperator {
         	
         	Long l = null;
         	Result res = in.getNext(l);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new String(((Long)res.result).toString());
         	}
         	return res;
@@ -557,7 +557,7 @@ public class POCast extends ExpressionOperator {
         case DataType.FLOAT : {
         	Float f = null;
         	Result res = in.getNext(f);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		res.result = new String(((Float)res.result).toString());
         	}
         	return res;
@@ -591,7 +591,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new String(((DataByteArray)res.result).toString());
         		dba = (DataByteArray) res.result;
         		try {
@@ -645,7 +645,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new String(((DataByteArray)res.result).toString());
         		dba = (DataByteArray) res.result;
         		try {
@@ -699,7 +699,7 @@ public class POCast extends ExpressionOperator {
         case DataType.BYTEARRAY : {
         	DataByteArray dba = null;
         	Result res = in.getNext(dba);
-        	if(res.returnStatus == POStatus.STATUS_OK) {
+        	if(res.returnStatus == POStatus.STATUS_OK && res.result != null) {
         		//res.result = new String(((DataByteArray)res.result).toString());
         		dba = (DataByteArray) res.result;
         		try {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POIsNull.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POIsNull.java
index 89f036a86..975e8e8c1 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POIsNull.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POIsNull.java
@@ -21,6 +21,7 @@ import java.util.Map;
 
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
+import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
 import org.apache.pig.data.DataBag;
@@ -60,133 +61,114 @@ public class POIsNull extends UnaryComparisonOperator {
     }
 
     @Override
-    public Result getNext(Double d) throws ExecException {
-        Result res = expr.getNext(d);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Double)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+    public Result getNext(Boolean b) throws ExecException {
+        
+        Result res = null;
+        switch(operandType) {
+        case DataType.BYTEARRAY:
+            res = expr.getNext(dummyDBA);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-
-    @Override
-    public Result getNext(Float f) throws ExecException {
-        Result res = expr.getNext(f);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Float)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.DOUBLE:
+            res = expr.getNext(dummyDouble);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-
-    @Override
-    public Result getNext(Integer i) throws ExecException {
-        Result res = expr.getNext(i);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Integer)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.INTEGER:
+            res = expr.getNext(dummyInt);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-
-    @Override
-    public Result getNext(Long l) throws ExecException {
-        Result res = expr.getNext(l);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Long)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.CHARARRAY:
+            res = expr.getNext(dummyString);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-    
-    @Override
-    public Result getNext(DataByteArray dba) throws ExecException {
-        Result res = expr.getNext(dba);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((DataByteArray)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.BOOLEAN:
+            res = expr.getNext(dummyBool);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-    
-    @Override
-    public Result getNext(String s) throws ExecException {
-        Result res = expr.getNext(s);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((String)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.LONG:
+            res = expr.getNext(dummyLong);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-    
-    @Override
-    public Result getNext(Boolean b) throws ExecException {
-        Result res = expr.getNext(b);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Boolean)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.FLOAT:
+            res = expr.getNext(dummyFloat);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-    
-    @Override
-    public Result getNext(Tuple t) throws ExecException {
-        Result res = expr.getNext(t);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Tuple)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.MAP:
+            res = expr.getNext(dummyMap);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-    
-    @Override
-    public Result getNext(DataBag b) throws ExecException {
-        Result res = expr.getNext(b);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((DataBag)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.TUPLE:
+            res = expr.getNext(dummyTuple);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
-        }
-        return res;
-    }
-    
-    @Override
-    public Result getNext(Map m) throws ExecException {
-        Result res = expr.getNext(m);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            if ((Map)res.result == null) {
-                res.result = true;
-            } else {
-                res.result = false;
+            return res;
+        case DataType.BAG:
+            res = expr.getNext(dummyBag);
+            if(res.returnStatus == POStatus.STATUS_OK) {
+                if (res.result == null) {
+                    res.result = true;
+                } else {
+                    res.result = false;
+                }
             }
+            return res;        
+        default:
+            throw new RuntimeException("'is null' to doesn't know how to " +
+                "handle type " + DataType.findTypeName(operandType));
         }
-        return res;
     }
 
     @Override
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONegative.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONegative.java
index b6c74f0e1..f30dc842f 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONegative.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONegative.java
@@ -57,16 +57,18 @@ public class PONegative extends UnaryExpressionOperator {
     @Override
     public Result getNext(Double d) throws ExecException {
         Result res = expr.getNext(d);
-        if(res.returnStatus == POStatus.STATUS_OK) {
-            res.result = -1*((Double)res.result);
-        }
+        if(res.returnStatus == POStatus.STATUS_OK && res.result!=null) {
+         		res.result = -1*((Double)res.result);
+
+       }
+       
         return res;
     }
 
     @Override
     public Result getNext(Float f) throws ExecException {
         Result res = expr.getNext(f);
-        if(res.returnStatus == POStatus.STATUS_OK) {
+        if(res.returnStatus == POStatus.STATUS_OK && res.result!=null ) {
             res.result = -1*((Float)res.result);
         }
         return res;
@@ -75,7 +77,7 @@ public class PONegative extends UnaryExpressionOperator {
     @Override
     public Result getNext(Integer i) throws ExecException {
         Result res = expr.getNext(i);
-        if(res.returnStatus == POStatus.STATUS_OK) {
+        if(res.returnStatus == POStatus.STATUS_OK && res.result!=null ) {
             res.result = -1*((Integer)res.result);
         }
         return res;
@@ -84,7 +86,7 @@ public class PONegative extends UnaryExpressionOperator {
     @Override
     public Result getNext(Long l) throws ExecException {
         Result res = expr.getNext(l);
-        if(res.returnStatus == POStatus.STATUS_OK) {
+        if(res.returnStatus == POStatus.STATUS_OK && res.result!=null) {
             res.result = -1*((Long)res.result);
         }
         return res;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONot.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONot.java
index bbf4ef168..241606a6d 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONot.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PONot.java
@@ -69,7 +69,7 @@ public class PONot extends UnaryComparisonOperator {
             falseRes.result = new Boolean(false);
         }
         res = expr.getNext(dummyBool);
-        if(res.returnStatus != POStatus.STATUS_OK) {
+        if(res.returnStatus != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         if (((Boolean)res.result).booleanValue()) return falseRes;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POOr.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POOr.java
index 5cb34d444..1df134ded 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POOr.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POOr.java
@@ -60,15 +60,22 @@ public class POOr extends BinaryComparisonOperator {
     public Result getNext(Boolean b) throws ExecException {
         Result left;
         left = lhs.getNext(dummyBool);
-        if(left.returnStatus != POStatus.STATUS_OK) {
+        if(left.returnStatus != POStatus.STATUS_OK || left.result == null) {
             return left;
         }
-        // Short circuit.
+        
+        // Cannot short circuit since rhs could be null and then we should
+        // be returning null.
+        Result right = rhs.getNext(dummyBool);
+        if(right.returnStatus != POStatus.STATUS_OK || right.result == null) {
+        	return right;
+        }
+        
         if (((Boolean)left.result).booleanValue()) return left;
         
         // No matter what, what we get from the right side is what we'll
         // return, error, null, true, or false.
-        return rhs.getNext(dummyBool);
+        return right;
     }
 
     @Override
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORegexp.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORegexp.java
index 3c5ed5e1c..128fede97 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORegexp.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/PORegexp.java
@@ -63,8 +63,8 @@ public class PORegexp extends BinaryComparisonOperator {
         right = rhs.getNext(dummyString);
 
         if (trueRef == null) initializeRefs();
-        if (left.returnStatus != POStatus.STATUS_OK) return left;
-        if (right.returnStatus != POStatus.STATUS_OK) return right;
+        if (left.returnStatus != POStatus.STATUS_OK || left.result == null) return left;
+        if (right.returnStatus != POStatus.STATUS_OK || right.result == null) return right;
         if (((String)left.result).matches((String)right.result)) {
             left.result = trueRef;
         } else {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java
index ab5205ab1..fb8f84cfa 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/POUserFunc.java
@@ -171,7 +171,7 @@ public class POUserFunc extends ExpressionOperator {
 			if(result.returnStatus == POStatus.STATUS_OK) {
 				result.result = func.exec((Tuple) result.result);
                 if(resultType == DataType.BYTEARRAY) {
-                    if(DataType.findType(result.result) != DataType.BYTEARRAY) {
+                    if(res.result != null && DataType.findType(result.result) != DataType.BYTEARRAY) {
                         result.result = new DataByteArray(result.result.toString().getBytes());
                     }
                 }
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Subtract.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Subtract.java
index 53d2fe721..b236164e6 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Subtract.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Subtract.java
@@ -58,14 +58,14 @@ public class Subtract extends BinaryExpressionOperator {
         Double left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Double) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Double) res.result;
@@ -81,14 +81,14 @@ public class Subtract extends BinaryExpressionOperator {
         Float left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Float) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Float) res.result;
@@ -104,14 +104,14 @@ public class Subtract extends BinaryExpressionOperator {
         Integer left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Integer) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Integer) res.result;
@@ -127,14 +127,14 @@ public class Subtract extends BinaryExpressionOperator {
         Long left = null, right = null;
         res = lhs.getNext(left);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         left = (Long) res.result;
         
         res = rhs.getNext(right);
         status = res.returnStatus;
-        if(status != POStatus.STATUS_OK) {
+        if(status != POStatus.STATUS_OK || res.result == null) {
             return res;
         }
         right = (Long) res.result;
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java
index 4513398a7..86ddc2945 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/relationalOperators/POFilter.java
@@ -143,9 +143,11 @@ public class POFilter extends PhysicalOperator {
             }
             */
             res = comOp.getNext(dummyBool);
-            if (res.returnStatus != POStatus.STATUS_OK) return res;
+            if (res.returnStatus != POStatus.STATUS_OK 
+                    && res.returnStatus != POStatus.STATUS_NULL) 
+                return res;
 
-            if ((Boolean) res.result == true) {
+            if (res.result != null && (Boolean) res.result == true) {
                 return inp;
             }
         }
diff --git a/src/org/apache/pig/builtin/Utf8StorageConverter.java b/src/org/apache/pig/builtin/Utf8StorageConverter.java
index 5619179e5..c38aefc1c 100644
--- a/src/org/apache/pig/builtin/Utf8StorageConverter.java
+++ b/src/org/apache/pig/builtin/Utf8StorageConverter.java
@@ -71,6 +71,8 @@ abstract public class Utf8StorageConverter {
     }
 
     public DataBag bytesToBag(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         Object o;
         try {
             o = parseFromBytes(b);
@@ -81,10 +83,14 @@ abstract public class Utf8StorageConverter {
     }
 
     public String bytesToCharArray(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         return new String(b);
     }
 
     public Double bytesToDouble(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         try {
             return Double.valueOf(new String(b));
         } catch (NumberFormatException nfe) {
@@ -96,6 +102,8 @@ abstract public class Utf8StorageConverter {
     }
 
     public Float bytesToFloat(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         try {
             return Float.valueOf(new String(b));
         } catch (NumberFormatException nfe) {
@@ -107,6 +115,8 @@ abstract public class Utf8StorageConverter {
     }
 
     public Integer bytesToInteger(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         String s = new String(b);
         try {
             return Integer.valueOf(s);
@@ -133,6 +143,8 @@ abstract public class Utf8StorageConverter {
     }
 
     public Long bytesToLong(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         String s = new String(b);
         try {
             return Long.valueOf(s);
@@ -159,6 +171,8 @@ abstract public class Utf8StorageConverter {
     }
 
     public Map<Object, Object> bytesToMap(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         Object o;
         try {
             o = parseFromBytes(b);
@@ -169,6 +183,8 @@ abstract public class Utf8StorageConverter {
     }
 
     public Tuple bytesToTuple(byte[] b) throws IOException {
+        if(b == null)
+            return null;
         Object o;
         try {
             o = parseFromBytes(b);
diff --git a/src/org/apache/pig/data/DataReaderWriter.java b/src/org/apache/pig/data/DataReaderWriter.java
index 3157de2b3..b29d41d35 100644
--- a/src/org/apache/pig/data/DataReaderWriter.java
+++ b/src/org/apache/pig/data/DataReaderWriter.java
@@ -24,6 +24,8 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pig.backend.executionengine.ExecException;
 
 /**
@@ -39,6 +41,12 @@ public class DataReaderWriter {
         byte b = in.readByte();
         switch (b) {
             case DataType.TUPLE: {
+                
+                // check if it is a null tuple
+                byte nullMarker = in.readByte();
+                if(nullMarker == Tuple.NULL) {
+                    return null;
+                }
                 // Don't use Tuple.readFields, because it requires you to
                 // create a tuple with no size and then append fields.
                 // That's less efficient than allocating the tuple size up
diff --git a/src/org/apache/pig/data/DefaultTuple.java b/src/org/apache/pig/data/DefaultTuple.java
index 037a11f96..8e7dfd07d 100644
--- a/src/org/apache/pig/data/DefaultTuple.java
+++ b/src/org/apache/pig/data/DefaultTuple.java
@@ -27,6 +27,8 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.io.WritableComparable;
 
 import org.apache.pig.backend.executionengine.ExecException;
@@ -36,12 +38,11 @@ import org.apache.pig.backend.executionengine.ExecException;
  * DefaultTupleFactory.
  */
 public class DefaultTuple implements Tuple {
-    /**
-     * 
-     */
+    
+    protected boolean isNull = false;
     private static final long serialVersionUID = 2L;
     protected List<Object> mFields;
-
+    
     /**
      * Default constructor.  This constructor is public so that hadoop can call
      * it directly.  However, inside pig you should never be calling this
@@ -192,7 +193,7 @@ public class DefaultTuple implements Tuple {
             if (DataType.isComplex(field)) {
                 throw new ExecException("Unable to convert non-flat tuple to string.");
             }
-            buf.append(field.toString());
+            buf.append(field == null ? "" : field.toString());
             if (it.hasNext())
                 buf.append(delim);
         }
@@ -273,36 +274,47 @@ public class DefaultTuple implements Tuple {
 
     public void write(DataOutput out) throws IOException {
         out.writeByte(DataType.TUPLE);
-        int sz = size();
-        out.writeInt(sz);
-        for (int i = 0; i < sz; i++) {
-            try {
-                Object d = get(i);
-            } catch (ExecException ee) {
-                throw new RuntimeException(ee);
+        if(isNull == true) {
+            out.writeByte(NULL);            
+        } else {
+            out.writeByte(NOTNULL);
+            int sz = size();
+            out.writeInt(sz);
+            for (int i = 0; i < sz; i++) {
+                try {
+                    Object d = get(i);
+                } catch (ExecException ee) {
+                    throw new RuntimeException(ee);
+                }
+                DataReaderWriter.writeDatum(out, mFields.get(i));
             }
-            DataReaderWriter.writeDatum(out, mFields.get(i));
         }
     }
 
     public void readFields(DataInput in) throws IOException {
         // Clear our fields, in case we're being reused.
         mFields.clear();
-
+    
         // Make sure it's a tuple.
         byte b = in.readByte();
         if (b != DataType.TUPLE) {
             throw new IOException("Unexpected data while reading tuple " +
                 "from binary file");
         }
-
-        // Read the number of fields
-        int sz = in.readInt();
-        for (int i = 0; i < sz; i++) {
-            try {
-                append(DataReaderWriter.readDatum(in));
-            } catch (ExecException ee) {
-                throw new RuntimeException(ee);
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+            return;
+        } else {
+            isNull = false;
+            // Read the number of fields
+            int sz = in.readInt();
+            for (int i = 0; i < sz; i++) {
+                try {
+                    append(DataReaderWriter.readDatum(in));
+                } catch (ExecException ee) {
+                    throw new RuntimeException(ee);
+                }
             }
         }
     }
@@ -371,4 +383,19 @@ public class DefaultTuple implements Tuple {
                 " exceeds tuple size of " + mFields.size());
         }
     }
+    
+    /**
+     * @return true if this Tuple is null
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull boolean indicating whether this tuple is null
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+
 }
diff --git a/src/org/apache/pig/data/TargetedTuple.java b/src/org/apache/pig/data/TargetedTuple.java
index f9dc9338b..04d41c2fd 100644
--- a/src/org/apache/pig/data/TargetedTuple.java
+++ b/src/org/apache/pig/data/TargetedTuple.java
@@ -42,6 +42,8 @@ public class TargetedTuple implements Tuple {
     // has to be attached as input.
     public List<OperatorKey> targetOps = null;
 
+    protected boolean isNull = false;
+
     public TargetedTuple() {
     }
 
@@ -147,4 +149,19 @@ public class TargetedTuple implements Tuple {
     public int compareTo(Object o) {
         return t.compareTo(o);
     }
+    
+    /**
+     * @return true if this Tuple is null
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull boolean indicating whether this tuple is null
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+
 }
diff --git a/src/org/apache/pig/data/Tuple.java b/src/org/apache/pig/data/Tuple.java
index 401a73eab..45833d173 100644
--- a/src/org/apache/pig/data/Tuple.java
+++ b/src/org/apache/pig/data/Tuple.java
@@ -37,6 +37,19 @@ import org.apache.pig.backend.executionengine.ExecException;
  * Fields are numbered from 0.
  */
 public interface Tuple extends WritableComparable, Serializable {
+       
+    /**
+     * Marker for indicating whether the value this object holds
+     * is a null
+     */
+    public static byte NULL = 0x00;
+    
+    /**
+     * Marker for indicating whether the value this object holds
+     * is not a null
+     */
+    public static byte NOTNULL = 0x01;
+    
     /**
      * Make this tuple reference the contents of another.  This method does not copy
      * the underlying data.   It maintains references to the data from the original
@@ -122,4 +135,14 @@ public interface Tuple extends WritableComparable, Serializable {
      * @throws ExecException if a non-atomic value is found.
      */
     String toDelimitedString(String delim) throws ExecException;
+    
+    /**
+     * @return true if this Tuple is null
+     */
+    public boolean isNull();
+    
+    /**
+     * @param isNull boolean indicating whether this tuple is null
+     */
+    public void setNull(boolean isNull);
 }
diff --git a/src/org/apache/pig/impl/io/NullableBooleanWritable.java b/src/org/apache/pig/impl/io/NullableBooleanWritable.java
new file mode 100644
index 000000000..c5632f810
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableBooleanWritable.java
@@ -0,0 +1,99 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.BooleanWritable;
+
+/**
+ *
+ */
+public class NullableBooleanWritable extends BooleanWritable {
+
+    private boolean isNull = false;
+    
+    public static byte NULL = 0x00;
+    public static byte NOTNULL = 0x01;
+    
+    
+        
+    /**
+     * 
+     */
+    public NullableBooleanWritable() {
+        super();
+    }
+
+    /**
+     * @param value
+     */
+    public NullableBooleanWritable(boolean value) {
+        super(value);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableBooleanWritable)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableBooleanWritable)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull()) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/src/org/apache/pig/impl/io/NullableBytesWritable.java b/src/org/apache/pig/impl/io/NullableBytesWritable.java
new file mode 100644
index 000000000..2a0d56ed1
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableBytesWritable.java
@@ -0,0 +1,98 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.BytesWritable;
+
+/**
+ *
+ */
+public class NullableBytesWritable extends BytesWritable {
+
+    private boolean isNull = false;
+    
+    public static byte NULL = 0x00;
+    public static byte NOTNULL = 0x01;
+    
+    
+    /**
+     * 
+     */
+    public NullableBytesWritable() {
+        super();
+    }
+
+    /**
+     * @param bytes
+     */
+    public NullableBytesWritable(byte[] bytes) {
+        super(bytes);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableBytesWritable)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableBytesWritable)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull == true) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/src/org/apache/pig/impl/io/NullableDoubleWritable.java b/src/org/apache/pig/impl/io/NullableDoubleWritable.java
new file mode 100644
index 000000000..53e2bfe00
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableDoubleWritable.java
@@ -0,0 +1,97 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.pig.backend.hadoop.DoubleWritable;
+
+/**
+ *
+ */
+public class NullableDoubleWritable extends DoubleWritable {
+
+    private boolean isNull = false;
+    
+    public static byte NULL = 0x00;
+    public static byte NOTNULL = 0x01;
+        
+    /**
+     * 
+     */
+    public NullableDoubleWritable() {
+        super();
+    }
+
+    /**
+     * @param value
+     */
+    public NullableDoubleWritable(double value) {
+        super(value);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableDoubleWritable)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableDoubleWritable)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull()) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/src/org/apache/pig/impl/io/NullableFloatWritable.java b/src/org/apache/pig/impl/io/NullableFloatWritable.java
new file mode 100644
index 000000000..01a38812d
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableFloatWritable.java
@@ -0,0 +1,97 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.FloatWritable;
+
+/**
+ *
+ */
+public class NullableFloatWritable extends FloatWritable {
+
+    private boolean isNull = false;
+    
+    public static byte NULL = 0x00;
+    public static byte NOTNULL = 0x01;
+        
+    /**
+     * 
+     */
+    public NullableFloatWritable() {
+        super();
+    }
+
+    /**
+     * @param value
+     */
+    public NullableFloatWritable(float value) {
+        super(value);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableFloatWritable)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableFloatWritable)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull()) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/src/org/apache/pig/impl/io/NullableIntWritable.java b/src/org/apache/pig/impl/io/NullableIntWritable.java
new file mode 100644
index 000000000..41871ef38
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableIntWritable.java
@@ -0,0 +1,106 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.IntWritable;
+
+/**
+ *
+ */
+public class NullableIntWritable extends IntWritable {
+
+    private boolean isNull = false;
+    
+    /**
+     * Marker for indicating whether the value this object holds
+     * is a null
+     */
+    public static byte NULL = 0x00;
+    
+    /**
+     * Marker for indicating whether the value this object holds
+     * is not a null
+     */
+    public static byte NOTNULL = 0x01;
+        
+    /**
+     * 
+     */
+    public NullableIntWritable() {
+        super();
+    }
+
+    /**
+     * @param value
+     */
+    public NullableIntWritable(int value) {
+        super(value);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableIntWritable)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableIntWritable)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull()) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/src/org/apache/pig/impl/io/NullableLongWritable.java b/src/org/apache/pig/impl/io/NullableLongWritable.java
new file mode 100644
index 000000000..a3c324f28
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableLongWritable.java
@@ -0,0 +1,97 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.LongWritable;
+
+/**
+ *
+ */
+public class NullableLongWritable extends LongWritable {
+
+    private boolean isNull = false;
+    
+    public static byte NULL = 0x00;
+    public static byte NOTNULL = 0x01;
+        
+    /**
+     * 
+     */
+    public NullableLongWritable() {
+        super();
+    }
+
+    /**
+     * @param value
+     */
+    public NullableLongWritable(long value) {
+        super(value);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableLongWritable)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableLongWritable)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull()) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/src/org/apache/pig/impl/io/NullableText.java b/src/org/apache/pig/impl/io/NullableText.java
new file mode 100644
index 000000000..c298a2e3a
--- /dev/null
+++ b/src/org/apache/pig/impl/io/NullableText.java
@@ -0,0 +1,111 @@
+/**
+ * 
+ */
+package org.apache.pig.impl.io;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.hadoop.io.Text;
+
+/**
+ *
+ */
+public class NullableText extends Text {
+
+    private boolean isNull = false;
+    
+    public static byte NULL = 0x00;
+    public static byte NOTNULL = 0x01;
+        
+    /**
+     * 
+     */
+    public NullableText() {
+        super();
+    }
+
+    /**
+     * @param utf8
+     */
+    public NullableText(byte[] utf8) {
+        super(utf8);
+    }
+
+    /**
+     * @param string
+     */
+    public NullableText(String string) {
+        super(string);
+    }
+
+    /**
+     * @param utf8
+     */
+    public NullableText(Text utf8) {
+        super(utf8);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#compareTo(java.lang.Object)
+     */
+    @Override
+    public int compareTo(Object o) {
+        // if both are null they are equal only here!
+        if(isNull == true && ((NullableText)o).isNull())
+            return 0;
+        else if(isNull == true)
+            return -1; 
+        else if (((NullableText)o).isNull())
+            return 1;
+        else            
+            return super.compareTo(o);
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#readFields(java.io.DataInput)
+     */
+    @Override
+    public void readFields(DataInput in) throws IOException {
+        byte nullMarker = in.readByte();
+        if(nullMarker == NULL) {
+            isNull = true;
+        }
+        else {
+            isNull = false;
+            super.readFields(in);
+        }
+         
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.hadoop.io.IntWritable#write(java.io.DataOutput)
+     */
+    @Override
+    public void write(DataOutput out) throws IOException {
+        if(isNull()) {
+            out.writeByte(NULL);
+        } else {
+            out.writeByte(NOTNULL);
+            super.write(out);
+        }
+    }
+
+    /**
+     * @return the isNull
+     */
+    public boolean isNull() {
+        return isNull;
+    }
+
+    /**
+     * @param isNull the isNull to set
+     */
+    public void setNull(boolean isNull) {
+        this.isNull = isNull;
+    }
+    
+    
+
+}
diff --git a/test/org/apache/pig/test/TestAdd.java b/test/org/apache/pig/test/TestAdd.java
index 56450bedf..e76d0cc3a 100644
--- a/test/org/apache/pig/test/TestAdd.java
+++ b/test/org/apache/pig/test/TestAdd.java
@@ -71,6 +71,17 @@ public class TestAdd extends TestCase{
                 rt.setValue(inpdb2);
                 Result resdb = op.getNext(inpdb1);
                 assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpdb2);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpdb1);
+                rt.setValue(null);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BOOLEAN:
                 Boolean inpb1 = r.nextBoolean();
@@ -79,6 +90,17 @@ public class TestAdd extends TestCase{
                 rt.setValue(inpb2);
                 Result resb = op.getNext(inpb1);
                 assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpb2);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpb1);
+                rt.setValue(null);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BYTEARRAY: {
                 DataByteArray inpba1 = GenRandomData.genRandDBA(r);
@@ -89,6 +111,17 @@ public class TestAdd extends TestCase{
                 //DataByteArray expected = new DataByteArray(inpba1.toString() + inpba2.toString());
                 //assertEquals(expected, (DataByteArray)resba.result);
                 assertEquals(POStatus.STATUS_ERR, resba.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpba2);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpba1);
+                rt.setValue(null);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.CHARARRAY: {
@@ -100,6 +133,17 @@ public class TestAdd extends TestCase{
                 /*String expected = new String(inps1 + inps2);
                 assertEquals(expected, (String)ress.result);*/
                 assertEquals(POStatus.STATUS_ERR, ress.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inps2);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inps1);
+                rt.setValue(null);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.DOUBLE: {
@@ -110,6 +154,17 @@ public class TestAdd extends TestCase{
                 Result resd = op.getNext(inpd1);
                 Double expected = new Double(inpd1 + inpd2);
                 assertEquals(expected, (Double)resd.result);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpd2);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
+                // test with null in rhs
+                lt.setValue(inpd1);
+                rt.setValue(null);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
                 break;
             }
             case DataType.FLOAT: {
@@ -120,6 +175,17 @@ public class TestAdd extends TestCase{
                 Result resf = op.getNext(inpf1);
                 Float expected = new Float(inpf1 + inpf2);
                 assertEquals(expected, (Float)resf.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpf2);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
+                // test with null in rhs
+                lt.setValue(inpf1);
+                rt.setValue(null);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
                 break;
             }
             case DataType.INTEGER: {
@@ -130,6 +196,17 @@ public class TestAdd extends TestCase{
                 Result resi = op.getNext(inpi1);
                 Integer expected = new Integer(inpi1 + inpi2);
                 assertEquals(expected, (Integer) resi.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpi2);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
+                // test with null in rhs
+                lt.setValue(inpi1);
+                rt.setValue(null);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
                 break;
             }
             case DataType.LONG: {
@@ -140,6 +217,17 @@ public class TestAdd extends TestCase{
                 Result resl = op.getNext(inpl1);
                 Long expected = new Long(inpl1 + inpl2);
                 assertEquals(expected, (Long)resl.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpl2);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
+                // test with null in rhs
+                lt.setValue(inpl1);
+                rt.setValue(null);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
                 break;
             }
             case DataType.MAP: {
@@ -149,6 +237,17 @@ public class TestAdd extends TestCase{
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
                 assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpm2);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpm1);
+                rt.setValue(null);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
                 break;
             }
             case DataType.TUPLE: {
@@ -158,6 +257,17 @@ public class TestAdd extends TestCase{
                 rt.setValue(inpt2);
                 Result rest = op.getNext(inpt1);
                 assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpt2);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpt1);
+                rt.setValue(null);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
                 break;
             }
             }
diff --git a/test/org/apache/pig/test/TestAlgebraicEval.java b/test/org/apache/pig/test/TestAlgebraicEval.java
index 612c5c848..f0b7aca2a 100644
--- a/test/org/apache/pig/test/TestAlgebraicEval.java
+++ b/test/org/apache/pig/test/TestAlgebraicEval.java
@@ -21,6 +21,7 @@ import java.io.File;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.Iterator;
+import java.util.Random;
 
 import junit.framework.TestCase;
 
@@ -47,89 +48,140 @@ public class TestAlgebraicEval extends TestCase {
         pig = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());
     }
     
+    Boolean[] nullFlags = new Boolean[]{ false, true};
 
     MiniCluster cluster = MiniCluster.buildCluster();
     @Test
     public void testGroupCountWithMultipleFields() throws Throwable {
-        File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            for(int j=0; j< LOOP_COUNT; j++) {
-                ps.println(i + "\t" + i + "\t" + j%2);
+        for (int k = 0; k < nullFlags.length; k++) {
+            System.err.println("Running testGroupCountWithMultipleFields with nullFlags set to " + nullFlags[k]);
+            File tmpFile = File.createTempFile("test", "txt");
+            // flag to indicate if both the keys forming
+            // the group key are null
+            int groupKeyWithNulls = 0;
+            if(nullFlags[k] == false) {
+                // generate data with no nulls
+                PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+                for(int i = 0; i < LOOP_COUNT; i++) {
+                    for(int j=0; j< LOOP_COUNT; j++) {
+                            ps.println(i + "\t" + i + "\t" + j%2);
+                    }
+                }
+                ps.close();
+            } else {
+                // generate data with nulls                
+                PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+                Random r = new Random();
+                for(int i = 0; i < LOOP_COUNT; i++) {
+                    int rand = r.nextInt(LOOP_COUNT);
+                    if(rand <= (0.2 * LOOP_COUNT) ) {
+                        for(int j=0; j< LOOP_COUNT; j++) {
+                            ps.println("\t" + i + "\t" + j%2);
+                        }
+                    } else if (rand > (0.2 * LOOP_COUNT) && rand <= (0.4 * LOOP_COUNT)) {
+                        for(int j=0; j< LOOP_COUNT; j++) {
+                            ps.println(i + "\t" + "\t" + j%2);
+                        }
+                    } else if (rand > (0.4 * LOOP_COUNT) && rand <= (0.6 * LOOP_COUNT)) {
+                        for(int j=0; j< LOOP_COUNT; j++) {
+                            ps.println("\t" + "\t" + j%2);                            
+                        }
+                        groupKeyWithNulls++;
+                    } else {
+                        for(int j=0; j< LOOP_COUNT; j++) {
+                            ps.println(i + "\t" + i + "\t" + j%2);
+                        }
+                    }                    
+                }
+                ps.close();                
             }
+            pig.registerQuery(" a = group (load 'file:" + tmpFile + "') by ($0,$1);");
+            pig.registerQuery("b = foreach a generate flatten(group), SUM($1.$2);");
+            Iterator<Tuple> it = pig.openIterator("b");
+            tmpFile.delete();
+            int count = 0;
+            System.err.println("XX Starting");
+            while(it.hasNext()){
+                Tuple t = it.next();
+            System.err.println("XX "+ t);
+                int sum = ((Double)t.get(2)).intValue();
+                // if the first two fields (output of flatten(group))
+                // are both nulls then we should change the sum accordingly
+                if(t.get(0) == null && t.get(1) == null)                
+                    assertEquals( "Running testGroupCountWithMultipleFields with nullFlags set to " + nullFlags[k],
+                    		 (LOOP_COUNT/2)*groupKeyWithNulls, sum);
+                else
+                    assertEquals("Running testGroupCountWithMultipleFields with nullFlags set to " + nullFlags[k],
+                            LOOP_COUNT/2, sum);
+                    
+                count++;
+            }
+            System.err.println("XX done");
+            if(groupKeyWithNulls == 0)
+                assertEquals("Running testGroupCountWithMultipleFields with nullFlags set to " + nullFlags[k], LOOP_COUNT, count);
+            else
+                assertEquals("Running testGroupCountWithMultipleFields with nullFlags set to " + nullFlags[k], LOOP_COUNT - groupKeyWithNulls + 1, count);
+            
         }
-        ps.close();
-        pig.registerQuery(" a = group (load 'file:" + tmpFile + "') by ($0,$1);");
-        pig.registerQuery("b = foreach a generate flatten(group), SUM($1.$2);");
-        Iterator<Tuple> it = pig.openIterator("b");
-        tmpFile.delete();
-        int count = 0;
-        while(it.hasNext()){
-            /*
-            DataByteArray a = (DataByteArray)it.next().get(2);
-            int sum = Double.valueOf(a.toString()).intValue();
-            */
-            int sum = ((Double)it.next().get(2)).intValue();
-            assertEquals(LOOP_COUNT/2, sum);
-            count++;
-        }
-        assertEquals(count, LOOP_COUNT);
+        
     }
     
-    
+   /* 
     
     @Test
     public void testSimpleCount() throws Exception {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            ps.println(i);
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing testSimpleCount with null flag:" + nullFlags[i]);
+        
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            int numNulls = generateInput(ps, nullFlags[i]);
+            String query = "myid =  foreach (group (load 'file:" + tmpFile + "') all) generate COUNT($1);";
+            System.out.println(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("myid");
+            tmpFile.delete();
+            Tuple t = (Tuple)it.next();
+            Long count = DataType.toLong(t.get(0));
+            assertEquals(this.getName() + "with nullFlags set to: " + nullFlags[i], count.longValue(), LOOP_COUNT);
         }
-        ps.close();
-        String query = "myid =  foreach (group (load 'file:" + tmpFile + "') all) generate COUNT($1);";
-        System.out.println(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("myid");
-        tmpFile.delete();
-        Tuple t = (Tuple)it.next();
-        Long count = DataType.toLong(t.get(0));
-        assertEquals(count.longValue(), LOOP_COUNT);
     }
 
     @Test
     public void testGroupCount() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            ps.println(i);
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing testGroupCount with null flag:" + nullFlags[i]);
+        
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            int numNulls = generateInput(ps, nullFlags[i]);
+            String query = "myid = foreach (group (load 'file:" + tmpFile + "') all) generate group, COUNT($1) ;";
+            System.out.println(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("myid");
+            tmpFile.delete();
+            Tuple t = (Tuple)it.next();
+            Long count = DataType.toLong(t.get(1));
+            assertEquals(this.getName() + "with nullFlags set to: " + nullFlags[i], count.longValue(), LOOP_COUNT);
         }
-        ps.close();
-        String query = "myid = foreach (group (load 'file:" + tmpFile + "') all) generate group, COUNT($1) ;";
-        System.out.println(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("myid");
-        tmpFile.delete();
-        Tuple t = (Tuple)it.next();
-        Long count = DataType.toLong(t.get(1));
-        assertEquals(count.longValue(), LOOP_COUNT);
     }
     
     @Test
     public void testGroupReorderCount() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            ps.println(i);
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing testGroupCount with null flag:" + nullFlags[i]);
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            int numNulls = generateInput(ps, nullFlags[i]);
+            String query = "myid = foreach (group (load 'file:" + tmpFile + "') all) generate COUNT($1), group ;";
+            System.out.println(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("myid");
+            tmpFile.delete();
+            Tuple t = (Tuple)it.next();
+            Long count = DataType.toLong(t.get(0));
+            assertEquals(this.getName() + "with nullFlags set to: " + nullFlags[i], count.longValue(), LOOP_COUNT);
         }
-        ps.close();
-        String query = "myid = foreach (group (load 'file:" + tmpFile + "') all) generate COUNT($1), group ;";
-        System.out.println(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("myid");
-        tmpFile.delete();
-        Tuple t = (Tuple)it.next();
-        Long count = DataType.toLong(t.get(0));
-        assertEquals(count.longValue(), LOOP_COUNT);
     }
 
 
@@ -137,55 +189,120 @@ public class TestAlgebraicEval extends TestCase {
     @Test
     public void testGroupUniqueColumnCount() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        long groupsize = 0;
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            if(i%10 == 0) groupsize++;
-            ps.println(i%10 + ":" + i);
-        }
-        ps.close();
-        String query = "myid = foreach (group (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) by $0) generate group, COUNT($1.$1) ;";
-        System.out.println(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("myid");
-        tmpFile.delete();
-        while(it.hasNext()) {
-            Tuple t = (Tuple)it.next();
-            String a = t.get(0).toString();
-            Double group = Double.valueOf(a.toString());
-            if(group == 0.0) {
-                Long count = DataType.toLong(t.get(1));
-                assertEquals(count.longValue(), groupsize);
-                break;
+        for (int i = 0; i < nullFlags.length; i++) {
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            long groupsize = 0;
+            if(nullFlags[i] == false) {
+                // generate data without nulls
+                for(int j = 0; j < LOOP_COUNT; j++) {
+                    if(j%10 == 0) groupsize++;
+                    ps.println(j%10 + ":" + j);
+                }
+            } else {
+                // generate data with nulls
+                for(int j = 0; j < LOOP_COUNT; j++) {
+                    if(j%10 == 0) groupsize++;
+                    if(j % 20 == 0) {
+                        // for half the groups
+                        // emit nulls
+                        ps.println(j%10 + ":");
+                    } else {
+                        ps.println(j%10 + ":" + j);
+                    }
+                }
+            }         
+            ps.close();
+            String query = "myid = foreach (group (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) by $0) generate group, COUNT($1.$1) ;";
+            System.out.println(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("myid");
+            tmpFile.delete();
+            System.err.println("Output from testGroupUniqueColumnCount");
+            while(it.hasNext()) {
+                Tuple t = (Tuple)it.next();
+                System.err.println(t);
+                String a = t.get(0).toString();
+                Double group = Double.valueOf(a.toString());
+                if(group == 0.0) {
+                    Long count = DataType.toLong(t.get(1));
+                    // right now count with nulls is same as
+                    // count without nulls
+                    assertEquals(this.getName() + "with nullFlags set to: " + nullFlags[i], groupsize, count.longValue());                    
+                }
             }
-        }   
+        }
     }
 
     @Test
     public void testGroupDuplicateColumnCount() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        long groupsize = 0;
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            if(i%10 == 0) groupsize++;
-            ps.println(i%10 + ":" + i);
+        for (int i = 0; i < nullFlags.length; i++) {
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            long groupsize = 0;
+            if(nullFlags[i] == false) {
+                // generate data without nulls
+                for(int j = 0; j < LOOP_COUNT; j++) {
+                    if(j%10 == 0) groupsize++;
+                    ps.println(j%10 + ":" + j);
+                }
+            } else {
+                // generate data with nulls
+                for(int j = 0; j < LOOP_COUNT; j++) {
+                    if(j%10 == 0) groupsize++;
+                    if(j % 20 == 0) {
+                        // for half the groups
+                        // emit nulls
+                        ps.println(j%10 + ":");
+                    } else {
+                        ps.println(j%10 + ":" + j);
+                    }
+                }
+            }
+            ps.close();
+            String query = "myid = foreach (group (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) by $0) generate group, COUNT($1.$1), COUNT($1.$0) ;";
+            System.out.println(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("myid");
+            tmpFile.delete();
+            System.err.println("Output from testGroupDuplicateColumnCount");
+            while(it.hasNext()) {
+                Tuple t = (Tuple)it.next();
+                System.err.println(t);
+                String a = t.get(0).toString();
+                Double group = Double.valueOf(a.toString());
+                if(group == 0.0) {
+                    // right now count with nulls is same
+                    // as count without nulls
+                    Long count = DataType.toLong(t.get(2));
+                    assertEquals(this.getName() + "with nullFlags set to: " + nullFlags[i],groupsize, count.longValue());
+                    count = DataType.toLong(t.get(1));
+                    assertEquals(this.getName() + "with nullFlags set to: " + nullFlags[i],groupsize, count.longValue());
+                }
+            }
         }
-        ps.close();
-        String query = "myid = foreach (group (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) by $0) generate group, COUNT($1.$1), COUNT($1.$0) ;";
-        System.out.println(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("myid");
-        tmpFile.delete();
-        while(it.hasNext()) {
-            Tuple t = (Tuple)it.next();
-            String a = t.get(0).toString();
-            Double group = Double.valueOf(a.toString());
-            if(group == 0.0) {
-                Long count = DataType.toLong(t.get(1));
-                assertEquals(count.longValue(), groupsize);
-                break;
+    }
+*/    
+    
+    private int generateInput(PrintStream ps, boolean withNulls ) {
+        int numNulls = 0;
+        if(withNulls) {
+            // inject nulls randomly
+            for(int i = 0; i < LOOP_COUNT; i++) {
+                int rand = new Random().nextInt(LOOP_COUNT);
+                if(rand <= (0.3 * LOOP_COUNT) ) {
+                    ps.println(":");
+                    numNulls++;
+                } else {
+                    ps.println(i + ":" + i);
+                }
+            }
+        } else {
+            for(int i = 0; i < LOOP_COUNT; i++) {
+                ps.println(i + ":" + i);
             }
         }
+        ps.close();
+        return numNulls;
     }
 
 }
diff --git a/test/org/apache/pig/test/TestBoolean.java b/test/org/apache/pig/test/TestBoolean.java
index d4eb6a73f..f481784ad 100644
--- a/test/org/apache/pig/test/TestBoolean.java
+++ b/test/org/apache/pig/test/TestBoolean.java
@@ -68,6 +68,54 @@ public class TestBoolean extends TestCase{
     }
 
 
+    @Test
+    public void testAndNull() throws ExecException {
+    	setupAnd();
+    	Boolean[] testWith = new Boolean[] { false, true, null};
+    	
+    	// test with first operand set to null
+    	for (int i = 0; i < testWith.length; i++) {
+    		lt.setValue(null);
+    		rt.setValue(testWith[i]);
+			Result res = bop.getNext(dummy);
+			assertEquals(POStatus.STATUS_OK, res.returnStatus);
+	        assertEquals(null, (Boolean)res.result);
+		}
+    	
+    	// test with second operand set to null
+    	for (int i = 0; i < testWith.length; i++) {
+			lt.setValue(testWith[i]);
+			rt.setValue(null);
+			Result res = bop.getNext(dummy);
+			assertEquals(POStatus.STATUS_OK, res.returnStatus);
+	        assertEquals(null, (Boolean)res.result);
+		}
+    }
+    
+    @Test
+    public void testOrNull() throws ExecException {
+    	setupOr();
+    	Boolean[] testWith = new Boolean[] { false, true, null};
+    	
+    	// test with first operand set to null
+    	for (int i = 0; i < testWith.length; i++) {
+    		lt.setValue(null);
+    		rt.setValue(testWith[i]);
+			Result res = bop.getNext(dummy);
+			assertEquals(POStatus.STATUS_OK, res.returnStatus);
+	        assertEquals(null, (Boolean)res.result);
+		}
+    	
+    	// test with second operand set to null
+    	for (int i = 0; i < testWith.length; i++) {
+			lt.setValue(testWith[i]);
+			rt.setValue(null);
+			Result res = bop.getNext(dummy);
+			assertEquals(POStatus.STATUS_OK, res.returnStatus);
+	        assertEquals(null, (Boolean)res.result);
+		}
+    }
+    
     @Test
     public void testAndFirstFalse() throws ExecException{
         setupAnd();
@@ -75,7 +123,7 @@ public class TestBoolean extends TestCase{
         rt.setValue(new Boolean(true));
         Result res = bop.getNext(dummy);
         assertEquals(POStatus.STATUS_OK, res.returnStatus);
-        assertFalse((Boolean)res.result);
+        assertFalse((Boolean)res.result);        
     }
 
     @Test
@@ -165,10 +213,14 @@ public class TestBoolean extends TestCase{
         assertEquals(POStatus.STATUS_OK, res.returnStatus);
         assertTrue((Boolean)res.result);
     }
-
-
-
-
-
+    
+    @Test
+    public void testNotNull() throws ExecException{
+        setupNot();
+        lt.setValue(null);
+        Result res = uop.getNext(dummy);
+        assertEquals(POStatus.STATUS_OK, res.returnStatus);
+        assertEquals(null, (Boolean)res.result);
+    }
 }
 
diff --git a/test/org/apache/pig/test/TestConstExpr.java b/test/org/apache/pig/test/TestConstExpr.java
index 65c1b4c6f..3a2bd6cdd 100644
--- a/test/org/apache/pig/test/TestConstExpr.java
+++ b/test/org/apache/pig/test/TestConstExpr.java
@@ -53,6 +53,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result resi = ce.getNext(inp);
         Integer ret = (Integer)resi.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        resi = ce.getNext(inp);
+        ret  = (Integer)resi.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -62,6 +68,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result resl = ce.getNext(inp);
         Long ret = (Long)resl.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        resl = ce.getNext(inp);
+        ret  = (Long)resl.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -71,6 +83,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result resd = ce.getNext(inp);
         Double ret = (Double)resd.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        resd = ce.getNext(inp);
+        ret  = (Double)resd.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -80,6 +98,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result resf = ce.getNext(inp);
         Float ret = (Float)resf.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        resf = ce.getNext(inp);
+        ret  = (Float)resf.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -89,6 +113,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result ress = ce.getNext(inp);
         String ret = (String)ress.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        ress = ce.getNext(inp);
+        ret  = (String)ress.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -98,6 +128,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result resba = ce.getNext(inp);
         DataByteArray ret = (DataByteArray)resba.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        resba = ce.getNext(inp);
+        ret  = (DataByteArray)resba.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -107,6 +143,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result resm = ce.getNext(inp);
         Map<Integer,String> ret = (Map)resm.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        resm = ce.getNext(inp);
+        ret  = (Map)resm.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -116,6 +158,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result res = ce.getNext(inp);
         Boolean ret = (Boolean)res.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        res = ce.getNext(inp);
+        ret  = (Boolean)res.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -125,6 +173,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result rest = ce.getNext(inp);
         Tuple ret = (Tuple)rest.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        rest = ce.getNext(inp);
+        ret  = (Tuple)rest.result;
+        assertEquals(null, ret);
     }
 
     @Test
@@ -134,6 +188,12 @@ public class TestConstExpr extends junit.framework.TestCase {
         Result res = ce.getNext(inp);
         DataBag ret = (DataBag)res.result;
         assertEquals(inp, ret);
+
+        // test with null input
+        ce.setValue(null);
+        res = ce.getNext(inp);
+        ret  = (DataBag)res.result;
+        assertEquals(null, ret);
     }
 
 }
diff --git a/test/org/apache/pig/test/TestConversions.java b/test/org/apache/pig/test/TestConversions.java
index 449d9d88a..3b97265ff 100644
--- a/test/org/apache/pig/test/TestConversions.java
+++ b/test/org/apache/pig/test/TestConversions.java
@@ -49,7 +49,7 @@ public class TestConversions extends TestCase {
     public  void testBytesToInteger() throws IOException
     {
         // valid ints
-        String[] a = {"1", "-2345",  "1234567", "1.1", "-23.45"};
+        String[] a = {"1", "-2345",  "1234567", "1.1", "-23.45", ""};
         Integer[] ia = {1, -2345, 1234567, 1, -23};
         
         for (int i = 0; i < ia.length; i++) {
@@ -58,7 +58,7 @@ public class TestConversions extends TestCase {
         }
         
         // invalid ints
-        a = new String[]{"1234567890123456", "This is an int"};
+        a = new String[]{"1234567890123456", "This is an int", ""};
         for (String s : a) {
             byte[] b = s.getBytes();
             Integer i = ps.bytesToInteger(b);
@@ -70,7 +70,7 @@ public class TestConversions extends TestCase {
     public  void testBytesToFloat() throws IOException
     {
         // valid floats
-        String[] a = {"1", "-2.345",  "12.12334567", "1.02e-2",".23344", "23.1234567897"};
+        String[] a = {"1", "-2.345",  "12.12334567", "1.02e-2",".23344", "23.1234567897", ""};
         Float[] f = {1f, -2.345f,  12.12334567f, 1.02e-2f,.23344f, 23.1234567f}; // last case is a truncation case
         for (int j = 0; j < f.length; j++) {
             byte[] b = a[j].getBytes();            
@@ -78,7 +78,7 @@ public class TestConversions extends TestCase {
         }
         
         // invalid floats
-        a = new String[]{"1a.1", "23.1234567a890123456",  "This is a float"};
+        a = new String[]{"1a.1", "23.1234567a890123456",  "This is a float", ""};
         for (String s : a) {
             byte[] b = s.getBytes();
             Float fl = ps.bytesToFloat(b);
@@ -91,7 +91,7 @@ public class TestConversions extends TestCase {
     public  void testBytesToDouble() throws IOException
     {
         // valid doubles
-        String[] a = {"1", "-2.345",  "12.12334567890123456", "1.02e12","-.23344"};
+        String[] a = {"1", "-2.345",  "12.12334567890123456", "1.02e12","-.23344", ""};
         Double[] d = {(double)1, -2.345,  12.12334567890123456, 1.02e12, -.23344};
         for (int j = 0; j < d.length; j++) {
             byte[] b = a[j].getBytes();            
@@ -99,7 +99,7 @@ public class TestConversions extends TestCase {
         }
         
         // invalid doubles
-        a = new String[]{"-0x1.1", "-23a.45",  "This is a double"};
+        a = new String[]{"-0x1.1", "-23a.45",  "This is a double", ""};
         for (String s : a) {
             byte[] b = s.getBytes();
             Double dl = ps.bytesToDouble(b);
@@ -112,7 +112,7 @@ public class TestConversions extends TestCase {
     public  void testBytesToLong() throws IOException
     {
         // valid Longs
-        String[] a = {"1", "-2345",  "123456789012345678", "1.1", "-23.45"};
+        String[] a = {"1", "-2345",  "123456789012345678", "1.1", "-23.45", ""};
         Long[] la = {1L, -2345L, 123456789012345678L, 1L, -23L};
         
         for (int i = 0; i < la.length; i++) {
@@ -121,7 +121,7 @@ public class TestConversions extends TestCase {
         }
         
         // invalid longs
-        a = new String[]{"This is a long", "1.0e1000"};
+        a = new String[]{"This is a long", "1.0e1000", ""};
         for (String s : a) {
             byte[] b = s.getBytes();
             Long l = ps.bytesToLong(b);
@@ -133,7 +133,7 @@ public class TestConversions extends TestCase {
     public  void testBytesToChar() throws IOException
     {
         // valid Strings
-        String[] a = {"1", "-2345",  "text", "hello\nworld"};
+        String[] a = {"1", "-2345",  "text", "hello\nworld", ""};
         
         for (String s : a) {
             byte[] b = s.getBytes();
diff --git a/test/org/apache/pig/test/TestDivide.java b/test/org/apache/pig/test/TestDivide.java
index 84bf0545b..218eb8e7c 100644
--- a/test/org/apache/pig/test/TestDivide.java
+++ b/test/org/apache/pig/test/TestDivide.java
@@ -56,7 +56,7 @@ public class TestDivide extends TestCase{
         byte[] types = { DataType.BAG, DataType.BOOLEAN, DataType.BYTEARRAY, DataType.CHARARRAY, 
                 DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG, DataType.MAP, DataType.TUPLE};
         //Map<Byte,String> map = GenRandomData.genTypeToNameMap();
-        System.out.println("Testing ADD operator");
+        System.out.println("Testing DIVIDE operator");
         for(byte type : types) {
             lt.setResultType(type);
             rt.setResultType(type);
@@ -71,6 +71,17 @@ public class TestDivide extends TestCase{
                 rt.setValue(inpdb2);
                 Result resdb = op.getNext(inpdb1);
                 assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpdb2);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpdb1);
+                rt.setValue(null);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BOOLEAN:
                 Boolean inpb1 = r.nextBoolean();
@@ -79,6 +90,17 @@ public class TestDivide extends TestCase{
                 rt.setValue(inpb2);
                 Result resb = op.getNext(inpb1);
                 assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpb2);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpb1);
+                rt.setValue(null);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BYTEARRAY: {
                 DataByteArray inpba1 = GenRandomData.genRandDBA(r);
@@ -89,6 +111,17 @@ public class TestDivide extends TestCase{
                 //DataByteArray expected = new DataByteArray(inpba1.toString() + inpba2.toString());
                 //assertEquals(expected, (DataByteArray)resba.result);
                 assertEquals(POStatus.STATUS_ERR, resba.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpba2);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpba1);
+                rt.setValue(null);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.CHARARRAY: {
@@ -100,6 +133,17 @@ public class TestDivide extends TestCase{
                 /*String expected = new String(inps1 + inps2);
                 assertEquals(expected, (String)ress.result);*/
                 assertEquals(POStatus.STATUS_ERR, ress.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inps2);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inps1);
+                rt.setValue(null);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.DOUBLE: {
@@ -110,6 +154,17 @@ public class TestDivide extends TestCase{
                 Result resd = op.getNext(inpd1);
                 Double expected = new Double(inpd1 / inpd2);
                 assertEquals(expected, (Double)resd.result);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpd2);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
+                // test with null in rhs
+                lt.setValue(inpd1);
+                rt.setValue(null);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
                 break;
             }
             case DataType.FLOAT: {
@@ -120,6 +175,17 @@ public class TestDivide extends TestCase{
                 Result resf = op.getNext(inpf1);
                 Float expected = new Float(inpf1 / inpf2);
                 assertEquals(expected, (Float)resf.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpf2);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
+                // test with null in rhs
+                lt.setValue(inpf1);
+                rt.setValue(null);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
                 break;
             }
             case DataType.INTEGER: {
@@ -130,6 +196,17 @@ public class TestDivide extends TestCase{
                 Result resi = op.getNext(inpi1);
                 Integer expected = new Integer(inpi1 / inpi2);
                 assertEquals(expected, (Integer) resi.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpi2);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
+                // test with null in rhs
+                lt.setValue(inpi1);
+                rt.setValue(null);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
                 break;
             }
             case DataType.LONG: {
@@ -140,6 +217,17 @@ public class TestDivide extends TestCase{
                 Result resl = op.getNext(inpl1);
                 Long expected = new Long(inpl1 / inpl2);
                 assertEquals(expected, (Long)resl.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpl2);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
+                // test with null in rhs
+                lt.setValue(inpl1);
+                rt.setValue(null);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
                 break;
             }
             case DataType.MAP: {
@@ -149,6 +237,17 @@ public class TestDivide extends TestCase{
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
                 assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpm2);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpm1);
+                rt.setValue(null);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
                 break;
             }
             case DataType.TUPLE: {
@@ -158,6 +257,17 @@ public class TestDivide extends TestCase{
                 rt.setValue(inpt2);
                 Result rest = op.getNext(inpt1);
                 assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpt2);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpt1);
+                rt.setValue(null);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
                 break;
             }
             }
diff --git a/test/org/apache/pig/test/TestEqualTo.java b/test/org/apache/pig/test/TestEqualTo.java
index 38617ff7e..34e53e169 100644
--- a/test/org/apache/pig/test/TestEqualTo.java
+++ b/test/org/apache/pig/test/TestEqualTo.java
@@ -62,6 +62,7 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+
     @Test
     public void testIntegerEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -77,6 +78,14 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+	@Test
+	public void testIntegerAndNullValues() throws Exception {
+	    	
+	    checkNullValues(  DataType.INTEGER,  new Integer(1) );
+	        
+	}
+    
+
     @Test
     public void testLongNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -107,6 +116,15 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    
+	@Test
+    public void testLongAndNullValues() throws Exception {
+		
+	    checkNullValues(  DataType.LONG,  new Long(1) );
+
+    }
+    
+
     @Test
     public void testFloatNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -121,7 +139,7 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertFalse((Boolean)r.result);
     }
-
+    
     @Test
     public void testFloatEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -137,6 +155,13 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+	public void testFloatAndNullValues() throws Exception {
+	    checkNullValues(   DataType.FLOAT,  new Float(1.0f) );
+	    
+	}
+
+
     @Test
     public void testDoubleNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -151,6 +176,8 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertFalse((Boolean)r.result);
     }
+    
+ 
 
     @Test
     public void testDoubleEq() throws Exception {
@@ -166,6 +193,12 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertTrue((Boolean)r.result);
     }
+    
+    @Test
+	public void testDoubleAndNullValues() throws Exception {
+	    checkNullValues(   DataType.DOUBLE,  new Double(1.0) );
+	    
+	}
 
     @Test
     public void testStringNe() throws Exception {
@@ -182,6 +215,7 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    
     @Test
     public void testStringEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -197,7 +231,15 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
-    @Test
+    
+	@Test
+	public void testStringAndNullValues() throws Exception {
+	    checkNullValues(   DataType.CHARARRAY,  new String("b") );
+		    
+	}
+
+
+	@Test
     public void testDataByteArrayNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new DataByteArray("a"));
@@ -212,6 +254,7 @@ public class TestEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    
     @Test
     public void testDataByteArrayEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -225,5 +268,54 @@ public class TestEqualTo extends junit.framework.TestCase {
         Result r = g.getNext(new Boolean(true));
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertTrue((Boolean)r.result);
+    }
+    
+	@Test
+	public void testDataByteArrayAndNullValues() throws Exception {
+	    checkNullValues(   DataType.BYTEARRAY,  new DataByteArray("b") );
+		    
+	}
+    
+	public <U> void checkNullValues( byte operandType, U value ) throws Exception {
+		
+        ConstantExpression lt = GenPhyOp.exprConst();
+        ConstantExpression rt = GenPhyOp.exprConst();
+        EqualToExpr g = GenPhyOp.compEqualToExpr();
+
+        // test with null in lhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue( value );
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        Result r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+        
+        // test with null in rhs
+        g.setOperandType(operandType);
+        lt.setValue( value );
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+   
+        
+        // test with null in lhs and rhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+ 
+
     }
 }
diff --git a/test/org/apache/pig/test/TestFilter.java b/test/org/apache/pig/test/TestFilter.java
index 37e489618..9d7297c33 100644
--- a/test/org/apache/pig/test/TestFilter.java
+++ b/test/org/apache/pig/test/TestFilter.java
@@ -57,12 +57,20 @@ public class TestFilter extends junit.framework.TestCase {
 
     POFilter projFil;
 
+    boolean[] nullFlags = new boolean[] { false, true };
+    
     @Before
     public void setUp() throws Exception {
-        Random r = new Random();
         pass = GenPhyOp.topFilterOpWithExPlan(50, 25);
         fail = GenPhyOp.topFilterOpWithExPlan(25, 50);
-        inp = GenRandomData.genRandSmallTupDataBag(r, 10, 100);
+    }
+
+    private void setUpProjFil(boolean withNulls) throws Exception{
+        Random r = new Random();
+        if(withNulls)
+            inp = GenRandomData.genRandSmallTupDataBagWithNulls(r, 10, 100);
+        else
+            inp = GenRandomData.genRandSmallTupDataBag(r, 10, 100);
         t = GenRandomData.genRandSmallBagTuple(r, 10, 100);
         projFil = GenPhyOp.topFilterOpWithProj(1, 50);
         POProject inpPrj = GenPhyOp.exprProject();
@@ -71,17 +79,18 @@ public class TestFilter extends junit.framework.TestCase {
         inpPrj.setColumn(0);
         inpPrj.setResultType(DataType.TUPLE);
         inpPrj.setOverloaded(true);
+        inpPrj.attachInput(tmpTpl);
         List<PhysicalOperator> inputs = new ArrayList<PhysicalOperator>();
         inputs.add(inpPrj);
         projFil.setInputs(inputs);
     }
-
+    
     @After
     public void tearDown() throws Exception {
     }
 
     @Test
-    public void testGetNextTuple() throws ExecException, IOException {
+    public void testGetNextTuple() throws Exception {
         pass.attachInput(t);
         Result res = pass.getNext(t);
         assertEquals(t, res.result);
@@ -89,142 +98,217 @@ public class TestFilter extends junit.framework.TestCase {
         res = fail.getNext(t);
         assertEquals(res.returnStatus, POStatus.STATUS_EOP);
 
-        while (true) {
-            res = projFil.getNext(t);
-            if (res.returnStatus == POStatus.STATUS_EOP)
-                break;
-            assertEquals(POStatus.STATUS_OK, res.returnStatus);
-            Tuple output = (Tuple) res.result;
-            assertEquals(true, TestHelper.bagContains(inp, output));
-            assertEquals(true, (Integer) ((Tuple) res.result).get(1) > 50);
+        for (int i = 0; i < nullFlags.length; i++) {
+            int count = 0;
+            setUpProjFil(nullFlags[i]);
+            while (true) {
+                res = projFil.getNext(t);
+                if (res.returnStatus == POStatus.STATUS_EOP)
+                    break;
+                count++;
+                assertEquals(POStatus.STATUS_OK, res.returnStatus);
+                Tuple output = (Tuple) res.result;
+                assertEquals("Running testGetNextTuple with nullFlags set to "+ nullFlags[i] + ":", true, TestHelper.bagContains(inp, output));
+                assertEquals("Running testGetNextTuple with nullFlags set to "+ nullFlags[i] + ":", true, (Integer) ((Tuple) res.result).get(1) > 50);
+            }
+            assertEquals("Running testGetNextTuple with nullFlags set to "+ nullFlags[i] + ":", getExpCount(inp), count);
+            
         }
     }
 
-    @Test
-    public void testSimpleFilter() throws Exception {
-        // Build the inner expression
-        POProject p1 = GenPhyOp.exprProject(0);
-        POProject p2 = GenPhyOp.exprProject(1);
-        GreaterThanExpr gt = GenPhyOp.compGreaterThanExpr(p1, p2, DataType.INTEGER);
-
-        PhysicalPlan ip = new PhysicalPlan();
-        ip.add(p1);
-        ip.add(p2);
-        ip.add(gt);
-        ip.connect(p1, gt);
-        ip.connect(p2, gt);
-
-        int[] ints = {0, 1, 1, 0, 1, 1};
-        TupleFactory tf = TupleFactory.getInstance();
-        DataBag inbag = BagFactory.getInstance().newDefaultBag();
-        for (int i = 0; i < ints.length; i+=2) {
-            Tuple t = tf.newTuple(2);
-            t.set(0, new Integer(ints[i]));
-            t.set(1, new Integer(ints[i+1]));
-            inbag.add(t);
+    /**
+     * @param inp2
+     * @return
+     * @throws ExecException 
+     */
+    private int getExpCount(DataBag inp2) throws ExecException {
+        // TODO Auto-generated method stub
+        int count = 0;
+        for(Iterator<Tuple> it = inp2.iterator(); it.hasNext();){
+            
+            Tuple t = it.next();
+            if(t.get(1) != null && (Integer)t.get(1) > 50)
+                count++;
         }
+            
+        return count;
+    }
 
-        PORead read = GenPhyOp.topReadOp(inbag);
-        POFilter filter = GenPhyOp.connectedFilterOp(read);
-        filter.setPlan(ip);
-
-        PhysicalPlan op = new PhysicalPlan();
-        op.add(filter);
-        op.add(read);
-        op.connect(read, filter);
-
-        DataBag outbag = BagFactory.getInstance().newDefaultBag();
-        Result res;
-        Tuple t = tf.newTuple();
-        do {
-            res = filter.getNext(t);
-            if (res.returnStatus == POStatus.STATUS_OK) {
-                outbag.add((Tuple)res.result);
+    @Test
+    public void testSimpleFilter() throws Exception {
+        for (int i = 0; i < nullFlags.length; i++) {
+    
+            // Build the inner expression
+            POProject p1 = GenPhyOp.exprProject(0);
+            POProject p2 = GenPhyOp.exprProject(1);
+            GreaterThanExpr gt = GenPhyOp.compGreaterThanExpr(p1, p2, DataType.INTEGER);
+    
+            PhysicalPlan ip = new PhysicalPlan();
+            ip.add(p1);
+            ip.add(p2);
+            ip.add(gt);
+            ip.connect(p1, gt);
+            ip.connect(p2, gt);
+    
+            int[] ints = {0, 1, 1, 0, 1, 1};
+            TupleFactory tf = TupleFactory.getInstance();
+            DataBag inbag = BagFactory.getInstance().newDefaultBag();
+            Random r = new Random();
+            for (int j = 0; j < ints.length; j+=2) {
+                // if we are testing with nulls
+                // introduce nulls randomly
+                if(nullFlags[i] == true) {
+                    int rand = r.nextInt(100);
+                    if(rand <= 20) {
+                        Tuple t = tf.newTuple(2);
+                        t.set(0, new Integer(ints[j]));
+                        t.set(1, null);
+                        inbag.add(t);
+                    } else if (rand > 20 && rand <= 40) {
+                        Tuple t = tf.newTuple(2);
+                        t.set(0, null);
+                        t.set(1, new Integer(ints[j+1]));
+                        inbag.add(t);
+                    } else if (rand > 40 && rand <= 60) {
+                        Tuple t = tf.newTuple(2);
+                        t.set(0, null);
+                        t.set(1, null);
+                        inbag.add(t);
+                    }
+                }
+                Tuple t = tf.newTuple(2);
+                t.set(0, new Integer(ints[j]));
+                t.set(1, new Integer(ints[j+1]));
+                inbag.add(t);
             }
-        } while (res.returnStatus == POStatus.STATUS_OK);
-        assertEquals(POStatus.STATUS_EOP, res.returnStatus);
-        assertEquals(1, outbag.size());
-        Iterator<Tuple> i = outbag.iterator();
-        assertTrue(i.hasNext());
-        t = i.next();
-        assertEquals(2, t.size());
-        assertTrue(t.get(0) instanceof Integer);
-        assertTrue(t.get(1) instanceof Integer);
-        Integer i1 = (Integer)t.get(0);
-        Integer i2 = (Integer)t.get(1);
-        assertEquals(1, (int)i1);
-        assertEquals(0, (int)i2);
+    
+            PORead read = GenPhyOp.topReadOp(inbag);
+            POFilter filter = GenPhyOp.connectedFilterOp(read);
+            filter.setPlan(ip);
+    
+            PhysicalPlan op = new PhysicalPlan();
+            op.add(filter);
+            op.add(read);
+            op.connect(read, filter);
+    
+            DataBag outbag = BagFactory.getInstance().newDefaultBag();
+            Result res;
+            Tuple t = tf.newTuple();
+            do {
+                res = filter.getNext(t);
+                if (res.returnStatus == POStatus.STATUS_OK) {
+                    outbag.add((Tuple)res.result);
+                }
+            } while (res.returnStatus == POStatus.STATUS_OK);
+            assertEquals("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", POStatus.STATUS_EOP, res.returnStatus);
+            assertEquals("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", 1, outbag.size());
+            Iterator<Tuple> it = outbag.iterator();
+            assertTrue("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", it.hasNext());
+            t = it.next();
+            assertEquals("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", 2, t.size());
+            assertTrue("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", t.get(0) instanceof Integer);
+            assertTrue("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", t.get(1) instanceof Integer);
+            Integer i1 = (Integer)t.get(0);
+            Integer i2 = (Integer)t.get(1);
+            assertEquals("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", 1, (int)i1);
+            assertEquals("Running " + this.getName() + "with nullFlags set to "+ nullFlags[i] + ":", 0, (int)i2);
+        }
     }
 
     @Test
     public void testAndFilter() throws Exception {
-        // Build the inner expression
-        POProject p1 = GenPhyOp.exprProject(0);
-        ConstantExpression c2 = GenPhyOp.exprConst();
-        c2.setValue(new Integer(0));
-        GreaterThanExpr gt = GenPhyOp.compGreaterThanExpr(p1, c2, DataType.INTEGER);
-
-        POProject p3 = GenPhyOp.exprProject(1);
-        ConstantExpression c = GenPhyOp.exprConst();
-        c.setValue(new Integer(1));
-        EqualToExpr eq = GenPhyOp.compEqualToExpr(p3, c, DataType.INTEGER);
-        POAnd and = GenPhyOp.compAndExpr(gt, eq);
-
-        PhysicalPlan ip = new PhysicalPlan();
-        ip.add(p1);
-        ip.add(c2);
-        ip.add(gt);
-        ip.add(p3);
-        ip.add(c);
-        ip.add(eq);
-        ip.add(and);
-        ip.connect(p1, gt);
-        ip.connect(c2, gt);
-        ip.connect(p3, eq);
-        ip.connect(c, eq);
-        ip.connect(eq, and);
-        ip.connect(gt, and);
-
-        int[] ints = {0, 1, 1, 0, 1, 1};
-        TupleFactory tf = TupleFactory.getInstance();
-        DataBag inbag = BagFactory.getInstance().newDefaultBag();
-        for (int i = 0; i < ints.length; i+=2) {
-            Tuple t = tf.newTuple(2);
-            t.set(0, new Integer(ints[i]));
-            t.set(1, new Integer(ints[i+1]));
-            inbag.add(t);
-        }
-
-        PORead read = GenPhyOp.topReadOp(inbag);
-        POFilter filter = GenPhyOp.connectedFilterOp(read);
-        filter.setPlan(ip);
-
-        PhysicalPlan op = new PhysicalPlan();
-        op.add(filter);
-        op.add(read);
-        op.connect(read, filter);
-
-        DataBag outbag = BagFactory.getInstance().newDefaultBag();
-        Result res;
-        Tuple t = tf.newTuple();
-        do {
-            res = filter.getNext(t);
-            if (res.returnStatus == POStatus.STATUS_OK) {
-                outbag.add((Tuple)res.result);
+        
+        for (int i = 0; i < nullFlags.length; i++) {
+            // Build the inner expression
+            POProject p1 = GenPhyOp.exprProject(0);
+            ConstantExpression c2 = GenPhyOp.exprConst();
+            c2.setValue(new Integer(0));
+            GreaterThanExpr gt = GenPhyOp.compGreaterThanExpr(p1, c2, DataType.INTEGER);
+        
+            POProject p3 = GenPhyOp.exprProject(1);
+            ConstantExpression c = GenPhyOp.exprConst();
+            c.setValue(new Integer(1));
+            EqualToExpr eq = GenPhyOp.compEqualToExpr(p3, c, DataType.INTEGER);
+            POAnd and = GenPhyOp.compAndExpr(gt, eq);
+        
+            PhysicalPlan ip = new PhysicalPlan();
+            ip.add(p1);
+            ip.add(c2);
+            ip.add(gt);
+            ip.add(p3);
+            ip.add(c);
+            ip.add(eq);
+            ip.add(and);
+            ip.connect(p1, gt);
+            ip.connect(c2, gt);
+            ip.connect(p3, eq);
+            ip.connect(c, eq);
+            ip.connect(eq, and);
+            ip.connect(gt, and);
+        
+            int[] ints = {0, 1, 1, 0, 1, 1};
+            TupleFactory tf = TupleFactory.getInstance();
+            DataBag inbag = BagFactory.getInstance().newDefaultBag();
+            Random r = new Random();
+            for (int j = 0; j < ints.length; j+=2) {
+                // if we are testing with nulls
+                // introduce nulls randomly
+                if(nullFlags[i] == true) {
+                    int rand = r.nextInt(100);
+                    if(rand <= 20) {
+                        Tuple t = tf.newTuple(2);
+                        t.set(0, new Integer(ints[j]));
+                        t.set(1, null);
+                        inbag.add(t);
+                    } else if (rand > 20 && rand <= 40) {
+                        Tuple t = tf.newTuple(2);
+                        t.set(0, null);
+                        t.set(1, new Integer(ints[j+1]));
+                        inbag.add(t);
+                    } else if (rand > 40 && rand <= 60) {
+                        Tuple t = tf.newTuple(2);
+                        t.set(0, null);
+                        t.set(1, null);
+                        inbag.add(t);
+                    }
+                }
+                Tuple t = tf.newTuple(2);
+                t.set(0, new Integer(ints[j]));
+                t.set(1, new Integer(ints[j+1]));
+                inbag.add(t);
             }
-        } while (res.returnStatus == POStatus.STATUS_OK);
-        assertEquals(POStatus.STATUS_EOP, res.returnStatus);
-        assertEquals(1, outbag.size());
-        Iterator<Tuple> i = outbag.iterator();
-        assertTrue(i.hasNext());
-        t = i.next();
-        assertEquals(2, t.size());
-        assertTrue(t.get(0) instanceof Integer);
-        assertTrue(t.get(1) instanceof Integer);
-        Integer i1 = (Integer)t.get(0);
-        Integer i2 = (Integer)t.get(1);
-        assertEquals(1, (int)i1);
-        assertEquals(1, (int)i2);
+        
+            PORead read = GenPhyOp.topReadOp(inbag);
+            POFilter filter = GenPhyOp.connectedFilterOp(read);
+            filter.setPlan(ip);
+        
+            PhysicalPlan op = new PhysicalPlan();
+            op.add(filter);
+            op.add(read);
+            op.connect(read, filter);
+        
+            DataBag outbag = BagFactory.getInstance().newDefaultBag();
+            Result res;
+            Tuple t = tf.newTuple();
+            do {
+                res = filter.getNext(t);
+                if (res.returnStatus == POStatus.STATUS_OK) {
+                    outbag.add((Tuple)res.result);
+                }
+            } while (res.returnStatus == POStatus.STATUS_OK);
+            assertEquals(POStatus.STATUS_EOP, res.returnStatus);
+            assertEquals(1, outbag.size());
+            Iterator<Tuple> it = outbag.iterator();
+            assertTrue(it.hasNext());
+            t = it.next();
+            assertEquals(2, t.size());
+            assertTrue(t.get(0) instanceof Integer);
+            assertTrue(t.get(1) instanceof Integer);
+            Integer i1 = (Integer)t.get(0);
+            Integer i2 = (Integer)t.get(1);
+            assertEquals(1, (int)i1);
+            assertEquals(1, (int)i2);
+        }
     }
 
     public static void main(String[] args) {
diff --git a/test/org/apache/pig/test/TestFilterOpString.java b/test/org/apache/pig/test/TestFilterOpString.java
index 896212ec5..80891ca00 100644
--- a/test/org/apache/pig/test/TestFilterOpString.java
+++ b/test/org/apache/pig/test/TestFilterOpString.java
@@ -54,11 +54,17 @@ public class TestFilterOpString extends TestCase {
     public void testStringEq() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        int expectedCount = 0;
         for(int i = 0; i < LOOP_COUNT; i++) {
             if(i % 5 == 0) {
                 ps.println("a:" + i);
+                // test with nulls
+                ps.println("a:");
+                ps.println(":a");
+                ps.println(":");
             } else {
                 ps.println("ab:ab");
+                expectedCount++;
             }
         }
         ps.close();
@@ -69,23 +75,33 @@ public class TestFilterOpString extends TestCase {
         pig.registerQuery(query);
         Iterator it = pig.openIterator("A");
         tmpFile.delete();
+        int count = 0;
         while(it.hasNext()) {
             Tuple t = (Tuple)it.next();
             String first = t.get(0).toString();
             String second = t.get(1).toString();
+            count++;
             assertTrue(first.equals(second));
         }
+        assertEquals(expectedCount, count);
     }
     
     @Test
     public void testStringNeq() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        int expectedCount = 0;
         for(int i = 0; i < LOOP_COUNT; i++) {
             if(i % 5 == 0) {
                 ps.println("ab:ab");
-            } else {
+            } else if (i % 3 == 0) {
                 ps.println("ab:abc");
+                expectedCount++;
+            } else {
+                // test with nulls
+                ps.println(":");
+                ps.println("ab:");
+                ps.println(":ab");                
             }
         }
         ps.close();
@@ -96,23 +112,33 @@ public class TestFilterOpString extends TestCase {
         pig.registerQuery(query);
         Iterator it = pig.openIterator("A");
         tmpFile.delete();
+        int count = 0;
         while(it.hasNext()) {
             Tuple t = (Tuple)it.next();
             String first = t.get(0).toString();
             String second = t.get(1).toString();
             assertFalse(first.equals(second));
+            count++;
         }
+        assertEquals(expectedCount, count);
     }
 
     @Test
     public void testStringGt() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        int expectedCount = 0;
         for(int i = 0; i < LOOP_COUNT; i++) {
             if(i % 5 == 0) {
                 ps.println("b:a");
+                expectedCount++;
             } else {
                 ps.println("a:b");
+                // test with nulls
+                ps.println("a:");
+                ps.println(":b");
+                ps.println(":");
+                
             }
         }
         ps.close();
@@ -123,12 +149,15 @@ public class TestFilterOpString extends TestCase {
         pig.registerQuery(query);
         Iterator it = pig.openIterator("A");
         tmpFile.delete();
+        int count = 0;
         while(it.hasNext()) {
             Tuple t = (Tuple)it.next();
             String first = t.get(0).toString();
             String second = t.get(1).toString();
             assertTrue(first.compareTo(second) > 0);
+            count++;
         }
+        assertEquals(expectedCount, count);
     }
 
     
@@ -137,13 +166,20 @@ public class TestFilterOpString extends TestCase {
     public void testStringGte() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        int expectedCount = 0;
         for(int i = 0; i < LOOP_COUNT; i++) {
             if(i % 5 == 0) {
                 ps.println("b:a");
+                expectedCount++;
             }else if(i % 3 == 0) {
                 ps.println("b:b");
+                expectedCount++;
             } else {
                 ps.println("a:b");
+                // test with nulls
+                ps.println("a:");
+                ps.println(":b");
+                ps.println(":");
             }
         }
         ps.close();
@@ -155,23 +191,32 @@ public class TestFilterOpString extends TestCase {
         pig.registerQuery(query);
         Iterator it = pig.openIterator("A");
         tmpFile.delete();
+        int count = 0;
         while(it.hasNext()) {
             Tuple t = (Tuple)it.next();
             String first = t.get(0).toString();
             String second = t.get(1).toString();
             assertTrue(first.compareTo(second) >= 0);
+            count++;
         }
+        assertEquals(expectedCount, count);
     }
 
     @Test
     public void testStringLt() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        int expectedCount = 0;
         for(int i = 0; i < LOOP_COUNT; i++) {
             if(i % 5 == 0) {
                 ps.println("b:a");
+                // test with nulls
+                ps.println("a:");
+                ps.println(":b");
+                ps.println(":");
             } else {
                 ps.println("a:b");
+                expectedCount++;
             }
         }
         ps.close();
@@ -183,12 +228,15 @@ public class TestFilterOpString extends TestCase {
         pig.registerQuery(query);
         Iterator it = pig.openIterator("A");
         tmpFile.delete();
+        int count = 0;
         while(it.hasNext()) {
             Tuple t = (Tuple)it.next();
             String first = t.get(0).toString();
             String second = t.get(1).toString();
             assertTrue(first.compareTo(second) < 0);
+            count++;
         }
+        assertEquals(expectedCount, count);
     }
 
     @Test
@@ -196,13 +244,20 @@ public class TestFilterOpString extends TestCase {
         PigServer pig = new PigServer(initString);
         File tmpFile = File.createTempFile("test", "txt");
         PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+        int expectedCount = 0;
         for(int i = 0; i < LOOP_COUNT; i++) {
             if(i % 5 == 0) {
                 ps.println("b:a");
+                // test with nulls
+                ps.println("a:");
+                ps.println(":b");
+                ps.println(":");
             }else if(i % 3 == 0) {
                 ps.println("b:b");
+                expectedCount++;
             } else {
                 ps.println("a:b");
+                expectedCount++;
             }
         }
         ps.close();
@@ -214,12 +269,15 @@ public class TestFilterOpString extends TestCase {
         pig.registerQuery(query);
         Iterator it = pig.openIterator("A");
         tmpFile.delete();
+        int count = 0;
         while(it.hasNext()) {
             Tuple t = (Tuple)it.next();
             String first = t.get(0).toString();
             String second = t.get(1).toString();
             assertTrue(first.compareTo(second) <= 0);
+            count++;
         }
+        assertEquals(expectedCount, count);
     }
 
 }
diff --git a/test/org/apache/pig/test/TestForEach.java b/test/org/apache/pig/test/TestForEach.java
index 9c7fa21d8..3f53a6c35 100644
--- a/test/org/apache/pig/test/TestForEach.java
+++ b/test/org/apache/pig/test/TestForEach.java
@@ -63,7 +63,7 @@ public class TestForEach extends junit.framework.TestCase {
     @Before
     public void setUp() throws Exception {
         Random r = new Random();
-        db = GenRandomData.genRandSmallTupDataBag(r, 10, 100);
+        db = GenRandomData.genRandSmallTupDataBagWithNulls(r, 10, 100);
         projDB = TestHelper.projectBag(db,0);
         fe = GenPhyOp.topForEachOPWithPlan(0,db.iterator().next());
         POProject proj = GenPhyOp.exprProject();
diff --git a/test/org/apache/pig/test/TestForEachNestedPlan.java b/test/org/apache/pig/test/TestForEachNestedPlan.java
index 6a83ec917..2d42a57d9 100644
--- a/test/org/apache/pig/test/TestForEachNestedPlan.java
+++ b/test/org/apache/pig/test/TestForEachNestedPlan.java
@@ -26,6 +26,7 @@ import junit.framework.TestCase;
 import junit.framework.Assert;
 
 import java.util.Iterator;
+import java.util.Random;
 import java.io.File;
 import java.io.IOException;
 import java.text.DecimalFormat;
@@ -41,24 +42,27 @@ public class TestForEachNestedPlan extends TestCase {
         pig = new PigServer(initString) ;
     }
 
+    Boolean[] nullFlags = new Boolean[]{ false, true };
+    
     @Test
     public void testInnerOrderBy() throws Exception {
-        File tmpFile = genDataSetFile1() ;
-        pig.registerQuery("a = load 'file:" + tmpFile + "'; ") ;
-        pig.registerQuery("b = group a by $0; ");
-        pig.registerQuery("c = foreach b { "
-                        + "     c1 = order $1 by *; "
-                        +  "    generate flatten(c1); "
-                        + "};") ;
-        Iterator<Tuple> it = pig.openIterator("c");
-        Tuple t = null ;
-        int count = 0 ;
-        while(it.hasNext()) {
-            t = it.next() ;
-            System.out.println(count + ":" + t) ;
-            count++ ;
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Running testInnerOrderBy with nullFlags set to :" + nullFlags[i]);
+            File tmpFile = genDataSetFile1(nullFlags[i]);
+            pig.registerQuery("a = load 'file:" + tmpFile + "'; ");
+            pig.registerQuery("b = group a by $0; ");
+            pig.registerQuery("c = foreach b { " + "     c1 = order $1 by *; "
+                    + "    generate flatten(c1); " + "};");
+            Iterator<Tuple> it = pig.openIterator("c");
+            Tuple t = null;
+            int count = 0;
+            while (it.hasNext()) {
+                t = it.next();
+                System.out.println(count + ":" + t);
+                count++;
+            }
+            Assert.assertEquals(count, 30);
         }
-        Assert.assertEquals(count, 30);
     }
 
 
@@ -87,16 +91,23 @@ public class TestForEachNestedPlan extends TestCase {
     /***
      * For generating a sample dataset
      */
-    private File genDataSetFile1() throws IOException {
+    private File genDataSetFile1(boolean withNulls) throws IOException {
 
         int dataLength = 30;
         String[][] data = new String[dataLength][] ;
 
         DecimalFormat formatter = new DecimalFormat("0000000");
 
+        Random r = new Random();
+        
         for (int i = 0; i < dataLength; i++) {
             data[i] = new String[2] ;
-            data[i][0] = formatter.format(i % 10);
+            // inject nulls randomly
+            if(withNulls && r.nextInt(dataLength) < 0.3 * dataLength) {
+                data[i][0] = "";
+            } else {
+                data[i][0] = formatter.format(i % 10);
+            }
             data[i][1] = formatter.format((dataLength - i)/2);
         }
 
diff --git a/test/org/apache/pig/test/TestGTOrEqual.java b/test/org/apache/pig/test/TestGTOrEqual.java
index f699e01b3..fb0d4da84 100644
--- a/test/org/apache/pig/test/TestGTOrEqual.java
+++ b/test/org/apache/pig/test/TestGTOrEqual.java
@@ -92,6 +92,12 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+    public void testIntegerAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.INTEGER,  new Integer(1) );
+    }
+    
     @Test
     public void testLongGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -107,6 +113,7 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    
     @Test
     public void testLongLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -137,6 +144,12 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+    public void testLongAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.LONG,  new Long(1L) );
+    }
+
     @Test
     public void testFloatGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -182,6 +195,13 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+    public void testFloatAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.FLOAT,  new Float(1.0f) );
+    }
+
+    
     @Test
     public void testDoubleGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -227,6 +247,13 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+    public void testDoubleAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.DOUBLE,  new Double(1.0) );
+    }
+
+
     @Test
     public void testStringGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -272,6 +299,12 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+    public void testStringAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.CHARARRAY,  new String("b") );
+    }
+
     @Test
     public void testDataByteArrayGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -317,8 +350,55 @@ public class TestGTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    @Test
+    public void testDataByteArrayAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.BYTEARRAY,  new DataByteArray("b") );
+    }
 
 
+	public <U> void checkNullValues( byte operandType, U value ) throws Exception {
+		
+        ConstantExpression lt = GenPhyOp.exprConst();
+        ConstantExpression rt = GenPhyOp.exprConst();
+        GTOrEqualToExpr g = GenPhyOp.compGTOrEqualToExpr();
+
+        // test with null in lhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue( value );
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        Result r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+        
+        // test with null in rhs
+        g.setOperandType(operandType);
+        lt.setValue( value );
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+   
+        
+        // test with null in lhs and rhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+ 
+
+    }
 
 
 
diff --git a/test/org/apache/pig/test/TestGreaterThan.java b/test/org/apache/pig/test/TestGreaterThan.java
index 32a77912d..897368b38 100644
--- a/test/org/apache/pig/test/TestGreaterThan.java
+++ b/test/org/apache/pig/test/TestGreaterThan.java
@@ -29,6 +29,7 @@ import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators.ConstantExpression;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOperators.GreaterThanExpr;
+
 import org.apache.pig.test.utils.GenPhyOp;
 import org.apache.pig.test.utils.GenRandomData;
 import org.junit.After;
@@ -62,6 +63,9 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+     
+    
+     
     @Test
     public void testIntegerLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -77,7 +81,8 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+ 
+	@Test
     public void testIntegerEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Integer(1));
@@ -92,20 +97,28 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
-    public void testLongGt() throws Exception {
-        ConstantExpression lt = GenPhyOp.exprConst();
-        lt.setValue(new Long(1L));
-        ConstantExpression rt = GenPhyOp.exprConst();
-        rt.setValue(new Long(0L));
-        GreaterThanExpr g = GenPhyOp.compGreaterThanExpr();
-        g.setLhs(lt);
-        g.setRhs(rt);
-        g.setOperandType(DataType.LONG);
-        Result r = g.getNext(new Boolean(true));
-        assertEquals(POStatus.STATUS_OK, r.returnStatus);
-        assertTrue((Boolean)r.result);
-    }
+	@Test
+	public void testIntegerAndNullValues() throws Exception {
+	    	
+	    checkNullValues(  DataType.INTEGER,  new Integer(1) );
+	        
+	}
+
+	@Test
+	public void testLongGt() throws Exception {
+	    ConstantExpression lt = GenPhyOp.exprConst();
+	    lt.setValue(new Long(1L));
+	    ConstantExpression rt = GenPhyOp.exprConst();
+	    rt.setValue(new Long(0L));
+	    GreaterThanExpr g = GenPhyOp.compGreaterThanExpr();
+	    g.setLhs(lt);
+	    g.setRhs(rt);
+	    g.setOperandType(DataType.LONG);
+	    Result r = g.getNext(new Boolean(true));
+	    assertEquals(POStatus.STATUS_OK, r.returnStatus);
+	    assertTrue((Boolean)r.result);
+	}
+
 
     @Test
     public void testLongLt() throws Exception {
@@ -122,13 +135,15 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+  
+    
+  	@Test
     public void testLongEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Long(1L));
         ConstantExpression rt = GenPhyOp.exprConst();
         rt.setValue(new Long(1L));
-        GreaterThanExpr g = GenPhyOp.compGreaterThanExpr();
+	    GreaterThanExpr g = GenPhyOp.compGreaterThanExpr();
         g.setLhs(lt);
         g.setRhs(rt);
         g.setOperandType(DataType.LONG);
@@ -137,7 +152,15 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+
+	@Test
+    public void testLongAndNullValues() throws Exception {
+		
+	    checkNullValues(  DataType.LONG,  new Long(1) );
+
+    }
+
+	@Test
     public void testFloatGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Float(1.0f));
@@ -152,7 +175,8 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
-    @Test
+
+	@Test
     public void testFloatLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Float(0.0f));
@@ -167,7 +191,8 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+ 
+	@Test
     public void testFloatEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Float(1.0f));
@@ -183,6 +208,12 @@ public class TestGreaterThan extends junit.framework.TestCase {
     }
 
     @Test
+	public void testFloatAndNullValues() throws Exception {
+	    checkNullValues(   DataType.FLOAT,  new Float(1.0f) );
+	    
+	}
+
+	@Test
     public void testDoubleGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Double(1.0));
@@ -197,7 +228,8 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
-    @Test
+
+	@Test
     public void testDoubleLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Double(0.0));
@@ -212,7 +244,7 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+	@Test
     public void testDoubleEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Double(1.0));
@@ -228,6 +260,12 @@ public class TestGreaterThan extends junit.framework.TestCase {
     }
 
     @Test
+	public void testDoubleAndNullValues() throws Exception {
+	    checkNullValues(   DataType.DOUBLE,  new Double(1.0) );
+	    
+	}
+    
+	@Test
     public void testStringGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new String("b"));
@@ -242,7 +280,7 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
-    @Test
+ 	@Test
     public void testStringLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new String("a"));
@@ -257,7 +295,7 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+	@Test
     public void testStringEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new String("b"));
@@ -272,7 +310,14 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
-    @Test
+	   @Test
+		public void testStringAndNullValues() throws Exception {
+		    checkNullValues(   DataType.CHARARRAY,  new String("b") );
+		    
+		}
+
+
+	@Test
     public void testDataByteArrayGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new DataByteArray("b"));
@@ -287,7 +332,8 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
-    @Test
+
+	@Test
     public void testDataByteArrayLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new DataByteArray("a"));
@@ -300,9 +346,11 @@ public class TestGreaterThan extends junit.framework.TestCase {
         Result r = g.getNext(new Boolean(true));
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertFalse((Boolean)r.result);
+	
     }
 
-    @Test
+
+	@Test
     public void testDataByteArrayEq() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new DataByteArray("b"));
@@ -317,13 +365,53 @@ public class TestGreaterThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+	   @Test
+		public void testDataByteArrayAndNullValues() throws Exception {
+		    checkNullValues(   DataType.BYTEARRAY,  new DataByteArray("b") );
+		    
+		}
+	
+	public <U> void checkNullValues( byte operandType, U value ) throws Exception {
+		
+        ConstantExpression lt = GenPhyOp.exprConst();
+        ConstantExpression rt = GenPhyOp.exprConst();
+        GreaterThanExpr g = GenPhyOp.compGreaterThanExpr();
 
+        // test with null in lhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue( value );
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        Result r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+        
+        // test with null in rhs
+        g.setOperandType(operandType);
+        lt.setValue( value );
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+   
+        
+        // test with null in lhs and rhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+ 
 
+    }
 
-
-
-
-
-
-
-}
+ }
diff --git a/test/org/apache/pig/test/TestInfixArithmetic.java b/test/org/apache/pig/test/TestInfixArithmetic.java
index 844900bc3..bd6779930 100644
--- a/test/org/apache/pig/test/TestInfixArithmetic.java
+++ b/test/org/apache/pig/test/TestInfixArithmetic.java
@@ -21,6 +21,7 @@ import java.io.File;
 import java.io.FileOutputStream;
 import java.io.PrintStream;
 import java.util.Iterator;
+import java.util.Random;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -33,6 +34,8 @@ import org.apache.pig.builtin.PigStorage;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
 
+
+
 import junit.framework.TestCase;
 
 public class TestInfixArithmetic extends TestCase {
@@ -49,90 +52,144 @@ public class TestInfixArithmetic extends TestCase {
     protected void setUp() throws Exception {
         pig = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());
     }
+    
+    Boolean[] nullFlags = new Boolean[] { false, true };
 
     @Test
     public void testAdd() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            ps.println(i + ":" + i);
-        }
-        ps.close();
-        String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 + $1, $1;";
-        log.info(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("A");
-        tmpFile.delete();
-        while(it.hasNext()) {
-            Tuple t = (Tuple)it.next();
-            Double first = DataType.toDouble(t.get(0));
-            Double second = DataType.toDouble(t.get(1));
-            assertTrue(second.equals(first + first));
+        
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing with nulls: " + nullFlags[i]);
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            generateInput(ps, nullFlags[i]);
+            String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 + $1, $1;";
+            log.info(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("A");
+            tmpFile.delete();
+            while(it.hasNext()) {
+                Tuple t = (Tuple)it.next();
+                Double first = (t.get(0) == null ? null :DataType.toDouble(t.get(0)));
+                Double second = (t.get(1) == null ? null :DataType.toDouble(t.get(1)));
+                Double third = (t.get(2) == null ? null :DataType.toDouble(t.get(2)));
+                if(first != null && third != null) {
+                    assertTrue(second.equals(first + first));
+                } else {
+                    assertEquals(null, second);
+                }
+                    
+            }
         }
+        
+        
     }
  
     @Test
     public void testSubtract() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            ps.println(i + ":" + i);
-        }
-        ps.close();
-        String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 - $1, $1 ;";
-        log.info(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("A");
-        tmpFile.delete();
-        while(it.hasNext()) {
-            Tuple t = (Tuple)it.next();
-            Double second = DataType.toDouble(t.get(1));
-            assertTrue(second.equals(0.0));
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing with nulls: " + nullFlags[i]);
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            generateInput(ps, nullFlags[i]);
+            String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 - $1, $1 ;";
+            log.info(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("A");
+            tmpFile.delete();
+            while(it.hasNext()) {
+                Tuple t = (Tuple)it.next();
+                Double first = (t.get(0) == null ? null :DataType.toDouble(t.get(0)));
+                Double second = (t.get(1) == null ? null :DataType.toDouble(t.get(1)));
+                Double third = (t.get(2) == null ? null :DataType.toDouble(t.get(2)));
+                if(first != null && third != null) {
+                    assertTrue(second.equals(0.0));
+                } else {
+                    assertEquals(null, second);
+                }
+                    
+            }
         }
     }
  
     @Test
     public void testMultiply() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 0; i < LOOP_COUNT; i++) {
-            ps.println(i + ":" + i);
-        }
-        ps.close();
-        String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 * $1, $1 ;";
-        log.info(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("A");
-        tmpFile.delete();
-        while(it.hasNext()) {
-            Tuple t = (Tuple)it.next();
-            Double first = DataType.toDouble(t.get(0));
-            Double second = DataType.toDouble(t.get(1));
-            assertTrue(second.equals(first * first));
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing with nulls: " + nullFlags[i]);
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            generateInput(ps, nullFlags[i]);
+            String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 * $1, $1 ;";
+            log.info(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("A");
+            tmpFile.delete();
+            while(it.hasNext()) {
+                Tuple t = (Tuple)it.next();
+                Double first = (t.get(0) == null ? null :DataType.toDouble(t.get(0)));
+                Double second = (t.get(1) == null ? null :DataType.toDouble(t.get(1)));
+                Double third = (t.get(2) == null ? null :DataType.toDouble(t.get(2)));
+                if(first != null && third != null) {
+                    assertTrue(second.equals(first * first));
+                } else {
+                    assertEquals(null, second);
+                }
+                    
+            }
         }
     }
     
     @Test
     public void testDivide() throws Throwable {
         File tmpFile = File.createTempFile("test", "txt");
-        PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
-        for(int i = 1; i < LOOP_COUNT; i++) {
-            ps.println(i + ":" + i);
-        }
-        ps.close();
-        String query = "A =  foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 / $1, $1;";
-        log.info(query);
-        pig.registerQuery(query);
-        Iterator it = pig.openIterator("A");
-        tmpFile.delete();
-        while(it.hasNext()) {
-            Tuple t = (Tuple)it.next();
-            Double second = DataType.toDouble(t.get(1));
-            assertTrue(second.equals(1.0));
+        for (int i = 0; i < nullFlags.length; i++) {
+            System.err.println("Testing with nulls: " + nullFlags[i]);
+            PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+            generateInput(ps, nullFlags[i]);
+            String query = "A = foreach (load 'file:" + tmpFile + "' using " + PigStorage.class.getName() + "(':')) generate $0, $0 / $1, $1 ;";
+            log.info(query);
+            pig.registerQuery(query);
+            Iterator it = pig.openIterator("A");
+            tmpFile.delete();
+            while(it.hasNext()) {
+                Tuple t = (Tuple)it.next();
+                Double first = (t.get(0) == null ? null :DataType.toDouble(t.get(0)));
+                Double second = (t.get(1) == null ? null :DataType.toDouble(t.get(1)));
+                Double third = (t.get(2) == null ? null :DataType.toDouble(t.get(2)));
+                if(first != null && third != null) {
+                    assertTrue(second.equals(1.0));
+                } else {
+                    assertEquals(null, second);
+                }
+                    
+            }
         }
+        
     }
     
     
+    private void generateInput(PrintStream ps, boolean withNulls) {
+        if(withNulls) {
+            // inject nulls randomly
+            for(int i = 1; i < LOOP_COUNT; i++) {
+                int rand = new Random().nextInt(LOOP_COUNT);
+                if(rand <= (0.2 * LOOP_COUNT) ) {
+                    ps.println(":"+i);
+                } else if (rand > (0.2 * LOOP_COUNT) && rand <= (0.4 * LOOP_COUNT)) {
+                    ps.println(i+":");
+                } else if (rand > (0.2 * LOOP_COUNT) && rand <= (0.4 * LOOP_COUNT)) {
+                    ps.println(":");
+                } else {
+                    ps.println(i + ":" + i);
+                }            
+            }
+        } else {
+            for(int i = 1; i < LOOP_COUNT; i++) {
+                ps.println(i + ":" + i);
+            }
+        }
+        ps.close();
+    }
     
     
 }
diff --git a/test/org/apache/pig/test/TestLTOrEqual.java b/test/org/apache/pig/test/TestLTOrEqual.java
index 19af60799..1f05f209c 100644
--- a/test/org/apache/pig/test/TestLTOrEqual.java
+++ b/test/org/apache/pig/test/TestLTOrEqual.java
@@ -92,6 +92,11 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+	@Test
+	public void testIntegerAndNullValues() throws Exception {
+		checkNullValues(  DataType.INTEGER, new Integer(1) );		    
+	}
+
     @Test
     public void testLongGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -137,6 +142,11 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+	@Test
+	public void testLongAndNullValues() throws Exception {
+		checkNullValues(  DataType.LONG, new Long(1L) );		    
+	}
+
     @Test
     public void testFloatGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -182,6 +192,12 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+    
+	@Test
+	public void testFloatAndNullValues() throws Exception {
+		checkNullValues(  DataType.FLOAT, new Float(1.0f) );		    
+	}
+
     @Test
     public void testDoubleGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -197,6 +213,8 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    
+
     @Test
     public void testDoubleLt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -227,6 +245,11 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+	@Test
+	public void testDoubleAndNullValues() throws Exception {
+		checkNullValues(  DataType.DOUBLE, new Double(1.0) );		    
+	}
+
     @Test
     public void testStringGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -272,6 +295,12 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+	@Test
+	public void testStringAndNullValues() throws Exception {
+		checkNullValues(  DataType.CHARARRAY, new String("b") );		    
+	}
+
+    
     @Test
     public void testDataByteArrayGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -317,7 +346,54 @@ public class TestLTOrEqual extends junit.framework.TestCase {
         assertTrue((Boolean)r.result);
     }
 
+	@Test
+	public void testDataByteArrayAndNullValues() throws Exception {
+		checkNullValues(  DataType.BYTEARRAY, new DataByteArray("b") );		    
+	}
+
+	public <U> void checkNullValues( byte operandType, U value ) throws Exception {
+		
+        ConstantExpression lt = GenPhyOp.exprConst();
+        ConstantExpression rt = GenPhyOp.exprConst();
+        LTOrEqualToExpr g = GenPhyOp.compLTOrEqualToExpr();
+
+
+        // test with null in lhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue( value );
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        Result r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+        
+        // test with null in rhs
+        g.setOperandType(operandType);
+        lt.setValue( value );
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+   
+        
+        // test with null in lhs and rhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+ 
 
+    }
 
 
 
diff --git a/test/org/apache/pig/test/TestLessThan.java b/test/org/apache/pig/test/TestLessThan.java
index ca4104f5c..1c6cfd7ab 100644
--- a/test/org/apache/pig/test/TestLessThan.java
+++ b/test/org/apache/pig/test/TestLessThan.java
@@ -93,6 +93,12 @@ public class TestLessThan extends junit.framework.TestCase {
     }
 
     @Test
+    public void testIntegerAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.INTEGER,  new Integer(1) );
+    }  
+    
+   	@Test
     public void testLongGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Long(1L));
@@ -137,6 +143,14 @@ public class TestLessThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    
+    @Test
+    public void testLongAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.LONG,  new Long(1L) );
+    }  
+    
+    
     @Test
     public void testFloatGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -182,6 +196,13 @@ public class TestLessThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    
+    @Test
+    public void testFloatAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.FLOAT,  new Float(1.0f) );
+    }  
+
     @Test
     public void testDoubleGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -227,6 +248,12 @@ public class TestLessThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    @Test
+    public void testDoubleAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.DOUBLE, new Double(1.0) );
+    }  
+
     @Test
     public void testStringGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -272,6 +299,12 @@ public class TestLessThan extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    @Test
+    public void testStringAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.CHARARRAY, new String("b") );
+    }  
+
     @Test
     public void testDataByteArrayGt() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -316,5 +349,55 @@ public class TestLessThan extends junit.framework.TestCase {
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertFalse((Boolean)r.result);
     }
+ 
+    
+    @Test
+    public void testDataByteArrayAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.BYTEARRAY, new DataByteArray("b") );
+    }  
+
+	public <U> void checkNullValues( byte operandType, U value ) throws Exception {
+		
+        ConstantExpression lt = GenPhyOp.exprConst();
+        ConstantExpression rt = GenPhyOp.exprConst();
+        LessThanExpr g = GenPhyOp.compLessThanExpr();
+
+        // test with null in lhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue( value );
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        Result r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+        
+        // test with null in rhs
+        g.setOperandType(operandType);
+        lt.setValue( value );
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+   
+        
+        // test with null in lhs and rhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+ 
+
+    }
 
 }
diff --git a/test/org/apache/pig/test/TestMod.java b/test/org/apache/pig/test/TestMod.java
index 79e347b58..c2fa0b280 100644
--- a/test/org/apache/pig/test/TestMod.java
+++ b/test/org/apache/pig/test/TestMod.java
@@ -71,6 +71,17 @@ public class TestMod extends TestCase{
                 rt.setValue(inpdb2);
                 Result resdb = op.getNext(inpdb1);
                 assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpdb2);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpdb1);
+                rt.setValue(null);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BOOLEAN:
                 Boolean inpb1 = r.nextBoolean();
@@ -79,6 +90,17 @@ public class TestMod extends TestCase{
                 rt.setValue(inpb2);
                 Result resb = op.getNext(inpb1);
                 assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpb2);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpb1);
+                rt.setValue(null);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BYTEARRAY: {
                 DataByteArray inpba1 = GenRandomData.genRandDBA(r);
@@ -89,6 +111,17 @@ public class TestMod extends TestCase{
                 //DataByteArray expected = new DataByteArray(inpba1.toString() + inpba2.toString());
                 //assertEquals(expected, (DataByteArray)resba.result);
                 assertEquals(POStatus.STATUS_ERR, resba.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpba2);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpba1);
+                rt.setValue(null);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.CHARARRAY: {
@@ -100,6 +133,17 @@ public class TestMod extends TestCase{
                 /*String expected = new String(inps1 + inps2);
                 assertEquals(expected, (String)ress.result);*/
                 assertEquals(POStatus.STATUS_ERR, ress.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inps2);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inps1);
+                rt.setValue(null);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.DOUBLE: {
@@ -109,6 +153,17 @@ public class TestMod extends TestCase{
                 rt.setValue(inpd2);
                 Result resd = op.getNext(inpd1);
                 assertEquals(POStatus.STATUS_ERR, resd.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpd2);
+                resd = op.getNext(inpd1);
+                assertEquals(POStatus.STATUS_ERR, resd.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpd1);
+                rt.setValue(null);
+                resd = op.getNext(inpd1);
+                assertEquals(POStatus.STATUS_ERR, resd.returnStatus);
                 break;
             }
             case DataType.FLOAT: {
@@ -118,6 +173,17 @@ public class TestMod extends TestCase{
                 rt.setValue(inpf2);
                 Result resf = op.getNext(inpf1);
                 assertEquals(POStatus.STATUS_ERR, resf.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpf2);
+                resf = op.getNext(inpf1);
+                assertEquals(POStatus.STATUS_ERR, resf.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpf1);
+                rt.setValue(null);
+                resf = op.getNext(inpf1);
+                assertEquals(POStatus.STATUS_ERR, resf.returnStatus);
                 break;
             }
             case DataType.INTEGER: {
@@ -128,6 +194,17 @@ public class TestMod extends TestCase{
                 Result resi = op.getNext(inpi1);
                 Integer expected = new Integer(inpi1 % inpi2);
                 assertEquals(expected, (Integer) resi.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpi2);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
+                // test with null in rhs
+                lt.setValue(inpi1);
+                rt.setValue(null);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
                 break;
             }
             case DataType.LONG: {
@@ -138,6 +215,17 @@ public class TestMod extends TestCase{
                 Result resl = op.getNext(inpl1);
                 Long expected = new Long(inpl1 % inpl2);
                 assertEquals(expected, (Long)resl.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpl2);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
+                // test with null in rhs
+                lt.setValue(inpl1);
+                rt.setValue(null);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
                 break;
             }
             case DataType.MAP: {
@@ -147,6 +235,17 @@ public class TestMod extends TestCase{
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
                 assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpm2);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpm1);
+                rt.setValue(null);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
                 break;
             }
             case DataType.TUPLE: {
@@ -156,6 +255,17 @@ public class TestMod extends TestCase{
                 rt.setValue(inpt2);
                 Result rest = op.getNext(inpt1);
                 assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpt2);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpt1);
+                rt.setValue(null);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
                 break;
             }
             }
diff --git a/test/org/apache/pig/test/TestMultiply.java b/test/org/apache/pig/test/TestMultiply.java
index d4dd5a87c..274c1ca9b 100644
--- a/test/org/apache/pig/test/TestMultiply.java
+++ b/test/org/apache/pig/test/TestMultiply.java
@@ -56,7 +56,7 @@ public class TestMultiply extends TestCase{
         byte[] types = { DataType.BAG, DataType.BOOLEAN, DataType.BYTEARRAY, DataType.CHARARRAY, 
                 DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG, DataType.MAP, DataType.TUPLE};
         //Map<Byte,String> map = GenRandomData.genTypeToNameMap();
-        System.out.println("Testing ADD operator");
+        System.out.println("Testing Multiply operator");
         for(byte type : types) {
             lt.setResultType(type);
             rt.setResultType(type);
@@ -71,6 +71,17 @@ public class TestMultiply extends TestCase{
                 rt.setValue(inpdb2);
                 Result resdb = op.getNext(inpdb1);
                 assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpdb2);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpdb1);
+                rt.setValue(null);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BOOLEAN:
                 Boolean inpb1 = r.nextBoolean();
@@ -79,6 +90,17 @@ public class TestMultiply extends TestCase{
                 rt.setValue(inpb2);
                 Result resb = op.getNext(inpb1);
                 assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpb2);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpb1);
+                rt.setValue(null);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BYTEARRAY: {
                 DataByteArray inpba1 = GenRandomData.genRandDBA(r);
@@ -89,6 +111,17 @@ public class TestMultiply extends TestCase{
                 //DataByteArray expected = new DataByteArray(inpba1.toString() + inpba2.toString());
                 //assertEquals(expected, (DataByteArray)resba.result);
                 assertEquals(POStatus.STATUS_ERR, resba.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpba2);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpba1);
+                rt.setValue(null);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.CHARARRAY: {
@@ -100,6 +133,17 @@ public class TestMultiply extends TestCase{
                 /*String expected = new String(inps1 + inps2);
                 assertEquals(expected, (String)ress.result);*/
                 assertEquals(POStatus.STATUS_ERR, ress.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inps2);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inps1);
+                rt.setValue(null);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.DOUBLE: {
@@ -110,6 +154,17 @@ public class TestMultiply extends TestCase{
                 Result resd = op.getNext(inpd1);
                 Double expected = new Double(inpd1 * inpd2);
                 assertEquals(expected, (Double)resd.result);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpd2);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
+                // test with null in rhs
+                lt.setValue(inpd1);
+                rt.setValue(null);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
                 break;
             }
             case DataType.FLOAT: {
@@ -120,6 +175,17 @@ public class TestMultiply extends TestCase{
                 Result resf = op.getNext(inpf1);
                 Float expected = new Float(inpf1 * inpf2);
                 assertEquals(expected, (Float)resf.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpf2);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
+                // test with null in rhs
+                lt.setValue(inpf1);
+                rt.setValue(null);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
                 break;
             }
             case DataType.INTEGER: {
@@ -130,6 +196,17 @@ public class TestMultiply extends TestCase{
                 Result resi = op.getNext(inpi1);
                 Integer expected = new Integer(inpi1 * inpi2);
                 assertEquals(expected, (Integer) resi.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpi2);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
+                // test with null in rhs
+                lt.setValue(inpi1);
+                rt.setValue(null);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
                 break;
             }
             case DataType.LONG: {
@@ -140,6 +217,17 @@ public class TestMultiply extends TestCase{
                 Result resl = op.getNext(inpl1);
                 Long expected = new Long(inpl1 * inpl2);
                 assertEquals(expected, (Long)resl.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpl2);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
+                // test with null in rhs
+                lt.setValue(inpl1);
+                rt.setValue(null);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
                 break;
             }
             case DataType.MAP: {
@@ -149,6 +237,17 @@ public class TestMultiply extends TestCase{
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
                 assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpm2);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpm1);
+                rt.setValue(null);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
                 break;
             }
             case DataType.TUPLE: {
@@ -158,6 +257,17 @@ public class TestMultiply extends TestCase{
                 rt.setValue(inpt2);
                 Result rest = op.getNext(inpt1);
                 assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpt2);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpt1);
+                rt.setValue(null);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
                 break;
             }
             }
diff --git a/test/org/apache/pig/test/TestNotEqualTo.java b/test/org/apache/pig/test/TestNotEqualTo.java
index 40f50762a..0c512020e 100644
--- a/test/org/apache/pig/test/TestNotEqualTo.java
+++ b/test/org/apache/pig/test/TestNotEqualTo.java
@@ -78,6 +78,12 @@ public class TestNotEqualTo extends junit.framework.TestCase {
     }
 
     @Test
+	public void testIntegerAndNullValues() throws Exception {
+		
+		checkNullValues( DataType.INTEGER,  new Integer(1) );
+	}
+
+	@Test
     public void testLongNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
         lt.setValue(new Long(1L));
@@ -107,6 +113,13 @@ public class TestNotEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+
+    @Test
+    public void testLongAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.LONG,  new Long(1L) );
+    }
+
     @Test
     public void testFloatNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -137,6 +150,13 @@ public class TestNotEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+
+    @Test
+    public void testFloatAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.FLOAT,  new Float(1.0f) );
+    }
+
     @Test
     public void testDoubleNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -167,6 +187,13 @@ public class TestNotEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+
+    @Test
+    public void testDoubleAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.DOUBLE,  new Double(1.0) );
+    }
+
     @Test
     public void testStringNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -197,6 +224,12 @@ public class TestNotEqualTo extends junit.framework.TestCase {
         assertFalse((Boolean)r.result);
     }
 
+    @Test
+    public void testStringAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.CHARARRAY,  new String("b") );
+    }
+
     @Test
     public void testDataByteArrayNe() throws Exception {
         ConstantExpression lt = GenPhyOp.exprConst();
@@ -226,4 +259,55 @@ public class TestNotEqualTo extends junit.framework.TestCase {
         assertEquals(POStatus.STATUS_OK, r.returnStatus);
         assertFalse((Boolean)r.result);
     }
+    
+
+    @Test
+    public void testDataByteArrayAndNullValues() throws Exception {
+    	
+    	checkNullValues( DataType.BYTEARRAY,  new DataByteArray("b") );
+    }
+
+	public <U> void checkNullValues( byte operandType, U value ) throws Exception {
+		
+        ConstantExpression lt = GenPhyOp.exprConst();
+        ConstantExpression rt = GenPhyOp.exprConst();
+        NotEqualToExpr g = GenPhyOp.compNotEqualToExpr();
+
+        // test with null in lhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue( value );
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        Result r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+        
+        // test with null in rhs
+        g.setOperandType(operandType);
+        lt.setValue( value );
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+   
+        
+        // test with null in lhs and rhs
+        g.setOperandType(operandType);
+        lt.setValue(null);
+        rt.setValue(null);
+        g.setLhs(lt);
+        g.setRhs(rt);
+       
+        r = g.getNext(new Boolean(true));
+        assertEquals(POStatus.STATUS_NULL, r.returnStatus);
+        assertEquals(null, (Boolean)r.result);
+ 
+
+    }
+
 }
diff --git a/test/org/apache/pig/test/TestNull.java b/test/org/apache/pig/test/TestNull.java
index bc79c2163..b12c253a5 100644
--- a/test/org/apache/pig/test/TestNull.java
+++ b/test/org/apache/pig/test/TestNull.java
@@ -55,6 +55,7 @@ public class TestNull extends junit.framework.TestCase {
         lt.attachInput(dummyTuple);
         POIsNull isNullExpr = (POIsNull) GenPhyOp.compIsNullExpr();
         isNullExpr.setExpr(lt);
+        isNullExpr.setOperandType(type);
 
         Object inp1;
         Result res;
@@ -62,114 +63,168 @@ public class TestNull extends junit.framework.TestCase {
         switch (type) {
         case DataType.BAG:
             inp1 = GenRandomData.genRandSmallTupDataBag(r, 10, 100);
-            res = isNullExpr.getNext((DataBag) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((DataBag) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!res.result.equals(ret))
+                return false;
+            // set the input to null and test
+            lt.setValue((DataBag)null);
+            res = isNullExpr.getNext((Boolean) null);
+            if (!res.result.equals(true))
+                return false;
+            return true;
         case DataType.BOOLEAN:
             inp1 = r.nextBoolean();
-            res = isNullExpr.getNext((Boolean) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Boolean) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Boolean)null);
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(true)))
+                return false;
+            return true;
         case DataType.BYTEARRAY:
             inp1 = GenRandomData.genRandDBA(r);
-            res = isNullExpr.getNext((DataByteArray) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((DataByteArray) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((DataByteArray)null);
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(true)))
+                return false;
+            return true;
         case DataType.CHARARRAY:
             inp1 = GenRandomData.genRandString(r);
-            res = isNullExpr.getNext((String) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((String) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((String)null);
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(true)))
+                return false;
+            return true;
         case DataType.DOUBLE:
             inp1 = r.nextDouble();
-            res = isNullExpr.getNext((Double) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Double) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Double)null);
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(true)))
+                return false;
+            return true;
         case DataType.FLOAT:
             inp1 = r.nextFloat();
-            res = isNullExpr.getNext((Float) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Float) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Float)null);
+            res = isNullExpr.getNext((Boolean) null);
+            if (!res.result.equals(true))
+                return false;
+            return true;
         case DataType.INTEGER:
             inp1 = r.nextInt();
-            res = isNullExpr.getNext((Integer) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Integer) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Integer)null);
+            res = isNullExpr.getNext((Boolean) null);
+            if (!res.result.equals(true))
+                return false;
+            return true;
         case DataType.LONG:
             inp1 = r.nextLong();
-            res = isNullExpr.getNext((Long) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Long) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Long)null);
+            res = isNullExpr.getNext((Boolean) null);
+            if (!res.result.equals(true))
+                return false;
+            return true;
         case DataType.MAP:
             inp1 = GenRandomData.genRandMap(r, 10);
-            res = isNullExpr.getNext((Map) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Map) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Map)null);
+            res = isNullExpr.getNext((Boolean) null);
+            if (!res.result.equals(true))
+                return false;
+            return true;
         case DataType.TUPLE:
             inp1 = GenRandomData.genRandSmallBagTuple(r, 10, 100);
-            res = isNullExpr.getNext((Tuple) inp1);
+            res = isNullExpr.getNext((Boolean) null);
             if ((Boolean) res.result != true)
                 return false;
             lt.setValue(inp1);
-            res = isNullExpr.getNext((Tuple) inp1);
-            ret = (DataType.compare(inp1, null) != 1);
-            if (res.result.equals(ret))
-                return true;
-            return false;
+            res = isNullExpr.getNext((Boolean) null);
+            ret = (DataType.compare(inp1, null) == 0);
+            if (!(res.result.equals(ret)))
+                return false;
+            // set the input to null and test
+            lt.setValue((Tuple)null);
+            res = isNullExpr.getNext((Boolean) null);
+            if (!res.result.equals(true))
+                return false;
+            return true;
         }
         return true;
     }
diff --git a/test/org/apache/pig/test/TestPOBinCond.java b/test/org/apache/pig/test/TestPOBinCond.java
index db223952a..f53d57671 100644
--- a/test/org/apache/pig/test/TestPOBinCond.java
+++ b/test/org/apache/pig/test/TestPOBinCond.java
@@ -19,11 +19,15 @@ package org.apache.pig.test;
 
 import java.util.Iterator;
 import java.util.Random;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.PrintStream;
 
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataType;
+import org.apache.pig.data.DefaultBagFactory;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
 import org.apache.pig.impl.plan.OperatorKey;
@@ -42,20 +46,99 @@ import junit.framework.TestCase;
 public class TestPOBinCond extends TestCase {
     Random r = new Random();
     DataBag bag = BagFactory.getInstance().newDefaultBag();
+    DataBag bagDefault = BagFactory.getInstance().newDefaultBag();
+    DataBag bagWithNull = BagFactory.getInstance().newDefaultBag();
+    DataBag bagWithBoolean = BagFactory.getInstance().newDefaultBag();
+    DataBag bagWithBooleanAndNull = BagFactory.getInstance().newDefaultBag();
+
     final int MAX = 10;
+
+    /***
+     *  POBinCondition tests
+     *  
+     *  (r1, 1, 0 )
+     *  (r2, 1, 0 )
+     *  (r3, 1, 0 )
+     *  ...
+     *  (rn, 1, 0 )
+     *    
+     *   where r is a random number ( r1 .. rn )
+     *   
+     *   The POBinCondition to test is:  Integer(result)= ( r == 1 )? Ingeger(1), Ingeger(0);
+     *   but the condition can be of any datatype: Interger, Float, Double...
+     *   
+     * @throws ExecException
+     */
     
     @Before
     @Override
     public void setUp() {
+    	
+    	//default bag as shown above
         for(int i = 0; i < 10; i ++) {
             Tuple t = TupleFactory.getInstance().newTuple();
             t.append(r.nextInt(2));
+            t.append(1);
             t.append(0);
+            bagDefault.add(t);
+        }
+       
+        //same as default bag but contains nulls
+        for(int i = 0; i < 10; i ++) {
+            Tuple t = TupleFactory.getInstance().newTuple();
+            if (r.nextInt(4)%3 == 0){
+            	t.append(null);
+            	
+            }else{
+                t.append(r.nextInt(2));
+            }
             t.append(1);
-            bag.add(t);
+            t.append(0);
+            bagWithNull.add(t);
+
         }
-    }
+        
+        //r is a boolean  
+        for(int i = 0; i < 10; i ++) {
+            Tuple t = TupleFactory.getInstance().newTuple();
+            if (r.nextInt(2)%2 == 0 ){
+            		t.append(true);
+            } else  {
+            		t.append(false);
+            }
+            t.append(1);
+            t.append(0);
+            bagWithBoolean.add(t);
+
+    	}
     
+        //r is a boolean with nulls
+        for(int i = 0; i < 10; i ++) {
+
+            Tuple t = TupleFactory.getInstance().newTuple();
+            if (r.nextInt(3)%2 == 0){
+            	
+             	t.append(null);
+             	
+            }else{
+            	
+               	if (r.nextInt(2)%2 == 0 ){
+            		t.append(true);
+            	} else {
+            		t.append(false);
+            	}
+
+            }
+            t.append(1);
+            t.append(0);
+            bagWithBooleanAndNull.add(t);
+
+        }
+
+        
+    }
+  
+    /* ORIGINAL TEST
     public void testPOBinCond() throws ExecException, PlanException {
         ConstantExpression rt = (ConstantExpression) GenPhyOp.exprConst();
         rt.setValue(1);
@@ -104,5 +187,286 @@ public class TestPOBinCond extends TestCase {
         }
         
         
+    }
+  */
+    
+
+    public void testPOBinCondWithInteger() throws  ExecException, PlanException {
+    	
+	    bag= getBag(DataType.INTEGER);
+    	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.INTEGER, new Integer(1) );
+ 
+    	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+            Tuple t = it.next();
+            testHelper.getPlan().attachInput(t);
+            Integer value = (Integer) t.get(0);
+            int expected = (value.intValue() == 1)? 1:0 ;
+            Integer result=(Integer)testHelper.getOperator().getNext(value).result;
+            int actual = result.intValue();
+            assertEquals( expected, actual );
+        }
+
+    }
+   
+    public void testPOBinCondWithLong() throws  ExecException, PlanException {
+        bag= getBag(DataType.LONG);
+       	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.LONG, new Long(1L) );
+    
+       	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+               Tuple t = it.next();
+               testHelper.getPlan().attachInput(t);
+               Long value = (Long) t.get(0);
+               int expected = (value.longValue() == 1L )? 1:0 ;
+               Integer dummy = new Integer(0);
+               Integer result=(Integer)testHelper.getOperator().getNext(dummy).result;
+               int actual = result.intValue();
+               assertEquals( expected, actual );
+        }
+    }
+
+    public void testPOBinCondWithFloat() throws  ExecException, PlanException {
+	   	
+		bag= getBag(DataType.FLOAT);
+	   	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.FLOAT, new Float(1.0f) );
+
+	   	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+	           Tuple t = it.next();
+	           testHelper.getPlan().attachInput(t);
+	           Float value = (Float) t.get(0);
+	           int expected = (value.floatValue() == 1.0f )? 1:0 ;
+	           Integer dummy = new Integer(0);
+	           Integer result=(Integer)testHelper.getOperator().getNext(dummy).result;
+	           int actual = result.intValue();
+	           assertEquals( expected, actual );
+	    }
+
+	}
+   
+    public void testPOBinCondWithDouble() throws  ExecException, PlanException {
+	   	
+		bag= getBag(DataType.DOUBLE);
+	   	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.DOUBLE, new Double(1.0) );
+
+	   	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+	           Tuple t = it.next();
+	           testHelper.getPlan().attachInput(t);
+	           Double value = (Double) t.get(0);
+	           int expected = (value.doubleValue() == 1.0 )? 1:0 ;
+	           Integer dummy = new Integer(0);
+	           Integer result=(Integer)testHelper.getOperator().getNext(dummy).result;
+	           int actual = result.intValue();
+	           assertEquals( expected, actual );
+	    }
+
+    }
+   
+    public void testPOBinCondIntWithNull() throws  ExecException, PlanException {
+   	
+    	bag= getBagWithNulls(DataType.INTEGER);
+       	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.INTEGER, new Integer(1) );
+    
+       	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+            Tuple t = it.next();
+            testHelper.getPlan().attachInput(t);
+            Integer value = null;
+            Integer result;
+
+            if (t.get(0) != null) {
+                value = (Integer) t.get(0);
+                result = (Integer) testHelper.getOperator().getNext(value).result;
+            } else {
+                result = (Integer) testHelper.getOperator().getNext(
+                        (Integer) null).result;
+            }
+            int actual;
+            if (value != null) {
+                int expected = (value.intValue() == 1) ? 1 : 0;
+                actual = result.intValue();
+                assertEquals(expected, actual);
+            } else {
+                assertEquals(null, result);
+            }
+ 
+       }
+
+   }
+   
+    public void testPOBinCondLongWithNull() throws  ExecException, PlanException {
+	   	
+	    bag= getBagWithNulls(DataType.LONG);
+	   	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.LONG, new Long(1L) );
+
+	   	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+	           Tuple t = it.next();
+	           testHelper.getPlan().attachInput(t);
+	           
+	           Long value=null;
+	           if ( t.get(0)!=null){
+	        	   value = (Long) t.get(0);
+	           }
+	           Integer dummy = new Integer(0);
+	           Integer result=(Integer)testHelper.getOperator().getNext(dummy).result;	                
+	           int expected;
+	           int actual;
+	           if ( value!=null ) {
+	        	   expected=(value.intValue() == 1)? 1:0 ;
+	        	   actual  = result.intValue();
+	        	   assertEquals( expected, actual );
+	           } else {
+	        	   assertEquals( null, result );
+	           }
+	       }
+	}
+   
+    public void testPOBinCondDoubleWithNull() throws  ExecException, PlanException {
+	   	
+	    bag= getBagWithNulls(DataType.DOUBLE);
+	   	TestPoBinCondHelper testHelper= new TestPoBinCondHelper(DataType.DOUBLE, new Double(1.0) );
+
+	   	for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+	           Tuple t = it.next();
+	           testHelper.getPlan().attachInput(t);
+
+	           Double value=null;
+	           if ( t.get(0)!=null){
+	        	   value = (Double) t.get(0);
+	           }
+	           Integer dummy = new Integer(0);
+	           Integer result=(Integer)testHelper.getOperator().getNext(dummy).result;
+	                
+	           int expected;
+	           int actual;
+	           if ( value!=null ) {
+	        	   expected=(value.intValue() == 1)? 1:0 ;
+	        	   actual  = result.intValue();
+	        	   assertEquals( expected, actual );
+	           } else {
+	        	   assertEquals( null, result );
+	           }
+	          
+
+	       }
+
+	}
+   
+    protected class TestPoBinCondHelper {
+    	
+    	 PhysicalPlan plan= null;
+     	 POBinCond op= null;
+    	 
+   
+		public <U> TestPoBinCondHelper(   byte type,  U value  )  throws  ExecException, PlanException {
+		    	
+				
+		        ConstantExpression rt = (ConstantExpression) GenPhyOp.exprConst();
+		        rt.setValue(value);
+		        rt.setResultType(type);
+		        
+		        POProject prj1 = GenPhyOp.exprProject();
+		        prj1.setColumn(0);
+		        prj1.setResultType(type);
+
+		        
+		        EqualToExpr equal = (EqualToExpr) GenPhyOp.compEqualToExpr();
+		        equal.setLhs(prj1);
+		        equal.setRhs(rt);
+		        equal.setOperandType(type);
+		        
+		        POProject prjLhs = GenPhyOp.exprProject();
+		        prjLhs.setResultType(DataType.INTEGER);
+		        prjLhs.setColumn(1);
+		        
+		        POProject prjRhs =prjRhs = GenPhyOp.exprProject();
+		        prjRhs.setResultType(DataType.INTEGER);
+		        prjRhs.setColumn(2);
+		     
+		        op = new POBinCond(new OperatorKey("", r.nextLong()), -1, equal, prjLhs, prjRhs);
+		        op.setResultType(DataType.INTEGER);
+		       
+		        plan= new PhysicalPlan();
+		        plan.add(op);
+		        plan.add(prjLhs);
+		        plan.add(prjRhs);
+		        plan.add(equal);
+		        plan.connect(equal, op);
+		        plan.connect(prjLhs, op);
+		        plan.connect(prjRhs, op);
+		        
+		        plan.add(prj1);
+		        plan.add(rt);
+		        plan.connect(prj1, equal);
+		        plan.connect(rt, equal);
+		        
+		       // File tmpFile = File.createTempFile("test", ".txt" );
+		       //PrintStream ps = new PrintStream(new FileOutputStream(tmpFile));
+		       //plan.explain(ps);
+		       //ps.close();
+
+		    }
+		
+		public PhysicalPlan getPlan(){
+			return plan;
+		}
+
+		
+		public POBinCond getOperator(){
+			return op;
+		}
+
+
+	}
+    
+    private DataBag getBag(byte type) {
+        DataBag bag = DefaultBagFactory.getInstance().newDefaultBag();
+        for(int i = 0; i < 10; i ++) {
+            Tuple t = TupleFactory.getInstance().newTuple();
+            switch(type) {
+                case DataType.INTEGER:
+                    t.append(r.nextInt(2));
+                    break;
+                case DataType.LONG:
+                    t.append(r.nextLong() % 2L);
+                    break;
+                case DataType.FLOAT:
+                    t.append((i % 2 == 0 ? 1.0f : 0.0f));
+                    break;
+                case DataType.DOUBLE:
+                    t.append((i % 2 == 0 ? 1.0 : 0.0));
+                    break;                
+            }
+            t.append(1);
+            t.append(0);
+            bag.add(t);
+        }        
+        return bag;        
+    }
+    
+    private DataBag getBagWithNulls(byte type) {
+        DataBag bag = DefaultBagFactory.getInstance().newDefaultBag();
+        for(int i = 0; i < 10; i ++) {
+            Tuple t = TupleFactory.getInstance().newTuple();
+            if (r.nextInt(4)%3 == 0){
+                t.append(null);                
+            }else{
+                switch(type) {
+                    case DataType.INTEGER:
+                        t.append(r.nextInt(2));
+                        break;
+                    case DataType.LONG: 
+                        t.append(r.nextLong() % 2L);
+                        break;
+                    case DataType.FLOAT:
+                        t.append( (i % 2 == 0 ? 1.0f : 0.0f));
+                        break;
+                    case DataType.DOUBLE:
+                        t.append( (i % 2 == 0 ? 1.0 : 0.0));
+                        break;
+                }
+            }            
+            t.append(1);
+            t.append(0);
+            bag.add(t);
+        }
+        return bag;
     }
 }
diff --git a/test/org/apache/pig/test/TestPOCast.java b/test/org/apache/pig/test/TestPOCast.java
index bfd1b57c5..c473141f1 100644
--- a/test/org/apache/pig/test/TestPOCast.java
+++ b/test/org/apache/pig/test/TestPOCast.java
@@ -355,6 +355,17 @@ public class TestPOCast extends TestCase {
 			}
 		}
 		
+		for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+			Tuple t = it.next();
+			plan.attachInput(t);
+            if(t.get(0) == null) {
+            	
+               	Float result  = (Float)op.getNext((Float)null).result;
+				assertEquals( null, result);
+
+            } 
+		}
+
 		for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
 			Tuple t = it.next();
 			plan.attachInput(t);
@@ -1129,4 +1140,101 @@ public class TestPOCast extends TestCase {
 			assertEquals(POStatus.STATUS_ERR, res.returnStatus);
 		}
 	}
+	
+	@Test
+	public void testNullToOther() throws PlanException, ExecException {
+		//Create data
+		DataBag bag = BagFactory.getInstance().newDefaultBag();
+		for(int i = 0; i < MAX; i++) {
+			Tuple t = TupleFactory.getInstance().newTuple();
+			t.append(r.nextInt());
+			bag.add(t);
+            if( r.nextInt(3) % 3 == 0 ){
+            	t = TupleFactory.getInstance().newTuple();
+            	t.append(null);
+	            bag.add(t);
+            }
+
+		}
+		
+		POCast op = new POCast(new OperatorKey("", r.nextLong()), -1);
+		POProject prj = new POProject(new OperatorKey("", r.nextLong()), -1, 0);
+		PhysicalPlan plan = new PhysicalPlan();
+		plan.add(prj);
+		plan.add(op);
+		plan.connect(prj, op);
+		
+		prj.setResultType(DataType.INTEGER);
+		
+		for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+			Tuple t = it.next();
+			plan.attachInput(t);
+            if(t.get(0) == null) {
+            	
+               	Integer result  = (Integer)op.getNext((Integer)null).result;
+				assertEquals( null, result);
+
+            } 
+            
+		}
+		
+		prj.setResultType(DataType.FLOAT);
+		
+		for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+			Tuple t = it.next();
+			plan.attachInput(t);
+            if(t.get(0) == null) {
+            	
+               	Float result  = (Float)op.getNext((Float)null).result;
+				assertEquals( null, result);
+
+            } 
+		}
+
+		prj.setResultType(DataType.DOUBLE);
+		
+		for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+			Tuple t = it.next();
+			plan.attachInput(t);
+            if(t.get(0) == null) {
+            	
+               	Double result  = (Double)op.getNext((Double)null).result;
+				assertEquals( null, result);
+
+            } 
+		}
+		
+		prj.setResultType(DataType.CHARARRAY);
+		
+		for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+			Tuple t = it.next();
+			plan.attachInput(t);
+            if(t.get(0) == null) {
+            	
+               	String result  = (String)op.getNext((String)null).result;
+				assertEquals( null, result);
+
+            } 
+		}
+		
+		prj.setResultType(DataType.BYTEARRAY);
+		
+		TupleFactory tf = TupleFactory.getInstance();
+		
+		{
+			Tuple t = tf.newTuple();
+			t.append(new DataByteArray((new Integer(r.nextInt())).toString().getBytes()));
+			plan.attachInput(t);
+            if(t.get(0) == null) {
+            	
+            	DataByteArray result  = (DataByteArray)op.getNext((String)null).result;
+				assertEquals( null, result);
+
+            } 
+
+		}
+
+
+	
+	}
 }
diff --git a/test/org/apache/pig/test/TestPODistinct.java b/test/org/apache/pig/test/TestPODistinct.java
index 9a5095765..774d7d4b0 100644
--- a/test/org/apache/pig/test/TestPODistinct.java
+++ b/test/org/apache/pig/test/TestPODistinct.java
@@ -41,13 +41,21 @@ import org.junit.Before;
 import org.junit.Test;
 
 public class TestPODistinct extends TestCase {
-    DataBag input = BagFactory.getInstance().newDefaultBag();
+	DataBag input = BagFactory.getInstance().newDefaultBag();
     Random r = new Random();
     final int MAX_VALUE = 10;
     final int MAX_SAMPLES = 100;
 
     @Before
     public void setUp() {
+         // System.out.println();
+    }
+
+ 
+    @Test
+    public void testPODistictWithInt() throws ExecException {
+    	
+       	input = BagFactory.getInstance().newDefaultBag();
         TupleFactory tf = TupleFactory.getInstance();
         for (int i = 0; i < MAX_SAMPLES; i++) {
             Tuple t = tf.newTuple();
@@ -55,35 +63,114 @@ public class TestPODistinct extends TestCase {
             input.add(t);
             // System.out.println(t);
         }
-        // System.out.println();
-    }
 
-    @Test
-    public void testPODistict() throws ExecException {
-        PORead read = new PORead(new OperatorKey("", r.nextLong()), input);
-        List<PhysicalOperator> inputs = new LinkedList<PhysicalOperator>();
-        inputs.add(read);
-        PODistinct distinct = new PODistinct(new OperatorKey("", r.nextLong()),
-                -1, inputs);
-        Map<Tuple, Integer> output = new HashMap<Tuple, Integer>();
-        Tuple t = null;
-        Result res = distinct.getNext(t);
-        t = (Tuple) res.result;
-        while (res.returnStatus != POStatus.STATUS_EOP) {
-            if (output.containsKey(t)) {
-                int i = output.get(t);
-                output.put(t, ++i);
-            } else {
-                output.put(t, 1);
-            }
-            res = distinct.getNext(t);
-            t = (Tuple) res.result;
+    	confirmDistinct();
+     }
+
+    public void testPODistictWithNullValues() throws ExecException {
+    	
+    	input = BagFactory.getInstance().newDefaultBag();
+        TupleFactory tf = TupleFactory.getInstance();
+        for (int i = 0; i < MAX_SAMPLES; i++) {
+            Tuple t = tf.newTuple();
+            t.append(null);
+            input.add(t);
+            // System.out.println(t);
+        }
+
+    	confirmDistinct();
+     }
+  
+    public void testPODistictWithIntAndNullValues() throws ExecException {
+    	
+      	input = BagFactory.getInstance().newDefaultBag();
+        TupleFactory tf = TupleFactory.getInstance();
+        for (int i = 0; i < MAX_SAMPLES; i++) {
+            Tuple t = tf.newTuple();
+            t.append(r.nextInt(MAX_VALUE));
+            input.add(t);
+            t = tf.newTuple();
+            t.append(null);
+            input.add(t);
+            // System.out.println(t);
+        }
+
+    	confirmDistinct();
+     }
+ 
+    public void testPODistictWithIntNullValues() throws ExecException {
+    	
+    	input = BagFactory.getInstance().newDefaultBag();
+        TupleFactory tf = TupleFactory.getInstance();
+        for (int i = 0; i < MAX_SAMPLES; i++) {
+            Tuple t = tf.newTuple();
+            t.append(r.nextInt(MAX_VALUE));
+            t.append(null);
+            input.add(t);
+            // System.out.println(t);
+        }
+
+    	confirmDistinct();
+     }
+    public void testPODistictWithNullIntValues() throws ExecException {
+    	
+    	input = BagFactory.getInstance().newDefaultBag();
+        TupleFactory tf = TupleFactory.getInstance();
+        for (int i = 0; i < MAX_SAMPLES; i++) {
+            Tuple t = tf.newTuple();
+            t.append(null);
+            t.append(r.nextInt(MAX_VALUE));
+            input.add(t);
+            // System.out.println(t);
         }
-        for (Map.Entry<Tuple, Integer> e : output.entrySet()) {
-            int i = e.getValue();
-            // System.out.println(e.getKey());
-            assertEquals(1, i);
+
+    	confirmDistinct();
+     }
+    
+    public void testPODistictArityWithNullValues() throws ExecException {
+    	
+    	input = BagFactory.getInstance().newDefaultBag();
+        TupleFactory tf = TupleFactory.getInstance();
+        for (int i = 0; i < MAX_SAMPLES; i++) {
+            Tuple t = tf.newTuple();
+            if ( r.nextInt(MAX_VALUE) % 3 == 0 ){
+            	t.append(null);
+            }
+            t.append(r.nextInt(MAX_VALUE));
+            t.append(r.nextInt(MAX_VALUE));
+            input.add(t);
+            // System.out.println(t);
         }
+
+    	confirmDistinct();
+     }
+
+    public void confirmDistinct() throws ExecException {
+	   	
+	    PORead read = new PORead(new OperatorKey("", r.nextLong()), input);
+	    List<PhysicalOperator> inputs = new LinkedList<PhysicalOperator>();
+	    inputs.add(read);
+	    PODistinct distinct = new PODistinct(new OperatorKey("", r.nextLong()),
+	            -1, inputs);
+	    Map<Tuple, Integer> output = new HashMap<Tuple, Integer>();
+	    Tuple t = null;
+	    Result res = distinct.getNext(t);
+	    t = (Tuple) res.result;
+	    while (res.returnStatus != POStatus.STATUS_EOP) {
+	        if (output.containsKey(t)) {
+	            int i = output.get(t);
+	            output.put(t, ++i);
+	        } else {
+	            output.put(t, 1);
+	        }
+	        res = distinct.getNext(t);
+	        t = (Tuple) res.result;
+	    }
+	    for (Map.Entry<Tuple, Integer> e : output.entrySet()) {
+	        int i = e.getValue();
+	        // System.out.println(e.getKey());
+	        assertEquals(1, i);
+	    }
     }
 
 }
diff --git a/test/org/apache/pig/test/TestPONegative.java b/test/org/apache/pig/test/TestPONegative.java
index b22df15db..0fa0d19ab 100644
--- a/test/org/apache/pig/test/TestPONegative.java
+++ b/test/org/apache/pig/test/TestPONegative.java
@@ -68,6 +68,48 @@ public class TestPONegative extends TestCase {
         
     }
     
+    public void testPONegIntAndNull () throws PlanException, ExecException {
+    	
+        for(int i = 0; i < MAX; i++) {
+            Tuple t = tf.newTuple();
+            t.append(r.nextInt());
+            bag.add(t);
+            if( r.nextInt(3) % 3 == 0 ){
+            	t = tf.newTuple();
+	            t.append(null);
+	            bag.add(t);
+            }
+
+        }
+        
+        POProject prj = new POProject(new OperatorKey("", r.nextLong()), -1, 0);
+        prj.setResultType(DataType.INTEGER);
+        PONegative pn = new PONegative(new OperatorKey("", r.nextLong()), -1, prj);
+        pn.setResultType(DataType.INTEGER);
+        
+        PhysicalPlan plan = new PhysicalPlan();
+        plan.add(prj); plan.add(pn);
+        plan.connect(prj, pn);
+        
+        for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+            Tuple t = it.next();
+            plan.attachInput(t);
+            
+            if(t.get(0) == null) {
+                Integer output = (Integer)pn.getNext((Integer)null).result;
+                assertEquals(null, output);
+
+            } else  {
+                Integer expected = -(Integer)t.get(0);
+                int output = (Integer) pn.getNext(expected).result;
+                assertEquals(expected.intValue(), output);
+                
+            }
+            
+          }
+        
+    }
+    
     public void testPONegLong () throws PlanException, ExecException {
         for(int i = 0; i < MAX; i++) {
             Tuple t = tf.newTuple();
@@ -94,6 +136,48 @@ public class TestPONegative extends TestCase {
         
     }
     
+    public void testPONegLongAndNull () throws PlanException, ExecException {
+        for(int i = 0; i < MAX; i++) {
+            Tuple t = tf.newTuple();
+            t.append(r.nextLong());
+            bag.add(t);
+            if( r.nextInt(3) % 3 == 0 ){
+            	t = tf.newTuple();
+	            t.append(null);
+	            bag.add(t);
+            }
+
+        }
+        
+        POProject prj = new POProject(new OperatorKey("", r.nextLong()), -1, 0);
+        prj.setResultType(DataType.LONG);
+        PONegative pn = new PONegative(new OperatorKey("", r.nextLong()), -1, prj);
+        pn.setResultType(DataType.LONG);
+        
+        PhysicalPlan plan = new PhysicalPlan();
+        plan.add(prj); plan.add(pn);
+        plan.connect(prj, pn);
+        
+        for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+            Tuple t = it.next();
+            plan.attachInput(t);
+            
+            if(t.get(0) == null) {
+                Long output = (Long)pn.getNext((Long)null).result;
+                assertEquals(null, output);
+
+            } else  {
+	            Long expected = -(Long)t.get(0);
+	            long output = (Long) pn.getNext(expected).result;
+	            assertEquals(expected.longValue(), output);
+                
+            }
+
+            
+        }
+        
+    }
+    
     public void testPONegDouble() throws PlanException, ExecException {
         for(int i = 0; i < MAX; i++) {
             Tuple t = tf.newTuple();
@@ -113,13 +197,56 @@ public class TestPONegative extends TestCase {
         for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
             Tuple t = it.next();
             plan.attachInput(t);
-            Double expected = -(Double)t.get(0);
-            double output = (Double) pn.getNext(expected).result;
-            assertEquals(expected.doubleValue(), output);
+			Double expected = -(Double)t.get(0);
+			double output = (Double) pn.getNext(expected).result;
+			assertEquals(expected.doubleValue(), output);
+
         }
         
     }
+  
     
+    public void testPONegDoubleAndNull() throws PlanException, ExecException {
+        for(int i = 0; i < MAX; i++) {
+            Tuple t = tf.newTuple();
+            t.append(r.nextDouble());
+            bag.add(t);
+            if( r.nextInt(3) % 3 == 0 ){
+            	t = tf.newTuple();
+	            t.append(null);
+	            bag.add(t);
+            }
+
+        }
+        
+        POProject prj = new POProject(new OperatorKey("", r.nextLong()), -1, 0);
+        prj.setResultType(DataType.DOUBLE);
+        PONegative pn = new PONegative(new OperatorKey("", r.nextLong()), -1, prj);
+        pn.setResultType(DataType.DOUBLE);
+        
+        PhysicalPlan plan = new PhysicalPlan();
+        plan.add(prj); plan.add(pn);
+        plan.connect(prj, pn);
+        
+        for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+            Tuple t = it.next();
+            plan.attachInput(t);
+            
+            if(t.get(0) == null) {
+            	Double output = (Double )pn.getNext((Double )null).result;
+                assertEquals(null, output);
+
+            } else  {
+                Double expected = -(Double)t.get(0);
+                double output = (Double) pn.getNext(expected).result;
+                assertEquals(expected.doubleValue(), output);
+                
+            }
+
+        }
+        
+    }
+
     public void testPONegFloat() throws PlanException, ExecException {
         for(int i = 0; i < MAX; i++) {
             Tuple t = tf.newTuple();
@@ -145,4 +272,47 @@ public class TestPONegative extends TestCase {
         }
         
     }
+    
+ 
+    public void testPONegFloatAndNull() throws PlanException, ExecException {
+        for(int i = 0; i < MAX; i++) {
+            Tuple t = tf.newTuple();
+            t.append(r.nextFloat());
+            bag.add(t);
+            if( r.nextInt(3) % 3 == 0 ){
+            	t = tf.newTuple();
+	            t.append(null);
+	            bag.add(t);
+            }
+
+        }
+        
+        POProject prj = new POProject(new OperatorKey("", r.nextLong()), -1, 0);
+        prj.setResultType(DataType.FLOAT);
+        PONegative pn = new PONegative(new OperatorKey("", r.nextLong()), -1, prj);
+        pn.setResultType(DataType.FLOAT);
+        
+        PhysicalPlan plan = new PhysicalPlan();
+        plan.add(prj); plan.add(pn);
+        plan.connect(prj, pn);
+        
+        for(Iterator<Tuple> it = bag.iterator(); it.hasNext(); ) {
+            Tuple t = it.next();
+            plan.attachInput(t);
+            
+            if(t.get(0) == null) {
+            	Float output = (Float)pn.getNext((Float)null).result;
+                assertEquals(null, output);
+
+            } else  {
+
+                Float expected = -(Float)t.get(0);
+                float output = (Float) pn.getNext(expected).result;
+                assertEquals(expected.floatValue(), output);
+                
+            }
+        }
+        
+    }
+
 }
diff --git a/test/org/apache/pig/test/TestRegexp.java b/test/org/apache/pig/test/TestRegexp.java
index 5cf2d94fe..d5e1327e9 100644
--- a/test/org/apache/pig/test/TestRegexp.java
+++ b/test/org/apache/pig/test/TestRegexp.java
@@ -60,6 +60,19 @@ public class TestRegexp extends TestCase{
         Result res = op.getNext(new Boolean(true));
         assertEquals(POStatus.STATUS_OK, res.returnStatus);
         assertTrue((Boolean)res.result);
+        
+        // test with null in lhs
+        lt.setValue(null);
+        rt.setValue(".*s.y.*");
+        res = op.getNext(new Boolean(true));
+        assertEquals(null, (Boolean)res.result);
+        
+        // test with null in rhs
+        lt.setValue(new String(
+        "The quick sly fox jumped over the lazy brown dog"));
+        rt.setValue(null);
+        res = op.getNext(new Boolean(true));
+        assertEquals(null, (Boolean)res.result);
     }
 
     @Test
diff --git a/test/org/apache/pig/test/TestSubtract.java b/test/org/apache/pig/test/TestSubtract.java
index 6d5b2b433..c45a0e4f3 100644
--- a/test/org/apache/pig/test/TestSubtract.java
+++ b/test/org/apache/pig/test/TestSubtract.java
@@ -56,7 +56,7 @@ public class TestSubtract extends TestCase{
         byte[] types = { DataType.BAG, DataType.BOOLEAN, DataType.BYTEARRAY, DataType.CHARARRAY, 
                 DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG, DataType.MAP, DataType.TUPLE};
         //Map<Byte,String> map = GenRandomData.genTypeToNameMap();
-        System.out.println("Testing ADD operator");
+        System.out.println("Testing Subtract operator");
         for(byte type : types) {
             lt.setResultType(type);
             rt.setResultType(type);
@@ -71,6 +71,17 @@ public class TestSubtract extends TestCase{
                 rt.setValue(inpdb2);
                 Result resdb = op.getNext(inpdb1);
                 assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpdb2);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpdb1);
+                rt.setValue(null);
+                resdb = op.getNext(inpdb1);
+                assertEquals(resdb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BOOLEAN:
                 Boolean inpb1 = r.nextBoolean();
@@ -79,6 +90,17 @@ public class TestSubtract extends TestCase{
                 rt.setValue(inpb2);
                 Result resb = op.getNext(inpb1);
                 assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpb2);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpb1);
+                rt.setValue(null);
+                resb = op.getNext(inpb1);
+                assertEquals(resb.returnStatus, POStatus.STATUS_ERR);
                 break;
             case DataType.BYTEARRAY: {
                 DataByteArray inpba1 = GenRandomData.genRandDBA(r);
@@ -89,6 +111,17 @@ public class TestSubtract extends TestCase{
                 //DataByteArray expected = new DataByteArray(inpba1.toString() + inpba2.toString());
                 //assertEquals(expected, (DataByteArray)resba.result);
                 assertEquals(POStatus.STATUS_ERR, resba.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpba2);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inpba1);
+                rt.setValue(null);
+                resba = op.getNext(inpba1);
+                assertEquals(resba.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.CHARARRAY: {
@@ -100,6 +133,17 @@ public class TestSubtract extends TestCase{
                 /*String expected = new String(inps1 + inps2);
                 assertEquals(expected, (String)ress.result);*/
                 assertEquals(POStatus.STATUS_ERR, ress.returnStatus);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inps2);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
+                // test with null in rhs
+                lt.setValue(inps1);
+                rt.setValue(null);
+                ress = op.getNext(inps1);
+                assertEquals(ress.returnStatus, POStatus.STATUS_ERR);
                 break;
             }
             case DataType.DOUBLE: {
@@ -110,6 +154,17 @@ public class TestSubtract extends TestCase{
                 Result resd = op.getNext(inpd1);
                 Double expected = new Double(inpd1 - inpd2);
                 assertEquals(expected, (Double)resd.result);
+                
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpd2);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
+                // test with null in rhs
+                lt.setValue(inpd1);
+                rt.setValue(null);
+                resd = op.getNext(inpd1);
+                assertEquals(null, (Double)resd.result);
                 break;
             }
             case DataType.FLOAT: {
@@ -120,6 +175,17 @@ public class TestSubtract extends TestCase{
                 Result resf = op.getNext(inpf1);
                 Float expected = new Float(inpf1 - inpf2);
                 assertEquals(expected, (Float)resf.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpf2);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
+                // test with null in rhs
+                lt.setValue(inpf1);
+                rt.setValue(null);
+                resf = op.getNext(inpf1);
+                assertEquals(null, (Float)resf.result);
                 break;
             }
             case DataType.INTEGER: {
@@ -130,6 +196,17 @@ public class TestSubtract extends TestCase{
                 Result resi = op.getNext(inpi1);
                 Integer expected = new Integer(inpi1 - inpi2);
                 assertEquals(expected, (Integer) resi.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpi2);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
+                // test with null in rhs
+                lt.setValue(inpi1);
+                rt.setValue(null);
+                resi = op.getNext(inpi1);
+                assertEquals(null, (Integer)resi.result);
                 break;
             }
             case DataType.LONG: {
@@ -140,6 +217,17 @@ public class TestSubtract extends TestCase{
                 Result resl = op.getNext(inpl1);
                 Long expected = new Long(inpl1 - inpl2);
                 assertEquals(expected, (Long)resl.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpl2);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
+                // test with null in rhs
+                lt.setValue(inpl1);
+                rt.setValue(null);
+                resl = op.getNext(inpl1);
+                assertEquals(null, (Long)resl.result);
                 break;
             }
             case DataType.MAP: {
@@ -149,6 +237,17 @@ public class TestSubtract extends TestCase{
                 rt.setValue(inpm2);
                 Result resm = op.getNext(inpm1);
                 assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpm2);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpm1);
+                rt.setValue(null);
+                resm = op.getNext(inpm1);
+                assertEquals(POStatus.STATUS_ERR, resm.returnStatus);
                 break;
             }
             case DataType.TUPLE: {
@@ -158,6 +257,17 @@ public class TestSubtract extends TestCase{
                 rt.setValue(inpt2);
                 Result rest = op.getNext(inpt1);
                 assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpt2);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
+                // test with null in rhs
+                lt.setValue(inpt1);
+                rt.setValue(null);
+                rest = op.getNext(inpt1);
+                assertEquals(POStatus.STATUS_ERR, rest.returnStatus);
                 break;
             }
             }
diff --git a/test/org/apache/pig/test/utils/GenRandomData.java b/test/org/apache/pig/test/utils/GenRandomData.java
index a1fa2c6c4..94c430944 100644
--- a/test/org/apache/pig/test/utils/GenRandomData.java
+++ b/test/org/apache/pig/test/utils/GenRandomData.java
@@ -87,13 +87,46 @@ public class GenRandomData {
         return t;
     }
     
-    public static Tuple genRandSmallTuple(String s, int value){
+    public static Tuple genRandSmallTuple(String s, Integer value){
         Tuple t = new DefaultTuple();
         t.append(s);
         t.append(value);
         return t;
     }
     
+    public static DataBag genRandSmallTupDataBagWithNulls(Random r, int num, int limit){
+        if(r==null) {
+            DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
+            Tuple t = new DefaultTuple();
+            t.append("RANDOM");
+            db.add(t);
+            return db;
+        }
+        DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
+        for(int i=0;i<num;i++){
+            // the first tuple is used as a sample tuple 
+            // in some tests to deduce return type - so
+            // don't introduce nulls into first tuple
+            if(i == 0) {
+                db.add(genRandSmallTuple(r, limit));
+                continue;
+            } else {
+                int rand = r.nextInt(num);
+                if(rand <= (0.2 * num) ) {
+                    db.add(genRandSmallTuple((String)null, rand));
+                } else if (rand > (0.2 * num) && rand <= (0.4 * num)) {
+                    db.add(genRandSmallTuple(genRandString(r), null));
+                } else if (rand > (0.4 * num) && rand <= (0.6 * num)) {
+                    db.add(genRandSmallTuple(null, null));
+                } else {
+                    db.add(genRandSmallTuple(r, limit));
+                }
+            }
+        }
+        
+        return db;
+    }
+    
     public static DataBag genRandSmallTupDataBag(Random r, int num, int limit){
         if(r==null) {
             DataBag db = DefaultBagFactory.getInstance().newDefaultBag();
