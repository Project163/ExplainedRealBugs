diff --git a/CHANGES.txt b/CHANGES.txt
index dd4ba0de6..8187d3093 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -28,7 +28,7 @@ PIG-619: Create one InputSplit even when the input file is zero length
          so that hadoop runs maps and creates output for the next
 		 job (gates).
 
-PIG-693: Proposed improvements to pig's optimizer (sms)
+PIG-697: Proposed improvements to pig's optimizer (sms)
 
 PIG-700: To automate the pig patch test process (gkesavan via sms)
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
index 66bdbe1cc..e200fb267 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCogroup.java
@@ -29,6 +29,7 @@ import java.util.Iterator;
 import org.apache.pig.PigException;
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
@@ -37,6 +38,7 @@ import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 
 public class LOCogroup extends LogicalOperator {
     private static final long serialVersionUID = 2L;
@@ -511,5 +513,103 @@ public class LOCogroup extends LogicalOperator {
         
         return cogroupClone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors == null) {
+            return null;
+        }
+        
+        //the column with the alias 'group' can be mapped in several ways
+        //1. group A by $0;
+        //Here the mapping is 0 -> (0, 0)
+        //2. group A by ($0, $1);
+        //Here there is no direct mapping and 'group' is an added column
+        //3. cogroup A by $0, B by $0;
+        //Here the mapping is 0 -> ((0, 0), (1, 0))
+        //4. cogroup A by ($0, $1), B by ($0, $1);
+        //Here there is no direct mapping and 'group' is an added column
+        //For anything other than a simple project 'group' is an added column
+        
+        MultiMap<LogicalOperator, LogicalPlan> groupByPlans = getGroupByPlans();
+        
+        boolean groupByAdded = false;
+        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        List<Pair<Integer, Integer>> removedFields = new ArrayList<Pair<Integer, Integer>>();
+        
+        for(int inputNum = 0; (inputNum < predecessors.size()) && (!groupByAdded); ++inputNum) {
+            LogicalOperator predecessor = predecessors.get(inputNum);
+
+            
+            List<LogicalPlan> predecessorPlans = (ArrayList<LogicalPlan>) groupByPlans.get(predecessor);
+
+            int inputColumn = -1;
+            for(LogicalPlan predecessorPlan: predecessorPlans) {                
+                List<LogicalOperator> leaves = predecessorPlan.getLeaves();
+                if(leaves == null || leaves.size() > 1) {
+                    groupByAdded = true;
+                    break;
+                }
+                
+                if(leaves.get(0) instanceof LOProject) {
+                    //find out if this project is a chain of projects
+                    if(LogicalPlan.chainOfProjects(predecessorPlan)) {
+                        LOProject rootProject = (LOProject)predecessorPlan.getRoots().get(0);
+                        inputColumn = rootProject.getCol();
+                        mapFields.put(0, new Pair<Integer, Integer>(inputNum, inputColumn));
+                    }
+                } else {
+                    groupByAdded = true;
+                }                
+            }
+            
+            Schema inputSchema;            
+            try {
+                inputSchema = predecessor.getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+            
+            if(inputSchema != null) {
+                for(int column = 0; column < inputSchema.size(); ++column) {
+                    if(!groupByAdded && inputColumn != column) {
+                        removedFields.add(new Pair<Integer, Integer>(inputNum, column));
+                    }
+                }
+            }
+
+        }
+
+        List<Integer> addedFields = new ArrayList<Integer>();
+
+        if(groupByAdded) {
+            addedFields.add(0); //for the column 'group'
+            mapFields = null; //since 'group' is an added column there is no mapping            
+        }
+        
+        //the columns 1 through n - 1 are generated by cogroup
+        for(int i = 0; i < groupByPlans.keySet().size(); ++i) {
+            addedFields.add(i+ 1);
+        }
+        
+        if(removedFields.size() == 0) {
+            removedFields = null;
+        }
+
+        return new ProjectionMap(mapFields, removedFields, addedFields);
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOCross.java b/src/org/apache/pig/impl/logicalLayer/LOCross.java
index 2a0be8c13..4efb613da 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOCross.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOCross.java
@@ -32,7 +32,10 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -183,5 +186,73 @@ public class LOCross extends LogicalOperator {
     public byte getType() {
         return DataType.BAG ;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors == null) {
+            return null;
+        }
+        
+        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        List<Integer> addedFields = new ArrayList<Integer>();
+        boolean[] unknownSchema = new boolean[predecessors.size()];
+        boolean anyUnknownInputSchema = false;
+        int outputColumnNum = 0;
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            LogicalOperator predecessor = predecessors.get(inputNum);
+            Schema inputSchema = null;        
+            
+            try {
+                inputSchema = predecessor.getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+            
+            if(inputSchema == null) {
+                unknownSchema[inputNum] = true;
+                outputColumnNum++;
+                addedFields.add(inputNum);
+                anyUnknownInputSchema = true;
+            } else {
+                unknownSchema[inputNum] = false;
+                for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
+                    mapFields.put(outputColumnNum++, new Pair<Integer, Integer>(inputNum, inputColumn));
+                }
+            }
+        }
+        
+        //TODO
+        /*
+         * For now, if there is any input that has an unknown schema
+         * flag it and return a null ProjectionMap.
+         * In the future, when unknown schemas are handled
+         * mark inputs that have unknown schemas as output columns
+         * that have been added.
+         */
+
+        if(anyUnknownInputSchema) {
+            return null;
+        }
+        
+        if(addedFields.size() == 0) {
+            addedFields = null;
+        }
+
+        return new ProjectionMap(mapFields, null, addedFields);
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LODistinct.java b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
index d537f3e58..b49d30f3d 100644
--- a/src/org/apache/pig/impl/logicalLayer/LODistinct.java
+++ b/src/org/apache/pig/impl/logicalLayer/LODistinct.java
@@ -26,6 +26,7 @@ import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
@@ -116,5 +117,44 @@ public class LODistinct extends LogicalOperator {
         LODistinct distinctClone = (LODistinct)super.clone();
         return distinctClone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a distinct have to match!
+            return null;
+        }
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
index 2672eca23..715a815ba 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFRJoin.java
@@ -31,8 +31,10 @@ import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 
 /**
  * This is the logical operator for the Fragment Replicate Join
@@ -268,6 +270,73 @@ public class LOFRJoin extends LogicalOperator {
 
         return new Schema(fsList) ;
     }
-    
+
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors == null) {
+            return null;
+        }
+        
+        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        List<Integer> addedFields = new ArrayList<Integer>();
+        boolean[] unknownSchema = new boolean[predecessors.size()];
+        boolean anyUnknownInputSchema = false;
+        int outputColumnNum = 0;
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            LogicalOperator predecessor = predecessors.get(inputNum);
+            Schema inputSchema = null;        
+            
+            try {
+                inputSchema = predecessor.getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+            
+            if(inputSchema == null) {
+                unknownSchema[inputNum] = true;
+                outputColumnNum++;
+                addedFields.add(inputNum);
+                anyUnknownInputSchema = true;
+            } else {
+                unknownSchema[inputNum] = false;
+                for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
+                    mapFields.put(outputColumnNum++, new Pair<Integer, Integer>(inputNum, inputColumn));
+                }
+            }
+        }
+        
+        //TODO
+        /*
+         * For now, if there is any input that has an unknown schema
+         * flag it and return a null ProjectionMap.
+         * In the future, when unknown schemas are handled
+         * mark inputs that have unknown schemas as output columns
+         * that have been added.
+         */
+
+        if(anyUnknownInputSchema) {
+            return null;
+        }
+        
+        if(addedFields.size() == 0) {
+            addedFields = null;
+        }
+
+        return new ProjectionMap(mapFields, null, addedFields);
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOFilter.java b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
index 8dada3b4e..ff6e34cd4 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOFilter.java
@@ -23,6 +23,7 @@ import java.util.ArrayList;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.data.DataType;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
@@ -124,5 +125,44 @@ public class LOFilter extends LogicalOperator {
         filterClone.mComparisonPlan = lpCloner.getClonedPlan();
         return filterClone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a filter have to match!
+            return null;
+        }
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 47db500e8..6a02060f0 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -18,6 +18,7 @@
 package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.HashMap;
@@ -30,7 +31,10 @@ import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.pig.impl.logicalLayer.optimizer.SchemaRemover;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.impl.logicalLayer.parser.QueryParser ;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.data.DataType;
@@ -174,7 +178,7 @@ public class LOForEach extends LogicalOperator {
                     //In the above script, the generate a1, will translate to 
                     //project(a1) -> project(*) and will not be translated to a sequence of projects
                     //As a result the project(*) will remain but the return type is a bag
-                    //project*) with a data type set to tuple indicataes a project(*) from an input
+                    //project(*) with a data type set to tuple indicates a project(*) from an input
                     //that has no schema
                     if( (((LOProject)op).isStar() ) && (((LOProject)op).getType() == DataType.TUPLE) ) {
                         mSchema = null;
@@ -447,4 +451,197 @@ public class LOForEach extends LogicalOperator {
         return forEachClone;
     }
 
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors == null) {
+            return null;
+        }
+        
+        LogicalOperator predecessor = predecessors.get(0);
+        
+        Schema inputSchema;
+        
+        try {
+            inputSchema = predecessor.getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        List<LogicalPlan> foreachPlans = getForEachPlans();
+        List<Boolean> flattenList = getFlatten();
+        
+        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        List<Integer> addedFields = new ArrayList<Integer>();
+        int outputColumn = 0;
+        
+        for(int i = 0; i < foreachPlans.size(); ++i) {
+            LogicalPlan foreachPlan = foreachPlans.get(i);
+            List<LogicalOperator> leaves = foreachPlan.getLeaves();
+            if(leaves == null || leaves.size() > 1) {
+                return null;
+            }
+            
+            int inputColumn = -1;
+            boolean mapped = false;
+            
+            if(leaves.get(0) instanceof LOProject) {
+                //find out if this project is a chain of projects
+                if(LogicalPlan.chainOfProjects(foreachPlan)) {
+                    LOProject rootProject = (LOProject)foreachPlan.getRoots().get(0);
+                    inputColumn = rootProject.getCol();
+                    if(inputSchema != null) {
+                        mapped = true;
+                    }
+                }
+            }
+            
+            Schema.FieldSchema leafFS;
+            try {
+                leafFS = ((ExpressionOperator)leaves.get(0)).getFieldSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+            
+            if(leafFS == null) {
+                return null;
+            }
+            
+            if(flattenList.get(i)) {
+                Schema innerSchema = leafFS.schema;
+                
+                if(innerSchema != null) {                    
+                    if(innerSchema.isTwoLevelAccessRequired()) {
+                        // this is the case where the schema is that of
+                        // a bag which has just one tuple fieldschema which
+                        // in turn has a list of fieldschemas. The schema
+                        // after flattening would consist of the fieldSchemas
+                        // present in the tuple
+                        
+                        // check that indeed we only have one field schema
+                        // which is that of a tuple
+                        if(innerSchema.getFields().size() != 1) {
+                            return null;
+                        }
+                        Schema.FieldSchema tupleFS;
+                        try {
+                            tupleFS = innerSchema.getField(0);
+                        } catch (FrontendException fee) {
+                            return null;
+                        }
+                        
+                        if(tupleFS.type != DataType.TUPLE) {
+                            return null;
+                        }
+                        innerSchema = tupleFS.schema;
+                    }
+                    
+                    //innerSchema could be modified and hence the second check
+                    if(innerSchema != null) {
+                        for(int j = 0; j < innerSchema.size(); ++j) {
+                            if(mapped) {
+                                //map each flattened column to the original column
+                                mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                            } else {
+                                addedFields.add(outputColumn++);
+                            }
+                        }
+                    } else {
+                        //innerSchema is null; check for schema type
+                        if(DataType.isSchemaType(leafFS.type)) {
+                            //flattening a null schema results in a bytearray
+                            if(mapped) {
+                                //map each flattened column to the original column
+                                mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                            } else {
+                                addedFields.add(outputColumn++);
+                            }
+                        } else {
+                            mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                        }
+                    }
+                } else {
+                    //innerSchema is null; check for schema type
+                    if(DataType.isSchemaType(leafFS.type)) {
+                        //flattening a null schema results in a bytearray
+                        if(mapped) {
+                            //map each flattened column to the original column
+                            mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                        } else {
+                            addedFields.add(outputColumn++);
+                        }
+                    } else {
+                        mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                    }
+                }
+            } else {
+                //not a flattened column
+                if(mapped) {
+                    mapFields.put(outputColumn++, new Pair<Integer, Integer>(0, inputColumn));
+                } else {
+                    addedFields.add(outputColumn++);
+                }
+            }
+        }
+        
+        List<Pair<Integer, Integer>> removedFields = new ArrayList<Pair<Integer, Integer>>();
+       
+        if(inputSchema == null) {
+            //if input schema is null then there are no mappedFields and removedFields
+            mapFields = null;
+            removedFields = null;
+        } else {
+            
+            //if the size of the map is zero then set it to null
+            if(mapFields.size() == 0) {
+                mapFields = null;
+            }
+            
+            if(addedFields.size() == 0) {
+                addedFields = null;
+            }
+            
+            //input schema is not null. Need to compute the removedFields
+            //compute the set difference between the input schema and mapped fields
+            
+            Set<Integer> removedSet = new HashSet<Integer>();
+            for(int i = 0; i < inputSchema.size(); ++i) {
+                removedSet.add(i);
+            }
+            
+            if(mapFields != null) {
+                Set<Integer> mappedSet = new HashSet<Integer>();
+                for(Integer key: mapFields.keySet()) {
+                    List<Pair<Integer, Integer>> values = (ArrayList<Pair<Integer, Integer>>)mapFields.get(key);
+                    for(Pair<Integer, Integer> value: values) {
+                        mappedSet.add(value.second);
+                    }
+                }
+                removedSet.removeAll(mappedSet);
+            }
+            
+            if(removedSet.size() == 0) {
+                removedFields = null;
+            } else {
+                for(Integer i: removedSet) {
+                    removedFields.add(new Pair<Integer, Integer>(0, i));
+                }
+            }
+        }
+
+        return new ProjectionMap(mapFields, removedFields, addedFields);
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLoad.java b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
index f3846df64..ded51011c 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLoad.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLoad.java
@@ -19,6 +19,10 @@ package org.apache.pig.impl.logicalLayer;
 
 import java.io.IOException;
 import java.net.URL;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import org.apache.pig.ExecType;
 import org.apache.pig.LoadFunc;
@@ -28,7 +32,10 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.impl.util.WrappedIOException;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
@@ -130,9 +137,6 @@ public class LOLoad extends LogicalOperator {
         if (!mIsSchemaComputed) {
             // get the schema of the load function
             try {
-                //DEBUG
-                //System.out.println("Schema file: " + mSchema);
-                
                 if (mEnforcedSchema != null) {
                     mSchema = mEnforcedSchema ;
                     return mSchema ;
@@ -220,5 +224,53 @@ public class LOLoad extends LogicalOperator {
     public Schema getDeterminedSchema() {
         return mDeterminedSchema;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            try {
+                inputSchema = mLoadFunc.determineSchema(mSchemaFile, mExecType, mStorage);
+            } catch (IOException ioe) {
+                return null;
+            }
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+            //compute the mapping assuming its a prefix projection
+            for(int i = 0; i < inputSchema.size(); ++i) {
+                mapFields.put(i, new Pair<Integer, Integer>(0, i));
+            }
+            return new ProjectionMap(mapFields, null, null);
+        }
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOSort.java b/src/org/apache/pig/impl/logicalLayer/LOSort.java
index 63d84d946..576600ca7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOSort.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOSort.java
@@ -27,6 +27,7 @@ import org.apache.pig.FuncSpec;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.PlanVisitor;
 import org.apache.pig.data.DataType;
@@ -202,5 +203,44 @@ public class LOSort extends LogicalOperator {
         }
         return clone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        } else {
+            return null;
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a sort have to match!
+            return null;
+        }
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOStore.java b/src/org/apache/pig/impl/logicalLayer/LOStore.java
index 0a393c666..983c81a48 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOStore.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOStore.java
@@ -20,6 +20,7 @@ package org.apache.pig.impl.logicalLayer;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -27,9 +28,11 @@ import org.apache.pig.StoreFunc;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileSpec;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.util.Pair;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -126,4 +129,41 @@ public class LOStore extends LogicalOperator {
     public FileSpec getInputSpec() {
         return mInputSpec;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        Schema inputSchema = null;        
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors != null) {
+            try {
+                inputSchema = predecessors.get(0).getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+        }
+        
+        if(inputSchema == null) {
+            return null;
+        }
+        
+        if(Schema.equals(inputSchema, outputSchema, false, true)) {
+            //there is a one is to one mapping between input and output schemas
+            return new ProjectionMap(false);
+        } else {
+            //problem - input and output schemas for a store have to match!
+            return null;
+        }
+    }
+
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index 333c02128..bf24c2757 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -18,15 +18,20 @@
 package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.Set;
 
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.PlanVisitor;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
 import org.apache.pig.data.DataType;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -69,7 +74,8 @@ public class LOUnion extends LogicalOperator {
                     if(null != mSchema) {
                         mSchema = mSchema.merge(op.getSchema(), false);
                     } else {
-                        mSchema = op.getSchema();
+                        mSchema = null;
+                        break;
                     }
                 }
                 if(null != mSchema) {
@@ -78,7 +84,7 @@ public class LOUnion extends LogicalOperator {
                         while(iter.hasNext()) {
                             op = iter.next();
                             Schema opSchema = op.getSchema();
-                            if(null != s) {
+                            if(null != opSchema) {
                                 for(Schema.FieldSchema opFs: opSchema.getFields()) {
                                     fs.setParent(opFs.canonicalName, op);
                                 }
@@ -127,5 +133,49 @@ public class LOUnion extends LogicalOperator {
         LOUnion unionClone = (LOUnion)super.clone();
         return unionClone;
     }
+    
+    @Override
+    public ProjectionMap getProjectionMap() {
+        Schema outputSchema;
+        
+        try {
+            outputSchema = getSchema();
+        } catch (FrontendException fee) {
+            return null;
+        }
+        
+        if(outputSchema == null) {
+            return null;
+        }
+        
+        List<LogicalOperator> predecessors = (ArrayList<LogicalOperator>)mPlan.getPredecessors(this);
+        if(predecessors == null) {
+            return null;
+        }
+        
+        MultiMap<Integer, Pair<Integer, Integer>> mapFields = new MultiMap<Integer, Pair<Integer, Integer>>();
+        
+        for(int inputNum = 0; inputNum < predecessors.size(); ++inputNum) {
+            LogicalOperator predecessor = predecessors.get(inputNum);
+            Schema inputSchema = null;        
+            
+            try {
+                inputSchema = predecessor.getSchema();
+            } catch (FrontendException fee) {
+                return null;
+            }
+            
+            if(inputSchema == null) {
+                return null;
+            } else {
+                for(int inputColumn = 0; inputColumn < inputSchema.size(); ++inputColumn) {
+                    mapFields.put(inputColumn, new Pair<Integer, Integer>(inputNum, inputColumn));
+                    //removedFields.add(new Pair<Integer, Integer>(inputNum, inputColumn));
+                }
+            }
+        }
+        
+        return new ProjectionMap(mapFields, null, null);
+    }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
index f1c361b13..e0e6495f9 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalOperator.java
@@ -20,6 +20,7 @@ package org.apache.pig.impl.logicalLayer;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.io.IOException;
 
 import org.apache.pig.data.DataType;
@@ -27,7 +28,9 @@ import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.Pair;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -69,12 +72,6 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
      */
     protected LogicalPlan mPlan;
 
-    /**
-     * A boolean variable to remember if input has to be flattened Used only in
-     * the context of generate
-     */
-    //private boolean mIsFlatten = false;
-    
     private static Log log = LogFactory.getLog(LogicalOperator.class);
 
     /**
@@ -128,11 +125,8 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
             // It's fine, it just means we don't have a schema yet.
         }
         if (mSchema == null) {
-            log.debug("Operator schema is null; Setting it to new schema");
             mSchema = schema;
         } else {
-            log.debug("Reconciling schema");
-            log.debug("mSchema: " + mSchema + " schema: " + schema);
             mSchema.reconcile(schema);
         }
     }
@@ -284,6 +278,29 @@ abstract public class LogicalOperator extends Operator<LOVisitor> {
         if(mSchema != null)
             loClone.mSchema = this.mSchema.clone();
         return loClone;
+    }    
+
+
+    /**
+     * Produce a map describing how this operator modifies its projection.
+     * @return ProjectionMap null indicates it does not know how the projection
+     * changes, for example a join of two inputs where one input does not have
+     * a schema.
+     */
+    public ProjectionMap getProjectionMap() {
+        return null;
+    };
+
+    /**
+     * Get a list of fields that this operator requires.  This is not necessarily
+     * equivalent to the list of fields the operator projects.  For example,
+     * a filter will project anything passed to it, but requires only the fields
+     * explicitly referenced in its filter expression.
+     * @return list of fields, numbered from 0.
+     */
+    public List<Pair<Integer, Integer>> getRequiredFields()
+    {
+        return null;
     }
 
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java b/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
index 66a58b854..1f348e63b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
+++ b/src/org/apache/pig/impl/logicalLayer/LogicalPlan.java
@@ -150,4 +150,52 @@ public class LogicalPlan extends OperatorPlan<LogicalOperator> {
         return clone;
     }
     
+    /**
+     * A utility method to check if a plan contains a chain of projection
+     * operators
+     * 
+     * @param plan
+     *            input plan
+     * @return true if there is a chain of projection operators; false otherwise
+     */
+    public static boolean chainOfProjects(LogicalPlan plan) {
+        
+        if (plan == null) {
+            return false;
+        }
+        
+        List<LogicalOperator> leaves = plan.getLeaves();
+
+        if (leaves == null) {
+            return false;
+        }
+
+        if (leaves.size() > 1) {
+            return false;
+        }
+
+        LogicalOperator node = leaves.get(0);
+
+        while (true) {
+            if ((node == null) || !(node instanceof LOProject)) {
+                //not a projection operator
+                return false;
+            }
+
+            List<LogicalOperator> predecessors = plan.getPredecessors(node);
+
+            if (predecessors == null) {
+                //we have reached the root
+                return true;
+            }
+
+            if (predecessors.size() > 1) {
+                //a project cannot have multiple inputs
+                return false;
+            }
+
+            node = predecessors.get(0);
+        }
+    }
+    
 }
diff --git a/src/org/apache/pig/impl/plan/ProjectionMap.java b/src/org/apache/pig/impl/plan/ProjectionMap.java
new file mode 100644
index 000000000..019a4039b
--- /dev/null
+++ b/src/org/apache/pig/impl/plan/ProjectionMap.java
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.pig.impl.plan;
+
+import java.io.Serializable;
+import java.lang.StringBuilder;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
+
+/**
+ * A struct detailing how a projection is altered by an operator.
+ */
+public class ProjectionMap {
+    /**
+     * Quick way for an operator to note that its input and output are the same.
+     */
+    private boolean mChanges = true;
+
+    /**
+     * Map of field changes, with keys being the output fields of the operator
+     * and values being the input fields. Fields are numbered from 0. So for a
+     * foreach operator derived from 'B = foreach A generate $0, $2, $3,
+     * udf($1)' would produce a mapping of 0->(0, 0), 2->(0, 1), 3->(0, 2)
+     */
+    private MultiMap<Integer, Pair<Integer, Integer>> mMappedFields;
+
+    /**
+     * List of fields removed from the input. This includes fields that were
+     * transformed, and thus are no longer the same fields. Using the example
+     * foreach given under mappedFields, this list would contain '(0,1)'.
+     */
+    private List<Pair<Integer, Integer>> mRemovedFields;
+
+    /**
+     * List of fields in the output of this operator that were created by this
+     * operator. Using the example foreach given under mappedFields, this list
+     * would contain '3'.
+     */
+    private List<Integer> mAddedFields;
+
+    /**
+     * 
+     * @param changes
+     *            to indicate if this projection map changes its input or not
+     */
+    public ProjectionMap(boolean changes) {
+        this(null, null, null, changes);
+    }
+
+    /**
+     * 
+     * @param mapFields
+     *            the mapping of input column to output column
+     * @param removedFields
+     *            the list of input columns that are removed
+     * @param addedFields
+     *            the list of columns that are added to the output
+     */
+    public ProjectionMap(MultiMap<Integer, Pair<Integer, Integer>> mapFields,
+            List<Pair<Integer, Integer>> removedFields,
+            List<Integer> addedFields) {
+        this(mapFields, removedFields, addedFields, true);
+    }
+
+    /**
+     * 
+     * @param mapFields
+     *            the mapping of input column to output column
+     * @param removedFields
+     *            the list of input columns that are removed
+     * @param addedFields
+     *            the list of columns that are added to the output
+     * @param changes
+     *            to indicate if this projection map changes its input or not
+     */
+    private ProjectionMap(MultiMap<Integer, Pair<Integer, Integer>> mapFields,
+            List<Pair<Integer, Integer>> removedFields,
+            List<Integer> addedFields, boolean changes) {
+        mMappedFields = mapFields;
+        mAddedFields = addedFields;
+        mRemovedFields = removedFields;
+        mChanges = changes;
+    }
+
+    /**
+     * 
+     * @return the mapping of input column to output column
+     */
+    public MultiMap<Integer, Pair<Integer, Integer>> getMappedFileds() {
+        return mMappedFields;
+    }
+
+    /**
+     * 
+     * @param fields
+     *            the mapping of input column to output column
+     */
+    public void setMappedFileds(MultiMap<Integer, Pair<Integer, Integer>> fields) {
+        mMappedFields = fields;
+    }
+
+    /**
+     * 
+     * @return the list of input columns that are removed
+     */
+    public List<Pair<Integer, Integer>> getRemovedFileds() {
+        return mRemovedFields;
+    }
+
+    /**
+     * 
+     * @param fields
+     *            the list of input columns that are removed
+     */
+    public void setRemovedFileds(List<Pair<Integer, Integer>> fields) {
+        mRemovedFields = fields;
+    }
+
+    /**
+     * 
+     * @return the list of columns that are added to the output
+     */
+    public List<Integer> getAddedFileds() {
+        return mAddedFields;
+    }
+
+    /**
+     * 
+     * @param fields
+     *            the list of columns that are added to the output
+     */
+    public void setAddedFileds(List<Integer> fields) {
+        mAddedFields = fields;
+    }
+
+    /**
+     * 
+     * @return if this projection map changes its input or not
+     */
+    public boolean changes() {
+        return getChanges();
+    }
+
+
+    /**
+     * 
+     * @return if this projection map changes its input or not
+     */
+    public boolean getChanges() {
+        return mChanges;
+    }
+
+    /**
+     * 
+     * @param changes
+     *            if this projection map changes its input or not
+     */
+    public void setChanges(boolean changes) {
+        mChanges = changes;
+    }
+    
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("changes: " + mChanges);
+        sb.append(" mapped fields: " + mMappedFields);
+        sb.append(" added fields: " + mAddedFields);
+        sb.append(" removed fields: " + mRemovedFields);
+        return sb.toString();
+    }
+}
\ No newline at end of file
diff --git a/test/org/apache/pig/test/TestProjectionMap.java b/test/org/apache/pig/test/TestProjectionMap.java
new file mode 100644
index 000000000..4d130d2b9
--- /dev/null
+++ b/test/org/apache/pig/test/TestProjectionMap.java
@@ -0,0 +1,1311 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.pig.test;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Random;
+import java.net.URL;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Set;
+
+import junit.framework.AssertionFailedError;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.pig.LoadFunc;
+import org.apache.pig.FuncSpec;
+import org.apache.pig.PigServer;
+import org.apache.pig.backend.datastorage.DataStorage;
+import org.apache.pig.builtin.PigStorage;
+import org.apache.pig.data.DataBag;
+import org.apache.pig.data.Tuple;
+import org.apache.pig.data.TupleFactory;
+import org.apache.pig.impl.PigContext;
+import org.apache.pig.ExecType;
+import org.apache.pig.impl.builtin.GFAny;
+import org.apache.pig.impl.io.BufferedPositionedInputStream;
+import org.apache.pig.impl.io.FileLocalizer;
+import org.apache.pig.impl.plan.OperatorKey;
+import org.apache.pig.impl.plan.ProjectionMap;
+import org.apache.pig.impl.logicalLayer.*;
+import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.data.DataType;
+import org.apache.pig.impl.logicalLayer.parser.ParseException ;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.util.Pair;
+import org.apache.pig.test.utils.Identity;
+import org.apache.pig.test.utils.LogicalPlanTester;
+import org.apache.pig.impl.util.LogUtils;
+import org.apache.pig.PigException;
+
+
+public class TestProjectionMap extends junit.framework.TestCase {
+
+    private final Log log = LogFactory.getLog(getClass());
+    LogicalPlanTester planTester = new LogicalPlanTester();
+    
+    @After
+    @Override
+    public void tearDown() throws Exception{
+        planTester.reset(); 
+    }
+
+    
+    @Test
+    public void testQueryForeach1() {
+        String query = "foreach (load 'a') generate $1,$2;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the foreach projection map has null mappedFields
+        //and null removed fields since the input schema is null
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        assertTrue(foreachProjectionMap.getMappedFileds() == null);
+        assertTrue(foreachProjectionMap.getRemovedFileds() == null);
+        
+        //check that added fields contain [0, 1]
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields.size() == 2);
+        assertTrue(foreachAddedFields.get(0) == 0);
+        assertTrue(foreachAddedFields.get(1) == 1);
+    }
+
+    @Test
+    public void testQueryForeach2() {
+        String query = "foreach (load 'a' using " + PigStorage.class.getName() + "(':')) generate $1, 'aoeuaoeu' ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the foreach projection map has null mappedFields
+        //and null removed fields since the input schema is null
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        assertTrue(foreachProjectionMap.getMappedFileds() == null);
+        assertTrue(foreachProjectionMap.getRemovedFileds() == null);
+        
+        //check that added fields contain [0, 1]
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields.size() == 2);
+        assertTrue(foreachAddedFields.get(0) == 0);
+        assertTrue(foreachAddedFields.get(1) == 1);
+    }
+
+    @Test
+    public void testQueryCogroup1() {
+        String query = "foreach (cogroup (load 'a') by $1, (load 'b') by $1) generate org.apache.pig.builtin.AVG($1) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        assertTrue(mapValues.get(1).first == 1);
+        assertTrue(mapValues.get(1).second == 1);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        assertTrue(foreachProjectionMap.getMappedFileds() == null);
+
+        //check that removed fields has all the columns from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachProjectionMap.getRemovedFileds().size() == 3);
+        int expectedColumn = 0;
+        for(Pair<Integer, Integer> removedField: foreachRemovedFields) {
+            assertTrue(removedField.first == 0);
+            assertTrue(removedField.second == expectedColumn++);
+        }
+        
+        //check that added fields contain [0]
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields.size() == 1);
+        assertTrue(foreachAddedFields.get(0) == 0);
+    }
+
+    @Test
+    public void testQueryGroupAll() throws Exception {
+        String query = "foreach (group (load 'a') ALL) generate $1 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields == null);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [0, 1]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 0);
+        assertTrue(cogroupAddedFields.get(1) == 1);
+        
+        //check that the foreach projection map has non-null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMappedFields = foreachProjectionMap.getMappedFileds();
+        assertTrue(foreachMappedFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMappedFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+
+
+        //check that removed fields has all the columns from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+
+    @Test
+    public void testQueryGroup2() {
+        String query = "foreach (group (load 'a') by $1) generate group, '1' ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [0, 1]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 1);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        
+        //check that the foreach projection map has non-null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);        
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        assertTrue(foreachMapFields != null);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 0);
+
+
+        //check that removed fields has all the columns from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 1);
+        
+        //check that added fields contain [1]
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields != null);
+        assertTrue(foreachAddedFields.size() == 1);
+        assertTrue(foreachAddedFields.get(0) == 1);
+    }
+
+    @Test
+    public void testQueryCogroup2() {
+        String query = "foreach (cogroup (load 'a') by ($1), (load 'b') by ($1)) generate $1.$1, $2.$1 ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        assertTrue(mapValues.get(1).first == 1);
+        assertTrue(mapValues.get(1).second == 1);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        assertTrue(foreachMapFields != null);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 2);
+
+        //check that removed fields has all the group column from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+
+    @Test
+    public void testQueryGroup3() {
+        String query = "foreach (group (load 'a') by ($6, $7)) generate flatten(group) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 6);
+        assertTrue(mapValues.get(1).first == 0);
+        assertTrue(mapValues.get(1).second == 7);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 1);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        
+        //check that the foreach projection map has null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        assertTrue(foreachMapFields != null);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 0);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 0);
+
+        //check that removed fields has all the group column from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 1);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+
+    }
+
+    @Test
+    public void testQueryFilterNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = filter a by $1 == '3';");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the filter projection map has null mappedFields
+        LOFilter filter = (LOFilter)lp.getLeaves().get(0);
+        ProjectionMap filterProjectionMap = filter.getProjectionMap();
+        assertTrue(filterProjectionMap == null);
+    }
+    
+    @Test
+    public void testQueryOrderByNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = order a by $1;");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the order by projection map has null mappedFields
+        LOSort sort = (LOSort)lp.getLeaves().get(0);
+        ProjectionMap sortProjectionMap = sort.getProjectionMap();
+        assertTrue(sortProjectionMap == null);
+    }
+    
+    @Test
+    public void testQueryDistinctNoSchema() {
+        planTester.buildPlan("a = load 'a';");
+        LogicalPlan lp = planTester.buildPlan("b = distinct a;");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the distinct projection map has null mappedFields
+        LODistinct distinct = (LODistinct)lp.getLeaves().get(0);
+        ProjectionMap distinctProjectionMap = distinct.getProjectionMap();
+        assertTrue(distinctProjectionMap == null);
+    }
+    
+    @Test
+    public void testQueryForeach3() {
+        String query = "foreach (load 'a') generate ($1 == '3'? $2 : $3) ;";
+        LogicalPlan lp = planTester.buildPlan(query);
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the foreach projection map has null mappedFields
+        //and null removed fields since the input schema is null
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        assertTrue(foreachProjectionMap.getMappedFileds() == null);
+        assertTrue(foreachProjectionMap.getRemovedFileds() == null);
+        
+        //check that added fields contain [0]
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields.size() == 1);
+        assertTrue(foreachAddedFields.get(0) == 0);
+    }
+    
+    @Test
+    public void testQueryForeach4() {
+        planTester.buildPlan("A = load 'a';");
+        planTester.buildPlan("B = load 'b';");
+        LogicalPlan lp = planTester.buildPlan("foreach (cogroup A by ($1), B by ($1)) generate A, flatten(B.($1, $2, $3));");
+        
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(cogroupMapValues.get(0).first == 0);
+        assertTrue(cogroupMapValues.get(0).second == 1);
+        assertTrue(cogroupMapValues.get(1).first == 1);
+        assertTrue(cogroupMapValues.get(1).second == 1);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has non-null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds();
+        assertTrue(foreachMapFields != null);
+        
+        List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 1);
+        
+        for(int i = 1; i < 4; ++i) {
+            foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(i);
+            assertTrue(foreachMapValues.get(0).first == 0);
+            assertTrue(foreachMapValues.get(0).second == 2);
+        }
+        
+        //check that removed fields has all the group column from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachProjectionMap.getRemovedFileds().size() == 1);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+    
+    @Test
+    public void testForeach5() {
+        planTester.buildPlan("A = load 'a';");
+        planTester.buildPlan("B = load 'b';");
+        planTester.buildPlan("C = cogroup A by ($1), B by ($1);");
+        String query = "foreach C { " +
+                "B = order B by $0; " +
+                "generate FLATTEN(A), B.($1, $2, $3) ;" +
+                "};" ;
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(cogroupMapValues.get(0).first == 0);
+        assertTrue(cogroupMapValues.get(0).second == 1);
+        assertTrue(cogroupMapValues.get(1).first == 1);
+        assertTrue(cogroupMapValues.get(1).second == 1);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds();
+        assertTrue(foreachMapFields != null);
+        
+        List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 1);
+        
+        //check that removed fields has all the columns from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachProjectionMap.getRemovedFileds().size() == 2);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        removedField = foreachRemovedFields.get(1);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 2);
+
+        //check that added fields contain [0]
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields.size() == 1);
+        assertTrue(foreachAddedFields.get(0) == 1);
+    }
+    
+    
+    @Test
+    public void testQueryCrossNoSchema(){
+        String query = "c = cross (load 'a'), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cross projection map
+        LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
+        ProjectionMap crossProjectionMap = cross.getProjectionMap();
+        assertTrue(crossProjectionMap == null);
+        
+    }
+    
+    @Test
+    public void testQueryUnionNoSchema(){
+        String query = "c = union (load 'a'), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check union projection map
+        LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
+        ProjectionMap unionProjectionMap = union.getProjectionMap();
+        assertTrue(unionProjectionMap == null);
+        
+    }
+    
+    @Test
+    public void testQueryFRJoinNoSchema(){
+        String query = "c = join (load 'a') by $0, (load 'b') by $0 using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cross projection map
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
+        assertTrue(frjoinProjectionMap == null);
+        
+    }
+
+    @Test
+    public void testQueryJoinNoSchema(){
+        String query = "c = join (load 'a') by $0, (load 'b') by $0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 0);
+        assertTrue(mapValues.get(1).first == 1);
+        assertTrue(mapValues.get(1).second == 0);
+        
+        //check the cogroup removed fields is null
+        assertTrue(cogroupProjectionMap.getRemovedFileds() == null);
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has non-null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        assertTrue(foreachMapFields != null);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 2);
+
+        //check that removed fields has all the group column from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+    
+    @Test
+    public void testQueryFilterWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = filter a by $1 == '3';");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the filter projection map is not null
+        LOFilter filter = (LOFilter)lp.getLeaves().get(0);
+        ProjectionMap filterProjectionMap = filter.getProjectionMap();
+        assertTrue(filterProjectionMap != null);
+        assertTrue(filterProjectionMap.changes() == false);
+    }
+    
+    @Test
+    public void testQueryOrderByWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = order a by $1;");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the order by projection map is not null
+        LOSort sort = (LOSort)lp.getLeaves().get(0);
+        ProjectionMap sortProjectionMap = sort.getProjectionMap();
+        assertTrue(sortProjectionMap != null);
+        assertTrue(sortProjectionMap.changes() == false);
+    }
+    
+    @Test
+    public void testQueryDistinctWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        LogicalPlan lp = planTester.buildPlan("b = distinct a;");
+        
+        //check that the load projection map is null
+        LOLoad load = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadProjectionMap = load.getProjectionMap();
+        assertTrue(loadProjectionMap == null);
+        
+        //check that the distinct projection map is not null
+        LODistinct distinct = (LODistinct)lp.getLeaves().get(0);
+        ProjectionMap distinctProjectionMap = distinct.getProjectionMap();
+        assertTrue(distinctProjectionMap != null);
+        assertTrue(distinctProjectionMap.changes() == false);
+    }
+
+    
+    @Test
+    public void testQueryImplicitJoinWithSchema() {
+        planTester.buildPlan("a = load 'a' as (url,hitCount);");
+        planTester.buildPlan("b = load 'b' as (url,rank);");
+        planTester.buildPlan("c = cogroup a by url, b by url;");
+        LogicalPlan lp = planTester.buildPlan("d = foreach c generate group,flatten(a),flatten(b);");
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> cogroupMapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(cogroupMapValues.get(0).first == 0);
+        assertTrue(cogroupMapValues.get(0).second == 0);
+        assertTrue(cogroupMapValues.get(1).first == 1);
+        assertTrue(cogroupMapValues.get(1).second == 0);
+        
+        //check that removed fields has hitCount from a and rank from b
+        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFileds();
+        assertTrue(cogroupRemovedFields.size() == 2);
+        Pair<Integer, Integer> removedField = cogroupRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 1);
+        
+        removedField = cogroupRemovedFields.get(1);
+        assertTrue(removedField.first == 1);
+        assertTrue(removedField.second == 1);
+
+        
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds();
+        assertTrue(foreachMapFields != null);
+        
+        List<Pair<Integer, Integer>> foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 0);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 1);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 1);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(3);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 2);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(4);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 2);
+        
+        //check that removed fields is null
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields == null);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+        
+        lp = planTester.buildPlan("e = foreach d generate group, a::url, b::url, b::rank, rank;");
+        
+        foreach = (LOForEach)lp.getLeaves().get(0);
+        foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        foreachMapFields = foreachProjectionMap.getMappedFileds();
+        assertTrue(foreachMapFields != null);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 0);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 1);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 3);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(3);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 4);
+        
+        foreachMapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(4);
+        assertTrue(foreachMapValues.get(0).first == 0);
+        assertTrue(foreachMapValues.get(0).second == 4);
+        
+        //check that removed fields is null
+        foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields != null);
+        assertTrue(foreachRemovedFields.size() == 1);
+        
+        removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 2);
+        
+        //check that added fields is null
+        foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+    
+    @Test
+    public void testQueryCrossWithSchema(){
+        String query = "c = cross (load 'a' as (url, hitcount)), (load 'b' as (url, rank));";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cross projection map
+        LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
+        ProjectionMap crossProjectionMap = cross.getProjectionMap();
+        assertTrue(crossProjectionMap != null);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> crossMapFields = crossProjectionMap.getMappedFileds();
+        assertTrue(crossMapFields != null);
+        
+        List<Pair<Integer, Integer>> crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(0);
+        assertTrue(crossMapValues.get(0).first == 0);
+        assertTrue(crossMapValues.get(0).second == 0);
+        
+        crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(1);
+        assertTrue(crossMapValues.get(0).first == 0);
+        assertTrue(crossMapValues.get(0).second == 1);
+        
+        crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(2);
+        assertTrue(crossMapValues.get(0).first == 1);
+        assertTrue(crossMapValues.get(0).second == 0);
+        
+        crossMapValues = (ArrayList<Pair<Integer, Integer>>)crossMapFields.get(3);
+        assertTrue(crossMapValues.get(0).first == 1);
+        assertTrue(crossMapValues.get(0).second == 1);
+        
+        //check that removed fields is null
+        List<Pair<Integer, Integer>> crossRemovedFields = crossProjectionMap.getRemovedFileds();
+        assertTrue(crossRemovedFields == null);
+        
+        //check that added fields is null
+        List<Integer> crossAddedFields = crossProjectionMap.getAddedFileds();
+        assertTrue(crossAddedFields == null);
+    }
+    
+    @Test
+    public void testQueryUnionWithSchema(){
+        String query = "c = union (load 'a' as (url, hitcount)), (load 'b' as (url, rank));";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check union projection map
+        LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
+        ProjectionMap unionProjectionMap = union.getProjectionMap();
+        assertTrue(unionProjectionMap != null);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> unionMapFields = unionProjectionMap.getMappedFileds();
+        assertTrue(unionMapFields != null);
+
+        List<Pair<Integer, Integer>> unionMapValues = (ArrayList<Pair<Integer, Integer>>)unionMapFields.get(0);
+        assertTrue(unionMapValues.get(0).first == 0);
+        assertTrue(unionMapValues.get(0).second == 0);
+        
+        assertTrue(unionMapValues.get(1).first == 1);
+        assertTrue(unionMapValues.get(1).second == 0);
+        
+        unionMapValues = (ArrayList<Pair<Integer, Integer>>)unionMapFields.get(1);
+        assertTrue(unionMapValues.get(0).first == 0);
+        assertTrue(unionMapValues.get(0).second == 1);
+        
+        assertTrue(unionMapValues.get(1).first == 1);
+        assertTrue(unionMapValues.get(1).second == 1);
+        
+        //check that removed fields is null
+        List<Pair<Integer, Integer>> unionRemovedFields = unionProjectionMap.getRemovedFileds();
+        assertTrue(unionRemovedFields == null);
+        
+        //check that added fields is null
+        List<Integer> unionAddedFields = unionProjectionMap.getAddedFileds();
+        assertTrue(unionAddedFields == null);
+
+    }
+    
+    @Test
+    public void testQueryFRJoinWithSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b' as (url, rank)) by $0 using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cross projection map
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
+        assertTrue(frjoinProjectionMap != null);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> frjoinMapFields = frjoinProjectionMap.getMappedFileds();
+        assertTrue(frjoinMapFields != null);
+
+        List<Pair<Integer, Integer>> frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(0);
+        assertTrue(frjoinMapValues.get(0).first == 0);
+        assertTrue(frjoinMapValues.get(0).second == 0);
+        
+        frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(1);
+        assertTrue(frjoinMapValues.get(0).first == 0);
+        assertTrue(frjoinMapValues.get(0).second == 1);
+        
+        frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(2);
+        assertTrue(frjoinMapValues.get(0).first == 1);
+        assertTrue(frjoinMapValues.get(0).second == 0);
+        
+        frjoinMapValues = (ArrayList<Pair<Integer, Integer>>)frjoinMapFields.get(3);
+        assertTrue(frjoinMapValues.get(0).first == 1);
+        assertTrue(frjoinMapValues.get(0).second == 1);
+        
+        //check that removed fields is null
+        List<Pair<Integer, Integer>> frjoinRemovedFields = frjoinProjectionMap.getRemovedFileds();
+        assertTrue(frjoinRemovedFields == null);
+        
+        //check that added fields is null
+        List<Integer> frjoinAddedFields = frjoinProjectionMap.getAddedFileds();
+        assertTrue(frjoinAddedFields == null);
+
+    }
+
+    @Test
+    public void testQueryJoinWithSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b' as (url, rank)) by $0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 0);
+        assertTrue(mapValues.get(1).first == 1);
+        assertTrue(mapValues.get(1).second == 0);
+        
+        //check that removed fields is not null
+        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFileds();
+        assertTrue(cogroupRemovedFields != null);
+        
+        Pair<Integer, Integer> removedFields = cogroupRemovedFields.get(0);
+        assertTrue(removedFields.first == 0);
+        assertTrue(removedFields.second == 1);
+
+        removedFields = cogroupRemovedFields.get(1);
+        assertTrue(removedFields.first == 1);
+        assertTrue(removedFields.second == 1);
+
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has non-null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        assertTrue(foreachMapFields != null);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 2);
+
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(3);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 2);
+
+        
+        //check that removed fields has all the group column from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+
+    @Test
+    public void testQueryCrossWithMixedSchema(){
+        String query = "c = cross (load 'a' as (url, hitcount)), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cross projection map
+        LOCross cross = (LOCross)lp.getSuccessors(loada).get(0);
+        ProjectionMap crossProjectionMap = cross.getProjectionMap();
+        assertTrue(crossProjectionMap == null);
+    }
+    
+    @Test
+    public void testQueryUnionWithMixedSchema(){
+        String query = "c = union (load 'a' as (url, hitcount)), (load 'b');";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check union projection map
+        LOUnion union = (LOUnion)lp.getSuccessors(loada).get(0);
+        ProjectionMap unionProjectionMap = union.getProjectionMap();
+        assertTrue(unionProjectionMap == null);
+    }
+    
+    @Test
+    public void testQueryFRJoinWithMixedSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b') by $0 using \"replicated\";";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cross projection map
+        LOFRJoin frjoin = (LOFRJoin)lp.getSuccessors(loada).get(0);
+        ProjectionMap frjoinProjectionMap = frjoin.getProjectionMap();
+        assertTrue(frjoinProjectionMap == null);
+        
+    }
+    
+    @Test
+    public void testQueryJoinWithMixedSchema(){
+        String query = "c = join (load 'a' as (url, hitcount)) by $0, (load 'b') by $0;";
+        LogicalPlan lp = planTester.buildPlan(query);
+
+        //check that the loads' projection map is null
+        LOLoad loada = (LOLoad) lp.getRoots().get(0);
+        ProjectionMap loadaProjectionMap = loada.getProjectionMap();
+        assertTrue(loadaProjectionMap == null);
+        
+        LOLoad loadb = (LOLoad) lp.getRoots().get(1);
+        ProjectionMap loadbProjectionMap = loadb.getProjectionMap();
+        assertTrue(loadbProjectionMap == null);
+        
+        //check cogroup projection map
+        LOCogroup cogroup = (LOCogroup)lp.getSuccessors(loada).get(0);
+        ProjectionMap cogroupProjectionMap = cogroup.getProjectionMap();
+        assertTrue(cogroupProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> cogroupMapFields = cogroupProjectionMap.getMappedFileds(); 
+        assertTrue(cogroupMapFields != null);
+        
+        List<Pair<Integer, Integer>> mapValues = (ArrayList<Pair<Integer, Integer>>)cogroupMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 0);
+        assertTrue(mapValues.get(1).first == 1);
+        assertTrue(mapValues.get(1).second == 0);
+        
+        //check that removed fields is not null
+        List<Pair<Integer, Integer>> cogroupRemovedFields = cogroupProjectionMap.getRemovedFileds();
+        assertTrue(cogroupRemovedFields.size() == 1);
+        
+        Pair<Integer, Integer> removedFields = cogroupRemovedFields.get(0);
+        assertTrue(removedFields.first == 0);
+        assertTrue(removedFields.second == 1);
+
+        //check that cogroup added fields contain [1, 2]
+        List<Integer> cogroupAddedFields = cogroupProjectionMap.getAddedFileds();
+        assertTrue(cogroupAddedFields.size() == 2);
+        assertTrue(cogroupAddedFields.get(0) == 1);
+        assertTrue(cogroupAddedFields.get(1) == 2);
+        
+        //check that the foreach projection map has non-null mappedFields
+        LOForEach foreach = (LOForEach)lp.getLeaves().get(0);
+        ProjectionMap foreachProjectionMap = foreach.getProjectionMap();
+        assertTrue(foreachProjectionMap.changes() == true);
+        
+        MultiMap<Integer, Pair<Integer, Integer>> foreachMapFields = foreachProjectionMap.getMappedFileds(); 
+        assertTrue(foreachMapFields.size() == 3);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(0);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+        
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(1);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 1);
+
+        mapValues = (ArrayList<Pair<Integer, Integer>>)foreachMapFields.get(2);
+        assertTrue(mapValues.get(0).first == 0);
+        assertTrue(mapValues.get(0).second == 2);
+
+        
+        //check that removed fields has all the group column from the input cogroup
+        List<Pair<Integer, Integer>> foreachRemovedFields = foreachProjectionMap.getRemovedFileds();
+        assertTrue(foreachRemovedFields.size() == 1);
+        Pair<Integer, Integer> removedField = foreachRemovedFields.get(0);
+        assertTrue(removedField.first == 0);
+        assertTrue(removedField.second == 0);
+        
+        //check that added fields is null
+        List<Integer> foreachAddedFields = foreachProjectionMap.getAddedFileds();
+        assertTrue(foreachAddedFields == null);
+    }
+    
+}
