diff --git a/CHANGES.txt b/CHANGES.txt
index f3ddf56b8..dc35ff91d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -118,6 +118,9 @@ PIG-1696: Performance: Use System.arraycopy() instead of manually copying the by
 
 BUG FIXES
 
+PIG-1933: Hints such as 'collected' and 'skewed' for "group by" or "join by" 
+ should not be treated as tokens. (xuefuz via thejas)
+
 PIG-1925: Parser error message doesn't show location of the error or show it
 as Line 0:0 (xuefuz via gates)
 
diff --git a/src/org/apache/pig/parser/AliasMasker.g b/src/org/apache/pig/parser/AliasMasker.g
index 46101065f..38c4f4160 100644
--- a/src/org/apache/pig/parser/AliasMasker.g
+++ b/src/org/apache/pig/parser/AliasMasker.g
@@ -244,10 +244,7 @@ group_clause
     )
 ;
 
-group_type
-    : HINT_COLLECTED { sb.append($HINT_COLLECTED.text); } 
-    | HINT_MERGE  { sb.append($HINT_MERGE.text); } 
-    | HINT_REGULAR { sb.append($HINT_REGULAR.text); } 
+group_type : QUOTEDSTRING { sb.append( $QUOTEDSTRING.text ); } 
 ;
 
 group_item
@@ -411,11 +408,7 @@ join_clause
     ( partition_clause )? )
 ;
 
-join_type
-    : HINT_REPL  { sb.append($HINT_REPL.text); }
-    | HINT_MERGE { sb.append($HINT_MERGE.text); }
-    | HINT_SKEWED { sb.append($HINT_SKEWED.text); }
-    | HINT_DEFAULT { sb.append($HINT_DEFAULT.text); }
+join_type : QUOTEDSTRING { sb.append( $QUOTEDSTRING.text ); }
 ;
 
 join_sub_clause
diff --git a/src/org/apache/pig/parser/AstValidator.g b/src/org/apache/pig/parser/AstValidator.g
index 2adf22b04..ddddb775e 100644
--- a/src/org/apache/pig/parser/AstValidator.g
+++ b/src/org/apache/pig/parser/AstValidator.g
@@ -229,28 +229,11 @@ scope {
 }
 @init {
     $group_clause::arity = 0;
-    int gt = HINT_REGULAR;
-    int num_inputs = 0;
 }
- : ^( ( GROUP | COGROUP ) 
-      ( group_item { num_inputs++; } )+ 
-      ( group_type { gt = $group_type.type; } )? 
-      partition_clause?
-    )
-    {
-        if( gt == HINT_COLLECTED ) {
-            if( num_inputs > 1 ) {
-                throw new ParserValidationException( input, new SourceLocation( (CommonTree)$group_type.start ),
-                    "Collected group is only supported for single input" );
-           } 
-        }
-    }
+ : ^( ( GROUP | COGROUP ) group_item+ group_type? partition_clause? )
 ;
 
-group_type returns [int type]
- : HINT_COLLECTED { $type = HINT_COLLECTED; } 
- | HINT_MERGE  { $type = HINT_MERGE; } 
- | HINT_REGULAR { $type = HINT_REGULAR; } 
+group_type : QUOTEDSTRING 
 ;
 
 group_item
@@ -379,53 +362,16 @@ scope {
 }
 @init {
     $join_clause::arity = 0;
-    boolean partitionerPresent = false;
-    int jt = HINT_DEFAULT;
 }
- : ^( JOIN join_sub_clause ( join_type { jt = $join_type.type; } )? ( partition_clause { partitionerPresent = true; } )? )
-   {
-       if( jt == HINT_SKEWED ) {
-           SourceLocation loc = new SourceLocation( (CommonTree)$join_type.start );
-           if( partitionerPresent ) {
-               throw new ParserValidationException( input, loc, 
-                   "Custom Partitioner is not supported for skewed join" );
-           }
-           
-           if( $join_sub_clause.inputCount != 2 ) {
-               throw new ParserValidationException( input, loc,
-                   "Skewed join can only be applied for 2-way joins" );
-           }
-       } else if( jt == HINT_MERGE && $join_sub_clause.inputCount != 2 ) {
-           SourceLocation loc = new SourceLocation( (CommonTree)$join_type.start );
-           throw new ParserValidationException( input, loc,
-               "Merge join can only be applied for 2-way joins" );
-       } else if( jt == HINT_REPL && $join_sub_clause.right ) {
-           SourceLocation loc = new SourceLocation( (CommonTree)$join_type.start );
-           throw new ParserValidationException( input, loc,
-               "Replicated join does not support (right|full) outer joins" );
-       }
-   }
+ : ^( JOIN join_sub_clause join_type? partition_clause? )
 ;
 
-join_type returns[int type]
- : HINT_REPL  { $type = HINT_REPL; }
- | HINT_MERGE { $type = HINT_MERGE; }
- | HINT_SKEWED { $type = HINT_SKEWED; }
- | HINT_DEFAULT { $type = HINT_DEFAULT; }
+join_type : QUOTEDSTRING
 ;
 
-join_sub_clause returns[int inputCount, boolean right, boolean left]
-@init {
-    $inputCount = 0;
-}
- : join_item ( LEFT { $left = true; }
-             | RIGHT { $right = true; }
-             | FULL { $left = true; $right = true; }
-             ) OUTER? join_item
-   { 
-       $inputCount = 2;
-   }
- | ( join_item { $inputCount++; } )+
+join_sub_clause
+ : join_item ( LEFT | RIGHT | FULL ) OUTER? join_item
+ | join_item+
 ;
 
 join_item
diff --git a/src/org/apache/pig/parser/LogicalPlanBuilder.java b/src/org/apache/pig/parser/LogicalPlanBuilder.java
index c423dd8e8..aa41c41df 100644
--- a/src/org/apache/pig/parser/LogicalPlanBuilder.java
+++ b/src/org/apache/pig/parser/LogicalPlanBuilder.java
@@ -232,6 +232,29 @@ public class LogicalPlanBuilder {
         else {
             op.pinOption(LOJoin.OPTION_JOIN);
         }
+        
+        int inputCount = inputAliases.size();
+        
+        if( jt == JOINTYPE.SKEWED ) {
+            if( partitioner != null ) {
+                throw new ParserValidationException( intStream, loc,
+                        "Custom Partitioner is not supported for skewed join" );
+            }
+            
+            if( inputCount != 2 ) {
+                throw new ParserValidationException( intStream, loc,
+                        "Skewed join can only be applied for 2-way joins" );
+            }
+        } else if( jt == JOINTYPE.MERGE && inputCount != 2 ) {
+            throw new ParserValidationException( intStream, loc,
+                    "Merge join can only be applied for 2-way joins" );
+        } else if( jt == JOINTYPE.REPLICATED ) {
+            if( innerFlags.size() == 2 && innerFlags.get( 0 ) == false ) {
+                throw new ParserValidationException( intStream, loc,
+                        "Replicated join does not support (right|full) outer joins" );
+            }
+        }
+
         boolean[] flags = new boolean[joinPlans.size()];
         if (innerFlags.size()!=0) {
             for( int i = 0; i < joinPlans.size(); i++ ) {
@@ -263,13 +286,18 @@ public class LogicalPlanBuilder {
         MultiMap<Integer, LogicalExpressionPlan> expressionPlans, GROUPTYPE gt, List<Boolean> innerFlags,
         String partitioner) throws ParserValidationException {
         if( gt == GROUPTYPE.COLLECTED ) {
+            if( inputAliases.size() > 1 ) {
+                throw new ParserValidationException( intStream, loc, 
+                        "Collected group is only supported for single input" );
+            }
+            
             List<LogicalExpressionPlan> exprPlans = expressionPlans.get( 0 );
             for( LogicalExpressionPlan exprPlan : exprPlans ) {
                 Iterator<Operator> it = exprPlan.getOperators();
                 while( it.hasNext() ) {
                     if( !( it.next() instanceof ProjectExpression ) ) {
                         throw new ParserValidationException( intStream, loc,
-                        		"Collected group is only supported for columns or star projection" );
+                                "Collected group is only supported for columns or star projection" );
                     }
                 }
             }
@@ -856,4 +884,36 @@ public class LogicalPlanBuilder {
         return f;
     }
     
+    GROUPTYPE parseGroupType(String hint, SourceLocation loc) throws ParserValidationException {
+        String modifier = unquote( hint );
+        
+        if( modifier.equalsIgnoreCase( "collected" ) ) {
+            return GROUPTYPE.COLLECTED;
+        } else if( modifier.equalsIgnoreCase( "regular" ) ){
+            return GROUPTYPE.REGULAR;
+        } else if( modifier.equalsIgnoreCase( "merge" ) ){
+            return GROUPTYPE.MERGE;
+        } else {
+            throw new ParserValidationException( intStream, loc,
+                "Only COLLECTED, REGULAR or MERGE are valid GROUP modifiers." );
+        }
+    }
+    
+    JOINTYPE parseJoinType(String hint, SourceLocation loc) throws ParserValidationException {
+        String modifier = unquote( hint );
+
+        if( modifier.equalsIgnoreCase( "repl" ) || modifier.equalsIgnoreCase( "replicated" ) ) {
+                  return JOINTYPE.REPLICATED; 
+          } else if( modifier.equalsIgnoreCase( "hash" ) || modifier.equalsIgnoreCase( "default" ) ) {
+                  return LOJoin.JOINTYPE.HASH;
+          } else if( modifier.equalsIgnoreCase( "skewed" ) ) {
+                 return JOINTYPE.SKEWED;
+          } else if (modifier.equalsIgnoreCase("merge")) {
+                  return JOINTYPE.MERGE;
+          } else {
+                  throw new ParserValidationException( intStream, loc,
+                          "Only REPL, REPLICATED, HASH, SKEWED and MERGE are vaild JOIN modifiers." );
+          }
+    }
+
 }
diff --git a/src/org/apache/pig/parser/LogicalPlanGenerator.g b/src/org/apache/pig/parser/LogicalPlanGenerator.g
index c98bc53ea..134938a09 100644
--- a/src/org/apache/pig/parser/LogicalPlanGenerator.g
+++ b/src/org/apache/pig/parser/LogicalPlanGenerator.g
@@ -149,7 +149,7 @@ public String getErrorMessage(RecognitionException e, String[] tokenNames) {
 
 @Override
 public String getErrorHeader(RecognitionException ex) {
-	return QueryParserUtils.generateErrorHeader( ex );
+    return QueryParserUtils.generateErrorHeader( ex );
 }
 
 } // End of @members
@@ -484,9 +484,10 @@ scope GScope;
 ;
 
 group_type returns[GROUPTYPE type]
- : HINT_COLLECTED { $type = GROUPTYPE.COLLECTED; }
- | HINT_MERGE { $type = GROUPTYPE.MERGE; }
- | HINT_REGULAR { $type = GROUPTYPE.REGULAR; }
+ : QUOTEDSTRING
+   {
+       $type =builder.parseGroupType( $QUOTEDSTRING.text, new SourceLocation( $QUOTEDSTRING.token ) );
+   } 
 ;
 
 group_item
@@ -967,10 +968,10 @@ scope GScope;
 ;
 
 join_type returns[JOINTYPE type]
- : HINT_REPL { $type = JOINTYPE.REPLICATED; }
- | HINT_MERGE { $type = JOINTYPE.MERGE; }
- | HINT_SKEWED { $type = JOINTYPE.SKEWED; }
- | HINT_DEFAULT { $type = JOINTYPE.HASH; }
+ : QUOTEDSTRING
+   {
+       $type = builder.parseJoinType( $QUOTEDSTRING.text, new SourceLocation( $QUOTEDSTRING.token ) );
+   }
 ;
 
 join_sub_clause
diff --git a/src/org/apache/pig/parser/QueryLexer.g b/src/org/apache/pig/parser/QueryLexer.g
index 4ea18ce6b..07e1b7935 100644
--- a/src/org/apache/pig/parser/QueryLexer.g
+++ b/src/org/apache/pig/parser/QueryLexer.g
@@ -297,24 +297,6 @@ DOUBLENUMBER : FLOATINGPOINT ( 'E' ( MINUS | PLUS )? INTEGER )?
 FLOATNUMBER : DOUBLENUMBER ( 'F' )?
 ;
 
-HINT_REPL : '\'REPL\'' |  '\'REPLICATED\''
-;
-
-HINT_SKEWED : '\'SKEWED\''
-;
-
-HINT_MERGE : '\'MERGE\''
-;
-
-HINT_DEFAULT : '\'HASH\'' | '\'DEFAULT\''
-;
-
-HINT_COLLECTED : '\'COLLECTED\''
-;
-
-HINT_REGULAR : '\'REGULAR\''
-;
-
 QUOTEDSTRING :  '\'' (   ( ~ ( '\'' | '\\' | '\n' | '\r' ) )
                        | ( '\\' ( ( 'N' | 'T' | 'B' | 'R' | 'F' | '\\' | '\'' ) ) )
                        | ( '\\u' ( '0'..'9' | 'A'..'F' )
diff --git a/src/org/apache/pig/parser/QueryParser.g b/src/org/apache/pig/parser/QueryParser.g
index 00f30a8c0..bf48b0c5d 100644
--- a/src/org/apache/pig/parser/QueryParser.g
+++ b/src/org/apache/pig/parser/QueryParser.g
@@ -257,7 +257,7 @@ func_args : func_args_string ( COMMA func_args_string )*
 group_clause : ( GROUP | COGROUP )^ group_item_list ( USING! group_type )? partition_clause?
 ;
 
-group_type : HINT_COLLECTED | HINT_MERGE | HINT_REGULAR
+group_type : QUOTEDSTRING
 ;
 
 group_item_list : group_item ( COMMA group_item )*
@@ -424,7 +424,7 @@ rel_list : rel ( COMMA rel )*
 join_clause : JOIN^ join_sub_clause ( USING! join_type )? partition_clause?
 ;
 
-join_type : HINT_REPL | HINT_MERGE | HINT_SKEWED | HINT_DEFAULT
+join_type : QUOTEDSTRING
 ;
 
 join_sub_clause : join_item ( LEFT | RIGHT | FULL ) OUTER? COMMA! join_item
diff --git a/test/org/apache/pig/parser/TestQueryParser.java b/test/org/apache/pig/parser/TestQueryParser.java
index 0de3f0577..8deb1a84d 100644
--- a/test/org/apache/pig/parser/TestQueryParser.java
+++ b/test/org/apache/pig/parser/TestQueryParser.java
@@ -151,6 +151,15 @@ public class TestQueryParser {
         shouldPass( query );
     }
 
+    // 'repl' and such, shouldn't be treated as a constant. So, the following should pass.
+    @Test
+    public void test11() throws IOException, RecognitionException {
+        String query = "a = load 'repl' as (name, age, gpa);" +
+            "b = FOREACH C GENERATE group, flatten( ( 1 == 2 ? 2 : 3 ) );" +
+            " store b into 'skewed'; ";
+        shouldPass( query );
+    }
+
     @Test
     public void testBagType() throws IOException, RecognitionException {
         String query = "a = load '1.txt' as ( u : bag{}, v : bag{tuple(x, y)} );" +
