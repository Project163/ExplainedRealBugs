diff --git a/CHANGES.txt b/CHANGES.txt
index 9c75f6d49..97e714faf 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -40,6 +40,8 @@ OPTIMIZATIONS
 Â 
 BUG FIXES
 
+PIG-4973: Bigdecimal divison fails (szita via daijy)
+
 PIG-4967: NPE in PigJobControl.run() when job status is null (water via daijy)
 
 PIG-4972: StreamingIO_1 fail on perl 5.22 (daijy)
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java
index aaf3ec700..f8d78b119 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/expressionOperators/Divide.java
@@ -19,7 +19,10 @@ package org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOp
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.math.RoundingMode;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pig.PigWarning;
 import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
@@ -36,6 +39,8 @@ public class Divide extends BinaryExpressionOperator {
      *
      */
     private static final long serialVersionUID = 1L;
+    public static final short BIGDECIMAL_MINIMAL_SCALE = 6;
+    private static final Log LOG = LogFactory.getLog(Divide.class);
 
     public Divide(OperatorKey k) {
         super(k);
@@ -72,12 +77,22 @@ public class Divide extends BinaryExpressionOperator {
         case DataType.BIGINTEGER:
             return ((BigInteger) a).divide((BigInteger) b);
         case DataType.BIGDECIMAL:
-            return ((BigDecimal) a).divide((BigDecimal) b);
+            return bigDecimalDivideWithScale(a, b);
         default:
             throw new ExecException("called on unsupported Number class " + DataType.findTypeName(dataType));
         }
     }
 
+    private Number bigDecimalDivideWithScale(Number a, Number b) {
+        // Using same result scaling as Hive. See Arithmetic Rules:
+        //   https://cwiki.apache.org/confluence/download/attachments/27362075/Hive_Decimal_Precision_Scale_Support.pdf
+        int resultScale = Math.max(BIGDECIMAL_MINIMAL_SCALE, ((BigDecimal)a).scale() + ((BigDecimal)b).precision() + 1);
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("For bigdecimal divide: using " + resultScale + " as result scale.");
+        }
+        return ((BigDecimal)a).divide((BigDecimal)b, resultScale, RoundingMode.HALF_UP);
+    }
+
     /*
      * This method is used to invoke the appropriate method, as Java does not provide generic
      * dispatch for it.
diff --git a/test/org/apache/pig/test/TestDivide.java b/test/org/apache/pig/test/TestDivide.java
index 1d9d9b454..6cd27d28c 100644
--- a/test/org/apache/pig/test/TestDivide.java
+++ b/test/org/apache/pig/test/TestDivide.java
@@ -20,6 +20,9 @@ package org.apache.pig.test;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
+import java.math.BigDecimal;
+import java.math.MathContext;
+import java.math.RoundingMode;
 import java.util.Map;
 import java.util.Random;
 
@@ -53,7 +56,7 @@ public class TestDivide {
     public void testOperator() throws ExecException {
         // int TRIALS = 10;
         byte[] types = { DataType.BAG, DataType.BOOLEAN, DataType.BYTEARRAY, DataType.CHARARRAY,
-                        DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG,
+                        DataType.DOUBLE, DataType.FLOAT, DataType.INTEGER, DataType.LONG, DataType.BIGDECIMAL,
                         DataType.DATETIME, DataType.MAP, DataType.TUPLE };
         // Map<Byte,String> map = GenRandomData.genTypeToNameMap();
         System.out.println("Testing DIVIDE operator");
@@ -250,6 +253,33 @@ public class TestDivide {
                 assertEquals(null, (Long)resl.result);
                 break;
             }
+            case DataType.BIGDECIMAL: {
+                MathContext mc = new MathContext(Divide.BIGDECIMAL_MINIMAL_SCALE, RoundingMode.HALF_UP);
+                BigDecimal inpf1 = new BigDecimal(r.nextDouble(),mc);
+                BigDecimal inpf2 = new BigDecimal(r.nextDouble(),mc);
+                lt.setValue(inpf1);
+                rt.setValue(inpf2);
+                Result resf = op.getNextBigDecimal();
+                BigDecimal expected = inpf1.divide(inpf2, 2 * Divide.BIGDECIMAL_MINIMAL_SCALE + 1, RoundingMode.HALF_UP);
+                assertEquals(expected, (BigDecimal)resf.result);
+
+                // test with null in lhs
+                lt.setValue(null);
+                rt.setValue(inpf2);
+                resf = op.getNextBigDecimal();
+                assertEquals(null, (BigDecimal)resf.result);
+                // test with null in rhs
+                lt.setValue(inpf1);
+                rt.setValue(null);
+                resf = op.getNextBigDecimal();
+                assertEquals(null, (BigDecimal)resf.result);
+                // test divide by 0
+                lt.setValue(inpf1);
+                rt.setValue(new BigDecimal(0.0f,mc));
+                resf = op.getNextBigDecimal();
+                assertEquals(null, (BigDecimal)resf.result);
+                break;
+            }
             case DataType.DATETIME:
                 DateTime inpdt1 = new DateTime(r.nextLong());
                 DateTime inpdt2 = new DateTime(r.nextLong());
