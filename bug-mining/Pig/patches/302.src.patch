diff --git a/CHANGES.txt b/CHANGES.txt
index 1dbfcbffb..c617de644 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -41,6 +41,9 @@ OPTIMIZATIONS
 
 BUG FIXES
 
+PIG-1022:  optimizer pushes filter before the foreach that generates column
+used by filter (daijy via gates)
+
 PIG-1107: PigLineRecordReader bails out on an empty line for compressed data
 (ankit.modi via olgan)
 
diff --git a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
index 3fc3a4d84..2ec6dfbe0 100644
--- a/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
+++ b/src/org/apache/pig/impl/logicalLayer/optimizer/PushUpFilter.java
@@ -36,6 +36,7 @@ import org.apache.pig.impl.logicalLayer.LOFilter;
 import org.apache.pig.impl.logicalLayer.LOForEach;
 import org.apache.pig.impl.logicalLayer.LOLimit;
 import org.apache.pig.impl.logicalLayer.LOLoad;
+import org.apache.pig.impl.logicalLayer.LOProject;
 import org.apache.pig.impl.logicalLayer.LOSplit;
 import org.apache.pig.impl.logicalLayer.LOStore;
 import org.apache.pig.impl.logicalLayer.LOStream;
@@ -43,10 +44,12 @@ import org.apache.pig.impl.logicalLayer.LOSplitOutput;
 import org.apache.pig.impl.logicalLayer.LOUnion;
 import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
+import org.apache.pig.impl.logicalLayer.TopLevelProjectFinder;
 import org.apache.pig.impl.logicalLayer.UDFFinder;
 import org.apache.pig.impl.plan.DepthFirstWalker;
 import org.apache.pig.impl.plan.ProjectionMap;
 import org.apache.pig.impl.plan.RequiredFields;
+import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.plan.optimizer.OptimizerException;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.util.MultiMap;
@@ -256,6 +259,18 @@ public class PushUpFilter extends LogicalTransformer {
 
                 Pair<Boolean, Set<Integer>> mappingResult = isRequiredFieldMapped(requiredField, predecessor.getProjectionMap());
                 boolean mapped = mappingResult.first;
+                
+                // Check if it is a direct mapping, that is, project optionally followed by cast, so if project->project, it is not
+                // considered as a mapping
+                for (Pair<Integer, Integer> pair : requiredField.getFields())
+                {
+                    if (!isFieldSimple(loForEach.getForEachPlans().get(pair.second)))
+                    {
+                        mapped = false;
+                        break;
+                    }
+                }
+                
                 if (!mapped) {
                     return false;
                 }
@@ -420,4 +435,44 @@ public class PushUpFilter extends LogicalTransformer {
 
         return new Pair<Boolean, Set<Integer>>(true, grandParentIndexes);
     }
+    
+    /**
+     * Check if the inner plan is simple
+     * 
+     * @param lp
+     *        logical plan to check
+     * @return Whether if the logical plan is a simple project optionally followed by cast
+     */
+    boolean isFieldSimple(LogicalPlan lp) throws OptimizerException
+    {
+        TopLevelProjectFinder projectFinder = new TopLevelProjectFinder(lp);
+            
+        try {
+            projectFinder.visit();
+        } catch (VisitorException ve) {
+            throw new OptimizerException();
+        }
+        if (projectFinder.getProjectSet()!=null && projectFinder.getProjectSet().size()==1)
+        {
+            LOProject project = projectFinder.getProjectSet().iterator().next();
+            if (lp.getPredecessors(project)==null)
+            {
+                LogicalOperator pred = project;
+                while (lp.getSuccessors(pred)!=null)
+                {
+                    if (lp.getSuccessors(pred).size()!=1)
+                        return false;
+                    if (!(lp.getSuccessors(pred).get(0) instanceof LOCast))
+                    {
+                        return false;
+                    }
+                    pred = lp.getSuccessors(pred).get(0);
+                }
+                return true;
+            }
+            return false;
+        }
+        else
+            return true;
+    }
 }
diff --git a/test/org/apache/pig/test/TestPushUpFilter.java b/test/org/apache/pig/test/TestPushUpFilter.java
index 753cd76bc..d68b58a03 100644
--- a/test/org/apache/pig/test/TestPushUpFilter.java
+++ b/test/org/apache/pig/test/TestPushUpFilter.java
@@ -1050,6 +1050,24 @@ public class TestPushUpFilter extends junit.framework.TestCase {
         assertTrue(pushUpFilter.getPushBeforeInput() == -1);
         
     }
+    
+    @Test
+    public void testFilterNestedForEach() throws Exception {
+        planTester.buildPlan("A = load 'myfile' as (name, age, gpa);");
+        planTester.buildPlan("B = group A by name;");
+        planTester.buildPlan("C = foreach B generate A.age as age;");        
+        LogicalPlan lp = planTester.buildPlan("D = filter C by age == 20;");
+        
+        planTester.setPlan(lp);
+        planTester.setProjectionMap(lp);
+        
+        PushUpFilter pushUpFilter = new PushUpFilter(lp);
+        
+        assertTrue(!pushUpFilter.check(lp.getLeaves()));
+        assertTrue(pushUpFilter.getSwap() == false);
+        assertTrue(pushUpFilter.getPushBefore() == false);
+        assertTrue(pushUpFilter.getPushBeforeInput() == -1);
+    }
 
 }
 
