diff --git a/CHANGES.txt b/CHANGES.txt
index 8dd4f1b03..58bd864c6 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -221,4 +221,7 @@ Trunk (unreleased changes)
     PIG-442: Disambiguated alias after a foreach flatten is not accessible a
     couple of statements after the foreach (sms via olgan)
 
+    PIG-424: nested foreach with flatten and agg gives an error (sms via
+    olgan)
+
 
diff --git a/src/org/apache/pig/impl/logicalLayer/LOForEach.java b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
index 1dba3309a..b1f2dcd7a 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOForEach.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOForEach.java
@@ -171,7 +171,7 @@ public class LOForEach extends LogicalOperator {
 								for(int i = 0; i < s.size(); ++i) {
                                     Schema.FieldSchema fs;
                                     try {
-                                        fs = s.getField(i);
+                                        fs = new Schema.FieldSchema(s.getField(i));
                                     } catch (ParseException pe) {
                                         throw new FrontendException(pe.getMessage());
                                     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOProject.java b/src/org/apache/pig/impl/logicalLayer/LOProject.java
index 2954b574b..abf727643 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOProject.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOProject.java
@@ -233,7 +233,7 @@ public class LOProject extends ExpressionOperator {
                                 if(null != expOpFs) {
                                     Schema s = expOpFs.schema;
                                     if(null != s) {
-                                        mFieldSchema = s.getField(mProjection.get(0));
+                                        mFieldSchema = new Schema.FieldSchema(s.getField(mProjection.get(0)));
                                     } else {
                                         mFieldSchema = new Schema.FieldSchema(null, DataType.BYTEARRAY);
                                     }
@@ -245,7 +245,7 @@ public class LOProject extends ExpressionOperator {
                                    Schema s = expressionOperator.getSchema();
                                 log.debug("s: " + s);
                                 if(null != s) {
-                                    mFieldSchema = s.getField(mProjection.get(0));
+                                    mFieldSchema = new Schema.FieldSchema(s.getField(mProjection.get(0)));
                                     log.debug("mFieldSchema alias: " + mFieldSchema.alias);
                                     log.debug("mFieldSchema schema: " + mFieldSchema.schema);
                                 } else {
@@ -266,7 +266,7 @@ public class LOProject extends ExpressionOperator {
                                     log.debug("Schema s: " + s);
                                     if(null != s) {
                                         if(colNum < s.size()) {
-                                            fss.add(s.getField(colNum));
+                                            fss.add(new Schema.FieldSchema(s.getField(colNum)));
                                         } else {
                                             fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
                                         }
@@ -279,7 +279,7 @@ public class LOProject extends ExpressionOperator {
                             } else {
                                 Schema s = expressionOperator.getSchema();
                                 if(null != s) {
-                                    fss.add(s.getField(colNum));
+                                    fss.add(new Schema.FieldSchema(s.getField(colNum)));
                                 } else {
                                     fss.add(new Schema.FieldSchema(null, DataType.BYTEARRAY));
                                 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
index 82cd05c45..1f8f514f7 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUserFunc.java
@@ -97,7 +97,7 @@ public class LOUserFunc extends ExpressionOperator {
         if (null != udfSchema) {
             Schema.FieldSchema fs;
             try {
-                fs = udfSchema.getField(0);
+                fs = new Schema.FieldSchema(udfSchema.getField(0));
             } catch (ParseException pe) {
                 throw new FrontendException(pe.getMessage());
             }
diff --git a/src/org/apache/pig/impl/logicalLayer/schema/Schema.java b/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
index c1540e37e..bfa26449e 100644
--- a/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
+++ b/src/org/apache/pig/impl/logicalLayer/schema/Schema.java
@@ -137,6 +137,29 @@ public class Schema implements Serializable, Cloneable {
             type = t;
         }
 
+        /**
+         * Copy Constructor.
+         * 
+         * @param fs
+         *           Source FieldSchema
+         * 
+         */
+        public FieldSchema(FieldSchema fs)  {
+            if(null != fs) {
+                alias = fs.alias;
+                if(null != fs.schema) {
+                    schema = new Schema(fs.schema);
+                } else {
+                    schema = null;
+                }
+                type = fs.type;
+            } else {
+                alias = null;
+                schema = null;
+                type = DataType.UNKNOWN;
+            }
+        }
+
         /***
          *  Two field schemas are equal if types and schemas
          *  are equal in all levels.
@@ -459,6 +482,41 @@ public class Schema implements Serializable, Cloneable {
         }
     }
 
+    /**
+     * Copy Constructor.
+     * @param s source schema
+     */
+    public Schema(Schema s) {
+
+        if(null != s) {
+            mFields = new ArrayList<FieldSchema>(s.size());
+            mAliases = new HashMap<String, FieldSchema>();
+            mFieldSchemas = new MultiMap<FieldSchema, String>();
+            try {
+                for (int i = 0; i < s.size(); ++i) {
+                    FieldSchema fs = new FieldSchema(s.getField(i));
+                    if(null != fs) {
+                        mFields.add(fs);
+                        if (fs.alias != null) {
+                            mAliases.put(fs.alias, fs);
+                            if(null != fs) {
+                                mFieldSchemas.put(fs, fs.alias);
+                            }
+                        }
+                    }
+                }
+            } catch (ParseException pe) {
+                mFields = new ArrayList<FieldSchema>();
+                mAliases = new HashMap<String, FieldSchema>();
+                mFieldSchemas = new MultiMap<FieldSchema, String>();
+            }
+        } else {
+            mFields = new ArrayList<FieldSchema>();
+            mAliases = new HashMap<String, FieldSchema>();
+            mFieldSchemas = new MultiMap<FieldSchema, String>();
+        }
+    }
+
     /**
      * Given an alias name, find the associated FieldSchema.
      * @param alias Alias to look up.
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index f8813700a..2af99cdb9 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -1350,6 +1350,22 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
         }
     }
 
+    @Test
+    public void testQuery95() throws FrontendException, ParseException {
+        buildPlan("a = load 'myfile' as (name, age, gpa);");
+        buildPlan("b = group a by name;");
+        LogicalPlan lp = buildPlan("c = foreach b {d = order a by $1; generate flatten(d), MAX(a.age) as max_age;};");
+        LOForEach foreach = (LOForEach) lp.getLeaves().get(0);
+        LOCogroup cogroup = (LOCogroup) lp.getPredecessors(foreach).get(0);
+        Schema.FieldSchema bagFs = new Schema.FieldSchema("a", getSchemaFromString("name: bytearray, age: bytearray, gpa: bytearray"), DataType.BAG);
+        Schema.FieldSchema groupFs = new Schema.FieldSchema("group", DataType.BYTEARRAY);
+        Schema cogroupExpectedSchema = new Schema();
+        cogroupExpectedSchema.add(groupFs);
+        cogroupExpectedSchema.add(bagFs);
+        assertTrue(Schema.equals(cogroup.getSchema(), cogroupExpectedSchema, false, false));
+        assertTrue(Schema.equals(foreach.getSchema(), getSchemaFromString("name: bytearray, age: bytearray, gpa: bytearray, max_age: double"), false, true));
+    }
+
     private Schema getSchemaFromString(String schemaString) throws ParseException {
         return getSchemaFromString(schemaString, DataType.BYTEARRAY);
     }
