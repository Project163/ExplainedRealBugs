diff --git a/build.xml b/build.xml
index f9cbda048..dcb9ecb34 100644
--- a/build.xml
+++ b/build.xml
@@ -241,6 +241,8 @@
         <javacc target="${src.gen.dot.parser.dir}/DOTParser.jj" outputdirectory="${src.gen.dot.parser.dir}" javacchome="${javacc.home}" />
         <jjtree target="${src.dir}/org/apache/pig/data/parser/TextDataParser.jjt" outputdirectory="${src.gen.textdata.parser.dir}/" javacchome="${javacc.home}" />
         <javacc target="${src.gen.textdata.parser.dir}/TextDataParser.jj" outputdirectory="${src.gen.textdata.parser.dir}" javacchome="${javacc.home}" />
+        <javacc target="contrib/zebra/src/java/org/apache/hadoop/zebra/types/SchemaParser.jjt" outputdirectory="contrib/zebra/src/java/org/apache/hadoop/zebra/types/" javacchome="${javacc.home}" />
+        <javacc target="contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.jjt" outputdirectory="contrib/zebra/src/java/org/apache/hadoop/zebra/types/" javacchome="${javacc.home}" />
     </target>
 
     <!-- ================================================================== -->
diff --git a/contrib/zebra/CHANGES.txt b/contrib/zebra/CHANGES.txt
index ef0aeec92..1e916ff99 100644
--- a/contrib/zebra/CHANGES.txt
+++ b/contrib/zebra/CHANGES.txt
@@ -14,4 +14,6 @@ Trunk (unreleased changes)
     PIG-987. Access control for column groups. Users can specifify
     desired group, owner, and, permissions for a column group.
     (Yan Zhou via rangadi)
+    
+    PIG-991. Various minor bugs. (Yan Zhou via rangadi)
 
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/io/ColumnGroup.java b/contrib/zebra/src/java/org/apache/hadoop/zebra/io/ColumnGroup.java
index f0b247c4f..84d236f85 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/io/ColumnGroup.java
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/io/ColumnGroup.java
@@ -339,6 +339,14 @@ class ColumnGroup {
       return cgschema;
     }
 
+    public String getGroup() {
+        return cgschema.getGroup();
+      }
+
+    public short getPerm() {
+        return cgschema.getPerm();
+    }
+
     /**
      * Get a scanner that reads all rows whose row keys fall in a specific
      * range.
@@ -1717,7 +1725,12 @@ class ColumnGroup {
       IOutils.indent(out, indent);
       out.println("Serializer: " + reader.getSerializer());
       IOutils.indent(out, indent);
-      out.println("Compressor: " + reader.getCompressor());
+      out.println("Compressor: " + reader.getCompressor());      
+      IOutils.indent(out, indent);
+      out.println("Group: " + reader.getGroup());      
+      IOutils.indent(out, indent);
+      out.println("Perm: " + reader.getPerm());      
+
       properties.put("Schema", reader.getSchema().toString());
       // Now output the properties table.
       int maxKeyLength = 0;
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/SchemaParser.jjt b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/SchemaParser.jjt
index 96d3846d1..527d53224 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/SchemaParser.jjt
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/SchemaParser.jjt
@@ -22,7 +22,7 @@ options {
 }
 
 PARSER_BEGIN(TableSchemaParser)
-package org.apache.pig.table.types;
+package org.apache.hadoop.zebra.types;
 import java.io.*;
 
 public class TableSchemaParser {
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParser.java b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParser.java
index 991d6a897..eb93be082 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParser.java
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParser.java
@@ -1,21 +1,3 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 /* Generated By:JavaCC: Do not edit this line. TableSchemaParser.java */
 package org.apache.hadoop.zebra.types;
 import java.io.*;
@@ -405,67 +387,6 @@ public class TableSchemaParser implements TableSchemaParserConstants {
     finally { jj_save(6, xla); }
   }
 
-  private boolean jj_3R_18() {
-    if (jj_scan_token(24)) return true;
-    if (jj_3R_17()) return true;
-    return false;
-  }
-
-  private boolean jj_3R_20() {
-    if (jj_3R_9()) return true;
-    return false;
-  }
-
-  private boolean jj_3R_19() {
-    if (jj_3R_10()) return true;
-    return false;
-  }
-
-  private boolean jj_3R_11() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_19()) {
-    jj_scanpos = xsp;
-    if (jj_3R_20()) return true;
-    }
-    return false;
-  }
-
-  private boolean jj_3R_29() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_scan_token(7)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(9)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(10)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(11)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(12)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(13)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(8)) return true;
-    }
-    }
-    }
-    }
-    }
-    }
-    return false;
-  }
-
-  private boolean jj_3R_10() {
-    if (jj_3R_17()) return true;
-    Token xsp;
-    while (true) {
-      xsp = jj_scanpos;
-      if (jj_3R_18()) { jj_scanpos = xsp; break; }
-    }
-    return false;
-  }
-
   private boolean jj_3R_4() {
     if (jj_scan_token(IDENTIFIER)) return true;
     if (jj_scan_token(21)) return true;
@@ -679,6 +600,67 @@ public class TableSchemaParser implements TableSchemaParserConstants {
     return false;
   }
 
+  private boolean jj_3R_18() {
+    if (jj_scan_token(24)) return true;
+    if (jj_3R_17()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_20() {
+    if (jj_3R_9()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_19() {
+    if (jj_3R_10()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_11() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_19()) {
+    jj_scanpos = xsp;
+    if (jj_3R_20()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_29() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(7)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(9)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(10)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(11)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(12)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(13)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(8)) return true;
+    }
+    }
+    }
+    }
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_10() {
+    if (jj_3R_17()) return true;
+    Token xsp;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_18()) { jj_scanpos = xsp; break; }
+    }
+    return false;
+  }
+
   /** Generated Token Manager. */
   public TableSchemaParserTokenManager token_source;
   SimpleCharStream jj_input_stream;
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserConstants.java b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserConstants.java
index a954c8a95..219e98621 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserConstants.java
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserConstants.java
@@ -1,21 +1,3 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 /* Generated By:JavaCC: Do not edit this line. TableSchemaParserConstants.java */
 package org.apache.hadoop.zebra.types;
 
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserTokenManager.java b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserTokenManager.java
index 97459b70f..7a6baca55 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserTokenManager.java
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableSchemaParserTokenManager.java
@@ -1,21 +1,3 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 /* Generated By:JavaCC: Do not edit this line. TableSchemaParserTokenManager.java */
 package org.apache.hadoop.zebra.types;
 import java.io.*;
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.java b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.java
index 1bf3020d5..1c3ea584c 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.java
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.java
@@ -75,7 +75,7 @@ public class TableStorageParser implements TableStorageParserConstants {
                 public TableStorageParser(java.io.Reader in, Partition partition, Schema schema) { this(in); mSchema = schema; this.partition = partition;}
                 private Schema mSchema;
                 private int mDefaultCGIndex = -1;
-                private String mCompressor = "lzo", mSerializer = "pig";
+                private String mCompressor = "gz", mSerializer = "pig";
                 private String mOwner = null, mGroup = null;
                 private short mPerm = -1;
                 private int mCGCount = 0;
@@ -258,9 +258,8 @@ public class TableStorageParser implements TableStorageParserConstants {
       }
     }
 //		String compressor, serializer;
-                System.out.println( "compressor = " + compressor + " serializer = " + serializer + " " + owner + " " + group + " " + perm);
                 if (compressor == null)
-                        compressor = "lzo";
+                        compressor = "gz";
                 if (serializer == null)
                         serializer = "pig";
                 if (fs == null)
@@ -620,6 +619,11 @@ public class TableStorageParser implements TableStorageParserConstants {
     return false;
   }
 
+  private boolean jj_3_1() {
+    if (jj_scan_token(0)) return true;
+    return false;
+  }
+
   private boolean jj_3R_7() {
     if (jj_scan_token(IDENTIFIER)) return true;
     if (jj_scan_token(27)) return true;
@@ -627,11 +631,6 @@ public class TableStorageParser implements TableStorageParserConstants {
     return false;
   }
 
-  private boolean jj_3_1() {
-    if (jj_scan_token(0)) return true;
-    return false;
-  }
-
   private boolean jj_3R_9() {
     if (jj_scan_token(28)) return true;
     if (jj_3R_11()) return true;
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.jjt b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.jjt
index aa1ce6d00..6c22d9f35 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.jjt
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParser.jjt
@@ -98,7 +98,7 @@ public class TableStorageParser {
 		public TableStorageParser(java.io.Reader in, Partition partition, Schema schema) { this(in); mSchema = schema; this.partition = partition;}
 		private Schema mSchema;
 		private int mDefaultCGIndex = -1;
-		private String mCompressor = "lzo", mSerializer = "pig";
+		private String mCompressor = "gz", mSerializer = "pig";
 		private String mOwner = null, mGroup = null;
 		private short mPerm = -1;
 		private int mCGCount = 0;
@@ -115,7 +115,7 @@ SKIP : {
 |  <"/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
 }
 
-TOKEN : { <COMPRESSOR : "lzo" | "gzip"> }
+TOKEN : { <COMPRESSOR : "lzo" | "gz"> }
 TOKEN : { <SERIALIZER : ("pig" | "avro")> }
 
 TOKEN : { <ORDER	 : "order by"> }
@@ -269,9 +269,8 @@ CGSchema FieldSchema() :
 	)
 	{
 //		String compressor, serializer;
-		System.out.println( "compressor = " + compressor + " serializer = " + serializer + " " + owner + " " + group + " " + perm);
 		if (compressor == null)
-			compressor = "lzo";
+			compressor = "gz";
 		if (serializer == null)
 			serializer = "pig";
 		if (fs == null)
diff --git a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParserTokenManager.java b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParserTokenManager.java
index 22e1be085..b72fade61 100644
--- a/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParserTokenManager.java
+++ b/contrib/zebra/src/java/org/apache/hadoop/zebra/types/TableStorageParserTokenManager.java
@@ -16,20 +16,20 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
    switch (pos)
    {
       case 0:
-         if ((active0 & 0x3e00L) != 0L)
+         if ((active0 & 0x8000L) != 0L)
          {
             jjmatchedKind = 21;
-            return 29;
+            return 16;
          }
-         if ((active0 & 0x8000L) != 0L)
+         if ((active0 & 0x3e00L) != 0L)
          {
             jjmatchedKind = 21;
-            return 18;
+            return 27;
          }
          if ((active0 & 0x4000L) != 0L)
          {
             jjmatchedKind = 21;
-            return 15;
+            return 13;
          }
          return -1;
       case 1:
@@ -37,7 +37,7 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 1;
-            return 29;
+            return 27;
          }
          return -1;
       case 2:
@@ -45,27 +45,27 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 2;
-            return 29;
+            return 27;
          }
          return -1;
       case 3:
          if ((active0 & 0xa000L) != 0L)
-            return 29;
+            return 27;
          if ((active0 & 0x5e00L) != 0L)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 3;
-            return 29;
+            return 27;
          }
          return -1;
       case 4:
          if ((active0 & 0x4000L) != 0L)
-            return 29;
+            return 27;
          if ((active0 & 0x1e00L) != 0L)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 4;
-            return 29;
+            return 27;
          }
          return -1;
       case 5:
@@ -82,7 +82,7 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 5;
-            return 29;
+            return 27;
          }
          return -1;
       case 6:
@@ -108,7 +108,7 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 6;
-            return 29;
+            return 27;
          }
          return -1;
       case 7:
@@ -116,7 +116,7 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 7;
-            return 29;
+            return 27;
          }
          if ((active0 & 0x1000L) != 0L)
          {
@@ -160,7 +160,7 @@ private final int jjStopStringLiteralDfa_0(int pos, long active0)
          {
             jjmatchedKind = 21;
             jjmatchedPos = 8;
-            return 29;
+            return 27;
          }
          return -1;
       case 9:
@@ -343,7 +343,7 @@ private int jjMoveStringLiteralDfa3_0(long old0, long active0)
       case 77:
       case 109:
          if ((active0 & 0x8000L) != 0L)
-            return jjStartNfaWithStates_0(3, 15, 29);
+            return jjStartNfaWithStates_0(3, 15, 27);
          break;
       case 80:
       case 112:
@@ -351,7 +351,7 @@ private int jjMoveStringLiteralDfa3_0(long old0, long active0)
       case 82:
       case 114:
          if ((active0 & 0x2000L) != 0L)
-            return jjStartNfaWithStates_0(3, 13, 29);
+            return jjStartNfaWithStates_0(3, 13, 27);
          break;
       case 85:
       case 117:
@@ -378,7 +378,7 @@ private int jjMoveStringLiteralDfa4_0(long old0, long active0)
       case 80:
       case 112:
          if ((active0 & 0x4000L) != 0L)
-            return jjStartNfaWithStates_0(4, 14, 29);
+            return jjStartNfaWithStates_0(4, 14, 27);
          break;
       case 82:
       case 114:
@@ -575,7 +575,7 @@ static final long[] jjbitVec0 = {
 private int jjMoveNfa_0(int startState, int curPos)
 {
    int startsAt = 0;
-   jjnewStateCnt = 29;
+   jjnewStateCnt = 27;
    int i = 1;
    jjstateSet[0] = startState;
    int kind = 0x7fffffff;
@@ -590,35 +590,35 @@ private int jjMoveNfa_0(int startState, int curPos)
          {
             switch(jjstateSet[--i])
             {
+               case 27:
+               case 23:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 21)
+                     kind = 21;
+                  jjCheckNAdd(23);
+                  break;
                case 2:
                   if ((0xff000000000000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 27;
+                     jjstateSet[jjnewStateCnt++] = 25;
                   else if (curChar == 47)
                      jjstateSet[jjnewStateCnt++] = 3;
                   else if (curChar == 45)
                      jjstateSet[jjnewStateCnt++] = 0;
                   break;
-               case 18:
-               case 25:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 21)
-                     kind = 21;
-                  jjCheckNAdd(25);
-                  break;
-               case 15:
+               case 16:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
                   if (kind > 21)
                      kind = 21;
-                  jjCheckNAdd(25);
+                  jjCheckNAdd(23);
                   break;
-               case 29:
+               case 13:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
                   if (kind > 21)
                      kind = 21;
-                  jjCheckNAdd(25);
+                  jjCheckNAdd(23);
                   break;
                case 0:
                   if (curChar != 45)
@@ -662,15 +662,15 @@ private int jjMoveNfa_0(int startState, int curPos)
                   if (curChar == 47)
                      jjstateSet[jjnewStateCnt++] = 3;
                   break;
-               case 26:
+               case 24:
                   if ((0xff000000000000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 27;
+                     jjstateSet[jjnewStateCnt++] = 25;
                   break;
-               case 27:
+               case 25:
                   if ((0xff000000000000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 28;
+                     jjstateSet[jjnewStateCnt++] = 26;
                   break;
-               case 28:
+               case 26:
                   if ((0xff000000000000L & l) != 0L && kind > 22)
                      kind = 22;
                   break;
@@ -685,66 +685,69 @@ private int jjMoveNfa_0(int startState, int curPos)
          {
             switch(jjstateSet[--i])
             {
+               case 27:
+                  if ((0x7fffffe87fffffeL & l) != 0L)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                     jjCheckNAdd(23);
+                  }
+                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  {
+                     if (kind > 21)
+                        kind = 21;
+                     jjCheckNAddTwoStates(22, 23);
+                  }
+                  break;
                case 2:
                   if ((0x7fffffe07fffffeL & l) != 0L)
                   {
                      if (kind > 21)
                         kind = 21;
-                     jjCheckNAddTwoStates(24, 25);
+                     jjCheckNAddTwoStates(22, 23);
                   }
                   if ((0x200000002L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 22;
+                     jjstateSet[jjnewStateCnt++] = 20;
                   else if ((0x1000000010000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 18;
+                     jjstateSet[jjnewStateCnt++] = 16;
                   else if ((0x8000000080L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 15;
+                     jjstateSet[jjnewStateCnt++] = 13;
                   else if ((0x100000001000L & l) != 0L)
                      jjstateSet[jjnewStateCnt++] = 11;
                   break;
-               case 18:
+               case 16:
                   if ((0x7fffffe87fffffeL & l) != 0L)
                   {
                      if (kind > 21)
                         kind = 21;
-                     jjCheckNAdd(25);
+                     jjCheckNAdd(23);
                   }
                   if ((0x7fffffe07fffffeL & l) != 0L)
                   {
                      if (kind > 21)
                         kind = 21;
-                     jjCheckNAddTwoStates(24, 25);
+                     jjCheckNAddTwoStates(22, 23);
                   }
                   if ((0x20000000200L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 17;
+                     jjstateSet[jjnewStateCnt++] = 15;
                   break;
-               case 15:
+               case 13:
                   if ((0x7fffffe87fffffeL & l) != 0L)
                   {
                      if (kind > 21)
                         kind = 21;
-                     jjCheckNAdd(25);
+                     jjCheckNAdd(23);
                   }
                   if ((0x7fffffe07fffffeL & l) != 0L)
                   {
                      if (kind > 21)
                         kind = 21;
-                     jjCheckNAddTwoStates(24, 25);
+                     jjCheckNAddTwoStates(22, 23);
                   }
                   if ((0x400000004000000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 14;
-                  break;
-               case 29:
-                  if ((0x7fffffe87fffffeL & l) != 0L)
                   {
-                     if (kind > 21)
-                        kind = 21;
-                     jjCheckNAdd(25);
-                  }
-                  if ((0x7fffffe07fffffeL & l) != 0L)
-                  {
-                     if (kind > 21)
-                        kind = 21;
-                     jjCheckNAddTwoStates(24, 25);
+                     if (kind > 7)
+                        kind = 7;
                   }
                   break;
                case 1:
@@ -771,55 +774,47 @@ private int jjMoveNfa_0(int startState, int curPos)
                   if ((0x100000001000L & l) != 0L)
                      jjstateSet[jjnewStateCnt++] = 11;
                   break;
-               case 13:
-                  if ((0x1000000010000L & l) != 0L && kind > 7)
-                     kind = 7;
-                  break;
                case 14:
-                  if ((0x20000000200L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 13;
-                  break;
-               case 16:
                   if ((0x8000000080L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 15;
+                     jjstateSet[jjnewStateCnt++] = 13;
                   break;
-               case 17:
+               case 15:
                   if ((0x8000000080L & l) != 0L && kind > 8)
                      kind = 8;
                   break;
-               case 19:
+               case 17:
                   if ((0x1000000010000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 18;
+                     jjstateSet[jjnewStateCnt++] = 16;
                   break;
-               case 20:
+               case 18:
                   if ((0x800000008000L & l) != 0L && kind > 8)
                      kind = 8;
                   break;
-               case 21:
+               case 19:
                   if ((0x4000000040000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 20;
+                     jjstateSet[jjnewStateCnt++] = 18;
                   break;
-               case 22:
+               case 20:
                   if ((0x40000000400000L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 21;
+                     jjstateSet[jjnewStateCnt++] = 19;
                   break;
-               case 23:
+               case 21:
                   if ((0x200000002L & l) != 0L)
-                     jjstateSet[jjnewStateCnt++] = 22;
+                     jjstateSet[jjnewStateCnt++] = 20;
                   break;
-               case 24:
+               case 22:
                   if ((0x7fffffe07fffffeL & l) == 0L)
                      break;
                   if (kind > 21)
                      kind = 21;
-                  jjCheckNAddTwoStates(24, 25);
+                  jjCheckNAddTwoStates(22, 23);
                   break;
-               case 25:
+               case 23:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
                   if (kind > 21)
                      kind = 21;
-                  jjCheckNAdd(25);
+                  jjCheckNAdd(23);
                   break;
                default : break;
             }
@@ -860,7 +855,7 @@ private int jjMoveNfa_0(int startState, int curPos)
          kind = 0x7fffffff;
       }
       ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 29 - (jjnewStateCnt = startsAt)))
+      if ((i = jjnewStateCnt) == (startsAt = 27 - (jjnewStateCnt = startsAt)))
          return curPos;
       try { curChar = input_stream.readChar(); }
       catch(java.io.IOException e) { return curPos; }
@@ -887,8 +882,8 @@ static final long[] jjtoSkip = {
    0x7eL, 
 };
 protected SimpleCharStream input_stream;
-private final int[] jjrounds = new int[29];
-private final int[] jjstateSet = new int[58];
+private final int[] jjrounds = new int[27];
+private final int[] jjstateSet = new int[54];
 protected char curChar;
 /** Constructor. */
 public TableStorageParserTokenManager(SimpleCharStream stream){
@@ -915,7 +910,7 @@ private void ReInitRounds()
 {
    int i;
    jjround = 0x80000001;
-   for (i = 29; i-- > 0;)
+   for (i = 27; i-- > 0;)
       jjrounds[i] = 0x80000000;
 }
 
diff --git a/contrib/zebra/src/test/org/apache/hadoop/zebra/io/TestColumnGroup.java b/contrib/zebra/src/test/org/apache/hadoop/zebra/io/TestColumnGroup.java
index 665a16851..a2fd52503 100644
--- a/contrib/zebra/src/test/org/apache/hadoop/zebra/io/TestColumnGroup.java
+++ b/contrib/zebra/src/test/org/apache/hadoop/zebra/io/TestColumnGroup.java
@@ -61,6 +61,7 @@ public class TestColumnGroup {
     conf.setInt("table.output.tfile.minBlock.size", 64 * 1024);
     conf.setInt("table.input.split.minSize", 64 * 1024);
     conf.set("table.output.tfile.compression", "none");
+    conf.set("io.compression.codec.lzo.class", "no");
     random = new Random(System.nanoTime());
     rootPath = new Path(System.getProperty("test.build.data",
         "build/test/data/workdir3"));
diff --git a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc1.java b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc1.java
index 7bfdccc5b..1d10c232e 100644
--- a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc1.java
+++ b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc1.java
@@ -81,7 +81,7 @@ public class TestStorageMisc1 {
   @Test
   public void testStorageValid1() {
     try {
-        String strStorage = "[r.r.f1,r.f2#{k1}] COMPRESS BY gzip SECURE BY user:gaurav; [r.r.f2, r.f2#{k2}] COMPRESS BY lzo SERIALIZE BY avro";
+        String strStorage = "[r.r.f1,r.f2#{k1}] COMPRESS BY gz SECURE BY user:gaurav; [r.r.f2, r.f2#{k2}] COMPRESS BY lzo SERIALIZE BY avro";
 //      String strStorage = "[r.r.f1,r.f2#{k1}] COMPRESS BY gzip SECURE BY user:gaurav; [r.r.f2, r.f2#{k2}] COMPRESS BY lzo SERIALIZE BY avro";
 //      String strStorage = "[r.r.f1,r.f2#{k1}] COMPRESS BY gzip SECURE BY user:gaurav group:data perm:0766; [r.r.f2, r.f2#{k2}] COMPRESS BY lzo SERIALIZE BY avro";
 //      String strStorage = "[r.r.f1,r.f2#{k1}] COMPRESS BY gzip SECURE BY user:gaurav group:data perm:966; [r.r.f2, r.f2#{k2}] COMPRESS BY lzo SERIALIZE BY avro";
diff --git a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc2.java b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc2.java
index d51b9a849..344205d5d 100644
--- a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc2.java
+++ b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc2.java
@@ -95,7 +95,7 @@ public class TestStorageMisc2 {
   @Test
   public void testStorageValid1() {
     try {
-      String strStorage = "[c] compress by gzip; [m1] serialize by avro";
+      String strStorage = "[c] compress by gz; [m1] serialize by avro";
       Partition p = new Partition(schema.toString(), strStorage);
       CGSchema[] cgschemas = p.getCGSchemas();
 
@@ -118,7 +118,7 @@ public class TestStorageMisc2 {
       Assert.assertEquals("m1", f21.name);
       Assert.assertEquals(ColumnType.MAP, f21.type);
 
-      Assert.assertEquals(cgs1.getCompressor(), "gzip");
+      Assert.assertEquals(cgs1.getCompressor(), "gz");
       Assert.assertEquals(cgs2.getSerializer(), "avro");
 
       System.out.println("*********** Column Map **********");
@@ -159,7 +159,7 @@ public class TestStorageMisc2 {
   @Test
   public void testStorageValid2() {
     try {
-      String strStorage = "[c] compress by gzip; [m1#{k1}] serialize by avro";
+      String strStorage = "[c] compress by gz; [m1#{k1}] serialize by avro";
       Partition p = new Partition(schema.toString(), strStorage);
       CGSchema[] cgschemas = p.getCGSchemas();
 
diff --git a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc3.java b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc3.java
index 7975fb31b..bfe6b4e32 100644
--- a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc3.java
+++ b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorageMisc3.java
@@ -48,7 +48,7 @@ public class TestStorageMisc3 {
   @Test
   public void testStorageValid1() {
     try {
-      String strStorage = "[c] compress by gzip; [m1] serialize by avro";
+      String strStorage = "[c] compress by gz; [m1] serialize by avro";
       Partition p = new Partition(schema.toString(), strStorage);
       CGSchema[] cgschemas = p.getCGSchemas();
 
@@ -71,7 +71,7 @@ public class TestStorageMisc3 {
       Assert.assertEquals("m1", f21.name);
       Assert.assertEquals(ColumnType.MAP, f21.type);
 
-      Assert.assertEquals(cgs1.getCompressor(), "gzip");
+      Assert.assertEquals(cgs1.getCompressor(), "gz");
       Assert.assertEquals(cgs2.getSerializer(), "avro");
 
       System.out.println("*********** Column Map **********");
diff --git a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorePrimitive.java b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorePrimitive.java
index 1d17bcd5f..901a39c95 100644
--- a/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorePrimitive.java
+++ b/contrib/zebra/src/test/org/apache/hadoop/zebra/types/TestStorePrimitive.java
@@ -72,7 +72,7 @@ public class TestStorePrimitive {
   @Test
   public void testStorageValid1() {
     try {
-      String strStorage = "[f1, f2]; [f3, f4] COMPRESS BY gzip SERIALIZE BY avro";
+      String strStorage = "[f1, f2]; [f3, f4] COMPRESS BY gz SERIALIZE BY avro";
       Partition p = new Partition(schema.toString(), strStorage);
       CGSchema[] cgschemas = p.getCGSchemas();
 
@@ -107,11 +107,11 @@ public class TestStorePrimitive {
       Assert.assertEquals("f6", f32.name);
       Assert.assertEquals(ColumnType.BYTES, f32.type);
 
-      Assert.assertEquals(cgs1.getCompressor(), "lzo");
+      Assert.assertEquals(cgs1.getCompressor(), "gz");
       Assert.assertEquals(cgs1.getSerializer(), "pig");
-      Assert.assertEquals(cgs2.getCompressor(), "gzip");
+      Assert.assertEquals(cgs2.getCompressor(), "gz");
       Assert.assertEquals(cgs2.getSerializer(), "avro");
-      Assert.assertEquals(cgs3.getCompressor(), "lzo");
+      Assert.assertEquals(cgs3.getCompressor(), "gz");
       Assert.assertEquals(cgs3.getSerializer(), "pig");
 
       System.out.println("*********** Column Map **********");
