diff --git a/CHANGES.txt b/CHANGES.txt
index c8cb06294..ca395ef00 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -24,6 +24,8 @@ INCOMPATIBLE CHANGES
 
 IMPROVEMENTS
 
+PIG-3082: outputSchema of a UDF allows two usages when describing a Tuple schema (jcoveney)
+
 PIG-3124:  Push FLATTENs After FILTERs If Possible (nwhite via daijy)
 
 PIG-3086: Allow A Prefix To Be Added To URIs In PigUnit Tests (nwhite via gates)
diff --git a/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java b/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
index 57e952fba..b8c58767a 100644
--- a/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
+++ b/src/org/apache/pig/newplan/logical/expression/UserFuncExpression.java
@@ -47,7 +47,7 @@ public class UserFuncExpression extends LogicalExpression {
     private String signature;
     private static int sigSeq=0;
     private boolean viaDefine=false; //this represents whether the function was instantiate via a DEFINE statement or not
-    
+
     public UserFuncExpression(OperatorPlan plan, FuncSpec funcSpec) {
         super("UserFunc", plan);
         mFuncSpec = funcSpec;
@@ -56,11 +56,11 @@ public class UserFuncExpression extends LogicalExpression {
             signature = Integer.toString(sigSeq++);
         }
     }
-    
-    
+
+
     public UserFuncExpression(OperatorPlan plan, FuncSpec funcSpec, List<LogicalExpression> args) {
         this( plan, funcSpec );
-        
+
         for( LogicalExpression arg : args ) {
             plan.connect( this, arg );
         }
@@ -79,7 +79,7 @@ public class UserFuncExpression extends LogicalExpression {
     public FuncSpec getFuncSpec() {
         return mFuncSpec;
     }
-    
+
     @Override
     public void accept(PlanVisitor v) throws FrontendException {
         if (!(v instanceof LogicalExpressionVisitor)) {
@@ -90,21 +90,21 @@ public class UserFuncExpression extends LogicalExpression {
 
     @Override
     public boolean isEqual(Operator other) throws FrontendException {
-        
+
         //For the purpose of optimization rules (specially LogicalExpressionSimplifier)
         // a non deterministic udf is not equal to another. So returning false for
         //such cases.
         // Note that the function is also invoked by implementations of OperatorPlan.isEqual
         // that function is called from test cases to compare logical plans, and
-        // it will return false even if the plans are clones. 
+        // it will return false even if the plans are clones.
         if(!this.isDeterministic())
             return false;
-        
+
         if( other instanceof UserFuncExpression ) {
             UserFuncExpression exp = (UserFuncExpression)other;
             if (!mFuncSpec.equals(exp.mFuncSpec ))
                 return false;
-            
+
             List<Operator> mySuccs = getPlan().getSuccessors(this);
             List<Operator> theirSuccs = other.getPlan().getSuccessors(other);
             if(mySuccs == null || theirSuccs == null){
@@ -126,7 +126,7 @@ public class UserFuncExpression extends LogicalExpression {
             return false;
         }
     }
-    
+
     public boolean isDeterministic() throws FrontendException{
         Class<?> udfClass;
         try {
@@ -139,9 +139,9 @@ public class UserFuncExpression extends LogicalExpression {
             return true;
         }
         return false;
-        
+
     }
-    
+
 
     public List<LogicalExpression> getArguments() throws FrontendException {
         List<Operator> successors = null;
@@ -168,12 +168,12 @@ public class UserFuncExpression extends LogicalExpression {
         mFuncSpec = funcSpec;
         ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(mFuncSpec);
     }
-    
+
     @Override
     public LogicalSchema.LogicalFieldSchema getFieldSchema() throws FrontendException {
         if (fieldSchema!=null)
             return fieldSchema;
-        
+
         LogicalSchema inputSchema = new LogicalSchema();
         List<Operator> succs = plan.getSuccessors(this);
 
@@ -191,7 +191,7 @@ public class UserFuncExpression extends LogicalExpression {
         // This significantly optimize the performance of frontend (PIG-1738)
         if (ef==null)
             ef = (EvalFunc<?>) PigContext.instantiateFuncFromSpec(mFuncSpec);
-        
+
         ef.setUDFContextSignature(signature);
         Properties props = UDFContext.getUDFContext().getUDFProperties(ef.getClass());
         Schema translatedInputSchema = Util.translateSchema(inputSchema);
@@ -200,9 +200,12 @@ public class UserFuncExpression extends LogicalExpression {
         }
         // Store inputSchema into the UDF context
         ef.setInputSchema(translatedInputSchema);
-;
+
         Schema udfSchema = ef.outputSchema(translatedInputSchema);
-        
+        if (udfSchema != null && udfSchema.size() > 1) {
+            throw new FrontendException("Given UDF returns an improper Schema. Schema should only contain one field of a Tuple, Bag, or a single type. Returns: " + udfSchema);
+        }
+
         //TODO appendability should come from a setting
         SchemaTupleFrontend.registerToGenerateIfPossible(translatedInputSchema, false, GenContext.UDF);
         SchemaTupleFrontend.registerToGenerateIfPossible(udfSchema, false, GenContext.UDF);
@@ -224,16 +227,16 @@ public class UserFuncExpression extends LogicalExpression {
         uidOnlyFieldSchema = fieldSchema.mergeUid(uidOnlyFieldSchema);
         return fieldSchema;
     }
-    
+
     @Override
     public LogicalExpression deepCopy(LogicalExpressionPlan lgExpPlan) throws FrontendException {
-        UserFuncExpression copy =  null; 
+        UserFuncExpression copy =  null;
         try {
             copy = new UserFuncExpression(
                     lgExpPlan,
                     this.getFuncSpec().clone(),
                     viaDefine);
-            
+
             copy.signature = signature;
             // Deep copy the input expressions.
             List<Operator> inputs = plan.getSuccessors( this );
@@ -245,14 +248,14 @@ public class UserFuncExpression extends LogicalExpression {
                     lgExpPlan.connect( copy, inputCopy );
                 }
             }
-            
+
         } catch(CloneNotSupportedException e) {
              e.printStackTrace();
         }
         copy.setLocation( new SourceLocation( location ) );
         return copy;
     }
-    
+
     public String toString() {
         StringBuilder msg = new StringBuilder();
         msg.append("(Name: " + name + "(" + getFuncSpec() + ")" + " Type: ");
@@ -269,7 +272,7 @@ public class UserFuncExpression extends LogicalExpression {
 
         return msg.toString();
     }
-    
+
     public String getSignature() {
         return signature;
     }
diff --git a/test/org/apache/pig/test/TestCommit.java b/test/org/apache/pig/test/TestCommit.java
index 7a57fdbf0..f76b36daa 100644
--- a/test/org/apache/pig/test/TestCommit.java
+++ b/test/org/apache/pig/test/TestCommit.java
@@ -22,7 +22,6 @@ import static org.junit.Assert.assertTrue;
 
 import java.io.File;
 import java.util.Iterator;
-import java.util.Properties;
 
 import org.apache.pig.ExecType;
 import org.apache.pig.PigServer;
@@ -40,7 +39,7 @@ public class TestCommit {
 
     @Before
     public void setUp() throws Exception{
-        pigServer = new PigServer(ExecType.LOCAL, new Properties());
+        pigServer = new PigServer(ExecType.LOCAL);
     }
 
     @Test
@@ -77,7 +76,7 @@ public class TestCommit {
                 assertEquals(t.get(1), expected2.get(1));
             }
         }
-        assertEquals(count, 2);
+        assertEquals(2, count);
     }
 
     @Test
@@ -120,7 +119,7 @@ public class TestCommit {
 
         }
         pigServer.deleteFile("testCheckin2-output.txt");
-        assertEquals(count, 2);
+        assertEquals(2, count);
         assertTrue(contain1);
         assertTrue(contain2);
     }
diff --git a/test/org/apache/pig/test/TestSchema.java b/test/org/apache/pig/test/TestSchema.java
index 62306fa22..bfe76c458 100644
--- a/test/org/apache/pig/test/TestSchema.java
+++ b/test/org/apache/pig/test/TestSchema.java
@@ -18,13 +18,17 @@
 
 package org.apache.pig.test;
 
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
-import junit.framework.Assert;
-
 import org.apache.pig.ExecType;
 import org.apache.pig.PigServer;
 import org.apache.pig.ResourceSchema;
@@ -32,8 +36,8 @@ import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
-import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
+import org.apache.pig.impl.logicalLayer.schema.SchemaMergeException;
 import org.apache.pig.impl.util.Utils;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
 import org.apache.pig.newplan.logical.relational.LogicalSchema.MergeMode;
@@ -41,324 +45,314 @@ import org.apache.pig.parser.ParserException;
 import org.junit.Test;
 
 public class TestSchema {
-    
+
     @Test
     public void testSchemaEqual1() {
-        
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.INTEGER)) ;
-        innerList1.add(new FieldSchema("11b", DataType.LONG)) ;
-        
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("11a", DataType.INTEGER)) ;
-        innerList2.add(new FieldSchema("11b", DataType.LONG)) ;
-        
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
-                
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.INTEGER)) ;
-        
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("1b", innerSchema2)) ;
-        list2.add(new FieldSchema("1c", DataType.INTEGER)) ;
-        
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
-        
-        Assert.assertTrue(Schema.equals(schema1, schema2, false, false)) ;
-
-        innerList2.get(1).alias = "pi" ;
-
-        Assert.assertFalse(Schema.equals(schema1, schema2, false, false)) ;
-        Assert.assertTrue(Schema.equals(schema1, schema2, false, true)) ;
-        
-        innerList2.get(1).alias = "11b" ;
-        innerList2.get(1).type = DataType.BYTEARRAY ;
-        
-        Assert.assertFalse(Schema.equals(schema1, schema2, false, false)) ;
-        Assert.assertTrue(Schema.equals(schema1, schema2, true, false)) ;
-        
-        innerList2.get(1).type = DataType.LONG ;
-        
-        Assert.assertTrue(Schema.equals(schema1, schema2, false, false)) ;
-        
-        list2.get(0).type = DataType.CHARARRAY ;
-        Assert.assertFalse(Schema.equals(schema1, schema2, false, false)) ;
+
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList1.add(new FieldSchema("11b", DataType.LONG));
+
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList2.add(new FieldSchema("11b", DataType.LONG));
+
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
+
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.INTEGER));
+
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("1b", innerSchema2));
+        list2.add(new FieldSchema("1c", DataType.INTEGER));
+
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
+
+        assertTrue(Schema.equals(schema1, schema2, false, false));
+
+        innerList2.get(1).alias = "pi";
+
+        assertFalse(Schema.equals(schema1, schema2, false, false));
+        assertTrue(Schema.equals(schema1, schema2, false, true));
+
+        innerList2.get(1).alias = "11b";
+        innerList2.get(1).type = DataType.BYTEARRAY;
+
+        assertFalse(Schema.equals(schema1, schema2, false, false));
+        assertTrue(Schema.equals(schema1, schema2, true, false));
+
+        innerList2.get(1).type = DataType.LONG;
+
+        assertTrue(Schema.equals(schema1, schema2, false, false));
+
+        list2.get(0).type = DataType.CHARARRAY;
+        assertFalse(Schema.equals(schema1, schema2, false, false));
     }
 
     // Positive test
     @Test
     public void testSchemaEqualWithNullSchema1() {
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", null)) ;
-        list1.add(new FieldSchema("1c", DataType.INTEGER)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", null));
+        list1.add(new FieldSchema("1c", DataType.INTEGER));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("1b", null)) ;
-        list2.add(new FieldSchema("1c", DataType.INTEGER)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("1b", null));
+        list2.add(new FieldSchema("1c", DataType.INTEGER));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // First check
-        Assert.assertTrue(Schema.equals(schema1, schema2, false, false)) ;
+        assertTrue(Schema.equals(schema1, schema2, false, false));
 
         // Manipulate
-        List<FieldSchema> dummyList = new ArrayList<FieldSchema>() ;
-        Schema dummySchema = new Schema(dummyList) ;
-        list2.get(1).schema = dummySchema ;
+        List<FieldSchema> dummyList = new ArrayList<FieldSchema>();
+        Schema dummySchema = new Schema(dummyList);
+        list2.get(1).schema = dummySchema;
 
         // And check again
-        Assert.assertFalse(Schema.equals(schema1, schema2, false, false)) ;
+        assertFalse(Schema.equals(schema1, schema2, false, false));
     }
-    
+
     @Test
     public void testNormalNestedMerge1() {
-        
+
         // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.INTEGER)) ; 
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
-        
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
-        
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
-                
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.LONG)) ;
-        
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
-        
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
-        
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
+
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", DataType.DOUBLE));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
+
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
+
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.LONG));
+
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
+
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
+
         // Merge
-        Schema mergedSchema = schema1.merge(schema2, true) ;
-        
-        
+        Schema mergedSchema = schema1.merge(schema2, true);
+
+
         // Generate expected schema
-        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>() ;
-        expectedInnerList.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT)) ;
-        
-        Schema expectedInner = new Schema(expectedInnerList) ;
-        
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", expectedInner)) ;
-        expectedList.add(new FieldSchema("2c", DataType.LONG)) ;
-        
-        Schema expected = new Schema(expectedList) ;
-        
+        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
+        expectedInnerList.add(new FieldSchema("22a", DataType.DOUBLE));
+        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT));
+
+        Schema expectedInner = new Schema(expectedInnerList);
+
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", expectedInner));
+        expectedList.add(new FieldSchema("2c", DataType.LONG));
+
+        Schema expected = new Schema(expectedList);
+
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
 
     @Test
     public void testMergeNullSchemas1() throws Throwable {
 
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", DataType.DOUBLE));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
 
-        Schema innerSchema2 = new Schema(innerList2) ;
+        Schema innerSchema2 = new Schema(innerList2);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", null)) ;
-        list1.add(new FieldSchema("1c", DataType.LONG)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", null));
+        list1.add(new FieldSchema("1c", DataType.LONG));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
         Schema mergedSchema = Schema.mergeSchema(schema1,
                                                  schema2,
                                                  true,
                                                  false,
-                                                 true) ;
+                                                 true);
 
 
         // Generate expected schema
 
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", null)) ;
-        expectedList.add(new FieldSchema("2c", DataType.LONG)) ;
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", null));
+        expectedList.add(new FieldSchema("2c", DataType.LONG));
 
-        Schema expected = new Schema(expectedList) ;
+        Schema expected = new Schema(expectedList);
 
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
 
     @Test
     public void testMergeNullSchemas2() throws Throwable {
         // Inner of inner schema
-        Schema innerInner = new Schema(new ArrayList<FieldSchema>()) ;
+        Schema innerInner = new Schema(new ArrayList<FieldSchema>());
 
         // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", innerInner)) ;
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", innerInner));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
 
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", null)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", null));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
 
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.LONG)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.LONG));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
         Schema mergedSchema = Schema.mergeSchema(schema1,
                                                  schema2,
                                                  true,
                                                  false,
-                                                 true) ;
+                                                 true);
 
 
         // Generate expected schema
-        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>() ;
-        expectedInnerList.add(new FieldSchema("22a", null)) ;
-        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT)) ;
+        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
+        expectedInnerList.add(new FieldSchema("22a", null));
+        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT));
 
-        Schema expectedInner = new Schema(expectedInnerList) ;
+        Schema expectedInner = new Schema(expectedInnerList);
 
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", expectedInner)) ;
-        expectedList.add(new FieldSchema("2c", DataType.LONG)) ;
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", expectedInner));
+        expectedList.add(new FieldSchema("2c", DataType.LONG));
 
-        Schema expected = new Schema(expectedList) ;
+        Schema expected = new Schema(expectedList);
 
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
 
     @Test
     public void testMergeDifferentSize1() throws Throwable {
 
         // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.INTEGER)) ;
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
-        innerList1.add(new FieldSchema("11c", DataType.CHARARRAY)) ;
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
+        innerList1.add(new FieldSchema("11c", DataType.CHARARRAY));
 
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", DataType.DOUBLE));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
 
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.LONG)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.LONG));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
-        list2.add(new FieldSchema("2d", DataType.MAP)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
+        list2.add(new FieldSchema("2d", DataType.MAP));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
         Schema mergedSchema = Schema.mergeSchema(schema1,
                                                  schema2,
                                                  true,
                                                  true,
-                                                 false) ;
+                                                 false);
 
 
         // Generate expected schema
-        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>() ;
-        expectedInnerList.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT)) ;
-        expectedInnerList.add(new FieldSchema("11c", DataType.CHARARRAY)) ;
+        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
+        expectedInnerList.add(new FieldSchema("22a", DataType.DOUBLE));
+        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT));
+        expectedInnerList.add(new FieldSchema("11c", DataType.CHARARRAY));
 
-        Schema expectedInner = new Schema(expectedInnerList) ;
+        Schema expectedInner = new Schema(expectedInnerList);
 
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", expectedInner)) ;
-        expectedList.add(new FieldSchema("2c", DataType.LONG)) ;
-        expectedList.add(new FieldSchema("2d", DataType.MAP)) ;
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", expectedInner));
+        expectedList.add(new FieldSchema("2c", DataType.LONG));
+        expectedList.add(new FieldSchema("2d", DataType.MAP));
 
-        Schema expected = new Schema(expectedList) ;
+        Schema expected = new Schema(expectedList);
 
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
 
     // negative test
-    @Test
+    @Test(expected = SchemaMergeException.class)
     public void testMergeDifferentSize2() throws Throwable {
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1c", DataType.LONG));
 
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
+        list2.add(new FieldSchema("2d", DataType.MAP));
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1c", DataType.LONG)) ;
-
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
-        list2.add(new FieldSchema("2d", DataType.MAP)) ;
-
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
-        try {
-            Schema mergedSchema = Schema.mergeSchema(schema1,
-                                                 schema2,
-                                                 true,
-                                                 false,
-                                                 false) ;
-            Assert.fail("Expect Error Here!") ;
-        }
-        catch (SchemaMergeException sme) {
-            // good
-        }
-
-
+        Schema mergedSchema = Schema.mergeSchema(schema1,
+                                             schema2,
+                                             true,
+                                             false,
+                                             false);
     }
 
 
@@ -366,54 +360,54 @@ public class TestSchema {
     public void testMergeMismatchType1() throws Throwable {
 
         // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.CHARARRAY)) ;
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.CHARARRAY));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
 
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", DataType.DOUBLE));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
 
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.MAP)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.MAP));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
         Schema mergedSchema = Schema.mergeSchema(schema1,
                                                  schema2,
                                                  true,
                                                  false,
-                                                 true) ;
+                                                 true);
 
 
         // Generate expected schema
-        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>() ;
-        expectedInnerList.add(new FieldSchema("22a", DataType.BYTEARRAY)) ;
-        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT)) ;
+        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
+        expectedInnerList.add(new FieldSchema("22a", DataType.BYTEARRAY));
+        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT));
 
-        Schema expectedInner = new Schema(expectedInnerList) ;
+        Schema expectedInner = new Schema(expectedInnerList);
 
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", expectedInner)) ;
-        expectedList.add(new FieldSchema("2c", DataType.BYTEARRAY)) ;
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", expectedInner));
+        expectedList.add(new FieldSchema("2c", DataType.BYTEARRAY));
 
-        Schema expected = new Schema(expectedList) ;
+        Schema expected = new Schema(expectedList);
 
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
 
 
@@ -421,43 +415,43 @@ public class TestSchema {
     public void testMergeMismatchType2() throws Throwable {
 
         // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.CHARARRAY)) ;
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.CHARARRAY));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
 
-        Schema innerSchema1 = new Schema(innerList1) ;
+        Schema innerSchema1 = new Schema(innerList1);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.MAP)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.MAP));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
         Schema mergedSchema = Schema.mergeSchema(schema1,
                                                  schema2,
                                                  true,
                                                  false,
-                                                 true) ;
+                                                 true);
 
 
         // Generate expected schema
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", DataType.TUPLE)) ;
-        expectedList.add(new FieldSchema("2c", DataType.BYTEARRAY)) ;
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", DataType.TUPLE));
+        expectedList.add(new FieldSchema("2c", DataType.BYTEARRAY));
 
-        Schema expected = new Schema(expectedList) ;
+        Schema expected = new Schema(expectedList);
 
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
 
     // Negative test
@@ -465,29 +459,29 @@ public class TestSchema {
     public void testMergeMismatchType3()  {
 
       // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.CHARARRAY)) ;
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.CHARARRAY));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
 
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", DataType.DOUBLE)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", DataType.DOUBLE));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
 
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.MAP)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.MAP));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.MAP)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.MAP));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
 
@@ -496,8 +490,8 @@ public class TestSchema {
                                                      schema2,
                                                      true,
                                                      false,
-                                                     false) ;
-            Assert.fail("Expect error here!") ;
+                                                     false);
+            fail("Expect error here!");
         } catch (SchemaMergeException e) {
             // good
         }
@@ -507,116 +501,116 @@ public class TestSchema {
     public void testMergeDifferentSizeAndTypeMismatch1() throws Throwable {
 
         // Generate two schemas
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.INTEGER)) ;
-        innerList1.add(new FieldSchema("11b", DataType.FLOAT)) ;
-        innerList1.add(new FieldSchema("11c", DataType.CHARARRAY)) ;
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList1.add(new FieldSchema("11b", DataType.FLOAT));
+        innerList1.add(new FieldSchema("11c", DataType.CHARARRAY));
 
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("22a", DataType.CHARARRAY)) ;
-        innerList2.add(new FieldSchema(null, DataType.LONG)) ;
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("22a", DataType.CHARARRAY));
+        innerList2.add(new FieldSchema(null, DataType.LONG));
 
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
 
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.INTEGER)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.LONG)) ;
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.INTEGER));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.LONG));
 
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("2a", DataType.CHARARRAY)) ;
-        list2.add(new FieldSchema("2b", innerSchema2)) ;
-        list2.add(new FieldSchema("2c", DataType.INTEGER)) ;
-        list2.add(new FieldSchema("2d", DataType.MAP)) ;
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("2a", DataType.CHARARRAY));
+        list2.add(new FieldSchema("2b", innerSchema2));
+        list2.add(new FieldSchema("2c", DataType.INTEGER));
+        list2.add(new FieldSchema("2d", DataType.MAP));
 
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
 
         // Merge
         Schema mergedSchema = Schema.mergeSchema(schema1,
                                                  schema2,
                                                  true,
                                                  true,
-                                                 true) ;
+                                                 true);
 
 
         // Generate expected schema
-        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>() ;
-        expectedInnerList.add(new FieldSchema("22a", DataType.BYTEARRAY)) ;
-        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT)) ;
-        expectedInnerList.add(new FieldSchema("11c", DataType.CHARARRAY)) ;
+        List<FieldSchema> expectedInnerList = new ArrayList<FieldSchema>();
+        expectedInnerList.add(new FieldSchema("22a", DataType.BYTEARRAY));
+        expectedInnerList.add(new FieldSchema("11b", DataType.FLOAT));
+        expectedInnerList.add(new FieldSchema("11c", DataType.CHARARRAY));
 
-        Schema expectedInner = new Schema(expectedInnerList) ;
+        Schema expectedInner = new Schema(expectedInnerList);
 
-        List<FieldSchema> expectedList = new ArrayList<FieldSchema>() ;
-        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY)) ;
-        expectedList.add(new FieldSchema("2b", expectedInner)) ;
-        expectedList.add(new FieldSchema("2c", DataType.LONG)) ;
-        expectedList.add(new FieldSchema("2d", DataType.MAP)) ;
+        List<FieldSchema> expectedList = new ArrayList<FieldSchema>();
+        expectedList.add(new FieldSchema("2a", DataType.BYTEARRAY));
+        expectedList.add(new FieldSchema("2b", expectedInner));
+        expectedList.add(new FieldSchema("2c", DataType.LONG));
+        expectedList.add(new FieldSchema("2d", DataType.MAP));
 
-        Schema expected = new Schema(expectedList) ;
+        Schema expected = new Schema(expectedList);
 
         // Compare
-        Assert.assertTrue(Schema.equals(mergedSchema, expected, false, false)) ;
+        assertTrue(Schema.equals(mergedSchema, expected, false, false));
     }
-    
+
     @Test
     public void testSchemaEqualTwoLevelAccess() throws Exception {
-        
-        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>() ;
-        innerList1.add(new FieldSchema("11a", DataType.INTEGER)) ;
-        innerList1.add(new FieldSchema("11b", DataType.LONG)) ;
-        
-        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>() ;
-        innerList2.add(new FieldSchema("11a", DataType.INTEGER)) ;
-        innerList2.add(new FieldSchema("11b", DataType.LONG)) ;
-        
-        Schema innerSchema1 = new Schema(innerList1) ;
-        Schema innerSchema2 = new Schema(innerList2) ;
-                
-        List<FieldSchema> list1 = new ArrayList<FieldSchema>() ;
-        list1.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list1.add(new FieldSchema("1b", innerSchema1)) ;
-        list1.add(new FieldSchema("1c", DataType.INTEGER)) ;
-        
-        List<FieldSchema> list2 = new ArrayList<FieldSchema>() ;
-        list2.add(new FieldSchema("1a", DataType.BYTEARRAY)) ;
-        list2.add(new FieldSchema("1b", innerSchema2)) ;
-        list2.add(new FieldSchema("1c", DataType.INTEGER)) ;
-        
-        Schema schema1 = new Schema(list1) ;
-        Schema schema2 = new Schema(list2) ;        
-      
+
+        List<FieldSchema> innerList1 = new ArrayList<FieldSchema>();
+        innerList1.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList1.add(new FieldSchema("11b", DataType.LONG));
+
+        List<FieldSchema> innerList2 = new ArrayList<FieldSchema>();
+        innerList2.add(new FieldSchema("11a", DataType.INTEGER));
+        innerList2.add(new FieldSchema("11b", DataType.LONG));
+
+        Schema innerSchema1 = new Schema(innerList1);
+        Schema innerSchema2 = new Schema(innerList2);
+
+        List<FieldSchema> list1 = new ArrayList<FieldSchema>();
+        list1.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list1.add(new FieldSchema("1b", innerSchema1));
+        list1.add(new FieldSchema("1c", DataType.INTEGER));
+
+        List<FieldSchema> list2 = new ArrayList<FieldSchema>();
+        list2.add(new FieldSchema("1a", DataType.BYTEARRAY));
+        list2.add(new FieldSchema("1b", innerSchema2));
+        list2.add(new FieldSchema("1c", DataType.INTEGER));
+
+        Schema schema1 = new Schema(list1);
+        Schema schema2 = new Schema(list2);
+
         Schema.FieldSchema bagFs1 = new Schema.FieldSchema("b", schema1, DataType.BAG);
         Schema bagSchema1 = new Schema(bagFs1);
-        
+
         Schema.FieldSchema tupleFs = new Schema.FieldSchema("t", schema2, DataType.TUPLE);
         Schema bagSchema = new Schema(tupleFs);
         bagSchema.setTwoLevelAccessRequired(true);
         Schema.FieldSchema bagFs2 = new Schema.FieldSchema("b", bagSchema, DataType.BAG);
         Schema bagSchema2 = new Schema(bagFs2);
 
-        
-        Assert.assertTrue(Schema.equals(bagSchema1, bagSchema2, false, false)) ;
-
-        innerList2.get(1).alias = "pi" ;
-
-        Assert.assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false)) ;
-        Assert.assertTrue(Schema.equals(bagSchema1, bagSchema2, false, true)) ;
-        
-        innerList2.get(1).alias = "11b" ;
-        innerList2.get(1).type = DataType.BYTEARRAY ;
-        
-        Assert.assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false)) ;
-        Assert.assertTrue(Schema.equals(bagSchema1, bagSchema2, true, false)) ;
-        
-        innerList2.get(1).type = DataType.LONG ;
-        
-        Assert.assertTrue(Schema.equals(bagSchema1, bagSchema2, false, false)) ;
-        
-        list2.get(0).type = DataType.CHARARRAY ;
-        Assert.assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false)) ;
+
+        assertTrue(Schema.equals(bagSchema1, bagSchema2, false, false));
+
+        innerList2.get(1).alias = "pi";
+
+        assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false));
+        assertTrue(Schema.equals(bagSchema1, bagSchema2, false, true));
+
+        innerList2.get(1).alias = "11b";
+        innerList2.get(1).type = DataType.BYTEARRAY;
+
+        assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false));
+        assertTrue(Schema.equals(bagSchema1, bagSchema2, true, false));
+
+        innerList2.get(1).type = DataType.LONG;
+
+        assertTrue(Schema.equals(bagSchema1, bagSchema2, false, false));
+
+        list2.get(0).type = DataType.CHARARRAY;
+        assertFalse(Schema.equals(bagSchema1, bagSchema2, false, false));
     }
 
     public void testCharArray2Numeric(){
@@ -624,10 +618,10 @@ public class TestSchema {
     	Schema.FieldSchema inputFieldSchema=new Schema.FieldSchema("",DataType.CHARARRAY);
     	for (byte type:numbericTypes){
     		Schema.FieldSchema castFieldSchema=new Schema.FieldSchema("",type);
-    		Assert.assertTrue(Schema.FieldSchema.castable(castFieldSchema, inputFieldSchema));
+    		assertTrue(Schema.FieldSchema.castable(castFieldSchema, inputFieldSchema));
     	}
     }
-    
+
     public void testSchemaSerialization() throws IOException {
         MiniCluster cluster = MiniCluster.buildCluster();
         PigServer pigServer = new PigServer(ExecType.MAPREDUCE, cluster.getProperties());
@@ -640,11 +634,11 @@ public class TestSchema {
         Iterator<Tuple> it = pigServer.openIterator("c");
         while(it.hasNext()) {
             Tuple t = it.next();
-            Assert.assertEquals("{a: {(f1: chararray,f2: int)}}", t.get(0));
+            assertEquals("{a: {(f1: chararray,f2: int)}}", t.get(0));
         }
         cluster.shutDown();
     }
-    
+
     @Test
     // See PIG-730
     public void testMergeSchemaWithTwoLevelAccess1() throws Exception {
@@ -654,9 +648,9 @@ public class TestSchema {
         s1.getField(0).schema.setTwoLevelAccessRequired(true);
         s2.getField(0).schema.setTwoLevelAccessRequired(true);
         Schema s3 = Schema.mergeSchema(s1, s2, true);
-        Assert.assertEquals(s3.getField(0).schema.isTwoLevelAccessRequired(), true);
+        assertTrue(s3.getField(0).schema.isTwoLevelAccessRequired());
     }
-    
+
     @Test
     // See PIG-730
     public void testMergeSchemaWithTwoLevelAccess() throws Exception {
@@ -666,9 +660,9 @@ public class TestSchema {
         s1.getField(0).schema.setTwoLevelAccessRequired(true);
         s1.getField(0).schema.setTwoLevelAccessRequired(false);
         Schema s3 = Schema.mergeSchema(s1, s2, true);
-        Assert.assertEquals(s3, s2);
+        assertEquals(s3, s2);
     }
-    
+
     @Test
     // See PIG-730
     public void testMergeSchemaWithTwoLevelAccess3() throws Exception {
@@ -676,94 +670,94 @@ public class TestSchema {
         LogicalSchema ls1 = Utils.parseSchema("a:{t:(a0:int, a1:int)}");
         LogicalSchema ls2 = Utils.parseSchema("b:{t:(b0:int, b1:int)}");
         LogicalSchema ls3 = LogicalSchema.merge(ls1, ls2, MergeMode.LoadForEach);
-        Assert.assertTrue(org.apache.pig.newplan.logical.Util.translateSchema(ls3).toString().equals("{a: {t: (a0: int,a1: int)}}"));
+        assertEquals("{a: {t: (a0: int,a1: int)}}", org.apache.pig.newplan.logical.Util.translateSchema(ls3).toString());
     }
-    
+
     @Test
     public void testNewNormalNestedMerge1() throws Exception {
         LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:bytearray, b1:(b11:int, b12:float), c1:long"));
         LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a2:bytearray, b2:(b21:double, b22:long), c2:int"));
-        
+
         LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
         LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:bytearray, b1:(), c1:long"));
         expected.getField(1).schema = new LogicalSchema();
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
         expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:bytearray, b1:(b11:int, b12:float), c1:long"));
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         mergedSchema = LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
         expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a2:bytearray, b2:(b21:double, b22:long), c2:int"));
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
     }
-    
-    
-    
+
+
+
     @Test
     public void testNewNormalNestedMerge2() throws Exception {
         LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:(a11:chararray, a12:float), b1:(b11:chararray, b12:float), c1:long"));
         LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a2:bytearray, b2:(b21:double, b22:long), c2:chararray"));
-        
+
         LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
         LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:(a11:chararray, a12:float), b1:(), c1:bytearray"));
         expected.getField(1).schema = new LogicalSchema();
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
         expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:(a11:chararray, a12:float), b1:(b11:chararray, b12:float), c1:long"));
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         mergedSchema = LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
         expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
                 "a2:(a11:chararray, a12:float), b2:(b21:double, b22:long), c2:chararray"));
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
     }
 
     @Test
     public void testNewMergeNullSchemas() throws Throwable {
         LogicalSchema a = Utils.parseSchema( "a1:bytearray, b1:(b11:int, b12:float), c1:long" );
         LogicalSchema b = Utils.parseSchema( "a2:bytearray, b2:(), c2:int" );
-        
+
         LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
         LogicalSchema expected = Utils.parseSchema( "a1:bytearray, b1:(), c1:long" );
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
         expected = Utils.parseSchema( "a1:bytearray, b1:(b11:int, b12:float), c1:long" );
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         mergedSchema = LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
         expected = Utils.parseSchema( "a2:bytearray, b2:(b11:int,b12:float), c2:int" );
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
     }
 
-    @Test
+    @Test(expected = FrontendException.class)
     public void testNewMergeDifferentSize1() throws Throwable {
         LogicalSchema a = Utils.parseSchema( "a1:bytearray, b1:long, c1:long" );
         LogicalSchema b = Utils.parseSchema( "a2:bytearray, b2:long" );
-        
+
         LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
-        Assert.assertTrue(mergedSchema==null);
-        
+        assertNull(mergedSchema);
+
         try {
             LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
-            Assert.fail();
         } catch (FrontendException e) {
-            Assert.assertTrue(e.getErrorCode()==1031);
+            assertEquals(1031, e.getErrorCode());
+            throw e;
         }
     }
 
-    @Test
+    @Test(expected = FrontendException.class)
     public void testNewMergeDifferentSize2() throws Throwable {
         LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:bytearray, b1:(b11:int, b12:float, b13:float), c1:long"));
@@ -774,18 +768,18 @@ public class TestSchema {
         LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:bytearray, b1:(), c1:long"));
         expected.getField(1).schema = new LogicalSchema();
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
 
         try {
             LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
-            Assert.fail();
         } catch (FrontendException e) {
-            Assert.assertTrue(e.getErrorCode()==1031);
+            assertEquals(1031, e.getErrorCode());
+            throw e;
         }
     }
 
 
-    @Test
+    @Test(expected = FrontendException.class)
     public void testNewMergeMismatchType1() throws Throwable {
         LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:chararray, b1:long, c1:long"));
@@ -795,49 +789,49 @@ public class TestSchema {
         LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
         LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:chararray, b1:bytearray, c1:long"));
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         try {
             LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
-            Assert.fail();
+            fail();
         } catch (FrontendException e) {
-            Assert.assertTrue(e.getErrorCode()==1031);
+            assertEquals(1031, e.getErrorCode());
         }
-        
+
         try {
             LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
-            Assert.fail();
         } catch (FrontendException e) {
-            Assert.assertTrue(e.getErrorCode()==1031);
+            assertEquals(1031, e.getErrorCode());
+            throw e;
         }
     }
 
 
-    @Test
+    @Test(expected = FrontendException.class)
     public void testNewMergeMismatchType2() throws Throwable {
         LogicalSchema a = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:chararray, b1:(b11:double, b12:(b121:int)), c1:long"));
         LogicalSchema b = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a2:bytearray, b2:(b21:double, b22:long), c2:int"));
-    
+
         LogicalSchema mergedSchema = LogicalSchema.merge(a, b, LogicalSchema.MergeMode.Union);
         LogicalSchema expected = org.apache.pig.newplan.logical.Util.translateSchema(Utils.getSchemaFromString(
             "a1:chararray, b1:(), c1:long"));
         expected.getField(1).schema = new LogicalSchema();
-        Assert.assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
-        
+        assertTrue(LogicalSchema.equals(mergedSchema, expected, false, false));
+
         try {
             LogicalSchema.merge(a, b, LogicalSchema.MergeMode.LoadForEach);
-            Assert.fail();
+            fail();
         } catch (FrontendException e) {
-            Assert.assertTrue(e.getErrorCode()==1031);
+            assertEquals(1031, e.getErrorCode());
         }
-        
+
         try {
             LogicalSchema.merge(b, a, LogicalSchema.MergeMode.LoadForEach);
-            Assert.fail();
         } catch (FrontendException e) {
-            Assert.assertTrue(e.getErrorCode()==1031);
+            assertEquals(1031, e.getErrorCode());
+            throw e;
         }
     }
 
@@ -845,8 +839,8 @@ public class TestSchema {
     public void testResourceSchemaToSchema() throws ParserException,FrontendException{
         Schema s1 = Utils.getSchemaFromString("b:bag{t:tuple(name:chararray,age:int)}");
         Schema s2 = Schema.getPigSchema(new ResourceSchema(s1));
-        Assert.assertTrue(s1.equals(s2));
-}
+        assertEquals(s1, s2);
+    }
 
     @Test
     public void testGetStringFromSchema() throws ParserException {
@@ -880,7 +874,7 @@ public class TestSchema {
             Schema s1 = Utils.getSchemaFromString(schemaString);
             String s=s1.toString();
             Schema s2 = Utils.getSchemaFromBagSchemaString(s); // removes outer curly-braces added by Schema#toString
-            Assert.assertTrue(Schema.equals(s1,s2,false,true));
+            assertTrue(Schema.equals(s1,s2,false,true));
         }
     }
-}
+}
\ No newline at end of file
diff --git a/test/org/apache/pig/test/TestUDF.java b/test/org/apache/pig/test/TestUDF.java
index 977cc9f87..89b9e7610 100644
--- a/test/org/apache/pig/test/TestUDF.java
+++ b/test/org/apache/pig/test/TestUDF.java
@@ -39,6 +39,8 @@ import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.impl.util.Utils;
+import org.apache.pig.parser.ParserException;
 import org.apache.pig.test.utils.MyUDFReturnMap;
 import org.junit.After;
 import org.junit.AfterClass;
@@ -195,6 +197,53 @@ public class TestUDF {
         }
     }
 
+    @Test
+    public void testEnsureProperSchema1() throws Exception {
+        PigServer pig = new PigServer(ExecType.LOCAL);
+        pig.registerQuery("DEFINE goodSchema1 org.apache.pig.test.TestUDF$MirrorSchema('a:int');");
+        pig.registerQuery("DEFINE goodSchema2 org.apache.pig.test.TestUDF$MirrorSchema('t:(a:int, b:int, c:int)');");
+        pig.registerQuery("DEFINE goodSchema3 org.apache.pig.test.TestUDF$MirrorSchema('b:{(a:int, b:int, c:int)}');");
+        pig.registerQuery("a = load 'thing';");
+        pig.registerQuery("b = foreach a generate goodSchema1();");
+        pig.registerQuery("c = foreach a generate goodSchema2();");
+        pig.registerQuery("d = foreach a generate goodSchema3();");
+        pig.dumpSchema("b");
+        pig.dumpSchema("c");
+        pig.dumpSchema("d");
+    }
+
+    @Test(expected = FrontendException.class)
+    public void testEnsureProperSchema2() throws Exception {
+        PigServer pig = new PigServer(ExecType.LOCAL);
+        pig.registerQuery("DEFINE badSchema org.apache.pig.test.TestUDF$MirrorSchema('a:int, b:int, c:int');");
+        pig.registerQuery("a = load 'thing';");
+        pig.registerQuery("b = foreach a generate badSchema();");
+        pig.dumpSchema("b");
+    }
+
+    public static class MirrorSchema extends EvalFunc<Object> {
+        private String schemaString;
+        private Schema schema;
+
+        public MirrorSchema(String schemaString) {
+            this.schemaString = schemaString;
+            try {
+                schema = Utils.getSchemaFromString(schemaString);
+            } catch (ParserException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        public Object exec(Tuple input) throws IOException {
+            return schemaString;
+        }
+
+        public Schema outputSchema(Schema input) {
+            return schema;
+        }
+    }
+
     @After
     public void tearDown() throws Exception {
         TempScriptFile.delete();
@@ -223,4 +272,4 @@ public class TestUDF {
             return l;
         }
     }
-}
+}
\ No newline at end of file
diff --git a/test/org/apache/pig/test/utils/Identity.java b/test/org/apache/pig/test/utils/Identity.java
index 4f3a29661..149fd6641 100644
--- a/test/org/apache/pig/test/utils/Identity.java
+++ b/test/org/apache/pig/test/utils/Identity.java
@@ -18,7 +18,9 @@
 package org.apache.pig.test.utils;
 
 import org.apache.pig.EvalFunc;
+import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 
 
@@ -34,7 +36,10 @@ public class Identity extends EvalFunc<Tuple> {
 
     @Override
     public Schema outputSchema(Schema input) {
-        return input; 
+        try {
+            return new Schema(new Schema.FieldSchema(null, input, DataType.TUPLE));
+        } catch (FrontendException e) {
+            throw new RuntimeException(e);
+        }
     }
-
 }
