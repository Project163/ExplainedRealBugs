diff --git a/CHANGES.txt b/CHANGES.txt
index d02b27fea..0671be6f3 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -26,7 +26,9 @@ PIG-1249: Safe-guards against misconfigured Pig scripts without PARALLEL keyword
 
 IMPROVEMENTS
 
-PIG-928: UDFs in scripting languages (daijy)
+PIG-1517: Pig needs to support keywords in the package name (aniket486 via olgan)
+
+PIG-928: UDFs in scripting languages (aniket486 via daijy)
 
 PIG-1509: Add .gitignore file (cwsteinbach via gates)
 
diff --git a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
index 5a1065b36..63f495279 100644
--- a/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
+++ b/src/org/apache/pig/impl/logicalLayer/parser/QueryParser.jjt
@@ -967,6 +967,10 @@ SKIP : {
    <"--"(~["\r","\n"])*>
 |  <"/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
 }
+// Every readable token added to following list before identifier needs to be added in
+// IdentifierOrReserved function so that package names will allow these keywords
+// Also, add it to TestLogicalPlanBuilder.testReservedWordsInFunctionNames
+
 // Comparison operators that can be used in a filter:
 TOKEN : { <#STRFILTEROP : "eq" | "gt" | "lt" | "gte" | "lte" | "neq" > }
 TOKEN : { <#NUMFILTEROP : "==" | "<" | "<=" | ">" | ">=" | "!=" > }
@@ -997,7 +1001,7 @@ TOKEN : { <INNER : "inner"> }
 TOKEN : { <OUTER : "outer"> }
 TOKEN : { <STAR : "*"> 		}
 TOKEN : { <PARALLEL : "parallel"> }
-TOKEN : { <PARTITION : "partition by"> }
+TOKEN : { <PARTITION : "partition"> }
 TOKEN : { <GROUP : "group"> }
 TOKEN : { <AND : "and"> }
 TOKEN : { <OR : "or"> }
@@ -1219,7 +1223,8 @@ Token IdentifierOrReserved() :
 }
 {
   (
- ( t1 = <DEFINE> )
+  (t1 = <FILTEROP> )
+| (t1 = <DEFINE> )
 | (t1 = <LOAD> )
 | (t1 =<FILTER> )
 | (t1 =<FOREACH> )
@@ -1275,6 +1280,9 @@ Token IdentifierOrReserved() :
 | (t1 =<STDOUT> )
 | (t1 =<LIMIT> )
 | (t1 =<SAMPLE> )
+| (t1 =<LEFT>)
+| (t1 =<RIGHT>)
+| (t1 =<FULL>)
 | (t1 =<IDENTIFIER>)
 )
     {
@@ -1346,7 +1354,7 @@ LogicalOperator BaseExpr(LogicalPlan lp) :
 |   (<SAMPLE> op = SampleClause(lp))
 |   (<ORDER> op = OrderClause(lp))
 |	(<DISTINCT> op = NestedExpr(lp) 
-	([<PARTITION> (partitioner = EvalClass(ClassType.PARTITIONER))])
+	([<PARTITION> <BY> (partitioner = EvalClass(ClassType.PARTITIONER))])
 	{
 		LogicalOperator distinct = new LODistinct(lp, new OperatorKey(scope, getNextId())); 
 		lp.add(distinct);
@@ -1849,7 +1857,7 @@ LogicalOperator CogroupClause(LogicalPlan lp) :
             cogroup = parseUsingForGroupBy("merge", gis, lp);
             }
         )])
-        ([<PARTITION> (partitioner = EvalClass(ClassType.PARTITIONER))])
+        ([<PARTITION> <BY> (partitioner = EvalClass(ClassType.PARTITIONER))])
     )
     {
         if (cogroup != null) {
@@ -2139,7 +2147,7 @@ LogicalOperator CrossClause(LogicalPlan lp) :
 	op = NestedExpr(lp) { inputs.add(op); }
 	("," op = NestedExpr(lp) { inputs.add(op); })+
 	)
-	([<PARTITION> (partitioner = EvalClass(ClassType.PARTITIONER))])
+	([<PARTITION> <BY> (partitioner = EvalClass(ClassType.PARTITIONER))])
 	{
 		LogicalOperator cross = new LOCross(lp, new OperatorKey(scope, getNextId()));
 		lp.add(cross);
@@ -2236,7 +2244,7 @@ LogicalOperator JoinClause(LogicalPlan lp) :
             joinOp = parseUsingForJoin("hash", gis, lp, isFullOuter, isRightOuter, isOuter);
 		    	}
      )]))
-     ([<PARTITION> (partitioner = EvalClass(ClassType.PARTITIONER))])
+     ([<PARTITION> <BY> (partitioner = EvalClass(ClassType.PARTITIONER))])
 	
 	{
 		log.trace("Exiting JoinClause");
diff --git a/test/org/apache/pig/test/TestLogicalPlanBuilder.java b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
index 29d3aee6e..bb359c687 100644
--- a/test/org/apache/pig/test/TestLogicalPlanBuilder.java
+++ b/test/org/apache/pig/test/TestLogicalPlanBuilder.java
@@ -1897,9 +1897,79 @@ public class TestLogicalPlanBuilder extends junit.framework.TestCase {
     public void testReservedWordsInFunctionNames() {
         // test that define can contain reserved words are later parts of
         // fully qualified function name
-        String query = "define FUNC org.apache.iterators.foreach();";
-        LogicalOperator lo = buildPlan(query).getRoots().get(0);
-        assertTrue(lo instanceof LODefine);
+       	String[] keywords = {
+			"define",
+			"load",
+			"filter",
+			"foreach",
+			"matches",
+			"order",
+			"arrange",
+			"distinct",
+			"cogroup",
+			"join",
+			"cross",
+			"union",
+			"split",
+			"into",
+			"if",
+			"all",
+			"any",
+			"as",
+			"by",
+			"using",
+			"inner",
+			"outer",
+			"parallel",
+			"partition",
+			"group",
+			"and",
+			"or",
+			"not",
+			"generate",
+			"flatten",
+			"eval",
+			"asc",
+			"desc",
+			"int",
+			"long",
+			"float",
+			"double",
+			"chararray",
+			"bytearray",
+			"bag",
+			"tuple",
+			"map",
+			"is",
+			"null",
+			"stream",
+			"through",
+			"store",
+			"ship",
+			"cache",
+			"input",
+			"output",
+			"stderr",
+			"stdin",
+			"stdout",
+			"limit",
+			"sample",
+			"left",
+			"right",
+			"full",
+			"eq",
+			"gt",
+			"lt",
+			"gte",
+			"lte",
+			"neq"
+		};
+
+		for(String keyword: keywords) {
+			String query = "define FUNC org.apache."+keyword+"();";
+        	LogicalOperator lo = buildPlan(query).getRoots().get(0);
+        	assertTrue(lo instanceof LODefine);
+		}
     }
 
 
