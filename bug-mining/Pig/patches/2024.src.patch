diff --git a/CHANGES.txt b/CHANGES.txt
index 37fb893b2..b728067ca 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -40,6 +40,8 @@ PIG-5446: Tez TestPigProgressReporting.testProgressReportingWithStatusMessage fa
 
 PIG-5450: Pig-on-Spark3 E2E ORC test failing with java.lang.VerifyError: Bad return type (knoguchi)
 
+PIG-5452: Null handling of FLATTEN with user defined schema (as clause) (knoguchi)
+
 Release 0.18.0 - Unreleased
  
 INCOMPATIBLE CHANGES
diff --git a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
index 13f5b387b..d5edeb8e0 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOGenerate.java
@@ -75,9 +75,7 @@ public class LOGenerate extends LogicalRelationalOperator {
         outputPlanSchemas = new ArrayList<LogicalSchema>();
         expSchemas = new ArrayList<LogicalSchema>();
         
-        flattenNumFields = new int[outputPlans.size()];
         for(int i=0; i<outputPlans.size(); i++) {
-            flattenNumFields[i] = 0;
             LogicalExpression exp = (LogicalExpression)outputPlans.get(i).getSources().get(0);
             
             LogicalSchema mUserDefinedSchemaCopy = null;
@@ -116,7 +114,6 @@ public class LOGenerate extends LogicalRelationalOperator {
                                 if (fieldSchema.schema!=null) {
                                     if (fieldSchema.schema.getField(0).schema!=null) {
                                         innerFieldSchemas = fieldSchema.schema.getField(0).schema.getFields();
-                                        flattenNumFields[i] = innerFieldSchemas.size();
                                     }
                                     for (LogicalSchema.LogicalFieldSchema fs : innerFieldSchemas) {
                                         fs.alias = fs.alias == null ? null : fieldSchema.alias + "::" + fs.alias;
@@ -125,7 +122,6 @@ public class LOGenerate extends LogicalRelationalOperator {
                             } else if (fieldSchema.type == DataType.MAP) {
                                 //should only contain 1 schemafield for Map's value
                                 innerFieldSchemas = fieldSchema.schema.getFields();
-                                flattenNumFields[i] = 2;  // used for FLATTEN(null-map)
                                 LogicalSchema.LogicalFieldSchema fsForValue = innerFieldSchemas.get(0);
                                 fsForValue.alias = fieldSchema.alias + "::value";
 
@@ -135,7 +131,6 @@ public class LOGenerate extends LogicalRelationalOperator {
                                 expSchema.addField(fsForKey);
                             } else { // DataType.TUPLE
                                 innerFieldSchemas = fieldSchema.schema.getFields();
-                                flattenNumFields[i] = innerFieldSchemas.size();
                                 for (LogicalSchema.LogicalFieldSchema fs : innerFieldSchemas) {
                                     fs.alias = fs.alias == null ? null : fieldSchema.alias + "::" + fs.alias;
                                 }
@@ -205,10 +200,19 @@ public class LOGenerate extends LogicalRelationalOperator {
             }
             outputPlanSchemas.add(planSchema);
         }
+
+        flattenNumFields = new int[outputPlans.size()];
         if (schema==null || schema.size()==0) {
             schema = null;
             outputPlanSchemas = null;
+        } else {
+            for(int i=0; i<outputPlans.size(); i++) {
+                if (flattenFlags[i]) {
+                    flattenNumFields[i] = outputPlanSchemas.get(i).size();
+                }
+            }
         }
+
         
         return schema;
     }
diff --git a/test/org/apache/pig/test/TestFlatten.java b/test/org/apache/pig/test/TestFlatten.java
index c253afca2..a1aeca13f 100644
--- a/test/org/apache/pig/test/TestFlatten.java
+++ b/test/org/apache/pig/test/TestFlatten.java
@@ -142,7 +142,7 @@ public class TestFlatten {
         );
 
         pig.setBatchOn();
-        pig.registerQuery("A = load 'input' using mock.Storage() as (bag1:bag {(a1_1:int, a1_2:chararray)}, bag2:bag{(a2_1:chararray, a2_2:chararray)});");
+        pig.registerQuery("A = load 'input' using mock.Storage() as (bag1:bag {(a1_1:chararray, a1_2:chararray)}, bag2:bag{(a2_1:chararray, a2_2:chararray)});");
         pig.registerQuery("B = foreach A GENERATE FLATTEN(bag1), FLATTEN(bag2);");
         pig.registerQuery("store B into 'output' using mock.Storage();");
         List<ExecJob> execJobs = pig.executeBatch();
@@ -161,7 +161,18 @@ public class TestFlatten {
                 //flatten(null-tuple-from-bag) on schema {(a1_1:int, a1_2:chararray)} also expands to (null, null)
                 "(null, null, '5', '6')", "(null, null, '7', '8')", "('e', 'f', '5', '6')", "('e', 'f', '7', '8')",
                 "('g', 'h', '9', '10')", "('g', 'h', null, null)", "('i', 'j', '9', '10')", "('i', 'j', null, null)" });
+        Util.checkQueryOutputs(actualResults.iterator(), expectedResults);
 
+        //instead of passing the bag with a correct inner schema to flatten, passing one
+        //with empty inner schema but later specifying the inner schema by 'as' clause.
+        pig.registerQuery("A = load 'input' using mock.Storage() as (bag1:bag {}, bag2:bag{});");
+        pig.registerQuery("B = foreach A GENERATE FLATTEN(bag1) as (a1_1:chararray, a1_2:chararray), FLATTEN(bag2) as (a2_1:chararray, a2_2:chararray);");
+        pig.registerQuery("store B into 'output2' using mock.Storage();");
+        execJobs = pig.executeBatch();
+        for( ExecJob execJob : execJobs ) {
+            assertTrue(execJob.getStatus() == ExecJob.JOB_STATUS.COMPLETED );
+        }
+        actualResults = data.get("output2");
         Util.checkQueryOutputs(actualResults.iterator(), expectedResults);
     }
 
@@ -238,6 +249,18 @@ public class TestFlatten {
         List<Tuple> expectedResults = Util.getTuplesFromConstantTupleStrings(
                 new String[] {
                 "('a', 'b', '1', '2')", "(null, null, '3', '4')", "('c', 'd', null, null)", "('e', null, null, '5')" });
+        Util.checkQueryOutputs(actualResults.iterator(), expectedResults);
+
+        //instead of passing the tuple with correct inner schema to flatten, passing one
+        //with empty inner schema but later specifying the inner schema by 'as' clause.
+        pig.registerQuery("A = load 'input' using mock.Storage() as (tuple1:tuple(), tuple2:tuple());");
+        pig.registerQuery("B = foreach A GENERATE FLATTEN(tuple1) as (a1:chararray, a2:chararray), FLATTEN(tuple2) as (a3:chararray, a4:chararray);");
+        pig.registerQuery("store B into 'output2' using mock.Storage();");
+        execJobs = pig.executeBatch();
+        for( ExecJob execJob : execJobs ) {
+            assertTrue(execJob.getStatus() == ExecJob.JOB_STATUS.COMPLETED );
+        }
+        actualResults = data.get("output2");
 
         Util.checkQueryOutputs(actualResults.iterator(), expectedResults);
     }
