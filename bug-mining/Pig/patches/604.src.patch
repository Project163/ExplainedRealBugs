diff --git a/src/org/apache/pig/PigServer.java b/src/org/apache/pig/PigServer.java
index 231a90264..2017217c4 100644
--- a/src/org/apache/pig/PigServer.java
+++ b/src/org/apache/pig/PigServer.java
@@ -102,6 +102,7 @@ import org.apache.pig.impl.util.PropertiesUtil;
 import org.apache.pig.impl.util.Utils;
 import org.apache.pig.newplan.logical.LogicalPlanMigrationVistor;
 import org.apache.pig.newplan.logical.optimizer.LogicalPlanOptimizer;
+import org.apache.pig.newplan.Operator;
 import org.apache.pig.pen.ExampleGenerator;
 import org.apache.pig.scripting.ScriptEngine;
 import org.apache.pig.tools.grunt.GruntParser;
@@ -1125,7 +1126,7 @@ public class PigServer {
         return currDAG.getAliasOp().keySet();
     }
 
-    public Map<LogicalOperator, DataBag> getExamples(String alias) throws IOException {
+    public Map<Operator, DataBag> getExamples(String alias) throws IOException {
         LogicalPlan plan = null;
         try {        
             if (currDAG.isBatchOn() && alias != null) {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
index 2c4a014e7..7b062a5cd 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/HExecutionEngine.java
@@ -107,10 +107,10 @@ public class HExecutionEngine {
     // map from LOGICAL key to into about the execution
     protected Map<OperatorKey, MapRedResult> materializedResults;
     
-    protected Map<LogicalOperator, PhysicalOperator> logToPhyMap;
     protected Map<LogicalOperator, LogicalRelationalOperator> opsMap;
     protected Map<Operator, PhysicalOperator> newLogToPhyMap;
     private Map<LOForEach, Map<LogicalOperator, LogicalRelationalOperator>> forEachInnerOpMap;
+    private org.apache.pig.newplan.logical.relational.LogicalPlan newPreoptimizedPlan;
     
     public HExecutionEngine(PigContext pigContext) {
         this.pigContext = pigContext;
@@ -265,6 +265,8 @@ public class HExecutionEngine {
                 opsMap = visitor.getOldToNewLOOpMap();
                 forEachInnerOpMap = visitor.getForEachInnerMap();
                 org.apache.pig.newplan.logical.relational.LogicalPlan newPlan = visitor.getNewLogicalPlan();
+                newPreoptimizedPlan =
+                    new org.apache.pig.newplan.logical.relational.LogicalPlan(newPlan);
                 
                 if (pigContext.inIllustrator) {
                     // disable all PO-specific optimizations
@@ -342,33 +344,28 @@ public class HExecutionEngine {
         }
     }
     
-    public Map<LogicalOperator, PhysicalOperator> getLogToPhyMap() {
-        if (logToPhyMap != null)
-            return logToPhyMap;
-        else if (newLogToPhyMap != null) {
-            Map<LogicalOperator, PhysicalOperator> result = new HashMap<LogicalOperator, PhysicalOperator>();
-            for (LogicalOperator lo: opsMap.keySet()) {
-                result.put(lo, newLogToPhyMap.get(opsMap.get(lo))); 
-            }
-            return result;
-        } else
-            return null;
+    public Map<Operator, PhysicalOperator> getLogToPhyMap() {
+        return newLogToPhyMap;
     }
     
-    public Map<LOForEach, Map<LogicalOperator, PhysicalOperator>> getForEachInnerLogToPhyMap() {
-        Map<LOForEach, Map<LogicalOperator, PhysicalOperator>> result =
-            new HashMap<LOForEach, Map<LogicalOperator, PhysicalOperator>>();
+    public Map<org.apache.pig.newplan.logical.relational.LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>> getForEachInnerLogToPhyMap() {
+        Map<org.apache.pig.newplan.logical.relational.LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>> result =
+            new HashMap<org.apache.pig.newplan.logical.relational.LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>>();
         for (Map.Entry<LOForEach, Map<LogicalOperator, LogicalRelationalOperator>> entry :
             forEachInnerOpMap.entrySet()) {
-            Map<LogicalOperator, PhysicalOperator> innerOpMap = new HashMap<LogicalOperator, PhysicalOperator>();
+            Map<LogicalRelationalOperator, PhysicalOperator> innerOpMap = new HashMap<LogicalRelationalOperator, PhysicalOperator>();
             for (Map.Entry<LogicalOperator, LogicalRelationalOperator> innerEntry : entry.getValue().entrySet()) {
-                innerOpMap.put(innerEntry.getKey(), newLogToPhyMap.get(innerEntry.getValue()));
+                innerOpMap.put(innerEntry.getValue(), newLogToPhyMap.get(innerEntry.getValue()));
             }
-            result.put(entry.getKey(), innerOpMap);
+            result.put((org.apache.pig.newplan.logical.relational.LOForEach) (opsMap.get(entry.getKey())), innerOpMap);
         }
         return result;
     }
     
+    public org.apache.pig.newplan.logical.relational.LogicalPlan getNewPlan() {
+        return newPreoptimizedPlan;
+    }
+    
     public static class SortInfoSetter extends LogicalRelationalNodesVisitor {
 
         public SortInfoSetter(OperatorPlan plan) throws FrontendException {
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
index 626be25f8..905a47070 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceLauncher.java
@@ -524,7 +524,7 @@ public class MapReduceLauncher extends Launcher{
         if (isMultiQuery) {
             // reduces the number of MROpers in the MR plan generated 
             // by multi-query (multi-store) script.
-            MultiQueryOptimizer mqOptimizer = new MultiQueryOptimizer(plan);
+            MultiQueryOptimizer mqOptimizer = new MultiQueryOptimizer(plan, pc.inIllustrator);
             mqOptimizer.visit();
         }
         
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
index 6fb1b0858..f312b71fd 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MapReduceOper.java
@@ -20,8 +20,6 @@ package org.apache.pig.backend.hadoop.executionengine.mapReduceLayer;
 import java.io.ByteArrayOutputStream;
 import java.util.HashSet;
 import java.util.Set;
-import java.util.Map;
-import java.util.HashMap;
 
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.NodeIdGenerator;
@@ -32,6 +30,7 @@ import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOpe
 import org.apache.pig.impl.plan.Operator;
 import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
 
 /**
  * An operator model for a Map Reduce job. 
@@ -150,7 +149,7 @@ public class MapReduceOper extends Operator<MROpPlanVisitor> {
 	
 	// Map of the physical operator in physical plan to the one in MR plan: only needed
 	// if the physical operator is changed/replaced in MR compilation due to, e.g., optimization
-	public Map<PhysicalOperator, PhysicalOperator> phyToMRMap;
+	public MultiMap<PhysicalOperator, PhysicalOperator> phyToMRMap;
 	
 	private static enum OPER_FEATURE {
 	    NONE,
@@ -175,7 +174,7 @@ public class MapReduceOper extends Operator<MROpPlanVisitor> {
         scalars = new HashSet<PhysicalOperator>();
         nig = NodeIdGenerator.getGenerator();
         scope = k.getScope();
-        phyToMRMap = new HashMap<PhysicalOperator, PhysicalOperator>();
+        phyToMRMap = new MultiMap<PhysicalOperator, PhysicalOperator>();
     }
 
     /*@Override
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java
index fc52c4118..44af52136 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/mapReduceLayer/MultiQueryOptimizer.java
@@ -21,6 +21,7 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.Iterator;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -77,12 +78,14 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
     
     private String scope;
     
-    MultiQueryOptimizer(MROperPlan plan) {
+    private boolean inIllustrator = false;
+    
+    MultiQueryOptimizer(MROperPlan plan, boolean inIllustrator) {
         super(plan, new ReverseDependencyOrderWalker<MapReduceOper, MROperPlan>(plan));
         nig = NodeIdGenerator.getGenerator();
         List<MapReduceOper> roots = plan.getRoots();
         scope = roots.get(0).getOperatorKey().getScope();
-        
+        this.inIllustrator = inIllustrator;
         log.info("MR plan size before optimization: " + plan.size());
     }
 
@@ -290,13 +293,28 @@ class MultiQueryOptimizer extends MROpPlanVisitor {
                 PhysicalOperator opSucc = succ.mapPlan.getSuccessors(op).get(0);
                 PhysicalPlan clone = null;
                 try {
+                    if (inIllustrator)
+                        pl.setOpMap(succ.phyToMRMap);
                     clone = pl.clone();
+                    if (inIllustrator)
+                        pl.resetOpMap();
                 } catch (CloneNotSupportedException e) {
                     int errCode = 2127;
                     String msg = "Internal Error: Cloning of plan failed for optimization.";
                     throw new OptimizerException(msg, errCode, PigException.BUG, e);
                 }
                 succ.mapPlan.remove(op);
+                
+                if (inIllustrator) {
+                    // need to remove the LOAD since data from load on temporary files can't be handled by illustrator
+                    for (Iterator<PhysicalOperator> it = pl.iterator(); it.hasNext(); )
+                    {
+                        PhysicalOperator po = it.next();
+                        if (po instanceof POLoad)
+                            succ.phyToMRMap.removeKey(po);
+                    }
+                }
+                
                 while (!clone.isEmpty()) {
                     PhysicalOperator oper = clone.getLeaves().get(0);
                     clone.remove(oper);
diff --git a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/plans/PhysicalPlan.java b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/plans/PhysicalPlan.java
index 4514e1e5c..d10626d98 100644
--- a/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/plans/PhysicalPlan.java
+++ b/src/org/apache/pig/backend/hadoop/executionengine/physicalLayer/plans/PhysicalPlan.java
@@ -24,7 +24,6 @@ import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
@@ -37,6 +36,7 @@ import org.apache.pig.backend.hadoop.executionengine.physicalLayer.expressionOpe
 import org.apache.pig.impl.plan.OperatorPlan;
 import org.apache.pig.impl.plan.PlanException;
 import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.impl.util.MultiMap;
 
 /**
  * 
@@ -57,6 +57,8 @@ public class PhysicalPlan extends OperatorPlan<PhysicalOperator> implements Clon
     // and that there is no more input expected.
     public boolean endOfAllInput = false;
 
+    private MultiMap<PhysicalOperator, PhysicalOperator> opmap = null;
+    
     public PhysicalPlan() {
         super();
     }
@@ -224,6 +226,8 @@ public class PhysicalPlan extends OperatorPlan<PhysicalOperator> implements Clon
         for (PhysicalOperator op : mOps.keySet()) {
             PhysicalOperator c = op.clone();
             clone.add(c);
+            if (opmap != null)
+                opmap.put(op, c);
             matches.put(op, c);
         }
 
@@ -296,6 +300,12 @@ public class PhysicalPlan extends OperatorPlan<PhysicalOperator> implements Clon
         return clone;
     }
     
+    public void setOpMap(MultiMap<PhysicalOperator, PhysicalOperator> opmap) {
+        this.opmap = opmap;
+    }
     
-    
+    public void resetOpMap()
+    {
+        opmap = null;
+    }
 }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOLimit.java b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
index 3df384576..2ceea11ad 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOLimit.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOLimit.java
@@ -52,6 +52,10 @@ public class LOLimit extends RelationalOperator {
         return mPlan.getPredecessors(this).get(0);
     }
 
+    public LogicalOperator getInput(LogicalPlan plan) {
+        return plan.getPredecessors(this).get(0);
+    }
+    
     public long getLimit() {
         return mLimit;
     }
diff --git a/src/org/apache/pig/impl/logicalLayer/LOUnion.java b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
index bd11271d4..73e22e80b 100644
--- a/src/org/apache/pig/impl/logicalLayer/LOUnion.java
+++ b/src/org/apache/pig/impl/logicalLayer/LOUnion.java
@@ -55,6 +55,10 @@ public class LOUnion extends RelationalOperator {
         return mPlan.getPredecessors(this);
     }
     
+    public List<LogicalOperator> getInputs(LogicalPlan plan) {
+        return plan.getPredecessors(this);
+    }
+    
     @Override
     public Schema getSchema() throws FrontendException {
         if (!mIsSchemaComputed) {
diff --git a/src/org/apache/pig/newplan/BaseOperatorPlan.java b/src/org/apache/pig/newplan/BaseOperatorPlan.java
index de85273b7..f38b05adb 100644
--- a/src/org/apache/pig/newplan/BaseOperatorPlan.java
+++ b/src/org/apache/pig/newplan/BaseOperatorPlan.java
@@ -54,6 +54,18 @@ public abstract class BaseOperatorPlan implements OperatorPlan {
         softToEdges = new PlanEdge();
     }
     
+    @SuppressWarnings("unchecked")
+    public BaseOperatorPlan(BaseOperatorPlan other) {
+        // (shallow) copy constructor
+        ops = (Set<Operator>) ((HashSet<Operator>) other.ops).clone();
+        roots = (List<Operator>) ((ArrayList) other.roots).clone();
+        leaves = (List<Operator>) ((ArrayList) other.leaves).clone();
+        fromEdges = other.fromEdges.shallowClone();
+        toEdges = other.toEdges.shallowClone();
+        softFromEdges = other.softFromEdges.shallowClone();
+        softToEdges = other.softToEdges.shallowClone();
+    }
+    
     /**
      * Get number of nodes in the plan.
      */
diff --git a/src/org/apache/pig/newplan/PlanEdge.java b/src/org/apache/pig/newplan/PlanEdge.java
index 8a4eec0e5..2e3249032 100644
--- a/src/org/apache/pig/newplan/PlanEdge.java
+++ b/src/org/apache/pig/newplan/PlanEdge.java
@@ -20,6 +20,7 @@ package org.apache.pig.newplan;
 
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
 
 import org.apache.pig.impl.util.MultiMap;
 import org.apache.pig.impl.util.Pair;
@@ -100,4 +101,14 @@ public class PlanEdge extends MultiMap<Operator, Operator> {
         return new Pair<Operator, Integer>(keeper, index);
     }
 
+    public PlanEdge shallowClone() {
+        // shallow clone: elements not cloned
+        PlanEdge result = new PlanEdge();
+        for (Map.Entry<Operator, ArrayList<Operator>> entry : mMap.entrySet()) {
+            ArrayList<Operator> list = new ArrayList<Operator>();
+            list.addAll(entry.getValue());
+            result.put(entry.getKey(), list);
+        }
+        return result;
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOCogroup.java b/src/org/apache/pig/newplan/logical/relational/LOCogroup.java
index a3fc84445..1a83cd5f3 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOCogroup.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOCogroup.java
@@ -292,4 +292,8 @@ public class LOCogroup extends LogicalRelationalOperator {
         groupKeyUidOnlySchema = null;
         generatedInputUids = new HashMap<Integer,Long>();
     }
+    
+    public List<Operator> getInputs(LogicalPlan plan) {
+      return plan.getPredecessors(this);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOCross.java b/src/org/apache/pig/newplan/logical/relational/LOCross.java
index 169683215..9440cb1ec 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOCross.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOCross.java
@@ -21,6 +21,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.PlanVisitor;
 
@@ -93,4 +94,8 @@ public class LOCross extends LogicalRelationalOperator {
             return false;
         }
     }
+    
+    public List<Operator>  getInputs() {
+        return plan.getPredecessors(this);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LODistinct.java b/src/org/apache/pig/newplan/logical/relational/LODistinct.java
index f228c416e..dc6c43c9c 100644
--- a/src/org/apache/pig/newplan/logical/relational/LODistinct.java
+++ b/src/org/apache/pig/newplan/logical/relational/LODistinct.java
@@ -59,4 +59,8 @@ public class LODistinct extends LogicalRelationalOperator {
             return false;
         }
     }
+    
+    public Operator getInput(LogicalPlan plan) {
+        return plan.getPredecessors(this).get(0);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOFilter.java b/src/org/apache/pig/newplan/logical/relational/LOFilter.java
index bbc68b06e..0017d5ba8 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOFilter.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOFilter.java
@@ -73,5 +73,9 @@ public class LOFilter extends LogicalRelationalOperator {
             return false;
         }
     }
+    
+    public Operator getInput(LogicalPlan plan) {
+        return plan.getPredecessors(this).get(0);
+    }
 }
 
diff --git a/src/org/apache/pig/newplan/logical/relational/LOLimit.java b/src/org/apache/pig/newplan/logical/relational/LOLimit.java
index 90417cb24..6eb75bc4f 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOLimit.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOLimit.java
@@ -18,6 +18,7 @@
 package org.apache.pig.newplan.logical.relational;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.PlanVisitor;
 
@@ -69,4 +70,8 @@ public class LOLimit extends LogicalRelationalOperator {
         else
             return false;
     }
+    
+    public Operator getInput(LogicalPlan plan) {
+        return plan.getPredecessors(this).get(0);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOLoad.java b/src/org/apache/pig/newplan/logical/relational/LOLoad.java
index 7aac64cd0..b65b90bb3 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOLoad.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOLoad.java
@@ -45,6 +45,7 @@ public class LOLoad extends LogicalRelationalOperator {
     private List<Integer> requiredFields = null;
     private boolean castInserted = false;
     private LogicalSchema uidOnlySchema;
+    private String schemaFile = null;
 
     /**
      * 
@@ -57,9 +58,15 @@ public class LOLoad extends LogicalRelationalOperator {
        super("LOLoad", plan);
        scriptSchema = schema;
        fs = loader;
+       if (loader != null)
+           schemaFile = loader.getFileName();
        this.conf = conf;
     }
     
+    public String getSchemaFile() {
+        return schemaFile;
+    }
+    
     public LoadFunc getLoadFunc() throws FrontendException {
         try { 
             if (loadFunc == null && fs!=null) {
diff --git a/src/org/apache/pig/newplan/logical/relational/LOSort.java b/src/org/apache/pig/newplan/logical/relational/LOSort.java
index 85b882f9f..e794b1ed5 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOSort.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOSort.java
@@ -25,6 +25,7 @@ import org.apache.pig.FuncSpec;
 import org.apache.pig.SortColInfo;
 import org.apache.pig.SortInfo;
 import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.impl.logicalLayer.LogicalOperator;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanVisitor;
@@ -157,4 +158,8 @@ public class LOSort extends LogicalRelationalOperator{
         }
         return checkEquality((LogicalRelationalOperator)other);
     }
+    
+    public Operator getInput(LogicalPlan plan) {
+        return plan.getPredecessors(this).get(0);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LOUnion.java b/src/org/apache/pig/newplan/logical/relational/LOUnion.java
index f789840f3..9afb8e672 100644
--- a/src/org/apache/pig/newplan/logical/relational/LOUnion.java
+++ b/src/org/apache/pig/newplan/logical/relational/LOUnion.java
@@ -125,4 +125,12 @@ public class LOUnion extends LogicalRelationalOperator {
     public void resetUid() {
         uidMapping = new ArrayList<Pair<Long, Long>>();
     }
+    
+    public List<Operator> getInputs() {
+        return plan.getPredecessors(this);
+    }
+    
+    public List<Operator> getInputs(LogicalPlan plan) {
+        return plan.getPredecessors(this);
+    }
 }
diff --git a/src/org/apache/pig/newplan/logical/relational/LogicalPlan.java b/src/org/apache/pig/newplan/logical/relational/LogicalPlan.java
index 17163d53c..e3966131f 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogicalPlan.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogicalPlan.java
@@ -19,6 +19,7 @@
 package org.apache.pig.newplan.logical.relational;
 
 import java.io.PrintStream;
+import java.util.HashSet;
 
 import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.newplan.BaseOperatorPlan;
@@ -32,6 +33,15 @@ import org.apache.pig.newplan.logical.optimizer.LogicalPlanPrinter;
  * each relational operator.
  */
 public class LogicalPlan extends BaseOperatorPlan {
+  
+    public LogicalPlan(LogicalPlan other) {
+        // shallow copy constructor
+        super(other);
+    }
+    
+    public LogicalPlan() {
+        super();
+    }
     
     /**
      * Equality is checked by calling equals on every leaf in the plan.  This
diff --git a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
index 6a9544142..88449cf90 100644
--- a/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
+++ b/src/org/apache/pig/newplan/logical/relational/LogicalSchema.java
@@ -80,12 +80,12 @@ public class LogicalSchema {
                 if( schema == null ) {
                     return ( alias + uidString + ":bag{}" );
                 }
-                return ( alias + uidString + ":bag{" + schema.toString() + "}" );
+                return ( alias + uidString + ":bag{" + schema.toString(verbose) + "}" );
             } else if( type == DataType.TUPLE ) {
                 if( schema == null ) {
                     return ( alias + uidString + ":tuple{}" );
                 }
-                return ( alias + uidString + ":tuple(" + schema.toString() + ")" );
+                return ( alias + uidString + ":tuple(" + schema.toString(verbose) + ")" );
             }
             return ( alias + uidString + ":" + DataType.findTypeName(type) );
         }
diff --git a/src/org/apache/pig/pen/AugmentBaseDataVisitor.java b/src/org/apache/pig/pen/AugmentBaseDataVisitor.java
index 0bff8c85f..0fafeae94 100644
--- a/src/org/apache/pig/pen/AugmentBaseDataVisitor.java
+++ b/src/org/apache/pig/pen/AugmentBaseDataVisitor.java
@@ -26,6 +26,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.HashSet;
 import java.util.Set;
+import java.util.Collection;
 
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -37,71 +38,75 @@ import org.apache.pig.data.DataByteArray;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.data.TupleFactory;
-import org.apache.pig.impl.logicalLayer.BinaryExpressionOperator;
-import org.apache.pig.impl.logicalLayer.ExpressionOperator;
+import org.apache.pig.newplan.logical.expression.BinaryExpression;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.LOAdd;
-import org.apache.pig.impl.logicalLayer.LOAnd;
-import org.apache.pig.impl.logicalLayer.LOCast;
-import org.apache.pig.impl.logicalLayer.LOCogroup;
-import org.apache.pig.impl.logicalLayer.LOLimit;
-import org.apache.pig.impl.logicalLayer.LOConst;
-import org.apache.pig.impl.logicalLayer.LOCross;
-import org.apache.pig.impl.logicalLayer.LODistinct;
-import org.apache.pig.impl.logicalLayer.LODivide;
-import org.apache.pig.impl.logicalLayer.LOEqual;
-import org.apache.pig.impl.logicalLayer.LOFilter;
-import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LOGreaterThan;
-import org.apache.pig.impl.logicalLayer.LOGreaterThanEqual;
-import org.apache.pig.impl.logicalLayer.LOLesserThan;
-import org.apache.pig.impl.logicalLayer.LOLesserThanEqual;
-import org.apache.pig.impl.logicalLayer.LOLoad;
-import org.apache.pig.impl.logicalLayer.LOMod;
-import org.apache.pig.impl.logicalLayer.LOMultiply;
-import org.apache.pig.impl.logicalLayer.LONot;
-import org.apache.pig.impl.logicalLayer.LONotEqual;
-import org.apache.pig.impl.logicalLayer.LOOr;
-import org.apache.pig.impl.logicalLayer.LOProject;
-import org.apache.pig.impl.logicalLayer.LORegexp;
-import org.apache.pig.impl.logicalLayer.LOSort;
-import org.apache.pig.impl.logicalLayer.LOSplit;
-import org.apache.pig.impl.logicalLayer.LOStore;
-import org.apache.pig.impl.logicalLayer.LOSubtract;
-import org.apache.pig.impl.logicalLayer.LOUnion;
-import org.apache.pig.impl.logicalLayer.LOVisitor;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
-import org.apache.pig.impl.logicalLayer.LogicalPlan;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
-import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.newplan.logical.expression.AddExpression;
+import org.apache.pig.newplan.logical.expression.AndExpression;
+import org.apache.pig.newplan.logical.expression.CastExpression;
+import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
+import org.apache.pig.newplan.logical.relational.LOCogroup;
+import org.apache.pig.newplan.logical.relational.LOLimit;
+import org.apache.pig.newplan.logical.expression.ConstantExpression;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
+import org.apache.pig.newplan.logical.relational.LOCross;
+import org.apache.pig.newplan.logical.relational.LODistinct;
+import org.apache.pig.newplan.logical.expression.DivideExpression;
+import org.apache.pig.newplan.logical.expression.EqualExpression;
+import org.apache.pig.newplan.logical.relational.LOFilter;
+import org.apache.pig.newplan.logical.relational.LOForEach;
+import org.apache.pig.newplan.logical.expression.GreaterThanExpression;
+import org.apache.pig.newplan.logical.expression.GreaterThanEqualExpression;
+import org.apache.pig.newplan.logical.expression.LessThanExpression;
+import org.apache.pig.newplan.logical.expression.LessThanEqualExpression;
+import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.newplan.logical.expression.ModExpression;
+import org.apache.pig.newplan.logical.expression.LogicalExpression;
+import org.apache.pig.newplan.logical.expression.MultiplyExpression;
+import org.apache.pig.newplan.logical.expression.NotExpression;
+import org.apache.pig.newplan.logical.expression.NotEqualExpression;
+import org.apache.pig.newplan.logical.expression.OrExpression;
+import org.apache.pig.newplan.logical.expression.ProjectExpression;
+import org.apache.pig.newplan.logical.expression.RegexExpression;
+import org.apache.pig.newplan.logical.relational.LOSort;
+import org.apache.pig.newplan.logical.relational.LOSplit;
+import org.apache.pig.newplan.logical.relational.LOStore;
+import org.apache.pig.newplan.logical.expression.SubtractExpression;
+import org.apache.pig.newplan.logical.relational.LOUnion;
+import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
 import org.apache.pig.pen.util.ExampleTuple;
 import org.apache.pig.pen.util.PreOrderDepthFirstWalker;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.POLimit;
+import org.apache.pig.impl.util.MultiMap;
+import org.apache.pig.impl.io.FileSpec;
 
 //This is used to generate synthetic data
 //Synthetic data generation is done by making constraint tuples for each operator as we traverse the plan
 //and try to replace the constraints with values as far as possible. We only deal with simple conditions right now
 
-public class AugmentBaseDataVisitor extends LOVisitor {
+public class AugmentBaseDataVisitor extends LogicalRelationalNodesVisitor {
 
     Map<LOLoad, DataBag> baseData = null;
     Map<LOLoad, DataBag> newBaseData = new HashMap<LOLoad, DataBag>();
-    Map<LogicalOperator, DataBag> derivedData = null;
+    Map<Operator, DataBag> derivedData = null;
     private boolean limit = false;
-    private final Map<LogicalOperator, PhysicalOperator> logToPhysMap;
+    private final Map<Operator, PhysicalOperator> logToPhysMap;
     private Map<LOLimit, Long> oriLimitMap;
 
-    Map<LogicalOperator, DataBag> outputConstraintsMap = new HashMap<LogicalOperator, DataBag>();
+    Map<Operator, DataBag> outputConstraintsMap = new HashMap<Operator, DataBag>();
 
     Log log = LogFactory.getLog(getClass());
 
     // Augmentation moves from the leaves to root and hence needs a
     // depthfirstwalker
-    public AugmentBaseDataVisitor(LogicalPlan plan,
-            Map<LogicalOperator, PhysicalOperator> logToPhysMap,
+    public AugmentBaseDataVisitor(OperatorPlan plan,
+            Map<Operator, PhysicalOperator> logToPhysMap,
             Map<LOLoad, DataBag> baseData,
-            Map<LogicalOperator, DataBag> derivedData) {
-        super(plan, new PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>(
+            Map<Operator, DataBag> derivedData) throws FrontendException {
+        super(plan, new PreOrderDepthFirstWalker(
                 plan));
         this.baseData = baseData;
         this.derivedData = derivedData;
@@ -112,7 +117,43 @@ public class AugmentBaseDataVisitor extends LOVisitor {
         limit = true;
     }
     
-    public Map<LOLoad, DataBag> getNewBaseData() {
+    public Map<LOLoad, DataBag> getNewBaseData() throws ExecException {
+        // consolidate base data from different LOADs on the same inputs
+        MultiMap<FileSpec, DataBag> inputDataMap = new MultiMap<FileSpec, DataBag>();
+        for (Map.Entry<LOLoad, DataBag> e : newBaseData.entrySet()) {
+            inputDataMap.put(e.getKey().getFileSpec(), e.getValue());
+        }
+        
+        int index = 0;
+        for (FileSpec fs : inputDataMap.keySet()) {
+            int maxSchemaSize = 0;
+            Tuple tupleOfMaxSchemaSize = null;
+            for (DataBag bag : inputDataMap.get(fs)) {
+                if (bag.size() > 0) {
+                    int size = 0;
+                    Tuple t = null;
+                    t = bag.iterator().next();
+                    size = t.size();
+                    if (size > maxSchemaSize) {
+                        maxSchemaSize = size;
+                        tupleOfMaxSchemaSize = t;
+                    }
+                }
+            }
+            for (DataBag bag : inputDataMap.get(fs)) {
+                if (bag.size() > 0) {
+                    for (Iterator<Tuple> it = bag.iterator(); it.hasNext();) {
+                        Tuple t = it.next();
+                        for (int i = t.size(); i < maxSchemaSize; ++i) {
+                            t.append(tupleOfMaxSchemaSize.get(i));
+                        }
+                    }
+                }
+            }
+            index++;
+        }
+        
+        
         for (Map.Entry<LOLoad, DataBag> e : baseData.entrySet()) {
             DataBag bag = newBaseData.get(e.getKey());
             if (bag == null) {
@@ -129,8 +170,8 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     }
     
     @Override
-    protected void visit(LOCogroup cg) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOCogroup cg) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
         // we first get the outputconstraints for the current cogroup
         DataBag outputConstraints = outputConstraintsMap.get(cg);
@@ -141,16 +182,14 @@ public class AugmentBaseDataVisitor extends LOVisitor {
         List<List<Integer>> groupSpecs = new LinkedList<List<Integer>>();
         int numCols = -1;
 
-        int minGroupSize = (cg.getInputs().size() == 1) ? 1 : 2;
-
-        for (LogicalOperator op : cg.getInputs()) {
-            List<LogicalPlan> groupByPlans = (List<LogicalPlan>) cg
-                    .getGroupByPlans().get(op);
+        for (int index = 0; index < cg.getInputs((LogicalPlan)plan).size(); ++index) {
+            Collection<LogicalExpressionPlan> groupByPlans = (List<LogicalExpressionPlan>) cg
+                    .getExpressionPlans().get(index);
             List<Integer> groupCols = new ArrayList<Integer>();
-            for (LogicalPlan plan : groupByPlans) {
-                LogicalOperator leaf = plan.getLeaves().get(0);
-                if (leaf instanceof LOProject) {
-                    groupCols.add(((LOProject) leaf).getCol());
+            for (LogicalExpressionPlan plan : groupByPlans) {
+                Operator leaf = plan.getSinks().get(0);
+                if (leaf instanceof ProjectExpression) {
+                    groupCols.add(Integer.valueOf(((ProjectExpression) leaf).getColNum()));
                 } else {
                     ableToHandle = false;
                     break;
@@ -173,7 +212,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
         try {
             if (ableToHandle) {
                 // we need to go through the output constraints first
-                int numInputs = cg.getInputs().size();
+                int numInputs = cg.getInputs((LogicalPlan) plan).size();
                 if (outputConstraints != null) {
                     for (Iterator<Tuple> it = outputConstraints.iterator(); it
                             .hasNext();) {
@@ -182,19 +221,19 @@ public class AugmentBaseDataVisitor extends LOVisitor {
 
                         for (int input = 0; input < numInputs; input++) {
 
-                            int numInputFields = cg.getInputs().get(input)
+                            int numInputFields = ((LogicalRelationalOperator) cg.getInputs((LogicalPlan) plan).get(input))
                                     .getSchema().size();
                             List<Integer> groupCols = groupSpecs.get(input);
 
                             DataBag output = outputConstraintsMap.get(cg
-                                    .getInputs().get(input));
+                                    .getInputs((LogicalPlan) plan).get(input));
                             if (output == null) {
                                 output = BagFactory.getInstance()
                                         .newDefaultBag();
-                                outputConstraintsMap.put(cg.getInputs().get(
+                                outputConstraintsMap.put(cg.getInputs((LogicalPlan) plan).get(
                                         input), output);
                             }
-                            for (int i = 0; i < minGroupSize; i++) {
+                            for (int i = 0; i < 2; i++) {
                                 Tuple inputConstraint = GetGroupByInput(
                                         groupLabel, groupCols, numInputFields);
                                 if (inputConstraint != null)
@@ -212,18 +251,18 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     Object groupLabel = groupTup.get(0);
 
                     for (int input = 0; input < numInputs; input++) {
-                        int numInputFields = cg.getInputs().get(input)
+                        int numInputFields = ((LogicalRelationalOperator)cg.getInputs((LogicalPlan) plan).get(input))
                                 .getSchema().size();
                         List<Integer> groupCols = groupSpecs.get(input);
 
                         DataBag output = outputConstraintsMap.get(cg
-                                .getInputs().get(input));
+                                .getInputs((LogicalPlan) plan).get(input));
                         if (output == null) {
                             output = BagFactory.getInstance().newDefaultBag();
-                            outputConstraintsMap.put(cg.getInputs().get(input),
+                            outputConstraintsMap.put(cg.getInputs((LogicalPlan) plan).get(input),
                                     output);
                         }
-                        int numTupsToAdd = minGroupSize
+                        int numTupsToAdd = 2
                                 - (int) ((DataBag) groupTup.get(input + 1))
                                         .size();
                         for (int i = 0; i < numTupsToAdd; i++) {
@@ -239,29 +278,29 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             log
                     .error("Error visiting Cogroup during Augmentation phase of Example Generator! "
                             + e.getMessage());
-            throw new VisitorException(
+            throw new FrontendException(
                     "Error visiting Cogroup during Augmentation phase of Example Generator! "
                             + e.getMessage());
         }
     }
 
     @Override
-    protected void visit(LOCross cs) throws VisitorException {
+    public void visit(LOCross cs) throws FrontendException {
 
     }
 
     @Override
-    protected void visit(LODistinct dt) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LODistinct dt) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
     
         DataBag outputConstraints = outputConstraintsMap.get(dt);
         outputConstraintsMap.remove(dt);
 
-        DataBag inputConstraints = outputConstraintsMap.get(dt.getInput());
+        DataBag inputConstraints = outputConstraintsMap.get(dt.getInput((LogicalPlan) plan));
         if (inputConstraints == null) {
             inputConstraints = BagFactory.getInstance().newDefaultBag();
-            outputConstraintsMap.put(dt.getInput(), inputConstraints);
+            outputConstraintsMap.put(dt.getInput((LogicalPlan) plan), inputConstraints);
         }
     
         if (outputConstraints != null && outputConstraints.size() > 0) {
@@ -273,7 +312,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
         
         boolean emptyInputConstraints = inputConstraints.size() == 0;
         if (emptyInputConstraints) {
-            DataBag inputData = derivedData.get(dt.getInput());
+            DataBag inputData = derivedData.get(dt.getInput((LogicalPlan) plan));
             for (Iterator<Tuple> it = inputData.iterator(); it.hasNext();)
             {
                 inputConstraints.add(it.next());
@@ -300,22 +339,22 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     }
 
     @Override
-    protected void visit(LOFilter filter) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOFilter filter) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
         
         DataBag outputConstraints = outputConstraintsMap.get(filter);
         outputConstraintsMap.remove(filter);
 
-        LogicalPlan filterCond = filter.getComparisonPlan();
-        DataBag inputConstraints = outputConstraintsMap.get(filter.getInput());
+        LogicalExpressionPlan filterCond = filter.getFilterPlan();
+        DataBag inputConstraints = outputConstraintsMap.get(filter.getInput((LogicalPlan) plan));
         if (inputConstraints == null) {
             inputConstraints = BagFactory.getInstance().newDefaultBag();
-            outputConstraintsMap.put(filter.getInput(), inputConstraints);
+            outputConstraintsMap.put(filter.getInput((LogicalPlan) plan), inputConstraints);
         }
 
         DataBag outputData = derivedData.get(filter);
-        DataBag inputData = derivedData.get(filter.getInput());
+        DataBag inputData = derivedData.get(filter.getInput((LogicalPlan) plan));
         try {
             if (outputConstraints != null && outputConstraints.size() > 0) { // there
                 // 's
@@ -365,19 +404,19 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             log
                     .error("Error visiting Load during Augmentation phase of Example Generator! "
                             + e.getMessage());
-            throw new VisitorException(
+            throw new FrontendException(
                     "Error visiting Load during Augmentation phase of Example Generator! "
                             + e.getMessage());
         }
     }
 
     @Override
-    protected void visit(LOForEach forEach) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOForEach forEach) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
         DataBag outputConstraints = outputConstraintsMap.get(forEach);
         outputConstraintsMap.remove(forEach);
-        List<LogicalPlan> plans = forEach.getForEachPlans();
+        LogicalPlan plan = forEach.getInnerPlan();
         boolean ableToHandle = true;
         List<Integer> cols = new ArrayList<Integer>();
         boolean cast = false;
@@ -386,20 +425,18 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             // we dont have to do anything in this case
             return;
 
-        for (LogicalPlan plan : plans) {
-            LogicalOperator op = plan.getLeaves().get(0);
-            if (op instanceof LOCast) {
+
+        Operator op = plan.getSinks().get(0);
+        if (op instanceof CastExpression) {
                 cast = true;
-                op = ((LOCast) op).getExpression();
+                op = ((CastExpression) op).getExpression();
             }
 
-            if (!(op instanceof LOProject)) {
+            if (!(op instanceof ProjectExpression)) {
                 ableToHandle = false;
-                break;
             } else {
-                cols.add(((LOProject) op).getCol());
+                cols.add(Integer.valueOf(((ProjectExpression) op).getColNum()));
             }
-        }
 
         if (ableToHandle) {
             // we can only handle simple projections
@@ -409,26 +446,31 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                 Tuple outputConstraint = it.next();
                 try {
                     Tuple inputConstraint = BackPropConstraint(
-                            outputConstraint, cols, (forEach.getPlan()
-                                    .getPredecessors(forEach)).get(0)
+                            outputConstraint, cols, ((LogicalRelationalOperator)plan
+                                    .getPredecessors(forEach).get(0))
                                     .getSchema(), cast);
                     output.add(inputConstraint);
                 } catch (Exception e) {
                     e.printStackTrace();
-                    throw new VisitorException(
+                    throw new FrontendException(
                             "Operator error during Augmenting Phase in Example Generator "
                                     + e.getMessage());
                 }
             }
-            outputConstraintsMap.put(forEach.getPlan().getPredecessors(forEach)
+            outputConstraintsMap.put(plan.getPredecessors(forEach)
                     .get(0), output);
         }
 
     }
 
     @Override
-    protected void visit(LOLoad load) throws VisitorException {
+    public void visit(LOLoad load) throws FrontendException {
         DataBag inputData = baseData.get(load);
+       // check if the inputData exists
+        if (inputData == null || inputData.size() == 0) {
+            log.error("No (valid) input data found!");
+            throw new RuntimeException("No (valid) input data found!");
+        }
 
         DataBag newInputData = newBaseData.get(load);
         if (newInputData == null) {
@@ -436,7 +478,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             newBaseData.put(load, newInputData);
         }
 
-        Schema schema;
+        LogicalSchema schema;
         try {
             schema = load.getSchema();
             if (schema == null)
@@ -447,17 +489,15 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             log
                     .error("Error visiting Load during Augmentation phase of Example Generator! "
                             + e.getMessage());
-            throw new VisitorException(
+            throw new FrontendException(
                     "Error visiting Load during Augmentation phase of Example Generator! "
                             + e.getMessage());
         }
+        
+        Tuple exampleTuple = inputData.iterator().next();
+        
         DataBag outputConstraints = outputConstraintsMap.get(load);
         outputConstraintsMap.remove(load);
-        // check if the inputData exists
-        if (inputData == null || inputData.size() == 0) {
-            log.error("No (valid) input data found!");
-            throw new RuntimeException("No (valid) input data found!");
-        }
 
         // first of all, we are required to guarantee that there is at least one
         // output tuple
@@ -469,7 +509,6 @@ public class AugmentBaseDataVisitor extends LOVisitor {
 
         // create example tuple to steal values from when we encounter
         // "don't care" fields (i.e. null fields)
-        Tuple exampleTuple = inputData.iterator().next();
         System.out.println(exampleTuple.toString());
 
         // run through output constraints; for each one synthesize a tuple and
@@ -505,7 +544,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                 log
                         .error("Error visiting Load during Augmentation phase of Example Generator! "
                                 + e.getMessage());
-                throw new VisitorException(
+                throw new FrontendException(
                         "Error visiting Load during Augmentation phase of Example Generator! "
                                 + e.getMessage());
 
@@ -521,24 +560,14 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                         newInput = true;
                 }
             } catch (ExecException e) {
-                throw new VisitorException(
+                throw new FrontendException(
                   "Error visiting Load during Augmentation phase of Example Generator! "
                           + e.getMessage());
             }
         }
-        
-        if (newInput) {
-            for (Map.Entry<LOLoad, DataBag> entry : newBaseData.entrySet()) {
-                LOLoad otherLoad = entry.getKey();
-                if (otherLoad != load && otherLoad.getInputFile().equals(load.getInputFile())) {
-                    // different load sharing the same input file
-                    entry.getValue().addAll(newInputData);
-                }
-            }
-        }
     }
 
-    private boolean inInput(Tuple newTuple, DataBag input, Schema schema) throws ExecException {
+    private boolean inInput(Tuple newTuple, DataBag input, LogicalSchema schema) throws ExecException {
         boolean result;
         for (Iterator<Tuple> iter = input.iterator(); iter.hasNext();) {
             result = true;
@@ -556,43 +585,43 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     }
     
     @Override
-    protected void visit(LOSort s) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOSort s) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
         DataBag outputConstraints = outputConstraintsMap.get(s);
         outputConstraintsMap.remove(s);
 
         if (outputConstraints == null)
-            outputConstraintsMap.put(s.getInput(), BagFactory.getInstance()
+            outputConstraintsMap.put(s.getInput((LogicalPlan) plan), BagFactory.getInstance()
                     .newDefaultBag());
         else
-            outputConstraintsMap.put(s.getInput(), outputConstraints);
+            outputConstraintsMap.put(s.getInput((LogicalPlan) plan), outputConstraints);
     }
 
     @Override
-    protected void visit(LOSplit split) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOSplit split) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
           return;
     }
 
     @Override
-    protected void visit(LOStore store) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOStore store) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
         DataBag outputConstraints = outputConstraintsMap.get(store);
         if (outputConstraints == null) {
-            outputConstraintsMap.put(store.getPlan().getPredecessors(store)
+            outputConstraintsMap.put(plan.getPredecessors(store)
                     .get(0), BagFactory.getInstance().newDefaultBag());
         } else {
             outputConstraintsMap.remove(store);
-            outputConstraintsMap.put(store.getPlan().getPredecessors(store)
+            outputConstraintsMap.put(plan.getPredecessors(store)
                     .get(0), outputConstraints);
         }
     }
 
     @Override
-    protected void visit(LOUnion u) throws VisitorException {
-        if (limit && !((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).getBranchFlag())
+    public void visit(LOUnion u) throws FrontendException {
+        if (limit && !((PreOrderDepthFirstWalker) currentWalker).getBranchFlag())
             return;
         DataBag outputConstraints = outputConstraintsMap.get(u);
         outputConstraintsMap.remove(u);
@@ -600,7 +629,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             // we dont need to do anything
             // we just find the inputs, create empty bags as their
             // outputConstraints and return
-            for (LogicalOperator op : u.getInputs()) {
+            for (Operator op : u.getInputs((LogicalPlan) plan)) {
                 DataBag constraints = BagFactory.getInstance().newDefaultBag();
                 outputConstraintsMap.put(op, constraints);
             }
@@ -610,10 +639,10 @@ public class AugmentBaseDataVisitor extends LOVisitor {
         // since we have some outputConstraints, we apply them to the inputs
         // round-robin
         int count = 0;
-        List<LogicalOperator> inputs = u.getInputs();
+        List<Operator> inputs = u.getInputs(((LogicalPlan) plan));
         int noInputs = inputs.size();
 
-        for (LogicalOperator op : inputs) {
+        for (Operator op : inputs) {
             DataBag constraint = BagFactory.getInstance().newDefaultBag();
             outputConstraintsMap.put(op, constraint);
         }
@@ -626,7 +655,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     }
 
     @Override
-    protected void visit(LOLimit lm) throws VisitorException {
+    public void visit(LOLimit lm) throws FrontendException {
         if (!limit) // not augment for LIMIT in this traversal
             return;
         
@@ -636,13 +665,13 @@ public class AugmentBaseDataVisitor extends LOVisitor {
         DataBag outputConstraints = outputConstraintsMap.get(lm);
         outputConstraintsMap.remove(lm);
 
-        DataBag inputConstraints = outputConstraintsMap.get(lm.getInput());
+        DataBag inputConstraints = outputConstraintsMap.get(lm.getInput((LogicalPlan) plan));
         if (inputConstraints == null) {
             inputConstraints = BagFactory.getInstance().newDefaultBag();
-            outputConstraintsMap.put(lm.getInput(), inputConstraints);
+            outputConstraintsMap.put(lm.getInput((LogicalPlan) plan), inputConstraints);
         }
 
-        DataBag inputData = derivedData.get(lm.getInput());
+        DataBag inputData = derivedData.get(lm.getInput((LogicalPlan) plan));
         
         if (outputConstraints != null && outputConstraints.size() > 0) { // there
             // 's
@@ -662,7 +691,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
              // ... plus one more if only one
              if (inputConstraints.size() == 1) {
                 inputConstraints.add(inputData.iterator().next());
-                ((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).setBranchFlag();
+                ((PreOrderDepthFirstWalker) currentWalker).setBranchFlag();
              }
           }
         } else if (inputConstraints.size() == 0){
@@ -671,7 +700,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             // ... plus one more if only one
             if (inputConstraints.size() == 1) {
                 inputConstraints.add(inputData.iterator().next());
-                ((PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>) mCurrentWalker).setBranchFlag();
+                ((PreOrderDepthFirstWalker) currentWalker).setBranchFlag();
             }
         }
         POLimit poLimit = (POLimit) logToPhysMap.get(lm);
@@ -700,7 +729,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     }
 
     Tuple BackPropConstraint(Tuple outputConstraint, List<Integer> cols,
-            Schema inputSchema, boolean cast) throws ExecException {
+            LogicalSchema inputSchema, boolean cast) throws ExecException {
         Tuple inputConst = TupleFactory.getInstance().newTuple(
                 inputSchema.getFields().size());
 
@@ -732,8 +761,8 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     // predicate
     // (or null if unable to find such a tuple)
 
-    ExampleTuple GenerateMatchingTuple(Schema schema, LogicalPlan plan,
-            boolean invert) throws ExecException {
+    ExampleTuple GenerateMatchingTuple(LogicalSchema schema, LogicalExpressionPlan plan,
+            boolean invert) throws FrontendException, ExecException {
         return GenerateMatchingTuple(TupleFactory.getInstance().newTuple(
                 schema.getFields().size()), plan, invert);
     }
@@ -753,39 +782,39 @@ public class AugmentBaseDataVisitor extends LOVisitor {
     // what predicate it wants satisfied in a given field)
     //
 
-    ExampleTuple GenerateMatchingTuple(Tuple constraint, LogicalPlan predicate,
-            boolean invert) throws ExecException {
+    ExampleTuple GenerateMatchingTuple(Tuple constraint, LogicalExpressionPlan predicate,
+            boolean invert) throws ExecException, FrontendException {
         Tuple t = TupleFactory.getInstance().newTuple(constraint.size());
         ExampleTuple tOut = new ExampleTuple(t);
         for (int i = 0; i < t.size(); i++)
             tOut.set(i, constraint.get(i));
 
-        GenerateMatchingTupleHelper(tOut, (ExpressionOperator) predicate
-                .getLeaves().get(0), invert);
+        GenerateMatchingTupleHelper(tOut, predicate
+                .getSources().get(0), invert);
         tOut.synthetic = true;
         return tOut;
 
     }
 
-    void GenerateMatchingTupleHelper(Tuple t, ExpressionOperator pred,
-            boolean invert) throws ExecException {
-        if (pred instanceof BinaryExpressionOperator)
-            GenerateMatchingTupleHelper(t, (BinaryExpressionOperator) pred,
+    void GenerateMatchingTupleHelper(Tuple t, Operator pred,
+            boolean invert) throws FrontendException, ExecException {
+        if (pred instanceof BinaryExpression)
+            GenerateMatchingTupleHelper(t, (BinaryExpression) pred,
                     invert);
-        else if (pred instanceof LONot)
-            GenerateMatchingTupleHelper(t, (LONot) pred, invert);
+        else if (pred instanceof NotExpression)
+            GenerateMatchingTupleHelper(t, (NotExpression) pred, invert);
         else
-            throw new ExecException("Unknown operator in filter predicate");
+            throw new FrontendException("Unknown operator in filter predicate");
     }
 
-    void GenerateMatchingTupleHelper(Tuple t, BinaryExpressionOperator pred,
-            boolean invert) throws ExecException {
+    void GenerateMatchingTupleHelper(Tuple t, BinaryExpression pred,
+            boolean invert) throws FrontendException, ExecException {
 
-        if (pred instanceof LOAnd) {
-            GenerateMatchingTupleHelper(t, (LOAnd) pred, invert);
+        if (pred instanceof AndExpression) {
+            GenerateMatchingTupleHelper(t, (AndExpression) pred, invert);
             return;
-        } else if (pred instanceof LOOr) {
-            GenerateMatchingTupleHelper(t, (LOOr) pred, invert);
+        } else if (pred instanceof OrExpression) {
+            GenerateMatchingTupleHelper(t, (OrExpression) pred, invert);
             return;
         }
 
@@ -798,27 +827,26 @@ public class AugmentBaseDataVisitor extends LOVisitor {
 
         int leftCol = -1, rightCol = -1;
 
-        if (pred instanceof LOAdd || pred instanceof LOSubtract
-                || pred instanceof LOMultiply || pred instanceof LODivide
-                || pred instanceof LOMod || pred instanceof LORegexp)
+        if (pred instanceof AddExpression || pred instanceof SubtractExpression
+                || pred instanceof MultiplyExpression || pred instanceof DivideExpression
+                || pred instanceof ModExpression || pred instanceof RegexExpression)
             return; // We don't try to work around these operators right now
 
-        if (pred.getLhsOperand() instanceof LOConst) {
+        if (pred.getLhs() instanceof ConstantExpression) {
             leftIsConst = true;
-            leftConst = ((LOConst) (pred.getLhsOperand())).getValue();
+            leftConst = ((ConstantExpression) (pred.getLhs())).getValue();
         } else {
-            LogicalOperator lhs = pred.getLhsOperand();
-            if (lhs instanceof LOCast)
-                lhs = ((LOCast) lhs).getExpression();
-            // if (!(pred.getLhsOperand() instanceof LOProject && ((LOProject)
+            LogicalExpression lhs = pred.getLhs();
+            if (lhs instanceof CastExpression)
+                lhs = ((CastExpression) lhs).getExpression();
+            // if (!(pred.getLhsOperand() instanceof ProjectExpression && ((ProjectExpression)
             // pred
             // .getLhsOperand()).getProjection().size() == 1))
             // return; // too hard
-            if (!(lhs instanceof LOProject && ((LOProject) lhs).getProjection()
-                    .size() == 1))
+            if (!(lhs instanceof ProjectExpression))
                 return;
-            leftCol = ((LOProject) lhs).getCol();
-            leftDataType = ((LOProject) lhs).getType();
+            leftCol = ((ProjectExpression) lhs).getColNum();
+            leftDataType = ((ProjectExpression) lhs).getType();
 
             Object d = t.get(leftCol);
             if (d != null) {
@@ -827,22 +855,21 @@ public class AugmentBaseDataVisitor extends LOVisitor {
             }
         }
 
-        if (pred.getRhsOperand() instanceof LOConst) {
+        if (pred.getRhs() instanceof ConstantExpression) {
             rightIsConst = true;
-            rightConst = ((LOConst) (pred.getRhsOperand())).getValue();
+            rightConst = ((ConstantExpression) (pred.getRhs())).getValue();
         } else {
-            LogicalOperator rhs = pred.getRhsOperand();
-            if (rhs instanceof LOCast)
-                rhs = ((LOCast) rhs).getExpression();
-            // if (!(pred.getRhsOperand() instanceof LOProject && ((LOProject)
+            Operator rhs = pred.getRhs();
+            if (rhs instanceof CastExpression)
+                rhs = ((CastExpression) rhs).getExpression();
+            // if (!(pred.getRhsOperand() instanceof ProjectExpression && ((ProjectExpression)
             // pred
             // .getRhsOperand()).getProjection().size() == 1))
             // return; // too hard
-            if (!(rhs instanceof LOProject && ((LOProject) rhs).getProjection()
-                    .size() == 1))
+            if (!(rhs instanceof ProjectExpression))
                 return;
-            rightCol = ((LOProject) rhs).getCol();
-            rightDataType = ((LOProject) rhs).getType();
+            rightCol = ((ProjectExpression) rhs).getColNum();
+            rightDataType = ((ProjectExpression) rhs).getType();
 
             Object d = t.get(rightCol);
             if (d != null) {
@@ -858,7 +885,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
 
         // convert some nulls to constants
         if (!invert) {
-            if (pred instanceof LOEqual) {
+            if (pred instanceof EqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType, leftConst
                             .toString()));
@@ -869,7 +896,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     t.set(leftCol, generateData(leftDataType, "0"));
                     t.set(rightCol, generateData(rightDataType, "0"));
                 }
-            } else if (pred instanceof LONotEqual) {
+            } else if (pred instanceof NotEqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType,
                             GetUnequalValue(leftConst).toString()));
@@ -880,8 +907,8 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     t.set(leftCol, generateData(leftDataType, "0"));
                     t.set(rightCol, generateData(rightDataType, "1"));
                 }
-            } else if (pred instanceof LOGreaterThan
-                    || pred instanceof LOGreaterThanEqual) {
+            } else if (pred instanceof GreaterThanExpression
+                    || pred instanceof GreaterThanEqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType,
                             GetSmallerValue(leftConst).toString()));
@@ -892,8 +919,8 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     t.set(leftCol, generateData(leftDataType, "1"));
                     t.set(rightCol, generateData(rightDataType, "0"));
                 }
-            } else if (pred instanceof LOLesserThan
-                    || pred instanceof LOLesserThanEqual) {
+            } else if (pred instanceof LessThanExpression
+                    || pred instanceof LessThanEqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType, GetLargerValue(
                             leftConst).toString()));
@@ -906,7 +933,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                 }
             }
         } else {
-            if (pred instanceof LOEqual) {
+            if (pred instanceof EqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType,
                             GetUnequalValue(leftConst).toString()));
@@ -917,7 +944,7 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     t.set(leftCol, generateData(leftDataType, "0"));
                     t.set(rightCol, generateData(rightDataType, "1"));
                 }
-            } else if (pred instanceof LONotEqual) {
+            } else if (pred instanceof NotEqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType, leftConst
                             .toString()));
@@ -928,8 +955,8 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     t.set(leftCol, generateData(leftDataType, "0"));
                     t.set(rightCol, generateData(rightDataType, "0"));
                 }
-            } else if (pred instanceof LOGreaterThan
-                    || pred instanceof LOGreaterThanEqual) {
+            } else if (pred instanceof GreaterThanExpression
+                    || pred instanceof GreaterThanEqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType, GetLargerValue(
                             leftConst).toString()));
@@ -940,8 +967,8 @@ public class AugmentBaseDataVisitor extends LOVisitor {
                     t.set(leftCol, generateData(leftDataType, "0"));
                     t.set(rightCol, generateData(rightDataType, "1"));
                 }
-            } else if (pred instanceof LOLesserThan
-                    || pred instanceof LOLesserThanEqual) {
+            } else if (pred instanceof LessThanExpression
+                    || pred instanceof LessThanEqualExpression) {
                 if (leftIsConst) {
                     t.set(rightCol, generateData(rightDataType,
                             GetSmallerValue(leftConst).toString()));
@@ -957,27 +984,27 @@ public class AugmentBaseDataVisitor extends LOVisitor {
 
     }
 
-    void GenerateMatchingTupleHelper(Tuple t, LOAnd op, boolean invert)
-            throws ExecException {
-        ExpressionOperator input = op.getLhsOperand();
+    void GenerateMatchingTupleHelper(Tuple t, AndExpression op, boolean invert)
+            throws FrontendException, ExecException {
+        Operator input = op.getLhs();
         GenerateMatchingTupleHelper(t, input, invert);
-        input = op.getRhsOperand();
+        input = op.getRhs();
         GenerateMatchingTupleHelper(t, input, invert);
 
     }
 
-    void GenerateMatchingTupleHelper(Tuple t, LOOr op, boolean invert)
-            throws ExecException {
-        ExpressionOperator input = op.getLhsOperand();
+    void GenerateMatchingTupleHelper(Tuple t, OrExpression op, boolean invert)
+            throws FrontendException, ExecException {
+        Operator input = op.getLhs();
         GenerateMatchingTupleHelper(t, input, invert);
-        input = op.getRhsOperand();
+        input = op.getRhs();
         GenerateMatchingTupleHelper(t, input, invert);
 
     }
 
-    void GenerateMatchingTupleHelper(Tuple t, LONot op, boolean invert)
-            throws ExecException {
-        ExpressionOperator input = op.getOperand();
+    void GenerateMatchingTupleHelper(Tuple t, NotExpression op, boolean invert)
+            throws FrontendException, ExecException {
+        LogicalExpression input = op.getExpression();
         GenerateMatchingTupleHelper(t, input, !invert);
 
     }
diff --git a/src/org/apache/pig/pen/DerivedDataVisitor.java b/src/org/apache/pig/pen/DerivedDataVisitor.java
index 69cd8bea6..e69de29bb 100644
--- a/src/org/apache/pig/pen/DerivedDataVisitor.java
+++ b/src/org/apache/pig/pen/DerivedDataVisitor.java
@@ -1,113 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.pig.pen;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.pig.backend.executionengine.ExecException;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.POStatus;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.Result;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhysicalPlan;
-import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.PORead;
-import org.apache.pig.data.BagFactory;
-import org.apache.pig.data.DataBag;
-import org.apache.pig.data.Tuple;
-import org.apache.pig.impl.PigContext;
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.LOCogroup;
-import org.apache.pig.impl.logicalLayer.LOCross;
-import org.apache.pig.impl.logicalLayer.LODistinct;
-import org.apache.pig.impl.logicalLayer.LOFilter;
-import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LOLimit;
-import org.apache.pig.impl.logicalLayer.LOLoad;
-import org.apache.pig.impl.logicalLayer.LOSort;
-import org.apache.pig.impl.logicalLayer.LOSplit;
-import org.apache.pig.impl.logicalLayer.LOStore;
-import org.apache.pig.impl.logicalLayer.LOUnion;
-import org.apache.pig.impl.logicalLayer.LOVisitor;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
-import org.apache.pig.impl.logicalLayer.LogicalPlan;
-import org.apache.pig.impl.logicalLayer.PlanSetter;
-import org.apache.pig.impl.logicalLayer.validators.LogicalPlanValidationExecutor;
-import org.apache.pig.impl.plan.CompilationMessageCollector;
-import org.apache.pig.impl.plan.DependencyOrderWalker;
-import org.apache.pig.impl.plan.OperatorKey;
-import org.apache.pig.impl.plan.PlanException;
-import org.apache.pig.impl.plan.VisitorException;
-import org.apache.pig.impl.util.IdentityHashSet;
-import org.apache.pig.pen.util.DependencyOrderLimitedWalker;
-import org.apache.pig.pen.util.LineageTracer;
-
-
-//This class is used to pass data through the entire plan and save the intermediates results.
-public class DerivedDataVisitor {
-
-    Map<LogicalOperator, DataBag> derivedData = new HashMap<LogicalOperator, DataBag>();
-    PhysicalPlan physPlan = null;
-    Map<LOLoad, DataBag> baseData = null;
-
-    Map<LogicalOperator, PhysicalOperator> LogToPhyMap = null;
-    Log log = LogFactory.getLog(getClass());
-
-    Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> OpToEqClasses = null;
-    Collection<IdentityHashSet<Tuple>> EqClasses = null;
-
-    LineageTracer lineage = new LineageTracer();
-
-    public DerivedDataVisitor(LogicalPlan plan, PigContext pc,
-            Map<LOLoad, DataBag> baseData,
-            PhysicalPlan physPlan) {
-
-        this.baseData = baseData;
-
-        OpToEqClasses = new HashMap<LogicalOperator, Collection<IdentityHashSet<Tuple>>>();
-        EqClasses = new LinkedList<IdentityHashSet<Tuple>>();
-
-        this.physPlan = physPlan;
-        // if(logToPhyMap == null)
-        // compilePlan(plan);
-        // else
-        // LogToPhyMap = logToPhyMap;
-
-    }
-
-    public DerivedDataVisitor(LogicalOperator op, PigContext pc,
-            Map<LOLoad, DataBag> baseData,
-            Map<LogicalOperator, PhysicalOperator> logToPhyMap,
-            PhysicalPlan physPlan) {
-        this.baseData = baseData;
-
-        OpToEqClasses = new HashMap<LogicalOperator, Collection<IdentityHashSet<Tuple>>>();
-        EqClasses = new LinkedList<IdentityHashSet<Tuple>>();
-
-        LogToPhyMap = logToPhyMap;
-        this.physPlan = physPlan;
-    }
-}
diff --git a/src/org/apache/pig/pen/EquivalenceClasses.java b/src/org/apache/pig/pen/EquivalenceClasses.java
index a43aed0b9..194f8cb77 100644
--- a/src/org/apache/pig/pen/EquivalenceClasses.java
+++ b/src/org/apache/pig/pen/EquivalenceClasses.java
@@ -29,56 +29,56 @@ import java.util.Iterator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.PhysicalOperator;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.Tuple;
-import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LOCross;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
-import org.apache.pig.impl.logicalLayer.LogicalPlan;
+import org.apache.pig.newplan.logical.relational.LOForEach;
+import org.apache.pig.newplan.logical.relational.LOCross;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.newplan.Operator;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhysicalPlan;
 import org.apache.pig.impl.util.IdentityHashSet;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.relationalOperators.*;
-import org.apache.pig.impl.plan.VisitorException;
 
 
 //These methods are used to generate equivalence classes given the operator name and the output from the operator
 //For example, it gives out 2 eq. classes for filter, one that passes the filter and one that doesn't
 public class EquivalenceClasses {
     
-    public static Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> getLoToEqClassMap(PhysicalPlan plan,
-        LogicalPlan lp, Map<LogicalOperator, PhysicalOperator> logToPhyMap,
-        Map<LogicalOperator, DataBag> logToDataMap,
-        Map<LOForEach, Map<LogicalOperator, PhysicalOperator>> forEachInnerLogToPhyMap,
+    public static Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> getLoToEqClassMap(PhysicalPlan plan,
+        LogicalPlan lp, Map<Operator, PhysicalOperator> logToPhyMap,
+        Map<Operator, DataBag> logToDataMap,
+        Map<LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>> forEachInnerLogToPhyMap,
         final HashMap<PhysicalOperator, Collection<IdentityHashSet<Tuple>>> poToEqclassesMap)
-        throws VisitorException {
-        Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> ret =
-          new HashMap<LogicalOperator, Collection<IdentityHashSet<Tuple>>>();
-        List<LogicalOperator> roots = lp.getRoots();
-        HashSet<LogicalOperator> seen = new HashSet<LogicalOperator>();
-        for(LogicalOperator lo: roots) {
+    {
+        Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> ret =
+          new HashMap<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>>();
+        List<Operator> roots = lp.getSources();
+        HashSet<Operator> seen = new HashSet<Operator>();
+        for(Operator lo: roots) {
             getEqClasses(plan, lo, lp, logToPhyMap, ret, poToEqclassesMap, logToDataMap, forEachInnerLogToPhyMap, seen);
         }
         return ret;
     }
     
-    private static void getEqClasses(PhysicalPlan plan, LogicalOperator parent, LogicalPlan lp,
-        Map<LogicalOperator, PhysicalOperator> logToPhyMap, Map<LogicalOperator,
+    private static void getEqClasses(PhysicalPlan plan, Operator parent, LogicalPlan lp,
+        Map<Operator, PhysicalOperator> logToPhyMap, Map<LogicalRelationalOperator,
         Collection<IdentityHashSet<Tuple>>> result,
         final HashMap<PhysicalOperator, Collection<IdentityHashSet<Tuple>>> poToEqclassesMap,
-        Map<LogicalOperator, DataBag> logToDataMap,
-        Map<LOForEach, Map<LogicalOperator, PhysicalOperator>> forEachInnerLogToPhyMap,
-        HashSet<LogicalOperator> seen) throws VisitorException {
+        Map<Operator, DataBag> logToDataMap,
+        Map<LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>> forEachInnerLogToPhyMap,
+        HashSet<Operator> seen) {
         if (parent instanceof LOForEach) {
             if (poToEqclassesMap.get(logToPhyMap.get(parent)) != null) {
                 LinkedList<IdentityHashSet<Tuple>> eqClasses = new LinkedList<IdentityHashSet<Tuple>>();
                 eqClasses.addAll(poToEqclassesMap.get(logToPhyMap.get(parent)));
-                for (Map.Entry<LogicalOperator, PhysicalOperator> entry : forEachInnerLogToPhyMap.get(parent).entrySet()) {
+                for (Map.Entry<LogicalRelationalOperator, PhysicalOperator> entry : forEachInnerLogToPhyMap.get(parent).entrySet()) {
                     if (poToEqclassesMap.get(entry.getValue()) != null)
                         eqClasses.addAll(poToEqclassesMap.get(entry.getValue()));
                 }
-                result.put(parent, eqClasses);
+                result.put((LogicalRelationalOperator) parent, eqClasses);
             }
         } else if (parent instanceof LOCross) {
             boolean ok = true; 
-            for (LogicalOperator input : ((LOCross) parent).getInputs()) {
+            for (Operator input : ((LOCross) parent).getInputs()) {
                 if (logToDataMap.get(input).size() < 2) {
                     // only if all inputs have at least more than two tuples will all outputs be added to the eq. class
                     ok = false;
@@ -92,12 +92,12 @@ public class EquivalenceClasses {
                     eqClass.add(it.next());
                 }
                 eqClasses.add(eqClass);
-                result.put(parent, eqClasses);
+                result.put((LogicalRelationalOperator) parent, eqClasses);
             } else {
                 LinkedList<IdentityHashSet<Tuple>> eqClasses = new LinkedList<IdentityHashSet<Tuple>>();
                 IdentityHashSet<Tuple> eqClass = new IdentityHashSet<Tuple>();
                 eqClasses.add(eqClass);
-                result.put(parent, eqClasses);
+                result.put((LogicalRelationalOperator)parent, eqClasses);
             }
         } else {
             Collection<IdentityHashSet<Tuple>> eqClasses = poToEqclassesMap.get(logToPhyMap.get(parent));
@@ -108,11 +108,11 @@ public class EquivalenceClasses {
                     eqClasses.add(new IdentityHashSet<Tuple>());
                 }
             }
-            result.put(parent, eqClasses);
+            result.put((LogicalRelationalOperator)parent, eqClasses);
         }
         // result.put(parent, getEquivalenceClasses(plan, parent, lp, logToPhyMap, poToEqclassesMap));
         if (lp.getSuccessors(parent) != null) {
-            for (LogicalOperator lo : lp.getSuccessors(parent)) {
+            for (Operator lo : lp.getSuccessors(parent)) {
                 if (!seen.contains(lo)) {
                     seen.add(lo);
                     getEqClasses(plan, lo, lp, logToPhyMap, result, poToEqclassesMap, logToDataMap, forEachInnerLogToPhyMap, seen);
diff --git a/src/org/apache/pig/pen/ExampleGenerator.java b/src/org/apache/pig/pen/ExampleGenerator.java
index 04c045669..c64db63a1 100644
--- a/src/org/apache/pig/pen/ExampleGenerator.java
+++ b/src/org/apache/pig/pen/ExampleGenerator.java
@@ -41,14 +41,14 @@ import org.apache.pig.impl.PigContext;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LOLoad;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
+import org.apache.pig.newplan.logical.relational.LOForEach;
+import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.impl.logicalLayer.LogicalPlan;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
-import org.apache.pig.impl.logicalLayer.LOSort;
-import org.apache.pig.impl.logicalLayer.LOLimit;
-import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.newplan.logical.relational.LOSort;
+import org.apache.pig.newplan.logical.relational.LOLimit;
+import org.apache.pig.newplan.Operator;
 import org.apache.pig.pen.util.DisplayExamples;
 import org.apache.pig.pen.util.LineageTracer;
 
@@ -60,6 +60,7 @@ import org.apache.pig.pen.util.LineageTracer;
 public class ExampleGenerator {
 
     LogicalPlan plan;
+    org.apache.pig.newplan.logical.relational.LogicalPlan newPlan;
     Map<LOLoad, DataBag> baseData = null;
     PigContext pigContext;
 
@@ -72,16 +73,16 @@ public class ExampleGenerator {
 
     private int MAX_RECORDS = 10000;
     
-    private Map<LogicalOperator, PhysicalOperator> logToPhyMap;
-    private Map<PhysicalOperator, LogicalOperator> poLoadToLogMap;
-    private Map<PhysicalOperator, LogicalOperator> poToLogMap;
+    private Map<Operator, PhysicalOperator> logToPhyMap;
+    private Map<PhysicalOperator, Operator> poLoadToLogMap;
+    private Map<PhysicalOperator, Operator> poToLogMap;
     private HashMap<PhysicalOperator, Collection<IdentityHashSet<Tuple>>> poToEqclassesMap;
     private LineageTracer lineage;
-    private Map<LogicalOperator, DataBag> logToDataMap = null;
-    private Map<LOForEach, Map<LogicalOperator, DataBag>> forEachInnerLogToDataMap;
-    Map<LOForEach, Map<LogicalOperator, PhysicalOperator>> forEachInnerLogToPhyMap;
+    private Map<Operator, DataBag> logToDataMap = null;
+    private Map<LOForEach, Map<LogicalRelationalOperator, DataBag>> forEachInnerLogToDataMap;
+    Map<LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>> forEachInnerLogToPhyMap;
     Map<LOLimit, Long> oriLimitMap = null;
-    Map<POLoad, Schema> poLoadToSchemaMap;
+    Map<POLoad, LogicalSchema> poLoadToSchemaMap;
 
     public ExampleGenerator(LogicalPlan plan, PigContext hadoopPigContext) {
         this.plan = plan;
@@ -99,14 +100,14 @@ public class ExampleGenerator {
         }
         execEngine = new HExecutionEngine(pigContext);
         localMRRunner = new LocalMapReduceSimulator();
-        poLoadToSchemaMap = new HashMap<POLoad, Schema>();
+        poLoadToSchemaMap = new HashMap<POLoad, LogicalSchema>();
     }
 
     public LineageTracer getLineage() {
       return lineage;
     }
     
-    public Map<LogicalOperator, PhysicalOperator> getLogToPhyMap() {
+    public Map<Operator, PhysicalOperator> getLogToPhyMap() {
         return logToPhyMap;
     }
     
@@ -114,36 +115,36 @@ public class ExampleGenerator {
         MAX_RECORDS = max;
     }
 
-    public Map<LogicalOperator, DataBag> getExamples() throws IOException, InterruptedException {
+    public Map<Operator, DataBag> getExamples() throws IOException, InterruptedException {
         if (pigContext.getProperties().getProperty("pig.usenewlogicalplan", "true").equals("false"))
             throw new ExecException("ILLUSTRATE must use the new logical plan!");
         pigContext.inIllustrator = true;
         physPlan = compilePlan(plan);
         physPlanReseter = new PhysicalPlanResetter(physPlan);
-        List<LogicalOperator> loads = plan.getRoots();
+        List<Operator> loads = newPlan.getSources();
         List<PhysicalOperator> pRoots = physPlan.getRoots();
         if (loads.size() != pRoots.size())
             throw new ExecException("Logical and Physical plans have different number of roots");
         logToPhyMap = execEngine.getLogToPhyMap();
         forEachInnerLogToPhyMap = execEngine.getForEachInnerLogToPhyMap();
-        poLoadToLogMap = new HashMap<PhysicalOperator, LogicalOperator>();
-        logToDataMap = new HashMap<LogicalOperator, DataBag>();
-        poToLogMap = new HashMap<PhysicalOperator, LogicalOperator>();
+        poLoadToLogMap = new HashMap<PhysicalOperator, Operator>();
+        logToDataMap = new HashMap<Operator, DataBag>();
+        poToLogMap = new HashMap<PhysicalOperator, Operator>();
         
         // set up foreach inner data map
-        forEachInnerLogToDataMap = new HashMap<LOForEach, Map<LogicalOperator, DataBag>>();
-        for (Map.Entry<LOForEach, Map<LogicalOperator, PhysicalOperator>> entry : forEachInnerLogToPhyMap.entrySet()) {
-            Map<LogicalOperator, DataBag> innerMap = new HashMap<LogicalOperator, DataBag>();
+        forEachInnerLogToDataMap = new HashMap<LOForEach, Map<LogicalRelationalOperator, DataBag>>();
+        for (Map.Entry<LOForEach, Map<LogicalRelationalOperator, PhysicalOperator>> entry : forEachInnerLogToPhyMap.entrySet()) {
+            Map<LogicalRelationalOperator, DataBag> innerMap = new HashMap<LogicalRelationalOperator, DataBag>();
             forEachInnerLogToDataMap.put(entry.getKey(), innerMap);
         }
 
-        for (LogicalOperator load : loads)
+        for (Operator load : loads)
         {
             poLoadToLogMap.put(logToPhyMap.get(load), load);
         }
 
         boolean hasLimit = false;
-        for (LogicalOperator lo : logToPhyMap.keySet()) {
+        for (Operator lo : logToPhyMap.keySet()) {
             poToLogMap.put(logToPhyMap.get(lo), lo);
             if (!hasLimit && lo instanceof LOLimit)
                 hasLimit = true;
@@ -159,64 +160,58 @@ public class ExampleGenerator {
             throw new RuntimeException(e.getMessage());
         }
 
-        Map<LogicalOperator, DataBag> derivedData = null;
-        try {
+        Map<Operator, DataBag> derivedData = null;
 
-            // create derived data and trim base data
-            LineageTrimmingVisitor trimmer = new LineageTrimmingVisitor(plan,
-                    baseData, this, logToPhyMap, physPlan, pigContext);
-            trimmer.visit();
-            // System.out.println(
-            // "Obtained the first level derived and trimmed data");
-            // create new derived data from trimmed basedata
-            derivedData = getData(physPlan);
+        // create derived data and trim base data
+        LineageTrimmingVisitor trimmer = new LineageTrimmingVisitor(newPlan,
+                baseData, this, logToPhyMap, physPlan, pigContext);
+        trimmer.visit();
+        baseData = trimmer.getBaseData();
+        // System.out.println(
+        // "Obtained the first level derived and trimmed data");
+        // create new derived data from trimmed basedata
+        derivedData = getData(physPlan);
 
-            // System.out.println(
-            // "Got new derived data from the trimmed base data");
-            // augment base data
-            AugmentBaseDataVisitor augment = new AugmentBaseDataVisitor(plan,
-                    logToPhyMap, baseData, derivedData);
+        // System.out.println(
+        // "Got new derived data from the trimmed base data");
+        // augment base data
+        AugmentBaseDataVisitor augment = new AugmentBaseDataVisitor(newPlan,
+                logToPhyMap, baseData, derivedData);
+        augment.visit();
+        this.baseData = augment.getNewBaseData();
+        // System.out.println("Obtained augmented base data");
+        // create new derived data and trim the base data after augmenting
+        // base data with synthetic tuples
+        trimmer = new LineageTrimmingVisitor(newPlan, baseData, this,
+                logToPhyMap, physPlan, pigContext);
+        trimmer.visit();
+        baseData = trimmer.getBaseData();
+        // System.out.println("Final trimming");
+        // create the final version of derivedData to give to the output
+        derivedData = getData(physPlan);
+        // System.out.println("Obtaining final derived data for output");
+        
+        if (hasLimit)
+        {
+            augment.setLimit();
             augment.visit();
             this.baseData = augment.getNewBaseData();
-            // System.out.println("Obtained augmented base data");
-            // create new derived data and trim the base data after augmenting
-            // base data with synthetic tuples
-            trimmer = new LineageTrimmingVisitor(plan, baseData, this,
-                    logToPhyMap, physPlan, pigContext);
-            trimmer.visit();
-            // System.out.println("Final trimming");
-            // create the final version of derivedData to give to the output
-            derivedData = getData(physPlan);
-            // System.out.println("Obtaining final derived data for output");
-            
-            if (hasLimit)
-            {
-                augment.setLimit();
-                augment.visit();
-                this.baseData = augment.getNewBaseData();
-                oriLimitMap = augment.getOriLimitMap();
-                derivedData = getData();
-            }
-
-        } catch (VisitorException e) {
-            e.printStackTrace(System.out);
-            log.error("Visitor exception while creating example data "
-                    + e.getMessage());
-            throw new RuntimeException(e.getMessage());
+            oriLimitMap = augment.getOriLimitMap();
+            derivedData = getData();
         }
 
         // DisplayExamples.printSimple(plan.getLeaves().get(0),
         // derivedData.derivedData);
-        System.out.println(DisplayExamples.printTabular(plan,
+        System.out.println(DisplayExamples.printTabular(newPlan,
                 derivedData, forEachInnerLogToDataMap));
         pigContext.inIllustrator = false;
         return derivedData;
     }
 
-    private void readBaseData(List<LogicalOperator> loads) throws IOException, InterruptedException, FrontendException, ExecException {
+    private void readBaseData(List<Operator> loads) throws IOException, InterruptedException, FrontendException, ExecException {
         PhysicalPlan thisPhyPlan = new PhysicalPlan();
-        for (LogicalOperator op : loads) {
-            Schema schema = op.getSchema();
+        for (Operator op : loads) {
+            LogicalSchema schema = ((LOLoad) op).getSchema();
             if(schema == null) {
                 throw new ExecException("Example Generator requires a schema. Please provide a schema while loading data.");
             }
@@ -224,9 +219,9 @@ public class ExampleGenerator {
             thisPhyPlan.add(logToPhyMap.get(op));
         }
         baseData = null;
-        Map<LogicalOperator, DataBag> result = getData(thisPhyPlan);
+        Map<Operator, DataBag> result = getData(thisPhyPlan);
         baseData = new HashMap<LOLoad, DataBag>();
-        for (LogicalOperator lo : result.keySet()) {
+        for (Operator lo : result.keySet()) {
             if (lo instanceof LOLoad) {
                 baseData.put((LOLoad) lo, result.get(lo));
             }
@@ -234,14 +229,16 @@ public class ExampleGenerator {
     }
 
     PhysicalPlan compilePlan(LogicalPlan plan) throws ExecException, FrontendException {
-        return execEngine.compile(plan, null);
+        PhysicalPlan result = execEngine.compile(plan, null);
+        newPlan = execEngine.getNewPlan();
+        return result;
     }
     
-    public Map<LogicalOperator, DataBag> getData() throws IOException, InterruptedException {
+    public Map<Operator, DataBag> getData() throws IOException, InterruptedException {
       return getData(physPlan);
     }
     
-    private Map<LogicalOperator, DataBag> getData(PhysicalPlan plan) throws PigException, IOException, InterruptedException
+    private Map<Operator, DataBag> getData(PhysicalPlan plan) throws PigException, IOException, InterruptedException
     {
         // get data on a physical plan possibly trimmed of one branch 
         lineage = new LineageTracer();
@@ -257,7 +254,7 @@ public class ExampleGenerator {
             setLoadDataMap();
             physPlanReseter.visit();
         }
-        localMRRunner.launchPig(plan, baseData, poLoadToLogMap, lineage, attacher, this, pigContext);
+        localMRRunner.launchPig(plan, baseData, lineage, attacher, this, pigContext);
         if (baseData == null)
             poToEqclassesMap = attacher.poToEqclassesMap;
         else {
@@ -272,7 +269,7 @@ public class ExampleGenerator {
         return logToDataMap;
     }
     
-    public Map<LogicalOperator, DataBag> getData(Map<LOLoad, DataBag> newBaseData) throws Exception 
+    public Map<Operator, DataBag> getData(Map<LOLoad, DataBag> newBaseData) throws Exception 
     {
         baseData = newBaseData;
         return getData(physPlan);
@@ -281,7 +278,7 @@ public class ExampleGenerator {
     private void phyToMRTransform(PhysicalPlan plan, Map<PhysicalOperator, DataBag> phyToDataMap) {
         // remap the LO to PO as result of the MR compilation may have changed PO in the MR plans
         Map<PhysicalOperator, PhysicalOperator> phyToMRMap = localMRRunner.getPhyToMRMap();
-        for (Map.Entry<PhysicalOperator, LogicalOperator> entry : poToLogMap.entrySet()) {
+        for (Map.Entry<PhysicalOperator, Operator> entry : poToLogMap.entrySet()) {
             if (phyToMRMap.get(entry.getKey()) != null) {
                 PhysicalOperator poInMR = phyToMRMap.get(entry.getKey());
                 logToDataMap.put(entry.getValue(), phyToDataMap.get(poInMR));
@@ -292,15 +289,15 @@ public class ExampleGenerator {
     
     private void getLogToDataMap(Map<PhysicalOperator, DataBag> phyToDataMap) {
         logToDataMap.clear();
-        for (LogicalOperator lo : logToPhyMap.keySet()) {
+        for (Operator lo : logToPhyMap.keySet()) {
             if (logToPhyMap.get(lo) != null)
                 logToDataMap.put(lo, phyToDataMap.get(logToPhyMap.get(lo)));
         }
         
         // set the LO-to-Data mapping for the ForEach inner plans
-        for (Map.Entry<LOForEach, Map<LogicalOperator, DataBag>> entry : forEachInnerLogToDataMap.entrySet()) {
+        for (Map.Entry<LOForEach, Map<LogicalRelationalOperator, DataBag>> entry : forEachInnerLogToDataMap.entrySet()) {
             entry.getValue().clear();
-            for (Map.Entry<LogicalOperator, PhysicalOperator>  innerEntry : forEachInnerLogToPhyMap.get(entry.getKey()).entrySet()) {
+            for (Map.Entry<LogicalRelationalOperator, PhysicalOperator>  innerEntry : forEachInnerLogToPhyMap.get(entry.getKey()).entrySet()) {
                 entry.getValue().put(innerEntry.getKey(), phyToDataMap.get(innerEntry.getValue()));
             }
         }
@@ -328,10 +325,10 @@ public class ExampleGenerator {
         }
     }
     
-    public Collection<IdentityHashSet<Tuple>> getEqClasses() throws VisitorException {
-        Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> logToEqclassesMap = getLoToEqClassMap();
+    public Collection<IdentityHashSet<Tuple>> getEqClasses() {
+        Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> logToEqclassesMap = getLoToEqClassMap();
         LinkedList<IdentityHashSet<Tuple>> ret = new LinkedList<IdentityHashSet<Tuple>>();
-        for (Map.Entry<LogicalOperator, Collection<IdentityHashSet<Tuple>>> entry :
+        for (Map.Entry<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> entry :
             logToEqclassesMap.entrySet()) {
             if (entry.getValue() != null)
                 ret.addAll(entry.getValue());
@@ -339,12 +336,12 @@ public class ExampleGenerator {
         return ret;
     }
 
-    public Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> getLoToEqClassMap() throws VisitorException {
-        Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> ret =
-          EquivalenceClasses.getLoToEqClassMap(physPlan, plan, logToPhyMap, logToDataMap, forEachInnerLogToPhyMap, poToEqclassesMap);
+    public Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> getLoToEqClassMap() {
+        Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> ret =
+          EquivalenceClasses.getLoToEqClassMap(physPlan, newPlan, logToPhyMap, logToDataMap, forEachInnerLogToPhyMap, poToEqclassesMap);
         // eq classes adjustments based upon logical operators
         
-        for (Map.Entry<LogicalOperator, Collection<IdentityHashSet<Tuple>>> entry :ret.entrySet())
+        for (Map.Entry<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> entry :ret.entrySet())
         {
             if (entry.getKey() instanceof LOSort) {
                 Collection<IdentityHashSet<Tuple>> eqClasses = entry.getValue();
diff --git a/src/org/apache/pig/pen/Illustrator.java b/src/org/apache/pig/pen/Illustrator.java
index 5a2147825..0eeeeae80 100644
--- a/src/org/apache/pig/pen/Illustrator.java
+++ b/src/org/apache/pig/pen/Illustrator.java
@@ -29,7 +29,7 @@ import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.pen.util.LineageTracer;
 import org.apache.pig.impl.util.IdentityHashSet;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
 
 /**
  * Class used by physical operators to generate example tuples for the ILLUSTRATE
@@ -51,7 +51,7 @@ public class Illustrator {
     private Boolean[] subExpResult;
     private boolean eqClassesShared;
     private long oriLimit = -1;
-    private Schema schema;
+    private LogicalSchema schema;
 
     public Illustrator(LineageTracer lineage, LinkedList<IdentityHashSet<Tuple>> equivalenceClasses, IllustratorAttacher attacher, PigContext hadoopPigContext) {
         this.lineage = lineage;
@@ -64,7 +64,7 @@ public class Illustrator {
     }
     
     public Illustrator(LineageTracer lineage, LinkedList<IdentityHashSet<Tuple>> equivalenceClasses, int maxRecords, IllustratorAttacher attacher,
-        Schema schema, PigContext hadoopPigContext) {
+        LogicalSchema schema, PigContext hadoopPigContext) {
         this(lineage, equivalenceClasses, attacher, hadoopPigContext);
         this.maxRecords = maxRecords;
         this.schema = schema;
@@ -136,7 +136,7 @@ public class Illustrator {
         return eqClassesShared;
     }
     
-    public Schema getSchema() {
+    public LogicalSchema getSchema() {
         return schema;
     }
 }
diff --git a/src/org/apache/pig/pen/IllustratorAttacher.java b/src/org/apache/pig/pen/IllustratorAttacher.java
index 9b269f60c..cfbb57e32 100644
--- a/src/org/apache/pig/pen/IllustratorAttacher.java
+++ b/src/org/apache/pig/pen/IllustratorAttacher.java
@@ -79,7 +79,7 @@ import org.apache.pig.data.Tuple;
 import org.apache.pig.backend.hadoop.executionengine.physicalLayer.plans.PhyPlanVisitor;
 import org.apache.pig.pen.util.LineageTracer;
 import org.apache.pig.impl.plan.DepthFirstWalker;
-import org.apache.pig.impl.logicalLayer.schema.Schema;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
 
 /**
  * The class used to (re)attach illustrators to physical operators
@@ -98,10 +98,10 @@ public class IllustratorAttacher extends PhyPlanVisitor {
     private int maxRecords;
     private boolean revisit = false;
     private ArrayList<Boolean[]> subExpResults = null;
-    private final Map<POLoad, Schema> poloadToSchemaMap;
+    private final Map<POLoad, LogicalSchema> poloadToSchemaMap;
     
     public IllustratorAttacher(PhysicalPlan plan, LineageTracer lineage, int maxRecords,
-        Map<POLoad, Schema> poLoadToSchemaMap, PigContext hadoopPigContext) throws VisitorException {
+        Map<POLoad, LogicalSchema> poLoadToSchemaMap, PigContext hadoopPigContext) throws VisitorException {
         super(plan, new DepthFirstWalker<PhysicalOperator, PhysicalPlan>(plan));
         pigContext = hadoopPigContext;
         this.lineage = lineage;
diff --git a/src/org/apache/pig/pen/LineageTrimmingVisitor.java b/src/org/apache/pig/pen/LineageTrimmingVisitor.java
index 1245c7e20..917073c7b 100644
--- a/src/org/apache/pig/pen/LineageTrimmingVisitor.java
+++ b/src/org/apache/pig/pen/LineageTrimmingVisitor.java
@@ -39,22 +39,23 @@ import org.apache.pig.data.BagFactory;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.PigContext;
-import org.apache.pig.impl.logicalLayer.LOCogroup;
-import org.apache.pig.impl.logicalLayer.LOJoin;
-import org.apache.pig.impl.logicalLayer.LOCross;
-import org.apache.pig.impl.logicalLayer.LODistinct;
-import org.apache.pig.impl.logicalLayer.LOFilter;
-import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LOLimit;
-import org.apache.pig.impl.logicalLayer.LOLoad;
-import org.apache.pig.impl.logicalLayer.LOSort;
-import org.apache.pig.impl.logicalLayer.LOSplit;
-import org.apache.pig.impl.logicalLayer.LOUnion;
-import org.apache.pig.impl.logicalLayer.LOStore;
-import org.apache.pig.impl.logicalLayer.LOVisitor;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
-import org.apache.pig.impl.logicalLayer.LogicalPlan;
-import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.newplan.logical.relational.LOCogroup;
+import org.apache.pig.newplan.logical.relational.LOJoin;
+import org.apache.pig.newplan.logical.relational.LOCross;
+import org.apache.pig.newplan.logical.relational.LODistinct;
+import org.apache.pig.newplan.logical.relational.LOFilter;
+import org.apache.pig.newplan.logical.relational.LOForEach;
+import org.apache.pig.newplan.logical.relational.LOLimit;
+import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LOSort;
+import org.apache.pig.newplan.logical.relational.LOSplit;
+import org.apache.pig.newplan.logical.relational.LOUnion;
+import org.apache.pig.newplan.logical.relational.LOStore;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalNodesVisitor;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.IdentityHashSet;
 import org.apache.pig.impl.util.Pair;
 import org.apache.pig.impl.io.FileSpec;
@@ -63,18 +64,18 @@ import org.apache.pig.pen.util.MetricEvaluation;
 import org.apache.pig.pen.util.PreOrderDepthFirstWalker;
 import org.apache.pig.pen.util.ExampleTuple;
 
-public class LineageTrimmingVisitor extends LOVisitor {
+public class LineageTrimmingVisitor extends LogicalRelationalNodesVisitor {
 
     LogicalPlan plan = null;
     Map<LOLoad, DataBag> baseData;
     Map<FileSpec, DataBag> inputToDataMap;
-    Map<LogicalOperator, PhysicalOperator> LogToPhyMap = null;
+    Map<Operator, PhysicalOperator> LogToPhyMap = null;
     PhysicalPlan physPlan = null;
     double completeness = 100.0;
     Log log = LogFactory.getLog(getClass());
 
-    Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> AffinityGroups = new HashMap<LogicalOperator, Collection<IdentityHashSet<Tuple>>>();
-    Map<LogicalOperator, LineageTracer> Lineage = new HashMap<LogicalOperator, LineageTracer>();
+    Map<Operator, Collection<IdentityHashSet<Tuple>>> AffinityGroups = new HashMap<Operator, Collection<IdentityHashSet<Tuple>>>();
+    Map<Operator, LineageTracer> Lineage = new HashMap<Operator, LineageTracer>();
 
     boolean continueTrimming;
     PigContext pc;
@@ -83,10 +84,9 @@ public class LineageTrimmingVisitor extends LOVisitor {
     public LineageTrimmingVisitor(LogicalPlan plan,
             Map<LOLoad, DataBag> baseData,
             ExampleGenerator eg,
-            Map<LogicalOperator, PhysicalOperator> LogToPhyMap,
+            Map<Operator, PhysicalOperator> LogToPhyMap,
             PhysicalPlan physPlan, PigContext pc) throws IOException, InterruptedException {
-        super(plan, new PreOrderDepthFirstWalker<LogicalOperator, LogicalPlan>(
-                plan));
+        super(plan, new PreOrderDepthFirstWalker(plan));
         // this.baseData.putAll(baseData);
         this.baseData = baseData;
         this.plan = plan;
@@ -100,11 +100,11 @@ public class LineageTrimmingVisitor extends LOVisitor {
 
     public void init() throws IOException, InterruptedException {
 
-        Map<LogicalOperator, DataBag> data = eg.getData();
+        Map<Operator, DataBag> data = eg.getData();
 
         LineageTracer lineage = eg.getLineage();
-        Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> OpToEqClasses = eg.getLoToEqClassMap();
-        for (LogicalOperator leaf : plan.getLeaves()) {
+        Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> OpToEqClasses = eg.getLoToEqClassMap();
+        for (Operator leaf : plan.getSinks()) {
             Lineage.put(leaf, lineage);
             AffinityGroups.put(leaf, eg.getEqClasses());
         }
@@ -116,7 +116,7 @@ public class LineageTrimmingVisitor extends LOVisitor {
     }
 
     @Override
-    protected void visit(LOCogroup cg) throws VisitorException {
+    public void visit(LOCogroup cg) throws FrontendException {
         // can't separate CoGroup from succeeding ForEach
         if (plan.getSuccessors(cg) != null && plan.getSuccessors(cg).get(0) instanceof LOForEach)
             return;
@@ -128,91 +128,91 @@ public class LineageTrimmingVisitor extends LOVisitor {
                 
                 LineageTracer lineage = null;
                 // create affinity groups
-                if (cg.getInputs().size() == 1) {
+                if (cg.getInputs(plan).size() == 1) {
                     lineage = eg.getLineage();
-                    AffinityGroups.put(cg.getInputs().get(0), eg.getEqClasses());
-                    Lineage.put(cg.getInputs().get(0), lineage);
+                    AffinityGroups.put(cg.getInputs(plan).get(0), eg.getEqClasses());
+                    Lineage.put(cg.getInputs(plan).get(0), lineage);
 
                 } else {
-                    for (LogicalOperator input : cg.getInputs()) {
+                    for (Operator input : cg.getInputs(plan)) {
                         Lineage.put(input, eg.getLineage());
                         AffinityGroups.put(input, eg.getEqClasses());
                     }
                 }
             } catch (Exception e) {
-                throw new VisitorException("Exception : "+e.getMessage());
+                throw new FrontendException("Exception : "+e.getMessage());
             }
         }
     }
 
     @Override
-    protected void visit(LOJoin join) throws VisitorException {
+    public void visit(LOJoin join) throws FrontendException {
         if (continueTrimming) {
           processOperator(join);
         }
     }
 
     @Override
-    protected void visit(LOCross cs) throws VisitorException {
+    public void visit(LOCross cs) throws FrontendException {
         if(continueTrimming)
             processOperator(cs);
 
     }
 
     @Override
-    protected void visit(LODistinct dt) throws VisitorException {
+    public void visit(LODistinct dt) throws FrontendException {
         if(continueTrimming)
             processOperator(dt);
 
     }
 
     @Override
-    protected void visit(LOFilter filter) throws VisitorException {
+    public void visit(LOFilter filter) throws FrontendException {
         if (continueTrimming)
             processOperator(filter);
     }
     
     @Override
-    protected void visit(LOStore store) throws VisitorException {
+    public void visit(LOStore store) throws FrontendException {
         if (continueTrimming)
             processOperator(store);
     }
 
     @Override
-    protected void visit(LOForEach forEach) throws VisitorException {
+    public void visit(LOForEach forEach) throws FrontendException {
         if (continueTrimming)
             processOperator(forEach);
     }
 
     @Override
-    protected void visit(LOLimit limOp) throws VisitorException {
+    public void visit(LOLimit limOp) throws FrontendException {
         if(continueTrimming)
             processOperator(limOp);
 
     }
 
     @Override
-    protected void visit(LOLoad load) throws VisitorException {
+    public void visit(LOLoad load) throws FrontendException {
         if (continueTrimming)
             processOperator(load);
     }
 
     @Override
-    protected void visit(LOSort s) throws VisitorException {
+    public void visit(LOSort s) throws FrontendException {
         if(continueTrimming)
             processOperator(s);
 
     }
 
     @Override
-    protected void visit(LOSplit split) throws VisitorException {
+    public void visit(LOSplit split) throws FrontendException {
         if(continueTrimming)
             processOperator(split);
 
     }
 
     @Override
-    protected void visit(LOUnion u) throws VisitorException {
+    public void visit(LOUnion u) throws FrontendException {
         if(continueTrimming)
             processOperator(u);
 
@@ -322,6 +322,7 @@ public class LineageTrimmingVisitor extends LOVisitor {
             for (Tuple t : members)
                 tuplesToRetain.add(t);
         }
+
         Map<LOLoad, DataBag> newBaseData = new HashMap<LOLoad, DataBag>();
         for (LOLoad loadOp : baseData.keySet()) {
             DataBag data = baseData.get(loadOp);
@@ -338,10 +339,10 @@ public class LineageTrimmingVisitor extends LOVisitor {
         return newBaseData;
     }
 
-    private void processLoad(LOLoad ld) throws VisitorException {
+    private void processLoad(LOLoad ld) throws FrontendException {
         // prune base records
-        if (inputToDataMap.get(ld.getInputFile()) != null) {
-            baseData.put(ld, inputToDataMap.get(ld.getInputFile()));
+        if (inputToDataMap.get(ld.getFileSpec()) != null) {
+            baseData.put(ld, inputToDataMap.get(ld.getFileSpec()));
             return;
         }
         
@@ -363,7 +364,7 @@ public class LineageTrimmingVisitor extends LOVisitor {
         newBaseData.put(ld, newData);
         for (Map.Entry<LOLoad, DataBag> entry : baseData.entrySet()) {
             if (entry.getKey() != ld) {
-                if (!entry.getKey().getInputFile().equals(ld.getInputFile()))
+                if (!entry.getKey().getFileSpec().equals(ld.getFileSpec()))
                     newBaseData.put(entry.getKey(), entry.getValue());
                 else
                     newBaseData.put(entry.getKey(), newData);
@@ -373,10 +374,10 @@ public class LineageTrimmingVisitor extends LOVisitor {
         if (checkNewBaseData(newData, newBaseData, realData))
             checkNewBaseData(newData, newBaseData, syntheticData);
         
-        inputToDataMap.put(ld.getInputFile(), baseData.get(ld));
+        inputToDataMap.put(ld.getFileSpec(), baseData.get(ld));
     }
     
-    private boolean checkNewBaseData(DataBag data, Map<LOLoad, DataBag> newBaseData, Set<Tuple> loadData) throws VisitorException {
+    private boolean checkNewBaseData(DataBag data, Map<LOLoad, DataBag> newBaseData, Set<Tuple> loadData) throws FrontendException {
         List<Pair<Tuple, Double>> sortedBase = new LinkedList<Pair<Tuple, Double>>();
         DataBag oldData = BagFactory.getInstance().newDefaultBag();
         oldData.addAll(data);
@@ -384,11 +385,11 @@ public class LineageTrimmingVisitor extends LOVisitor {
         for (Tuple t : loadData) {
             data.add(t);
             // obtain the derived data 
-            Map<LogicalOperator, DataBag> derivedData;
+            Map<Operator, DataBag> derivedData;
             try {
                 derivedData = eg.getData(newBaseData);
             } catch (Exception e) {
-                throw new VisitorException("Exception: "+e.getMessage());
+                throw new FrontendException("Exception: "+e.getMessage());
             }
             double newCompleteness = MetricEvaluation.getCompleteness(null,
                     derivedData, eg.getLoToEqClassMap(), true);
@@ -412,11 +413,11 @@ public class LineageTrimmingVisitor extends LOVisitor {
         for (Pair<Tuple, Double> p : sortedBase) {
             data.add(p.first);
             // obtain the derived data 
-            Map<LogicalOperator, DataBag> derivedData;
+            Map<Operator, DataBag> derivedData;
             try {
                 derivedData = eg.getData(newBaseData);
             } catch (Exception e) {
-                throw new VisitorException("Exception: "+e.getMessage());
+                throw new FrontendException("Exception: "+e.getMessage());
             }
             double newCompleteness = MetricEvaluation.getCompleteness(null,
                     derivedData, eg.getLoToEqClassMap(), true);
@@ -430,7 +431,7 @@ public class LineageTrimmingVisitor extends LOVisitor {
         return true;
     }
     
-    private void processOperator(LogicalOperator op) throws VisitorException {
+    private void processOperator(LogicalRelationalOperator op) throws FrontendException {
         
         try {
             if (op instanceof LOLoad) {
@@ -446,28 +447,28 @@ public class LineageTrimmingVisitor extends LOVisitor {
             if (continueTrimming == false)
                 return;
 
-            LogicalOperator childOp = plan.getPredecessors(op).get(0);
+            Operator childOp = plan.getPredecessors(op).get(0);
             if (op instanceof LOForEach && childOp instanceof LOCogroup)
             {
                 LOCogroup cg = (LOCogroup) childOp;
-                for (LogicalOperator input : cg.getInputs()) {
+                for (Operator input : cg.getInputs(plan)) {
                     AffinityGroups.put(input, eg.getEqClasses());
                     Lineage.put(input, eg.getLineage());
                 }
             } else {
-                List<LogicalOperator> childOps = plan.getPredecessors(op);
-                for (LogicalOperator lo : childOps) {
+                List<Operator> childOps = plan.getPredecessors(op);
+                for (Operator lo : childOps) {
                     AffinityGroups.put(lo, eg.getEqClasses());
                     Lineage.put(lo, eg.getLineage());
                 }
             }
         } catch (Exception e) {
           e.printStackTrace(System.out);
-          throw new VisitorException("Exception: "+e.getMessage());
+          throw new FrontendException("Exception: "+e.getMessage());
         }
     }
 
-    private boolean checkCompleteness(LogicalOperator op) throws Exception, VisitorException {
+    private boolean checkCompleteness(LogicalRelationalOperator op) throws Exception {
         LineageTracer lineage = Lineage.get(op);
         Lineage.remove(op);
 
@@ -479,7 +480,7 @@ public class LineageTrimmingVisitor extends LOVisitor {
                 baseData, lineage, affinityGroups);
 
         // obtain the derived data
-        Map<LogicalOperator, DataBag> derivedData = eg.getData(newBaseData);
+        Map<Operator, DataBag> derivedData = eg.getData(newBaseData);
         double newCompleteness = MetricEvaluation.getCompleteness(null,
                 derivedData, eg.getLoToEqClassMap(), true);
 
@@ -492,4 +493,8 @@ public class LineageTrimmingVisitor extends LOVisitor {
 
         return continueTrimming;
     }
+    
+    Map<LOLoad, DataBag> getBaseData() {
+        return baseData;
+    }
 }
diff --git a/src/org/apache/pig/pen/LocalMapReduceSimulator.java b/src/org/apache/pig/pen/LocalMapReduceSimulator.java
index d432918dd..b1c23defa 100644
--- a/src/org/apache/pig/pen/LocalMapReduceSimulator.java
+++ b/src/org/apache/pig/pen/LocalMapReduceSimulator.java
@@ -56,8 +56,8 @@ import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileLocalizer;
 import org.apache.pig.impl.io.NullableTuple;
 import org.apache.pig.impl.io.PigNullableWritable;
-import org.apache.pig.impl.logicalLayer.LOLoad;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
+import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.impl.plan.DepthFirstWalker;
 import org.apache.pig.impl.plan.OperatorKey;
 import org.apache.pig.impl.plan.VisitorException;
@@ -82,7 +82,6 @@ public class LocalMapReduceSimulator {
 
     @SuppressWarnings("unchecked")
     public void launchPig(PhysicalPlan php, Map<LOLoad, DataBag> baseData,
-                              Map<PhysicalOperator, LogicalOperator> poLoadToLogMap,
                               LineageTracer lineage,
                               IllustratorAttacher attacher,
                               ExampleGenerator eg,
@@ -158,7 +157,7 @@ public class LocalMapReduceSimulator {
                 for (POLoad ld : lds) {
                     input = output.get(ld.getLFile().getFileName());
                     if (input == null && baseData != null) {
-                        for (LogicalOperator lo : baseData.keySet()) {
+                        for (LogicalRelationalOperator lo : baseData.keySet()) {
                             if (((LOLoad) lo).getSchemaFile().equals(ld.getLFile().getFileName()))
                             {
                                  input = baseData.get(lo);
@@ -174,7 +173,7 @@ public class LocalMapReduceSimulator {
                     input = output.get(ld.getLFile().getFileName());
                     if (input == null && baseData != null) {
                         if (input == null && baseData != null) {
-                            for (LogicalOperator lo : baseData.keySet()) {
+                            for (LogicalRelationalOperator lo : baseData.keySet()) {
                                 if (((LOLoad) lo).getSchemaFile().equals(ld.getLFile().getFileName()))
                                 {
                                      input = baseData.get(lo);
@@ -224,7 +223,9 @@ public class LocalMapReduceSimulator {
                         context = reduce.getIllustratorContext(job, intermediateData, (POPackage) pack);
                     reduce.run(context);
                 }
-                phyToMRMap.putAll(mro.phyToMRMap);
+                for (PhysicalOperator key : mro.phyToMRMap.keySet())
+                    for (PhysicalOperator value : mro.phyToMRMap.get(key))
+                        phyToMRMap.put(key, value);
             }
             
             
diff --git a/src/org/apache/pig/pen/util/DisplayExamples.java b/src/org/apache/pig/pen/util/DisplayExamples.java
index 6e3e9f78a..265f8f762 100644
--- a/src/org/apache/pig/pen/util/DisplayExamples.java
+++ b/src/org/apache/pig/pen/util/DisplayExamples.java
@@ -29,12 +29,14 @@ import org.apache.pig.data.DataBag;
 import org.apache.pig.data.DataType;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.logicalLayer.LOForEach;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
-import org.apache.pig.impl.logicalLayer.LOStore;
-import org.apache.pig.impl.logicalLayer.LOLimit;
-import org.apache.pig.impl.logicalLayer.LogicalPlan;
-import org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;
+import org.apache.pig.newplan.logical.relational.LOForEach;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
+import org.apache.pig.newplan.logical.relational.LOStore;
+import org.apache.pig.newplan.logical.relational.LOLoad;
+import org.apache.pig.newplan.logical.relational.LOLimit;
+import org.apache.pig.newplan.logical.relational.LogicalPlan;
+import org.apache.pig.newplan.logical.relational.LogicalSchema;
+import org.apache.pig.newplan.Operator;
 import org.apache.pig.impl.util.IdentityHashSet;
 
 //Class containing some generic printing methods to print example data in a simple/tabular form
@@ -44,9 +46,9 @@ public class DisplayExamples {
     public static final int MAX_DATAATOM_LENGTH = 25;
 
     static void printMetrics(
-            LogicalOperator op,
-            Map<LogicalOperator, DataBag> derivedData,
-            Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses) {
+            Operator op,
+            Map<Operator, DataBag> derivedData,
+            Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses) {
         /*
          * System.out.println("Realness : " + Metrics.getRealness(op,
          * derivedData, true)); System.out.println("Completeness : " +
@@ -67,26 +69,34 @@ public class DisplayExamples {
     }
 
     public static String printTabular(LogicalPlan lp,
-            Map<LogicalOperator, DataBag> exampleData,
-            Map<LOForEach, Map<LogicalOperator, DataBag>> forEachInnerLogToDataMap) {
+            Map<Operator, DataBag> exampleData,
+            Map<LOForEach, Map<LogicalRelationalOperator, DataBag>> forEachInnerLogToDataMap) throws FrontendException {
         StringBuffer output = new StringBuffer();
-        Set<LogicalOperator> seen = new HashSet<LogicalOperator>();
-        for (LogicalOperator currentOp : lp.getLeaves())
-            printTabular(currentOp, exampleData, forEachInnerLogToDataMap, seen, output);
+        Set<Operator> seen = new HashSet<Operator>();
+        for (Operator currentOp : lp.getSinks()) {
+            if (currentOp instanceof LOStore && ((LOStore) currentOp).isTmpStore())
+            {
+                // display the branches of the temporary store first
+                printTabular(currentOp, lp, exampleData, forEachInnerLogToDataMap, seen, output);
+            }
+        }
+        for (Operator currentOp : lp.getSinks())
+            printTabular(currentOp, lp, exampleData, forEachInnerLogToDataMap, seen, output);
         return output.toString();
     }
 
-    static void printTabular(LogicalOperator op,
-            Map<LogicalOperator, DataBag> exampleData,
-            Map<LOForEach, Map<LogicalOperator, DataBag>> forEachInnerLogToDataMap,
-            Set<LogicalOperator> seen,
+    static void printTabular(Operator op,
+            LogicalPlan lp,
+            Map<Operator, DataBag> exampleData,
+            Map<LOForEach, Map<LogicalRelationalOperator, DataBag>> forEachInnerLogToDataMap,
+            Set<Operator> seen,
             StringBuffer output) {
 
-        List<LogicalOperator> inputs = op.getPlan().getPredecessors(op);
+        List<Operator> inputs = lp.getPredecessors(op);
         if (inputs != null) { // to avoid an exception when op == LOLoad
-            for (LogicalOperator Op : inputs) {
+            for (Operator Op : inputs) {
                 if (!seen.contains(Op))
-                  printTabular(Op, exampleData, forEachInnerLogToDataMap, seen, output);
+                  printTabular(Op, lp, exampleData, forEachInnerLogToDataMap, seen, output);
             }
         }
         seen.add(op);
@@ -95,8 +105,13 @@ public class DisplayExamples {
             printNestedTabular((LOForEach)op, forEachInnerLogToDataMap, exampleData.get(op), output);
         }
         
-        if (op.getAlias() != null) {
+        if (((LogicalRelationalOperator)op).getAlias() != null) {
             DataBag bag = exampleData.get(op);
+            if (op instanceof LOLoad && ((LOLoad)op).isCastInserted())
+            {
+                op = op.getPlan().getSuccessors(op).get(0);
+                bag = exampleData.get(op);
+            }
             try {
                 DisplayTable(MakeArray(op, bag), op, bag, output);
             } catch (FrontendException e) {
@@ -112,31 +127,29 @@ public class DisplayExamples {
 
     // print out nested gen block in ForEach
     static void printNestedTabular(LOForEach foreach,
-            Map<LOForEach, Map<LogicalOperator, DataBag>> forEachInnerLogToDataMap,
+            Map<LOForEach, Map<LogicalRelationalOperator, DataBag>> forEachInnerLogToDataMap,
             DataBag foreachData,
             StringBuffer output) {
-        List<LogicalPlan> plans = foreach.getForEachPlans();
-        if (plans != null) {
-            for (LogicalPlan plan : plans) {
-                printNestedTabular(plan.getLeaves().get(0), foreach.getAlias(), foreachData, forEachInnerLogToDataMap.get(foreach), output);
-            }
+        LogicalPlan plan = foreach.getInnerPlan();
+        if (plan != null) {
+            printNestedTabular(plan.getSinks().get(0), plan, foreach.getAlias(), foreachData, forEachInnerLogToDataMap.get(foreach), output);
         }
     }
 
-    static void printNestedTabular(LogicalOperator lo, String foreachAlias, DataBag foreachData, 
-            Map<LogicalOperator, DataBag> logToDataMap, StringBuffer output) {
+    static void printNestedTabular(Operator lo, LogicalPlan lp, String foreachAlias, DataBag foreachData, 
+            Map<LogicalRelationalOperator, DataBag> logToDataMap, StringBuffer output) {
         
-        List<LogicalOperator> inputs = lo.getPlan().getPredecessors(lo);
+        List<Operator> inputs = lp.getPredecessors(lo);
         if (inputs != null) {
-            for (LogicalOperator op : inputs)
-                printNestedTabular(op, foreachAlias, foreachData, logToDataMap, output);
+            for (Operator op : inputs)
+                printNestedTabular(op, lp, foreachAlias, foreachData, logToDataMap, output);
         }
         
         DataBag bag = logToDataMap.get(lo);
         if (bag == null)
           return;
         
-        if (lo.getAlias() != null) {
+        if (((LogicalRelationalOperator)lo).getAlias() != null) {
             try {
               DisplayNestedTable(MakeArray(lo, bag), lo, foreachAlias, foreachData, bag, output);
             } catch (FrontendException e) {
@@ -149,20 +162,20 @@ public class DisplayExamples {
         }
     }
     
-    public static void printSimple(LogicalOperator op,
-            Map<LogicalOperator, DataBag> exampleData) {
+    public static void printSimple(Operator op, LogicalPlan lp,
+            Map<Operator, DataBag> exampleData) {
         DataBag bag = exampleData.get(op);
 
-        List<LogicalOperator> inputs = op.getPlan().getPredecessors(op);
+        List<Operator> inputs = lp.getPredecessors(op);
         if (inputs != null) {
-            for (LogicalOperator lOp : inputs) {
-                printSimple(lOp, exampleData);
+            for (Operator lOp : inputs) {
+                printSimple(lOp, lp, exampleData);
             }
         }
-        if (op.getAlias() != null) {
+        if (((LogicalRelationalOperator)op).getAlias() != null) {
             // printTable(op, bag, output);
             // DisplayTable(MakeArray(op, bag), op, bag, output);
-            System.out.println(op.getAlias() + " : " + bag);
+            System.out.println(((LogicalRelationalOperator)op).getAlias() + " : " + bag);
         }
         // System.out.println(op.getAlias() + " : " + bag);
     }
@@ -178,13 +191,13 @@ public class DisplayExamples {
         return str.toString();
     }
 
-    static void DisplayTable(String[][] table, LogicalOperator op, DataBag bag,
+    static void DisplayTable(String[][] table, Operator op, DataBag bag,
             StringBuffer output) throws FrontendException {
         if (op instanceof LOStore && ((LOStore) op).isTmpStore())
             return;
         
-        int cols = op.getSchema().getFields().size();
-        List<FieldSchema> fields = op.getSchema().getFields();
+        int cols = ((LogicalRelationalOperator)op).getSchema().getFields().size();
+        List<LogicalSchema.LogicalFieldSchema> fields = ((LogicalRelationalOperator)op).getSchema().getFields();
         int rows = (int) bag.size();
         int[] maxColSizes = new int[cols];
         for (int i = 0; i < cols; ++i) {
@@ -193,7 +206,8 @@ public class DisplayExamples {
                 maxColSizes[i] = 5;
         }
         int total = 0;
-        int aliasLength = (op instanceof LOStore ? op.getAlias().length() + 12 : op.getAlias().length() + 4);
+        final String alias = ((LogicalRelationalOperator)op).getAlias();
+        int aliasLength = (op instanceof LOStore ? alias.length() + 12 : alias.length() + 4);
         for (int j = 0; j < cols; ++j) {
             for (int i = 0; i < rows; ++i) {
                 int length = table[i][j].length();
@@ -214,11 +228,11 @@ public class DisplayExamples {
                         false)
                         + "\n");
         if (op instanceof LOStore)
-            output.append("| Store : " + op.getAlias() + AddSpaces(4, true) + " | ");
+            output.append("| Store : " + alias + AddSpaces(4, true) + " | ");
         else
-            output.append("| " + op.getAlias() + AddSpaces(4, true) + " | ");
+            output.append("| " + alias + AddSpaces(4, true) + " | ");
         for (int i = 0; i < cols; ++i) {
-            String field = fields.get(i).toString();
+            String field = fields.get(i).toString(false);
             output.append(field
                     + AddSpaces(maxColSizes[i] - field.length(), true) + " | ");
         }
@@ -243,10 +257,11 @@ public class DisplayExamples {
                         + "\n");
     }
 
-    static void DisplayNestedTable(String[][] table, LogicalOperator op, String foreachAlias, DataBag bag,
+    static void DisplayNestedTable(String[][] table, Operator op, String foreachAlias, DataBag bag,
             DataBag foreachData, StringBuffer output) throws FrontendException {
-        int cols = op.getSchema().getFields().size();
-        List<FieldSchema> fields = op.getSchema().getFields();
+        LogicalRelationalOperator lop = (LogicalRelationalOperator) op;
+        int cols = lop.getSchema().getFields().size();
+        List<LogicalSchema.LogicalFieldSchema> fields = lop.getSchema().getFields();
         int rows = (int) bag.size();
         int[] maxColSizes = new int[cols];
         for (int i = 0; i < cols; ++i) {
@@ -255,7 +270,8 @@ public class DisplayExamples {
                 maxColSizes[i] = 5;
         }
         int total = 0;
-        int aliasLength = op.getAlias().length() + +foreachAlias.length() + 5;
+        final String alias = ((LogicalRelationalOperator)op).getAlias();
+        int aliasLength = alias.length() + +foreachAlias.length() + 5;
         for (int j = 0; j < cols; ++j) {
             for (int i = 0; i < rows; ++i) {
                 int length = table[i][j].length();
@@ -270,10 +286,10 @@ public class DisplayExamples {
                 .append(AddSpaces(total + 3 * (cols + 1) + aliasLength + 1,
                         false)
                         + "\n");
-        output.append("| " + foreachAlias + "." + op.getAlias() + AddSpaces(4, true) + " | ");
+        output.append("| " + foreachAlias + "." + alias + AddSpaces(4, true) + " | ");
         for (int i = 0; i < cols; ++i) {
             String field;
-            field = fields.get(i).toString();
+            field = fields.get(i).toString(false);
             output.append(field
                     + AddSpaces(maxColSizes[i] - field.length(), true) + " | ");
         }
@@ -298,10 +314,10 @@ public class DisplayExamples {
                         + "\n");
     }
 
-    static String[][] MakeArray(LogicalOperator op, DataBag bag)
+    static String[][] MakeArray(Operator op, DataBag bag)
             throws Exception {
         int rows = (int) bag.size();
-        int cols = op.getSchema().getFields().size();
+        int cols = ((LogicalRelationalOperator)op).getSchema().getFields().size();
         String[][] table = new String[rows][cols];
         Iterator<Tuple> it = bag.iterator();
         for (int i = 0; i < rows; ++i) {
diff --git a/src/org/apache/pig/pen/util/MetricEvaluation.java b/src/org/apache/pig/pen/util/MetricEvaluation.java
index 201d85768..d445602c4 100644
--- a/src/org/apache/pig/pen/util/MetricEvaluation.java
+++ b/src/org/apache/pig/pen/util/MetricEvaluation.java
@@ -24,19 +24,20 @@ import java.util.Map;
 
 import org.apache.pig.data.DataBag;
 import org.apache.pig.data.Tuple;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.impl.util.IdentityHashSet;
 
 //Evaluates various metrics
 public class MetricEvaluation {
-    public static float getRealness(LogicalOperator op,
-            Map<LogicalOperator, DataBag> exampleData, boolean overallRealness) {
+    public static float getRealness(Operator op,
+            Map<Operator, DataBag> exampleData, boolean overallRealness) {
         // StringBuffer str = new StringBuffer();
         int noTuples = 0;
         int noSynthetic = 0;
-        for (Map.Entry<LogicalOperator, DataBag> e : exampleData.entrySet()) {
+        for (Map.Entry<Operator, DataBag> e : exampleData.entrySet()) {
             // if(e.getKey() instanceof LORead) continue;
-            if (e.getKey().getAlias() == null)
+            if (((LogicalRelationalOperator)e.getKey()).getAlias() == null)
                 continue;
             DataBag bag;
             if (overallRealness) {
@@ -65,9 +66,9 @@ public class MetricEvaluation {
     }
 
     public static float getConciseness(
-            LogicalOperator op,
-            Map<LogicalOperator, DataBag> exampleData,
-            Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses,
+            Operator op,
+            Map<Operator, DataBag> exampleData,
+            Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses,
             boolean overallConciseness) {
         DataBag bag = exampleData.get(op);
 
@@ -85,7 +86,7 @@ public class MetricEvaluation {
             conciseness = 0;
             int noOperators = 0;
 
-            for (Map.Entry<LogicalOperator, Collection<IdentityHashSet<Tuple>>> e : OperatorToEqClasses
+            for (Map.Entry<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> e : OperatorToEqClasses
                     .entrySet()) {
                 if (e.getKey().getAlias() == null)
                     continue;
@@ -108,9 +109,9 @@ public class MetricEvaluation {
     }
 
     public static float getCompleteness(
-            LogicalOperator op,
-            Map<LogicalOperator, DataBag> exampleData,
-            Map<LogicalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses,
+            Operator op,
+            Map<Operator, DataBag> exampleData,
+            Map<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> OperatorToEqClasses,
             boolean overallCompleteness) {
 
         int noClasses = 0;
@@ -126,7 +127,7 @@ public class MetricEvaluation {
 
             return 100 * ((float) noCoveredClasses) / (float) noClasses;
         } else {
-            for (Map.Entry<LogicalOperator, Collection<IdentityHashSet<Tuple>>> e : OperatorToEqClasses
+            for (Map.Entry<LogicalRelationalOperator, Collection<IdentityHashSet<Tuple>>> e : OperatorToEqClasses
                     .entrySet()) {
                 noCoveredClasses = 0;
                 noClasses = 0;
diff --git a/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java b/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java
index 708e53e40..b30c1ab78 100644
--- a/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java
+++ b/src/org/apache/pig/pen/util/PreOrderDepthFirstWalker.java
@@ -23,16 +23,15 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import org.apache.pig.impl.plan.DepthFirstWalker;
-import org.apache.pig.impl.plan.Operator;
-import org.apache.pig.impl.plan.OperatorPlan;
-import org.apache.pig.impl.plan.PlanVisitor;
-import org.apache.pig.impl.plan.PlanWalker;
-import org.apache.pig.impl.plan.VisitorException;
+import org.apache.pig.newplan.DepthFirstWalker;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.PlanVisitor;
+import org.apache.pig.newplan.PlanWalker;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.util.Utils;
 
-public class PreOrderDepthFirstWalker<O extends Operator, P extends OperatorPlan<O>>
-        extends PlanWalker<O, P> {
+public class PreOrderDepthFirstWalker extends PlanWalker {
   
     private boolean branchFlag = false;
     
@@ -40,7 +39,7 @@ public class PreOrderDepthFirstWalker<O extends Operator, P extends OperatorPlan
      * @param plan
      *            Plan for this walker to traverse.
      */
-    public PreOrderDepthFirstWalker(P plan) {
+    public PreOrderDepthFirstWalker(OperatorPlan plan) {
         super(plan);
     }
 
@@ -60,29 +59,28 @@ public class PreOrderDepthFirstWalker<O extends Operator, P extends OperatorPlan
      * @throws VisitorException
      *             if an error is encountered while walking.
      */
-    public void walk(PlanVisitor<O, P> visitor) throws VisitorException {
-        List<O> leaves = mPlan.getLeaves();
-        Set<O> seen = new HashSet<O>();
+    public void walk(PlanVisitor visitor) throws FrontendException {
+        List<Operator> leaves = plan.getSinks();
+        Set<Operator> seen = new HashSet<Operator>();
 
         depthFirst(null, leaves, seen, visitor);
     }
 
-    public PlanWalker<O, P> spawnChildWalker(P plan) {
-        return new DepthFirstWalker<O, P>(plan);
+    public PlanWalker spawnChildWalker(OperatorPlan plan) {
+        return new DepthFirstWalker(plan);
     }
 
-    @SuppressWarnings("unchecked")
-    private void depthFirst(O node, Collection<O> predecessors, Set<O> seen,
-            PlanVisitor<O, P> visitor) throws VisitorException {
+    private void depthFirst(Operator node, Collection<Operator> predecessors, Set<Operator> seen,
+            PlanVisitor visitor) throws FrontendException {
         if (predecessors == null)
             return;
 
         boolean thisBranchFlag = branchFlag;
-        for (O pred : predecessors) {
+        for (Operator pred : predecessors) {
             if (seen.add(pred)) {
                 branchFlag = thisBranchFlag;
-                pred.visit(visitor);
-                Collection<O> newPredecessors = Utils.mergeCollection(mPlan.getPredecessors(pred), mPlan.getSoftLinkPredecessors(pred));
+                pred.accept(visitor);
+                Collection<Operator> newPredecessors = Utils.mergeCollection(plan.getPredecessors(pred), plan.getSoftLinkPredecessors(pred));
                 depthFirst(pred, newPredecessors, seen, visitor);
             }
         }
diff --git a/test/org/apache/pig/test/TestExampleGenerator.java b/test/org/apache/pig/test/TestExampleGenerator.java
index 0902c2828..c42f90d34 100644
--- a/test/org/apache/pig/test/TestExampleGenerator.java
+++ b/test/org/apache/pig/test/TestExampleGenerator.java
@@ -32,7 +32,7 @@ import org.apache.pig.backend.executionengine.ExecException;
 import org.apache.pig.data.DataBag;
 import org.apache.pig.impl.PigContext;
 import org.apache.pig.impl.io.FileLocalizer;
-import org.apache.pig.impl.logicalLayer.LogicalOperator;
+import org.apache.pig.newplan.Operator;
 import org.junit.AfterClass;
 import org.junit.Before;
 import org.junit.Test;
@@ -105,7 +105,7 @@ public class TestExampleGenerator extends TestCase {
         String query = "A = load " + A
                 + " using PigStorage() as (x : int, y : int);\n";
         pigserver.registerQuery(query);
-        Map<LogicalOperator, DataBag> derivedData = pigserver.getExamples("A");
+        Map<Operator, DataBag> derivedData = pigserver.getExamples("A");
 
         assertTrue(derivedData != null);
 
@@ -121,7 +121,7 @@ public class TestExampleGenerator extends TestCase {
         pigserver.registerQuery(query);
         query = "B = filter A by x > 10;";
         pigserver.registerQuery(query);
-        Map<LogicalOperator, DataBag> derivedData = pigserver.getExamples("B");
+        Map<Operator, DataBag> derivedData = pigserver.getExamples("B");
 
         assertTrue(derivedData != null);
 
@@ -137,7 +137,7 @@ public class TestExampleGenerator extends TestCase {
         pigserver.registerQuery(query);
         query = "B = filter A by x > 5 AND y < 6;";
         pigserver.registerQuery(query);
-        Map<LogicalOperator, DataBag> derivedData = pigserver.getExamples("B");
+        Map<Operator, DataBag> derivedData = pigserver.getExamples("B");
 
         assertTrue(derivedData != null);
     }
@@ -158,7 +158,7 @@ public class TestExampleGenerator extends TestCase {
         pigserver.registerQuery(query);
         query = "E = DISTINCT D;";
         pigserver.registerQuery(query);
-        Map<LogicalOperator, DataBag> derivedData = pigserver.getExamples("E");
+        Map<Operator, DataBag> derivedData = pigserver.getExamples("E");
 
         assertTrue(derivedData != null);
 
@@ -172,7 +172,7 @@ public class TestExampleGenerator extends TestCase {
                 + " using PigStorage() as (x : int, y : int);");
         pigServer.registerQuery("B = foreach A generate x + y as sum;");
 
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("B");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("B");
 
         assertTrue(derivedData != null);
     }
@@ -185,7 +185,7 @@ public class TestExampleGenerator extends TestCase {
 
         pigServer.registerQuery("E = join A1 by x, B1 by x;");
 
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("E");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("E");
 
         assertTrue(derivedData != null);
     }
@@ -198,7 +198,7 @@ public class TestExampleGenerator extends TestCase {
 
         pigServer.registerQuery("E = join A1 by x, B1 by x;");
 
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("E");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("E");
 
         assertTrue(derivedData != null);
     }
@@ -210,7 +210,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A + " as (x, y);");
         pigServer.registerQuery("B = load " + B + " as (x, y);");
         pigServer.registerQuery("C = cogroup A by (x, y), B by (x, y);");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
     }
@@ -221,7 +221,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A + " as (x, y);");
         pigServer.registerQuery("B = load " + B + " as (x, y);");
         pigServer.registerQuery("C = cogroup A by x, B by x;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
     }
@@ -231,7 +231,7 @@ public class TestExampleGenerator extends TestCase {
         PigServer pigServer = new PigServer(pigContext);
         pigServer.registerQuery("A = load " + A.toString() + " as (x, y);");
         pigServer.registerQuery("B = group A by x;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("B");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("B");
 
         assertTrue(derivedData != null);
 
@@ -243,7 +243,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A.toString() + " as (x:int, y:int);");
         pigServer.registerQuery("B = group A by x;");
         pigServer.registerQuery("C = foreach B generate group, COUNT(A);};");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
 
@@ -256,7 +256,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("B = FILTER A by x  > 3;");
         pigServer.registerQuery("C = group B by y;");
         pigServer.registerQuery("D = foreach C generate group, COUNT(B);};");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("D");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("D");
 
         assertTrue(derivedData != null);
 
@@ -269,7 +269,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("B = FILTER A by x  > 3;");
         pigServer.registerQuery("C = FILTER A by x < 3;");
         pigServer.registerQuery("D = UNION B, C;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("D");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("D");
 
         assertTrue(derivedData != null);
 
@@ -281,7 +281,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A.toString() + " as (x:int, y:int);");
         pigServer.registerQuery("B = group A by x;");
         pigServer.registerQuery("C = foreach B { FA = filter A by y == 6; generate group, COUNT(FA);};");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
 
@@ -293,7 +293,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A.toString() + " as (x:int, y:int);");
         pigServer.registerQuery("B = group A by x;");
         pigServer.registerQuery("C = foreach B { FA = filter A by y == 6; DA = DISTINCT FA; generate group, COUNT(DA);};");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
 
@@ -305,7 +305,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A.toString() + " as (x, y);");
         pigServer.registerQuery("B = load " + B.toString() + " as (x, y);");
         pigServer.registerQuery("C = union A, B;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
     }
@@ -315,7 +315,7 @@ public class TestExampleGenerator extends TestCase {
         PigServer pigServer = new PigServer(pigContext);
         pigServer.registerQuery("A = load " + A.toString() + " as (x, y);");
         pigServer.registerQuery("B = DISTINCT A;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("B");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("B");
 
         assertTrue(derivedData != null);
     }
@@ -326,7 +326,7 @@ public class TestExampleGenerator extends TestCase {
         pigServer.registerQuery("A = load " + A.toString() + " as (x, y);");
         pigServer.registerQuery("B = load " + B.toString() + " as (x, y);");
         pigServer.registerQuery("C = CROSS A, B;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("C");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("C");
 
         assertTrue(derivedData != null);
     }
@@ -336,7 +336,7 @@ public class TestExampleGenerator extends TestCase {
         PigServer pigServer = new PigServer(pigContext);
         pigServer.registerQuery("A = load " + A.toString() + " as (x, y);");
         pigServer.registerQuery("B = limit A 5;");
-        Map<LogicalOperator, DataBag> derivedData = pigServer.getExamples("B");
+        Map<Operator, DataBag> derivedData = pigServer.getExamples("B");
 
         assertTrue(derivedData != null);
     }
diff --git a/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld b/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld
index e1914e080..56a4d2115 100644
--- a/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld
+++ b/test/org/apache/pig/test/data/GoldenFiles/MRC18.gld
@@ -18,4 +18,4 @@ Reduce Plan Empty
     |   |   |
     |   |   Project[tuple][*] - scope-126
     |   |
-    |   |---b: Load(/tmp/input2:org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MergeJoinIndexer('org.apache.pig.builtin.PigStorage','kmonaaafhdhcaabdgkgbhggbcohfhegjgmcoebhchcgbhjemgjhdhehiibncbnjjmhgbjnadaaabejaaaehdgjhkgfhihaaaaaaaabhhaeaaaaaaabhdhcaaeogphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccohagmgbgohdcofagihjhdgjgdgbgmfagmgbgoaaaaaaaaaaaaaaabacaaabfkaaangfgogeepggebgmgmejgohahfhehihcaacfgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcfagmgbgoeaondlnechegpmlgacaaaiemaaakgneghcgpgnefgeghgfhdheaacdemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphfhegjgmcpenhfgmhegjengbhadlemaaafgnelgfhjhdheaaapemgkgbhggbcphfhegjgmcpengbhadlemaaahgnemgfgbhggfhdheaabaemgkgbhggbcphfhegjgmcpemgjhdhedlemaaaegnephahdhbaahoaaafemaaaggnfcgpgphehdhbaahoaaagemaaaognfdgpggheeghcgpgnefgeghgfhdhbaahoaaaeemaaamgnfdgpgghefegpefgeghgfhdhbaahoaaaeemaaaignfegpefgeghgfhdhbaahoaaaehihahdhcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohfhegjgmcoenhfgmhegjengbhaaaaaaaaaaaaaaaacacaaabemaaaegnengbhahbaahoaaafhihahdhcaabbgkgbhggbcohfhegjgmcoeigbhdgiengbhaafahnkmbmdbgganbadaaacegaaakgmgpgbgeeggbgdhegphcejaaajhegihcgfhdgigpgmgehihadpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhdhcaacegphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcelgfhjaaaaaaaaaaaaaaabacaaacekaaacgjgeemaaafhdgdgphagfheaabcemgkgbhggbcpgmgbgoghcpfdhehcgjgoghdlhihaaaaaaaaaaaaaaahhheaaafhdgdgphagfhdhcaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdheaaaaaaaaaaaaaaabacaaaffkaaakgphggfhcgmgpgbgegfgefkaabfhahcgpgdgfhdhdgjgoghecgbghepggfehfhagmgfhdfkaabehcgfhdhfgmhefdgjgoghgmgffehfhagmgfecgbghfkaaaehdhegbhcemaaahgdgpgmhfgngohdheaabfemgkgbhggbcphfhegjgmcpebhchcgbhjemgjhdhedlhihcaagcgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcoefhihahcgfhdhdgjgpgoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaadgmgpghheaacaemgphcghcpgbhagbgdgigfcpgdgpgngngpgohdcpgmgpghghgjgoghcpemgpghdlhihcaaemgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofagihjhdgjgdgbgmephagfhcgbhegphcaaaaaaaaaaaaaaabacaaamfkaaafgbgdgdhfgnfkaaangjgohahfheebhehegbgdgigfgeejaabehcgfhbhfgfhdhegfgefagbhcgbgmgmgfgmgjhdgnecaaakhcgfhdhfgmhefehjhagfemaaafgbgmgjgbhdhbaahoaaaoemaaafgjgohahfheheaablemgphcghcpgbhagbgdgigfcphagjghcpgegbhegbcpfehfhagmgfdlemaaaggjgohahfhehdhbaahoaaagemaaangmgjgogfgbghgffehcgbgdgfhcheaachemgphcghcpgbhagbgdgigfcphagjghcphagfgocphfhegjgmcpemgjgogfgbghgffehcgbgdgfhcdlemaaadgmgpghhbaahoaabeemaaahgphfhehahfhehdhbaahoaaagemaaakhagbhcgfgohefagmgbgoheaafaemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccphagmgbgohdcpfagihjhdgjgdgbgmfagmgbgodlemaaadhcgfhdheaaeeemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccpfcgfhdhfgmhedlhihcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaaegnelgfhjheaacgemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphagmgbgocpephagfhcgbhegphcelgfhjdlhihahbaahoaaapaaaappppppppdchahahahahdhcaaclgphcghcogbhagbgdgigfcogdgpgngngpgohdcogmgpghghgjgoghcogjgnhagmcoemgpghdeekemgpghghgfhccikmpnoicknfncdiacaaabemaaaegogbgngfhbaahoaaaohihaheaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdhehahahdhcaaecgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofcgfhdhfgmheaaaaaaaaaaaaaaabacaaacecaaamhcgfhehfhcgofdhegbhehfhdemaaaghcgfhdhfgmheheaabcemgkgbhggbcpgmgbgoghcpepgcgkgfgdhedlhihaachahbaahoaaboaaaaaaaahdhbaahoaaaaaaaaaaabhhaeaaaaaaabhdhcaabbgkgbhggbcogmgbgoghcoejgohegfghgfhcbcockakephibihdiacaaabejaaafhggbgmhfgfhihcaabagkgbhggbcogmgbgoghcoeohfgngcgfhcigkmjfbnaljeoailacaaaahihaaaaaaaaahihihdhbaahoaaaaaaaaaaabhhaeaaaaaaakhbaahoaabmhihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhbaahoaabmhbaahoaaaphihdhbaahoaaaaaaaaaaaahhaeaaaaaaakhihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahiaahi','','b','scope','true')) - scope-117
\ No newline at end of file
+    |   |---b: Load(/tmp/input2:org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MergeJoinIndexer('org.apache.pig.builtin.PigStorage','kmonaaafhdhcaabdgkgbhggbcohfhegjgmcoebhchcgbhjemgjhdhehiibncbnjjmhgbjnadaaabejaaaehdgjhkgfhihaaaaaaaabhhaeaaaaaaabhdhcaaeogphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccohagmgbgohdcofagihjhdgjgdgbgmfagmgbgoaaaaaaaaaaaaaaabacaaacfkaaangfgogeepggebgmgmejgohahfheemaaafgphagngbhaheaacdemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphfhegjgmcpenhfgmhegjengbhadlhihcaacfgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcfagmgbgoeaondlnechegpmlgacaaaiemaaakgneghcgpgnefgeghgfhdhbaahoaaademaaafgnelgfhjhdheaaapemgkgbhggbcphfhegjgmcpengbhadlemaaahgnemgfgbhggfhdheaabaemgkgbhggbcphfhegjgmcpemgjhdhedlemaaaegnephahdhbaahoaaafemaaaggnfcgpgphehdhbaahoaaagemaaaognfdgpggheeghcgpgnefgeghgfhdhbaahoaaademaaamgnfdgpgghefegpefgeghgfhdhbaahoaaademaaaignfegpefgeghgfhdhbaahoaaadhihahdhcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohfhegjgmcoenhfgmhegjengbhaaaaaaaaaaaaaaaacacaaabemaaaegnengbhahbaahoaaafhihahdhcaabbgkgbhggbcohfhegjgmcoeigbhdgiengbhaafahnkmbmdbgganbadaaacegaaakgmgpgbgeeggbgdhegphcejaaajhegihcgfhdgigpgmgehihadpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhdhcaacegphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcelgfhjaaaaaaaaaaaaaaabacaaacekaaacgjgeemaaafhdgdgphagfheaabcemgkgbhggbcpgmgbgoghcpfdhehcgjgoghdlhihaaaaaaaaaaaaaaahhheaaafhdgdgphagfhdhcaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdheaaaaaaaaaaaaaaabacaaaffkaaakgphggfhcgmgpgbgegfgefkaabfhahcgpgdgfhdhdgjgoghecgbghepggfehfhagmgfhdfkaabehcgfhdhfgmhefdgjgoghgmgffehfhagmgfecgbghfkaaaehdhegbhcemaaahgdgpgmhfgngohdheaabfemgkgbhggbcphfhegjgmcpebhchcgbhjemgjhdhedlhihcaagcgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcoefhihahcgfhdhdgjgpgoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaadgmgpghheaacaemgphcghcpgbhagbgdgigfcpgdgpgngngpgohdcpgmgpghghgjgoghcpemgpghdlhihcaaemgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofagihjhdgjgdgbgmephagfhcgbhegphcaaaaaaaaaaaaaaabacaaamfkaaafgbgdgdhfgnfkaaangjgohahfheebhehegbgdgigfgeejaabehcgfhbhfgfhdhegfgefagbhcgbgmgmgfgmgjhdgnecaaakhcgfhdhfgmhefehjhagfemaaafgbgmgjgbhdhbaahoaaaoemaaafgjgohahfheheaablemgphcghcpgbhagbgdgigfcphagjghcpgegbhegbcpfehfhagmgfdlemaaaggjgohahfhehdhbaahoaaagemaaangmgjgogfgbghgffehcgbgdgfhcheaachemgphcghcpgbhagbgdgigfcphagjghcphagfgocphfhegjgmcpemgjgogfgbghgffehcgbgdgfhcdlemaaadgmgpghhbaahoaabeemaaahgphfhehahfhehdhbaahoaaagemaaakhagbhcgfgohefagmgbgoheaafaemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccphagmgbgohdcpfagihjhdgjgdgbgmfagmgbgodlemaaadhcgfhdheaaeeemgphcghcpgbhagbgdgigfcphagjghcpgcgbgdglgfgogecpgigbgegpgphacpgfhigfgdhfhegjgpgogfgoghgjgogfcphagihjhdgjgdgbgmemgbhjgfhccpfcgfhdhfgmhedlhihcaacbgphcghcogbhagbgdgigfcohagjghcogjgnhagmcohagmgbgocoephagfhcgbhegphcaaaaaaaaaaaaaaabacaaabemaaaegnelgfhjheaacgemgphcghcpgbhagbgdgigfcphagjghcpgjgnhagmcphagmgbgocpephagfhcgbhegphcelgfhjdlhihahbaahoaaapaaaappppppppdchahahahahdhcaaclgphcghcogbhagbgdgigfcogdgpgngngpgohdcogmgpghghgjgoghcogjgnhagmcoemgpghdeekemgpghghgfhccikmpnoicknfncdiacaaabemaaaegogbgngfhbaahoaaaohihaheaafjgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccogfhihahcgfhdhdgjgpgoephagfhcgbhegphchdcofaepfahcgpgkgfgdhehahahdhcaaecgphcghcogbhagbgdgigfcohagjghcogcgbgdglgfgogecogigbgegpgphacogfhigfgdhfhegjgpgogfgoghgjgogfcohagihjhdgjgdgbgmemgbhjgfhccofcgfhdhfgmheaaaaaaaaaaaaaaabacaaacecaaamhcgfhehfhcgofdhegbhehfhdemaaaghcgfhdhfgmheheaabcemgkgbhggbcpgmgbgoghcpepgcgkgfgdhedlhihaachahbaahoaaboaaaaaaaahdhbaahoaaaaaaaaaaabhhaeaaaaaaabhdhcaabbgkgbhggbcogmgbgoghcoejgohegfghgfhcbcockakephibihdiacaaabejaaafhggbgmhfgfhihcaabagkgbhggbcogmgbgoghcoeohfgngcgfhcigkmjfbnaljeoailacaaaahihaaaaaaaaahihihdhbaahoaaaaaaaaaaabhhaeaaaaaaakhbaahoaabmhihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaabhbaahoaabmhbaahoaaaphihdhbaahoaaaaaaaaaaaahhaeaaaaaaakhihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahihdhbaahoaaaihdhbaahoaaakdpeaaaaaaaaaaaamhhaiaaaaaabaaaaaaaaahiaahahi','','b','scope','true')) - scope-117
