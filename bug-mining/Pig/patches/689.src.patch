diff --git a/CHANGES.txt b/CHANGES.txt
index 93f216bad..f952f2865 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -151,6 +151,8 @@ PIG-1696: Performance: Use System.arraycopy() instead of manually copying the by
 
 BUG FIXES
 
+PIG-1871: Dont throw exception if partition filters cannot be pushed up. (rding)
+
 PIG-1870: HBaseStorage doesn't project correctly (dvryaboy)
 
 PIG-1788: relation-as-scalar error messages should indicate the field 
diff --git a/src/org/apache/pig/newplan/PColFilterExtractor.java b/src/org/apache/pig/newplan/PColFilterExtractor.java
index f0b2cd746..7e8c1ec32 100644
--- a/src/org/apache/pig/newplan/PColFilterExtractor.java
+++ b/src/org/apache/pig/newplan/PColFilterExtractor.java
@@ -22,6 +22,8 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
 import org.apache.pig.Expression;
 import org.apache.pig.PigException;
 import org.apache.pig.impl.logicalLayer.FrontendException;
@@ -62,6 +64,9 @@ import org.apache.pig.newplan.DepthFirstWalker;
  *
  */
 public class PColFilterExtractor extends PlanVisitor {
+    
+    private static final Log LOG = LogFactory.getLog(PColFilterExtractor.class);
+    
 	/**
 	 * partition columns associated with the table
 	 * present in the load on which the filter whose
@@ -88,7 +93,9 @@ public class PColFilterExtractor extends PlanVisitor {
 	private Side replaceSide = Side.NONE;
 
 	private boolean filterRemovable = false;
-
+	
+    private boolean canPushDown = true;
+	
 	@Override
 	public void visit() throws FrontendException {
 		// we will visit the leaf and it will recursively walk the plan
@@ -136,52 +143,60 @@ public class PColFilterExtractor extends PlanVisitor {
 			// so the following cases should throw error until that changes.
 			List<Class<?>> opsToCheckFor = new ArrayList<Class<?>>();
 			opsToCheckFor.add(RegexExpression.class);
-			int errCode = 1110;
 			if(checkSuccessors(project, opsToCheckFor)) {
-				throw new FrontendException("Unsupported query: " +
-						"You have an partition column (" 
-						+ fieldName + ") inside a regexp operator in the " +
-						"filter condition.", errCode, PigException.INPUT);
+            LOG.warn("No partition filter push down: " +
+                "You have an partition column (" 
+                + fieldName + ") inside a regexp operator in the " +
+                "filter condition.");
+            canPushDown = false;
+            return;
 			} 
 			opsToCheckFor.set(0, UserFuncExpression.class);
 			if(checkSuccessors(project, opsToCheckFor)) {
-				throw new FrontendException("Unsupported query: " +
-						"You have an partition column (" 
-						+ fieldName + ") inside a function in the " +
-						"filter condition.", errCode, PigException.INPUT);
+            LOG.warn("No partition filter push down: " +
+                "You have an partition column (" 
+                + fieldName + ") inside a function in the " +
+                "filter condition.");
+            canPushDown = false;
+            return;
 			}
 			opsToCheckFor.set(0, CastExpression.class);
 			if(checkSuccessors(project, opsToCheckFor)) {
-				throw new FrontendException("Unsupported query: " +
-						"You have an partition column (" 
-						+ fieldName + ") inside a cast in the " +
-						"filter condition.", errCode, PigException.INPUT);
+            LOG.warn("No partition filter push down: " +
+                "You have an partition column (" 
+                + fieldName + ") inside a cast in the " +
+                "filter condition.");
+            canPushDown = false;
+            return;
 			}
-
 			opsToCheckFor.set(0, IsNullExpression.class);
 			if(checkSuccessors(project, opsToCheckFor)) {
-				throw new FrontendException("Unsupported query: " +
-						"You have an partition column (" 
-						+ fieldName + ") inside a null check operator in the " +
-						"filter condition.", errCode, PigException.INPUT);
+            LOG.warn("No partition filter push down: " +
+                "You have an partition column (" 
+                + fieldName + ") inside a null check operator in the " +
+                "filter condition.");
+            canPushDown = false;
+            return;
 			}
 			opsToCheckFor.set(0, BinCondExpression.class);
 			if(checkSuccessors(project, opsToCheckFor)) {
-				throw new FrontendException("Unsupported query: " +
-						"You have an partition column (" 
-						+ fieldName + ") inside a bincond operator in the " +
-						"filter condition.", errCode, PigException.INPUT);
+            LOG.warn("No partition filter push down: " +
+                "You have an partition column (" 
+                + fieldName + ") inside a bincond operator in the " +
+                "filter condition.");
+            canPushDown = false;
+            return;
 			}
 			opsToCheckFor.set(0, AndExpression.class);
 			opsToCheckFor.add(OrExpression.class);
 			if(checkSuccessors(project, opsToCheckFor)) {
-				errCode = 1112;
-				throw new FrontendException("Unsupported query: " +
-						"You have an partition column (" + fieldName +
-						" ) in a construction like: " +
-						"(pcond  and ...) or (pcond and ...) " +
-						"where pcond is a condition on a partition column.",
-						errCode, PigException.INPUT);
+            LOG.warn("No partition filter push down: " +
+                "You have an partition column (" + fieldName +
+                " ) in a construction like: " +
+                "(pcond  and ...) or (pcond and ...) " +
+                "where pcond is a condition on a partition column.");
+            canPushDown = false;
+            return;
 			}
 		} else {
 			sawNonKeyCol = true;
@@ -222,11 +237,11 @@ public class PColFilterExtractor extends PlanVisitor {
 				replaceSide = Side.RIGHT;
 			}
 		} else if(lhsSawKey && rhsSawNonKeyCol || rhsSawKey && lhsSawNonKeyCol){
-			int errCode = 1111;
-			String errMsg = "Use of partition column/condition with" +
-			" non partition column/condition in filter expression is not " +
-			"supported." ;
-			throw new FrontendException(errMsg, errCode, PigException.INPUT);
+        LOG.warn("No partition filter push down: " +
+            "Use of partition column/condition with" +
+            " non partition column/condition in filter expression is not " +
+            "supported.");
+        canPushDown = false;
 		}
 
 		sawKey = lhsSawKey || rhsSawKey;
@@ -239,8 +254,8 @@ public class PColFilterExtractor extends PlanVisitor {
 	 * @return the condition on partition columns extracted from filter
 	 */
 	public  Expression getPColCondition(){
-		if(pColConditions.size() == 0)
-			return null;
+    if(!canPushDown || pColConditions.size() == 0)
+        return null;
 		Expression cond =  pColConditions.get(0);
 		for(int i=1; i<pColConditions.size(); i++){
 			//if there is more than one condition expression
@@ -255,7 +270,7 @@ public class PColFilterExtractor extends PlanVisitor {
 	 * @return the filterRemovable
 	 */
 	public boolean isFilterRemovable() {
-		return filterRemovable;
+    return canPushDown && filterRemovable;
 	}
 
 	//////// helper methods /////////////////////////
@@ -299,7 +314,7 @@ public class PColFilterExtractor extends PlanVisitor {
 				}
 			}
 		} else {
-			throwException();
+		    logInternalErrorAndSetFlag();
 		}
 		return false; // more checking can be done
 	}
@@ -325,7 +340,8 @@ public class PColFilterExtractor extends PlanVisitor {
 		// Rt
 
 		if( !( childExpr instanceof BinaryExpression ) ) {
-			throwException();
+		     logInternalErrorAndSetFlag();
+	         return;
 		}
 		// child's lhs operand
 		LogicalExpression leftChild = 
@@ -346,7 +362,8 @@ public class PColFilterExtractor extends PlanVisitor {
 			remove(rightChild);
 			replace(childExpr, leftChild);
 		}else {
-			throwException();
+		     logInternalErrorAndSetFlag();
+	         return;
 		}
 		//reset 
 		replaceSide = Side.NONE;
@@ -403,7 +420,7 @@ public class PColFilterExtractor extends PlanVisitor {
 		plan.remove( op );
 	}
 
-	public static Expression getExpression(LogicalExpression op) throws FrontendException
+	public Expression getExpression(LogicalExpression op) throws FrontendException
 	 {
 		if(op instanceof ConstantExpression) {
 			ConstantExpression constExpr =(ConstantExpression)op ;
@@ -414,7 +431,8 @@ public class PColFilterExtractor extends PlanVisitor {
             return new Expression.Column(fieldName);
         } else {
 			if( !( op instanceof BinaryExpression ) ) {
-				throwException();
+            logInternalErrorAndSetFlag();
+            return null;
 			}
 			BinaryExpression binOp = (BinaryExpression)op;
 			if(binOp instanceof AddExpression) {
@@ -444,26 +462,24 @@ public class PColFilterExtractor extends PlanVisitor {
 			} else if(binOp instanceof LessThanEqualExpression) {
 				return getExpression(binOp, OpType.OP_LE);
 			} else {
-				throwException();
+            logInternalErrorAndSetFlag();
 			}
 		}
 		return null;
 	}
 
-    private static Expression getExpression(BinaryExpression binOp, OpType 
+    private Expression getExpression(BinaryExpression binOp, OpType 
             opType) throws FrontendException {
         return new Expression.BinaryExpression(getExpression(binOp.getLhs())
                 ,getExpression(binOp.getRhs()), opType);
     }
-	private static void throwException() throws FrontendException {
-		int errCode = 2209;
-		throw new FrontendException(
-				"Internal error while processing any partition filter " +
-				"conditions in the filter after the load" ,
-				errCode,
-				PigException.BUG
-		);
-	}
+    
+    private void logInternalErrorAndSetFlag() throws FrontendException {
+        LOG.warn("No partition filter push down: "
+                + "Internal error while processing any partition filter "
+                + "conditions in the filter after the load");
+        canPushDown = false;
+    }
 
 	// this might get called from some visit() - in that case, delegate to
 	// the other visit()s which we have defined here 
@@ -517,4 +533,8 @@ public class PColFilterExtractor extends PlanVisitor {
 		visit(isNull.getExpression());
 	}
 
+    public boolean canPushDown() {
+        return canPushDown;
+    }
+
 }
diff --git a/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java b/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
index 819b5724f..898f59e57 100644
--- a/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
+++ b/src/org/apache/pig/newplan/logical/rules/PartitionFilterOptimizer.java
@@ -30,19 +30,19 @@ import org.apache.pig.LoadFunc;
 import org.apache.pig.LoadMetadata;
 import org.apache.pig.Expression.BinaryExpression;
 import org.apache.pig.Expression.Column;
+import org.apache.pig.impl.logicalLayer.FrontendException;
+import org.apache.pig.newplan.Operator;
+import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.OperatorSubPlan;
+import org.apache.pig.newplan.PColFilterExtractor;
+import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
 import org.apache.pig.newplan.logical.relational.LOFilter;
 import org.apache.pig.newplan.logical.relational.LOLoad;
 import org.apache.pig.newplan.logical.relational.LogicalPlan;
 import org.apache.pig.newplan.logical.relational.LogicalRelationalOperator;
 import org.apache.pig.newplan.logical.relational.LogicalSchema;
-import org.apache.pig.newplan.Operator;
-import org.apache.pig.newplan.OperatorPlan;
-import org.apache.pig.newplan.OperatorSubPlan;
-import org.apache.pig.newplan.PColFilterExtractor;
 import org.apache.pig.newplan.optimizer.Rule;
 import org.apache.pig.newplan.optimizer.Transformer;
-import org.apache.pig.impl.logicalLayer.FrontendException;
-import org.apache.pig.impl.util.Pair;
 
 public class PartitionFilterOptimizer extends Rule {
     private String[] partitionKeys;
@@ -147,10 +147,19 @@ public class PartitionFilterOptimizer extends Rule {
         	subPlan = new OperatorSubPlan( currentPlan );
 
         	setupColNameMaps();
+        	
+        	// PIG-1871: Don't throw exception if partition filters cannot be pushed up. 
+        	// Perform transformation on a copy of the filter plan, and replace the 
+        	// original filter plan only if the transformation is successful 
+        	// (i.e. partition filter can be pushed down) 
+        	LogicalExpressionPlan filterExpr = loFilter.getFilterPlan();
+        	LogicalExpressionPlan filterExprCopy = filterExpr.deepCopy();
+        	
         	PColFilterExtractor pColFilterFinder = new PColFilterExtractor(
-        			loFilter.getFilterPlan(), getMappedKeys( partitionKeys ) );
+        	        filterExprCopy, getMappedKeys( partitionKeys ) );
         	pColFilterFinder.visit();
         	Expression partitionFilter = pColFilterFinder.getPColCondition();
+        	
         	if(partitionFilter != null) {
         		// the column names in the filter may be the ones provided by
         		// the user in the schema in the load statement - we may need
@@ -164,6 +173,8 @@ public class PartitionFilterOptimizer extends Rule {
 				}
         		if(pColFilterFinder.isFilterRemovable()) {  
         			currentPlan.removeAndReconnect( loFilter );
+        		} else {
+        		    loFilter.setFilterPlan(filterExprCopy);
         		}
         	}
         }
diff --git a/test/org/apache/pig/test/TestPartitionFilterPushDown.java b/test/org/apache/pig/test/TestPartitionFilterPushDown.java
index 2a3841ffa..328b8a5a4 100644
--- a/test/org/apache/pig/test/TestPartitionFilterPushDown.java
+++ b/test/org/apache/pig/test/TestPartitionFilterPushDown.java
@@ -41,6 +41,7 @@ import org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;
 import org.apache.pig.data.Tuple;
 import org.apache.pig.newplan.logical.LogicalPlanMigrationVistor;
 import org.apache.pig.newplan.logical.expression.LogicalExpression;
+import org.apache.pig.newplan.logical.expression.LogicalExpressionPlan;
 import org.apache.pig.newplan.logical.optimizer.LogicalPlanOptimizer;
 import org.apache.pig.newplan.logical.relational.LOFilter;
 import org.apache.pig.newplan.logical.relational.LOLoad;
@@ -49,15 +50,20 @@ import org.apache.pig.newplan.logical.rules.PartitionFilterOptimizer;
 import org.apache.pig.newplan.logical.rules.LoadTypeCastInserter;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
+import org.apache.pig.newplan.OperatorSubPlan;
 import org.apache.pig.newplan.PColFilterExtractor;
 import org.apache.pig.newplan.optimizer.PlanOptimizer;
+import org.apache.pig.newplan.optimizer.PlanTransformListener;
 import org.apache.pig.newplan.optimizer.Rule;
+import org.apache.pig.newplan.optimizer.Transformer;
 import org.apache.pig.impl.PigContext;
+import org.apache.pig.impl.logicalLayer.FrontendException;
 import org.apache.pig.impl.logicalLayer.PlanSetter;
 import org.apache.pig.impl.logicalLayer.parser.ParseException;
 import org.apache.pig.impl.logicalLayer.schema.Schema;
 import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.impl.util.LogUtils;
+import org.apache.pig.test.TestPartitionFilterOptimization.TestLoader;
 import org.apache.pig.test.utils.LogicalPlanTester;
 import org.junit.AfterClass;
 import org.junit.Assert;
@@ -244,6 +250,60 @@ public class TestPartitionFilterPushDown {
                 "((dstid == 30) and ((srcid == 10) or (mrkt == 'us')))", 
                 "(name == 'foo')");
     }
+    
+    @Test
+    public void test7() throws Exception {
+        LogicalPlanTester tester = new LogicalPlanTester(pc);
+        tester.buildPlan("a = load 'foo' using " + TestLoader.class.getName()
+                + "('srcid, mrkt, dstid, name, age', 'srcid, name');");
+        org.apache.pig.impl.logicalLayer.LogicalPlan lp = tester
+                .buildPlan("b = filter a by "
+                        + "(srcid < 20 and age < 30) or (name == 'foo' and age > 40);");
+        LogicalPlan plan = migratePlan(lp);
+        
+        Rule rule = new PartitionFilterOptimizer("test");
+        List<OperatorPlan> matches = rule.match(plan);
+        if (matches != null) {
+            Transformer transformer = rule.getNewTransformer();
+            for (OperatorPlan m : matches) {
+                if (transformer.check(m)) {
+                    transformer.transform(m);
+                }
+            }
+            OperatorSubPlan newPlan = (OperatorSubPlan)transformer.reportChanges();
+ 
+            Assert.assertTrue(newPlan.getBasePlan().isEqual(plan));
+        }
+  
+    }
+    
+    @Test
+    public void test8() throws Exception {
+        LogicalPlanTester tester = new LogicalPlanTester(pc);
+        tester.buildPlan("a = load 'foo' using " + TestLoader.class.getName()
+                + "('srcid, mrkt, dstid, name, age', 'srcid,name');");
+        org.apache.pig.impl.logicalLayer.LogicalPlan lp = tester
+                .buildPlan("b = filter a by "
+                        + "(srcid < 20) or (name == 'foo');");
+        LogicalPlan plan = migratePlan(lp);
+        
+        Rule rule = new PartitionFilterOptimizer("test");
+        List<OperatorPlan> matches = rule.match(plan);
+        if (matches != null) {
+            Transformer transformer = rule.getNewTransformer();
+            for (OperatorPlan m : matches) {
+                if (transformer.check(m)) {
+                    transformer.transform(m);
+                }
+            }
+            OperatorSubPlan newPlan = (OperatorSubPlan)transformer.reportChanges();
+
+            Assert.assertTrue(newPlan.getBasePlan().size() == 1);
+        }
+  
+    }
+    
+    
     /**
      * test case where filter has both conditions on partition cols and non
      * partition cols and the filter condition will be split to extract the
@@ -266,50 +326,85 @@ public class TestPartitionFilterPushDown {
         // same condition should fail
     	org.apache.pig.impl.logicalLayer.LogicalPlan lp = lpTester.buildPlan("b = filter a by " +
                     "srcid > age;");
-        negativeTest(lp, Arrays.asList("srcid"), 1111);
+        negativeTest(lp, Arrays.asList("srcid"));
         lp =  lpTester.buildPlan("b = filter a by " +
                     "srcid + age == 20;");
-        negativeTest(lp, Arrays.asList("srcid"), 1111);
+        negativeTest(lp, Arrays.asList("srcid"));
 
         // OR of partition column condition and non partiton col condition 
         // should fail
         lp = lpTester.buildPlan("b = filter a by " +
                     "srcid > 10 or name == 'foo';");
-        negativeTest(lp, Arrays.asList("srcid"), 1111);
+        negativeTest(lp, Arrays.asList("srcid"));
     }
     
     @Test
     public void testNegPColInWrongPlaces() throws Exception {
-        
-        int expectedErrCode = 1112;
+
         org.apache.pig.impl.logicalLayer.LogicalPlan lp = lpTester.buildPlan("b = filter a by " +
         "(srcid > 10 and name == 'foo') or dstid == 10;");
-        negativeTest(lp, Arrays.asList("srcid", "dstid"), expectedErrCode); 
-        
-        expectedErrCode = 1110;
+        negativeTest(lp, Arrays.asList("srcid", "dstid")); 
+
         lp = lpTester.buildPlan("b = filter a by " +
                 "CONCAT(mrkt, '_10') == 'US_10' and age == 20;");
-        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"), expectedErrCode);
+        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"));
         
         lp = lpTester.buildPlan("b = filter a by " +
                 "mrkt matches '.*us.*' and age < 15;");
-        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"), expectedErrCode);
+        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"));
         
         lp = lpTester.buildPlan("b = filter a by " +
                 "(int)mrkt == 10 and name matches '.*foo.*';");
-        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"),expectedErrCode);
+        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"));
         
         lp = lpTester.buildPlan("b = filter a by " +
             "(mrkt == 'us' ? age : age + 10) == 40 and name matches '.*foo.*';");
-        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"), expectedErrCode);
+        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"));
         
         lp = lpTester.buildPlan("b = filter a by " +
             "(mrkt is null) and name matches '.*foo.*';");
-        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"), expectedErrCode);
+        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"));
         
         lp = lpTester.buildPlan("b = filter a by " +
             "(mrkt is not null) and name matches '.*foo.*';");
-        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"), expectedErrCode);
+        negativeTest(lp, Arrays.asList("srcid", "dstid", "mrkt"));
+    }
+    
+    @Test
+    public void testNegPColInWrongPlaces2() throws Exception {
+        
+        LogicalPlanTester tester = new LogicalPlanTester(pc);
+        tester.buildPlan("a = load 'foo' using " + TestLoader.class.getName()
+                + "('srcid, mrkt, dstid, name, age', 'srcid,dstid,mrkt');");
+        
+        org.apache.pig.impl.logicalLayer.LogicalPlan lp = tester
+                .buildPlan("b = filter a by "
+                        + "(srcid > 10 and name == 'foo') or dstid == 10;");
+        negativeTest(lp); 
+        
+        lp = tester.buildPlan("b = filter a by " +
+                "CONCAT(mrkt, '_10') == 'US_10' and age == 20;");
+        negativeTest(lp);
+        
+        lp = tester.buildPlan("b = filter a by " +
+                "mrkt matches '.*us.*' and age < 15;");
+        negativeTest(lp);
+        
+        lp = tester.buildPlan("b = filter a by " +
+                "(int)mrkt == 10 and name matches '.*foo.*';");
+        negativeTest(lp);
+        
+        lp = tester.buildPlan("b = filter a by " +
+            "(mrkt == 'us' ? age : age + 10) == 40 and name matches '.*foo.*';");
+        negativeTest(lp);
+        
+        lp = tester.buildPlan("b = filter a by " +
+            "(mrkt is null) and name matches '.*foo.*';");
+        negativeTest(lp);
+        
+        lp = tester.buildPlan("b = filter a by " +
+            "(mrkt is not null) and name matches '.*foo.*';");
+        negativeTest(lp);
     }
     
     
@@ -335,7 +430,10 @@ public class TestPartitionFilterPushDown {
                     "((mrkt == 'us') and (srcid == 10))",
                     TestLoader.partFilter.toString());
         LOFilter filter = (LOFilter)newLogicalPlan.getSinks().get(0);
-        String actual = PColFilterExtractor.getExpression(
+        
+        PColFilterExtractor extractor = new PColFilterExtractor(filter.getFilterPlan(), new ArrayList<String>());
+        
+        String actual = extractor.getExpression(
                 (LogicalExpression)filter.getFilterPlan().getSources().get(0)).
                 toString().toLowerCase();
         Assert.assertEquals("checking trimmed filter expression:", 
@@ -374,7 +472,10 @@ public class TestPartitionFilterPushDown {
                     null,
                     TestLoader.partFilter);
         LOFilter filter = (LOFilter) newLogicalPlan.getSinks().get(0);
-        String actual = PColFilterExtractor.getExpression(
+        
+        PColFilterExtractor extractor = new PColFilterExtractor(filter.getFilterPlan(), new ArrayList<String>());
+        
+        String actual = extractor.getExpression(
                 (LogicalExpression) filter.getFilterPlan().
                 getSources().get(0)).
                 toString().toLowerCase();
@@ -439,7 +540,10 @@ public class TestPartitionFilterPushDown {
                     "((mrkt == 'us') and (srcid == 10))",
                     TestLoader.partFilter.toString());
         LOFilter filter = (LOFilter) newLogicalPlan.getSinks().get(0);
-        String actual = PColFilterExtractor.getExpression(
+        
+        PColFilterExtractor extractor = new PColFilterExtractor(filter.getFilterPlan(), new ArrayList<String>());
+        
+        String actual = extractor.getExpression(
                 (LogicalExpression) filter.getFilterPlan().getSources().get(0)).
                 toString().toLowerCase();
         Assert.assertEquals("checking trimmed filter expression:", 
@@ -508,7 +612,7 @@ public class TestPartitionFilterPushDown {
         	 Assert.assertTrue("Check that filter can be removed:", 
                     pColExtractor.isFilterRemovable());
         } else {
-            String actual = PColFilterExtractor.getExpression(
+            String actual = pColExtractor.getExpression(
                                 (LogicalExpression)filter.getFilterPlan().getSources().get(0)).
                                 toString().toLowerCase();
             Assert.assertEquals("checking trimmed filter expression:", expFilterString,
@@ -517,20 +621,43 @@ public class TestPartitionFilterPushDown {
         return pColExtractor;
     }
     
-    private void negativeTest(org.apache.pig.impl.logicalLayer.LogicalPlan lp, List<String> partitionCols,
-            int expectedErrorCode) throws VisitorException {
-    	LogicalPlan newLogicalPlan = migratePlan( lp );
-        LOFilter filter = (LOFilter)newLogicalPlan.getSinks().get(0);
-        PColFilterExtractor pColExtractor = new PColFilterExtractor(
-                filter.getFilterPlan(), partitionCols);
-        try {
-            pColExtractor.visit();
-        } catch(Exception e) {
-        	 Assert.assertEquals("Checking if exception has right error code", 
-                    expectedErrorCode, LogUtils.getPigException(e).getErrorCode());
-            return;
+    private void negativeTest(org.apache.pig.impl.logicalLayer.LogicalPlan lp,
+            List<String> partitionCols) throws FrontendException {
+        LogicalPlan newLogicalPlan = migratePlan(lp);
+        LOFilter filter = (LOFilter) newLogicalPlan.getSinks().get(0);
+
+        LogicalExpressionPlan plan = filter.getFilterPlan();
+
+        PColFilterExtractor pColExtractor = new PColFilterExtractor(plan,
+                partitionCols);
+
+        pColExtractor.visit();
+
+        Assert.assertTrue(!pColExtractor.canPushDown());
+    }
+    
+    private void negativeTest(org.apache.pig.impl.logicalLayer.LogicalPlan lp)
+            throws FrontendException {
+        LogicalPlan plan = migratePlan(lp);
+ 
+        LOFilter filter = (LOFilter) plan.getSinks().get(0);
+        
+        Rule rule = new PartitionFilterOptimizer("test");
+        List<OperatorPlan> matches = rule.match(plan);
+        if (matches != null) {
+            Transformer transformer = rule.getNewTransformer();
+            for (OperatorPlan m : matches) {
+                if (transformer.check(m)) {
+                    transformer.transform(m);
+                }
+            }
+            OperatorSubPlan newPlan = (OperatorSubPlan)transformer.reportChanges();
+
+            LOFilter filter2 = (LOFilter) newPlan.getBasePlan().getSinks().get(0);
+            
+            Assert.assertTrue(filter.isEqual(filter2));
+            Assert.assertTrue(newPlan.getBasePlan().isEqual(plan));
         }
-        Assert.fail("Exception expected!");
     }
     
     /**
