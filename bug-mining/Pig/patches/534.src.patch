diff --git a/CHANGES.txt b/CHANGES.txt
index 6ba4194d4..1e970cddc 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -207,6 +207,9 @@ PIG-1309: Map-side Cogroup (ashutoshc)
 
 BUG FIXES
 
+PIG-1635: Logical simplifier does not simplify away constants under AND and OR; after simplificaion the ordering of operands of
+          AND and OR may get changed (yanz)
+
 PIG-1639: New logical plan: PushUpFilter should not push before group/cogroup 
 if filter condition contains UDF (xuefuz via daijy)
 
diff --git a/src/org/apache/pig/newplan/logical/rules/ConstExpEvaluator.java b/src/org/apache/pig/newplan/logical/rules/ConstExpEvaluator.java
index 59a0cc81e..cec47c5aa 100644
--- a/src/org/apache/pig/newplan/logical/rules/ConstExpEvaluator.java
+++ b/src/org/apache/pig/newplan/logical/rules/ConstExpEvaluator.java
@@ -26,6 +26,7 @@ import org.apache.pig.newplan.ReverseDependencyOrderWalker;
 import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.data.DataType;
+import org.apache.pig.impl.util.Pair;
 
 /**
  *  a constant expression evaluation visitor that will evaluate the constant expressions.
@@ -244,8 +245,8 @@ class ConstExpEvaluator extends LogicalExpressionVisitor {
                     Operator[] preds = predList.toArray(new Operator[0]); 
                     for (Object p : preds) {
                         Operator pred = (Operator) p;
-                        plan.disconnect(pred, parent);
-                        plan.connect(pred, newExp);
+                        Pair<Integer, Integer> pos = plan.disconnect(pred, parent);
+                        plan.connect(pred, pos.first, newExp, pos.second);
                     }
                 }
                 plan.remove(parent);
diff --git a/src/org/apache/pig/newplan/logical/rules/LogicalExpressionSimplifier.java b/src/org/apache/pig/newplan/logical/rules/LogicalExpressionSimplifier.java
index a922fdc7a..4102adab8 100644
--- a/src/org/apache/pig/newplan/logical/rules/LogicalExpressionSimplifier.java
+++ b/src/org/apache/pig/newplan/logical/rules/LogicalExpressionSimplifier.java
@@ -210,6 +210,10 @@ public class LogicalExpressionSimplifier extends Rule {
                 return;
             byte relation;
             int size = children.size();
+            for (int i = 0; i < size; i++) {
+                if (children.get(i) instanceof ConstantExpression && ((Boolean) ((ConstantExpression) children.get(i)).getValue()))
+                    decrDNFSplitCount((LogicalExpression) children.get(i));
+            }
             for (int i = 0; i < size; i++) {
                 LogicalExpression child1 = (LogicalExpression) children.get(i);
                 for (int j = i + 1; j < size; j++) {
@@ -255,6 +259,10 @@ public class LogicalExpressionSimplifier extends Rule {
             Operator[] children = plan.getSuccessors(or).toArray(
                             new Operator[0]);
             int size = children.length;
+            for (int i = 0; i < size; i++) {
+              if (children[i] instanceof ConstantExpression && !((Boolean) ((ConstantExpression) children[i]).getValue()))
+                  decrDNFSplitCount((LogicalExpression) children[i]);
+            }
             for (int ii = 0; ii < size; ii++) {
                 LogicalExpression child = (LogicalExpression) children[ii];
                 if (child instanceof AndExpression || (child instanceof DNFExpression && ((DNFExpression) child).type == DNFExpression.DNFExpressionType.AND)) {
@@ -498,6 +506,9 @@ public class LogicalExpressionSimplifier extends Rule {
 
         private byte handleAndSimple(LogicalExpression e1, LogicalExpression e2)
                         throws FrontendException {
+            if (e2 instanceof ConstantExpression)
+                // no relationship between an AND and a constant
+                return Unknown;
             // get the inference relation between e1, an AND expression, and e2, a leaf logical expression
             List<Operator> andChildren = e1.getPlan().getSuccessors(e1);
             boolean hasUnknown = false;
diff --git a/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java b/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
index 06358e24f..8fa53f689 100644
--- a/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
+++ b/src/org/apache/pig/newplan/logical/rules/NotConversionVisitor.java
@@ -29,6 +29,7 @@ import org.apache.pig.newplan.Operator;
 import org.apache.pig.newplan.OperatorPlan;
 import org.apache.pig.newplan.PlanWalker;
 import org.apache.pig.newplan.PlanVisitor;
+import org.apache.pig.impl.util.Pair;
 
 /**
  * A NOT conversion visitor that will traverse the expression tree in a depth-first
@@ -59,8 +60,8 @@ class NOTConversionVisitor extends LogicalExpressionVisitor {
         if (p != null) {
             Operator[] preds = p.toArray(new Operator[0]);
             for (Operator pred : preds) {
-                plan.disconnect(pred, oldOp);
-                plan.connect(pred, newOp);
+                Pair<Integer, Integer> pos = plan.disconnect(pred, oldOp);
+                plan.connect(pred, pos.first, newOp, pos.second);
             }
         }
         List<Operator> s = plan.getSuccessors(oldOp);
@@ -81,8 +82,8 @@ class NOTConversionVisitor extends LogicalExpressionVisitor {
             Operator[] preds = p.toArray(new Operator[0]);
             for (Operator pred : preds) {
                 if (pred != before) {
-                    plan.disconnect(pred, after);
-                    plan.connect(pred, before);
+                    Pair<Integer, Integer> pos = plan.disconnect(pred, after);
+                    plan.connect(pred, pos.first, before, pos.second);
                 }
             }
         }
@@ -93,13 +94,12 @@ class NOTConversionVisitor extends LogicalExpressionVisitor {
         if (p != null) {
             Operator[] preds = p.toArray(new Operator[0]);
             for (Operator pred : preds) {
-                plan.disconnect(pred, op);
+                Pair<Integer, Integer> pos = plan.disconnect(pred, op);
                 List<Operator> s = plan.getSuccessors(op);
                 if (s != null) {
                     Operator[] sucs = s.toArray(new Operator[0]);
-                    for (Operator suc : sucs) {
-                        plan.connect(pred, suc);
-                    }
+                    for (int i = 0;  i < sucs.length; i++)
+                        plan.connect(pred, pos.first+i, sucs[i], pos.second+i);
                 }
             }
         }
diff --git a/test/org/apache/pig/test/TestFilterSimplification.java b/test/org/apache/pig/test/TestFilterSimplification.java
index 76bc19507..1b5a0efc3 100644
--- a/test/org/apache/pig/test/TestFilterSimplification.java
+++ b/test/org/apache/pig/test/TestFilterSimplification.java
@@ -33,6 +33,7 @@ import org.apache.pig.impl.plan.VisitorException;
 import org.apache.pig.test.utils.LogicalPlanTester;
 
 import junit.framework.TestCase;
+import org.junit.Test;
 
 public class TestFilterSimplification extends TestCase {
 
@@ -48,6 +49,7 @@ public class TestFilterSimplification extends TestCase {
         return newplan;
     }
 
+    @Test
     public void test1() throws Exception {
         // case 1: simple and implication
         LogicalPlanTester lpt = new LogicalPlanTester(pc);
@@ -547,6 +549,7 @@ public class TestFilterSimplification extends TestCase {
 
     }
 
+    @Test
     public void test2() throws Exception {
         LogicalPlanTester lpt = new LogicalPlanTester(pc);
         lpt.buildPlan("b = filter (load 'd.txt' as (name, age, gpa)) by age >= 50 or name > 'fred' and gpa <= 3.0 or name >= 'bob';");
@@ -612,6 +615,57 @@ public class TestFilterSimplification extends TestCase {
         assertTrue(expected.isEqual(newLogicalPlan));
     }
 
+    @Test
+    public void test3() throws Exception {
+        // boolean constant elimination: AND
+        LogicalPlanTester lpt = new LogicalPlanTester(pc);
+        lpt.buildPlan("b = filter (load 'd.txt' as (id:int, v1, v2)) by ((v1 is not null) AND (id == 1) AND (1 == 1));");
+        org.apache.pig.impl.logicalLayer.LogicalPlan plan = lpt.buildPlan("store b into 'empty';");
+        LogicalPlan newLogicalPlan = migratePlan(plan);
+
+        PlanOptimizer optimizer = new MyPlanOptimizer(newLogicalPlan, 10);
+        optimizer.optimize();
+
+        lpt = new LogicalPlanTester(pc);
+        lpt.buildPlan("b = filter (load 'd.txt' as (id:int, v1, v2)) by ((v1 is not null) AND (id == 1));");
+        plan = lpt.buildPlan("store b into 'empty';");
+        LogicalPlan expected = migratePlan(plan);
+
+        assertTrue(expected.isEqual(newLogicalPlan));
+
+        // boolean constant elimination: OR
+        lpt = new LogicalPlanTester(pc);
+        lpt.buildPlan("b = filter (load 'd.txt' as (id:int, v1, v2)) by (((v1 is not null) AND (id == 1)) OR (1 == 0));");
+        plan = lpt.buildPlan("store b into 'empty';");
+        newLogicalPlan = migratePlan(plan);
+
+        optimizer = new MyPlanOptimizer(newLogicalPlan, 10);
+        optimizer.optimize();
+
+        lpt = new LogicalPlanTester(pc);
+        lpt.buildPlan("b = filter (load 'd.txt' as (id:int, v1, v2)) by ((v1 is not null) AND (id == 1));");
+        plan = lpt.buildPlan("store b into 'empty';");
+        expected = migratePlan(plan);
+
+        assertTrue(expected.isEqual(newLogicalPlan));
+        
+        // the mirror case of the above
+        lpt = new LogicalPlanTester(pc);
+        lpt.buildPlan("b = filter (load 'd.txt' as (id:int, v1, v2)) by ((1 == 0) OR ((v1 is not null) AND (id == 1)));");
+        plan = lpt.buildPlan("store b into 'empty';");
+        newLogicalPlan = migratePlan(plan);
+
+        optimizer = new MyPlanOptimizer(newLogicalPlan, 10);
+        optimizer.optimize();
+
+        lpt = new LogicalPlanTester(pc);
+        lpt.buildPlan("b = filter (load 'd.txt' as (id:int, v1, v2)) by ((v1 is not null) AND (id == 1));");
+        plan = lpt.buildPlan("store b into 'empty';");
+        expected = migratePlan(plan);
+
+        assertTrue(expected.isEqual(newLogicalPlan));
+    }
+
     public class MyPlanOptimizer extends LogicalPlanOptimizer {
 
         protected MyPlanOptimizer(OperatorPlan p, int iterations) {
