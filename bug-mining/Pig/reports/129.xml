<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 19:49:17 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[PIG-505] Lineage for UDFs that do not return bytearray</title>
                <link>https://issues.apache.org/jira/browse/PIG-505</link>
                <project id="12310730" key="PIG">Pig</project>
                    <description>&lt;p&gt;In Pig-335, the lineage design states that UDFs that return bytearrays could cause problems in tracing the lineage. For UDFs that do not return bytearray, the lineage design should pickup the right load function to use as long as there is no ambiguity.  In the current implementation, we could have issues with scripts like:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;a = load &lt;span class=&quot;code-quote&quot;&gt;&apos;input&apos;&lt;/span&gt; as (field1);
b = foreach a generate myudf_to_double(field1);
c =  foreach b generate $0 + 2.0;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When $0 has to be cast to a double, the lineage code will complain that it hit a UDF and hence cannot determine the right load function to use.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12406958">PIG-505</key>
            <summary>Lineage for UDFs that do not return bytearray</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="sms">Santhosh Muthur Srinivasan</assignee>
                                    <reporter username="sms">Santhosh Muthur Srinivasan</reporter>
                        <labels>
                    </labels>
                <created>Tue, 21 Oct 2008 22:57:10 +0000</created>
                <updated>Wed, 24 Mar 2010 22:04:12 +0000</updated>
                            <resolved>Fri, 31 Oct 2008 20:25:28 +0000</resolved>
                                    <version>0.2.0</version>
                                    <fixVersion>0.2.0</fixVersion>
                                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                                                                <comments>
                            <comment id="12641940" author="sms" created="Wed, 22 Oct 2008 18:58:03 +0000"  >&lt;p&gt;In the existing design, Pig treats unknown types as bytearrays. As a result, if UDFs return complex types (map, bag, tuple) and if the outputSchema method does not specify the schema of the complex type,  Pig will treat the contents of the complex type as bytearray. The exception to this rule is map. The contents of map are always treated as bytearray. In the future, there are plans for treating unknown types as unknown types.&lt;/p&gt;

&lt;p&gt;Impact of UDFs creating bytearrays&lt;br/&gt;
------------------------------------------------&lt;/p&gt;

&lt;p&gt;If a UDF creates bytearrays, and if the bytearray is used in comparisons or in arithmetic operations or cast explicitly to a Pig type, the bytearray has to be cast to the appropriate type. The knowledge of converting the bytearray to the appropriate Pig type is best known to the UDF. In all other cases, we are making best effort guesses at picking the appropriate (load) function to convert bytearrays to Pig types.&lt;/p&gt;

&lt;p&gt;While the above paragraph captures the problem of UDFs creating bytearrays and their subsequent use, the view of treating unkown types as bytearrays leads to another problem. The UDF could be returning the correct Pig type and not a bytearray. In such cases, the treatment of the correct type as bytearray leads to an execution time situation. Pig expects DataByteArray but gets the correct type (i.e., Integer, Double, ...) leading to a ClassCastException. This problem has been addressed by capturing the exception, examining the type of the result and returning the right type in POCast. In the situation where a bytearray is returned by the UDF, Pig will never be able to convert the bytearray to the appropriate type resulting in a valid run time exception.&lt;/p&gt;

&lt;p&gt;With this background, the impact of treating unknown types as unknown types and the impact of treating unknown types as bytearrays is listed below:&lt;/p&gt;

&lt;p&gt;Impact of using unkown type as unknown type:&lt;br/&gt;
====================================&lt;/p&gt;

&lt;p&gt;Pros:&lt;br/&gt;
-------&lt;br/&gt;
1. UDFs that return bytearrays are affected at runtime, iff they use bytearrays in contexts where a cast is required, i.e., arithmetic operations, comparisons and explicit casts.&lt;/p&gt;

&lt;p&gt;2. Lineage code is not impacted&lt;/p&gt;

&lt;p&gt;3. Aligns with the strategy of handling Unknown types in the future&lt;/p&gt;

&lt;p&gt;Cons:&lt;br/&gt;
---------&lt;br/&gt;
1. Finding the right match for UDFs does not handle unknown types&lt;/p&gt;

&lt;p&gt;2. Impact of the change is huge. The getNext(Unkown) required of every operator as the output of a UDF could be used anywhere an expression is allowed in Pig&lt;/p&gt;

&lt;p&gt;3. Cost of figuring out the right type at runtime is the cost of instanceof in Java&lt;/p&gt;

&lt;p&gt;Impact of using unknown type as bytearray:&lt;br/&gt;
=================================&lt;/p&gt;

&lt;p&gt;Pros:&lt;br/&gt;
-------&lt;/p&gt;

&lt;p&gt;1. UDFs that return bytearrays are affected at runtime, iff they use bytearrays in contexts where a cast is required, i.e., arithmetic operations, comparisons and explicit casts.&lt;/p&gt;

&lt;p&gt;2. Unknowns are treated as bytearrays which is consistent with what the treatment of unknown types in the current design&lt;/p&gt;

&lt;p&gt;3. Treatment of unknowns as bytearrays in POCast is already in place&lt;/p&gt;

&lt;p&gt;Cons:&lt;br/&gt;
--------&lt;/p&gt;

&lt;p&gt;1. Lineage code is impacted. Lineage for UDFs will have to trace the correct load function. If there is a single load function then the choice is obvious. If there are more than one load functions to pick then randomly pick a load function. Expect the failure to occur at run time if a bytearray is returned by the UDF. This is a hack as the UDF could create bytearrays that are not recognized by the load functions.&lt;/p&gt;

&lt;p&gt;2. Adding to the current view of treating unknown types as bytearrays.&lt;/p&gt;

&lt;p&gt;3. Cost of figuring out the right type is the cost of handling an exception in Java&lt;/p&gt;

&lt;p&gt;We need to pick an approach based on the short term versus long term view nature of the solution. Comments/questions/thoughts are welcome.&lt;/p&gt;</comment>
                            <comment id="12642206" author="alangates" created="Thu, 23 Oct 2008 17:24:10 +0000"  >&lt;p&gt;A couple of comments:&lt;/p&gt;

&lt;p&gt;You say that the long term plan is to have a true unknown type, and then pose the problem as do we want to start the switch now or later.  (In fairness, I&apos;m pretty sure you&apos;re quoting something I said here, so I&apos;m about to question my own statement.)  I don&apos;t know if that&apos;s true or not.  In the original design for types we had an unknown type.  We ended up dropping it in implementation because it turned out to be so similar to the bytearray.  While there is some cost to combining byte arrays with unknown types (as you lay out) I&apos;m not sure that that means we should should separate the two.  The long term cost of maintainability may be greater.&lt;/p&gt;

&lt;p&gt;I&apos;m a confused by the first con of continuing to use byte arrays as unknowns.  Are you saying that if we do this, in the case where there is only one load function in the script, after a UDF returns what is really a byte array, we&apos;ll use the cast from that load function?  I&apos;m not certain what the right course is here.  From a correctness viewpoint, we can argue that pig doesn&apos;t know whether that byte array is from the load function or from the UDF.  However, this is a little burdensome to the user because it means any byte arrays inside complex types have to be dealt with before going to a UDF.  The con of using the load function where possible is if the byte array really is from the UDF and not the load function, we may error out or worse silently produce wrong data.  Since silently producing wrong data is a mortal sin in data processing I&apos;d come down on the side of not using the load function&apos;s cast here.&lt;/p&gt;

&lt;p&gt;A question, if we allow unknown in this one case, do we truly have to change code everywhere?  Instead of adding a getNext(unknown) to all operators, could we instead add a CastFromUnknown operator?  The entry point would still be getNext(ByteArray), so from all outside code&apos;s viewpoint the current type system should remain untouched.  And this operator would be written to introspect the type of object it got and either pass it on as is if it&apos;s the right type or cast it to the right type if it can.  It would never use a load function&apos;s cast (assuming we choose as indicated above), and it wouldn&apos;t incur the cost of throwing and catching an exception on the cast, it could use instanceof instead (which should be much faster).&lt;/p&gt;</comment>
                            <comment id="12642223" author="sms" created="Thu, 23 Oct 2008 18:35:29 +0000"  >&lt;p&gt;Responses with paragraph numbers:&lt;/p&gt;

&lt;p&gt;Paragraph 2: &lt;/p&gt;

&lt;p&gt;The current lineage code barfs if the load function is null for converting bytearrays to Pig type. As a result, we have to pick a load function to use resulting in run time errors or erroneous results. Based on your comment, it seems appropriate to relax the rule that load functions cannot null for bytearray to Pig type conversions and then throw an appropriate error message at run time (assuming no bugs in the lineage code)&lt;/p&gt;

&lt;p&gt;Paragraph 3:&lt;/p&gt;

&lt;p&gt;The inputs to cast expression can serve as inputs to any operators that expects expressions. As a result, setting the return type of expression operator to unknown will have across the board impact. In order to mitigate this impact, we could introduce a new visitor that changes the type of all expressions that are not inputs to cast to bytearray, However, this introduces a problem. When do we use this visitor? Before the type checker or after the type checker? If we use the visitor before the type checker the we will lose unknown types for casts introduced by the type checker. If we use the visitor after the type checker, the type checker will barf if unknown types occur in the graph. As a result, we will have to either migrate some of the functionality of the type checker into the visitor. This approach is complicated and not worth the benefit.&lt;/p&gt;

&lt;p&gt;Based on the discussions and given the cost implications of code complexity, maintenance and performance, the solution is probably the following:&lt;/p&gt;

&lt;p&gt;1. Relax the rule of load function not being null in the lineage code.&lt;br/&gt;
2. If a null pointer exception occurs in the back end (POCast, specifically) then we assume that it was due to a bytearray created by a UDF and report an appropriate error message.&lt;/p&gt;

&lt;p&gt;The only constraint to this solution is the assumption that the lineage code is not buggy. If the lineage code is buggy and we end up with a null load function for the right bytearray to Pig type conversion, it will require investigation.&lt;/p&gt;</comment>
                            <comment id="12642241" author="ciemo" created="Thu, 23 Oct 2008 19:30:00 +0000"  >&lt;p&gt;Are we overthinking this problem at this time?&lt;/p&gt;

&lt;p&gt;At this time, the only source of &quot;undefined&quot; values in user defined functions that I know of are those that return maps.  (I could be wrong).&lt;/p&gt;

&lt;p&gt;Why don&apos;t we just make the following simplifying assumptions (or conventions) for right now?&lt;/p&gt;

&lt;p&gt;1) UDFs that return maps must return the individual values as bytearray type.  Period.&lt;br/&gt;
2) When casting using the lineage code, the code assumes that these are bytearray for conversion purposes.&lt;br/&gt;
3) Tell me how to code my UDFs to follow these guidelines and conventions.&lt;/p&gt;

&lt;p&gt;The other option is to introduce some cast convention that allows me to define whether the map will adhere to a bytearray convention or a chararray convention to reduce the chance of redundant conversions.&lt;/p&gt;

&lt;p&gt;For example &amp;#8211; (map&amp;lt;bytearray&amp;gt;) or (map&amp;lt;chararray&amp;gt;).  Or maybe this is handled intrinsically in the function definition.&lt;/p&gt;</comment>
                            <comment id="12642255" author="sms" created="Thu, 23 Oct 2008 20:07:14 +0000"  >&lt;p&gt;Undefined values could occur in other complex types - tuples and bags. If the outputSchema method in the UDF is not implemented and the tuple or bag is flattened, the Pig has to deal with unknowns.&lt;/p&gt;

&lt;p&gt;1. Pig will prefer that you return the correct type instead of bytearray unless your type is a bytearray.&lt;/p&gt;

&lt;p&gt;2. Pig is making that assumption in the current implementation and we are continuing to adhere to that assumption&lt;/p&gt;

&lt;p&gt;3. Unless you need bytearrays, return the appropriate type in your Map, i.e, Pig expects a Map&amp;lt;Object, Object&amp;gt;, for the values, please use Integer, Long, Float, Double, String, DataByteArray, Map, Tupe and Bag depending on your use case. Use DataByteArray only if you will use it as a bytearray in Pig&lt;/p&gt;

&lt;p&gt;In the future, we might let users specify the value type and even the key type and value types of the map like strongly typed languages.&lt;/p&gt;</comment>
                            <comment id="12642269" author="ciemo" created="Thu, 23 Oct 2008 20:35:43 +0000"  >&lt;p&gt;The problem is this - I think we&apos;ve not done a good a job of communicating this assumption of full typing for Maps.  In fact, it was the Pig 2.0 development team that ported this user defined function from Pig 1.4.&lt;/p&gt;

&lt;p&gt;The function is string.URLPARSE and It uses a generic Map&amp;lt;Object,Object&amp;gt; return type rather than, say, Map&amp;lt;String,String&amp;gt; which would seem more appropriate.  Also, this function DOES have a a defined outputSchema of DataType.MAP.&lt;/p&gt;

&lt;p&gt;Maybe one of the solutions to working around this problem is making another pass through the example user defined functions and making sure they are FULLY 2.0 compliant for types.&lt;/p&gt;

&lt;p&gt;Here&apos;s the example code for string.URLPARSE.  Please advise on what you think the correct defintion for the return type and the outputSchema should be.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;

&lt;p&gt;package string;&lt;/p&gt;

&lt;p&gt;import java.io.IOException;&lt;br/&gt;
import java.util.Map;&lt;br/&gt;
import java.util.HashMap;&lt;/p&gt;

&lt;p&gt;import java.util.regex.Pattern;&lt;br/&gt;
import java.util.regex.Matcher;&lt;/p&gt;

&lt;p&gt;import org.apache.pig.EvalFunc;&lt;br/&gt;
import org.apache.pig.data.Tuple;&lt;br/&gt;
import org.apache.pig.impl.logicalLayer.schema.Schema;&lt;br/&gt;
import org.apache.pig.data.DataType;&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;string.URLPARSE parses a URL into the parts as described in RFC 1738 and RFC 1808.&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;According to the RFCs, a URL may be described as:&lt;br/&gt;
 *&lt;/li&gt;
	&lt;li&gt;scheme://authority/path;params?query#fragment&lt;/li&gt;
	&lt;li&gt;scheme://userinfo@host:port/path;params?query#fragment&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;ULRPARSE also supports parsing non-conformant ULRs that have scheme:// stripped.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dl&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dt&amp;gt;&amp;lt;b&amp;gt;Parameters:&amp;lt;/b&amp;gt;&amp;lt;/dt&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;&amp;lt;code&amp;gt;url&amp;lt;/code&amp;gt; - &amp;lt;code&amp;gt;String&amp;lt;/code&amp;gt; url string to parse.&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dt&amp;gt;&amp;lt;b&amp;gt;Return Value:&amp;lt;/b&amp;gt;&amp;lt;/dt&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;&amp;lt;code&amp;gt;Map&amp;lt;/code&amp;gt; parsed url&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dt&amp;gt;&amp;lt;b&amp;gt;Return Schema:&amp;lt;/b&amp;gt;&amp;lt;/dt&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;urlparse&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;scheme&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;authority&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;userinfo&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;host&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;port&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;path&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;params&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;paramsFields&apos; Map&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;query&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;queryFields&apos; Map&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;#&apos;fragment&apos; String&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;Note that none of the returned values are decoded so the values may contain&lt;/li&gt;
	&lt;li&gt;escaped characters such as %2F and +&amp;lt;/p&amp;gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dt&amp;gt;&amp;lt;b&amp;gt;Example:&amp;lt;/b&amp;gt;&amp;lt;/dt&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;dd&amp;gt;&amp;lt;code&amp;gt;&lt;/li&gt;
	&lt;li&gt;register string.jar;&amp;lt;br/&amp;gt;&lt;/li&gt;
	&lt;li&gt;A = load &apos;mydata&apos; using PigStorage() as ( url );&amp;lt;br/&amp;gt;&lt;/li&gt;
	&lt;li&gt;B = foreach A generate url, string.URLPARSE(url) as parsedurl;&lt;/li&gt;
	&lt;li&gt;C = foreach B generate url, parsedurl#&apos;host&apos; as host;&lt;/li&gt;
	&lt;li&gt;&amp;lt;/code&amp;gt;&amp;lt;/dd&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;/dl&amp;gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@author David (Ciemo) Ciemiewicz&lt;br/&gt;
 */&lt;br/&gt;
public class URLPARSE extends EvalFunc&amp;lt;Map&amp;lt;Object, Object&amp;gt; &amp;gt; {&lt;br/&gt;
        // @Override&lt;br/&gt;
        static private String strOrNullStr(String str) 
{
                return (str == null) ? &quot;&quot; : str;
        }
&lt;p&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;        static private Pattern scheme_rest = Pattern.compile(&quot;^((&lt;span class=&quot;error&quot;&gt;&amp;#91;A-Za-z&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;A-Za-z0-9.+-&amp;#93;&lt;/span&gt;&lt;b&gt;)&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;?(.&lt;/b&gt;)$&quot;);&lt;br/&gt;
        static private Pattern authority_rest = Pattern.compile(&quot;^((//)?(((&lt;span class=&quot;error&quot;&gt;&amp;#91;^@:/&amp;#93;&lt;/span&gt;&lt;ins&gt;)@)?(&lt;span class=&quot;error&quot;&gt;&amp;#91;^:/&amp;#93;&lt;/span&gt;&lt;/ins&gt;)(&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;0-9&amp;#93;&lt;/span&gt;+))?))(.*)$&quot;);&lt;br/&gt;
        static private Pattern path_params_query_fragment = Pattern.compile(&quot;^(/?&lt;span class=&quot;error&quot;&gt;&amp;#91;^;?#&amp;#93;&lt;/span&gt;&lt;b&gt;)?(;(&lt;span class=&quot;error&quot;&gt;&amp;#91;^?#&amp;#93;&lt;/span&gt;&lt;/b&gt;))?(&lt;br class=&quot;atl-forced-newline&quot; /&gt;?(&lt;span class=&quot;error&quot;&gt;&amp;#91;^#&amp;#93;&lt;/span&gt;&lt;b&gt;))?(#(.&lt;/b&gt;))?$&quot;);&lt;br/&gt;
        static private Pattern field_value_pairs = Pattern.compile(&quot;((&lt;span class=&quot;error&quot;&gt;&amp;#91;^=&amp;amp;&amp;#93;&lt;/span&gt;+)=(&lt;span class=&quot;error&quot;&gt;&amp;#91;^=&amp;amp;&amp;#93;&lt;/span&gt;&lt;b&gt;))&amp;amp;&lt;/b&gt;&quot;);&lt;/p&gt;

&lt;p&gt;        public Map&amp;lt;Object, Object&amp;gt; exec(Tuple input) throws IOException {&lt;br/&gt;
                if (input == null || input.size() == 0)&lt;br/&gt;
                        return null;&lt;/p&gt;

&lt;p&gt;                String url;&lt;/p&gt;

&lt;p&gt;                try&lt;/p&gt;
{
                        url = (String)input.get(0);
                }
&lt;p&gt; catch(Exception e)&lt;/p&gt;
{
                        System.out.println(&quot;Can&apos;t convert field to a string; error = &quot; + e.getMessage());
                        return null;
                }

&lt;p&gt;                //Pattern p;&lt;br/&gt;
                HashMap&amp;lt;Object, Object&amp;gt; output = new HashMap&amp;lt;Object, Object&amp;gt;();&lt;br/&gt;
                Matcher m;&lt;br/&gt;
                String scheme = &quot;&quot;;&lt;br/&gt;
                String authority = &quot;&quot;;&lt;br/&gt;
                String userinfo = &quot;&quot;;&lt;br/&gt;
                String host = &quot;&quot;;&lt;br/&gt;
                String port = &quot;&quot;;&lt;br/&gt;
                String path = &quot;&quot;;&lt;br/&gt;
                String params = &quot;&quot;;&lt;br/&gt;
                String query = &quot;&quot;;&lt;br/&gt;
                String fragment = &quot;&quot;;&lt;br/&gt;
                String rest = &quot;&quot;;&lt;/p&gt;

&lt;p&gt;                if(url == null) &lt;/p&gt;
{
                        return null;
                }
&lt;p&gt;                m = scheme_rest.matcher(url);&lt;br/&gt;
                if (m.find()) {&lt;br/&gt;
                        scheme = strOrNullStr(m.group(2));&lt;br/&gt;
                        rest = strOrNullStr(m.group(3));&lt;/p&gt;

&lt;p&gt;                        m = authority_rest.matcher(rest);&lt;br/&gt;
                        if (m.find()) {&lt;br/&gt;
                                //String doubleslash = strOrNullStr(m.group(2));&lt;br/&gt;
                                authority = strOrNullStr(m.group(3));&lt;br/&gt;
                                userinfo = strOrNullStr(m.group(5));&lt;br/&gt;
                                host = strOrNullStr(m.group(6));&lt;br/&gt;
                                port = strOrNullStr(m.group(8));&lt;/p&gt;

&lt;p&gt;                                rest = strOrNullStr(m.group(9));&lt;/p&gt;

&lt;p&gt;                                m = path_params_query_fragment.matcher(rest);&lt;br/&gt;
                                if (m.find()) &lt;/p&gt;
{
                                        path = strOrNullStr(m.group(1));
                                        params = strOrNullStr(m.group(3));
                                        query = strOrNullStr(m.group(5));
                                        fragment = strOrNullStr(m.group(7));
                                }
&lt;p&gt;                        }&lt;br/&gt;
                }&lt;/p&gt;

&lt;p&gt;                HashMap&amp;lt;Object, Object&amp;gt; paramsFieldsMap = new HashMap&amp;lt;Object, Object&amp;gt;();&lt;br/&gt;
                m = field_value_pairs.matcher(params);&lt;br/&gt;
                while (m.find()) &lt;/p&gt;
{
                        String field = strOrNullStr(m.group(2));
                        String value = strOrNullStr(m.group(3));

                        paramsFieldsMap.put(field, value);
                }

&lt;p&gt;                HashMap&amp;lt;Object, Object&amp;gt; queryFieldsMap = new HashMap&amp;lt;Object, Object&amp;gt;();&lt;br/&gt;
                m = field_value_pairs.matcher(query);&lt;br/&gt;
                while (m.find()) &lt;/p&gt;
{
                        String field = strOrNullStr(m.group(2));
                        String value = strOrNullStr(m.group(3));

                        queryFieldsMap.put(field, value);
                }

&lt;p&gt;                output.put(&quot;url&quot;,       url);&lt;br/&gt;
                output.put(&quot;scheme&quot;,    scheme);&lt;br/&gt;
                output.put(&quot;authority&quot;, authority);&lt;br/&gt;
                output.put(&quot;userinfo&quot;,  userinfo);&lt;br/&gt;
                output.put(&quot;host&quot;,      host);&lt;br/&gt;
                output.put(&quot;port&quot;,      port);&lt;br/&gt;
                output.put(&quot;path&quot;,      path);&lt;br/&gt;
                output.put(&quot;params&quot;,    params);&lt;br/&gt;
                output.put(&quot;paramsFields&quot;, paramsFieldsMap);&lt;br/&gt;
                output.put(&quot;query&quot;, query);&lt;br/&gt;
                output.put(&quot;queryFields&quot;, queryFieldsMap);&lt;br/&gt;
                output.put(&quot;fragment&quot;, fragment);&lt;/p&gt;

&lt;p&gt;                return output;&lt;br/&gt;
        }&lt;/p&gt;

&lt;p&gt;        @Override&lt;br/&gt;
        public Schema outputSchema(Schema input) &lt;/p&gt;
{
                return new Schema(new Schema.FieldSchema(getSchemaName(&quot;urlparse&quot;, input), DataType.MAP));
        }
&lt;p&gt;}&lt;/p&gt;</comment>
                            <comment id="12642325" author="pi_song" created="Thu, 23 Oct 2008 22:36:26 +0000"  >&lt;p&gt;Unknown is unknown. It cannot be bytearray.&lt;/p&gt;

&lt;p&gt;In case,&lt;br/&gt;
Table1 as (x:Unknown, y:Unknown)&lt;/p&gt;

&lt;p&gt;we can&apos;t even tell the result of (x == y) because we don&apos;t know their types and unknown from x can be a different type (not the same as y&apos;s unknown)&lt;/p&gt;

&lt;p&gt;Haven&apos;t looked at the code yet so haven&apos;t taken implementation into thinking.&lt;/p&gt;</comment>
                            <comment id="12642326" author="ciemo" created="Thu, 23 Oct 2008 22:41:53 +0000"  >&lt;p&gt;Just tried naively changing Map&amp;lt;Object,Object&amp;gt; to Map&amp;lt;String,String&amp;gt; for string.URLPARSE and realized that this won&apos;t work.&lt;/p&gt;

&lt;p&gt;The thing is that some of the mapped values are strings and some are maps such as paramsFields and queryFields.&lt;/p&gt;

&lt;p&gt;When you look at the code, it will make sense.&lt;/p&gt;

&lt;p&gt;So the type must be &quot;unknown&quot; and not &quot;bytearray&quot; because it could be String or Map.&lt;/p&gt;

&lt;p&gt;So, it would seem that there is need for &quot;unknown&quot; but, in this case, the cast operation is not a bytearray to whatever conversion but is rather Object (unknown) to Type (Map) with an opaque, no conversion cast of the data.&lt;/p&gt;

&lt;p&gt;urlparse&lt;br/&gt;
#&apos;scheme&apos; String&lt;br/&gt;
#&apos;authority&apos; String&lt;br/&gt;
#&apos;userinfo&apos; String&lt;br/&gt;
#&apos;host&apos; String&lt;br/&gt;
#&apos;port&apos; String&lt;br/&gt;
#&apos;path&apos; String&lt;br/&gt;
#&apos;params&apos; String&lt;br/&gt;
#&apos;paramsFields&apos; Map&lt;br/&gt;
#&apos;query&apos; String&lt;br/&gt;
#&apos;queryFields&apos; Map&lt;br/&gt;
#&apos;fragment&apos; String&lt;/p&gt;</comment>
                            <comment id="12642578" author="sms" created="Sat, 25 Oct 2008 00:33:06 +0000"  >&lt;p&gt;Response to David&apos;s comments:&lt;/p&gt;

&lt;p&gt;The map type in Pig was designed to hold any atomic key type (i.e., string, int, float, long, double) and any value type. As a result, the natural representation is a Map&amp;lt;Object, Object&amp;gt;.  The UDF has the right outputSchema implementation. UDFs that return maps should return Map&amp;lt;Object, Object&amp;gt;.&lt;/p&gt;

&lt;p&gt;With the proposal in comment 3 (&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-505?focusedCommentId=12642223#action_12642223&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/PIG-505?focusedCommentId=12642223#action_12642223&lt;/a&gt;), the UDF will work as long as there are no DataByteArray values in the Map that require a cast.&lt;/p&gt;

&lt;p&gt;Response to Pi&apos;s comments:&lt;/p&gt;

&lt;p&gt;Treating unknowns as bytearrays will lead to run time errors which will not go away if we treat unknowns as unknowns. The trade-off is better error handling. Specifically, in your example, comparing 2 unknowns can be caught during type checking whereas making them bytearrays might result in a run time error iff the two types do not match.&lt;/p&gt;

&lt;p&gt;Summary: Treating unknowns as bytearray will result in coarser error messages. On the other hand treating unknown as unknown will require significant changes without eliminating the possibility of run time errors.&lt;/p&gt;</comment>
                            <comment id="12642637" author="ciemo" created="Sat, 25 Oct 2008 16:57:19 +0000"  >&lt;p&gt;Santhosh,&lt;/p&gt;

&lt;p&gt;This sounds fine.  I don&apos;t quite follow comment #3 but if the result is the similar to doing a cast of a Java Object to a String, Float, Double, Integer, Long, etc, then this sounds cool.&lt;/p&gt;

&lt;p&gt;It would seem that if some Data was a DataByteArray (bytearray) in the map and this required conversion, would it be possible to do a double cast such as:&lt;/p&gt;

&lt;p&gt;(chararray) (bytearray) mymap#&apos;abytearrayfield&apos; as bytearray_now_chararray&lt;/p&gt;

&lt;p&gt;Presumably one might need to add some parentheses:&lt;/p&gt;

&lt;p&gt;(chararray) ((bytearray) (mymap#&apos;abytearrayfield&apos;)) as bytearray_now_chararray&lt;/p&gt;


&lt;p&gt;Maybe it should be okay to have runtime errors in the case of unknown.  Ideally, I&apos;d like compile time errors for unknown which force us to use casts &amp;#8211; we can never have an unknown detected at compile time without resulting in the need for a cast.&lt;/p&gt;

&lt;p&gt;There is a question though of what load functions that use maps will do that is different than URLPARSE and other UDFs that return maps.&lt;/p&gt;</comment>
                            <comment id="12643349" author="sms" created="Tue, 28 Oct 2008 22:05:01 +0000"  >&lt;p&gt;If the map contains a DataByteArray (bytearray) then we will not be able to convert it to any of the Pig types. For DataByteArray, Pig does not have a mechanism to interpret the bytes. Only non DataByteArray types can be converted to Pig types as long they can be converted, i.e., int to float, int to long, etc.&lt;/p&gt;

&lt;p&gt;Double cast expressions require the parenthesis as you pointed out and can be used for non-bytearray conversions for data coming out of a UDF.&lt;/p&gt;</comment>
                            <comment id="12643382" author="ciemo" created="Wed, 29 Oct 2008 00:15:05 +0000"  >&lt;p&gt;I don&apos;t understand this statement:&lt;/p&gt;

&lt;p&gt;If the map contains a DataByteArray (bytearray) then we will not be able to convert it to any of the Pig types. For DataByteArray, Pig does not have a mechanism to interpret the bytes. Only non DataByteArray types can be converted to Pig types as long they can be converted, i.e., int to float, int to long, etc. &lt;/p&gt;

&lt;p&gt;The Pig 1.4 to 2.0 Transition document (1.3 Cast) says:&lt;br/&gt;
from / to	bag	tuple	map	int	long	float	double	chararray	bytearray&lt;br/&gt;
bytearray	 yes	 yes	 yes	 yes	 yes	 yes	 yes	 yes	  &lt;/p&gt;
</comment>
                            <comment id="12643391" author="sms" created="Wed, 29 Oct 2008 01:00:01 +0000"  >&lt;p&gt;With our current design, we do not support conversion of bytearray from UDF to Pig types. Its an issue that needs a design/architectural solution.&lt;/p&gt;</comment>
                            <comment id="12644142" author="sms" created="Thu, 30 Oct 2008 22:36:46 +0000"  >&lt;p&gt;The attached patch (&lt;a href=&quot;https://issues.apache.org/jira/browse/PIG-505&quot; title=&quot;Lineage for UDFs that do not return bytearray&quot; class=&quot;issue-link&quot; data-issue-key=&quot;PIG-505&quot;&gt;&lt;del&gt;PIG-505&lt;/del&gt;&lt;/a&gt;.patch) addresses the following issues:&lt;/p&gt;

&lt;p&gt;1. The lineage code does not error out when bytearrays are seen from a UDF. Instead the error message is pushed to runtime if a bytearray originating from a UDF is cast to a Pig type&lt;/p&gt;

&lt;p&gt;2. Moved the SchemaUitils class out of the parser and into the Schema class&lt;/p&gt;

&lt;p&gt;3. Added unit test cases for the lineage change&lt;/p&gt;

&lt;p&gt;All unit test cases pass.&lt;/p&gt;</comment>
                            <comment id="12644422" author="olgan" created="Fri, 31 Oct 2008 20:25:28 +0000"  >&lt;p&gt;patch committed; thanks, santhosh&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12393112" name="PIG-505.patch" size="24422" author="sms" created="Thu, 30 Oct 2008 22:36:46 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>164110</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            17 years, 4 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310041" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Patch Info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10042"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0gl1b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>94838</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>