diff --git a/Cargo.toml b/Cargo.toml
index 358d940d..7f9d7248 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -46,6 +46,9 @@ spmc = "0.2"
 url = "1.0"
 tokio-fs = "0.1"
 tokio-mockstream = "1.1.0"
+serde = "1.0"
+serde_derive = "1.0"
+serde_json = "1.0"
 
 [features]
 default = [
@@ -77,6 +80,11 @@ name = "client"
 path = "examples/client.rs"
 required-features = ["runtime"]
 
+[[example]]
+name = "client_json"
+path = "examples/client_json.rs"
+required-features = ["runtime"]
+
 [[example]]
 name = "echo"
 path = "examples/echo.rs"
diff --git a/examples/README.md b/examples/README.md
index b877ef84..8179e27e 100644
--- a/examples/README.md
+++ b/examples/README.md
@@ -6,6 +6,9 @@ Run examples with `cargo run --example example_name`.
 
 * [`client`](client.rs) - A simple CLI http client that request the url passed in parameters and outputs the response content and details to the stdout, reading content chunk-by-chunk.
 
+* [`client_json`](client_json.rs) - A simple program that GETs some json, reads the body asynchronously,
+parses it with serde and outputs the result.
+
 * [`echo`](echo.rs) - An echo server that copies POST request's content to the response content.
 
 * [`hello`](hello.rs) - A simple server that returns "Hello World!" using a closure wrapped to provide a [`Service`](../src/service/service.rs).
diff --git a/examples/client_json.rs b/examples/client_json.rs
new file mode 100644
index 00000000..24a8c597
--- /dev/null
+++ b/examples/client_json.rs
@@ -0,0 +1,50 @@
+#![deny(warnings)]
+extern crate hyper;
+#[macro_use]
+extern crate serde_derive;
+extern crate serde;
+extern crate serde_json;
+
+use hyper::Client;
+use hyper::rt::{self, Future, Stream};
+
+fn main() {
+    let url = "http://jsonplaceholder.typicode.com/users".parse().unwrap();
+
+    // Run the runtime with the future trying to fetch, parse and print json.
+    //
+    // Note that in more complicated use cases, the runtime should probably
+    // run on its own, and futures should just be spawned into it.
+    rt::run(fetch_json(url));
+}
+
+fn fetch_json(url: hyper::Uri) -> impl Future<Item=(), Error=()> {
+    let client = Client::new();
+
+    client
+        // Fetch the url...
+        .get(url)
+        // And then, if we get a response back...
+        .and_then(|res| {
+            // asynchronously concatenate chunks of the body
+            res.into_body().concat2()
+        })
+        // use the body after concatenation
+        .map(|body| {
+            // try to parse as json with serde_json
+            let users: Vec<User> = serde_json::from_slice(&body).expect("parse json");
+
+            // pretty print result
+            println!("{:#?}", users);
+        })
+        // If there was an error, let the user know...
+        .map_err(|err| {
+            eprintln!("Error {}", err);
+        })
+}
+
+#[derive(Deserialize, Debug)]
+struct User {
+    id: i32,
+    name: String,
+}
\ No newline at end of file
