diff --git a/src/client/conn.rs b/src/client/conn.rs
index 23b548da..fd25741f 100644
--- a/src/client/conn.rs
+++ b/src/client/conn.rs
@@ -272,7 +272,7 @@ where
         ResponseFuture { inner }
     }
 
-    pub(crate) fn send_request_retryable(
+    pub(super) fn send_request_retryable(
         &mut self,
         req: Request<B>,
     ) -> impl Future<Output = Result<Response<Body>, (crate::Error, Option<Request<B>>)>> + Unpin
diff --git a/src/client/connect/dns.rs b/src/client/connect/dns.rs
index 90d3d4a2..08cbb1e8 100644
--- a/src/client/connect/dns.rs
+++ b/src/client/connect/dns.rs
@@ -346,7 +346,7 @@ mod sealed {
     }
 }
 
-pub(crate) async fn resolve<R>(resolver: &mut R, name: Name) -> Result<R::Addrs, R::Error>
+pub(super) async fn resolve<R>(resolver: &mut R, name: Name) -> Result<R::Addrs, R::Error>
 where
     R: Resolve,
 {
diff --git a/src/client/dispatch.rs b/src/client/dispatch.rs
index a7e6311b..804eebbf 100644
--- a/src/client/dispatch.rs
+++ b/src/client/dispatch.rs
@@ -6,10 +6,10 @@ use tokio::sync::{mpsc, oneshot};
 
 use crate::common::{task, Pin, Poll};
 
-pub type RetryPromise<T, U> = oneshot::Receiver<Result<U, (crate::Error, Option<T>)>>;
-pub type Promise<T> = oneshot::Receiver<Result<T, crate::Error>>;
+pub(crate) type RetryPromise<T, U> = oneshot::Receiver<Result<U, (crate::Error, Option<T>)>>;
+pub(crate) type Promise<T> = oneshot::Receiver<Result<T, crate::Error>>;
 
-pub fn channel<T, U>() -> (Sender<T, U>, Receiver<T, U>) {
+pub(crate) fn channel<T, U>() -> (Sender<T, U>, Receiver<T, U>) {
     let (tx, rx) = mpsc::unbounded_channel();
     let (giver, taker) = want::new();
     let tx = Sender {
@@ -25,7 +25,7 @@ pub fn channel<T, U>() -> (Sender<T, U>, Receiver<T, U>) {
 ///
 /// While the inner sender is unbounded, the Giver is used to determine
 /// if the Receiver is ready for another request.
-pub struct Sender<T, U> {
+pub(crate) struct Sender<T, U> {
     /// One message is always allowed, even if the Receiver hasn't asked
     /// for it yet. This boolean keeps track of whether we've sent one
     /// without notice.
@@ -44,24 +44,24 @@ pub struct Sender<T, U> {
 /// Cannot poll the Giver, but can still use it to determine if the Receiver
 /// has been dropped. However, this version can be cloned.
 #[cfg(feature = "http2")]
-pub struct UnboundedSender<T, U> {
+pub(crate) struct UnboundedSender<T, U> {
     /// Only used for `is_closed`, since mpsc::UnboundedSender cannot be checked.
     giver: want::SharedGiver,
     inner: mpsc::UnboundedSender<Envelope<T, U>>,
 }
 
 impl<T, U> Sender<T, U> {
-    pub fn poll_ready(&mut self, cx: &mut task::Context<'_>) -> Poll<crate::Result<()>> {
+    pub(crate) fn poll_ready(&mut self, cx: &mut task::Context<'_>) -> Poll<crate::Result<()>> {
         self.giver
             .poll_want(cx)
             .map_err(|_| crate::Error::new_closed())
     }
 
-    pub fn is_ready(&self) -> bool {
+    pub(crate) fn is_ready(&self) -> bool {
         self.giver.is_wanting()
     }
 
-    pub fn is_closed(&self) -> bool {
+    pub(crate) fn is_closed(&self) -> bool {
         self.giver.is_canceled()
     }
 
@@ -78,7 +78,7 @@ impl<T, U> Sender<T, U> {
         }
     }
 
-    pub fn try_send(&mut self, val: T) -> Result<RetryPromise<T, U>, T> {
+    pub(crate) fn try_send(&mut self, val: T) -> Result<RetryPromise<T, U>, T> {
         if !self.can_send() {
             return Err(val);
         }
@@ -89,7 +89,7 @@ impl<T, U> Sender<T, U> {
             .map_err(|mut e| (e.0).0.take().expect("envelope not dropped").0)
     }
 
-    pub fn send(&mut self, val: T) -> Result<Promise<U>, T> {
+    pub(crate) fn send(&mut self, val: T) -> Result<Promise<U>, T> {
         if !self.can_send() {
             return Err(val);
         }
@@ -101,7 +101,7 @@ impl<T, U> Sender<T, U> {
     }
 
     #[cfg(feature = "http2")]
-    pub fn unbound(self) -> UnboundedSender<T, U> {
+    pub(crate) fn unbound(self) -> UnboundedSender<T, U> {
         UnboundedSender {
             giver: self.giver.shared(),
             inner: self.inner,
@@ -111,15 +111,15 @@ impl<T, U> Sender<T, U> {
 
 #[cfg(feature = "http2")]
 impl<T, U> UnboundedSender<T, U> {
-    pub fn is_ready(&self) -> bool {
+    pub(crate) fn is_ready(&self) -> bool {
         !self.giver.is_canceled()
     }
 
-    pub fn is_closed(&self) -> bool {
+    pub(crate) fn is_closed(&self) -> bool {
         self.giver.is_canceled()
     }
 
-    pub fn try_send(&mut self, val: T) -> Result<RetryPromise<T, U>, T> {
+    pub(crate) fn try_send(&mut self, val: T) -> Result<RetryPromise<T, U>, T> {
         let (tx, rx) = oneshot::channel();
         self.inner
             .send(Envelope(Some((val, Callback::Retry(tx)))))
@@ -139,7 +139,7 @@ impl<T, U> Clone for UnboundedSender<T, U> {
 }
 
 #[pin_project::pin_project(PinnedDrop)]
-pub struct Receiver<T, U> {
+pub(crate) struct Receiver<T, U> {
     #[pin]
     inner: mpsc::UnboundedReceiver<Envelope<T, U>>,
     taker: want::Taker,
@@ -199,7 +199,7 @@ impl<T, U> Drop for Envelope<T, U> {
     }
 }
 
-pub enum Callback<T, U> {
+pub(crate) enum Callback<T, U> {
     Retry(oneshot::Sender<Result<U, (crate::Error, Option<T>)>>),
     NoRetry(oneshot::Sender<Result<U, crate::Error>>),
 }
diff --git a/src/client/mod.rs b/src/client/mod.rs
index 7f3006aa..9600a764 100644
--- a/src/client/mod.rs
+++ b/src/client/mod.rs
@@ -63,7 +63,7 @@ cfg_feature! {
 
     mod client;
     pub mod conn;
-    pub(crate) mod dispatch;
+    pub(super) mod dispatch;
     mod pool;
     pub mod service;
 }
diff --git a/src/client/pool.rs b/src/client/pool.rs
index bbee0344..0f22657b 100644
--- a/src/client/pool.rs
+++ b/src/client/pool.rs
@@ -100,7 +100,7 @@ impl Config {
 }
 
 impl<T> Pool<T> {
-    pub fn new(config: Config, __exec: &Exec) -> Pool<T> {
+    pub(super) fn new(config: Config, __exec: &Exec) -> Pool<T> {
         let inner = if config.is_enabled() {
             Some(Arc::new(Mutex::new(PoolInner {
                 connecting: HashSet::new(),
@@ -140,7 +140,7 @@ impl<T> Pool<T> {
 impl<T: Poolable> Pool<T> {
     /// Returns a `Checkout` which is a future that resolves if an idle
     /// connection becomes available.
-    pub fn checkout(&self, key: Key) -> Checkout<T> {
+    pub(super) fn checkout(&self, key: Key) -> Checkout<T> {
         Checkout {
             key,
             pool: self.clone(),
@@ -489,11 +489,11 @@ pub(super) struct Pooled<T: Poolable> {
 }
 
 impl<T: Poolable> Pooled<T> {
-    pub fn is_reused(&self) -> bool {
+    pub(super) fn is_reused(&self) -> bool {
         self.is_reused
     }
 
-    pub fn is_pool_enabled(&self) -> bool {
+    pub(super) fn is_pool_enabled(&self) -> bool {
         self.pool.0.is_some()
     }
 
diff --git a/src/common/date.rs b/src/common/date.rs
index e8f9f702..a436fc07 100644
--- a/src/common/date.rs
+++ b/src/common/date.rs
@@ -8,17 +8,17 @@ use http::header::HeaderValue;
 use httpdate::HttpDate;
 
 // "Sun, 06 Nov 1994 08:49:37 GMT".len()
-pub const DATE_VALUE_LENGTH: usize = 29;
+pub(crate) const DATE_VALUE_LENGTH: usize = 29;
 
 #[cfg(feature = "http1")]
-pub fn extend(dst: &mut Vec<u8>) {
+pub(crate) fn extend(dst: &mut Vec<u8>) {
     CACHED.with(|cache| {
         dst.extend_from_slice(cache.borrow().buffer());
     })
 }
 
 #[cfg(feature = "http1")]
-pub fn update() {
+pub(crate) fn update() {
     CACHED.with(|cache| {
         cache.borrow_mut().check();
     })
diff --git a/src/common/drain.rs b/src/common/drain.rs
index 4f04fd61..4bb2ecc1 100644
--- a/src/common/drain.rs
+++ b/src/common/drain.rs
@@ -5,19 +5,19 @@ use tokio::sync::watch;
 
 use super::{task, Future, Pin, Poll};
 
-pub fn channel() -> (Signal, Watch) {
+pub(crate) fn channel() -> (Signal, Watch) {
     let (tx, rx) = watch::channel(());
     (Signal { tx }, Watch { rx })
 }
 
-pub struct Signal {
+pub(crate) struct Signal {
     tx: watch::Sender<()>,
 }
 
-pub struct Draining(Pin<Box<dyn Future<Output = ()> + Send + Sync>>);
+pub(crate) struct Draining(Pin<Box<dyn Future<Output = ()> + Send + Sync>>);
 
 #[derive(Clone)]
-pub struct Watch {
+pub(crate) struct Watch {
     rx: watch::Receiver<()>,
 }
 
@@ -37,7 +37,7 @@ enum State<F> {
 }
 
 impl Signal {
-    pub fn drain(self) -> Draining {
+    pub(crate) fn drain(self) -> Draining {
         let _ = self.tx.send(());
         Draining(Box::pin(async move { self.tx.closed().await }))
     }
@@ -52,7 +52,7 @@ impl Future for Draining {
 }
 
 impl Watch {
-    pub fn watch<F, FN>(self, future: F, on_drain: FN) -> Watching<F, FN>
+    pub(crate) fn watch<F, FN>(self, future: F, on_drain: FN) -> Watching<F, FN>
     where
         F: Future,
         FN: FnOnce(Pin<&mut F>),
diff --git a/src/common/exec.rs b/src/common/exec.rs
index 169a202a..c52482a3 100644
--- a/src/common/exec.rs
+++ b/src/common/exec.rs
@@ -24,7 +24,7 @@ pub trait NewSvcExec<I, N, S: HttpService<Body>, E, W: Watcher<I, S, E>>: Clone
     fn execute_new_svc(&mut self, fut: NewSvcTask<I, N, S, E, W>);
 }
 
-pub type BoxSendFuture = Pin<Box<dyn Future<Output = ()> + Send>>;
+pub(crate) type BoxSendFuture = Pin<Box<dyn Future<Output = ()> + Send>>;
 
 // Either the user provides an executor for background tasks, or we use
 // `tokio::spawn`.
diff --git a/src/common/mod.rs b/src/common/mod.rs
index 4b1233bf..a5947315 100644
--- a/src/common/mod.rs
+++ b/src/common/mod.rs
@@ -29,7 +29,13 @@ pub(crate) mod watch;
 #[cfg(any(feature = "http1", feature = "http2"))]
 #[cfg(feature = "client")]
 pub(crate) use self::lazy::{lazy, Started as Lazy};
-pub use self::never::Never;
+#[cfg(any(
+    feature = "client",
+    feature = "http1",
+    feature = "http2",
+    feature = "runtime"
+))]
+pub(crate) use self::never::Never;
 pub(crate) use self::task::Poll;
 
 // group up types normally needed for `Future`
diff --git a/src/common/never.rs b/src/common/never.rs
index f4fdb95d..f143caf6 100644
--- a/src/common/never.rs
+++ b/src/common/never.rs
@@ -6,7 +6,7 @@ use std::error::Error;
 use std::fmt;
 
 #[derive(Debug)]
-pub enum Never {}
+pub(crate) enum Never {}
 
 impl fmt::Display for Never {
     fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {
diff --git a/src/common/sync_wrapper.rs b/src/common/sync_wrapper.rs
index 1e4aa403..05b11e2c 100644
--- a/src/common/sync_wrapper.rs
+++ b/src/common/sync_wrapper.rs
@@ -46,7 +46,7 @@
 /// [`poll`]: https://doc.rust-lang.org/std/future/trait.Future.html#method.poll
 /// [`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html
 #[repr(transparent)]
-pub struct SyncWrapper<T>(T);
+pub(crate) struct SyncWrapper<T>(T);
 
 impl<T> SyncWrapper<T> {
     /// Creates a new SyncWrapper containing the given value.
@@ -58,7 +58,7 @@ impl<T> SyncWrapper<T> {
     ///
     /// let wrapped = SyncWrapper::new(42);
     /// ```
-    pub fn new(value: T) -> Self {
+    pub(crate) fn new(value: T) -> Self {
         Self(value)
     }
 
@@ -82,7 +82,7 @@ impl<T> SyncWrapper<T> {
     /// *value = 0;
     /// assert_eq!(*wrapped.get_mut(), 0);
     /// ```
-    pub fn get_mut(&mut self) -> &mut T {
+    pub(crate) fn get_mut(&mut self) -> &mut T {
         &mut self.0
     }
 
@@ -105,7 +105,7 @@ impl<T> SyncWrapper<T> {
     /// assert_eq!(wrapped.into_inner(), 42);
     /// ```
     #[allow(dead_code)]
-    pub fn into_inner(self) -> T {
+    pub(crate) fn into_inner(self) -> T {
         self.0
     }
 }
diff --git a/src/error.rs b/src/error.rs
index 68b042f0..663156e0 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -18,7 +18,7 @@ struct ErrorImpl {
 }
 
 #[derive(Debug, PartialEq)]
-pub(crate) enum Kind {
+pub(super) enum Kind {
     Parse(Parse),
     User(User),
     /// A message reached EOF, but is not complete.
@@ -64,7 +64,7 @@ pub(crate) enum Kind {
 }
 
 #[derive(Debug, PartialEq)]
-pub(crate) enum Parse {
+pub(super) enum Parse {
     Method,
     Version,
     #[cfg(feature = "http1")]
@@ -76,7 +76,7 @@ pub(crate) enum Parse {
 }
 
 #[derive(Debug, PartialEq)]
-pub(crate) enum User {
+pub(super) enum User {
     /// Error calling user's HttpBody::poll_data().
     #[cfg(any(feature = "http1", feature = "http2"))]
     Body,
@@ -124,7 +124,7 @@ pub(crate) enum User {
 
 // Sentinel type to indicate the error was caused by a timeout.
 #[derive(Debug)]
-pub(crate) struct TimedOut;
+pub(super) struct TimedOut;
 
 impl Error {
     /// Returns true if this was an HTTP parse error.
@@ -172,19 +172,19 @@ impl Error {
         self.inner.cause
     }
 
-    pub(crate) fn new(kind: Kind) -> Error {
+    pub(super) fn new(kind: Kind) -> Error {
         Error {
             inner: Box::new(ErrorImpl { kind, cause: None }),
         }
     }
 
-    pub(crate) fn with<C: Into<Cause>>(mut self, cause: C) -> Error {
+    pub(super) fn with<C: Into<Cause>>(mut self, cause: C) -> Error {
         self.inner.cause = Some(cause.into());
         self
     }
 
     #[cfg(any(all(feature = "http1", feature = "server"), feature = "ffi"))]
-    pub(crate) fn kind(&self) -> &Kind {
+    pub(super) fn kind(&self) -> &Kind {
         &self.inner.kind
     }
 
@@ -202,7 +202,7 @@ impl Error {
     }
 
     #[cfg(feature = "http2")]
-    pub(crate) fn h2_reason(&self) -> h2::Reason {
+    pub(super) fn h2_reason(&self) -> h2::Reason {
         // Find an h2::Reason somewhere in the cause stack, if it exists,
         // otherwise assume an INTERNAL_ERROR.
         self.find_source::<h2::Error>()
@@ -210,68 +210,68 @@ impl Error {
             .unwrap_or(h2::Reason::INTERNAL_ERROR)
     }
 
-    pub(crate) fn new_canceled() -> Error {
+    pub(super) fn new_canceled() -> Error {
         Error::new(Kind::Canceled)
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn new_incomplete() -> Error {
+    pub(super) fn new_incomplete() -> Error {
         Error::new(Kind::IncompleteMessage)
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn new_too_large() -> Error {
+    pub(super) fn new_too_large() -> Error {
         Error::new(Kind::Parse(Parse::TooLarge))
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn new_version_h2() -> Error {
+    pub(super) fn new_version_h2() -> Error {
         Error::new(Kind::Parse(Parse::VersionH2))
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn new_unexpected_message() -> Error {
+    pub(super) fn new_unexpected_message() -> Error {
         Error::new(Kind::UnexpectedMessage)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
-    pub(crate) fn new_io(cause: std::io::Error) -> Error {
+    pub(super) fn new_io(cause: std::io::Error) -> Error {
         Error::new(Kind::Io).with(cause)
     }
 
     #[cfg(all(any(feature = "http1", feature = "http2"), feature = "tcp"))]
     #[cfg(feature = "server")]
-    pub(crate) fn new_listen<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_listen<E: Into<Cause>>(cause: E) -> Error {
         Error::new(Kind::Listen).with(cause)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
     #[cfg(feature = "server")]
-    pub(crate) fn new_accept<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_accept<E: Into<Cause>>(cause: E) -> Error {
         Error::new(Kind::Accept).with(cause)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
     #[cfg(feature = "client")]
-    pub(crate) fn new_connect<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_connect<E: Into<Cause>>(cause: E) -> Error {
         Error::new(Kind::Connect).with(cause)
     }
 
-    pub(crate) fn new_closed() -> Error {
+    pub(super) fn new_closed() -> Error {
         Error::new(Kind::ChannelClosed)
     }
 
     #[cfg(any(feature = "http1", feature = "http2", feature = "stream"))]
-    pub(crate) fn new_body<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_body<E: Into<Cause>>(cause: E) -> Error {
         Error::new(Kind::Body).with(cause)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
-    pub(crate) fn new_body_write<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_body_write<E: Into<Cause>>(cause: E) -> Error {
         Error::new(Kind::BodyWrite).with(cause)
     }
 
-    pub(crate) fn new_body_write_aborted() -> Error {
+    pub(super) fn new_body_write_aborted() -> Error {
         Error::new(Kind::BodyWriteAborted)
     }
 
@@ -281,71 +281,71 @@ impl Error {
 
     #[cfg(feature = "http1")]
     #[cfg(feature = "server")]
-    pub(crate) fn new_user_header() -> Error {
+    pub(super) fn new_user_header() -> Error {
         Error::new_user(User::UnexpectedHeader)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
     #[cfg(feature = "client")]
-    pub(crate) fn new_user_unsupported_version() -> Error {
+    pub(super) fn new_user_unsupported_version() -> Error {
         Error::new_user(User::UnsupportedVersion)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
     #[cfg(feature = "client")]
-    pub(crate) fn new_user_unsupported_request_method() -> Error {
+    pub(super) fn new_user_unsupported_request_method() -> Error {
         Error::new_user(User::UnsupportedRequestMethod)
     }
 
     #[cfg(feature = "http1")]
     #[cfg(feature = "server")]
-    pub(crate) fn new_user_unsupported_status_code() -> Error {
+    pub(super) fn new_user_unsupported_status_code() -> Error {
         Error::new_user(User::UnsupportedStatusCode)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
     #[cfg(feature = "client")]
-    pub(crate) fn new_user_absolute_uri_required() -> Error {
+    pub(super) fn new_user_absolute_uri_required() -> Error {
         Error::new_user(User::AbsoluteUriRequired)
     }
 
-    pub(crate) fn new_user_no_upgrade() -> Error {
+    pub(super) fn new_user_no_upgrade() -> Error {
         Error::new_user(User::NoUpgrade)
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn new_user_manual_upgrade() -> Error {
+    pub(super) fn new_user_manual_upgrade() -> Error {
         Error::new_user(User::ManualUpgrade)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
     #[cfg(feature = "server")]
-    pub(crate) fn new_user_make_service<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_user_make_service<E: Into<Cause>>(cause: E) -> Error {
         Error::new_user(User::MakeService).with(cause)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
-    pub(crate) fn new_user_service<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_user_service<E: Into<Cause>>(cause: E) -> Error {
         Error::new_user(User::Service).with(cause)
     }
 
     #[cfg(any(feature = "http1", feature = "http2"))]
-    pub(crate) fn new_user_body<E: Into<Cause>>(cause: E) -> Error {
+    pub(super) fn new_user_body<E: Into<Cause>>(cause: E) -> Error {
         Error::new_user(User::Body).with(cause)
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn new_shutdown(cause: std::io::Error) -> Error {
+    pub(super) fn new_shutdown(cause: std::io::Error) -> Error {
         Error::new(Kind::Shutdown).with(cause)
     }
 
     #[cfg(feature = "ffi")]
-    pub(crate) fn new_user_aborted_by_callback() -> Error {
+    pub(super) fn new_user_aborted_by_callback() -> Error {
         Error::new_user(User::AbortedByCallback)
     }
 
     #[cfg(feature = "http2")]
-    pub(crate) fn new_h2(cause: ::h2::Error) -> Error {
+    pub(super) fn new_h2(cause: ::h2::Error) -> Error {
         if cause.is_io() {
             Error::new_io(cause.into_io().expect("h2::Error::is_io"))
         } else {
diff --git a/src/ffi/mod.rs b/src/ffi/mod.rs
index 423a0776..b593c89d 100644
--- a/src/ffi/mod.rs
+++ b/src/ffi/mod.rs
@@ -1,5 +1,7 @@
 // We have a lot of c-types in here, stop warning about their names!
 #![allow(non_camel_case_types)]
+// unreachable_pub warns `#[no_mangle] pub extern fn` in private mod.
+#![allow(unreachable_pub)]
 
 // We may eventually allow the FFI to be enabled without `client` or `http1`,
 // that is why we don't auto enable them as `ffi = ["client", "http1"]` in
diff --git a/src/headers.rs b/src/headers.rs
index 8e06fd4b..897aa05d 100644
--- a/src/headers.rs
+++ b/src/headers.rs
@@ -8,12 +8,12 @@ use http::Method;
 use http::HeaderMap;
 
 #[cfg(feature = "http1")]
-pub fn connection_keep_alive(value: &HeaderValue) -> bool {
+pub(super) fn connection_keep_alive(value: &HeaderValue) -> bool {
     connection_has(value, "keep-alive")
 }
 
 #[cfg(feature = "http1")]
-pub fn connection_close(value: &HeaderValue) -> bool {
+pub(super) fn connection_close(value: &HeaderValue) -> bool {
     connection_has(value, "close")
 }
 
@@ -31,15 +31,15 @@ fn connection_has(value: &HeaderValue, needle: &str) -> bool {
 
 #[cfg(feature = "http1")]
 #[cfg(feature = "server")]
-pub fn content_length_parse(value: &HeaderValue) -> Option<u64> {
+pub(super) fn content_length_parse(value: &HeaderValue) -> Option<u64> {
     value.to_str().ok().and_then(|s| s.parse().ok())
 }
 
-pub fn content_length_parse_all(headers: &HeaderMap) -> Option<u64> {
+pub(super) fn content_length_parse_all(headers: &HeaderMap) -> Option<u64> {
     content_length_parse_all_values(headers.get_all(CONTENT_LENGTH).into_iter())
 }
 
-pub fn content_length_parse_all_values(values: ValueIter<'_, HeaderValue>) -> Option<u64> {
+pub(super) fn content_length_parse_all_values(values: ValueIter<'_, HeaderValue>) -> Option<u64> {
     // If multiple Content-Length headers were sent, everything can still
     // be alright if they all contain the same value, and all parse
     // correctly. If not, then it's an error.
@@ -68,7 +68,7 @@ pub fn content_length_parse_all_values(values: ValueIter<'_, HeaderValue>) -> Op
 
 #[cfg(feature = "http2")]
 #[cfg(feature = "client")]
-pub fn method_has_defined_payload_semantics(method: &Method) -> bool {
+pub(super) fn method_has_defined_payload_semantics(method: &Method) -> bool {
     match *method {
         Method::GET | Method::HEAD | Method::DELETE | Method::CONNECT => false,
         _ => true,
@@ -76,19 +76,19 @@ pub fn method_has_defined_payload_semantics(method: &Method) -> bool {
 }
 
 #[cfg(feature = "http2")]
-pub fn set_content_length_if_missing(headers: &mut HeaderMap, len: u64) {
+pub(super) fn set_content_length_if_missing(headers: &mut HeaderMap, len: u64) {
     headers
         .entry(CONTENT_LENGTH)
         .or_insert_with(|| HeaderValue::from(len));
 }
 
 #[cfg(feature = "http1")]
-pub fn transfer_encoding_is_chunked(headers: &HeaderMap) -> bool {
+pub(super) fn transfer_encoding_is_chunked(headers: &HeaderMap) -> bool {
     is_chunked(headers.get_all(http::header::TRANSFER_ENCODING).into_iter())
 }
 
 #[cfg(feature = "http1")]
-pub fn is_chunked(mut encodings: ValueIter<'_, HeaderValue>) -> bool {
+pub(super) fn is_chunked(mut encodings: ValueIter<'_, HeaderValue>) -> bool {
     // chunked must always be the last encoding, according to spec
     if let Some(line) = encodings.next_back() {
         return is_chunked_(line);
@@ -98,7 +98,7 @@ pub fn is_chunked(mut encodings: ValueIter<'_, HeaderValue>) -> bool {
 }
 
 #[cfg(feature = "http1")]
-pub fn is_chunked_(value: &HeaderValue) -> bool {
+pub(super) fn is_chunked_(value: &HeaderValue) -> bool {
     // chunked must always be the last encoding, according to spec
     if let Ok(s) = value.to_str() {
         if let Some(encoding) = s.rsplit(',').next() {
@@ -110,7 +110,7 @@ pub fn is_chunked_(value: &HeaderValue) -> bool {
 }
 
 #[cfg(feature = "http1")]
-pub fn add_chunked(mut entry: http::header::OccupiedEntry<'_, HeaderValue>) {
+pub(super) fn add_chunked(mut entry: http::header::OccupiedEntry<'_, HeaderValue>) {
     const CHUNKED: &str = "chunked";
 
     if let Some(line) = entry.iter_mut().next_back() {
diff --git a/src/lib.rs b/src/lib.rs
index e9b04229..8b16e312 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -2,6 +2,7 @@
 #![deny(missing_docs)]
 #![deny(missing_debug_implementations)]
 #![cfg_attr(test, deny(rust_2018_idioms))]
+#![cfg_attr(all(test, feature = "full"), deny(unreachable_pub))]
 #![cfg_attr(test, deny(warnings))]
 #![cfg_attr(all(test, feature = "nightly"), feature(test))]
 #![cfg_attr(docsrs, feature(doc_cfg))]
diff --git a/src/proto/h1/conn.rs b/src/proto/h1/conn.rs
index 9866e133..174a1d86 100644
--- a/src/proto/h1/conn.rs
+++ b/src/proto/h1/conn.rs
@@ -35,7 +35,7 @@ where
     B: Buf,
     T: Http1Transaction,
 {
-    pub fn new(io: I) -> Conn<I, B, T> {
+    pub(crate) fn new(io: I) -> Conn<I, B, T> {
         Conn {
             io: Buffered::new(io),
             state: State {
@@ -60,21 +60,21 @@ where
     }
 
     #[cfg(feature = "server")]
-    pub fn set_flush_pipeline(&mut self, enabled: bool) {
+    pub(crate) fn set_flush_pipeline(&mut self, enabled: bool) {
         self.io.set_flush_pipeline(enabled);
     }
 
-    pub fn set_max_buf_size(&mut self, max: usize) {
+    pub(crate) fn set_max_buf_size(&mut self, max: usize) {
         self.io.set_max_buf_size(max);
     }
 
     #[cfg(feature = "client")]
-    pub fn set_read_buf_exact_size(&mut self, sz: usize) {
+    pub(crate) fn set_read_buf_exact_size(&mut self, sz: usize) {
         self.io.set_read_buf_exact_size(sz);
     }
 
     #[cfg(feature = "client")]
-    pub fn set_title_case_headers(&mut self) {
+    pub(crate) fn set_title_case_headers(&mut self) {
         self.state.title_case_headers = true;
     }
 
@@ -83,23 +83,23 @@ where
         self.state.allow_half_close = true;
     }
 
-    pub fn into_inner(self) -> (I, Bytes) {
+    pub(crate) fn into_inner(self) -> (I, Bytes) {
         self.io.into_inner()
     }
 
-    pub fn pending_upgrade(&mut self) -> Option<crate::upgrade::Pending> {
+    pub(crate) fn pending_upgrade(&mut self) -> Option<crate::upgrade::Pending> {
         self.state.upgrade.take()
     }
 
-    pub fn is_read_closed(&self) -> bool {
+    pub(crate) fn is_read_closed(&self) -> bool {
         self.state.is_read_closed()
     }
 
-    pub fn is_write_closed(&self) -> bool {
+    pub(crate) fn is_write_closed(&self) -> bool {
         self.state.is_write_closed()
     }
 
-    pub fn can_read_head(&self) -> bool {
+    pub(crate) fn can_read_head(&self) -> bool {
         match self.state.reading {
             Reading::Init => {
                 if T::should_read_first() {
@@ -115,7 +115,7 @@ where
         }
     }
 
-    pub fn can_read_body(&self) -> bool {
+    pub(crate) fn can_read_body(&self) -> bool {
         match self.state.reading {
             Reading::Body(..) | Reading::Continue(..) => true,
             _ => false,
@@ -211,7 +211,7 @@ where
         }
     }
 
-    pub fn poll_read_body(
+    pub(crate) fn poll_read_body(
         &mut self,
         cx: &mut task::Context<'_>,
     ) -> Poll<Option<io::Result<Bytes>>> {
@@ -268,13 +268,13 @@ where
         ret
     }
 
-    pub fn wants_read_again(&mut self) -> bool {
+    pub(crate) fn wants_read_again(&mut self) -> bool {
         let ret = self.state.notify_read;
         self.state.notify_read = false;
         ret
     }
 
-    pub fn poll_read_keep_alive(&mut self, cx: &mut task::Context<'_>) -> Poll<crate::Result<()>> {
+    pub(crate) fn poll_read_keep_alive(&mut self, cx: &mut task::Context<'_>) -> Poll<crate::Result<()>> {
         debug_assert!(!self.can_read_head() && !self.can_read_body());
 
         if self.is_read_closed() {
@@ -412,7 +412,7 @@ where
         self.maybe_notify(cx);
     }
 
-    pub fn can_write_head(&self) -> bool {
+    pub(crate) fn can_write_head(&self) -> bool {
         if !T::should_read_first() {
             if let Reading::Closed = self.state.reading {
                 return false;
@@ -424,18 +424,18 @@ where
         }
     }
 
-    pub fn can_write_body(&self) -> bool {
+    pub(crate) fn can_write_body(&self) -> bool {
         match self.state.writing {
             Writing::Body(..) => true,
             Writing::Init | Writing::KeepAlive | Writing::Closed => false,
         }
     }
 
-    pub fn can_buffer_body(&self) -> bool {
+    pub(crate) fn can_buffer_body(&self) -> bool {
         self.io.can_buffer()
     }
 
-    pub fn write_head(&mut self, head: MessageHead<T::Outgoing>, body: Option<BodyLength>) {
+    pub(crate) fn write_head(&mut self, head: MessageHead<T::Outgoing>, body: Option<BodyLength>) {
         if let Some(encoder) = self.encode_head(head, body) {
             self.state.writing = if !encoder.is_eof() {
                 Writing::Body(encoder)
@@ -447,7 +447,7 @@ where
         }
     }
 
-    pub fn write_full_msg(&mut self, head: MessageHead<T::Outgoing>, body: B) {
+    pub(crate) fn write_full_msg(&mut self, head: MessageHead<T::Outgoing>, body: B) {
         if let Some(encoder) =
             self.encode_head(head, Some(BodyLength::Known(body.remaining() as u64)))
         {
@@ -555,7 +555,7 @@ where
         // the user's headers be.
     }
 
-    pub fn write_body(&mut self, chunk: B) {
+    pub(crate) fn write_body(&mut self, chunk: B) {
         debug_assert!(self.can_write_body() && self.can_buffer_body());
         // empty chunks should be discarded at Dispatcher level
         debug_assert!(chunk.remaining() != 0);
@@ -580,7 +580,7 @@ where
         self.state.writing = state;
     }
 
-    pub fn write_body_and_end(&mut self, chunk: B) {
+    pub(crate) fn write_body_and_end(&mut self, chunk: B) {
         debug_assert!(self.can_write_body() && self.can_buffer_body());
         // empty chunks should be discarded at Dispatcher level
         debug_assert!(chunk.remaining() != 0);
@@ -600,7 +600,7 @@ where
         self.state.writing = state;
     }
 
-    pub fn end_body(&mut self) -> crate::Result<()> {
+    pub(crate) fn end_body(&mut self) -> crate::Result<()> {
         debug_assert!(self.can_write_body());
 
         let mut res = Ok(());
@@ -657,14 +657,14 @@ where
         Err(err)
     }
 
-    pub fn poll_flush(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
+    pub(crate) fn poll_flush(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
         ready!(Pin::new(&mut self.io).poll_flush(cx))?;
         self.try_keep_alive(cx);
         trace!("flushed({}): {:?}", T::LOG, self.state);
         Poll::Ready(Ok(()))
     }
 
-    pub fn poll_shutdown(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
+    pub(crate) fn poll_shutdown(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
         match ready!(Pin::new(self.io.io_mut()).poll_shutdown(cx)) {
             Ok(()) => {
                 trace!("shut down IO complete");
@@ -691,16 +691,16 @@ where
         }
     }
 
-    pub fn close_read(&mut self) {
+    pub(crate) fn close_read(&mut self) {
         self.state.close_read();
     }
 
-    pub fn close_write(&mut self) {
+    pub(crate) fn close_write(&mut self) {
         self.state.close_write();
     }
 
     #[cfg(feature = "server")]
-    pub fn disable_keep_alive(&mut self) {
+    pub(crate) fn disable_keep_alive(&mut self) {
         if self.state.is_idle() {
             trace!("disable_keep_alive; closing idle connection");
             self.state.close();
@@ -710,7 +710,7 @@ where
         }
     }
 
-    pub fn take_error(&mut self) -> crate::Result<()> {
+    pub(crate) fn take_error(&mut self) -> crate::Result<()> {
         if let Some(err) = self.state.error.take() {
             Err(err)
         } else {
diff --git a/src/proto/h1/decode.rs b/src/proto/h1/decode.rs
index 73b5dd4d..4d270778 100644
--- a/src/proto/h1/decode.rs
+++ b/src/proto/h1/decode.rs
@@ -17,7 +17,7 @@ use self::Kind::{Chunked, Eof, Length};
 /// If a message body does not include a Transfer-Encoding, it *should*
 /// include a Content-Length header.
 #[derive(Clone, PartialEq)]
-pub struct Decoder {
+pub(crate) struct Decoder {
     kind: Kind,
 }
 
@@ -65,19 +65,19 @@ enum ChunkedState {
 impl Decoder {
     // constructors
 
-    pub fn length(x: u64) -> Decoder {
+    pub(crate) fn length(x: u64) -> Decoder {
         Decoder {
             kind: Kind::Length(x),
         }
     }
 
-    pub fn chunked() -> Decoder {
+    pub(crate) fn chunked() -> Decoder {
         Decoder {
             kind: Kind::Chunked(ChunkedState::Size, 0),
         }
     }
 
-    pub fn eof() -> Decoder {
+    pub(crate) fn eof() -> Decoder {
         Decoder {
             kind: Kind::Eof(false),
         }
@@ -93,11 +93,11 @@ impl Decoder {
 
     // methods
 
-    pub fn is_eof(&self) -> bool {
+    pub(crate) fn is_eof(&self) -> bool {
         matches!(self.kind, Length(0) | Chunked(ChunkedState::End, _) | Eof(true))
     }
 
-    pub fn decode<R: MemRead>(
+    pub(crate) fn decode<R: MemRead>(
         &mut self,
         cx: &mut task::Context<'_>,
         body: &mut R,
diff --git a/src/proto/h1/dispatch.rs b/src/proto/h1/dispatch.rs
index 8bbb0333..39f457ef 100644
--- a/src/proto/h1/dispatch.rs
+++ b/src/proto/h1/dispatch.rs
@@ -37,7 +37,7 @@ pub(crate) trait Dispatch {
 cfg_server! {
     use crate::service::HttpService;
 
-    pub struct Server<S: HttpService<B>, B> {
+    pub(crate) struct Server<S: HttpService<B>, B> {
         in_flight: Pin<Box<Option<S::Future>>>,
         pub(crate) service: S,
     }
@@ -45,7 +45,7 @@ cfg_server! {
 
 cfg_client! {
     #[pin_project::pin_project]
-    pub struct Client<B> {
+    pub(crate) struct Client<B> {
         callback: Option<crate::client::dispatch::Callback<Request<B>, http::Response<Body>>>,
         #[pin]
         rx: ClientRx<B>,
@@ -68,7 +68,7 @@ where
     Bs: HttpBody + 'static,
     Bs::Error: Into<Box<dyn StdError + Send + Sync>>,
 {
-    pub fn new(dispatch: D, conn: Conn<I, Bs::Data, T>) -> Self {
+    pub(crate) fn new(dispatch: D, conn: Conn<I, Bs::Data, T>) -> Self {
         Dispatcher {
             conn,
             dispatch,
@@ -79,14 +79,14 @@ where
     }
 
     #[cfg(feature = "server")]
-    pub fn disable_keep_alive(&mut self) {
+    pub(crate) fn disable_keep_alive(&mut self) {
         self.conn.disable_keep_alive();
         if self.conn.is_write_closed() {
             self.close();
         }
     }
 
-    pub fn into_inner(self) -> (I, Bytes, D) {
+    pub(crate) fn into_inner(self) -> (I, Bytes, D) {
         let (io, buf) = self.conn.into_inner();
         (io, buf, self.dispatch)
     }
@@ -454,14 +454,14 @@ cfg_server! {
     where
         S: HttpService<B>,
     {
-        pub fn new(service: S) -> Server<S, B> {
+        pub(crate) fn new(service: S) -> Server<S, B> {
             Server {
                 in_flight: Box::pin(None),
                 service,
             }
         }
 
-        pub fn into_service(self) -> S {
+        pub(crate) fn into_service(self) -> S {
             self.service
         }
     }
@@ -538,7 +538,7 @@ cfg_server! {
 
 cfg_client! {
     impl<B> Client<B> {
-        pub fn new(rx: ClientRx<B>) -> Client<B> {
+        pub(crate) fn new(rx: ClientRx<B>) -> Client<B> {
             Client {
                 callback: None,
                 rx,
diff --git a/src/proto/h1/encode.rs b/src/proto/h1/encode.rs
index c8ed99bb..6a370399 100644
--- a/src/proto/h1/encode.rs
+++ b/src/proto/h1/encode.rs
@@ -10,18 +10,18 @@ type StaticBuf = &'static [u8];
 
 /// Encoders to handle different Transfer-Encodings.
 #[derive(Debug, Clone, PartialEq)]
-pub struct Encoder {
+pub(crate) struct Encoder {
     kind: Kind,
     is_last: bool,
 }
 
 #[derive(Debug)]
-pub struct EncodedBuf<B> {
+pub(crate) struct EncodedBuf<B> {
     kind: BufKind<B>,
 }
 
 #[derive(Debug)]
-pub struct NotEof;
+pub(crate) struct NotEof;
 
 #[derive(Debug, PartialEq, Clone)]
 enum Kind {
@@ -54,34 +54,34 @@ impl Encoder {
             is_last: false,
         }
     }
-    pub fn chunked() -> Encoder {
+    pub(crate) fn chunked() -> Encoder {
         Encoder::new(Kind::Chunked)
     }
 
-    pub fn length(len: u64) -> Encoder {
+    pub(crate) fn length(len: u64) -> Encoder {
         Encoder::new(Kind::Length(len))
     }
 
     #[cfg(feature = "server")]
-    pub fn close_delimited() -> Encoder {
+    pub(crate) fn close_delimited() -> Encoder {
         Encoder::new(Kind::CloseDelimited)
     }
 
-    pub fn is_eof(&self) -> bool {
+    pub(crate) fn is_eof(&self) -> bool {
         matches!(self.kind, Kind::Length(0))
     }
 
     #[cfg(feature = "server")]
-    pub fn set_last(mut self, is_last: bool) -> Self {
+    pub(crate) fn set_last(mut self, is_last: bool) -> Self {
         self.is_last = is_last;
         self
     }
 
-    pub fn is_last(&self) -> bool {
+    pub(crate) fn is_last(&self) -> bool {
         self.is_last
     }
 
-    pub fn is_close_delimited(&self) -> bool {
+    pub(crate) fn is_close_delimited(&self) -> bool {
         match self.kind {
             #[cfg(feature = "server")]
             Kind::CloseDelimited => true,
@@ -89,7 +89,7 @@ impl Encoder {
         }
     }
 
-    pub fn end<B>(&self) -> Result<Option<EncodedBuf<B>>, NotEof> {
+    pub(crate) fn end<B>(&self) -> Result<Option<EncodedBuf<B>>, NotEof> {
         match self.kind {
             Kind::Length(0) => Ok(None),
             Kind::Chunked => Ok(Some(EncodedBuf {
@@ -101,7 +101,7 @@ impl Encoder {
         }
     }
 
-    pub fn encode<B>(&mut self, msg: B) -> EncodedBuf<B>
+    pub(crate) fn encode<B>(&mut self, msg: B) -> EncodedBuf<B>
     where
         B: Buf,
     {
diff --git a/src/proto/h1/io.rs b/src/proto/h1/io.rs
index da0ff820..5536b5d1 100644
--- a/src/proto/h1/io.rs
+++ b/src/proto/h1/io.rs
@@ -15,7 +15,7 @@ use crate::common::{task, Pin, Poll};
 pub(crate) const INIT_BUFFER_SIZE: usize = 8192;
 
 /// The minimum value that can be set to max buffer size.
-pub const MINIMUM_MAX_BUFFER_SIZE: usize = INIT_BUFFER_SIZE;
+pub(crate) const MINIMUM_MAX_BUFFER_SIZE: usize = INIT_BUFFER_SIZE;
 
 /// The default maximum read buffer size. If the buffer gets this big and
 /// a message is still not complete, a `TooLarge` error is triggered.
@@ -29,7 +29,7 @@ pub(crate) const DEFAULT_MAX_BUFFER_SIZE: usize = 8192 + 4096 * 100;
 /// forces a flush if the queue gets this big.
 const MAX_BUF_LIST_BUFFERS: usize = 16;
 
-pub struct Buffered<T, B> {
+pub(crate) struct Buffered<T, B> {
     flush_pipeline: bool,
     io: T,
     read_blocked: bool,
@@ -55,7 +55,7 @@ where
     T: AsyncRead + AsyncWrite + Unpin,
     B: Buf,
 {
-    pub fn new(io: T) -> Buffered<T, B> {
+    pub(crate) fn new(io: T) -> Buffered<T, B> {
         let write_buf = WriteBuf::new(&io);
         Buffered {
             flush_pipeline: false,
@@ -68,7 +68,7 @@ where
     }
 
     #[cfg(feature = "server")]
-    pub fn set_flush_pipeline(&mut self, enabled: bool) {
+    pub(crate) fn set_flush_pipeline(&mut self, enabled: bool) {
         debug_assert!(!self.write_buf.has_remaining());
         self.flush_pipeline = enabled;
         if enabled {
@@ -76,7 +76,7 @@ where
         }
     }
 
-    pub fn set_max_buf_size(&mut self, max: usize) {
+    pub(crate) fn set_max_buf_size(&mut self, max: usize) {
         assert!(
             max >= MINIMUM_MAX_BUFFER_SIZE,
             "The max_buf_size cannot be smaller than {}.",
@@ -87,19 +87,19 @@ where
     }
 
     #[cfg(feature = "client")]
-    pub fn set_read_buf_exact_size(&mut self, sz: usize) {
+    pub(crate) fn set_read_buf_exact_size(&mut self, sz: usize) {
         self.read_buf_strategy = ReadStrategy::Exact(sz);
     }
 
     #[cfg(feature = "server")]
-    pub fn set_write_strategy_flatten(&mut self) {
+    pub(crate) fn set_write_strategy_flatten(&mut self) {
         // this should always be called only at construction time,
         // so this assert is here to catch myself
         debug_assert!(self.write_buf.queue.bufs_cnt() == 0);
         self.write_buf.set_strategy(WriteStrategy::Flatten);
     }
 
-    pub fn read_buf(&self) -> &[u8] {
+    pub(crate) fn read_buf(&self) -> &[u8] {
         self.read_buf.as_ref()
     }
 
@@ -115,7 +115,7 @@ where
         self.read_buf.capacity() - self.read_buf.len()
     }
 
-    pub fn headers_buf(&mut self) -> &mut Vec<u8> {
+    pub(crate) fn headers_buf(&mut self) -> &mut Vec<u8> {
         let buf = self.write_buf.headers_mut();
         &mut buf.bytes
     }
@@ -124,15 +124,15 @@ where
         &mut self.write_buf
     }
 
-    pub fn buffer<BB: Buf + Into<B>>(&mut self, buf: BB) {
+    pub(crate) fn buffer<BB: Buf + Into<B>>(&mut self, buf: BB) {
         self.write_buf.buffer(buf)
     }
 
-    pub fn can_buffer(&self) -> bool {
+    pub(crate) fn can_buffer(&self) -> bool {
         self.flush_pipeline || self.write_buf.can_buffer()
     }
 
-    pub fn consume_leading_lines(&mut self) {
+    pub(crate) fn consume_leading_lines(&mut self) {
         if !self.read_buf.is_empty() {
             let mut i = 0;
             while i < self.read_buf.len() {
@@ -182,7 +182,7 @@ where
         }
     }
 
-    pub fn poll_read_from_io(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<usize>> {
+    pub(crate) fn poll_read_from_io(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<usize>> {
         self.read_blocked = false;
         let next = self.read_buf_strategy.next();
         if self.read_buf_remaining_mut() < next {
@@ -212,19 +212,19 @@ where
         }
     }
 
-    pub fn into_inner(self) -> (T, Bytes) {
+    pub(crate) fn into_inner(self) -> (T, Bytes) {
         (self.io, self.read_buf.freeze())
     }
 
-    pub fn io_mut(&mut self) -> &mut T {
+    pub(crate) fn io_mut(&mut self) -> &mut T {
         &mut self.io
     }
 
-    pub fn is_read_blocked(&self) -> bool {
+    pub(crate) fn is_read_blocked(&self) -> bool {
         self.read_blocked
     }
 
-    pub fn poll_flush(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
+    pub(crate) fn poll_flush(&mut self, cx: &mut task::Context<'_>) -> Poll<io::Result<()>> {
         if self.flush_pipeline && !self.read_buf.is_empty() {
             Poll::Ready(Ok(()))
         } else if self.write_buf.remaining() == 0 {
@@ -293,7 +293,7 @@ where
 impl<T: Unpin, B> Unpin for Buffered<T, B> {}
 
 // TODO: This trait is old... at least rename to PollBytes or something...
-pub trait MemRead {
+pub(crate) trait MemRead {
     fn read_mem(&mut self, cx: &mut task::Context<'_>, len: usize) -> Poll<io::Result<Bytes>>;
 }
 
@@ -402,7 +402,7 @@ impl Default for ReadStrategy {
 }
 
 #[derive(Clone)]
-pub struct Cursor<T> {
+pub(crate) struct Cursor<T> {
     bytes: T,
     pos: usize,
 }
diff --git a/src/proto/h1/mod.rs b/src/proto/h1/mod.rs
index 10aa0962..1498872e 100644
--- a/src/proto/h1/mod.rs
+++ b/src/proto/h1/mod.rs
@@ -5,11 +5,11 @@ use crate::body::DecodedLength;
 use crate::proto::{BodyLength, MessageHead};
 
 pub(crate) use self::conn::Conn;
-pub use self::decode::Decoder;
+pub(crate) use self::decode::Decoder;
 pub(crate) use self::dispatch::Dispatcher;
-pub use self::encode::{EncodedBuf, Encoder};
-pub use self::io::Cursor; //TODO: move out of h1::io
-pub use self::io::MINIMUM_MAX_BUFFER_SIZE;
+pub(crate) use self::encode::{EncodedBuf, Encoder};
+ //TODO: move out of h1::io
+pub(crate) use self::io::MINIMUM_MAX_BUFFER_SIZE;
 
 mod conn;
 mod decode;
diff --git a/src/proto/h2/server.rs b/src/proto/h2/server.rs
index 200ad9f8..eea52e3e 100644
--- a/src/proto/h2/server.rs
+++ b/src/proto/h2/server.rs
@@ -136,7 +136,7 @@ where
         }
     }
 
-    pub fn graceful_shutdown(&mut self) {
+    pub(crate) fn graceful_shutdown(&mut self) {
         trace!("graceful_shutdown");
         match self.state {
             State::Handshaking { .. } => {
diff --git a/src/proto/mod.rs b/src/proto/mod.rs
index fe2e2e92..0c86336b 100644
--- a/src/proto/mod.rs
+++ b/src/proto/mod.rs
@@ -17,33 +17,33 @@ cfg_http2! {
 
 /// An Incoming Message head. Includes request/status line, and headers.
 #[derive(Debug, Default)]
-pub struct MessageHead<S> {
+pub(crate) struct MessageHead<S> {
     /// HTTP version of the message.
-    pub version: http::Version,
+    pub(crate) version: http::Version,
     /// Subject (request line or status line) of Incoming message.
-    pub subject: S,
+    pub(crate) subject: S,
     /// Headers of the Incoming message.
-    pub headers: http::HeaderMap,
+    pub(crate) headers: http::HeaderMap,
     /// Extensions.
     extensions: http::Extensions,
 }
 
 /// An incoming request message.
 #[cfg(feature = "http1")]
-pub type RequestHead = MessageHead<RequestLine>;
+pub(crate) type RequestHead = MessageHead<RequestLine>;
 
 #[derive(Debug, Default, PartialEq)]
 #[cfg(feature = "http1")]
-pub struct RequestLine(pub http::Method, pub http::Uri);
+pub(crate) struct RequestLine(pub(crate) http::Method, pub(crate) http::Uri);
 
 /// An incoming response message.
 #[cfg(feature = "http1")]
 #[cfg(feature = "client")]
-pub type ResponseHead = MessageHead<http::StatusCode>;
+pub(crate) type ResponseHead = MessageHead<http::StatusCode>;
 
 #[derive(Debug)]
 #[cfg(feature = "http1")]
-pub enum BodyLength {
+pub(crate) enum BodyLength {
     /// Content-Length
     Known(u64),
     /// Transfer-Encoding: chunked (if h1)
diff --git a/src/server/conn.rs b/src/server/conn.rs
index b94b5054..50b84dd0 100644
--- a/src/server/conn.rs
+++ b/src/server/conn.rs
@@ -147,7 +147,7 @@ pub(super) struct SpawnAll<I, S, E> {
     //
     // See https://github.com/rust-lang/rust/issues/64705
     #[pin]
-    pub serve: Serve<I, S, E>,
+    pub(super) serve: Serve<I, S, E>,
 }
 
 /// A future binding a connection with a Service.
@@ -815,7 +815,7 @@ impl Default for ConnectionMode {
 impl<I, S, E> Serve<I, S, E> {
     /// Get a reference to the incoming stream.
     #[inline]
-    pub fn incoming_ref(&self) -> &I {
+    pub(super) fn incoming_ref(&self) -> &I {
         &self.incoming
     }
 
@@ -1025,7 +1025,7 @@ pub(crate) mod spawn_all {
     }
 
     #[pin_project(project = StateProj)]
-    pub enum State<I, N, S: HttpService<Body>, E, W: Watcher<I, S, E>> {
+    pub(super) enum State<I, N, S: HttpService<Body>, E, W: Watcher<I, S, E>> {
         Connecting(#[pin] Connecting<I, N, E>, W),
         Connected(#[pin] W::Future),
     }
diff --git a/src/server/tcp.rs b/src/server/tcp.rs
index c6cfc989..91afc401 100644
--- a/src/server/tcp.rs
+++ b/src/server/tcp.rs
@@ -8,6 +8,7 @@ use tokio::time::Sleep;
 
 use crate::common::{task, Future, Pin, Poll};
 
+#[allow(unreachable_pub)] // https://github.com/rust-lang/rust/issues/57411
 pub use self::addr_stream::AddrStream;
 use super::accept::Accept;
 
diff --git a/src/service/make.rs b/src/service/make.rs
index 074d66f1..63e6f298 100644
--- a/src/service/make.rs
+++ b/src/service/make.rs
@@ -177,6 +177,7 @@ impl<F> fmt::Debug for MakeServiceFn<F> {
 mod sealed {
     pub trait Sealed<X> {}
 
+    #[allow(unreachable_pub)] // This is intentional.
     pub trait CantImpl {}
 
     #[allow(missing_debug_implementations)]
diff --git a/src/service/mod.rs b/src/service/mod.rs
index 2c2bf3aa..5f156d46 100644
--- a/src/service/mod.rs
+++ b/src/service/mod.rs
@@ -44,16 +44,16 @@ mod make;
 mod oneshot;
 mod util;
 
-pub(crate) use self::http::HttpService;
+pub(super) use self::http::HttpService;
 #[cfg(any(feature = "http1", feature = "http2"))]
 #[cfg(feature = "client")]
-pub(crate) use self::make::MakeConnection;
+pub(super) use self::make::MakeConnection;
 #[cfg(any(feature = "http1", feature = "http2"))]
 #[cfg(feature = "server")]
-pub(crate) use self::make::MakeServiceRef;
+pub(super) use self::make::MakeServiceRef;
 #[cfg(any(feature = "http1", feature = "http2"))]
 #[cfg(feature = "client")]
-pub(crate) use self::oneshot::{oneshot, Oneshot};
+pub(super) use self::oneshot::{oneshot, Oneshot};
 
 pub use self::make::make_service_fn;
 pub use self::util::service_fn;
diff --git a/src/upgrade.rs b/src/upgrade.rs
index a981b912..6004c1a3 100644
--- a/src/upgrade.rs
+++ b/src/upgrade.rs
@@ -63,12 +63,12 @@ pub fn on<T: sealed::CanUpgrade>(msg: T) -> OnUpgrade {
 }
 
 #[cfg(feature = "http1")]
-pub(crate) struct Pending {
+pub(super) struct Pending {
     tx: oneshot::Sender<crate::Result<Upgraded>>,
 }
 
 #[cfg(feature = "http1")]
-pub(crate) fn pending() -> (Pending, OnUpgrade) {
+pub(super) fn pending() -> (Pending, OnUpgrade) {
     let (tx, rx) = oneshot::channel();
     (Pending { tx }, OnUpgrade { rx: Some(rx) })
 }
@@ -77,7 +77,7 @@ pub(crate) fn pending() -> (Pending, OnUpgrade) {
 
 impl Upgraded {
     #[cfg(any(feature = "http1", test))]
-    pub(crate) fn new<T>(io: T, read_buf: Bytes) -> Self
+    pub(super) fn new<T>(io: T, read_buf: Bytes) -> Self
     where
         T: AsyncRead + AsyncWrite + Unpin + Send + 'static,
     {
@@ -154,12 +154,12 @@ impl fmt::Debug for Upgraded {
 // ===== impl OnUpgrade =====
 
 impl OnUpgrade {
-    pub(crate) fn none() -> Self {
+    pub(super) fn none() -> Self {
         OnUpgrade { rx: None }
     }
 
     #[cfg(feature = "http1")]
-    pub(crate) fn is_none(&self) -> bool {
+    pub(super) fn is_none(&self) -> bool {
         self.rx.is_none()
     }
 }
@@ -189,14 +189,14 @@ impl fmt::Debug for OnUpgrade {
 
 #[cfg(feature = "http1")]
 impl Pending {
-    pub(crate) fn fulfill(self, upgraded: Upgraded) {
+    pub(super) fn fulfill(self, upgraded: Upgraded) {
         trace!("pending upgrade fulfill");
         let _ = self.tx.send(Ok(upgraded));
     }
 
     /// Don't fulfill the pending Upgrade, but instead signal that
     /// upgrades are handled manually.
-    pub(crate) fn manual(self) {
+    pub(super) fn manual(self) {
         trace!("pending upgrade handled manually");
         let _ = self.tx.send(Err(crate::Error::new_user_manual_upgrade()));
     }
@@ -221,7 +221,7 @@ impl StdError for UpgradeExpected {}
 
 // ===== impl Io =====
 
-pub(crate) trait Io: AsyncRead + AsyncWrite + Unpin + 'static {
+pub(super) trait Io: AsyncRead + AsyncWrite + Unpin + 'static {
     fn __hyper_type_id(&self) -> TypeId {
         TypeId::of::<Self>()
     }
