diff --git a/src/error.rs b/src/error.rs
index 5f50f3cc..eda4f515 100644
--- a/src/error.rs
+++ b/src/error.rs
@@ -8,6 +8,18 @@ pub type Result<T> = std::result::Result<T, Error>;
 type Cause = Box<dyn StdError + Send + Sync>;
 
 /// Represents errors that can occur handling HTTP streams.
+///
+/// # Formatting
+///
+/// The `Display` implementation of this type will only print the details of
+/// this level of error, even though it may have been caused by another error
+/// and contain that error in its source. To print all the relevant
+/// information, including the source chain, using something like
+/// `std::error::Report`, or equivalent 3rd party types.
+///
+/// The contents of the formatted error message of this specific `Error` type
+/// is unspecified. **You must not depend on it.** The wording and details may
+/// change in any version, with the goal of improving error messages.
 pub struct Error {
     inner: Box<ErrorImpl>,
 }
@@ -170,11 +182,6 @@ impl Error {
         self.find_source::<TimedOut>().is_some()
     }
 
-    /// Consumes the error, returning its cause.
-    pub fn into_cause(self) -> Option<Box<dyn StdError + Send + Sync>> {
-        self.inner.cause
-    }
-
     pub(super) fn new(kind: Kind) -> Error {
         Error {
             inner: Box::new(ErrorImpl { kind, cause: None }),
@@ -324,11 +331,6 @@ impl Error {
         }
     }
 
-    /// The error's standalone message, without the message from the source.
-    pub fn message(&self) -> impl fmt::Display + '_ {
-        self.description()
-    }
-
     fn description(&self) -> &str {
         match self.inner.kind {
             Kind::Parse(Parse::Method) => "invalid HTTP method parsed",
@@ -410,11 +412,7 @@ impl fmt::Debug for Error {
 
 impl fmt::Display for Error {
     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
-        if let Some(ref cause) = self.inner.cause {
-            write!(f, "{}: {}", self.description(), cause)
-        } else {
-            f.write_str(self.description())
-        }
+        f.write_str(self.description())
     }
 }
 
diff --git a/tests/client.rs b/tests/client.rs
index 3d46c3fb..1d19f8ea 100644
--- a/tests/client.rs
+++ b/tests/client.rs
@@ -2318,10 +2318,6 @@ mod conn {
         let error = client.send_request(req).await.unwrap_err();
 
         assert!(error.is_user());
-        assert_eq!(
-            error.to_string(),
-            "dispatch task is gone: user code panicked"
-        );
     }
 
     async fn drain_til_eof<T: tokio::io::AsyncRead + Unpin>(mut sock: T) -> io::Result<()> {
diff --git a/tests/server.rs b/tests/server.rs
index 4a514907..16a5a9af 100644
--- a/tests/server.rs
+++ b/tests/server.rs
@@ -523,6 +523,7 @@ fn post_with_chunked_body() {
 
 #[test]
 fn post_with_chunked_overflow() {
+    use std::error::Error as _;
     let server = serve();
     let mut req = connect(server.addr());
     req.write_all(
@@ -542,7 +543,7 @@ fn post_with_chunked_overflow() {
     .unwrap();
     req.read(&mut [0; 256]).unwrap();
 
-    let err = server.body_err().to_string();
+    let err = server.body_err().source().unwrap().to_string();
     assert!(
         err.contains("overflow"),
         "error should be overflow: {:?}",
