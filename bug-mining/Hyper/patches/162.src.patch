diff --git a/src/proto/h1/io.rs b/src/proto/h1/io.rs
index 115b074c..d0a953c7 100644
--- a/src/proto/h1/io.rs
+++ b/src/proto/h1/io.rs
@@ -66,12 +66,11 @@ where
     }
 
     pub fn set_flush_pipeline(&mut self, enabled: bool) {
+        debug_assert!(!self.write_buf.has_remaining());
         self.flush_pipeline = enabled;
-        self.write_buf.set_strategy(if enabled {
-            Strategy::Flatten
-        } else {
-            Strategy::Auto
-        });
+        if enabled {
+            self.set_write_strategy_flatten();
+        }
     }
 
     pub fn set_max_buf_size(&mut self, max: usize) {
diff --git a/src/server/conn.rs b/src/server/conn.rs
index 9bcffe20..45e0d277 100644
--- a/src/server/conn.rs
+++ b/src/server/conn.rs
@@ -37,6 +37,7 @@ use error::{Kind, Parse};
 #[derive(Clone, Debug)]
 pub struct Http {
     exec: Exec,
+    h1_writev: bool,
     mode: ConnectionMode,
     keep_alive: bool,
     max_buf_size: Option<usize>,
@@ -138,6 +139,7 @@ impl Http {
     pub fn new() -> Http {
         Http {
             exec: Exec::Default,
+            h1_writev: true,
             mode: ConnectionMode::Fallback,
             keep_alive: true,
             max_buf_size: None,
@@ -157,6 +159,20 @@ impl Http {
         self
     }
 
+    /// Set whether HTTP/1 connections should try to use vectored writes,
+    /// or always flatten into a single buffer.
+    ///
+    /// Note that setting this to false may mean more copies of body data,
+    /// but may also improve performance when an IO transport doesn't
+    /// support vectored writes well, such as most TLS implementations.
+    ///
+    /// Default is `true`.
+    #[inline]
+    pub fn http1_writev(&mut self, val: bool) -> &mut Self {
+        self.h1_writev = val;
+        self
+    }
+
     /// Sets whether HTTP2 is required.
     ///
     /// Default is false
@@ -264,6 +280,9 @@ impl Http {
                 if !self.keep_alive {
                     conn.disable_keep_alive();
                 }
+                if !self.h1_writev {
+                    conn.set_write_strategy_flatten();
+                }
                 conn.set_flush_pipeline(self.pipeline_flush);
                 if let Some(max) = self.max_buf_size {
                     conn.set_max_buf_size(max);
diff --git a/src/server/mod.rs b/src/server/mod.rs
index 924deaf8..33898c58 100644
--- a/src/server/mod.rs
+++ b/src/server/mod.rs
@@ -175,6 +175,21 @@ impl<I> Builder<I> {
         self
     }
 
+    /// Set whether HTTP/1 connections should try to use vectored writes,
+    /// or always flatten into a single buffer.
+    ///
+    /// # Note
+    ///
+    /// Setting this to `false` may mean more copies of body data,
+    /// but may also improve performance when an IO transport doesn't
+    /// support vectored writes well, such as most TLS implementations.
+    ///
+    /// Default is `true`.
+    pub fn http1_writev(mut self, val: bool) -> Self {
+        self.protocol.http1_writev(val);
+        self
+    }
+
     /// Sets whether HTTP/2 is required.
     ///
     /// Default is `false`.
