diff --git a/src/proto/h1/conn.rs b/src/proto/h1/conn.rs
index a8fa7e0e..891940b4 100644
--- a/src/proto/h1/conn.rs
+++ b/src/proto/h1/conn.rs
@@ -151,7 +151,9 @@ where I: AsyncRead + AsyncWrite + Unpin,
         self.state.version = msg.head.version;
 
         if msg.decode == DecodedLength::ZERO {
-            debug_assert!(!msg.expect_continue, "expect-continue needs a body");
+            if log_enabled!(log::Level::Debug) && msg.expect_continue {
+                debug!("ignoring expect-continue since body is empty");
+            }
             self.state.reading = Reading::KeepAlive;
             if !T::should_read_first() {
                 self.try_keep_alive(cx);
diff --git a/tests/server.rs b/tests/server.rs
index cbda4f22..0c5b5638 100644
--- a/tests/server.rs
+++ b/tests/server.rs
@@ -724,6 +724,28 @@ fn expect_continue_sends_100() {
     assert_eq!(body, msg);
 }
 
+#[test]
+fn expect_continue_but_no_body_is_ignored() {
+    let server = serve();
+    let mut req = connect(server.addr());
+    server.reply();
+
+    // no content-length or transfer-encoding means no body!
+    req.write_all(b"\
+        POST /foo HTTP/1.1\r\n\
+        Host: example.domain\r\n\
+        Expect: 100-continue\r\n\
+        Connection: Close\r\n\
+        \r\n\
+    ").expect("write");
+
+    let expected = "HTTP/1.1 200 OK\r\n";
+    let mut resp = String::new();
+    req.read_to_string(&mut resp).expect("read");
+
+    assert_eq!(&resp[..expected.len()], expected);
+}
+
 #[test]
 fn pipeline_disabled() {
     let server = serve();
