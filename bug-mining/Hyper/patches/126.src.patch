diff --git a/src/header/common/authorization.rs b/src/header/common/authorization.rs
index 68c24c02..09a34c5c 100644
--- a/src/header/common/authorization.rs
+++ b/src/header/common/authorization.rs
@@ -184,13 +184,13 @@ impl FromStr for Basic {
                         password: password
                     })
                 },
-                Err(e) => {
-                    debug!("Basic::from_utf8 error={:?}", e);
+                Err(_) => {
+                    debug!("Basic::from_str utf8 error");
                     Err(::Error::Header)
                 }
             },
-            Err(e) => {
-                debug!("Basic::from_base64 error={:?}", e);
+            Err(_) => {
+                debug!("Basic::from_str base64 error");
                 Err(::Error::Header)
             }
         }
diff --git a/src/header/mod.rs b/src/header/mod.rs
index bee26f22..88356898 100644
--- a/src/header/mod.rs
+++ b/src/header/mod.rs
@@ -240,17 +240,6 @@ impl<'a> fmt::Display for ValueString<'a> {
     }
 }
 
-struct HeaderValueString<'a, H: Header + 'a>(&'a H);
-
-impl<'a, H: Header> fmt::Debug for HeaderValueString<'a, H> {
-    #[inline]
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        try!(f.write_str("\""));
-        try!(self.0.fmt_header(&mut Formatter(Multi::Join(true, f))));
-        f.write_str("\"")
-    }
-}
-
 struct NewlineReplacer<'a, F: fmt::Write + 'a>(&'a mut F);
 
 impl<'a, F: fmt::Write + 'a> fmt::Write for NewlineReplacer<'a, F> {
@@ -394,7 +383,6 @@ impl Headers {
     ///
     /// The field is determined by the type of the value being set.
     pub fn set<H: Header>(&mut self, value: H) {
-        trace!("Headers.set( {:?}, {:?} )", header_name::<H>(), HeaderValueString(&value));
         self.data.insert(HeaderName(Ascii::new(Cow::Borrowed(header_name::<H>()))),
                          Item::new_typed(value));
     }
@@ -432,7 +420,6 @@ impl Headers {
     /// Note that this function may return `None` even though a header was removed. If you want to
     /// know whether a header exists, rather rely on `has`.
     pub fn remove<H: Header>(&mut self) -> Option<H> {
-        trace!("Headers.remove( {:?} )", header_name::<H>());
         self.data.remove(&HeaderName(Ascii::new(Cow::Borrowed(header_name::<H>()))))
             .and_then(Item::into_typed::<H>)
     }
@@ -488,7 +475,6 @@ impl Headers {
     pub fn set_raw<K: Into<Cow<'static, str>>, V: Into<Raw>>(&mut self, name: K, value: V) {
         let name = name.into();
         let value = value.into();
-        trace!("Headers.set_raw( {:?}, {:?} )", name, value);
         self.data.insert(HeaderName(Ascii::new(name)), Item::new_raw(value));
     }
 
@@ -510,7 +496,6 @@ impl Headers {
     pub fn append_raw<K: Into<Cow<'static, str>>, V: Into<Raw>>(&mut self, name: K, value: V) {
         let name = name.into();
         let value = value.into();
-        trace!("Headers.append_raw( {:?}, {:?} )", name, value);
         let name = HeaderName(Ascii::new(name));
         if let Some(item) = self.data.get_mut(&name) {
             item.raw_mut().push(value);
@@ -521,7 +506,6 @@ impl Headers {
 
     /// Remove a header by name.
     pub fn remove_raw(&mut self, name: &str) {
-        trace!("Headers.remove_raw( {:?} )", name);
         self.data.remove(name);
     }
 
diff --git a/src/http/conn.rs b/src/http/conn.rs
index 608f7211..261b133b 100644
--- a/src/http/conn.rs
+++ b/src/http/conn.rs
@@ -7,7 +7,7 @@ use futures::task::Task;
 use tokio_io::{AsyncRead, AsyncWrite};
 use tokio_proto::streaming::pipeline::{Frame, Transport};
 
-use http::{self, Http1Transaction, DebugTruncate};
+use http::{self, Http1Transaction};
 use http::io::{Cursor, Buffered};
 use http::h1::{Encoder, Decoder};
 use method::Method;
@@ -90,13 +90,13 @@ where I: AsyncRead + AsyncWrite,
                 self.io.consume_leading_lines();
                 let was_mid_parse = !self.io.read_buf().is_empty();
                 return if was_mid_parse {
-                    debug!("parse error ({}) with bytes: {:?}", e, self.io.read_buf());
+                    debug!("parse error ({}) with {} bytes", e, self.io.read_buf().len());
                     Ok(Async::Ready(Some(Frame::Error { error: e })))
                 } else if must_respond_with_error {
                     trace!("parse error with 0 input, err = {:?}", e);
                     Ok(Async::Ready(Some(Frame::Error { error: e })))
                 } else {
-                    debug!("socket complete");
+                    debug!("read eof");
                     Ok(Async::Ready(None))
                 };
             }
@@ -669,20 +669,19 @@ struct DebugFrame<'a, T: fmt::Debug + 'a, B: AsRef<[u8]> + 'a>(&'a Frame<http::M
 impl<'a, T: fmt::Debug + 'a, B: AsRef<[u8]> + 'a> fmt::Debug for DebugFrame<'a, T, B> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         match *self.0 {
-            Frame::Message { ref message, ref body } => {
+            Frame::Message { ref body, .. } => {
                 f.debug_struct("Message")
-                    .field("message", message)
                     .field("body", body)
                     .finish()
             },
             Frame::Body { chunk: Some(ref chunk) } => {
                 f.debug_struct("Body")
-                    .field("chunk", &DebugTruncate(chunk.as_ref()))
+                    .field("bytes", &chunk.as_ref().len())
                     .finish()
             },
             Frame::Body { chunk: None } => {
                 f.debug_struct("Body")
-                    .field("chunk", &None::<()>)
+                    .field("bytes", &None::<()>)
                     .finish()
             },
             Frame::Error { ref error } => {
diff --git a/src/http/h1/encode.rs b/src/http/h1/encode.rs
index 3f374ddf..6068b7a7 100644
--- a/src/http/h1/encode.rs
+++ b/src/http/h1/encode.rs
@@ -59,7 +59,7 @@ impl Encoder {
                 }
                 let n = {
                     let max = cmp::min(*remaining as usize, msg.len());
-                    trace!("sized write, len = {}, remaining = {}", max, remaining);
+                    trace!("sized write = {}", max);
                     let slice = &msg[..max];
 
                     try!(w.write_atomic(&[slice]))
@@ -70,8 +70,7 @@ impl Encoder {
                 }
 
                 *remaining -= n as u64;
-                debug!("encoded {} bytes", n);
-                trace!("encode sized complete, remaining = {}", remaining);
+                trace!("encoded {} bytes, remaining = {}", n, remaining);
                 Ok(n)
             },
         }
diff --git a/src/http/h1/parse.rs b/src/http/h1/parse.rs
index 71bcb77c..6d7b2f03 100644
--- a/src/http/h1/parse.rs
+++ b/src/http/h1/parse.rs
@@ -23,7 +23,6 @@ impl Http1Transaction for ServerTransaction {
         if buf.len() == 0 {
             return Ok(None);
         }
-        trace!("parse({:?})", buf);
         let mut headers_indices = [HeaderIndices {
             name: (0, 0),
             value: (0, 0)
@@ -34,7 +33,7 @@ impl Http1Transaction for ServerTransaction {
             let mut req = httparse::Request::new(&mut headers);
             match try!(req.parse(&buf)) {
                 httparse::Status::Complete(len) => {
-                    trace!("httparse Complete({})", len);
+                    trace!("Request.parse Complete({})", len);
                     let method = try!(req.method.unwrap().parse());
                     let path = req.path.unwrap();
                     let bytes_ptr = buf.as_ref().as_ptr() as usize;
@@ -110,11 +109,9 @@ impl Http1Transaction for ServerTransaction {
 
 
     fn encode(mut head: MessageHead<Self::Outgoing>, has_body: bool, method: &mut Option<Method>, dst: &mut Vec<u8>) -> Encoder {
-        trace!("ServerTransaction::encode head={:?}, has_body={}, method={:?}",
-               head, has_body, method);
+        trace!("ServerTransaction::encode has_body={}, method={:?}", has_body, method);
 
         let body = ServerTransaction::set_length(&mut head, has_body, method.as_ref());
-        debug!("encode headers = {:?}", head.headers);
 
         let init_cap = 30 + head.headers.len() * AVERAGE_HEADER_SIZE;
         dst.reserve(init_cap);
@@ -180,7 +177,6 @@ impl Http1Transaction for ClientTransaction {
         if buf.len() == 0 {
             return Ok(None);
         }
-        trace!("parse({:?})", buf);
         let mut headers_indices = [HeaderIndices {
             name: (0, 0),
             value: (0, 0)
@@ -192,7 +188,7 @@ impl Http1Transaction for ClientTransaction {
             let bytes = buf.as_ref();
             match try!(res.parse(bytes)) {
                 httparse::Status::Complete(len) => {
-                    trace!("Response.try_parse Complete({})", len);
+                    trace!("Response.parse Complete({})", len);
                     let code = res.code.unwrap();
                     let status = try!(StatusCode::try_from(code).map_err(|_| ::Error::Status));
                     let reason = match status.canonical_reason() {
@@ -273,14 +269,11 @@ impl Http1Transaction for ClientTransaction {
     }
 
     fn encode(mut head: MessageHead<Self::Outgoing>, has_body: bool, method: &mut Option<Method>, dst: &mut Vec<u8>) -> Encoder {
-        trace!("ClientTransaction::encode head={:?}, has_body={}, method={:?}",
-               head, has_body, method);
-
+        trace!("ClientTransaction::encode has_body={}, method={:?}", has_body, method);
 
         *method = Some(head.subject.0.clone());
 
         let body = ClientTransaction::set_length(&mut head, has_body);
-        debug!("encode headers = {:?}", head.headers);
 
         let init_cap = 30 + head.headers.len() * AVERAGE_HEADER_SIZE;
         dst.reserve(init_cap);
diff --git a/src/http/io.rs b/src/http/io.rs
index 971a3e84..594b51e4 100644
--- a/src/http/io.rs
+++ b/src/http/io.rs
@@ -6,7 +6,7 @@ use std::ptr;
 use futures::{Async, Poll};
 use tokio_io::{AsyncRead, AsyncWrite};
 
-use http::{Http1Transaction, MessageHead, DebugTruncate};
+use http::{Http1Transaction, MessageHead};
 use bytes::{BytesMut, Bytes};
 
 const INIT_BUFFER_SIZE: usize = 8192;
@@ -224,8 +224,9 @@ impl<T: AsRef<[u8]>> Cursor<T> {
 
 impl<T: AsRef<[u8]>> fmt::Debug for Cursor<T> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        f.debug_tuple("Cursor")
-            .field(&DebugTruncate(self.buf()))
+        f.debug_struct("Cursor")
+            .field("pos", &self.pos)
+            .field("len", &self.bytes.as_ref().len())
             .finish()
     }
 }
diff --git a/src/http/mod.rs b/src/http/mod.rs
index 20213b6e..53fe49f4 100644
--- a/src/http/mod.rs
+++ b/src/http/mod.rs
@@ -150,23 +150,6 @@ pub trait Http1Transaction {
 
 pub type ParseResult<T> = ::Result<Option<(MessageHead<T>, usize)>>;
 
-struct DebugTruncate<'a>(&'a [u8]);
-
-impl<'a> fmt::Debug for DebugTruncate<'a> {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        let bytes = self.0;
-        if bytes.len() > 32 {
-            try!(f.write_str("["));
-            for byte in &bytes[..32] {
-                try!(write!(f, "{:?}, ", byte));
-            }
-            write!(f, "... {}]", bytes.len())
-        } else {
-            fmt::Debug::fmt(bytes, f)
-        }
-    }
-}
-
 #[test]
 fn test_should_keep_alive() {
     let mut headers = Headers::new();
diff --git a/src/http/request.rs b/src/http/request.rs
index ddb869ba..2d08bace 100644
--- a/src/http/request.rs
+++ b/src/http/request.rs
@@ -132,24 +132,9 @@ impl<B> fmt::Debug for Request<B> {
     }
 }
 
-struct MaybeAddr<'a>(&'a Option<SocketAddr>);
-
-impl<'a> fmt::Display for MaybeAddr<'a> {
-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        match *self.0 {
-            Some(ref addr) => {
-                write!(f, "addr={}, ", addr)
-            },
-            None => Ok(()),
-        }
-    }
-}
-
 /// Constructs a request using a received ResponseHead and optional body
 pub fn from_wire<B>(addr: Option<SocketAddr>, incoming: RequestHead, body: B) -> Request<B> {
     let MessageHead { version, subject: RequestLine(method, uri), headers } = incoming;
-    info!("Request::new: {}\"{} {} {}\"", MaybeAddr(&addr), method, uri, version);
-    debug!("Request::new: headers={:?}", headers);
 
     Request::<B> {
         method: method,
diff --git a/src/http/response.rs b/src/http/response.rs
index 9a814045..480702db 100644
--- a/src/http/response.rs
+++ b/src/http/response.rs
@@ -147,8 +147,6 @@ impl fmt::Debug for Response {
 #[cfg(not(feature = "raw_status"))]
 pub fn from_wire<B>(incoming: ResponseHead, body: Option<B>) -> Response<B> {
     let status = incoming.status();
-    info!("Response::new \"{} {}\"", incoming.version, status);
-    debug!("Response::new headers={:?}", incoming.headers);
 
     Response::<B> {
         status: status,
@@ -163,8 +161,6 @@ pub fn from_wire<B>(incoming: ResponseHead, body: Option<B>) -> Response<B> {
 #[cfg(feature = "raw_status")]
 pub fn from_wire<B>(incoming: ResponseHead, body: Option<B>) -> Response<B> {
     let status = incoming.status();
-    info!("Response::new \"{} {}\"", incoming.version, status);
-    debug!("Response::new headers={:?}", incoming.headers);
 
     Response::<B> {
         status: status,
