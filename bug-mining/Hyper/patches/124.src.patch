diff --git a/src/http/conn.rs b/src/http/conn.rs
index 7b91efc9..ed79b09e 100644
--- a/src/http/conn.rs
+++ b/src/http/conn.rs
@@ -7,10 +7,10 @@ use futures::task::Task;
 use tokio_io::{AsyncRead, AsyncWrite};
 use tokio_proto::streaming::pipeline::{Frame, Transport};
 
-use header::{ContentLength, TransferEncoding};
 use http::{self, Http1Transaction, DebugTruncate};
 use http::io::{Cursor, Buffered};
 use http::h1::{Encoder, Decoder};
+use method::Method;
 use version::HttpVersion;
 
 
@@ -37,10 +37,11 @@ where I: AsyncRead + AsyncWrite,
         Conn {
             io: Buffered::new(io),
             state: State {
+                keep_alive: keep_alive,
+                method: None,
+                read_task: None,
                 reading: Reading::Init,
                 writing: Writing::Init,
-                read_task: None,
-                keep_alive: keep_alive,
             },
             _marker: PhantomData,
         }
@@ -103,7 +104,7 @@ where I: AsyncRead + AsyncWrite,
 
         match version {
             HttpVersion::Http10 | HttpVersion::Http11 => {
-                let decoder = match T::decoder(&head) {
+                let decoder = match T::decoder(&head, &mut self.state.method) {
                     Ok(d) => d,
                     Err(e) => {
                         debug!("decoder error = {:?}", e);
@@ -234,17 +235,8 @@ where I: AsyncRead + AsyncWrite,
         }
     }
 
-    fn write_head(&mut self, mut head: http::MessageHead<T::Outgoing>, body: bool) {
+    fn write_head(&mut self, head: http::MessageHead<T::Outgoing>, body: bool) {
         debug_assert!(self.can_write_head());
-        if !body {
-            head.headers.remove::<TransferEncoding>();
-            //TODO: check that this isn't a response to a HEAD
-            //request, which could include the content-length
-            //even if no body is to be written
-            if T::should_set_length(&head) {
-                head.headers.set(ContentLength(0));
-            }
-        }
 
         let wants_keep_alive = head.should_keep_alive();
         self.state.keep_alive &= wants_keep_alive;
@@ -256,8 +248,8 @@ where I: AsyncRead + AsyncWrite,
                 buf.extend_from_slice(pending.buf());
             }
         }
-        let encoder = T::encode(head, buf);
-        self.state.writing = if body {
+        let encoder = T::encode(head, body, &mut self.state.method, buf);
+        self.state.writing = if !encoder.is_eof() {
             Writing::Body(encoder, None)
         } else {
             Writing::KeepAlive
@@ -493,10 +485,11 @@ impl<I, B: AsRef<[u8]>, T, K: fmt::Debug> fmt::Debug for Conn<I, B, T, K> {
 }
 
 struct State<B, K> {
+    keep_alive: K,
+    method: Option<Method>,
+    read_task: Option<Task>,
     reading: Reading,
     writing: Writing<B>,
-    read_task: Option<Task>,
-    keep_alive: K,
 }
 
 #[derive(Debug)]
@@ -522,6 +515,7 @@ impl<B: AsRef<[u8]>, K: fmt::Debug> fmt::Debug for State<B, K> {
             .field("reading", &self.reading)
             .field("writing", &self.writing)
             .field("keep_alive", &self.keep_alive)
+            .field("method", &self.method)
             .field("read_task", &self.read_task)
             .finish()
     }
@@ -641,6 +635,7 @@ impl<B, K: KeepAlive> State<B, K> {
     }
 
     fn idle(&mut self) {
+        self.method = None;
         self.reading = Reading::Init;
         self.writing = Writing::Init;
         self.keep_alive.idle();
diff --git a/src/http/h1/parse.rs b/src/http/h1/parse.rs
index f9d964ab..71bcb77c 100644
--- a/src/http/h1/parse.rs
+++ b/src/http/h1/parse.rs
@@ -5,7 +5,8 @@ use httparse;
 use bytes::{BytesMut, Bytes};
 
 use header::{self, Headers, ContentLength, TransferEncoding};
-use http::{MessageHead, RawStatus, Http1Transaction, ParseResult, ServerTransaction, ClientTransaction, RequestLine};
+use http::{MessageHead, RawStatus, Http1Transaction, ParseResult,
+           ServerTransaction, ClientTransaction, RequestLine, RequestHead};
 use http::h1::{Encoder, Decoder, date};
 use method::Method;
 use status::StatusCode;
@@ -72,8 +73,11 @@ impl Http1Transaction for ServerTransaction {
         }, len)))
     }
 
-    fn decoder(head: &MessageHead<Self::Incoming>) -> ::Result<Decoder> {
+    fn decoder(head: &MessageHead<Self::Incoming>, method: &mut Option<Method>) -> ::Result<Decoder> {
         use ::header;
+
+        *method = Some(head.subject.0.clone());
+
         // According to https://tools.ietf.org/html/rfc7230#section-3.3.3
         // 1. (irrelevant to Request)
         // 2. (irrelevant to Request)
@@ -105,30 +109,11 @@ impl Http1Transaction for ServerTransaction {
     }
 
 
-    fn encode(mut head: MessageHead<Self::Outgoing>, dst: &mut Vec<u8>) -> Encoder {
-        use ::header;
-        trace!("writing head: {:?}", head);
-
-        let len = head.headers.get::<header::ContentLength>().map(|n| **n);
-
-        let body = if let Some(len) = len {
-            Encoder::length(len)
-        } else {
-            let encodings = match head.headers.get_mut::<header::TransferEncoding>() {
-                Some(&mut header::TransferEncoding(ref mut encodings)) => {
-                    if encodings.last() != Some(&header::Encoding::Chunked) {
-                        encodings.push(header::Encoding::Chunked);
-                    }
-                    false
-                },
-                None => true
-            };
+    fn encode(mut head: MessageHead<Self::Outgoing>, has_body: bool, method: &mut Option<Method>, dst: &mut Vec<u8>) -> Encoder {
+        trace!("ServerTransaction::encode head={:?}, has_body={}, method={:?}",
+               head, has_body, method);
 
-            if encodings {
-                head.headers.set(header::TransferEncoding(vec![header::Encoding::Chunked]));
-            }
-            Encoder::chunked()
-        };
+        let body = ServerTransaction::set_length(&mut head, has_body, method.as_ref());
         debug!("encode headers = {:?}", head.headers);
 
         let init_cap = 30 + head.headers.len() * AVERAGE_HEADER_SIZE;
@@ -150,16 +135,39 @@ impl Http1Transaction for ServerTransaction {
         extend(dst, b"\r\n");
         body
     }
+}
 
-    fn should_set_length(head: &MessageHead<Self::Outgoing>) -> bool {
-        //TODO: pass method, check if method == HEAD
+impl ServerTransaction {
+    fn set_length(head: &mut MessageHead<StatusCode>, has_body: bool, method: Option<&Method>) -> Encoder {
+        // these are here thanks to borrowck
+        // `if method == Some(&Method::Get)` says the RHS doesnt live long enough
+        const HEAD: Option<&'static Method> = Some(&Method::Head);
+        const CONNECT: Option<&'static Method> = Some(&Method::Connect);
+
+        let can_have_body = {
+            if method == HEAD {
+                false
+            } else if method == CONNECT && head.subject.is_success() {
+                false
+            } else {
+                match head.subject {
+                    // TODO: support for 1xx codes needs improvement everywhere
+                    // would be 100...199 => false
+                    StatusCode::NoContent |
+                    StatusCode::NotModified => false,
+                    _ => true,
+                }
+            }
+        };
 
-        match head.subject {
-            // TODO: support for 1xx codes needs improvement everywhere
-            // would be 100...199 => false
-            StatusCode::NoContent |
-            StatusCode::NotModified => false,
-            _ => true,
+        if has_body && can_have_body {
+            set_length(&mut head.headers)
+        } else {
+            head.headers.remove::<TransferEncoding>();
+            if can_have_body {
+                head.headers.set(ContentLength(0));
+            }
+            Encoder::length(0)
         }
     }
 }
@@ -213,8 +221,7 @@ impl Http1Transaction for ClientTransaction {
         }, len)))
     }
 
-    fn decoder(inc: &MessageHead<Self::Incoming>) -> ::Result<Decoder> {
-        use ::header;
+    fn decoder(inc: &MessageHead<Self::Incoming>, method: &mut Option<Method>) -> ::Result<Decoder> {
         // According to https://tools.ietf.org/html/rfc7230#section-3.3.3
         // 1. HEAD responses, and Status 1xx, 204, and 304 cannot have a body.
         // 2. Status 2xx to a CONNECT cannot have a body.
@@ -224,7 +231,21 @@ impl Http1Transaction for ClientTransaction {
         // 6. (irrelevant to Response)
         // 7. Read till EOF.
 
-        //TODO: need a way to pass the Method that caused this Response
+        match *method {
+            Some(Method::Head) => {
+                return Ok(Decoder::length(0));
+            }
+            Some(Method::Connect) => match inc.subject.0 {
+                200...299 => {
+                    return Ok(Decoder::length(0));
+                },
+                _ => {},
+            },
+            Some(_) => {},
+            None => {
+                trace!("ClientTransaction::decoder is missing the Method");
+            }
+        }
 
         match inc.subject.0 {
             100...199 |
@@ -251,39 +272,14 @@ impl Http1Transaction for ClientTransaction {
         }
     }
 
-    fn encode(mut head: MessageHead<Self::Outgoing>, dst: &mut Vec<u8>) -> Encoder {
-        trace!("writing head: {:?}", head);
-
-
-        let mut body = Encoder::length(0);
-        let expects_no_body = match head.subject.0 {
-            Method::Head | Method::Get | Method::Connect => true,
-            _ => false
-        };
-        let mut chunked = false;
+    fn encode(mut head: MessageHead<Self::Outgoing>, has_body: bool, method: &mut Option<Method>, dst: &mut Vec<u8>) -> Encoder {
+        trace!("ClientTransaction::encode head={:?}, has_body={}, method={:?}",
+               head, has_body, method);
 
-        if let Some(con_len) = head.headers.get::<ContentLength>() {
-            body = Encoder::length(**con_len);
-        } else {
-            chunked = !expects_no_body;
-        }
 
-        if chunked {
-            body = Encoder::chunked();
-            let encodings = match head.headers.get_mut::<TransferEncoding>() {
-                Some(encodings) => {
-                    if !encodings.contains(&header::Encoding::Chunked) {
-                        encodings.push(header::Encoding::Chunked);
-                    }
-                    true
-                },
-                None => false
-            };
+        *method = Some(head.subject.0.clone());
 
-            if !encodings {
-                head.headers.set(TransferEncoding(vec![header::Encoding::Chunked]));
-            }
-        }
+        let body = ClientTransaction::set_length(&mut head, has_body);
         debug!("encode headers = {:?}", head.headers);
 
         let init_cap = 30 + head.headers.len() * AVERAGE_HEADER_SIZE;
@@ -292,13 +288,40 @@ impl Http1Transaction for ClientTransaction {
 
         body
     }
+}
+
+impl ClientTransaction {
+    fn set_length(head: &mut RequestHead, has_body: bool) -> Encoder {
+        if has_body {
+            set_length(&mut head.headers)
+        } else {
+            head.headers.remove::<ContentLength>();
+            head.headers.remove::<TransferEncoding>();
+            Encoder::length(0)
+        }
+    }
+}
+
+fn set_length(headers: &mut Headers) -> Encoder {
+    let len = headers.get::<header::ContentLength>().map(|n| **n);
 
+    if let Some(len) = len {
+        Encoder::length(len)
+    } else {
+        let encodings = match headers.get_mut::<header::TransferEncoding>() {
+            Some(&mut header::TransferEncoding(ref mut encodings)) => {
+                if encodings.last() != Some(&header::Encoding::Chunked) {
+                    encodings.push(header::Encoding::Chunked);
+                }
+                false
+            },
+            None => true
+        };
 
-    fn should_set_length(head: &MessageHead<Self::Outgoing>) -> bool {
-        match &head.subject.0 {
-            &Method::Get | &Method::Head => false,
-            _ => true
+        if encodings {
+            headers.set(header::TransferEncoding(vec![header::Encoding::Chunked]));
         }
+        Encoder::chunked()
     }
 }
 
@@ -421,63 +444,83 @@ mod tests {
     fn test_decoder_request() {
         use super::Decoder;
 
+        let method = &mut None;
         let mut head = MessageHead::<::http::RequestLine>::default();
 
         head.subject.0 = ::Method::Get;
-        assert_eq!(Decoder::length(0), ServerTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(0), ServerTransaction::decoder(&head, method).unwrap());
+        assert_eq!(*method, Some(::Method::Get));
+
         head.subject.0 = ::Method::Post;
-        assert_eq!(Decoder::length(0), ServerTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(0), ServerTransaction::decoder(&head, method).unwrap());
+        assert_eq!(*method, Some(::Method::Post));
 
         head.headers.set(TransferEncoding::chunked());
-        assert_eq!(Decoder::chunked(), ServerTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::chunked(), ServerTransaction::decoder(&head, method).unwrap());
         // transfer-encoding and content-length = chunked
         head.headers.set(ContentLength(10));
-        assert_eq!(Decoder::chunked(), ServerTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::chunked(), ServerTransaction::decoder(&head, method).unwrap());
 
         head.headers.remove::<TransferEncoding>();
-        assert_eq!(Decoder::length(10), ServerTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(10), ServerTransaction::decoder(&head, method).unwrap());
 
         head.headers.set_raw("Content-Length", vec![b"5".to_vec(), b"5".to_vec()]);
-        assert_eq!(Decoder::length(5), ServerTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(5), ServerTransaction::decoder(&head, method).unwrap());
 
         head.headers.set_raw("Content-Length", vec![b"10".to_vec(), b"11".to_vec()]);
-        ServerTransaction::decoder(&head).unwrap_err();
+        ServerTransaction::decoder(&head, method).unwrap_err();
 
         head.headers.remove::<ContentLength>();
 
         head.headers.set_raw("Transfer-Encoding", "gzip");
-        ServerTransaction::decoder(&head).unwrap_err();
+        ServerTransaction::decoder(&head, method).unwrap_err();
     }
 
     #[test]
     fn test_decoder_response() {
         use super::Decoder;
 
+        let method = &mut Some(::Method::Get);
         let mut head = MessageHead::<::http::RawStatus>::default();
 
         head.subject.0 = 204;
-        assert_eq!(Decoder::length(0), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(0), ClientTransaction::decoder(&head, method).unwrap());
         head.subject.0 = 304;
-        assert_eq!(Decoder::length(0), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(0), ClientTransaction::decoder(&head, method).unwrap());
 
         head.subject.0 = 200;
-        assert_eq!(Decoder::eof(), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::eof(), ClientTransaction::decoder(&head, method).unwrap());
+
+        *method = Some(::Method::Head);
+        assert_eq!(Decoder::length(0), ClientTransaction::decoder(&head, method).unwrap());
+
+        *method = Some(::Method::Connect);
+        assert_eq!(Decoder::length(0), ClientTransaction::decoder(&head, method).unwrap());
+
+
+        // CONNECT receiving non 200 can have a body
+        head.subject.0 = 404;
+        head.headers.set(ContentLength(10));
+        assert_eq!(Decoder::length(10), ClientTransaction::decoder(&head, method).unwrap());
+        head.headers.remove::<ContentLength>();
+
 
+        *method = Some(::Method::Get);
         head.headers.set(TransferEncoding::chunked());
-        assert_eq!(Decoder::chunked(), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::chunked(), ClientTransaction::decoder(&head, method).unwrap());
 
         // transfer-encoding and content-length = chunked
         head.headers.set(ContentLength(10));
-        assert_eq!(Decoder::chunked(), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::chunked(), ClientTransaction::decoder(&head, method).unwrap());
 
         head.headers.remove::<TransferEncoding>();
-        assert_eq!(Decoder::length(10), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(10), ClientTransaction::decoder(&head, method).unwrap());
 
         head.headers.set_raw("Content-Length", vec![b"5".to_vec(), b"5".to_vec()]);
-        assert_eq!(Decoder::length(5), ClientTransaction::decoder(&head).unwrap());
+        assert_eq!(Decoder::length(5), ClientTransaction::decoder(&head, method).unwrap());
 
         head.headers.set_raw("Content-Length", vec![b"10".to_vec(), b"11".to_vec()]);
-        ClientTransaction::decoder(&head).unwrap_err();
+        ClientTransaction::decoder(&head, method).unwrap_err();
     }
 
     #[cfg(feature = "nightly")]
@@ -541,7 +584,7 @@ mod tests {
 
         b.iter(|| {
             let mut vec = Vec::new();
-            ServerTransaction::encode(head.clone(), &mut vec);
+            ServerTransaction::encode(head.clone(), true, &mut None, &mut vec);
             assert_eq!(vec.len(), len);
             ::test::black_box(vec);
         })
diff --git a/src/http/mod.rs b/src/http/mod.rs
index b678e97d..20213b6e 100644
--- a/src/http/mod.rs
+++ b/src/http/mod.rs
@@ -144,9 +144,8 @@ pub trait Http1Transaction {
     type Incoming;
     type Outgoing: Default;
     fn parse(bytes: &mut BytesMut) -> ParseResult<Self::Incoming>;
-    fn decoder(head: &MessageHead<Self::Incoming>) -> ::Result<h1::Decoder>;
-    fn encode(head: MessageHead<Self::Outgoing>, dst: &mut Vec<u8>) -> h1::Encoder;
-    fn should_set_length(head: &MessageHead<Self::Outgoing>) -> bool;
+    fn decoder(head: &MessageHead<Self::Incoming>, method: &mut Option<::Method>) -> ::Result<h1::Decoder>;
+    fn encode(head: MessageHead<Self::Outgoing>, has_body: bool, method: &mut Option<Method>, dst: &mut Vec<u8>) -> h1::Encoder;
 }
 
 pub type ParseResult<T> = ::Result<Option<(MessageHead<T>, usize)>>;
diff --git a/src/lib.rs b/src/lib.rs
index 0955a475..94dcac52 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -1,6 +1,6 @@
 #![doc(html_root_url = "https://docs.rs/hyper/0.11.1")]
 #![deny(missing_docs)]
-#![deny(warnings)]
+//#![deny(warnings)]
 #![deny(missing_debug_implementations)]
 #![cfg_attr(all(test, feature = "nightly"), feature(test))]
 
diff --git a/tests/client.rs b/tests/client.rs
index e93426c8..f88a85d3 100644
--- a/tests/client.rs
+++ b/tests/client.rs
@@ -12,7 +12,7 @@ use std::time::Duration;
 use hyper::client::{Client, Request, HttpConnector};
 use hyper::{Method, StatusCode};
 
-use futures::Future;
+use futures::{Future, Stream};
 use futures::sync::oneshot;
 
 use tokio_core::reactor::{Core, Handle};
@@ -93,6 +93,12 @@ macro_rules! test {
             $(
                 assert_eq!(res.headers().get(), Some(&$response_headers));
             )*
+
+            let body = core.run(res.body().concat2()).unwrap();
+
+            let expected_res_body = Option::<&[u8]>::from($response_body)
+                .unwrap_or_default();
+            assert_eq!(body.as_ref(), expected_res_body);
         }
     );
 }
@@ -225,6 +231,36 @@ test! {
             body: None,
 }
 
+
+test! {
+    name: client_head_ignores_body,
+
+    server:
+        expected: "\
+            HEAD /head HTTP/1.1\r\n\
+            Host: {addr}\r\n\
+            \r\n\
+            ",
+        reply: "\
+            HTTP/1.1 200 OK\r\n\
+            Content-Length: 11\r\n\
+            \r\n\
+            Hello World\
+            ",
+
+    client:
+        request:
+            method: Head,
+            url: "http://{addr}/head",
+            headers: [],
+            body: None,
+            proxy: false,
+        response:
+            status: Ok,
+            headers: [],
+            body: None,
+}
+
 #[test]
 fn client_keep_alive() {
     let server = TcpListener::bind("127.0.0.1:0").unwrap();
diff --git a/tests/server.rs b/tests/server.rs
index e5c38289..ca34c3db 100644
--- a/tests/server.rs
+++ b/tests/server.rs
@@ -16,182 +16,8 @@ use std::time::Duration;
 
 use hyper::server::{Http, Request, Response, Service, NewService};
 
-struct Serve {
-    addr: SocketAddr,
-    msg_rx: mpsc::Receiver<Msg>,
-    reply_tx: spmc::Sender<Reply>,
-    shutdown_signal: Option<oneshot::Sender<()>>,
-    thread: Option<thread::JoinHandle<()>>,
-}
-
-impl Serve {
-    fn addr(&self) -> &SocketAddr {
-        &self.addr
-    }
-
-    fn body(&self) -> Vec<u8> {
-        let mut buf = vec![];
-        while let Ok(Msg::Chunk(msg)) = self.msg_rx.try_recv() {
-            buf.extend(&msg);
-        }
-        buf
-    }
-
-    fn reply(&self) -> ReplyBuilder {
-        ReplyBuilder {
-            tx: &self.reply_tx
-        }
-    }
-}
-
-struct ReplyBuilder<'a> {
-    tx: &'a spmc::Sender<Reply>,
-}
-
-impl<'a> ReplyBuilder<'a> {
-    fn status(self, status: hyper::StatusCode) -> Self {
-        self.tx.send(Reply::Status(status)).unwrap();
-        self
-    }
-
-    fn header<H: hyper::header::Header>(self, header: H) -> Self {
-        let mut headers = hyper::Headers::new();
-        headers.set(header);
-        self.tx.send(Reply::Headers(headers)).unwrap();
-        self
-    }
-
-    fn body<T: AsRef<[u8]>>(self, body: T) {
-        self.tx.send(Reply::Body(body.as_ref().into())).unwrap();
-    }
-}
-
-impl Drop for Serve {
-    fn drop(&mut self) {
-        drop(self.shutdown_signal.take());
-        self.thread.take().unwrap().join().unwrap();
-    }
-}
-
-#[derive(Clone)]
-struct TestService {
-    tx: Arc<Mutex<mpsc::Sender<Msg>>>,
-    reply: spmc::Receiver<Reply>,
-    _timeout: Option<Duration>,
-}
-
-#[derive(Clone, Debug)]
-enum Reply {
-    Status(hyper::StatusCode),
-    Headers(hyper::Headers),
-    Body(Vec<u8>),
-}
-
-enum Msg {
-    //Head(Request),
-    Chunk(Vec<u8>),
-}
-
-impl NewService for TestService {
-    type Request = Request;
-    type Response = Response;
-    type Error = hyper::Error;
-
-    type Instance = TestService;
-
-    fn new_service(&self) -> std::io::Result<TestService> {
-        Ok(self.clone())
-    }
-
-
-}
-
-impl Service for TestService {
-    type Request = Request;
-    type Response = Response;
-    type Error = hyper::Error;
-    type Future = Box<Future<Item=Response, Error=hyper::Error>>;
-    fn call(&self, req: Request) -> Self::Future {
-        let tx = self.tx.clone();
-        let replies = self.reply.clone();
-        req.body().for_each(move |chunk| {
-            tx.lock().unwrap().send(Msg::Chunk(chunk.to_vec())).unwrap();
-            Ok(())
-        }).map(move |_| {
-            let mut res = Response::new();
-            while let Ok(reply) = replies.try_recv() {
-                match reply {
-                    Reply::Status(s) => {
-                        res.set_status(s);
-                    },
-                    Reply::Headers(headers) => {
-                        *res.headers_mut() = headers;
-                    },
-                    Reply::Body(body) => {
-                        res.set_body(body);
-                    },
-                }
-            }
-            res
-        }).boxed()
-    }
-
-}
-
-fn connect(addr: &SocketAddr) -> TcpStream {
-    let req = TcpStream::connect(addr).unwrap();
-    req.set_read_timeout(Some(Duration::from_secs(1))).unwrap();
-    req.set_write_timeout(Some(Duration::from_secs(1))).unwrap();
-    req
-}
-
-fn serve() -> Serve {
-    serve_with_options(Default::default())
-}
-
-#[derive(Default)]
-struct ServeOptions {
-    keep_alive_disabled: bool,
-    timeout: Option<Duration>,
-}
-
-fn serve_with_options(options: ServeOptions) -> Serve {
-    let _ = pretty_env_logger::init();
-
-    let (addr_tx, addr_rx) = mpsc::channel();
-    let (msg_tx, msg_rx) = mpsc::channel();
-    let (reply_tx, reply_rx) = spmc::channel();
-    let (shutdown_tx, shutdown_rx) = oneshot::channel();
-
-    let addr = "127.0.0.1:0".parse().unwrap();
-
-    let keep_alive = !options.keep_alive_disabled;
-    let dur = options.timeout;
-
-    let thread_name = format!("test-server-{:?}", dur);
-    let thread = thread::Builder::new().name(thread_name).spawn(move || {
-        let srv = Http::new().keep_alive(keep_alive).bind(&addr, TestService {
-            tx: Arc::new(Mutex::new(msg_tx.clone())),
-            _timeout: dur,
-            reply: reply_rx,
-        }).unwrap();
-        addr_tx.send(srv.local_addr().unwrap()).unwrap();
-        srv.run_until(shutdown_rx.then(|_| Ok(()))).unwrap();
-    }).unwrap();
-
-    let addr = addr_rx.recv().unwrap();
-
-    Serve {
-        msg_rx: msg_rx,
-        reply_tx: reply_tx,
-        addr: addr,
-        shutdown_signal: Some(shutdown_tx),
-        thread: Some(thread),
-    }
-}
-
 #[test]
-fn server_get_should_ignore_body() {
+fn get_should_ignore_body() {
     let server = serve();
 
     let mut req = connect(server.addr());
@@ -209,7 +35,7 @@ fn server_get_should_ignore_body() {
 }
 
 #[test]
-fn server_get_with_body() {
+fn get_with_body() {
     let server = serve();
     let mut req = connect(server.addr());
     req.write_all(b"\
@@ -226,7 +52,7 @@ fn server_get_with_body() {
 }
 
 #[test]
-fn server_get_fixed_response() {
+fn get_fixed_response() {
     let foo_bar = b"foo bar baz";
     let server = serve();
     server.reply()
@@ -248,7 +74,7 @@ fn server_get_fixed_response() {
 }
 
 #[test]
-fn server_get_chunked_response() {
+fn get_chunked_response() {
     let foo_bar = b"foo bar baz";
     let server = serve();
     server.reply()
@@ -270,7 +96,7 @@ fn server_get_chunked_response() {
 }
 
 #[test]
-fn server_get_chunked_response_with_ka() {
+fn get_chunked_response_with_ka() {
     let foo_bar = b"foo bar baz";
     let foo_bar_chunk = b"\r\nfoo bar baz\r\n0\r\n\r\n";
     let server = serve();
@@ -324,10 +150,8 @@ fn server_get_chunked_response_with_ka() {
     }
 }
 
-
-
 #[test]
-fn server_post_with_chunked_body() {
+fn post_with_chunked_body() {
     let server = serve();
     let mut req = connect(server.addr());
     req.write_all(b"\
@@ -350,7 +174,7 @@ fn server_post_with_chunked_body() {
 }
 
 #[test]
-fn server_empty_response_chunked() {
+fn empty_response_chunked() {
     let server = serve();
 
     server.reply()
@@ -384,7 +208,7 @@ fn server_empty_response_chunked() {
 }
 
 #[test]
-fn server_empty_response_chunked_without_body_should_set_content_length() {
+fn empty_response_chunked_without_body_should_set_content_length() {
     extern crate pretty_env_logger;
     let _ = pretty_env_logger::init();
     let server = serve();
@@ -414,7 +238,66 @@ fn server_empty_response_chunked_without_body_should_set_content_length() {
 }
 
 #[test]
-fn server_keep_alive() {
+fn head_response_can_send_content_length() {
+    extern crate pretty_env_logger;
+    let _ = pretty_env_logger::init();
+    let server = serve();
+    server.reply()
+        .status(hyper::Ok)
+        .header(hyper::header::ContentLength(1024));
+    let mut req = connect(server.addr());
+    req.write_all(b"\
+        HEAD / HTTP/1.1\r\n\
+        Host: example.domain\r\n\
+        Connection: close\r\n\
+        \r\n\
+    ").unwrap();
+
+    let mut response = String::new();
+    req.read_to_string(&mut response).unwrap();
+
+    assert!(response.contains("Content-Length: 1024\r\n"));
+
+    let mut lines = response.lines();
+    assert_eq!(lines.next(), Some("HTTP/1.1 200 OK"));
+
+    let mut lines = lines.skip_while(|line| !line.is_empty());
+    assert_eq!(lines.next(), Some(""));
+    assert_eq!(lines.next(), None);
+}
+
+#[test]
+fn response_does_not_set_chunked_if_body_not_allowed() {
+    extern crate pretty_env_logger;
+    let _ = pretty_env_logger::init();
+    let server = serve();
+    server.reply()
+        .status(hyper::StatusCode::NotModified)
+        .header(hyper::header::TransferEncoding::chunked());
+    let mut req = connect(server.addr());
+    req.write_all(b"\
+        GET / HTTP/1.1\r\n\
+        Host: example.domain\r\n\
+        Connection: close\r\n\
+        \r\n\
+    ").unwrap();
+
+    let mut response = String::new();
+    req.read_to_string(&mut response).unwrap();
+
+    assert!(!response.contains("Transfer-Encoding"));
+
+    let mut lines = response.lines();
+    assert_eq!(lines.next(), Some("HTTP/1.1 304 Not Modified"));
+
+    // no body or 0\r\n\r\n
+    let mut lines = lines.skip_while(|line| !line.is_empty());
+    assert_eq!(lines.next(), Some(""));
+    assert_eq!(lines.next(), None);
+}
+
+#[test]
+fn keep_alive() {
     let foo_bar = b"foo bar baz";
     let server = serve();
     server.reply()
@@ -467,8 +350,8 @@ fn server_keep_alive() {
 }
 
 #[test]
-fn test_server_disable_keep_alive() {
-  let foo_bar = b"foo bar baz";
+fn disable_keep_alive() {
+    let foo_bar = b"foo bar baz";
     let server = serve_with_options(ServeOptions {
         keep_alive_disabled: true,
         .. Default::default()
@@ -553,3 +436,183 @@ fn expect_continue() {
     let body = server.body();
     assert_eq!(body, msg);
 }
+
+// -------------------------------------------------
+// the Server that is used to run all the tests with
+// -------------------------------------------------
+
+struct Serve {
+    addr: SocketAddr,
+    msg_rx: mpsc::Receiver<Msg>,
+    reply_tx: spmc::Sender<Reply>,
+    shutdown_signal: Option<oneshot::Sender<()>>,
+    thread: Option<thread::JoinHandle<()>>,
+}
+
+impl Serve {
+    fn addr(&self) -> &SocketAddr {
+        &self.addr
+    }
+
+    fn body(&self) -> Vec<u8> {
+        let mut buf = vec![];
+        while let Ok(Msg::Chunk(msg)) = self.msg_rx.try_recv() {
+            buf.extend(&msg);
+        }
+        buf
+    }
+
+    fn reply(&self) -> ReplyBuilder {
+        ReplyBuilder {
+            tx: &self.reply_tx
+        }
+    }
+}
+
+struct ReplyBuilder<'a> {
+    tx: &'a spmc::Sender<Reply>,
+}
+
+impl<'a> ReplyBuilder<'a> {
+    fn status(self, status: hyper::StatusCode) -> Self {
+        self.tx.send(Reply::Status(status)).unwrap();
+        self
+    }
+
+    fn header<H: hyper::header::Header>(self, header: H) -> Self {
+        let mut headers = hyper::Headers::new();
+        headers.set(header);
+        self.tx.send(Reply::Headers(headers)).unwrap();
+        self
+    }
+
+    fn body<T: AsRef<[u8]>>(self, body: T) {
+        self.tx.send(Reply::Body(body.as_ref().into())).unwrap();
+    }
+}
+
+impl Drop for Serve {
+    fn drop(&mut self) {
+        drop(self.shutdown_signal.take());
+        self.thread.take().unwrap().join().unwrap();
+    }
+}
+
+#[derive(Clone)]
+struct TestService {
+    tx: Arc<Mutex<mpsc::Sender<Msg>>>,
+    reply: spmc::Receiver<Reply>,
+    _timeout: Option<Duration>,
+}
+
+#[derive(Clone, Debug)]
+enum Reply {
+    Status(hyper::StatusCode),
+    Headers(hyper::Headers),
+    Body(Vec<u8>),
+}
+
+enum Msg {
+    //Head(Request),
+    Chunk(Vec<u8>),
+}
+
+impl NewService for TestService {
+    type Request = Request;
+    type Response = Response;
+    type Error = hyper::Error;
+
+    type Instance = TestService;
+
+    fn new_service(&self) -> std::io::Result<TestService> {
+        Ok(self.clone())
+    }
+
+
+}
+
+impl Service for TestService {
+    type Request = Request;
+    type Response = Response;
+    type Error = hyper::Error;
+    type Future = Box<Future<Item=Response, Error=hyper::Error>>;
+    fn call(&self, req: Request) -> Self::Future {
+        let tx = self.tx.clone();
+        let replies = self.reply.clone();
+        req.body().for_each(move |chunk| {
+            tx.lock().unwrap().send(Msg::Chunk(chunk.to_vec())).unwrap();
+            Ok(())
+        }).map(move |_| {
+            let mut res = Response::new();
+            while let Ok(reply) = replies.try_recv() {
+                match reply {
+                    Reply::Status(s) => {
+                        res.set_status(s);
+                    },
+                    Reply::Headers(headers) => {
+                        *res.headers_mut() = headers;
+                    },
+                    Reply::Body(body) => {
+                        res.set_body(body);
+                    },
+                }
+            }
+            res
+        }).boxed()
+    }
+
+}
+
+fn connect(addr: &SocketAddr) -> TcpStream {
+    let req = TcpStream::connect(addr).unwrap();
+    req.set_read_timeout(Some(Duration::from_secs(1))).unwrap();
+    req.set_write_timeout(Some(Duration::from_secs(1))).unwrap();
+    req
+}
+
+fn serve() -> Serve {
+    serve_with_options(Default::default())
+}
+
+#[derive(Default)]
+struct ServeOptions {
+    keep_alive_disabled: bool,
+    timeout: Option<Duration>,
+}
+
+fn serve_with_options(options: ServeOptions) -> Serve {
+    let _ = pretty_env_logger::init();
+
+    let (addr_tx, addr_rx) = mpsc::channel();
+    let (msg_tx, msg_rx) = mpsc::channel();
+    let (reply_tx, reply_rx) = spmc::channel();
+    let (shutdown_tx, shutdown_rx) = oneshot::channel();
+
+    let addr = "127.0.0.1:0".parse().unwrap();
+
+    let keep_alive = !options.keep_alive_disabled;
+    let dur = options.timeout;
+
+    let thread_name = format!("test-server-{:?}", dur);
+    let thread = thread::Builder::new().name(thread_name).spawn(move || {
+        let srv = Http::new().keep_alive(keep_alive).bind(&addr, TestService {
+            tx: Arc::new(Mutex::new(msg_tx.clone())),
+            _timeout: dur,
+            reply: reply_rx,
+        }).unwrap();
+        addr_tx.send(srv.local_addr().unwrap()).unwrap();
+        srv.run_until(shutdown_rx.then(|_| Ok(()))).unwrap();
+    }).unwrap();
+
+    let addr = addr_rx.recv().unwrap();
+
+    Serve {
+        msg_rx: msg_rx,
+        reply_tx: reply_tx,
+        addr: addr,
+        shutdown_signal: Some(shutdown_tx),
+        thread: Some(thread),
+    }
+}
+
+
