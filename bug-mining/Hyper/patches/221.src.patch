diff --git a/src/proto/h1/conn.rs b/src/proto/h1/conn.rs
index 3022529e..05755368 100644
--- a/src/proto/h1/conn.rs
+++ b/src/proto/h1/conn.rs
@@ -902,7 +902,6 @@ impl State {
     }
 
     fn prepare_upgrade(&mut self) -> crate::upgrade::OnUpgrade {
-        debug_assert!(self.upgrade.is_none());
         let (tx, rx) = crate::upgrade::pending();
         self.upgrade = Some(tx);
         rx
diff --git a/tests/server.rs b/tests/server.rs
index 903b935e..054dfc8a 100644
--- a/tests/server.rs
+++ b/tests/server.rs
@@ -1323,6 +1323,46 @@ async fn upgrades_new() {
     assert_eq!(s(&vec), "bar=foo");
 }
 
+#[tokio::test]
+async fn upgrades_ignored() {
+    let _ = pretty_env_logger::try_init();
+    let mut listener = tcp_bind(&"127.0.0.1:0".parse().unwrap()).unwrap();
+    let addr = listener.local_addr().unwrap();
+
+    tokio::spawn(async move {
+        let svc = service_fn(move |req: Request<Body>| {
+            assert_eq!(req.headers()["upgrade"], "yolo");
+            future::ok::<_, hyper::Error>(Response::new(hyper::Body::empty()))
+        });
+
+        let (socket, _) = listener.accept().await.unwrap();
+        Http::new()
+            .serve_connection(socket, svc)
+            .with_upgrades()
+            .await
+            .expect("server task");
+    });
+
+    let client = hyper::Client::new();
+    let url = format!("http://{}/", addr);
+
+    let make_req = || {
+        hyper::Request::builder()
+            .uri(&*url)
+            .header("upgrade", "yolo")
+            .header("connection", "upgrade")
+            .body(hyper::Body::empty())
+            .expect("make_req")
+    };
+
+    let res1 = client.request(make_req()).await.expect("req 1");
+    assert_eq!(res1.status(), 200);
+    drop(res1);
+
+    let res2 = client.request(make_req()).await.expect("req 2");
+    assert_eq!(res2.status(), 200);
+}
+
 #[tokio::test]
 async fn http_connect_new() {
     use tokio::io::{AsyncReadExt, AsyncWriteExt};
