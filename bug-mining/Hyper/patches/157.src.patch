diff --git a/src/client/conn.rs b/src/client/conn.rs
index 0a89f903..97689bb5 100644
--- a/src/client/conn.rs
+++ b/src/client/conn.rs
@@ -354,7 +354,7 @@ where
     ///
     /// Only works for HTTP/1 connections. HTTP/2 connections will panic.
     pub fn into_parts(self) -> Parts<T> {
-        let (io, read_buf) = match self.inner {
+        let (io, read_buf, _) = match self.inner {
             Either::A(h1) => h1.into_inner(),
             Either::B(_h2) => {
                 panic!("http2 cannot into_inner");
diff --git a/src/proto/h1/dispatch.rs b/src/proto/h1/dispatch.rs
index db2c471d..8cd7665d 100644
--- a/src/proto/h1/dispatch.rs
+++ b/src/proto/h1/dispatch.rs
@@ -27,7 +27,7 @@ pub(crate) trait Dispatch {
 
 pub struct Server<S: Service> {
     in_flight: Option<S::Future>,
-    service: S,
+    pub(crate) service: S,
 }
 
 pub struct Client<B> {
@@ -58,8 +58,9 @@ where
         self.conn.disable_keep_alive()
     }
 
-    pub fn into_inner(self) -> (I, Bytes) {
-        self.conn.into_inner()
+    pub fn into_inner(self) -> (I, Bytes, D) {
+        let (io, buf) = self.conn.into_inner();
+        (io, buf, self.dispatch)
     }
 
     /// The "Future" poll function. Runs this dispatcher until the
diff --git a/src/server/conn.rs b/src/server/conn.rs
index d607900a..e650ec83 100644
--- a/src/server/conn.rs
+++ b/src/server/conn.rs
@@ -98,7 +98,7 @@ where
 /// This allows taking apart a `Connection` at a later time, in order to
 /// reclaim the IO object, and additional related pieces.
 #[derive(Debug)]
-pub struct Parts<T> {
+pub struct Parts<T, S> {
     /// The original IO object used in the handshake.
     pub io: T,
     /// A buffer of bytes that have been read but not processed as HTTP.
@@ -110,6 +110,8 @@ pub struct Parts<T> {
     /// You will want to check for any existing bytes if you plan to continue
     /// communicating on the IO object.
     pub read_buf: Bytes,
+    /// The `Service` used to serve this connection.
+    pub service: S,
     _inner: (),
 }
 
@@ -335,8 +337,8 @@ where
     /// This should only be called after `poll_without_shutdown` signals
     /// that the connection is "done". Otherwise, it may not have finished
     /// flushing all necessary HTTP bytes.
-    pub fn into_parts(self) -> Parts<I> {
-        let (io, read_buf) = match self.conn {
+    pub fn into_parts(self) -> Parts<I, S> {
+        let (io, read_buf, dispatch) = match self.conn {
             Either::A(h1) => {
                 h1.into_inner()
             },
@@ -347,6 +349,7 @@ where
         Parts {
             io: io,
             read_buf: read_buf,
+            service: dispatch.service,
             _inner: (),
         }
     }
