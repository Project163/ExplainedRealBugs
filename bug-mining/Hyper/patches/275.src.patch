diff --git a/capi/examples/upload.c b/capi/examples/upload.c
index 9b791eed..4bf44e65 100644
--- a/capi/examples/upload.c
+++ b/capi/examples/upload.c
@@ -153,11 +153,6 @@ static void print_informational(void *userdata, hyper_response *resp) {
     uint16_t http_status = hyper_response_status(resp);
 
     printf("\nInformational (1xx): %d\n", http_status);
-
-    const hyper_buf *headers = hyper_response_headers_raw(resp);
-    if (headers) {
-        write(1, hyper_buf_bytes(headers), hyper_buf_len(headers));
-    }
 }
 
 typedef enum {
@@ -228,7 +223,6 @@ int main(int argc, char *argv[]) {
     // Prepare client options
     hyper_clientconn_options *opts = hyper_clientconn_options_new();
     hyper_clientconn_options_exec(opts, exec);
-    hyper_clientconn_options_headers_raw(opts, 1);
 
     hyper_task *handshake = hyper_clientconn_handshake(io, opts);
     hyper_task_set_userdata(handshake, (void *)EXAMPLE_HANDSHAKE);
diff --git a/capi/include/hyper.h b/capi/include/hyper.h
index 16487f08..d41ccaac 100644
--- a/capi/include/hyper.h
+++ b/capi/include/hyper.h
@@ -391,17 +391,6 @@ void hyper_clientconn_options_exec(struct hyper_clientconn_options *opts,
  */
 enum hyper_code hyper_clientconn_options_http2(struct hyper_clientconn_options *opts, int enabled);
 
-/*
- Set the whether to include a copy of the raw headers in responses
- received on this connection.
-
- Pass `0` to disable, `1` to enable.
-
- If enabled, see `hyper_response_headers_raw()` for usage.
- */
-enum hyper_code hyper_clientconn_options_headers_raw(struct hyper_clientconn_options *opts,
-                                                     int enabled);
-
 /*
  Set whether HTTP/1 connections will accept obsolete line folding for header values.
  Newline codepoints (\r and \n) will be transformed to spaces when parsing.
@@ -567,21 +556,6 @@ const uint8_t *hyper_response_reason_phrase(const struct hyper_response *resp);
  */
 size_t hyper_response_reason_phrase_len(const struct hyper_response *resp);
 
-/*
- Get a reference to the full raw headers of this response.
-
- You must have enabled `hyper_clientconn_options_headers_raw()`, or this
- will return NULL.
-
- The returned `hyper_buf *` is just a reference, owned by the response.
- You need to make a copy if you wish to use it after freeing the
- response.
-
- The buffer is not null-terminated, see the `hyper_buf` functions for
- getting the bytes and length.
- */
-const struct hyper_buf *hyper_response_headers_raw(const struct hyper_response *resp);
-
 /*
  Get the HTTP version used by this response.
 
diff --git a/src/client/conn/http1.rs b/src/client/conn/http1.rs
index c4776fda..ad100f88 100644
--- a/src/client/conn/http1.rs
+++ b/src/client/conn/http1.rs
@@ -108,8 +108,6 @@ pub struct Builder {
     h1_title_case_headers: bool,
     h1_preserve_header_case: bool,
     #[cfg(feature = "ffi")]
-    h1_headers_raw: bool,
-    #[cfg(feature = "ffi")]
     h1_preserve_header_order: bool,
     h1_read_buf_exact_size: Option<usize>,
     h1_max_buf_size: Option<usize>,
@@ -300,8 +298,6 @@ impl Builder {
             h1_title_case_headers: false,
             h1_preserve_header_case: false,
             #[cfg(feature = "ffi")]
-            h1_headers_raw: false,
-            #[cfg(feature = "ffi")]
             h1_preserve_header_order: false,
             h1_max_buf_size: None,
         }
@@ -456,12 +452,6 @@ impl Builder {
         self
     }
 
-    #[cfg(feature = "ffi")]
-    pub(crate) fn http1_headers_raw(&mut self, enabled: bool) -> &mut Builder {
-        self.h1_headers_raw = enabled;
-        self
-    }
-
     /// Sets the exact size of the read buffer to *always* use.
     ///
     /// Note that setting this option unsets the `http1_max_buf_size` option.
@@ -535,10 +525,7 @@ impl Builder {
             if opts.h1_preserve_header_order {
                 conn.set_preserve_header_order();
             }
-            #[cfg(feature = "ffi")]
-            if opts.h1_headers_raw {
-                conn.set_raw_headers(true);
-            }
+
             if opts.h09_responses {
                 conn.set_h09_responses();
             }
diff --git a/src/ffi/client.rs b/src/ffi/client.rs
index 637b490e..8cd1dca4 100644
--- a/src/ffi/client.rs
+++ b/src/ffi/client.rs
@@ -14,7 +14,6 @@ use super::task::{hyper_executor, hyper_task, hyper_task_return_type, AsTaskType
 /// An options builder to configure an HTTP client connection.
 pub struct hyper_clientconn_options {
     http1_allow_obsolete_multiline_headers_in_responses: bool,
-    http1_headers_raw: bool,
     http1_preserve_header_case: bool,
     http1_preserve_header_order: bool,
     http2: bool,
@@ -72,7 +71,6 @@ ffi_fn! {
             conn::http1::Builder::new()
                 .executor(options.exec.clone())
                 .http1_allow_obsolete_multiline_headers_in_responses(options.http1_allow_obsolete_multiline_headers_in_responses)
-                .http1_headers_raw(options.http1_headers_raw)
                 .http1_preserve_header_case(options.http1_preserve_header_case)
                 .http1_preserve_header_order(options.http1_preserve_header_order)
                 .handshake::<_, crate::Recv>(io)
@@ -131,7 +129,6 @@ ffi_fn! {
     fn hyper_clientconn_options_new() -> *mut hyper_clientconn_options {
         Box::into_raw(Box::new(hyper_clientconn_options {
             http1_allow_obsolete_multiline_headers_in_responses: false,
-            http1_headers_raw: false,
             http1_preserve_header_case: false,
             http1_preserve_header_order: false,
             http2: false,
@@ -203,20 +200,6 @@ ffi_fn! {
     }
 }
 
-ffi_fn! {
-    /// Set the whether to include a copy of the raw headers in responses
-    /// received on this connection.
-    ///
-    /// Pass `0` to disable, `1` to enable.
-    ///
-    /// If enabled, see `hyper_response_headers_raw()` for usage.
-    fn hyper_clientconn_options_headers_raw(opts: *mut hyper_clientconn_options, enabled: c_int) -> hyper_code {
-        let opts = non_null! { &mut *opts ?= hyper_code::HYPERE_INVALID_ARG };
-        opts.http1_headers_raw = enabled != 0;
-        hyper_code::HYPERE_OK
-    }
-}
-
 ffi_fn! {
     /// Set whether HTTP/1 connections will accept obsolete line folding for header values.
     /// Newline codepoints (\r and \n) will be transformed to spaces when parsing.
diff --git a/src/ffi/http_types.rs b/src/ffi/http_types.rs
index 885b31c7..a10c10bd 100644
--- a/src/ffi/http_types.rs
+++ b/src/ffi/http_types.rs
@@ -2,7 +2,7 @@ use bytes::Bytes;
 use libc::{c_int, size_t};
 use std::ffi::c_void;
 
-use super::body::{hyper_body, hyper_buf};
+use super::body::hyper_body;
 use super::error::hyper_code;
 use super::task::{hyper_task_return_type, AsTaskType};
 use super::{UserDataPointer, HYPER_ITER_CONTINUE};
@@ -25,8 +25,6 @@ pub struct hyper_headers {
     orig_order: OriginalHeaderOrder,
 }
 
-pub(crate) struct RawHeaders(pub(crate) hyper_buf);
-
 pub(crate) struct OnInformational {
     func: hyper_request_on_informational_callback,
     data: UserDataPointer,
@@ -278,27 +276,6 @@ ffi_fn! {
     }
 }
 
-ffi_fn! {
-    /// Get a reference to the full raw headers of this response.
-    ///
-    /// You must have enabled `hyper_clientconn_options_headers_raw()`, or this
-    /// will return NULL.
-    ///
-    /// The returned `hyper_buf *` is just a reference, owned by the response.
-    /// You need to make a copy if you wish to use it after freeing the
-    /// response.
-    ///
-    /// The buffer is not null-terminated, see the `hyper_buf` functions for
-    /// getting the bytes and length.
-    fn hyper_response_headers_raw(resp: *const hyper_response) -> *const hyper_buf {
-        let resp = non_null!(&*resp ?= std::ptr::null());
-        match resp.0.extensions().get::<RawHeaders>() {
-            Some(raw) => &raw.0,
-            None => std::ptr::null(),
-        }
-    } ?= std::ptr::null()
-}
-
 ffi_fn! {
     /// Get the HTTP version used by this response.
     ///
diff --git a/src/proto/h1/conn.rs b/src/proto/h1/conn.rs
index 59a7bb05..3250b7f3 100644
--- a/src/proto/h1/conn.rs
+++ b/src/proto/h1/conn.rs
@@ -68,8 +68,6 @@ where
                 h09_responses: false,
                 #[cfg(feature = "ffi")]
                 on_informational: None,
-                #[cfg(feature = "ffi")]
-                raw_headers: false,
                 notify_read: false,
                 reading: Reading::Init,
                 writing: Writing::Init,
@@ -142,11 +140,6 @@ where
         self.state.allow_half_close = true;
     }
 
-    #[cfg(feature = "ffi")]
-    pub(crate) fn set_raw_headers(&mut self, enabled: bool) {
-        self.state.raw_headers = enabled;
-    }
-
     pub(crate) fn into_inner(self) -> (I, Bytes) {
         self.io.into_inner()
     }
@@ -219,8 +212,6 @@ where
                 h09_responses: self.state.h09_responses,
                 #[cfg(feature = "ffi")]
                 on_informational: &mut self.state.on_informational,
-                #[cfg(feature = "ffi")]
-                raw_headers: self.state.raw_headers,
             }
         )) {
             Ok(msg) => msg,
@@ -828,8 +819,6 @@ struct State {
     /// received.
     #[cfg(feature = "ffi")]
     on_informational: Option<crate::ffi::OnInformational>,
-    #[cfg(feature = "ffi")]
-    raw_headers: bool,
     /// Set to true when the Dispatcher should poll read operations
     /// again. See the `maybe_notify` method for more.
     notify_read: bool,
diff --git a/src/proto/h1/io.rs b/src/proto/h1/io.rs
index 0aba58f0..da4101b6 100644
--- a/src/proto/h1/io.rs
+++ b/src/proto/h1/io.rs
@@ -197,8 +197,6 @@ where
                     h09_responses: parse_ctx.h09_responses,
                     #[cfg(feature = "ffi")]
                     on_informational: parse_ctx.on_informational,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: parse_ctx.raw_headers,
                 },
             )? {
                 Some(msg) => {
@@ -738,8 +736,6 @@ mod tests {
                 h09_responses: false,
                 #[cfg(feature = "ffi")]
                 on_informational: &mut None,
-                #[cfg(feature = "ffi")]
-                raw_headers: false,
             };
             assert!(buffered
                 .parse::<ClientTransaction>(cx, parse_ctx)
diff --git a/src/proto/h1/mod.rs b/src/proto/h1/mod.rs
index 73eeb529..86561c37 100644
--- a/src/proto/h1/mod.rs
+++ b/src/proto/h1/mod.rs
@@ -92,8 +92,6 @@ pub(crate) struct ParseContext<'a> {
     h09_responses: bool,
     #[cfg(feature = "ffi")]
     on_informational: &'a mut Option<crate::ffi::OnInformational>,
-    #[cfg(feature = "ffi")]
-    raw_headers: bool,
 }
 
 /// Passed to Http1Transaction::encode
diff --git a/src/proto/h1/role.rs b/src/proto/h1/role.rs
index 638ca4c2..37072384 100644
--- a/src/proto/h1/role.rs
+++ b/src/proto/h1/role.rs
@@ -1064,11 +1064,6 @@ impl Http1Transaction for Client {
                 extensions.insert(reason);
             }
 
-            #[cfg(feature = "ffi")]
-            if ctx.raw_headers {
-                extensions.insert(crate::ffi::RawHeaders(crate::ffi::hyper_buf(slice)));
-            }
-
             let head = MessageHead {
                 version,
                 subject: status,
@@ -1590,8 +1585,6 @@ mod tests {
                 h09_responses: false,
                 #[cfg(feature = "ffi")]
                 on_informational: &mut None,
-                #[cfg(feature = "ffi")]
-                raw_headers: false,
             },
         )
         .unwrap()
@@ -1623,8 +1616,6 @@ mod tests {
             h09_responses: false,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         let msg = Client::parse(&mut raw, ctx).unwrap().unwrap();
         assert_eq!(raw.len(), 0);
@@ -1651,8 +1642,6 @@ mod tests {
             h09_responses: false,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         Server::parse(&mut raw, ctx).unwrap_err();
     }
@@ -1677,8 +1666,6 @@ mod tests {
             h09_responses: true,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         let msg = Client::parse(&mut raw, ctx).unwrap().unwrap();
         assert_eq!(raw, H09_RESPONSE);
@@ -1705,8 +1692,6 @@ mod tests {
             h09_responses: false,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         Client::parse(&mut raw, ctx).unwrap_err();
         assert_eq!(raw, H09_RESPONSE);
@@ -1737,8 +1722,6 @@ mod tests {
             h09_responses: false,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         let msg = Client::parse(&mut raw, ctx).unwrap().unwrap();
         assert_eq!(raw.len(), 0);
@@ -1766,8 +1749,6 @@ mod tests {
             h09_responses: false,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         Client::parse(&mut raw, ctx).unwrap_err();
     }
@@ -1790,8 +1771,6 @@ mod tests {
             h09_responses: false,
             #[cfg(feature = "ffi")]
             on_informational: &mut None,
-            #[cfg(feature = "ffi")]
-            raw_headers: false,
         };
         let parsed_message = Server::parse(&mut raw, ctx).unwrap().unwrap();
         let orig_headers = parsed_message
@@ -1835,8 +1814,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 },
             )
             .expect("parse ok")
@@ -1861,8 +1838,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 },
             )
             .expect_err(comment)
@@ -2096,8 +2071,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 }
             )
             .expect("parse ok")
@@ -2122,8 +2095,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 },
             )
             .expect("parse ok")
@@ -2148,8 +2119,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 },
             )
             .expect_err("parse should err")
@@ -2669,8 +2638,6 @@ mod tests {
                 h09_responses: false,
                 #[cfg(feature = "ffi")]
                 on_informational: &mut None,
-                #[cfg(feature = "ffi")]
-                raw_headers: false,
             },
         )
         .expect("parse ok")
@@ -2759,8 +2726,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 },
             )
             .unwrap()
@@ -2805,8 +2770,6 @@ mod tests {
                     h09_responses: false,
                     #[cfg(feature = "ffi")]
                     on_informational: &mut None,
-                    #[cfg(feature = "ffi")]
-                    raw_headers: false,
                 },
             )
             .unwrap()
