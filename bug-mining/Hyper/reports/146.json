{"url":"https://api.github.com/repos/hyperium/hyper/issues/1439","repository_url":"https://api.github.com/repos/hyperium/hyper","labels_url":"https://api.github.com/repos/hyperium/hyper/issues/1439/labels{/name}","comments_url":"https://api.github.com/repos/hyperium/hyper/issues/1439/comments","events_url":"https://api.github.com/repos/hyperium/hyper/issues/1439/events","html_url":"https://github.com/hyperium/hyper/issues/1439","id":296090828,"node_id":"MDU6SXNzdWUyOTYwOTA4Mjg=","number":1439,"title":"Connection stuck when \"keep alive\" is used","user":{"login":"idubrov","id":434788,"node_id":"MDQ6VXNlcjQzNDc4OA==","avatar_url":"https://avatars.githubusercontent.com/u/434788?v=4","gravatar_id":"","url":"https://api.github.com/users/idubrov","html_url":"https://github.com/idubrov","followers_url":"https://api.github.com/users/idubrov/followers","following_url":"https://api.github.com/users/idubrov/following{/other_user}","gists_url":"https://api.github.com/users/idubrov/gists{/gist_id}","starred_url":"https://api.github.com/users/idubrov/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/idubrov/subscriptions","organizations_url":"https://api.github.com/users/idubrov/orgs","repos_url":"https://api.github.com/users/idubrov/repos","events_url":"https://api.github.com/users/idubrov/events{/privacy}","received_events_url":"https://api.github.com/users/idubrov/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2018-02-10T10:29:36Z","updated_at":"2018-02-13T02:32:27Z","closed_at":"2018-02-13T02:16:50Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"I have a simple client that sends requests in chunks of 5 and after a while this client stucks.\r\n\r\nThe client looks like this:\r\n```\r\n  let mut core = tokio_core::reactor::Core::new().unwrap();\r\n  let handle = core.handle();\r\n  let items = ... // long list of Hyper requests\r\n  let client = Client::new(&handle);\r\n  let requests = stream::iter_result(items)\r\n    .chunks(concurrency)\r\n    .for_each(|reqs| {\r\n      info!(\"Running {} tasks ...\", concurrency);\r\n      let vec = reqs\r\n        .into_iter()\r\n        .map(|(path, request)| process_request(&client, &path, request))\r\n        .collect::<Vec<_>>();\r\n      future::join_all(vec).map(|_results| ())\r\n    });\r\n\r\n  core.run(requests).unwrap();\r\n```\r\n\r\nDebugger shows that it waits for the mio event (sits in mio::sys::unix::kqueue::Selector::select):\r\n\r\n```\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP\r\n  * frame #0: 0x0000000106b7bd96 libsystem_kernel.dylib`kevent + 10\r\n    frame #1: 0x0000000104f94c03 piston`mio::sys::unix::kqueue::Selector::select::h5908d164b552abc8(self=0x0000000106e33020, evts=0x00007fff5bca9f48, awakener=(__0 = 18446744073709551615), timeout=<unavailable>) at kqueue.rs:84\r\n    frame #2: 0x0000000104f8e2fa piston`mio::poll::Poll::poll2::h47cfb2893a485481(self=0x0000000106e33020, events=0x00007fff5bca9f48, timeout=Option<std::time::duration::Duration> @ 0x00007fff5bca8ce8) at poll.rs:1161\r\n    frame #3: 0x0000000104f8e026 piston`mio::poll::Poll::poll::h1c5a4889decc5479(self=0x0000000106e33020, events=0x00007fff5bca9f48, timeout=Option<std::time::duration::Duration> @ 0x00007fff5bca91a0) at poll.rs:1125\r\n    frame #4: 0x0000000104f6a90b piston`tokio_core::reactor::Core::poll::h355d296d2c61bccc(self=0x00007fff5bca9f48, max_wait=Option<std::time::duration::Duration> @ 0x00007fff5bca9e18) at mod.rs:276\r\n    frame #5: 0x0000000104354499 piston`tokio_core::reactor::Core::run::h3e432d0bd23cd991(self=0x00007fff5bca9f48, f=<unavailable>) at mod.rs:241\r\n    frame #6: 0x000000010481faad piston`piston::submit::execute::h35469783a8e181fc(matches=0x0000000106e7c018) at submit.rs:231\r\n```\r\n\r\nAnalyzing logs shows that the following events seem to be causing the issue:\r\n\r\n```\r\n// First, I see that token of interest receives Readable | Hup event (actual token number is 0, since this is x*2+2):\r\nTRACE tokio_core::reactor               > event Readable | Hup Token(2)\r\n// I added some debugging to tokio-core dispatch_io to print status of io.reader/io.writer, here you can see that reader task is not none:\r\nDEBUG tokio_core::reactor > TKIO: is readable writer.is_none() == true, reader.is_none() == false\r\n// Client writes some data to the connection (token 0 is the same as Token(2) above, as (2-2)/2 = 0\r\nDEBUG tokio_core::net::tcp > DBG: WRITE BUFS: (token 0) Ok(63817) <-- this one I added to AsyncWrite.write_buf\r\nDEBUG hyper::proto::h1::io > flushed 63817 bytes\r\n// Finally, this is where error is returned from mio (error code is 54, ECONNRESET)\r\n// This is normal token, it works just fine (has more logging output after that line)\r\nTRACE tokio_core::reactor > event Writable Token(6)\r\n// reader task is present for this token\r\nDEBUG tokio_core::reactor > TKIO: is writable writer.is_none() == true, reader.is_none() == false\r\n// However, this token receives Error event and it is the last line in logs related to it.\r\nTRACE tokio_core::reactor > event Readable | Writable | Error | Hup Token(2)\r\n// No reader task to notify? -- reader.is_none() is true.\r\nDEBUG tokio_core::reactor > TKIO: is writable writer.is_none() == true, reader.is_none() == true```\r\n\r\nI am still researching it, but it does look like it is related to \"keep alive\" feature.\r\n\r\nIt seems like Hyper does not like it when remote side closes the socket around the time the connection is taken from the \"idle\" and used for the next request.","closed_by":{"login":"seanmonstar","id":51479,"node_id":"MDQ6VXNlcjUxNDc5","avatar_url":"https://avatars.githubusercontent.com/u/51479?v=4","gravatar_id":"","url":"https://api.github.com/users/seanmonstar","html_url":"https://github.com/seanmonstar","followers_url":"https://api.github.com/users/seanmonstar/followers","following_url":"https://api.github.com/users/seanmonstar/following{/other_user}","gists_url":"https://api.github.com/users/seanmonstar/gists{/gist_id}","starred_url":"https://api.github.com/users/seanmonstar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seanmonstar/subscriptions","organizations_url":"https://api.github.com/users/seanmonstar/orgs","repos_url":"https://api.github.com/users/seanmonstar/repos","events_url":"https://api.github.com/users/seanmonstar/events{/privacy}","received_events_url":"https://api.github.com/users/seanmonstar/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hyperium/hyper/issues/1439/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hyperium/hyper/issues/1439/timeline","performed_via_github_app":null,"state_reason":"completed"}