{"url":"https://api.github.com/repos/hyperium/hyper/issues/1438","repository_url":"https://api.github.com/repos/hyperium/hyper","labels_url":"https://api.github.com/repos/hyperium/hyper/issues/1438/labels{/name}","comments_url":"https://api.github.com/repos/hyperium/hyper/issues/1438/comments","events_url":"https://api.github.com/repos/hyperium/hyper/issues/1438/events","html_url":"https://github.com/hyperium/hyper/issues/1438","id":295686530,"node_id":"MDU6SXNzdWUyOTU2ODY1MzA=","number":1438,"title":"A proper `Body` trait","user":{"login":"seanmonstar","id":51479,"node_id":"MDQ6VXNlcjUxNDc5","avatar_url":"https://avatars.githubusercontent.com/u/51479?v=4","gravatar_id":"","url":"https://api.github.com/users/seanmonstar","html_url":"https://github.com/seanmonstar","followers_url":"https://api.github.com/users/seanmonstar/followers","following_url":"https://api.github.com/users/seanmonstar/following{/other_user}","gists_url":"https://api.github.com/users/seanmonstar/gists{/gist_id}","starred_url":"https://api.github.com/users/seanmonstar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seanmonstar/subscriptions","organizations_url":"https://api.github.com/users/seanmonstar/orgs","repos_url":"https://api.github.com/users/seanmonstar/repos","events_url":"https://api.github.com/users/seanmonstar/events{/privacy}","received_events_url":"https://api.github.com/users/seanmonstar/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":694496598,"node_id":"MDU6TGFiZWw2OTQ0OTY1OTg=","url":"https://api.github.com/repos/hyperium/hyper/labels/C-feature","name":"C-feature","color":"f9d0c4","default":false,"description":"Category: feature. This is adding a new feature."},{"id":872551013,"node_id":"MDU6TGFiZWw4NzI1NTEwMTM=","url":"https://api.github.com/repos/hyperium/hyper/labels/A-body","name":"A-body","color":"fbca04","default":false,"description":"Area: body streaming."}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":{"url":"https://api.github.com/repos/hyperium/hyper/milestones/4","html_url":"https://github.com/hyperium/hyper/milestone/4","labels_url":"https://api.github.com/repos/hyperium/hyper/milestones/4/labels","id":2338703,"node_id":"MDk6TWlsZXN0b25lMjMzODcwMw==","number":4,"title":"0.12","description":"","creator":{"login":"seanmonstar","id":51479,"node_id":"MDQ6VXNlcjUxNDc5","avatar_url":"https://avatars.githubusercontent.com/u/51479?v=4","gravatar_id":"","url":"https://api.github.com/users/seanmonstar","html_url":"https://github.com/seanmonstar","followers_url":"https://api.github.com/users/seanmonstar/followers","following_url":"https://api.github.com/users/seanmonstar/following{/other_user}","gists_url":"https://api.github.com/users/seanmonstar/gists{/gist_id}","starred_url":"https://api.github.com/users/seanmonstar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seanmonstar/subscriptions","organizations_url":"https://api.github.com/users/seanmonstar/orgs","repos_url":"https://api.github.com/users/seanmonstar/repos","events_url":"https://api.github.com/users/seanmonstar/events{/privacy}","received_events_url":"https://api.github.com/users/seanmonstar/received_events","type":"User","user_view_type":"public","site_admin":false},"open_issues":0,"closed_issues":24,"state":"closed","created_at":"2017-02-21T19:39:36Z","updated_at":"2018-06-01T23:09:51Z","due_on":null,"closed_at":"2018-06-01T23:09:51Z"},"comments":9,"created_at":"2018-02-08T22:21:16Z","updated_at":"2019-05-07T19:04:47Z","closed_at":"2018-03-14T20:01:03Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Currently (v0.11), hyper allows using any `impl Stream<Item=impl AsRef<[u8]>, Error=hyper::Error>` as the send body for requests and response. That should likely be changed, since it currently prevents using new features from HTTP2. While we can upgrade the current receive stream to have inherent methods to do new things, there is no way for hyper to use them with send streams. Here's some new features we'd like to support:\r\n\r\n- HTTP trailers: while defined in HTTP/1.1, they were rarely ever used, but HTTP/2 makes them easy to use, and new things are using them, like gRPC.\r\n- Push promises: while a design isn't settled yet, it's possible for a push promise to arrive after the headers, and a user may wish to be able to send new push promises after having gotten part way though a body.\r\n- Flow control? To start with, hyper will manage flow control internally, but we may want to add the ability for users to control that themselves. If so, they would be new methods on the trait with default implementations.\r\n- Other new frame types that get added to HTTP/2.\r\n- Being able to adjust the reset code sent before dropping the stream.\r\n\r\nTo accomplish this, hyper probably needs to define it's own trait, so that new features can be added later.\r\n\r\n## The `Body` trait\r\n\r\n```rust\r\n/// Replaces the `Stream<Item=impl AsRef<[u8]>, Error=hyper::Error>`.\r\n///\r\n/// This trait represents a streaming body of a `Request` or `Response`.\r\npub trait Body {\r\n    /// A buffer of bytes representing a single chunk of a body.\r\n    type Data: AsRef<[u8]> + 'static;\r\n    \r\n    /// The `User` error can be read more about here: https://github.com/hyperium/hyper/issues/1431\r\n    type Error: Into<hyper::error::User>;\r\n    \r\n    /// Poll for a stream of `Data` buffers.\r\n    fn poll_data(&mut self) -> Poll<Option<Self::Data>>, Self::Error>;\r\n    \r\n    /// Poll for an optional *single* `HeaderMap` of trailers. This should\r\n    /// only be called after `poll_data` has ended.\r\n    ///\r\n    /// Note: Trailers aren't currently used for HTTP/1, only for HTTP/2.\r\n    fn poll_trailers(&mut self) -> Poll<Option<HeaderMap>, Self::Error> {\r\n        Ok(Async::Ready(None))\r\n    }\r\n    \r\n    /// A hint that the `Body` is complete, and doesn't need to be polled more.\r\n    ///\r\n    /// This can be useful to determine if the there is any body or trailers\r\n    /// without having to poll. An empty `Body` could return `true` and hyper\r\n    /// would be able to know that only the headers need to be sent. Or, it can\r\n    /// also be checked after each `poll_data` call, to allow hyper to try to end\r\n    /// the underlying stream with the last chunk, instead of needing to send an\r\n    /// extra `DATA` frame just to mark the stream as finished.\r\n    ///\r\n    /// As a hint, it is used to try to optimize, and thus is OK for a default\r\n    /// implementation to return `false`.\r\n    fn is_end_stream(&self) -> bool {\r\n        false\r\n    }\r\n    \r\n    /// Return a length of the total bytes that will be streamed, if known.\r\n    ///\r\n    /// If an exact size of bytes is known, this would allow hyper to send a\r\n    /// `Content-Length` header automatically, not needing to fall back to\r\n    /// `Transfer-Encoding: chunked`.\r\n    ///\r\n    /// This does not need to be kept updated after polls, it will only be called\r\n    /// once to create the headers.\r\n    fn content_length(&self) -> Option<u64> {\r\n        None\r\n    }\r\n    \r\n    /// A callback if there is an error trying to *write* data or trailers\r\n    /// that have been polled from this `Body`.\r\n    ///\r\n    /// This can be things like declaring a certain size in `size_hint`,\r\n    /// or having manually set a `Content-Length` header, and the polled\r\n    /// data happens to be bigger. This error wouldn't necessarily close\r\n    /// the request/response message, but could be useful to know.\r\n    /// \r\n    /// Additionally, after returning a `Response<impl Body>` in a server\r\n    /// context, there isn't any other mechanism to learn of errors that\r\n    /// may occur trying to flush the body's data.\r\n    ///\r\n    /// The default implementation is to just log the error.\r\n    fn on_error(&mut self, err: hyper::Error) {\r\n        debug!(\"Body::on_error: {}\", err);\r\n    }\r\n    \r\n    // fn into_stream?\r\n    //\r\n    // This could be a simple wrapper that turns any `Body` into a\r\n    // `Stream<Item=Self::Data, Error=Self::Error>`. Besides allowing\r\n    // a user to easily convert a body into a `Stream` when something wants\r\n    // one, it could do so correctly, by making sure that once `poll_data`\r\n    // has reached the end, `poll_trailers` is also called, to allow any\r\n    // `Body` implementation to know when it was finished properly.\r\n    //\r\n    // Alternatively, instead of being on the trait itself, this could\r\n    // just be a type in the `hyper::body` module, `IntoStream<impl Body>`,\r\n    // and it can be imported directly and a constructor used...\r\n}\r\n```\r\n\r\nSome questions about the design that I still have:\r\n\r\n- **Does the signature of `poll_trailers()` look like it is a stream of trailers?** It's supposed to be like a future, only yielding once, not multiple `HeaderMap`s. It's probably fine, since `Iterator::next` returns `Option<T>`, and that doesn't mean that anything else returning `Option<T>` is iterator-like. Documentation should be enough.\r\n- **Does `content_length` pull its weight?**\r\n- **Should there a trait method `into_stream`?** Being there does mean less imports are needed, but does it conflict with `Body` trait objects? It could just be `IntoStream::new(body)`...\r\n- **Does `on_error` make sense to have?** Additionally, should it also be used to allow sending a reset error on a receive stream? For instance, if you've received the default body in a `Request` in the server, and after polling a little while, some other part of your app is on fire, should you be able to call `body.on_error(User::internal_error())` and hyper should try to send that reset error? Currently, all you can do is drop the body, and hyper will send a `CANCEL` reset.\r\n- **An alternative to separate `poll_*` methods is to use a single method, and return a non-exhaustive enum of the frames that a user can receive.** This might reduce complication around knowing what order to call methods in, especially as new events are added, like push promises.\r\n\r\n  ```rust\r\n    match await body.poll_next()? {\r\n      Some(Frame::Data(chunk)) => {},\r\n      Some(Frame::Trailers(trailers)) => {},\r\n      _ => {\r\n          // new, unknown frame type\r\n          // HTTP/2 requires new frames to be ignorable by\r\n          // those that don't understand them\r\n      }\r\n  }\r\n  ```\r\n\r\n  Then, when hyper adds push promise support, a user just needs to update their match block to handle them. If they are added in a new method, it might be confusing when to call `poll_data` vs `poll_push_promise`, etc.\r\n\r\n## The default body type\r\n\r\nSince the trait name is `Body`, the v0.11 `hyper::Body` needs a new name. So far, I haven't thought of any that I feel great about. In Java, you often find interfaces or abstract classes with the good name, and `DefaultFoo` as the implementation. ðŸ¤·â€â™‚ï¸ \r\n\r\n```rust\r\n/// What `hyper::Body` is in v0.11. Don't love the name...\r\n///\r\n/// This type serves two purposes:\r\n/// - It is the body type that is *received* from hyper, such as in\r\n///   client responses and server requests.\r\n/// - It is a simple to use default for applications to create and\r\n///   give to hyper as a send stream.\r\npub struct DefaultBody {\r\n    // ...\r\n}\r\n\r\nimpl Body for DefaultBody {\r\n    type Data = hyper::Chunk;\r\n    type Error = hyper::Error;\r\n    \r\n    // ...\r\n}\r\n\r\nimpl DefaultBody {\r\n    /// Creates a channel with a sender that can be safely passed to\r\n    /// other tasks or threads. Data can be pushed onto the sender,\r\n    /// and the associated `DefaultBody` receives it.\r\n    pub fn channel() -> (DefaultBodySender, Self) {\r\n        // ...\r\n    }\r\n    \r\n    /// Creates an empty body.\r\n    pub fn empty() -> Self {\r\n        // ...\r\n    }\r\n    \r\n    /// Create a body that yields just a single buffer.\r\n    pub fn once<T>(buf: T) -> Self\r\n    where\r\n        T: Into<Chunk>,\r\n    {\r\n        // ...\r\n    }\r\n    \r\n    /// Wraps any `Stream` as a `hyper::Body`.\r\n    ///\r\n    /// Internally, this boxes the stream, so as to not require\r\n    /// a type parameter on `Self`. If boxing is undesirable,\r\n    /// consider implementing `hyper::Body` on a custom type.\r\n    pub fn wrap_stream<T>(stream: T) -> Self\r\n    where\r\n        T: Stream + 'static,\r\n        T::Item: Into<Chunk>,\r\n        T::Error: Into<hyper::error::User>,\r\n    {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nSome things I'd like to add to the (naming, bleck) `DefaultBodySender` are:\r\n\r\n- The ability to send new frames as hyper gains support for them, like push promises.\r\n- **The ability to make closing the stream an explicit action.** Right now, with an mpsc channel, if the sender is in another thread and that that thread panics, the sender is dropped, and the receiver just assumes the stream is finished. hyper understands that as \"all good, end the writing\". However, this can be bad! If the stream had a `Content-Length`, the remote will realize the body was interrupted. But if it didn't, the remote will just assume that the ended stream is the full response. This can result in the remote treating partial content as the full content.\r\n  \r\n  I'd like for the default sender to have an option to mark that being dropped without having called `close()` should signal an error has occurred. This could either be a boolean flag you enable on the sender, or it could be a a new method that returns a guard type to be used in places where panics may happen.","closed_by":{"login":"seanmonstar","id":51479,"node_id":"MDQ6VXNlcjUxNDc5","avatar_url":"https://avatars.githubusercontent.com/u/51479?v=4","gravatar_id":"","url":"https://api.github.com/users/seanmonstar","html_url":"https://github.com/seanmonstar","followers_url":"https://api.github.com/users/seanmonstar/followers","following_url":"https://api.github.com/users/seanmonstar/following{/other_user}","gists_url":"https://api.github.com/users/seanmonstar/gists{/gist_id}","starred_url":"https://api.github.com/users/seanmonstar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seanmonstar/subscriptions","organizations_url":"https://api.github.com/users/seanmonstar/orgs","repos_url":"https://api.github.com/users/seanmonstar/repos","events_url":"https://api.github.com/users/seanmonstar/events{/privacy}","received_events_url":"https://api.github.com/users/seanmonstar/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hyperium/hyper/issues/1438/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hyperium/hyper/issues/1438/timeline","performed_via_github_app":null,"state_reason":"completed"}