{"url":"https://api.github.com/repos/hyperium/hyper/issues/1498","repository_url":"https://api.github.com/repos/hyperium/hyper","labels_url":"https://api.github.com/repos/hyperium/hyper/issues/1498/labels{/name}","comments_url":"https://api.github.com/repos/hyperium/hyper/issues/1498/comments","events_url":"https://api.github.com/repos/hyperium/hyper/issues/1498/events","html_url":"https://github.com/hyperium/hyper/issues/1498","id":317100089,"node_id":"MDU6SXNzdWUzMTcxMDAwODk=","number":1498,"title":"Client feature proposal: set_local_address","user":{"login":"kw217","id":587036,"node_id":"MDQ6VXNlcjU4NzAzNg==","avatar_url":"https://avatars.githubusercontent.com/u/587036?v=4","gravatar_id":"","url":"https://api.github.com/users/kw217","html_url":"https://github.com/kw217","followers_url":"https://api.github.com/users/kw217/followers","following_url":"https://api.github.com/users/kw217/following{/other_user}","gists_url":"https://api.github.com/users/kw217/gists{/gist_id}","starred_url":"https://api.github.com/users/kw217/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kw217/subscriptions","organizations_url":"https://api.github.com/users/kw217/orgs","repos_url":"https://api.github.com/users/kw217/repos","events_url":"https://api.github.com/users/kw217/events{/privacy}","received_events_url":"https://api.github.com/users/kw217/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":128399841,"node_id":"MDU6TGFiZWwxMjgzOTk4NDE=","url":"https://api.github.com/repos/hyperium/hyper/labels/A-client","name":"A-client","color":"fbca04","default":false,"description":"Area: client."},{"id":154002675,"node_id":"MDU6TGFiZWwxNTQwMDI2NzU=","url":"https://api.github.com/repos/hyperium/hyper/labels/E-easy","name":"E-easy","color":"0e8a16","default":false,"description":"Effort: easy. A task that would be a great starting point for a new contributor."},{"id":694496598,"node_id":"MDU6TGFiZWw2OTQ0OTY1OTg=","url":"https://api.github.com/repos/hyperium/hyper/labels/C-feature","name":"C-feature","color":"f9d0c4","default":false,"description":"Category: feature. This is adding a new feature."}],"state":"closed","locked":false,"assignee":{"login":"kw217","id":587036,"node_id":"MDQ6VXNlcjU4NzAzNg==","avatar_url":"https://avatars.githubusercontent.com/u/587036?v=4","gravatar_id":"","url":"https://api.github.com/users/kw217","html_url":"https://github.com/kw217","followers_url":"https://api.github.com/users/kw217/followers","following_url":"https://api.github.com/users/kw217/following{/other_user}","gists_url":"https://api.github.com/users/kw217/gists{/gist_id}","starred_url":"https://api.github.com/users/kw217/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kw217/subscriptions","organizations_url":"https://api.github.com/users/kw217/orgs","repos_url":"https://api.github.com/users/kw217/repos","events_url":"https://api.github.com/users/kw217/events{/privacy}","received_events_url":"https://api.github.com/users/kw217/received_events","type":"User","user_view_type":"public","site_admin":false},"assignees":[{"login":"kw217","id":587036,"node_id":"MDQ6VXNlcjU4NzAzNg==","avatar_url":"https://avatars.githubusercontent.com/u/587036?v=4","gravatar_id":"","url":"https://api.github.com/users/kw217","html_url":"https://github.com/kw217","followers_url":"https://api.github.com/users/kw217/followers","following_url":"https://api.github.com/users/kw217/following{/other_user}","gists_url":"https://api.github.com/users/kw217/gists{/gist_id}","starred_url":"https://api.github.com/users/kw217/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kw217/subscriptions","organizations_url":"https://api.github.com/users/kw217/orgs","repos_url":"https://api.github.com/users/kw217/repos","events_url":"https://api.github.com/users/kw217/events{/privacy}","received_events_url":"https://api.github.com/users/kw217/received_events","type":"User","user_view_type":"public","site_admin":false}],"milestone":null,"comments":3,"created_at":"2018-04-24T07:21:12Z","updated_at":"2018-05-01T18:58:11Z","closed_at":"2018-05-01T18:58:11Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Hi,\r\n\r\nI am using the Hyper client on a host which has multiple network interfaces. I would like to issue an HTTP request over a specific interface. The syntax should be something like this:\r\n```rust\r\n    let bind_addr: Option<IpAddr> = Some(\"127.0.0.1\".parse().unwrap());\r\n    let client = Client::configure().set_local_address(bind_addr).build(&handle);\r\n```\r\nBelow I propose:\r\n* A configuration syntax.\r\n* A way of implementing this architecturally, which involves changes to mio and tokio-core.\r\n\r\nWould you be happy to receive a PR along these lines, and do you think the approach of enhancing mio and tokio-core is best, or should we simply change hyper?\r\n\r\nDetails follow.\r\n\r\nUncontroversially we need the following plumbing:\r\n* in `client/mod.rs` we add `local_address: Option<IpAddr>` to `Config`, default it to `None`, add `set_local_address`, and make `build` set it on `HttpConnector` if present.\r\n* Similarly, we add `local_address: Option<IpAddr>` to the fields of `HttpConnector` and provide a setter.\r\n* To convey the local address to the point where the connection is done, the `Lazy` and `Resolving` states of `HttpConnecting` gain an extra tuple field `Option<IpAddr>`, and `ConnectingTcp` gains a `local_address` field. The same will also be required in the hyper-tls connector.\r\n\r\nThe interesting part is what we replace `self.current = tokio::net::TcpStream::connect(&addr, handle);` with in `ConnectingTcp`.\r\n\r\nDoing it all purely in Hyper looks like this (replacing a few lines of `impl ConnectingTcp` around https://github.com/hyperium/hyper/blob/master/src/client/connect.rs#L426):\r\n```rust\r\n              if let Some(addr) = self.addrs.next() {\r\n                debug!(\"connecting to {}\", addr);\r\n                let do_bind = |local: &Option<IpAddr>| {\r\n                    let sock = match addr {\r\n                        SocketAddr::V4(..) => TcpBuilder::new_v4(),\r\n                        SocketAddr::V6(..) => TcpBuilder::new_v6(),\r\n                    }?;\r\n                    match local {\r\n                        &None => (), // oops, should add special Windows knowledge here\r\n                        &Some(ref local_addr) => sock.bind(SocketAddr::new(local_addr.clone(), 0)).map(|_| ())?,\r\n                    };\r\n                    sock.to_tcp_stream()\r\n                };\r\n\r\n                match do_bind(&self.local_address) {\r\n                    Ok(tcp) => {\r\n                        self.current = Some(mio::net::TcpStream::connect_stream(tcp, &addr, handle));\r\n                        continue;\r\n                    },\r\n                    Err(e) => {\r\n                        err = Some(e)\r\n                    }\r\n                };\r\n            }\r\n```\r\n\r\nThis direct approach is unpleasant because it violates the architectural layering and duplicates code. In particular, this code is taken almost verbatim from `mio::net::TcpStream::connect()` – and as you can see there, it should really include a [special Windows workaround](https://github.com/carllerche/mio/blob/master/src/net/tcp.rs#L97) here.\r\n\r\nIt also loses the zero-allocation property: Tokio’s `TcpStream::connect_stream` can only return a `Box<Future>`, so we have to change ConnectingTcp to use this boxed future rather than the bare Tokio `TcpStreamNew` (which we cannot construct outside Tokio).\r\n\r\nHow could we preserve the architectural layering?\r\n\r\nIn `mio::net::TcpStream` we should add a `connect_with_local_address` method beside `connect`, to encapsulate the Windows and socket knowledge. We should then expose that in a new `tokio::net::TcpStream::connect_with_local_address` method. Then this method is available to be used Hyper’s `ConnectingTcp`:\r\n```rust\r\n              if let Some(addr) = self.addrs.next() {\r\n                debug!(\"connecting to {}\", addr);\r\n                self.current = tokio::net::TcpStream::connect_with_local_address(&addr, &local, handle);\r\n```\r\n\r\nI think this a cleaner approach architecturally, and it is also able to preserve zero-allocation. But it does involve making changes to three projects. Which is the best approach?\r\n\r\n","closed_by":{"login":"seanmonstar","id":51479,"node_id":"MDQ6VXNlcjUxNDc5","avatar_url":"https://avatars.githubusercontent.com/u/51479?v=4","gravatar_id":"","url":"https://api.github.com/users/seanmonstar","html_url":"https://github.com/seanmonstar","followers_url":"https://api.github.com/users/seanmonstar/followers","following_url":"https://api.github.com/users/seanmonstar/following{/other_user}","gists_url":"https://api.github.com/users/seanmonstar/gists{/gist_id}","starred_url":"https://api.github.com/users/seanmonstar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seanmonstar/subscriptions","organizations_url":"https://api.github.com/users/seanmonstar/orgs","repos_url":"https://api.github.com/users/seanmonstar/repos","events_url":"https://api.github.com/users/seanmonstar/events{/privacy}","received_events_url":"https://api.github.com/users/seanmonstar/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hyperium/hyper/issues/1498/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hyperium/hyper/issues/1498/timeline","performed_via_github_app":null,"state_reason":"completed"}