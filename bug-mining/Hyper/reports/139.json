{"url":"https://api.github.com/repos/hyperium/hyper/issues/1397","repository_url":"https://api.github.com/repos/hyperium/hyper","labels_url":"https://api.github.com/repos/hyperium/hyper/issues/1397/labels{/name}","comments_url":"https://api.github.com/repos/hyperium/hyper/issues/1397/comments","events_url":"https://api.github.com/repos/hyperium/hyper/issues/1397/events","html_url":"https://github.com/hyperium/hyper/issues/1397","id":281085830,"node_id":"MDU6SXNzdWUyODEwODU4MzA=","number":1397,"title":"Client connections leaked with long-poll GETs","user":{"login":"mthebridge","id":13729669,"node_id":"MDQ6VXNlcjEzNzI5NjY5","avatar_url":"https://avatars.githubusercontent.com/u/13729669?v=4","gravatar_id":"","url":"https://api.github.com/users/mthebridge","html_url":"https://github.com/mthebridge","followers_url":"https://api.github.com/users/mthebridge/followers","following_url":"https://api.github.com/users/mthebridge/following{/other_user}","gists_url":"https://api.github.com/users/mthebridge/gists{/gist_id}","starred_url":"https://api.github.com/users/mthebridge/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mthebridge/subscriptions","organizations_url":"https://api.github.com/users/mthebridge/orgs","repos_url":"https://api.github.com/users/mthebridge/repos","events_url":"https://api.github.com/users/mthebridge/events{/privacy}","received_events_url":"https://api.github.com/users/mthebridge/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":125710197,"node_id":"MDU6TGFiZWwxMjU3MTAxOTc=","url":"https://api.github.com/repos/hyperium/hyper/labels/C-bug","name":"C-bug","color":"d93f0b","default":false,"description":"Category: bug. Something is wrong. This is bad!"},{"id":128399841,"node_id":"MDU6TGFiZWwxMjgzOTk4NDE=","url":"https://api.github.com/repos/hyperium/hyper/labels/A-client","name":"A-client","color":"fbca04","default":false,"description":"Area: client."}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":11,"created_at":"2017-12-11T16:44:37Z","updated_at":"2017-12-15T10:16:16Z","closed_at":"2017-12-14T21:58:18Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"I'm not sure if this is a hyper, tokio_timer or general futures issue, it seems similar to #1353  - but that suggests this is fixed by using `no_proto` on the Client, and I see the same problem whether or not I use `no_proto` .\r\n\r\nOriginally raised as https://github.com/jimmycuadra/rust-etcd/issues/20, but managed to isolate it to hyper.\r\n\r\nThe trigger seems to be using `tokio_timer::Timeout` on a `Client.get()` that has returned the headers with Chunked-Encoding but no chunks received yet.\r\n\r\nNothing obvious in trace-level logs.\r\n\r\nRepro instructions (on Linux - not tried on any other platforms), mostly cribbed from the rust-etcd repo:\r\n\r\n  * Start an etcd instance running locally (assuming you have docker, `docker run --net=host -d quay.io/coreos/etcd:v2.2.0` works) \r\n  * Run this simple etcd client code (below) that loops watching for changes to a key.\r\n  * Observe leaking TCP connections - I view through `sudo netstat - plant | grep 2379` (and eventually you'll run out of ports).  \r\n\r\n```rust\r\nextern crate hyper;\r\nextern crate tokio_core;\r\n#[macro_use]\r\nextern crate log;\r\nextern crate env_logger;\r\nextern crate futures;\r\nextern crate tokio_timer;\r\n\r\nuse std::time::Duration;\r\nuse futures::future::Future;\r\nuse futures::Stream;\r\nuse tokio_core::reactor;\r\nuse tokio_timer::{Timer, TimeoutError};\r\nuse hyper::{Client, Uri};\r\nuse std::error::Error;\r\n\r\n// Dummy error type to handle this\r\n#[derive(Debug)]\r\nenum MyError {\r\n    Timeout,\r\n    Other(String),\r\n}\r\n\r\nimpl std::fmt::Display for MyError {\r\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\r\n        write!(f, \"{}\", self.description())\r\n    }\r\n}\r\n\r\nimpl Error for MyError {\r\n    fn description(&self) -> &str {\r\n        match *self {\r\n            MyError::Timeout => \"Timeout\",\r\n            MyError::Other(ref s) => s,\r\n        }\r\n    }\r\n}\r\n\r\nimpl<T> From<TimeoutError<T>> for MyError {\r\n    fn from(_error: TimeoutError<T>) -> MyError {\r\n        MyError::Timeout\r\n    }\r\n}\r\n\r\nimpl From<hyper::Error> for MyError {\r\n    fn from(error: hyper::Error) -> MyError {\r\n        MyError::Other(error.description().to_string())\r\n    }\r\n}\r\n\r\nfn main() {\r\n    env_logger::init().unwrap();\r\n\r\n    let mut core = reactor::Core::new().unwrap();\r\n\r\n    let client = Client::new(&core.handle());\r\n\r\n    let mut idx = 0;\r\n    loop {\r\n        let url_str = format!(\r\n            \"http://localhost:2379/v2/keys/foo?waitIndex={}&wait=true&recursive=true\",\r\n            idx\r\n        );\r\n        let url = url_str.parse::<Uri>().unwrap();\r\n        debug!(\"Kicking off watch for index: {}\", idx);\r\n        let timer = Timer::default();\r\n        let cur_idx = idx;\r\n        let work: Box<Future<Item = (), Error = MyError>> = Box::new(\r\n            timer.timeout(\r\n                client\r\n                    .get(url)\r\n                    .map_err(|e| MyError::Other(e.description().to_string()))\r\n                    .and_then(|response| {\r\n                        let status = response.status();\r\n                        response\r\n                            .body()\r\n                            .concat2()\r\n                            .map_err(|e| MyError::Other(format!(\"Body parse error: {}\", e)))\r\n                            .and_then(move |ref _body| if status == hyper::StatusCode::Ok {\r\n                                idx += 1;\r\n                                Ok(())\r\n                            } else {\r\n                                Err(MyError::Other(\"Bad response from etcd\".to_string()))\r\n                            })\r\n                    })\r\n                    .map(|_| {\r\n                        debug!(\"Completed watch for index {}\", cur_idx);\r\n                    }),\r\n                Duration::from_secs(3),\r\n            ),\r\n        );\r\n        let res = core.run(work);\r\n\r\n        match res {\r\n            Ok(_) => debug!(\"Spotted change from etcd\"),\r\n            Err(MyError::Timeout) => info!(\"Timeout\"),\r\n            Err(MyError::Other(e)) => error!(\" error from etcd: {}\", e),\r\n        }\r\n    }\r\n}\r\n```","closed_by":{"login":"seanmonstar","id":51479,"node_id":"MDQ6VXNlcjUxNDc5","avatar_url":"https://avatars.githubusercontent.com/u/51479?v=4","gravatar_id":"","url":"https://api.github.com/users/seanmonstar","html_url":"https://github.com/seanmonstar","followers_url":"https://api.github.com/users/seanmonstar/followers","following_url":"https://api.github.com/users/seanmonstar/following{/other_user}","gists_url":"https://api.github.com/users/seanmonstar/gists{/gist_id}","starred_url":"https://api.github.com/users/seanmonstar/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/seanmonstar/subscriptions","organizations_url":"https://api.github.com/users/seanmonstar/orgs","repos_url":"https://api.github.com/users/seanmonstar/repos","events_url":"https://api.github.com/users/seanmonstar/events{/privacy}","received_events_url":"https://api.github.com/users/seanmonstar/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/hyperium/hyper/issues/1397/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/hyperium/hyper/issues/1397/timeline","performed_via_github_app":null,"state_reason":"completed"}