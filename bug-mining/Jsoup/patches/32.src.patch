diff --git a/CHANGES b/CHANGES
index 608258d4..0a3fac39 100644
--- a/CHANGES
+++ b/CHANGES
@@ -6,6 +6,9 @@ jsoup changelog
 
  * Implemented Node.clone() to create deep, independent copies of Nodes, Elements, and Documents.
 
+ * Added :not() selector, to find elements that do not match the selector. E.g. div:not(.logo) finds divs that
+   do not have the "logo" class name.
+
  * Relaxed parse rules of H1 - H6, to allow nested content. This is against spec, but matches browser and publisher
    behaviour.
 
diff --git a/src/main/java/org/jsoup/select/Selector.java b/src/main/java/org/jsoup/select/Selector.java
index 55d01e5a..e370de8e 100644
--- a/src/main/java/org/jsoup/select/Selector.java
+++ b/src/main/java/org/jsoup/select/Selector.java
@@ -45,6 +45,7 @@ import java.util.LinkedHashSet;
   <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>
   <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>
   <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>
+  <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em></td><code>div:not(.logo)</code> finds all divs that do not have the "logo" class</td></tr>
   <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text "jsoup".</td></tr>
   <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>
   <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contains the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text "jsoup".</td></tr>
@@ -106,6 +107,8 @@ public class Selector {
         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
             elements.add(root);
             combinator(tq.consume().toString());
+        } else if (tq.matches(":has(")) {
+            elements.addAll(root.getAllElements());
         } else {
             addElements(findElements()); // chomp first element matcher off queue 
         }            
@@ -177,6 +180,8 @@ public class Selector {
             return matches(false);
         } else if (tq.matches(":matchesOwn(")) {
             return matches(true);
+        } else if (tq.matches(":not(")) {
+            return not();
         } else { // unhandled
             throw new SelectorParseException("Could not parse query '%s': unexpected token at '%s'", query, tq.remainder());
         }
@@ -300,6 +305,15 @@ public class Selector {
         return own ? root.getElementsMatchingOwnText(regex) : root.getElementsMatchingText(regex);
     }
 
+    // :not(selector)
+    private Elements not() {
+        tq.consume(":not");
+        String subQuery = tq.chompBalanced('(', ')');
+        Validate.notEmpty(subQuery, ":not(selector) subselect must not be empty");
+
+        return filterOut(root.getAllElements(), select(subQuery, root));
+    }
+
     // direct child descendants
     private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {
         Elements children = new Elements();
@@ -391,6 +405,23 @@ public class Selector {
         return children;
     }
 
+    // exclude set. package open so that Elements can implement .not() selector.
+    static Elements filterOut(Collection<Element> elements, Collection<Element> outs) {
+        Elements output = new Elements();
+        for (Element el: elements) {
+            boolean found = false;
+            for (Element out: outs) {
+                if (el.equals(out)) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+                output.add(el);
+        }
+        return output;
+    }
+
     public static class SelectorParseException extends IllegalStateException {
         public SelectorParseException(String msg, Object... params) {
             super(String.format(msg, params));
diff --git a/src/test/java/org/jsoup/select/SelectorTest.java b/src/test/java/org/jsoup/select/SelectorTest.java
index b8551861..1567f1fa 100644
--- a/src/test/java/org/jsoup/select/SelectorTest.java
+++ b/src/test/java/org/jsoup/select/SelectorTest.java
@@ -419,6 +419,12 @@ public class SelectorTest {
         assertEquals("0", divs3.get(0).id());
         assertEquals("1", divs3.get(1).id());
         assertEquals("2", divs3.get(2).id());
+
+        Elements els1 = doc.body().select(":has(p)");
+        assertEquals(3, els1.size()); // body, div, dib
+        assertEquals("body", els1.first().tagName());
+        assertEquals("0", els1.get(1).id());
+        assertEquals("2", els1.get(2).id());
     }
 
     @Test public void testNestedHas() {
@@ -532,4 +538,35 @@ public class SelectorTest {
         assertEquals(1, el2.size());
         assertEquals("2", el2.first().id());
     }
+
+    @Test public void notParas() {
+        Document doc = Jsoup.parse("<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>");
+
+        Elements el1 = doc.select("p:not([id=1])");
+        assertEquals(2, el1.size());
+        assertEquals("Two", el1.first().text());
+        assertEquals("Three", el1.last().text());
+
+        Elements el2 = doc.select("p:not(:has(span))");
+        assertEquals(2, el2.size());
+        assertEquals("One", el2.first().text());
+        assertEquals("Two", el2.last().text());
+    }
+
+    @Test public void notAll() {
+        Document doc = Jsoup.parse("<p>Two</p> <p><span>Three</span></p>");
+
+        Elements el1 = doc.body().select(":not(p)"); // should just be the span
+        assertEquals(2, el1.size());
+        assertEquals("body", el1.first().tagName());
+        assertEquals("span", el1.last().tagName());
+    }
+
+    @Test public void notClass() {
+        Document doc = Jsoup.parse("<div class=left>One</div><div class=right id=1><p>Two</p></div>");
+
+        Elements el1 = doc.select("div:not(.left)");
+        assertEquals(1, el1.size());
+        assertEquals("1", el1.first().id());
+    }
 }
