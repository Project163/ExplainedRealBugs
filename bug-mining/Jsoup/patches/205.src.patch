diff --git a/CHANGES b/CHANGES
index 1997b26b..3d3f1e8c 100644
--- a/CHANGES
+++ b/CHANGES
@@ -17,6 +17,9 @@ jsoup changelog
 
   * Build Improvement: updated Jetty (used for integration tests; not bundled) to 9.4.35.v2020112.
 
+  * Bugfix: when parsing HTML, could throw NPEs on some tags (isindex or table>input).
+    <https://github.com/jhy/jsoup/issues/1404>
+
 *** Release 1.13.1 [2020-Feb-29]
   * Improvement: added Element#closest(selector), which walks up the tree to find the nearest element matching the
     selector.
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index b879de3e..39520ed5 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -196,7 +196,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
 
     Element insert(final Token.StartTag startTag) {
         // cleanup duplicate attributes:
-        if (startTag.attributes != null && !startTag.attributes.isEmpty()) {
+        if (startTag.hasAttributes() && !startTag.attributes.isEmpty()) {
             int dupes = startTag.attributes.deduplicate(settings);
             if (dupes > 0) {
                 error("Duplicate attribute");
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index 21c8f64c..0d660d19 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -339,9 +339,11 @@ enum HtmlTreeBuilderState {
                     tb.error(this);
                     // merge attributes onto real html
                     Element html = tb.getStack().get(0);
-                    for (Attribute attribute : startTag.getAttributes()) {
-                        if (!html.hasAttr(attribute.getKey()))
-                            html.attributes().put(attribute);
+                    if (startTag.hasAttributes()) {
+                        for (Attribute attribute : startTag.attributes) {
+                            if (!html.hasAttr(attribute.getKey()))
+                                html.attributes().put(attribute);
+                        }
                     }
                     break;
                 case "body":
@@ -353,9 +355,11 @@ enum HtmlTreeBuilderState {
                     } else {
                         tb.framesetOk(false);
                         Element body = stack.get(1);
-                        for (Attribute attribute : startTag.getAttributes()) {
-                            if (!body.hasAttr(attribute.getKey()))
-                                body.attributes().put(attribute);
+                        if (startTag.hasAttributes()) {
+                            for (Attribute attribute : startTag.attributes) {
+                                if (!body.hasAttr(attribute.getKey()))
+                                    body.attributes().put(attribute);
+                            }
                         }
                     }
                     break;
@@ -451,14 +455,14 @@ enum HtmlTreeBuilderState {
                         return false;
 
                     tb.processStartTag("form");
-                    if (startTag.attributes.hasKey("action")) {
+                    if (startTag.hasAttribute("action")) {
                         Element form = tb.getFormElement();
                         form.attr("action", startTag.attributes.get("action"));
                     }
                     tb.processStartTag("hr");
                     tb.processStartTag("label");
                     // hope you like english.
-                    String prompt = startTag.attributes.hasKey("prompt") ?
+                    String prompt = startTag.hasAttribute("prompt") ?
                         startTag.attributes.get("prompt") :
                         "This is a searchable index. Enter search keywords: ";
 
@@ -466,9 +470,11 @@ enum HtmlTreeBuilderState {
 
                     // input
                     Attributes inputAttribs = new Attributes();
-                    for (Attribute attr : startTag.attributes) {
-                        if (!inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))
-                            inputAttribs.put(attr);
+                    if (startTag.hasAttributes()) {
+                        for (Attribute attr : startTag.attributes) {
+                            if (!inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))
+                                inputAttribs.put(attr);
+                        }
                     }
                     inputAttribs.put("name", "isindex");
                     tb.processStartTag("input", inputAttribs);
@@ -931,7 +937,7 @@ enum HtmlTreeBuilderState {
                 } else if (inSorted(name, InTableToHead)) {
                     return tb.process(t, InHead);
                 } else if (name.equals("input")) {
-                    if (!startTag.attributes.get("type").equalsIgnoreCase("hidden")) {
+                    if (!(startTag.hasAttributes() && startTag.attributes.get("type").equalsIgnoreCase("hidden"))) {
                         return anythingElse(t, tb);
                     } else {
                         tb.insertEmpty(startTag);
diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java
index f9061377..56f72b58 100644
--- a/src/main/java/org/jsoup/parser/Token.java
+++ b/src/main/java/org/jsoup/parser/Token.java
@@ -123,6 +123,14 @@ abstract class Token {
             pendingAttributeValueS = null;
         }
 
+        final boolean hasAttributes() {
+            return attributes != null;
+        }
+
+        final boolean hasAttribute(String key) {
+            return attributes != null && attributes.hasKey(key);
+        }
+
         final void finaliseTag() {
             // finalises for emit
             if (pendingAttributeName != null) {
@@ -151,12 +159,6 @@ abstract class Token {
             return selfClosing;
         }
 
-        final Attributes getAttributes() {
-            if (attributes == null)
-                attributes = new Attributes();
-            return attributes;
-        }
-
         // these appenders are rarely hit in not null state-- caused by null chars.
         final void appendTagName(String append) {
             tagName = tagName == null ? append : tagName.concat(append);
@@ -237,7 +239,7 @@ abstract class Token {
 
         @Override
         public String toString() {
-            if (attributes != null && attributes.size() > 0)
+            if (hasAttributes() && attributes.size() > 0)
                 return "<" + name() + " " + attributes.toString() + ">";
             else
                 return "<" + name() + ">";
diff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java
index 6d2e8445..db053ea8 100644
--- a/src/main/java/org/jsoup/parser/Tokeniser.java
+++ b/src/main/java/org/jsoup/parser/Tokeniser.java
@@ -85,7 +85,7 @@ final class Tokeniser {
             lastStartTag = startTag.tagName;
         } else if (token.type == Token.TokenType.EndTag) {
             Token.EndTag endTag = (Token.EndTag) token;
-            if (endTag.attributes != null)
+            if (endTag.hasAttributes())
                 error("Attributes incorrectly present on end tag");
         }
     }
diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
index 36172511..d68156dc 100644
--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java
@@ -75,7 +75,7 @@ public class XmlTreeBuilder extends TreeBuilder {
     Element insert(Token.StartTag startTag) {
         Tag tag = Tag.valueOf(startTag.name(), settings);
         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
-        if (startTag.attributes != null)
+        if (startTag.hasAttributes())
             startTag.attributes.deduplicate(settings);
 
         Element el = new Element(tag, null, settings.normalizeAttributes(startTag.attributes));
diff --git a/src/test/java/org/jsoup/parser/HtmlParserTest.java b/src/test/java/org/jsoup/parser/HtmlParserTest.java
index 000ff978..8eb27cb3 100644
--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java
@@ -434,6 +434,22 @@ public class HtmlParserTest {
         assertEquals("http://example.com/foo", doc.select("a").first().absUrl("href"));
     }
 
+    @Test public void parseBodyIsIndexNoAttributes() {
+        // https://github.com/jhy/jsoup/issues/1404
+        String expectedHtml = "<form>\n" +
+            " <hr><label>This is a searchable index. Enter search keywords: <input name=\"isindex\"></label>\n" +
+            " <hr>\n" +
+            "</form>";
+        Document doc = Jsoup.parse("<isindex>");
+        assertEquals(expectedHtml, doc.body().html());
+
+        doc = Jsoup.parseBodyFragment("<isindex>");
+        assertEquals(expectedHtml, doc.body().html());
+
+        doc = Jsoup.parseBodyFragment("<table><input></table>");
+        assertEquals("<input>\n<table></table>", doc.body().html());
+    }
+
     @Test public void handlesUnknownNamespaceTags() {
         // note that the first foo:bar should not really be allowed to be self closing, if parsed in html mode.
         String h = "<foo:bar id='1' /><abc:def id=2>Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>";
