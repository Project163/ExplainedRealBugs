diff --git a/CHANGES b/CHANGES
index 3d90c87d..efff2370 100644
--- a/CHANGES
+++ b/CHANGES
@@ -4,6 +4,9 @@ jsoup changelog
   * Improvement: added a new pseudo selector :matchText, which allows text nodes to match as if they were elements.
     This enables finding text that is only marked by a "br" tag, for example.
     <https://github.com/jhy/jsoup/issues/550>
+
+  * Improvement: normalize invisible characters (like soft-hyphens) in Element.text().
+    <https://github.com/jhy/jsoup/issues/978>
     
   * Bugfix: in a deep DOM stack, a StackOverFlow exception could occur when generating implied end tags.
     <https://github.com/jhy/jsoup/issues/966>
diff --git a/src/main/java/org/jsoup/helper/StringUtil.java b/src/main/java/org/jsoup/helper/StringUtil.java
index c9bf750b..9d2e7443 100644
--- a/src/main/java/org/jsoup/helper/StringUtil.java
+++ b/src/main/java/org/jsoup/helper/StringUtil.java
@@ -128,6 +128,11 @@ public final class StringUtil {
         // 160 is &nbsp; (non-breaking space). Not in the spec but expected.
     }
 
+    public static boolean isInvisibleChar(int c) {
+        return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
+        // zero width sp, zw non join, zw join, soft hyphen
+    }
+
     /**
      * Normalise the whitespace within this string; multiple spaces collapse to a single, and all whitespace characters
      * (e.g. newline, tab) convert to a simple space
@@ -160,7 +165,7 @@ public final class StringUtil {
                 accum.append(' ');
                 lastWasWhite = true;
             }
-            else {
+            else if (!isInvisibleChar(c)) {
                 accum.appendCodePoint(c);
                 lastWasWhite = false;
                 reachedNonWhite = true;
diff --git a/src/test/java/org/jsoup/nodes/ElementTest.java b/src/test/java/org/jsoup/nodes/ElementTest.java
index 546f3098..5225bff1 100644
--- a/src/test/java/org/jsoup/nodes/ElementTest.java
+++ b/src/test/java/org/jsoup/nodes/ElementTest.java
@@ -1199,6 +1199,24 @@ public class ElementTest {
         Element matched = doc.select("p:contains(get what you want)").first();
         assertEquals("p", matched.nodeName());
         assertTrue(matched.is(":containsOwn(get what you want)"));
+    }
+
+    @Test public void testNormalizesInvisiblesInText() {
+        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);
+        String escaped = "This&shy;is&#x200b;one&#x200c;long&#x200d;word";
+        String decoded = "This\u00ADis\u200Bone\u200Clong\u200Dword"; // browser would not display those soft hyphens / other chars, so we don't want them in the text
+
+        Document doc = Jsoup.parse("<p>" + escaped);
+        Element p = doc.select("p").first();
+        doc.outputSettings().charset("ascii"); // so that the outer html is easier to see with escaped invisibles
+        assertEquals("Thisisonelongword", p.text()); // text is normalized
+        assertEquals("<p>" + escaped + "</p>", p.outerHtml()); // html / whole text keeps &shy etc;
+        assertEquals(decoded, p.textNodes().get(0).getWholeText());
+
+        Element matched = doc.select("p:contains(Thisisonelongword)").first(); // really just oneloneword, no invisibles
+        assertEquals("p", matched.nodeName());
+        assertTrue(matched.is(":containsOwn(Thisisonelongword)"));
+
     }
 	
 	@Test
