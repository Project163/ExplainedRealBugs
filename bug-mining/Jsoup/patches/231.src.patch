diff --git a/CHANGES b/CHANGES
index 2cd90933..f52f5b78 100644
--- a/CHANGES
+++ b/CHANGES
@@ -34,6 +34,9 @@ jsoup changelog
   * Improvement: much better performance in Node#clone() for large and deeply nested documents. Complexity was O(n^2) or
     worse, now O(n).
 
+  * Improvement: during traversal using the NodeTraversor, nodes may now be replaced with Node#replaceWith(Node).
+    <https://github.com/jhy/jsoup/issues/1289>
+
   * Build Improvement: moved to GitHub Workflows for build verification.
 
   * Build Improvement: updated Jetty (used for integration tests; not bundled) to 9.4.35.v2020112.
diff --git a/src/main/java/org/jsoup/select/NodeTraversor.java b/src/main/java/org/jsoup/select/NodeTraversor.java
index 99488277..74b66b4e 100644
--- a/src/main/java/org/jsoup/select/NodeTraversor.java
+++ b/src/main/java/org/jsoup/select/NodeTraversor.java
@@ -19,18 +19,23 @@ public class NodeTraversor {
      */
     public static void traverse(NodeVisitor visitor, Node root) {
         Node node = root;
+        Node parent; // remember parent to find nodes that get replaced in .head
         int depth = 0;
         
         while (node != null) {
-            visitor.head(node, depth);
-            if (node.childNodeSize() > 0) {
+            parent = node.parentNode();
+            visitor.head(node, depth); // visit current node
+            if (parent != null && !node.hasParent()) // must have been replaced; find replacement
+                node = parent.childNode(node.siblingIndex()); // replace ditches parent but keeps sibling index
+
+            if (node.childNodeSize() > 0) { // descend
                 node = node.childNode(0);
                 depth++;
             } else {
                 while (true) {
                     assert node != null; // as depth > 0, will have parent
                     if (!(node.nextSibling() == null && depth > 0)) break;
-                    visitor.tail(node, depth);
+                    visitor.tail(node, depth); // when no more siblings, ascend
                     node = node.parentNode();
                     depth--;
                 }
diff --git a/src/main/java/org/jsoup/select/NodeVisitor.java b/src/main/java/org/jsoup/select/NodeVisitor.java
index 08092979..5f0011ad 100644
--- a/src/main/java/org/jsoup/select/NodeVisitor.java
+++ b/src/main/java/org/jsoup/select/NodeVisitor.java
@@ -1,31 +1,37 @@
 package org.jsoup.select;
 
+import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Node;
 
 /**
  * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.
  * <p>
  * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first
- * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to
- * create a start tag for a node, and tail to create the end tag.
+ * seen, and the tail method when all of the node's children have been visited. As an example, {@code head} can be used to
+ * emit a start tag for a node, and {@code tail} to create the end tag.
  * </p>
  */
 public interface NodeVisitor {
     /**
-     * Callback for when a node is first visited.
-     *
-     * @param node the node being visited.
-     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
-     * of that will have depth 1.
+     Callback for when a node is first visited.
+     <p>The node may be modified (e.g. {@link Node#attr(String)} or replaced {@link Node#replaceWith(Node)}). If it's
+     {@code instanceOf Element}, you may cast it to an {@link Element} and access those methods.</p>
+     <p>Note that nodes may not be removed during traversal using this method; use {@link
+    NodeTraversor#filter(NodeFilter, Node)} with a {@link NodeFilter.FilterResult#REMOVE} return instead.</p>
+
+     @param node the node being visited.
+     @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
+     of that will have depth 1.
      */
     void head(Node node, int depth);
 
     /**
-     * Callback for when a node is last visited, after all of its descendants have been visited.
-     *
-     * @param node the node being visited.
-     * @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
-     * of that will have depth 1.
+     Callback for when a node is last visited, after all of its descendants have been visited.
+     <p>Note that replacement with {@link Node#replaceWith(Node)}</p> is not supported in {@code tail}.
+
+     @param node the node being visited.
+     @param depth the depth of the node, relative to the root node. E.g., the root node has depth 0, and a child node
+     of that will have depth 1.
      */
     void tail(Node node, int depth);
 }
diff --git a/src/test/java/org/jsoup/select/TraversorTest.java b/src/test/java/org/jsoup/select/TraversorTest.java
index 00f70d32..c5d8a2f2 100644
--- a/src/test/java/org/jsoup/select/TraversorTest.java
+++ b/src/test/java/org/jsoup/select/TraversorTest.java
@@ -2,10 +2,12 @@ package org.jsoup.select;
 
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Node;
 import org.junit.jupiter.api.Test;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
 
 public class TraversorTest {
     // Note: NodeTraversor.traverse(new NodeVisitor) is tested in
@@ -114,4 +116,59 @@ public class TraversorTest {
         }, doc.select("div"));
         assertEquals("<div><p><#text></#text></p>", accum.toString());
     }
+
+    @Test public void replaceElement() {
+        // https://github.com/jhy/jsoup/issues/1289
+        // test we can replace an element during traversal
+        String html = "<div><p>One <i>two</i> <i>three</i> four.</p></div>";
+        Document doc = Jsoup.parse(html);
+
+        NodeTraversor.traverse(new NodeVisitor() {
+            @Override
+            public void head(Node node, int depth) {
+                if (node instanceof Element) {
+                    Element el = (Element) node;
+                    if (el.normalName().equals("i")) {
+                        Element u = new Element("u").insertChildren(0, el.childNodes());
+                        el.replaceWith(u);
+                    }
+                }
+            }
+
+            @Override
+            public void tail(Node node, int depth) {}
+        }, doc);
+
+        Element p = doc.selectFirst("p");
+        assertNotNull(p);
+        assertEquals("<p>One <u>two</u> <u>three</u> four.</p>", p.outerHtml());
+    }
+
+    @Test public void canAddChildren() {
+        Document doc = Jsoup.parse("<div><p></p><p></p></div>");
+
+        NodeTraversor.traverse(new NodeVisitor() {
+            int i = 0;
+            @Override
+            public void head(Node node, int depth) {
+                if (node.nodeName().equals("p")) {
+                    Element p = (Element) node;
+                    p.append("<span>" + i++ + "</span>");
+                }
+            }
+
+            @Override
+            public void tail(Node node, int depth) {
+                if (node.nodeName().equals("p")) {
+                    Element p = (Element) node;
+                    p.append("<span>" + i++ + "</span>");
+                }
+            }
+        }, doc);
+
+        assertEquals("<div>\n" +
+            " <p><span>0</span><span>1</span></p>\n" +
+            " <p><span>2</span><span>3</span></p>\n" +
+            "</div>", doc.body().html());
+    }
 }
