diff --git a/CHANGES b/CHANGES
index eca6e059..282088f4 100644
--- a/CHANGES
+++ b/CHANGES
@@ -33,6 +33,9 @@ jsoup changelog
  * Removed an unnecessary synchronisation in Tag.valueOf, allowing multi-threaded parsing to run faster.
    <https://github.com/jhy/jsoup/issues/238>
 
+ * Made entity decoding less greedy, so that non-entities are less likely to be incorrectly treated as entities.
+   <https://github.com/jhy/jsoup/issues/224>
+
 *** Release 1.6.3 [2012-May-28]
  * Fixed parsing of group-or commas in CSS selectors, to correctly handle sub-queries containing commas.
    <https://github.com/jhy/jsoup/issues/179>
diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java
index 0ae83e1f..a60fab89 100644
--- a/src/main/java/org/jsoup/nodes/Entities.java
+++ b/src/main/java/org/jsoup/nodes/Entities.java
@@ -1,5 +1,7 @@
 package org.jsoup.nodes;
 
+import org.jsoup.parser.Parser;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.CharsetEncoder;
@@ -34,6 +36,7 @@ public class Entities {
 
     private static final Map<String, Character> full;
     private static final Map<Character, String> xhtmlByVal;
+    private static final Map<String, Character> base;
     private static final Map<Character, String> baseByVal;
     private static final Map<Character, String> fullByVal;
     private static final Pattern unescapePattern = Pattern.compile("&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\d*);?");
@@ -43,13 +46,23 @@ public class Entities {
 
     /**
      * Check if the input is a known named entity
-     * @param name the possible entity name (e.g. "lt" or "amp"
+     * @param name the possible entity name (e.g. "lt" or "amp")
      * @return true if a known named entity
      */
     public static boolean isNamedEntity(String name) {
         return full.containsKey(name);
     }
 
+    /**
+     * Check if the input is a known named entity in the base entity set.
+     * @param name the possible entity name (e.g. "lt" or "amp")
+     * @return true if a known named entity in the base set
+     * @see #isNamedEntity(String)
+     */
+    public static boolean isBaseNamedEntity(String name) {
+        return base.containsKey(name);
+    }
+
     /**
      * Get the Character value of the named entity
      * @param name named entity (e.g. "lt" or "amp")
@@ -91,38 +104,7 @@ public class Entities {
      * @return
      */
     static String unescape(String string, boolean strict) {
-        // todo: change this method to use Tokeniser.consumeCharacterReference
-        if (!string.contains("&"))
-            return string;
-
-        Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]\\d*);?
-        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs
-        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required
-
-        while (m.find()) {
-            int charval = -1;
-            String num = m.group(3);
-            if (num != null) {
-                try {
-                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
-                    charval = Integer.valueOf(num, base);
-                } catch (NumberFormatException e) {
-                } // skip
-            } else {
-                String name = m.group(1);
-                if (full.containsKey(name))
-                    charval = full.get(name);
-            }
-
-            if (charval != -1 || charval > 0xFFFF) { // out of range
-                String c = Character.toString((char) charval);
-                m.appendReplacement(accum, Matcher.quoteReplacement(c));
-            } else {
-                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string
-            }
-        }
-        m.appendTail(accum);
-        return accum.toString();
+        return Parser.unescapeEntities(string, strict);
     }
 
     // xhtml has restricted entities
@@ -136,7 +118,8 @@ public class Entities {
 
     static {
         xhtmlByVal = new HashMap<Character, String>();
-        baseByVal = toCharacterKey(loadEntities("entities-base.properties")); // most common / default
+        base = loadEntities("entities-base.properties");  // most common / default
+        baseByVal = toCharacterKey(base);
         full = loadEntities("entities-full.properties"); // extended and overblown.
         fullByVal = toCharacterKey(full);
 
diff --git a/src/main/java/org/jsoup/parser/Parser.java b/src/main/java/org/jsoup/parser/Parser.java
index 2236219c..eebce38d 100644
--- a/src/main/java/org/jsoup/parser/Parser.java
+++ b/src/main/java/org/jsoup/parser/Parser.java
@@ -124,6 +124,17 @@ public class Parser {
         return doc;
     }
 
+    /**
+     * Utility method to unescape HTML entities from a string
+     * @param string HTML escaped string
+     * @param inAttribute if the string is to be escaped in strict mode (as attributes are)
+     * @return an unescaped string
+     */
+    public static String unescapeEntities(String string, boolean inAttribute) {
+        Tokeniser tokeniser = new Tokeniser(new CharacterReader(string), ParseErrorList.noTracking());
+        return tokeniser.unescapeEntities(inAttribute);
+    }
+
     /**
      * @param bodyHtml HTML to parse
      * @param baseUri baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.
diff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java
index 29425d76..34458558 100644
--- a/src/main/java/org/jsoup/parser/Tokeniser.java
+++ b/src/main/java/org/jsoup/parser/Tokeniser.java
@@ -131,23 +131,16 @@ class Tokeniser {
                 return (char) charval;
             }
         } else { // named
-            // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
+            // get as many letters as possible, and look for matching entities.
             String nameRef = reader.consumeLetterThenDigitSequence();
-            String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches
             boolean looksLegit = reader.matches(';');
-            boolean found = false;
-            while (nameRef.length() > 0 && !found) {
-                if (Entities.isNamedEntity(nameRef))
-                    found = true;
-                else {
-                    nameRef = nameRef.substring(0, nameRef.length()-1);
-                    reader.unconsume();
-                }
-            }
+            // found if a base named entity without a ;, or an extended entity with the ;.
+            boolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));
+
             if (!found) {
-                if (looksLegit) // named with semicolon
-                    characterReferenceError(String.format("invalid named referenece '%s'", origNameRef));
                 reader.rewindToMark();
+                if (looksLegit) // named with semicolon
+                    characterReferenceError(String.format("invalid named referenece '%s'", nameRef));
                 return null;
             }
             if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
@@ -227,4 +220,25 @@ class Tokeniser {
         // Element currentNode = currentNode();
         // return currentNode != null && currentNode.namespace().equals("HTML");
     }
+
+    /**
+     * Utility method to consume reader and unescape entities found within.
+     * @param inAttribute
+     * @return unescaped string from reader
+     */
+    String unescapeEntities(boolean inAttribute) {
+        StringBuilder builder = new StringBuilder();
+        while (!reader.isEmpty()) {
+            builder.append(reader.consumeTo('&'));
+            if (reader.matches('&')) {
+                reader.consume();
+                Character c = consumeCharacterReference(null, inAttribute);
+                if (c == null)
+                    builder.append('&');
+                else
+                    builder.append(c);
+            }
+        }
+        return builder.toString();
+    }
 }
diff --git a/src/test/java/org/jsoup/nodes/EntitiesTest.java b/src/test/java/org/jsoup/nodes/EntitiesTest.java
index 392a9ef5..e88b41c0 100644
--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java
+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java
@@ -4,7 +4,6 @@ import org.jsoup.Jsoup;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
-import org.jsoup.nodes.Entities;
 
 import java.nio.charset.Charset;
 
@@ -24,17 +23,17 @@ public class EntitiesTest {
     }
 
     @Test public void unescape() {
-        String text = "Hello &amp;&LT&gt; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;";
-        assertEquals("Hello &<> Å π π 新 there &! ¾ © ©", Entities.unescape(text));
+        String text = "Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;";
+        assertEquals("Hello &<> ® Å &angst π π 新 there &! ¾ © ©", Entities.unescape(text));
 
         assertEquals("&0987654321; &unknown", Entities.unescape("&0987654321; &unknown"));
     }
 
     @Test public void strictUnescape() { // for attributes, enforce strict unescaping (must look like &xxx; , not just &xxx)
-        String text = "Hello &mid &amp;";
-        assertEquals("Hello &mid &", Entities.unescape(text, true));
-        assertEquals("Hello ∣ &", Entities.unescape(text));
-        assertEquals("Hello ∣ &", Entities.unescape(text, false));
+        String text = "Hello &amp= &amp;";
+        assertEquals("Hello &amp= &", Entities.unescape(text, true));
+        assertEquals("Hello &= &", Entities.unescape(text));
+        assertEquals("Hello &= &", Entities.unescape(text, false));
     }
 
     
@@ -60,4 +59,9 @@ public class EntitiesTest {
         assertEquals("&sup1;&sup2;&sup3;&frac14;&frac12;&frac34;", p.html());
         assertEquals("¹²³¼½¾", p.text());
     }
+
+    @Test public void noSpuriousDecodes() {
+        String string = "http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2";
+        assertEquals(string, Entities.unescape(string));
+    }
 }
diff --git a/src/test/java/org/jsoup/parser/AttributeParseTest.java b/src/test/java/org/jsoup/parser/AttributeParseTest.java
index 6db6d1f7..eebd40cb 100644
--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java
+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java
@@ -57,13 +57,13 @@ public class AttributeParseTest {
     @Test public void strictAttributeUnescapes() {
         String html = "<a id=1 href='?foo=bar&mid&lt=true'>One</a> <a id=2 href='?foo=bar&lt;qux&lg=1'>Two</a>";
         Elements els = Jsoup.parse(html).select("a");
-        assertEquals("?foo=bar∣&lt=true", els.first().attr("href")); // &mid gets to ∣ because not tailed by =; lt is so not unescaped
+        assertEquals("?foo=bar&mid&lt=true", els.first().attr("href"));
         assertEquals("?foo=bar<qux&lg=1", els.last().attr("href"));
     }
 
     @Test public void moreAttributeUnescapes() {
         String html = "<a href='&wr_id=123&mid-size=true&ok=&wr'>Check</a>";
         Elements els = Jsoup.parse(html).select("a");
-        assertEquals("&wr_id=123&mid-size=true&ok=≀", els.first().attr("href"));
+        assertEquals("&wr_id=123&mid-size=true&ok=&wr", els.first().attr("href"));
     }
 }
diff --git a/src/test/java/org/jsoup/parser/HtmlParserTest.java b/src/test/java/org/jsoup/parser/HtmlParserTest.java
index 046bc306..5cc5e922 100644
--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java
@@ -720,4 +720,20 @@ public class HtmlParserTest {
         assertEquals("html", nodes.get(0).nodeName());
         assertEquals("<html> <head></head> <body> <ol> <li>One</li> </ol> <p>Two</p> </body> </html>", StringUtil.normaliseWhitespace(nodes.get(0).outerHtml()));
     }
+
+    @Test public void doesNotFindShortestMatchingEntity() {
+        // previous behaviour was to identify a possible entity, then chomp down the string until a match was found.
+        // (as defined in html5.) However in practise that lead to spurious matches against the author's intent.
+        String html = "One &clubsuite; &clubsuit;";
+        Document doc = Jsoup.parse(html);
+        assertEquals(StringUtil.normaliseWhitespace("One &amp;clubsuite; ♣"), doc.body().html());
+    }
+
+    @Test public void relaxedBaseEntityMatchAndStrictExtendedMatch() {
+        // extended entities need a ; at the end to match, base does not
+        String html = "&amp &quot &reg &icy &hopf &icy; &hopf;";
+        Document doc = Jsoup.parse(html);
+        doc.outputSettings().escapeMode(Entities.EscapeMode.extended); // modifies output only to clarify test
+        assertEquals(StringUtil.normaliseWhitespace("&amp; &quot; &reg; &amp;icy &amp;hopf &icy; &hopf;"), doc.body().html());
+    }
 }
