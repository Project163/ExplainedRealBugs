diff --git a/CHANGES b/CHANGES
index 89104515..c44379d5 100644
--- a/CHANGES
+++ b/CHANGES
@@ -141,6 +141,10 @@ jsoup changelog
     the formatting tag search depth to 256. In practice, it's generally between 4 - 8.
     <https://github.com/jhy/jsoup/issues/1544>
 
+  * Bugfix: [Fuzz] when parsing an unterminated RCDATA token (e.g. a <title> tag), could throw an IO Exception "No
+    buffer left to unconsume" when trying to rewind the buffer.
+    <https://github.com/jhy/jsoup/issues/1542>
+
 *** Release 1.13.1 [2020-Feb-29]
   * Improvement: added Element#closest(selector), which walks up the tree to find the nearest element matching the
     selector.
diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java
index 94710fd0..a781a0c2 100644
--- a/src/main/java/org/jsoup/parser/CharacterReader.java
+++ b/src/main/java/org/jsoup/parser/CharacterReader.java
@@ -137,9 +137,12 @@ public final class CharacterReader {
         return val;
     }
 
+    /**
+     Unconsume one character (bufPos--). MUST only be called directly after a consume(), and no chance of a bufferUp.
+     */
     void unconsume() {
         if (bufPos < 1)
-            throw new UncheckedIOException(new IOException("No buffer left to unconsume"));
+            throw new UncheckedIOException(new IOException("WTF: No buffer left to unconsume.")); // a bug if this fires, need to trace it.
 
         bufPos--;
     }
diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java
index 74e96fa5..e405c1b7 100644
--- a/src/main/java/org/jsoup/parser/TokeniserState.java
+++ b/src/main/java/org/jsoup/parser/TokeniserState.java
@@ -191,8 +191,7 @@ enum TokeniserState {
                 // consuming to EOF; break out here
                 t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());
                 t.emitTagPending();
-                r.unconsume(); // undo "<"
-                t.transition(Data);
+                t.transition(TagOpen); // straight into TagOpen, as we came from < and looks like we're on a start tag
             } else {
                 t.emit("<");
                 t.transition(Rcdata);
diff --git a/src/test/java/org/jsoup/integration/FuzzFixesTest.java b/src/test/java/org/jsoup/integration/FuzzFixesTest.java
index d2dc86c5..5aeb7c9f 100644
--- a/src/test/java/org/jsoup/integration/FuzzFixesTest.java
+++ b/src/test/java/org/jsoup/integration/FuzzFixesTest.java
@@ -2,7 +2,6 @@ package org.jsoup.integration;
 
 import org.jsoup.Jsoup;
 import org.jsoup.nodes.Document;
-import org.jsoup.parser.HtmlParserTest;
 import org.jsoup.parser.Parser;
 import org.junit.jupiter.api.Test;
 
@@ -11,28 +10,30 @@ import java.io.FileInputStream;
 import java.io.IOException;
 
 import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 
 /**
  Tests fixes for issues raised by the OSS Fuzz project @ https://oss-fuzz.com/testcases?project=jsoup
  */
 public class FuzzFixesTest {
 
-    @Test public void blankAbsAttr() {
+    @Test
+    public void blankAbsAttr() {
         // https://github.com/jhy/jsoup/issues/1541
         String html = "b<bodY abs: abs:abs: abs:abs:abs>";
         Document doc = Jsoup.parse(html);
         assertNotNull(doc);
     }
 
-    @Test public void resetInsertionMode() throws IOException {
+    @Test
+    public void resetInsertionMode() throws IOException {
         // https://github.com/jhy/jsoup/issues/1538
         File in = ParseTest.getFile("/fuzztests/1538.html"); // lots of escape chars etc.
         Document doc = Jsoup.parse(in, "UTF-8");
         assertNotNull(doc);
     }
 
-    @Test public void xmlDeclOverflow() throws IOException {
+    @Test
+    public void xmlDeclOverflow() throws IOException {
         // https://github.com/jhy/jsoup/issues/1539
         File in = ParseTest.getFile("/fuzztests/1539.html"); // lots of escape chars etc.
         Document doc = Jsoup.parse(in, "UTF-8");
@@ -42,26 +43,16 @@ public class FuzzFixesTest {
         assertNotNull(docXml);
     }
 
-    @Test public void unconsume() throws IOException {
-        // https://github.com/jhy/jsoup/issues/1542
-        File in = ParseTest.getFile("/fuzztests/1542.html"); // lots of escape chars etc.
-        Document doc = Jsoup.parse(in, "UTF-8");
-        assertNotNull(doc);
-
-        Document docFromString = Jsoup.parse(ParseTest.getFileAsString(in));
-        assertNotNull(docFromString);
-
-        // I haven't been able to replicate this - per code, content is handed as a plain string, as here. File encoding issue? Tried UTF8, ascii, windows-1252.
-    }
-
-    @Test public void stackOverflowState14() throws IOException {
+    @Test
+    public void stackOverflowState14() throws IOException {
         // https://github.com/jhy/jsoup/issues/1543
         File in = ParseTest.getFile("/fuzztests/1543.html");
         Document doc = Jsoup.parse(in, "UTF-8");
         assertNotNull(doc);
     }
 
-    @Test public void parseTimeout() throws IOException {
+    @Test
+    public void parseTimeout() throws IOException {
         // https://github.com/jhy/jsoup/issues/1544
         File in = ParseTest.getFile("/fuzztests/1544.html");
         Document doc = Jsoup.parse(in, "UTF-8");
diff --git a/src/test/java/org/jsoup/parser/TokeniserStateTest.java b/src/test/java/org/jsoup/parser/TokeniserStateTest.java
index d8a791f3..d34c38fc 100644
--- a/src/test/java/org/jsoup/parser/TokeniserStateTest.java
+++ b/src/test/java/org/jsoup/parser/TokeniserStateTest.java
@@ -218,6 +218,18 @@ public class TokeniserStateTest {
         assertEquals(CharacterReader.readAheadLimit - 1, errorList.get(0).getPosition());
     }
 
+    @Test
+    public void testUnconsumeAfterBufferUp() {
+        // test for after consume() a bufferUp occurs (look-forward) but then attempts to unconsume. Would throw a "No buffer left to unconsume"
+        String triggeringSnippet = "<title>One <span>Two";
+        char[] padding = new char[CharacterReader.readAheadLimit - triggeringSnippet.length() + 8]; // The "<span" part must be just at the limit. The "containsIgnoreCase" scan does a bufferUp, losing the unconsume
+        Arrays.fill(padding, ' ');
+        String paddedSnippet = String.valueOf(padding) + triggeringSnippet;
+        ParseErrorList errorList = ParseErrorList.tracking(1);
+        Parser.parseFragment(paddedSnippet, null, "", errorList);
+        // just asserting we don't get a WTF on unconsume
+    }
+
     @Test
     public void testOpeningAngleBracketInsteadOfAttribute() {
         String triggeringSnippet = "<html <";
