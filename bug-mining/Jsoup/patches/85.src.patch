diff --git a/CHANGES b/CHANGES
index 0b24e2d5..f0cd67dd 100644
--- a/CHANGES
+++ b/CHANGES
@@ -7,6 +7,9 @@ jsoup changelog
  * Refactored the Cleaner to traverse rather than recurse child nodes, to avoid the risk of overflowing the stack.
    <https://github.com/jhy/jsoup/issues/246>
 
+ * Added Element.insertChildren(), to easily insert a list of child nodes at a specific index.
+   <https://github.com/jhy/jsoup/issues/239>
+
  * When parsing in XML mode, preserve XML declarations (<?xml ... ?>).
    <https://github.com/jhy/jsoup/issues/242>
 
diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index d3e74142..9f2ef5c8 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -258,7 +258,7 @@ public class Element extends Node {
     /**
      * Add a node child node to this element.
      * 
-     * @param child node to add. Must not already have a parent.
+     * @param child node to add.
      * @return this element, so that you can add more child nodes or elements.
      */
     public Element appendChild(Node child) {
@@ -267,11 +267,11 @@ public class Element extends Node {
         addChildren(child);
         return this;
     }
-    
+
     /**
      * Add a node to the start of this element's children.
      * 
-     * @param child node to add. Must not already have a parent.
+     * @param child node to add.
      * @return this element, so that you can add more child nodes or elements.
      */
     public Element prependChild(Node child) {
@@ -280,6 +280,28 @@ public class Element extends Node {
         addChildren(0, child);
         return this;
     }
+
+
+    /**
+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the
+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
+     *
+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the
+     * end
+     * @param children child nodes to insert
+     * @return this element, for chaining.
+     */
+    public Element insertChildren(int index, Collection<? extends Node> children) {
+        Validate.notNull(children, "Children collection to be inserted must not be null.");
+        int currentSize = childNodeSize();
+        if (index < 0) index += currentSize +1; // roll around
+        Validate.isTrue(index >= 0 && index <= currentSize, "Insert position out of bounds.");
+
+        ArrayList<Node> nodes = new ArrayList<Node>(children);
+        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);
+        addChildren(index, nodeArray);
+        return this;
+    }
     
     /**
      * Create a new element by tag name, and add it as the last child.
diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java
index ee622ea5..95d8814e 100644
--- a/src/main/java/org/jsoup/nodes/Node.java
+++ b/src/main/java/org/jsoup/nodes/Node.java
@@ -210,13 +210,19 @@ public abstract class Node implements Cloneable {
      @return list of children. If no children, returns an empty list.
      */
     public List<Node> childNodes() {
-        // actually returns the real list, as this method is hit many times during selection, and so is a GC time-sink
-        // leaving the documentation as is (warning of unmodifiability) to discourage out-of-API modifications
-        return childNodes;
+        return Collections.unmodifiableList(childNodes);
+    }
+
+    /**
+     * Get the number of child nodes that this node holds.
+     * @return the number of child nodes that this node holds.
+     */
+    public final int childNodeSize() {
+        return childNodes.size();
     }
     
     protected Node[] childNodesAsArray() {
-        return childNodes.toArray(new Node[childNodes().size()]);
+        return childNodes.toArray(new Node[childNodeSize()]);
     }
 
     /**
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index ceab9faa..510943ea 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -721,7 +721,7 @@ enum HtmlTreeBuilderState {
                             }
 
                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());
-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);
+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);
                             for (Node childNode : childNodes) {
                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.
                             }
diff --git a/src/main/java/org/jsoup/select/Elements.java b/src/main/java/org/jsoup/select/Elements.java
index 0b101c71..184b0874 100644
--- a/src/main/java/org/jsoup/select/Elements.java
+++ b/src/main/java/org/jsoup/select/Elements.java
@@ -34,7 +34,11 @@ public class Elements implements List<Element>, Cloneable {
     public Elements(Element... elements) {
         this(Arrays.asList(elements));
     }
-    
+
+    /**
+     * Creates a deep copy of these elements.
+     * @return a deep copy
+     */
     @Override
 	public Elements clone() {
     	List<Element> elements = new ArrayList<Element>();
diff --git a/src/main/java/org/jsoup/select/NodeTraversor.java b/src/main/java/org/jsoup/select/NodeTraversor.java
index 9bb081e5..fd35e2ed 100644
--- a/src/main/java/org/jsoup/select/NodeTraversor.java
+++ b/src/main/java/org/jsoup/select/NodeTraversor.java
@@ -28,7 +28,7 @@ public class NodeTraversor {
         
         while (node != null) {
             visitor.head(node, depth);
-            if (node.childNodes().size() > 0) {
+            if (node.childNodeSize() > 0) {
                 node = node.childNode(0);
                 depth++;
             } else {
diff --git a/src/test/java/org/jsoup/nodes/ElementTest.java b/src/test/java/org/jsoup/nodes/ElementTest.java
index 3b4c21d3..65a795a9 100644
--- a/src/test/java/org/jsoup/nodes/ElementTest.java
+++ b/src/test/java/org/jsoup/nodes/ElementTest.java
@@ -2,11 +2,14 @@ package org.jsoup.nodes;
 
 import org.jsoup.Jsoup;
 import org.jsoup.TextUtil;
+import org.jsoup.helper.StringUtil;
+import org.jsoup.parser.Tag;
 import org.jsoup.select.Elements;
 import org.junit.Test;
 
 import static org.junit.Assert.*;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 import java.util.Map;
@@ -552,4 +555,95 @@ public class ElementTest {
             fail("Should throw index out of bounds");
         } catch (IndexOutOfBoundsException e) {}
     }
+
+    @Test
+    public void moveByAppend() {
+        // test for https://github.com/jhy/jsoup/issues/239
+        // can empty an element and append its children to another element
+        Document doc = Jsoup.parse("<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>");
+        Element div1 = doc.select("div").get(0);
+        Element div2 = doc.select("div").get(1);
+
+        assertEquals(4, div1.childNodeSize());
+        List<Node> children = div1.childNodes();
+        assertEquals(4, children.size());
+
+        div2.insertChildren(0, children);
+
+        assertEquals(0, children.size()); // children is backed by div1.childNodes, moved, so should be 0 now
+        assertEquals(0, div1.childNodeSize());
+        assertEquals(4, div2.childNodeSize());
+        assertEquals("<div id=\"1\"></div>\n<div id=\"2\">\n Text \n <p>One</p> Text \n <p>Two</p>\n</div>",
+            doc.body().html());
+    }
+
+    @Test
+    public void insertChildrenArgumentValidation() {
+        Document doc = Jsoup.parse("<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>");
+        Element div1 = doc.select("div").get(0);
+        Element div2 = doc.select("div").get(1);
+        List<Node> children = div1.childNodes();
+
+        try {
+            div2.insertChildren(6, children);
+            fail();
+        } catch (IllegalArgumentException e) {}
+
+        try {
+            div2.insertChildren(-5, children);
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+
+        try {
+            div2.insertChildren(0, null);
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    @Test
+    public void insertChildrenAtPosition() {
+        Document doc = Jsoup.parse("<div id=1>Text1 <p>One</p> Text2 <p>Two</p></div><div id=2>Text3 <p>Three</p></div>");
+        Element div1 = doc.select("div").get(0);
+        Elements p1s = div1.select("p");
+        Element div2 = doc.select("div").get(1);
+
+        assertEquals(2, div2.childNodeSize());
+        div2.insertChildren(-1, p1s);
+        assertEquals(2, div1.childNodeSize()); // moved two out
+        assertEquals(4, div2.childNodeSize());
+        assertEquals(3, p1s.get(1).siblingIndex()); // should be last
+
+        List<Node> els = new ArrayList<Node>();
+        Element el1 = new Element(Tag.valueOf("span"), "").text("Span1");
+        Element el2 = new Element(Tag.valueOf("span"), "").text("Span2");
+        TextNode tn1 = new TextNode("Text4", "");
+        els.add(el1);
+        els.add(el2);
+        els.add(tn1);
+
+        assertNull(el1.parent());
+        div2.insertChildren(-2, els);
+        assertEquals(div2, el1.parent());
+        assertEquals(7, div2.childNodeSize());
+        assertEquals(3, el1.siblingIndex());
+        assertEquals(4, el2.siblingIndex());
+        assertEquals(5, tn1.siblingIndex());
+    }
+
+    @Test
+    public void insertChildrenAsCopy() {
+        Document doc = Jsoup.parse("<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>");
+        Element div1 = doc.select("div").get(0);
+        Element div2 = doc.select("div").get(1);
+        Elements ps = doc.select("p").clone();
+        ps.first().text("One cloned");
+        div2.insertChildren(-1, ps);
+
+        assertEquals(4, div1.childNodeSize()); // not moved -- cloned
+        assertEquals(2, div2.childNodeSize());
+        assertEquals("<div id=\"1\">Text <p>One</p> Text <p>Two</p></div><div id=\"2\"><p>One cloned</p><p>Two</p></div>",
+            TextUtil.stripNewlines(doc.body().html()));
+    }
 }
diff --git a/src/test/java/org/jsoup/parser/HtmlParserTest.java b/src/test/java/org/jsoup/parser/HtmlParserTest.java
index 9a03bab9..33b0d33c 100644
--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java
@@ -284,7 +284,7 @@ public class HtmlParserTest {
         Element div = doc.getElementById("1");
         assertEquals("<html> <foo><&amp;", div.text());
         assertEquals(0, div.children().size());
-        assertEquals(1, div.childNodes().size()); // no elements, one text node
+        assertEquals(1, div.childNodeSize()); // no elements, one text node
     }
 
     @Test public void handlesInvalidStartTags() {
diff --git a/src/test/java/org/jsoup/safety/CleanerTest.java b/src/test/java/org/jsoup/safety/CleanerTest.java
index 3b2e30fc..3d9dfd26 100644
--- a/src/test/java/org/jsoup/safety/CleanerTest.java
+++ b/src/test/java/org/jsoup/safety/CleanerTest.java
@@ -176,7 +176,7 @@ public class CleanerTest {
         Document dirtyDoc = Jsoup.parse(dirty);
         Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);
         assertFalse(cleanDoc == null);
-        assertEquals(0, cleanDoc.body().childNodes().size());
+        assertEquals(0, cleanDoc.body().childNodeSize());
     }
 
     @Test public void cleansInternationalText() {
