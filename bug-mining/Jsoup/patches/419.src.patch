diff --git a/CHANGES.md b/CHANGES.md
index 57d1cd7d..80ca454c 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -11,6 +11,7 @@
 
 ### Bug Fixes
 * When parsing from an InputStream and a multibyte character happened to straddle a buffer boundary, the stream would not be completely read. [#2353](https://github.com/jhy/jsoup/issues/2353).
+* In `NodeTraversor`, if a last child element was removed during the `head()` call, the parent would be visited twice. [#2355](https://github.com/jhy/jsoup/issues/2355).
 
 ## 1.21.1 (2025-Jun-23)
 
diff --git a/src/main/java/org/jsoup/select/NodeTraversor.java b/src/main/java/org/jsoup/select/NodeTraversor.java
index 71f9bbcc..763be08d 100644
--- a/src/main/java/org/jsoup/select/NodeTraversor.java
+++ b/src/main/java/org/jsoup/select/NodeTraversor.java
@@ -25,24 +25,39 @@ public class NodeTraversor {
         Validate.notNull(root);
         Node node = root;
         int depth = 0;
-        
+
         while (node != null) {
             Node parent = node.parentNode(); // remember parent to find nodes that get replaced in .head
             int origSize = parent != null ? parent.childNodeSize() : 0;
             Node next = node.nextSibling();
 
             visitor.head(node, depth); // visit current node
+
+            // check for modifications to the tree
             if (parent != null && !node.hasParent()) { // removed or replaced
                 if (origSize == parent.childNodeSize()) { // replaced
                     node = parent.childNode(node.siblingIndex()); // replace ditches parent but keeps sibling index
-                } else { // removed
-                    node = next;
-                    if (node == null) { // last one, go up
-                        node = parent;
+                    continue;
+                }
+                // else, removed
+                node = next;
+                if (node == null) {
+                    // was last in parent. need to walk up the tree, tail()ing on the way, until we find a suitable next. Otherwise, would revisit ancestor nodes.
+                    node = parent;
+                    while (true) {
                         depth--;
+                        visitor.tail(node, depth);
+                        if (node == root) break;
+                        if (node.nextSibling() != null) {
+                            node = node.nextSibling();
+                            break;
+                        }
+                        node = node.parentNode();
+                        if (node == null) break;
                     }
-                    continue; // don't tail removed
+                    if (node == root || node == null) break; // done, break outer
                 }
+                continue; // don't tail removed
             }
 
             if (node.childNodeSize() > 0) { // descend
diff --git a/src/test/java/org/jsoup/nodes/NodeIteratorTest.java b/src/test/java/org/jsoup/nodes/NodeIteratorTest.java
index 1102c6f3..3a54fbf4 100644
--- a/src/test/java/org/jsoup/nodes/NodeIteratorTest.java
+++ b/src/test/java/org/jsoup/nodes/NodeIteratorTest.java
@@ -8,7 +8,7 @@ import java.util.NoSuchElementException;
 
 import static org.junit.jupiter.api.Assertions.*;
 
-class NodeIteratorTest {
+public class NodeIteratorTest {
     String html = "<div id=1><p>One<p>Two</div><div id=2><p>Three<p>Four</div>";
 
     @Test void canIterateNodes() {
@@ -249,7 +249,7 @@ class NodeIteratorTest {
         assertIterates(it, expected);
     }
 
-    static void trackSeen(Node node, StringBuilder actual) {
+    public static void trackSeen(Node node, StringBuilder actual) {
         if (node instanceof Element) {
             Element el = (Element) node;
             actual.append(el.tagName());
diff --git a/src/test/java/org/jsoup/select/TraversorTest.java b/src/test/java/org/jsoup/select/TraversorTest.java
index dd4400be..9f57a8d7 100644
--- a/src/test/java/org/jsoup/select/TraversorTest.java
+++ b/src/test/java/org/jsoup/select/TraversorTest.java
@@ -7,10 +7,14 @@ import org.jsoup.nodes.Element;
 import org.jsoup.nodes.Node;
 import org.jsoup.nodes.TextNode;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 
+import java.util.HashSet;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static org.jsoup.nodes.NodeIteratorTest.trackSeen;
 import static org.junit.jupiter.api.Assertions.*;
 
 public class TraversorTest {
@@ -220,4 +224,44 @@ public class TraversorTest {
         });
         assertTrue(seen.get());
     }
+
+    @ParameterizedTest
+    @ValueSource(strings = {"em", "b"})
+    void doesntVisitAgainAfterRemoving(String removeTag) {
+        // https://github.com/jhy/jsoup/issues/2355
+        Document doc = Jsoup.parse("<div id=1><div><em>first</em><b>last</b></div></div>");
+        HashSet<Node> visited = new HashSet<>();
+        NodeTraversor.traverse((node, depth) -> {
+            if (!visited.add(node))
+                fail(String.format("node '%s' is being visited for the second time", node));
+            if (removeTag.equals(node.nodeName()))
+                node.remove();
+        }, doc);
+    }
+
+
+    @Test
+    void traversesOnceInOrderAfterRemove() {
+        Document doc = Jsoup.parse("<div><p>Text <em>emphasized</em> and <b>bold</b></p></div>");
+        StringBuilder headOrder = new StringBuilder();
+        StringBuilder tailOrder = new StringBuilder();
+
+        NodeTraversor.traverse(new NodeVisitor() {
+            @Override
+            public void head(Node node, int depth) {
+                trackSeen(node, headOrder);
+                if ("b".equals(node.nodeName())) // remove the b, causes a cascade of last childs, don't miss any
+                    node.remove();
+            }
+
+            @Override
+            public void tail(Node node, int depth) {
+                trackSeen(node, tailOrder);
+            }
+        }, doc);
+
+        // check
+        assertEquals("#root;html;head;body;div;p;Text ;em;emphasized; and ;b;", headOrder.toString());
+        assertEquals("head;Text ;emphasized;em; and ;p;div;body;html;#root;", tailOrder.toString());
+    }
 }
