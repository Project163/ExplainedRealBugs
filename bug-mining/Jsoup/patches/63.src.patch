diff --git a/CHANGES b/CHANGES
index 2c604be1..4a182410 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,6 +1,10 @@
 jsoup changelog
 
-*** Release 1.6.4 [PENDING]
+*** Release 1.7.2 [PENDING]
+ * Refactored the Cleaner to traverse rather than recurse child nodes, to avoid the risk of overflowing the stack.
+   <https://github.com/jhy/jsoup/issues/246>
+
+*** Release 1.7.1 [2012-Sep-23]
  * Improved parse time, now 2.3x faster than previous release, with lower memory consumption.
 
  * Reduced memory consumption when selecting elements.
diff --git a/src/main/java/org/jsoup/safety/Cleaner.java b/src/main/java/org/jsoup/safety/Cleaner.java
index 8110836f..27af7a7b 100644
--- a/src/main/java/org/jsoup/safety/Cleaner.java
+++ b/src/main/java/org/jsoup/safety/Cleaner.java
@@ -3,6 +3,8 @@ package org.jsoup.safety;
 import org.jsoup.helper.Validate;
 import org.jsoup.nodes.*;
 import org.jsoup.parser.Tag;
+import org.jsoup.select.NodeTraversor;
+import org.jsoup.select.NodeVisitor;
 
 import java.util.List;
 
@@ -66,36 +68,52 @@ public class Cleaner {
 
     /**
      Iterates the input and copies trusted nodes (tags, attributes, text) into the destination.
-     @param source source of HTML
-     @param dest destination element to copy into
-     @return number of discarded elements (that were considered unsafe)
      */
-    private int copySafeNodes(Element source, Element dest) {
-        List<Node> sourceChildren = source.childNodes();
-        int numDiscarded = 0;
+    private final class CleaningVisitor implements NodeVisitor {
+        private int numDiscarded = 0;
+        private final Element root;
+        private Element destination; // current element to append nodes to
+
+        private CleaningVisitor(Element root, Element destination) {
+            this.root = root;
+            this.destination = destination;
+        }
 
-        for (Node sourceChild : sourceChildren) {
-            if (sourceChild instanceof Element) {
-                Element sourceEl = (Element) sourceChild;
+        public void head(Node source, int depth) {
+            if (source instanceof Element) {
+                Element sourceEl = (Element) source;
 
                 if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs
                     ElementMeta meta = createSafeElement(sourceEl);
                     Element destChild = meta.el;
-                    dest.appendChild(destChild);
+                    destination.appendChild(destChild);
 
                     numDiscarded += meta.numAttribsDiscarded;
-                    numDiscarded += copySafeNodes(sourceEl, destChild); // recurs
-                } else { // not a safe tag, but it may have children (els or text) that are, so recurse
+                    destination = destChild;
+                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.
                     numDiscarded++;
-                    numDiscarded += copySafeNodes(sourceEl, dest);
                 }
-            } else if (sourceChild instanceof TextNode) {
-                TextNode sourceText = (TextNode) sourceChild;
-                TextNode destText = new TextNode(sourceText.getWholeText(), sourceChild.baseUri());
-                dest.appendChild(destText);
-            } // else, we don't care about comments, xml proc instructions, etc
+            } else if (source instanceof TextNode) {
+                TextNode sourceText = (TextNode) source;
+                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());
+                destination.appendChild(destText);
+            } else { // else, we don't care about comments, xml proc instructions, etc
+                numDiscarded++;
+            }
         }
-        return numDiscarded;
+
+        public void tail(Node source, int depth) {
+            if (source instanceof Element && whitelist.isSafeTag(source.nodeName())) {
+                destination = destination.parent(); // would have descended, so pop destination stack
+            }
+        }
+    }
+
+    private int copySafeNodes(Element source, Element dest) {
+        CleaningVisitor cleaningVisitor = new CleaningVisitor(source, dest);
+        NodeTraversor traversor = new NodeTraversor(cleaningVisitor);
+        traversor.traverse(source);
+        return cleaningVisitor.numDiscarded;
     }
 
     private ElementMeta createSafeElement(Element sourceEl) {
diff --git a/src/test/java/org/jsoup/safety/CleanerTest.java b/src/test/java/org/jsoup/safety/CleanerTest.java
index 9e45cdf4..3b2e30fc 100644
--- a/src/test/java/org/jsoup/safety/CleanerTest.java
+++ b/src/test/java/org/jsoup/safety/CleanerTest.java
@@ -92,9 +92,11 @@ public class CleanerTest {
         String ok = "<p>Test <b><a href='http://example.com/'>OK</a></b></p>";
         String nok1 = "<p><script></script>Not <b>OK</b></p>";
         String nok2 = "<p align=right>Test Not <b>OK</b></p>";
+        String nok3 = "<!-- comment --><p>Not OK</p>"; // comments and the like will be cleaned
         assertTrue(Jsoup.isValid(ok, Whitelist.basic()));
         assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));
         assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));
+        assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));
     }
     
     @Test public void resolvesRelativeLinks() {
@@ -103,7 +105,7 @@ public class CleanerTest {
         assertEquals("<a href=\"http://example.com/foo\" rel=\"nofollow\">Link</a>\n<img src=\"http://example.com/bar\" />", clean);
     }
 
-    @Test public void preservesRelatedLinksIfConfigured() {
+    @Test public void preservesRelativeLinksIfConfigured() {
         String html = "<a href='/foo'>Link</a><img src='/bar'> <img src='javascript:alert()'>";
         String clean = Jsoup.clean(html, "http://example.com/", Whitelist.basicWithImages().preserveRelativeLinks(true));
         assertEquals("<a href=\"/foo\" rel=\"nofollow\">Link</a>\n<img src=\"/bar\" /> \n<img />", clean);
