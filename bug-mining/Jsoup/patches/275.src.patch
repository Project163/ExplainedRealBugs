diff --git a/CHANGES b/CHANGES
index 7a356e68..893e0016 100644
--- a/CHANGES
+++ b/CHANGES
@@ -4,6 +4,9 @@ jsoup changelog
   * Improvement: added native XPath support in Element#selectXpath(String)
     <https://github.com/jhy/jsoup/pull/1629>
 
+  * Improvement: added full support for the <template> tag to the HTML5 parser spec.
+    <https://github.com/jhy/jsoup/issues/1634>
+
   * Improvement: added support in CharacterReader to track newlines, so that parse errors can be reported more
     intuitively.
     <https://github.com/jhy/jsoup/pull/1624>
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
index 8c7c8ce2..ff55f91c 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
@@ -32,6 +32,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
     static final String[] TagSearchTableScope = new String[]{"html", "table"};
     static final String[] TagSearchSelectScope = new String[]{"optgroup", "option"};
     static final String[] TagSearchEndTags = new String[]{"dd", "dt", "li", "optgroup", "option", "p", "rb", "rp", "rt", "rtc"};
+    static final String[] TagThoroughSearchEndTags = new String[]{"caption", "colgroup", "dd", "dt", "li", "optgroup", "option", "p", "rb", "rp", "rt", "rtc", "tbody", "td", "tfoot", "th", "thead", "tr"};
     static final String[] TagSearchSpecial = new String[]{"address", "applet", "area", "article", "aside", "base", "basefont", "bgsound",
         "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "command", "dd",
         "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form",
@@ -51,6 +52,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
     private @Nullable FormElement formElement; // the current form element
     private @Nullable Element contextElement; // fragment parse context -- could be null even if fragment parsing
     private ArrayList<Element> formattingElements; // active (open) formatting elements
+    private ArrayList<HtmlTreeBuilderState> tmplInsertMode; // stack of Template Insertion modes
     private List<String> pendingTableCharacters; // chars in table to be shifted out
     private Token.EndTag emptyEnd; // reused empty end tag
 
@@ -79,6 +81,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
         formElement = null;
         contextElement = null;
         formattingElements = new ArrayList<>();
+        tmplInsertMode = new ArrayList<>();
         pendingTableCharacters = new ArrayList<>();
         emptyEnd = new Token.EndTag();
         framesetOk = true;
@@ -109,13 +112,15 @@ public class HtmlTreeBuilder extends TreeBuilder {
             else if (contextTag.equals(("noscript")))
                 tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext
             else if (contextTag.equals("plaintext"))
-                tokeniser.transition(TokeniserState.Data);
+                tokeniser.transition(TokeniserState.PLAINTEXT);
             else
                 tokeniser.transition(TokeniserState.Data); // default
 
             root = new Element(Tag.valueOf(contextTag, settings), baseUri);
             doc.appendChild(root);
             stack.add(root);
+            if (contextTag.equals("template"))
+                pushTemplateMode(HtmlTreeBuilderState.InTemplate);
             resetInsertionMode();
 
             // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated
@@ -258,10 +263,15 @@ public class HtmlTreeBuilder extends TreeBuilder {
         return el;
     }
 
-    FormElement insertForm(Token.StartTag startTag, boolean onStack) {
+    FormElement insertForm(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {
         Tag tag = Tag.valueOf(startTag.name(), settings);
         FormElement el = new FormElement(tag, null, settings.normalizeAttributes(startTag.attributes));
-        setFormElement(el);
+        if (checkTemplateStack) {
+            if(!onStack("template"))
+                setFormElement(el);
+        } else
+            setFormElement(el);
+
         insertNode(el);
         if (onStack)
             stack.add(el);
@@ -318,11 +328,15 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     boolean onStack(Element el) {
-        return isElementInQueue(stack, el);
+        return onStack(stack, el);
+    }
+
+    boolean onStack(String elName) {
+        return getFromStack(elName) != null;
     }
 
     private static final int maxQueueDepth = 256; // an arbitrary tension point between real HTML and crafted pain
-    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {
+    private static boolean onStack(ArrayList<Element> queue, Element element) {
         final int bottom = queue.size() - 1;
         final int upper = bottom >= maxQueueDepth ? bottom - maxQueueDepth : 0;
         for (int pos = bottom; pos >= upper; pos--) {
@@ -391,7 +405,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     void clearStackToTableContext() {
-        clearStackToContext("table");
+        clearStackToContext("table", "template");
     }
 
     void clearStackToTableBodyContext() {
@@ -412,7 +426,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
         }
     }
 
-    Element aboveOnStack(Element el) {
+    @Nullable Element aboveOnStack(Element el) {
         assert onStack(el);
         for (int pos = stack.size() -1; pos >= 0; pos--) {
             Element next = stack.get(pos);
@@ -461,7 +475,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
                 transition(HtmlTreeBuilderState.InSelect);
                 // todo - should loop up (with some limit) and check for table or template hits
                 break;
-            } else if (("td".equals(name) || "th".equals(name) && !last)) {
+            } else if ((("td".equals(name) || "th".equals(name)) && !last)) {
                 transition(HtmlTreeBuilderState.InCell);
                 break;
             } else if ("tr".equals(name)) {
@@ -479,7 +493,11 @@ public class HtmlTreeBuilder extends TreeBuilder {
             } else if ("table".equals(name)) {
                 transition(HtmlTreeBuilderState.InTable);
                 break;
-            // todo - template
+            } else if ("template".equals(name)) {
+                HtmlTreeBuilderState tmplState = currentTemplateMode();
+                Validate.notNull(tmplState, "Bug: no template insertion mode on stack!");
+                transition(tmplState);
+                break;
             } else if ("head".equals(name) && !last) {
                 transition(HtmlTreeBuilderState.InHead);
                 break;
@@ -598,10 +616,12 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     /**
-     11.2.5.2 Closing elements that have implied end tags<p/>
-     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a
-     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,
-     the UA must pop the current node off the stack of open elements.
+     13.2.6.3 Closing elements that have implied end tags
+     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.
+
+     If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.
+
+     When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.
 
      @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the
      process, then the UA must perform the above steps as if that element was not in the above list.
@@ -615,7 +635,24 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     void generateImpliedEndTags() {
-        generateImpliedEndTags(null);
+        generateImpliedEndTags(false);
+    }
+
+    /**
+     Pops elements off the stack according to the implied end tag rules
+     @param thorough if we are thorough (includes table elements etc) or not
+     */
+    void generateImpliedEndTags(boolean thorough) {
+        final String[] search = thorough ? TagThoroughSearchEndTags : TagSearchEndTags;
+        while (inSorted(currentElement().normalName(), search)) {
+            pop();
+        }
+    }
+
+    void closeElement(String name) {
+        generateImpliedEndTags(name);
+        if (!name.equals(currentElement().normalName())) error(state());
+        popStackToClose(name);
     }
 
     boolean isSpecial(Element el) {
@@ -746,7 +783,7 @@ public class HtmlTreeBuilder extends TreeBuilder {
     }
 
     boolean isInActiveFormattingElements(Element el) {
-        return isElementInQueue(formattingElements, el);
+        return onStack(formattingElements, el);
     }
 
     Element getActiveFormattingElement(String nodeName) {
@@ -790,6 +827,27 @@ public class HtmlTreeBuilder extends TreeBuilder {
             fosterParent.appendChild(in);
     }
 
+    // Template Insertion Mode stack
+    void pushTemplateMode(HtmlTreeBuilderState state) {
+        tmplInsertMode.add(state);
+    }
+
+    @Nullable HtmlTreeBuilderState popTemplateMode() {
+        if (tmplInsertMode.size() > 0) {
+            return tmplInsertMode.remove(tmplInsertMode.size() -1);
+        } else {
+            return null;
+        }
+    }
+
+    int templateModeSize() {
+        return tmplInsertMode.size();
+    }
+
+    @Nullable HtmlTreeBuilderState currentTemplateMode() {
+        return (tmplInsertMode.size() > 0) ? tmplInsertMode.get(tmplInsertMode.size() -1)  : null;
+    }
+
     @Override
     public String toString() {
         return "TreeBuilder{" +
diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
index dedcb001..57c27ce3 100644
--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
@@ -135,7 +135,6 @@ enum HtmlTreeBuilderState {
                         tb.transition(InHeadNoscript);
                     } else if (name.equals("script")) {
                         // skips some script rules as won't execute them
-
                         tb.tokeniser.transition(TokeniserState.ScriptData);
                         tb.markInsertionMode();
                         tb.transition(Text);
@@ -143,6 +142,12 @@ enum HtmlTreeBuilderState {
                     } else if (name.equals("head")) {
                         tb.error(this);
                         return false;
+                    } else if (name.equals("template")) {
+                        tb.insert(start);
+                        tb.insertMarkerToFormattingElements();
+                        tb.framesetOk(false);
+                        tb.transition(InTemplate);
+                        tb.pushTemplateMode(InTemplate);
                     } else {
                         return anythingElse(t, tb);
                     }
@@ -155,7 +160,19 @@ enum HtmlTreeBuilderState {
                         tb.transition(AfterHead);
                     } else if (inSorted(name, Constants.InHeadEnd)) {
                         return anythingElse(t, tb);
-                    } else {
+                    } else if (name.equals("template")) {
+                        if (!tb.onStack(name)) {
+                            tb.error(this);
+                        } else {
+                            tb.generateImpliedEndTags(true);
+                            if (!name.equals(tb.currentElement().normalName())) tb.error(this);
+                            tb.popStackToClose(name);
+                            tb.clearFormattingElementsToLastMarker();
+                            tb.popTemplateMode();
+                            tb.resetInsertionMode();
+                        }
+                    }
+                    else {
                         tb.error(this);
                         return false;
                     }
@@ -236,9 +253,13 @@ enum HtmlTreeBuilderState {
                     anythingElse(t, tb);
                 }
             } else if (t.isEndTag()) {
-                if (inSorted(t.asEndTag().normalName(), AfterHeadBody)) {
+                String name = t.asEndTag().normalName();
+                if (inSorted(name, AfterHeadBody)) {
                     anythingElse(t, tb);
-                } else {
+                } else if (name.equals("template")) {
+                    tb.process(t, InHead);
+                }
+                else {
                     tb.error(this);
                     return false;
                 }
@@ -286,6 +307,8 @@ enum HtmlTreeBuilderState {
                 case EndTag:
                     return inBodyEndTag(t, tb);
                 case EOF:
+                    if (tb.templateModeSize() > 0)
+                        return tb.process(t, InTemplate);
                     // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html
                     // stop parsing
                     break;
@@ -340,7 +363,8 @@ enum HtmlTreeBuilderState {
                     break;
                 case "html":
                     tb.error(this);
-                    // merge attributes onto real html (if present)
+                    if (tb.onStack("template")) return false; // ignore
+                    // otherwise, merge attributes onto real html (if present)
                     stack = tb.getStack();
                     if (stack.size() > 0) {
                         Element html = tb.getStack().get(0);
@@ -355,7 +379,7 @@ enum HtmlTreeBuilderState {
                 case "body":
                     tb.error(this);
                     stack = tb.getStack();
-                    if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body"))) {
+                    if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).normalName().equals("body")) || tb.onStack("template")) {
                         // only in fragment case
                         return false; // ignore
                     } else {
@@ -389,14 +413,14 @@ enum HtmlTreeBuilderState {
                     }
                     break;
                 case "form":
-                    if (tb.getFormElement() != null) {
+                    if (tb.getFormElement() != null && !tb.onStack("template")) {
                         tb.error(this);
                         return false;
                     }
                     if (tb.inButtonScope("p")) {
-                        tb.processEndTag("p");
+                        tb.closeElement("p");
                     }
-                    tb.insertForm(startTag, true);
+                    tb.insertForm(startTag, true, true); // won't associate to any template
                     break;
                 case "plaintext":
                     if (tb.inButtonScope("p")) {
@@ -641,6 +665,9 @@ enum HtmlTreeBuilderState {
             final String name = endTag.normalName();
 
             switch (name) {
+                case "template":
+                    tb.process(t, InHead);
+                    break;
                 case "sarcasm": // *sigh*
                 case "span":
                     // same as final fall through, but saves short circuit
@@ -671,17 +698,26 @@ enum HtmlTreeBuilderState {
                         return tb.process(endTag);
                     break;
                 case "form":
-                    Element currentForm = tb.getFormElement();
-                    tb.setFormElement(null);
-                    if (currentForm == null || !tb.inScope(name)) {
-                        tb.error(this);
-                        return false;
-                    } else {
+                    if (!tb.onStack("template")) {
+                        Element currentForm = tb.getFormElement();
+                        tb.setFormElement(null);
+                        if (currentForm == null || !tb.inScope(name)) {
+                            tb.error(this);
+                            return false;
+                        }
                         tb.generateImpliedEndTags();
                         if (!tb.currentElementIs(name))
                             tb.error(this);
                         // remove currentForm from stack. will shift anything under up.
                         tb.removeFromStack(currentForm);
+                    } else { // template on stack
+                        if (!tb.inScope(name)) {
+                            tb.error(this);
+                            return false;
+                        }
+                        tb.generateImpliedEndTags();
+                        if (!tb.currentElementIs(name)) tb.error(this);
+                        tb.popStackToClose(name);
                     }
                     break;
                 case "p":
@@ -974,10 +1010,10 @@ enum HtmlTreeBuilderState {
                     }
                 } else if (name.equals("form")) {
                     tb.error(this);
-                    if (tb.getFormElement() != null)
+                    if (tb.getFormElement() != null || tb.onStack("template"))
                         return false;
                     else {
-                        tb.insertForm(startTag, false);
+                        tb.insertForm(startTag, false, false); // not added to stack. can associate to template
                     }
                 } else {
                     return anythingElse(t, tb);
@@ -998,6 +1034,8 @@ enum HtmlTreeBuilderState {
                 } else if (inSorted(name, InTableEndErr)) {
                     tb.error(this);
                     return false;
+                } else if (name.equals("template")) {
+                    tb.process(t, InHead);
                 } else {
                     return anythingElse(t, tb);
                 }
@@ -1106,22 +1144,32 @@ enum HtmlTreeBuilderState {
                         case "col":
                             tb.insertEmpty(startTag);
                             break;
+                        case "template":
+                            tb.process(t, InHead);
+                            break;
                         default:
                             return anythingElse(t, tb);
                     }
                     break;
                 case EndTag:
                     Token.EndTag endTag = t.asEndTag();
-                    if (endTag.normalName.equals("colgroup")) {
-                        if (tb.currentElementIs("html")) { // frag case
-                            tb.error(this);
-                            return false;
-                        } else {
-                            tb.pop();
-                            tb.transition(InTable);
-                        }
-                    } else
-                        return anythingElse(t, tb);
+                    String name = endTag.normalName();
+                    switch (name) {
+                        case "colgroup":
+                            if (!tb.currentElementIs(name)) {
+                                tb.error(this);
+                                return false;
+                            } else {
+                                tb.pop();
+                                tb.transition(InTable);
+                            }
+                            break;
+                        case "template":
+                            tb.process(t, InHead);
+                            break;
+                        default:
+                            return anythingElse(t, tb);
+                    }
                     break;
                 case EOF:
                     if (tb.currentElementIs("html"))
@@ -1134,10 +1182,14 @@ enum HtmlTreeBuilderState {
             return true;
         }
 
-        private boolean anythingElse(Token t, TreeBuilder tb) {
-            boolean processed = tb.processEndTag("colgroup");
-            if (processed) // only ignored in frag case
-                return tb.process(t);
+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
+            if (!tb.currentElementIs("colgroup")) {
+                tb.error(this);
+                return false;
+            }
+            tb.pop();
+            tb.transition(InTable);
+            tb.process(t);
             return true;
         }
     },
@@ -1147,9 +1199,7 @@ enum HtmlTreeBuilderState {
                 case StartTag:
                     Token.StartTag startTag = t.asStartTag();
                     String name = startTag.normalName();
-                    if (name.equals("template")) {
-                        tb.insert(startTag);
-                    } else if (name.equals("tr")) {
+                    if (name.equals("tr")) {
                         tb.clearStackToTableBodyContext();
                         tb.insert(startTag);
                         tb.transition(InRow);
@@ -1209,9 +1259,7 @@ enum HtmlTreeBuilderState {
                 Token.StartTag startTag = t.asStartTag();
                 String name = startTag.normalName();
 
-                if (name.equals("template")) {
-                    tb.insert(startTag);
-                } else if (inSorted(name, InCellNames)) {
+                if (inSorted(name, InCellNames)) {
                     tb.clearStackToTableRowContext();
                     tb.insert(startTag);
                     tb.transition(InCell);
@@ -1365,7 +1413,7 @@ enum HtmlTreeBuilderState {
                             return false; // frag
                         tb.processEndTag("select");
                         return tb.process(start);
-                    } else if (name.equals("script")) {
+                    } else if (name.equals("script") || name.equals("template")) {
                         return tb.process(t, InHead);
                     } else {
                         return anythingElse(t, tb);
@@ -1398,6 +1446,8 @@ enum HtmlTreeBuilderState {
                                 tb.resetInsertionMode();
                             }
                             break;
+                        case "template":
+                            return tb.process(t, InHead);
                         default:
                             return anythingElse(t, tb);
                     }
@@ -1419,12 +1469,12 @@ enum HtmlTreeBuilderState {
     },
     InSelectInTable {
         boolean process(Token t, HtmlTreeBuilder tb) {
-            if (t.isStartTag() && inSorted(t.asStartTag().normalName(), InSelecTableEnd)) {
+            if (t.isStartTag() && inSorted(t.asStartTag().normalName(), InSelectTableEnd)) {
                 tb.error(this);
                 tb.popStackToClose("select");
                 tb.resetInsertionMode();
                 return tb.process(t);
-            } else if (t.isEndTag() && inSorted(t.asEndTag().normalName(),InSelecTableEnd )) {
+            } else if (t.isEndTag() && inSorted(t.asEndTag().normalName(), InSelectTableEnd)) {
                 tb.error(this);
                 if (tb.inTableScope(t.asEndTag().normalName())) {
                     tb.popStackToClose("select");
@@ -1437,6 +1487,71 @@ enum HtmlTreeBuilderState {
             }
         }
     },
+    InTemplate {
+        boolean process(Token t, HtmlTreeBuilder tb) {
+            final String name;
+            switch (t.type) {
+                case Character:
+                case Comment:
+                case Doctype:
+                    tb.process(t, InBody);
+                    break;
+                case StartTag:
+                    name = t.asStartTag().normalName();
+                    if (inSorted(name, InTemplateToHead))
+                        tb.process(t, InHead);
+                    else if (inSorted(name, InTemplateToTable)) {
+                        tb.popTemplateMode();
+                        tb.pushTemplateMode(InTable);
+                        tb.transition(InTable);
+                        return tb.process(t);
+                    }
+                    else if (name.equals("col")) {
+                        tb.popTemplateMode();
+                        tb.pushTemplateMode(InColumnGroup);
+                        tb.transition(InColumnGroup);
+                        return tb.process(t);
+                    } else if (name.equals("tr")) {
+                        tb.popTemplateMode();
+                        tb.pushTemplateMode(InTableBody);
+                        tb.transition(InTableBody);
+                        return tb.process(t);
+                    } else if (name.equals("td") || name.equals("th")) {
+                        tb.popTemplateMode();
+                        tb.pushTemplateMode(InRow);
+                        tb.transition(InRow);
+                        return tb.process(t);
+                    } else {
+                        tb.popTemplateMode();
+                        tb.pushTemplateMode(InBody);
+                        tb.transition(InBody);
+                        return tb.process(t);
+                    }
+
+                    break;
+                case EndTag:
+                    name = t.asEndTag().normalName();
+                    if (name.equals("template"))
+                        tb.process(t, InHead);
+                    else {
+                        tb.error(this);
+                        return false;
+                    }
+                    break;
+                case EOF:
+                    if (!tb.onStack("template")) {// stop parsing
+                        return true;
+                    }
+                    tb.error(this);
+                    tb.popStackToClose("template");
+                    tb.clearFormattingElementsToLastMarker();
+                    tb.popTemplateMode();
+                    tb.resetInsertionMode();
+                    return tb.process(t);
+            }
+            return true;
+        }
+    },
     AfterBody {
         boolean process(Token t, HtmlTreeBuilder tb) {
             if (isWhitespace(t)) {
@@ -1623,10 +1738,10 @@ enum HtmlTreeBuilderState {
         static final String[] InHeadEmpty = new String[]{"base", "basefont", "bgsound", "command", "link"};
         static final String[] InHeadRaw = new String[]{"noframes", "style"};
         static final String[] InHeadEnd = new String[]{"body", "br", "html"};
-        static final String[] AfterHeadBody = new String[]{"body", "html"};
+        static final String[] AfterHeadBody = new String[]{"body", "br", "html"};
         static final String[] BeforeHtmlToHead = new String[]{"body", "br", "head", "html", };
         static final String[] InHeadNoScriptHead = new String[]{"basefont", "bgsound", "link", "meta", "noframes", "style"};
-        static final String[] InBodyStartToHead = new String[]{"base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "title"};
+        static final String[] InBodyStartToHead = new String[]{"base", "basefont", "bgsound", "command", "link", "meta", "noframes", "script", "style", "template", "title"};
         static final String[] InBodyStartPClosers = new String[]{"address", "article", "aside", "blockquote", "center", "details", "dir", "div", "dl",
             "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "menu", "nav", "ol",
             "p", "section", "summary", "ul"};
@@ -1646,7 +1761,7 @@ enum HtmlTreeBuilderState {
         static final String[] InBodyEndTableFosters = new String[]{"table", "tbody", "tfoot", "thead", "tr"};
         static final String[] InTableToBody = new String[]{"tbody", "tfoot", "thead"};
         static final String[] InTableAddBody = new String[]{"td", "th", "tr"};
-        static final String[] InTableToHead = new String[]{"script", "style"};
+        static final String[] InTableToHead = new String[]{"script", "style", "template"};
         static final String[] InCellNames = new String[]{"td", "th"};
         static final String[] InCellBody = new String[]{"body", "caption", "col", "colgroup", "html"};
         static final String[] InCellTable = new String[]{ "table", "tbody", "tfoot", "thead", "tr"};
@@ -1658,9 +1773,11 @@ enum HtmlTreeBuilderState {
         static final String[] InRowMissing = new String[]{"caption", "col", "colgroup", "tbody", "tfoot", "thead", "tr"};
         static final String[] InRowIgnore = new String[]{"body", "caption", "col", "colgroup", "html", "td", "th"};
         static final String[] InSelectEnd = new String[]{"input", "keygen", "textarea"};
-        static final String[] InSelecTableEnd = new String[]{"caption", "table", "tbody", "td", "tfoot", "th", "thead", "tr"};
+        static final String[] InSelectTableEnd = new String[]{"caption", "table", "tbody", "td", "tfoot", "th", "thead", "tr"};
         static final String[] InTableEndIgnore = new String[]{"tbody", "tfoot", "thead"};
         static final String[] InHeadNoscriptIgnore = new String[]{"head", "noscript"};
         static final String[] InCaptionIgnore = new String[]{"body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"};
+        static final String[] InTemplateToHead = new String[] {"base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"};
+        static final String[] InTemplateToTable = new String[] {"caption", "colgroup", "tbody", "tfoot", "thead"};
     }
 }
diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java
index 7bb84740..1f43ead4 100644
--- a/src/main/java/org/jsoup/parser/Tag.java
+++ b/src/main/java/org/jsoup/parser/Tag.java
@@ -237,7 +237,7 @@ public class Tag implements Cloneable {
             "ul", "ol", "pre", "div", "blockquote", "hr", "address", "figure", "figcaption", "form", "fieldset", "ins",
             "del", "dl", "dt", "dd", "li", "table", "caption", "thead", "tfoot", "tbody", "colgroup", "col", "tr", "th",
             "td", "video", "audio", "canvas", "details", "menu", "plaintext", "template", "article", "main",
-            "svg", "math", "center"
+            "svg", "math", "center", "template"
     };
     private static final String[] inlineTags = {
             "object", "base", "font", "tt", "i", "b", "u", "big", "small", "em", "strong", "dfn", "code", "samp", "kbd",
diff --git a/src/test/java/org/jsoup/parser/HtmlParserTest.java b/src/test/java/org/jsoup/parser/HtmlParserTest.java
index 95cf165f..59b25044 100644
--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java
@@ -1499,4 +1499,98 @@ public class HtmlParserTest {
         String out = doc.body().outerHtml();
         assertEquals("<body style=\"color: red\" name>\n <div></div>\n</body>", out);
     }
+
+    @Test void templateInHead() {
+        // https://try.jsoup.org/~EGp3UZxQe503TJDHQEQEzm8IeUc
+        String html = "<head><template id=1><meta name=tmpl></template><title>Test</title><style>One</style></head><body><p>Two</p>";
+        Document doc = Jsoup.parse(html);
+
+        String want = "<html><head><template id=\"1\"><meta name=\"tmpl\"></template><title>Test</title><style>One</style></head><body><p>Two</p></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+
+        Elements template = doc.select("template#1");
+        template.select("meta").attr("content", "Yes");
+        template.unwrap();
+
+        want = "<html><head><meta name=\"tmpl\" content=\"Yes\"><title>Test</title><style>One</style></head><body><p>Two</p></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+    }
+
+    @Test void nestedTemplateInBody() {
+        String html = "<body><template id=1><table><tr><template id=2><td>One</td><td>Two</td></template></tr></template></body>";
+        Document doc = Jsoup.parse(html);
+
+        String want = "<html><head></head><body><template id=\"1\"><table><tbody><tr><template id=\"2\"><td>One</td><td>Two</td></template></tr></tbody></table></template></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+
+        // todo - will be nice to add some simpler template element handling like clone children etc?
+        Element tmplTbl = doc.selectFirst("template#1");
+        Element tmplRow = doc.selectFirst("template#2");
+        assertNotNull(tmplRow);
+        assertNotNull(tmplTbl);
+        tmplRow.appendChild(tmplRow.clone());
+        doc.select("template").unwrap();
+
+        want = "<html><head></head><body><table><tbody><tr><td>One</td><td>Two</td><td>One</td><td>Two</td></tr></tbody></table></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+    }
+
+    @Test void canSelectIntoTemplate() {
+        String html = "<body><div><template><p>Hello</p>";
+        Document doc = Jsoup.parse(html);
+        String want = "<html><head></head><body><div><template><p>Hello</p></template></div></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+
+        Element p = doc.selectFirst("div p");
+        Element p1 = doc.selectFirst("template :containsOwn(Hello)");
+        assertEquals("p", p.normalName());
+        assertEquals(p, p1);
+    }
+
+    @Test void tableRowFragment() {
+        Document doc = Jsoup.parse("<body><table></table></body");
+        String html = "<tr><td><img></td></tr>";
+        Element table = doc.selectFirst("table");
+        table.html(html); // invokes the fragment parser with table as context
+        String want = "<tbody><tr><td><img></td></tr></tbody>";
+        assertEquals(want, TextUtil.stripNewlines(table.html()));
+        want = "<table><tbody><tr><td><img></td></tr></tbody></table>";
+        assertEquals(want, TextUtil.stripNewlines(doc.body().html()));
+    }
+
+    @Test void templateTableRowFragment() {
+        // https://github.com/jhy/jsoup/issues/1409 (per the fragment <tr> use case)
+        Document doc = Jsoup.parse("<body><table><template></template></table></body");
+        String html = "<tr><td><img></td></tr>";
+        Element tmpl = doc.selectFirst("template");
+        tmpl.html(html); // invokes the fragment parser with template as context
+        String want = "<tr><td><img></td></tr>";
+        assertEquals(want, TextUtil.stripNewlines(tmpl.html()));
+        tmpl.unwrap();
+
+        want = "<html><head></head><body><table><tr><td><img></td></tr></table></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+    }
+
+    @Test void templateNotInTableRowFragment() {
+        // https://github.com/jhy/jsoup/issues/1409 (per the fragment <tr> use case)
+        Document doc = Jsoup.parse("<body><template></template></body");
+        String html = "<tr><td><img></td></tr>";
+        Element tmpl = doc.selectFirst("template");
+        tmpl.html(html); // invokes the fragment parser with template as context
+        String want = "<tr><td><img></td></tr>";
+        assertEquals(want, TextUtil.stripNewlines(tmpl.html()));
+        tmpl.unwrap();
+
+        want = "<html><head></head><body><tr><td><img></td></tr></body></html>";
+        assertEquals(want, TextUtil.stripNewlines(doc.html()));
+    }
+
+    @Test void templateFragment() {
+        // https://github.com/jhy/jsoup/issues/1315
+        String html = "<template id=\"lorem-ipsum\"><tr><td>Lorem</td><td>Ipsum</td></tr></template>";
+        Document frag = Jsoup.parseBodyFragment(html);
+        String want = "<template id=\"lorem-ipsum\"><tr><td>Lorem</td><td>Ipsum</td></tr></template>";
+        assertEquals(want, TextUtil.stripNewlines(frag.body().html()));
+    }
 }
diff --git a/src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java b/src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
index 649340c3..29482c84 100644
--- a/src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlTreeBuilderStateTest.java
@@ -44,7 +44,7 @@ public class HtmlTreeBuilderStateTest {
     public void ensureArraysAreSorted() {
         List<Object[]> constants = findConstantArrays(Constants.class);
         ensureSorted(constants);
-        assertEquals(38, constants.size());
+        assertEquals(40, constants.size());
     }
 
 
diff --git a/src/test/java/org/jsoup/parser/HtmlTreeBuilderTest.java b/src/test/java/org/jsoup/parser/HtmlTreeBuilderTest.java
index 133af5fb..10e6c254 100644
--- a/src/test/java/org/jsoup/parser/HtmlTreeBuilderTest.java
+++ b/src/test/java/org/jsoup/parser/HtmlTreeBuilderTest.java
@@ -18,7 +18,7 @@ public class HtmlTreeBuilderTest {
     public void ensureSearchArraysAreSorted() {
         List<Object[]> constants = HtmlTreeBuilderStateTest.findConstantArrays(HtmlTreeBuilder.class);
         HtmlTreeBuilderStateTest.ensureSorted(constants);
-        assertEquals(7, constants.size());
+        assertEquals(8, constants.size());
     }
 
     @Test
