diff --git a/CHANGES.md b/CHANGES.md
index 20bf2ae6..ede98efd 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -13,6 +13,7 @@
 * When parsing from an InputStream and a multibyte character happened to straddle a buffer boundary, the stream would not be completely read. [#2353](https://github.com/jhy/jsoup/issues/2353).
 * In `NodeTraversor`, if a last child element was removed during the `head()` call, the parent would be visited twice. [#2355](https://github.com/jhy/jsoup/issues/2355).
 * Cloning an Element that has an Attributes object would add an empty internal user-data attribute to that clone, which would cause unexpected results for `Attributes#size()` and `Attributes#isEmpty()`. [#2356](https://github.com/jhy/jsoup/issues/2356)
+* In a multithreaded application where multiple threads are calling `Element#children()` on the same element concurrently, a race condition could happen when the method was generating the internal child element cache (a filtered view of its child nodes). Since concurrent reads of DOM objects should be threadsafe without external synchronization, this method has been updated to execute atomically. [#2366](https://github.com/jhy/jsoup/issues/2366)
 
 ## 1.21.1 (2025-Jun-23)
 
diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java
index f45088f1..054ab537 100644
--- a/src/main/java/org/jsoup/nodes/Element.java
+++ b/src/main/java/org/jsoup/nodes/Element.java
@@ -391,12 +391,15 @@ public class Element extends Node implements Iterable<Element> {
      */
     List<Element> childElementsList() {
         if (childNodeSize() == 0) return EmptyChildren; // short circuit creating empty
-        List<Element> children = cachedChildren();
-        if (children == null) {
-            children = filterNodes(Element.class);
-            stashChildren(children);
+        // set atomically, so works in multi-thread. Calling methods look like reads, so should be thread-safe
+        synchronized (childNodes) { // sync vs re-entrant lock, to save another field
+            List<Element> children = cachedChildren();
+            if (children == null) {
+                children = filterNodes(Element.class);
+                stashChildren(children);
+            }
+            return children;
         }
-        return children;
     }
 
     private static final String childElsKey = "jsoup.childEls";
diff --git a/src/test/java/org/jsoup/nodes/ElementIT.java b/src/test/java/org/jsoup/nodes/ElementIT.java
index 084c583f..849441c3 100644
--- a/src/test/java/org/jsoup/nodes/ElementIT.java
+++ b/src/test/java/org/jsoup/nodes/ElementIT.java
@@ -5,6 +5,8 @@ import org.jsoup.select.Elements;
 import org.junit.jupiter.api.Test;
 
 import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static org.junit.jupiter.api.Assertions.*;
 
@@ -183,4 +185,45 @@ public class ElementIT {
             t.join();
         }
     }
+
+    @Test
+    void concurrentChildren() throws InterruptedException {
+        int childCount = 200;
+
+        Document doc = Jsoup.parse("<div></div>");
+        Element div = doc.expectFirst("div");
+        for (int i = 0; i < childCount; i++) {
+            div.appendElement("p").after("Some text");
+        }
+
+        int threadCount = 100;
+        int iterCount = 10000;
+        CountDownLatch startLatch = new CountDownLatch(1);
+        CountDownLatch endLatch = new CountDownLatch(threadCount);
+        AtomicReference<Throwable> failure = new AtomicReference<>();
+
+        for (int i = 0; i < threadCount; i++) {
+            Thread t = new Thread(() -> {
+                try {
+                    startLatch.await();
+                    for (int j = 0; j < iterCount; j++) {
+                        Elements children = div.children();
+                        assertEquals(childCount, children.size());
+                    }
+                } catch (Throwable e) {
+                    System.err.println(e);
+                    failure.set(e);
+                } finally {
+                    endLatch.countDown();
+                }
+            });
+            t.start();
+        }
+
+        startLatch.countDown();
+        endLatch.await();
+        if (failure.get() != null) {
+            throw new AssertionError(failure.get());
+        }
+    }
 }
