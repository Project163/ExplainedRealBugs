diff --git a/CHANGES b/CHANGES
index 207db684..56d9f6e1 100644
--- a/CHANGES
+++ b/CHANGES
@@ -23,6 +23,10 @@ jsoup changelog
     Improves the HTML adoption agency algorithm when adopting elements with many children.
     <https://github.com/jhy/jsoup/issues/1638>
 
+  * Improvement: increased the parse speed when in RCData (e.g. <title>) and unescaped <tag> tokens are found, by
+    memoizing the </title> scan and reducing GC.
+    <https://github.com/jhy/jsoup/issues/1644>
+
   * Bugfix: when tracking errors or checking for validity in the Cleaner, errors were incorrectly raised for missing
     optional closing tags.
 
diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java
index af27c7aa..605b1997 100644
--- a/src/main/java/org/jsoup/parser/CharacterReader.java
+++ b/src/main/java/org/jsoup/parser/CharacterReader.java
@@ -104,7 +104,8 @@ public final class CharacterReader {
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
-        scanBufferForNewlines();
+        scanBufferForNewlines(); // if enabled, we index newline positions for line number tracking
+        lastIcSeq = null; // cache for last containsIgnoreCase(seq)
     }
 
     /**
@@ -656,11 +657,31 @@ public final class CharacterReader {
         }
     }
 
+    // we maintain a cache of the previously scanned sequence, and return that if applicable on repeated scans.
+    // that improves the situation where there is a sequence of <p<p<p<p<p<p<p...</title> and we're bashing on the <p
+    // looking for the </title>. Resets in bufferUp()
+    @Nullable private String lastIcSeq; // scan cache
+    private int lastIcIndex; // nearest found indexOf
+
+    /** Used to check presence of </title>, </style> when we're in RCData and see a <xxx. Only finds consistent case. */
     boolean containsIgnoreCase(String seq) {
-        // used to check presence of </title>, </style>. only finds consistent case.
+        if (seq.equals(lastIcSeq)) {
+            if (lastIcIndex == -1) return false;
+            if (lastIcIndex >= bufPos) return true;
+        }
+        lastIcSeq = seq;
+
         String loScan = seq.toLowerCase(Locale.ENGLISH);
+        int lo = nextIndexOf(loScan);
+        if (lo > -1) {
+            lastIcIndex = bufPos + lo; return true;
+        }
+
         String hiScan = seq.toUpperCase(Locale.ENGLISH);
-        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);
+        int hi = nextIndexOf(hiScan);
+        boolean found = hi > -1;
+        lastIcIndex = found ? bufPos + hi : -1; // we don't care about finding the nearest, just that buf contains
+        return found;
     }
 
     @Override
diff --git a/src/main/java/org/jsoup/parser/Tokeniser.java b/src/main/java/org/jsoup/parser/Tokeniser.java
index d8d9a7b9..1ebf0871 100644
--- a/src/main/java/org/jsoup/parser/Tokeniser.java
+++ b/src/main/java/org/jsoup/parser/Tokeniser.java
@@ -47,6 +47,7 @@ final class Tokeniser {
     Token.Doctype doctypePending = new Token.Doctype(); // doctype building up
     Token.Comment commentPending = new Token.Comment(); // comment building up
     private String lastStartTag; // the last start tag emitted, to test appropriate end tag
+    @Nullable private String lastStartCloseSeq; // "</" + lastStartTag, so we can quickly check for that in RCData
 
     Tokeniser(CharacterReader reader, ParseErrorList errors) {
         this.reader = reader;
@@ -84,6 +85,7 @@ final class Tokeniser {
         if (token.type == Token.TokenType.StartTag) {
             Token.StartTag startTag = (Token.StartTag) token;
             lastStartTag = startTag.tagName;
+            lastStartCloseSeq = null; // only lazy inits
         } else if (token.type == Token.TokenType.EndTag) {
             Token.EndTag endTag = (Token.EndTag) token;
             if (endTag.hasAttributes())
@@ -274,6 +276,13 @@ final class Tokeniser {
         return lastStartTag; // could be null
     }
 
+    /** Returns the closer sequence {@code </lastStart} */
+    String appropriateEndTagSeq() {
+        if (lastStartCloseSeq == null) // reset on start tag emit
+            lastStartCloseSeq = "</" + lastStartTag;
+        return lastStartCloseSeq;
+    }
+
     void error(TokeniserState state) {
         if (errors.canAddError())
             errors.add(new ParseError(reader, "Unexpected character '%s' in input state [%s]", reader.current(), state));
diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java
index 2907ad59..acc8db35 100644
--- a/src/main/java/org/jsoup/parser/TokeniserState.java
+++ b/src/main/java/org/jsoup/parser/TokeniserState.java
@@ -186,7 +186,7 @@ enum TokeniserState {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
-            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase("</" + t.appropriateEndTagName())) {
+            } else if (r.matchesAsciiAlpha() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(t.appropriateEndTagSeq())) {
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
                 t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());
diff --git a/src/test/java/org/jsoup/parser/CharacterReaderTest.java b/src/test/java/org/jsoup/parser/CharacterReaderTest.java
index a362b1e6..d9f22801 100644
--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java
+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java
@@ -220,6 +220,43 @@ public class CharacterReaderTest {
         assertFalse(r.containsIgnoreCase("one"));
     }
 
+    @Test void containsIgnoreCaseBuffer() {
+        String html = "<p><p><p></title><p></TITLE><p>" + BufferBuster("Foo Bar Qux ") + "<foo><bar></title>";
+        CharacterReader r = new CharacterReader(html);
+
+        assertTrue(r.containsIgnoreCase("</title>"));
+        assertFalse(r.containsIgnoreCase("</not>"));
+        assertFalse(r.containsIgnoreCase("</not>")); // cached, but we only test functionally here
+        assertTrue(r.containsIgnoreCase("</title>"));
+        r.consumeTo("</title>");
+        assertTrue(r.containsIgnoreCase("</title>"));
+        r.consumeTo("<p>");
+        assertTrue(r.matches("<p>"));
+
+        assertTrue(r.containsIgnoreCase("</title>"));
+        assertTrue(r.containsIgnoreCase("</title>"));
+        assertFalse(r.containsIgnoreCase("</not>"));
+        assertFalse(r.containsIgnoreCase("</not>"));
+
+        r.consumeTo("</TITLE>");
+        r.consumeTo("<p>");
+        assertTrue(r.matches("<p>"));
+        assertFalse(r.containsIgnoreCase("</title>")); // because we haven't buffered up yet, we don't know
+        r.consumeTo("<foo>");
+        assertFalse(r.matches("<foo>")); // buffer underrun
+        r.consumeTo("<foo>");
+        assertTrue(r.matches("<foo>")); // cross the buffer
+        assertTrue(r.containsIgnoreCase("</TITLE>"));
+        assertTrue(r.containsIgnoreCase("</title>"));
+    }
+
+    static String BufferBuster(String content) {
+        StringBuilder builder = new StringBuilder();
+        while (builder.length() < maxBufferLen)
+            builder.append(content);
+        return builder.toString();
+    }
+
     @Test public void matchesAny() {
         char[] scan = {' ', '\n', '\t'};
         CharacterReader r = new CharacterReader("One\nTwo\tThree");
diff --git a/src/test/resources/fuzztests/1644.html.gz b/src/test/resources/fuzztests/1644.html.gz
new file mode 100644
index 00000000..e4bce4e2
Binary files /dev/null and b/src/test/resources/fuzztests/1644.html.gz differ
diff --git a/src/test/resources/fuzztests/39164.html b/src/test/resources/fuzztests/39164.html
deleted file mode 100644
index 10899556..00000000
Binary files a/src/test/resources/fuzztests/39164.html and /dev/null differ
diff --git a/src/test/resources/fuzztests/39164.html.gz b/src/test/resources/fuzztests/39164.html.gz
new file mode 100644
index 00000000..50fd9f96
Binary files /dev/null and b/src/test/resources/fuzztests/39164.html.gz differ
