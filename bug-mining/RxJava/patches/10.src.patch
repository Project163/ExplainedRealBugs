diff --git a/rxjava-core/src/main/java/rx/Observable.java b/rxjava-core/src/main/java/rx/Observable.java
index 1d84a4cdb..9f88e15fd 100644
--- a/rxjava-core/src/main/java/rx/Observable.java
+++ b/rxjava-core/src/main/java/rx/Observable.java
@@ -5182,6 +5182,10 @@ public class Observable<T> {
     public final <R> Observable<R> map(Func1<? super T, ? extends R> func) {
         return lift(new OperatorMap<T, R>(func));
     }
+    
+    private final <R> Observable<R> mapNotification(Func1<? super T, ? extends R> onNext, Func1<? super Throwable, ? extends R> onError, Func0<? extends R> onCompleted) {
+        return lift(new OperatorMapNotification<T, R>(onNext, onError, onCompleted));
+    }
 
     /**
      * Returns an Observable that represents all of the emissions <em>and</em> notifications from the source
@@ -5254,7 +5258,7 @@ public class Observable<T> {
             Func1<? super T, ? extends Observable<? extends R>> onNext,
             Func1<? super Throwable, ? extends Observable<? extends R>> onError,
             Func0<? extends Observable<? extends R>> onCompleted) {
-        return lift(new OperatorMergeMapTransform<T, R>(onNext, onError, onCompleted));
+        return merge(mapNotification(onNext, onError, onCompleted));
     }
 
     /**
diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMapNotification.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMapNotification.java
new file mode 100644
index 000000000..02d9b1fd2
--- /dev/null
+++ b/rxjava-core/src/main/java/rx/internal/operators/OperatorMapNotification.java
@@ -0,0 +1,78 @@
+/**
+ * Copyright 2014 Netflix, Inc.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package rx.internal.operators;
+
+import rx.Observable.Operator;
+import rx.Subscriber;
+import rx.exceptions.OnErrorThrowable;
+import rx.functions.Func0;
+import rx.functions.Func1;
+
+/**
+ * Applies a function of your choosing to every item emitted by an {@code Observable}, and emits the results of
+ * this transformation as a new {@code Observable}.
+ * <p>
+ * <img width="640" height="305" src="https://raw.githubusercontent.com/wiki/Netflix/RxJava/images/rx-operators/map.png" alt="">
+ */
+public final class OperatorMapNotification<T, R> implements Operator<R, T> {
+
+    private final Func1<? super T, ? extends R> onNext;
+    private final Func1<? super Throwable, ? extends R> onError;
+    private final Func0<? extends R> onCompleted;
+
+    public OperatorMapNotification(Func1<? super T, ? extends R> onNext, Func1<? super Throwable, ? extends R> onError, Func0<? extends R> onCompleted) {
+        this.onNext = onNext;
+        this.onError = onError;
+        this.onCompleted = onCompleted;
+    }
+
+    @Override
+    public Subscriber<? super T> call(final Subscriber<? super R> o) {
+        return new Subscriber<T>(o) {
+
+            @Override
+            public void onCompleted() {
+                try {
+                    o.onNext(onCompleted.call());
+                    o.onCompleted();
+                } catch (Throwable e) {
+                    o.onError(e);
+                }
+            }
+
+            @Override
+            public void onError(Throwable e) {
+                try {
+                    o.onNext(onError.call(e));
+                    o.onCompleted();
+                } catch (Throwable e2) {
+                    o.onError(e);
+                }
+            }
+
+            @Override
+            public void onNext(T t) {
+                try {
+                    o.onNext(onNext.call(t));
+                } catch (Throwable e) {
+                    o.onError(OnErrorThrowable.addValueAsLastCause(e, t));
+                }
+            }
+
+        };
+    }
+
+}
diff --git a/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeMapTransform.java b/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeMapTransform.java
deleted file mode 100644
index d1a2394eb..000000000
--- a/rxjava-core/src/main/java/rx/internal/operators/OperatorMergeMapTransform.java
+++ /dev/null
@@ -1,151 +0,0 @@
- /**
-  * Copyright 2014 Netflix, Inc.
-  *
-  * Licensed under the Apache License, Version 2.0 (the "License"); you may not
-  * use this file except in compliance with the License. You may obtain a copy of
-  * the License at
-  *
-  * http://www.apache.org/licenses/LICENSE-2.0
-  *
-  * Unless required by applicable law or agreed to in writing, software
-  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
-  * License for the specific language governing permissions and limitations under
-  * the License.
-  */
-package rx.internal.operators;
-
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import rx.Observable;
-import rx.Observable.Operator;
-import rx.Subscriber;
-import rx.functions.Func0;
-import rx.functions.Func1;
-import rx.observers.SerializedSubscriber;
-import rx.subscriptions.CompositeSubscription;
-
-/**
- * Projects the notification of an observable sequence to an observable
- * sequence and merges the results into one.
- *
- * @param <T> the input value type
- * @param <R> the output value type
- */
-public final class OperatorMergeMapTransform<T, R> implements Operator<R, T> {
-    final Func1<? super T, ? extends Observable<? extends R>> onNext;
-    final Func1<? super Throwable, ? extends Observable<? extends R>> onError;
-    final Func0<? extends Observable<? extends R>> onCompleted;
-    
-    public OperatorMergeMapTransform(Func1<? super T, ? extends Observable<? extends R>> onNext,
-            Func1<? super Throwable, ? extends Observable<? extends R>> onError,
-            Func0<? extends Observable<? extends R>> onCompleted) {
-        this.onNext = onNext;
-        this.onError = onError;
-        this.onCompleted = onCompleted;
-    }
-    
-    @Override
-    public Subscriber<? super T> call(Subscriber<? super R> child) {
-        final SerializedSubscriber<R> s = new SerializedSubscriber<R>(child);
-        final CompositeSubscription csub = new CompositeSubscription();
-        child.add(csub);
-        
-        return new SourceSubscriber<T, R>(s, csub, onNext, onError, onCompleted);
-    }
-    static final class SourceSubscriber<T, R> extends Subscriber<T> {
-        final Subscriber<R> s;
-        final CompositeSubscription csub;
-        final Func1<? super T, ? extends Observable<? extends R>> onNext;
-        final Func1<? super Throwable, ? extends Observable<? extends R>> onError;
-        final Func0<? extends Observable<? extends R>> onCompleted;
-        
-        volatile int wip;
-        @SuppressWarnings("rawtypes")
-        static final AtomicIntegerFieldUpdater<SourceSubscriber> WIP_UPDATER
-                = AtomicIntegerFieldUpdater.newUpdater(SourceSubscriber.class, "wip");
-        
-        public SourceSubscriber(Subscriber<R> s, CompositeSubscription csub, Func1<? super T, ? extends Observable<? extends R>> onNext, Func1<? super Throwable, ? extends Observable<? extends R>> onError, Func0<? extends Observable<? extends R>> onCompleted) {
-            super(s);
-            this.s = s;
-            this.csub = csub;
-            this.onNext = onNext;
-            this.onError = onError;
-            this.onCompleted = onCompleted;
-            this.wip = 1;
-        }
-        
-        @Override
-        public void onNext(T t) {
-            Observable<? extends R> o;
-            try {
-                o = onNext.call(t);
-            } catch (Throwable e) {
-                error(e);
-                return;
-            }
-            subscribeTo(o);
-        }
-        
-        @Override
-        public void onError(Throwable e) {
-            Observable<? extends R> o;
-            try {
-                o = onError.call(e);
-            } catch (Throwable t) {
-                error(t);
-                return;
-            }
-            subscribeTo(o);
-            finish();
-        }
-        
-        @Override
-        public void onCompleted() {
-            Observable<? extends R> o;
-            try {
-                o = onCompleted.call();
-            } catch (Throwable e) {
-                error(e);
-                return;
-            }
-            subscribeTo(o);
-            finish();
-        }
-        void finish() {
-            if (WIP_UPDATER.decrementAndGet(this) == 0) {
-                s.onCompleted();
-            }
-        }
-        void error(Throwable t) {
-            s.onError(t);
-            unsubscribe();
-        }
-        void subscribeTo(Observable<? extends R> o) {
-            Subscriber<R> oSub = new Subscriber<R>() {
-                
-                @Override
-                public void onNext(R t) {
-                    s.onNext(t);
-                }
-                
-                @Override
-                public void onError(Throwable e) {
-                    error(e);
-                }
-                
-                @Override
-                public void onCompleted() {
-                    try {
-                        finish();
-                    } finally {
-                        csub.remove(this);
-                    }
-                }
-            };
-            csub.add(oSub);
-            WIP_UPDATER.incrementAndGet(this);
-            
-            o.unsafeSubscribe(oSub);
-        }
-    }
-}
