diff --git a/fontbox/src/main/java/org/apache/fontbox/cmap/CIDRange.java b/fontbox/src/main/java/org/apache/fontbox/cmap/CIDRange.java
index dbdf9329ff..04c8d31ba0 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cmap/CIDRange.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cmap/CIDRange.java
@@ -23,30 +23,68 @@ package org.apache.fontbox.cmap;
 class CIDRange
 {
 
-    private final char from;
+    private final int from;
+    private int to;
+    private final int unicode;
+    private final int codeLength;
 
-    private char to;
-
-    private final int cid;
-
-    CIDRange(char from, char to, int cid)
+    /**
+     * Constructor.
+     * 
+     * @param from       start value of COD range
+     * @param to         end value of CID range
+     * @param unicode        unicode start value
+     * @param codeLength byte length of CID values
+     */
+    CIDRange(int from, int to, int unicode, int codeLength)
     {
         this.from = from;
         this.to = to;
-        this.cid = cid;
+        this.unicode = unicode;
+        this.codeLength = codeLength;
+    }
+
+    /**
+     * Returns the byte length of the codes of the CID range.
+     * 
+     * @return the code length
+     */
+    public int getCodeLength()
+    {
+        return codeLength;
+    }
+
+    /**
+     * Maps the given Unicode character to the corresponding CID in this range.
+     *
+     * @param bytes Unicode character
+     * @return corresponding CID, or -1 if the character is out of range
+     */
+    public int map(byte[] bytes)
+    {
+        if (bytes.length == codeLength)
+        {
+            int ch = CMap.toInt(bytes);
+            if (from <= ch && ch <= to)
+            {
+                return unicode + (ch - from);
+            }
+        }
+        return -1;
     }
 
     /**
      * Maps the given Unicode character to the corresponding CID in this range.
      *
-     * @param ch Unicode character
+     * @param code   Unicode character
+     * @param length origin byte length of the code
      * @return corresponding CID, or -1 if the character is out of range
      */
-    public int map(char ch)
+    public int map(int code, int length)
     {
-        if (from <= ch && ch <= to)
+        if (length == codeLength && from <= code && code <= to)
         {
-            return cid + (ch - from);
+            return unicode + (code - from);
         }
         return -1;
     }
@@ -59,25 +97,26 @@ class CIDRange
      */
     public int unmap(int code)
     {
-        if (cid <= code && code <= cid + (to - from))
+        if (unicode <= code && code <= unicode + (to - from))
         {
-            return from + (code - cid);
+            return from + (code - unicode);
         }
         return -1;
     }
 
     /**
-     * Check if the given values represent a consecutive range of the given range. If so, extend the given range instead
-     * of creating a new one.
+     * Check if the given values represent a consecutive range of the given range. If so, extend the given range instead of
+     * creating a new one.
      * 
      * @param newFrom start value of the new range
-     * @param newTo end value of the new range
-     * @param newCid start CID value of the range
+     * @param newTo   end value of the new range
+     * @param newCid  start CID value of the range
+     * @param length  byte length of CIDs
      * @return true if the given range was extended
      */
-    public boolean extend(char newFrom, char newTo, int newCid)
+    public boolean extend(int newFrom, int newTo, int newCid, int length)
     {
-        if ((newFrom == to + 1) && (newCid == cid + to - from + 1))
+        if (codeLength == length && (newFrom == to + 1) && (newCid == unicode + to - from + 1))
         {
             to = newTo;
             return true;
diff --git a/fontbox/src/main/java/org/apache/fontbox/cmap/CMap.java b/fontbox/src/main/java/org/apache/fontbox/cmap/CMap.java
index baf935c54a..bcd5298f1e 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cmap/CMap.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cmap/CMap.java
@@ -22,6 +22,8 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
+
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
@@ -46,14 +48,21 @@ public class CMap
     private int minCodeLength = 4;
     private int maxCodeLength;
 
+    private int minCidLength = 4;
+    private int maxCidLength = 0;
+
     // code lengths
     private final List<CodespaceRange> codespaceRanges = new ArrayList<>();
 
     // Unicode mappings
-    private final Map<Integer,String> charToUnicode = new HashMap<>();
+    // one byte input values
+    private final Map<Integer, String> charToUnicodeOneByte = new HashMap<>();
+    // two byte input values
+    private final Map<Integer, String> charToUnicodeTwoBytes = new HashMap<>();
 
     // CID mappings
-    private final Map<Integer,Integer> codeToCid = new HashMap<>();
+    // map with all code to cid mappings organized by the origin byte length of the input value
+    private final Map<Integer, Map<Integer, Integer>> codeToCid = new HashMap<>();
     private final List<CIDRange> codeToCidRanges = new ArrayList<>();
 
     private static final String SPACE = " ";
@@ -83,23 +92,66 @@ public class CMap
      */
     public boolean hasUnicodeMappings()
     {
-        return !charToUnicode.isEmpty();
+        return !charToUnicodeOneByte.isEmpty() || !charToUnicodeTwoBytes.isEmpty();
     }
 
     /**
      * Returns the sequence of Unicode characters for the given character code.
      *
+     * This method exists for convenience. It may return false values as the origin byte length of the input value is
+     * unknown and the mapping for some input values aren't unique. <br>
+     * Example:<br>
+     * The two byte value 0x00, 0x65 maps to 0x20 <br>
+     * An input value of 0x65 always returns 0x20 even if the value has an origin byte length of 1.
+     *
      * @param code character code
      * @return Unicode characters (may be more than one, e.g "fi" ligature)
      */
     public String toUnicode(int code)
     {
-        return charToUnicode.get(code);
+        String unicode = code < 256 ? toUnicode(code, 1) : null;
+        if (unicode == null)
+        {
+            unicode = toUnicode(code, 2);
+        }
+        return unicode;
+    }
+
+    /**
+     * Returns the sequence of Unicode characters for the given character code.
+     *
+     * @param code character code
+     * @return Unicode characters (may be more than one, e.g "fi" ligature)
+     */
+    public String toUnicode(int code, int length)
+    {
+        if (length == 1)
+        {
+            return charToUnicodeOneByte.get(code);
+        }
+        if (length == 2)
+        {
+            return charToUnicodeTwoBytes.get(code);
+        }
+        LOG.warn("Mappings with more than 2 bytes aren't supported");
+        return null;
+    }
+
+    /**
+     * Returns the sequence of Unicode characters for the given character code.
+     *
+     * @param code bytes of the character code
+     * @return Unicode characters (may be more than one, e.g "fi" ligature)
+     */
+    public String toUnicode(byte[] code)
+    {
+        return toUnicode(toInt(code), code.length);
     }
 
     /**
      * Reads a character code from a string in the content stream.
-     * <p>See "CMap Mapping" and "Handling Undefined Characters" in PDF32000 for more details.
+     * <p>
+     * See "CMap Mapping" and "Handling Undefined Characters" in PDF32000 for more details.
      *
      * @param in string stream
      * @return character code
@@ -112,25 +164,25 @@ public class CMap
         in.mark(maxCodeLength);
         for (int i = minCodeLength-1; i < maxCodeLength; i++)
         {
-            final int byteCount = i+1;
-            for (CodespaceRange range : codespaceRanges)
+            final int byteCount = i + 1;
+            if (codespaceRanges.stream().anyMatch(r -> r.isFullMatch(bytes, byteCount)))
             {
-                if (range.isFullMatch(bytes, byteCount))
-                {
-                    return toInt(bytes, byteCount);
-                }
+                return toInt(bytes, byteCount);
             }
             if (byteCount < maxCodeLength)
             {
                 bytes[byteCount] = (byte)in.read();
             }
         }
-        String seq = "";
-        for (int i = 0; i < maxCodeLength; ++i)
+        if (LOG.isWarnEnabled())
         {
-            seq += String.format("0x%02X (%04o) ", bytes[i], bytes[i]);
+            String seq = "";
+            for (int i = 0; i < maxCodeLength; ++i)
+            {
+                seq += String.format("0x%02X (%04o) ", bytes[i], bytes[i]);
+            }
+            LOG.warn("Invalid character code sequence " + seq + "in CMap " + cmapName);
         }
-        LOG.warn("Invalid character code sequence " + seq + "in CMap " + cmapName);
         // PDFBOX-4811 reposition to where we were after initial read
         if (in.markSupported())
         {
@@ -147,7 +199,15 @@ public class CMap
     /**
      * Returns an int for the given byte array
      */
-    static int toInt(byte[] data, int dataLen)
+    static int toInt(byte[] data)
+    {
+        return toInt(data, data.length);
+    }
+
+    /**
+     * Returns an int for the given byte array
+     */
+    private static int toInt(byte[] data, int dataLen)
     {
         int code = 0;
         for (int i = 0; i < dataLen; ++i)
@@ -161,19 +221,107 @@ public class CMap
     /**
      * Returns the CID for the given character code.
      *
+     * @param code character code as byte array
+     * @return CID
+     */
+    public int toCID(byte[] code)
+    {
+        if (!hasCIDMappings() || code.length < minCidLength || code.length > maxCidLength)
+        {
+            return 0;
+        }
+        Integer cid = null;
+        if (codeToCid.containsKey(code.length))
+        {
+            cid = codeToCid.get(code.length).get(toInt(code));
+        }
+        if (cid == null)
+        {
+            cid = toCIDFromRanges(code);
+        }
+        return cid;
+    }
+
+    /**
+     * Returns the CID for the given character code.
+     * 
+     * This method exists for convenience. It may return false values as the origin byte length of the input value is
+     * unknown and the mapping for some input values aren't unique. <br>
+     * Example:<br>
+     * The two byte value 0x00, 0x65 maps to 0x20 <br>
+     * An input value of 0x65 always returns 0x20 even if the value has an origin byte length of 1.
+     *
      * @param code character code
      * @return CID
      */
     public int toCID(int code)
     {
-        Integer cid = codeToCid.get(code);
-        if (cid != null)
+        if (!hasCIDMappings())
         {
-            return cid;
+            return 0;
         }
+        Integer cid = 0;
+        int length = minCidLength;
+        while (cid == 0 && (length <= maxCidLength))
+        {
+            cid = toCID(code, length++);
+        }
+        return cid;
+    }
+
+    /**
+     * Returns the CID for the given character code.
+     *
+     * @param code   character code
+     * @param length the origin byte length of the code
+     * @return CID
+     */
+    public int toCID(int code, int length)
+    {
+        if (!hasCIDMappings() || length < minCidLength || length > maxCidLength)
+        {
+            return 0;
+        }
+        Integer cid = null;
+        if (codeToCid.containsKey(length))
+        {
+            cid = codeToCid.get(length).get(code);
+        }
+        return cid != null ? cid : toCIDFromRanges(code, length);
+    }
+
+    /**
+     * Returns the CID for the given character code.
+     *
+     * @param code character code
+     * @return CID
+     */
+
+    private int toCIDFromRanges(int code, int length)
+    {
         for (CIDRange range : codeToCidRanges)
         {
-            int ch = range.map((char)code);
+            int ch = range.map(code, length);
+            if (ch != -1)
+            {
+                return ch;
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * Returns the CID for the given character code.
+     *
+     * @param code character code
+     * @return CID
+     */
+
+    private int toCIDFromRanges(byte[] code)
+    {
+        for (CIDRange range : codeToCidRanges)
+        {
+            int ch = range.map(code);
             if (ch != -1)
             {
                 return ch;
@@ -184,7 +332,8 @@ public class CMap
 
     /**
      * Convert the given part of a byte array to an integer.
-     * @param data the byte array
+     * 
+     * @param data   the byte array
      * @param offset The offset into the byte array.
      * @param length The length of the data we are getting.
      * @return the resulting integer
@@ -209,8 +358,18 @@ public class CMap
     void addCharMapping(byte[] codes, String unicode)
     {
         int code = getCodeFromArray(codes, 0, codes.length);
-        charToUnicode.put(code, unicode);
-
+        if (codes.length == 1)
+        {
+            charToUnicodeOneByte.put(code, unicode);
+        }
+        else if (codes.length == 2)
+        {
+            charToUnicodeTwoBytes.put(code, unicode);
+        }
+        else
+        {
+            LOG.warn("Mappings with more than 2 bytes aren't supported yet");
+        }
         // fixme: ugly little hack
         if (SPACE.equals(unicode))
         {
@@ -224,9 +383,17 @@ public class CMap
      * @param code character code
      * @param cid CID
      */
-    void addCIDMapping(int code, int cid)
+    void addCIDMapping(byte[] code, int cid)
     {
-        codeToCid.put(cid, code);
+        Map<Integer, Integer> codeToCidMap = codeToCid.get(code.length);
+        if (codeToCidMap == null)
+        {
+            codeToCidMap = new HashMap<>();
+            codeToCid.put(code.length, codeToCidMap);
+            minCidLength = Math.min(minCidLength, code.length);
+            maxCidLength = Math.max(maxCidLength, code.length);
+        }
+        codeToCidMap.put(toInt(code), cid);
     }
 
     /**
@@ -237,16 +404,23 @@ public class CMap
      * @param cid the cid to be started with.
      *
      */
-    void addCIDRange(char from, char to, int cid)
+    void addCIDRange(byte[] from, byte[] to, int cid)
+    {
+        addCIDRange(codeToCidRanges, toInt(from), toInt(to), cid, from.length);
+    }
+
+    private void addCIDRange(List<CIDRange> cidRanges, int from, int to, int cid, int length)
     {
         CIDRange lastRange = null;
-        if (!codeToCidRanges.isEmpty())
+        if (!cidRanges.isEmpty())
         {
-            lastRange = codeToCidRanges.get(codeToCidRanges.size() - 1);
+            lastRange = cidRanges.get(cidRanges.size() - 1);
         }
-        if (lastRange == null || !lastRange.extend(from, to, cid))
+        if (lastRange == null || !lastRange.extend(from, to, cid, length))
         {
-            codeToCidRanges.add(new CIDRange(from, to, cid));
+            cidRanges.add(new CIDRange(from, to, cid, length));
+            minCidLength = Math.min(minCidLength, length);
+            maxCidLength = Math.max(maxCidLength, length);
         }
     }
 
@@ -271,9 +445,24 @@ public class CMap
     void useCmap(CMap cmap)
     {
         cmap.codespaceRanges.forEach(this::addCodespaceRange);
-        charToUnicode.putAll(cmap.charToUnicode);
-        codeToCid.putAll(cmap.codeToCid);
+        charToUnicodeOneByte.putAll(cmap.charToUnicodeOneByte);
+        charToUnicodeTwoBytes.putAll(cmap.charToUnicodeTwoBytes);
+        for (Entry<Integer, Map<Integer, Integer>> map : cmap.codeToCid.entrySet())
+        {
+            if (codeToCid.containsKey(map.getKey()))
+            {
+                codeToCid.get(map.getKey()).putAll(map.getValue());
+            }
+            else
+            {
+                codeToCid.put(map.getKey(), map.getValue());
+            }
+        }
         codeToCidRanges.addAll(cmap.codeToCidRanges);
+        maxCodeLength = Math.max(maxCodeLength, cmap.maxCodeLength);
+        minCodeLength = Math.min(minCodeLength, cmap.minCodeLength);
+        maxCidLength = Math.max(maxCidLength, cmap.maxCidLength);
+        minCidLength = Math.min(minCidLength, cmap.minCidLength);
     }
 
     /**
diff --git a/fontbox/src/main/java/org/apache/fontbox/cmap/CMapParser.java b/fontbox/src/main/java/org/apache/fontbox/cmap/CMapParser.java
index ec5a8d703a..7e33636cdd 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cmap/CMapParser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cmap/CMapParser.java
@@ -23,6 +23,7 @@ import java.io.InputStream;
 import java.io.PushbackInputStream;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -289,32 +290,24 @@ public class CMapParser
                 break;
             }
             byte[] startCode = (byte[]) nextToken;
-            int start = createIntFromBytes(startCode);
             byte[] endCode = (byte[]) parseNextToken(cmapStream);
-            int end = createIntFromBytes(endCode);
             int mappedCode = (Integer) parseNextToken(cmapStream);
-            if (startCode.length <= 2 && endCode.length <= 2)
+            if (startCode.length == endCode.length)
             {
                 // some CMaps are using CID ranges to map single values
-                if (end == start)
+                if (Arrays.equals(startCode, endCode))
                 {
-                    result.addCIDMapping(mappedCode, start);
+                    result.addCIDMapping(startCode, mappedCode);
                 }
                 else
                 {
-                    result.addCIDRange((char) start, (char) end, mappedCode);
+                    result.addCIDRange(startCode, endCode, mappedCode);
                 }
             }
             else
             {
-                // TODO Is this even possible?
-                int endOfMappings = mappedCode + end - start;
-                while (mappedCode <= endOfMappings)
-                {
-                    int mappedCID = createIntFromBytes(startCode);
-                    result.addCIDMapping(mappedCode++, mappedCID);
-                    increment(startCode);
-                }
+                throw new IOException(
+                        "Error : ~cidrange values must not have different byte lengths");
             }
         }
     }
@@ -334,9 +327,8 @@ public class CMapParser
                 break;
             }
             byte[] inputCode = (byte[]) nextToken;
-            int mappedCode = (Integer) parseNextToken(cmapStream);
-            int mappedCID = createIntFromBytes(inputCode);
-            result.addCIDMapping(mappedCode, mappedCID);
+            int mappedCID = (Integer) parseNextToken(cmapStream);
+            result.addCIDMapping(inputCode, mappedCID);
         }
     }
 
@@ -356,8 +348,8 @@ public class CMapParser
             }
             byte[] startCode = (byte[]) nextToken;
             byte[] endCode = (byte[]) parseNextToken(cmapStream);
-            int start = CMap.toInt(startCode, startCode.length);
-            int end = CMap.toInt(endCode, endCode.length);
+            int start = CMap.toInt(startCode);
+            int end = CMap.toInt(endCode);
             // end has to be bigger than start or equal
             if (end < start)
             {
@@ -715,17 +707,6 @@ public class CMapParser
         }
     }
 
-    private int createIntFromBytes(byte[] bytes)
-    {
-        int intValue = bytes[0] & 0xFF;
-        if (bytes.length == 2)
-        {
-            intValue <<= 8;
-            intValue += bytes[1] & 0xFF;
-        }
-        return intValue;
-    }
-
     private String createStringFromBytes(byte[] bytes)
     {
         return new String(bytes, bytes.length == 1 ? StandardCharsets.ISO_8859_1 : StandardCharsets.UTF_16BE);
diff --git a/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMap.java b/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMap.java
index 1399161482..601ad75ff1 100644
--- a/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMap.java
+++ b/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMap.java
@@ -37,12 +37,10 @@ public class TestCMap extends TestCase
      */
     public void testLookup() throws IOException
     {
-        byte[] bs = new byte[1];
-        bs[0] = (byte)200;
-
+        byte[] bs = new byte[] { (byte) 200 };
         CMap cMap = new CMap();
         cMap.addCharMapping(bs, "a");
-        assertTrue("a".equals(cMap.toUnicode(200)));
+        assertEquals("a", cMap.toUnicode(bs));
     }
 
     /**
diff --git a/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMapParser.java b/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMapParser.java
index d03f8e0112..e7e5f16901 100644
--- a/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMapParser.java
+++ b/fontbox/src/test/java/org/apache/fontbox/cmap/TestCMapParser.java
@@ -21,8 +21,6 @@ import java.io.IOException;
 
 import junit.framework.TestCase;
 
-import static org.apache.fontbox.cmap.CMap.toInt;
-
 /**
  * This will test the CMapParser implementation.
  *
@@ -46,44 +44,44 @@ public class TestCMapParser extends TestCase
         // char mappings
         byte[] bytes1 = {0, 1};
         assertEquals("bytes 00 01 from bfrange <0001> <0005> <0041>", "A",
-                cMap.toUnicode(toInt(bytes1, bytes1.length)));
+                cMap.toUnicode(bytes1));
 
         byte[] bytes2 = {1, 00};
         String str2 = "0";
         assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", str2,
-                cMap.toUnicode(toInt(bytes2, bytes2.length)));
+                cMap.toUnicode(bytes2));
 
         byte[] bytes3 = { 1, 32 };
         assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", "P",
-                cMap.toUnicode(toInt(bytes3, bytes3.length)));
+                cMap.toUnicode(bytes3));
 
         byte[] bytes4 = { 1, 33 };
         assertEquals("bytes 01 00 from bfrange <0100> <0109> <0030>", "R",
-                cMap.toUnicode(toInt(bytes4, bytes4.length)));
+                cMap.toUnicode(bytes4));
 
         byte[] bytes5 = { 0, 10 };
         String str5 = "*";
         assertEquals("bytes 00 0A from bfchar <000A> <002A>", str5,
-                cMap.toUnicode(toInt(bytes5, bytes5.length)));
+                cMap.toUnicode(bytes5));
 
         byte[] bytes6 = { 1, 10 };
         String str6 = "+";
         assertEquals("bytes 01 0A from bfchar <010A> <002B>", str6,
-                cMap.toUnicode(toInt(bytes6, bytes6.length)));
+                cMap.toUnicode(bytes6));
 
         // CID mappings
-        int cid1 = 65;
+        byte[] cid1 = new byte[] { 0, 65 };
         assertEquals("CID 65 from cidrange <0000> <00ff> 0 ", 65, cMap.toCID(cid1));
 
-        int cid2 = 280;
+        byte[] cid2 = new byte[] { 1, 24 };
         int strCID2 = 0x0118;
         assertEquals("CID 280 from cidrange <0100> <01ff> 256", strCID2, cMap.toCID(cid2));
 
-        int cid3 = 520;
+        byte[] cid3 = new byte[] { 2, 8 };
         int strCID3 = 0x0208;
         assertEquals("CID 520 from cidchar <0208> 520", strCID3, cMap.toCID(cid3));
 
-        int cid4 = 300;
+        byte[] cid4 = new byte[] { 1, 0x2c };
         int strCID4 = 0x12C;
         assertEquals("CID 300 from cidrange <0300> <0300> 300", strCID4, cMap.toCID(cid4));
     }
@@ -96,9 +94,43 @@ public class TestCMapParser extends TestCase
         CMapParser parser = new CMapParser();
         CMap cMap = parser.parse(new File(inDir, "Identity-H"));
 
-        assertEquals("Indentity-H CID 65", 65, cMap.toCID(65));
-        assertEquals("Indentity-H CID 12345", 12345, cMap.toCID(12345));
-        assertEquals("Indentity-H CID 0xFFFF", 0xFFFF, cMap.toCID(0xFFFF));
+        assertEquals("Indentity-H CID 65", 65, cMap.toCID(new byte[] { 0, 65 }));
+        assertEquals("Indentity-H CID 12345", 12345, cMap.toCID(new byte[] { 0x30, 0x39 }));
+        assertEquals("Indentity-H CID 0xFFFF", 0xFFFF,
+                cMap.toCID(new byte[] { (byte) 0xFF, (byte) 0xFF }));
+    }
+
+    public void testUniJIS_UTF16_H() throws IOException
+    {
+        final String resourceDir = "src/main/resources/org/apache/fontbox/cmap";
+        File inDir = new File(resourceDir);
+
+        CMapParser parser = new CMapParser();
+        CMap cMap = parser.parse(new File(inDir, "UniJIS-UTF16-H"));
+
+        // the next 3 cases demonstrate the issue of possible false result values of CMap.toCID(int code)
+        assertEquals("UniJIS-UTF16-H CID 0xb1 -> 694", 694, cMap.toCID(0xb1));
+        assertFalse("UniJIS-UTF16-H CID 0xb1 -> 694", cMap.toCID(0xb1, 1) == 694);
+        assertEquals("UniJIS-UTF16-H CID 0x00b1 -> 694", 694, cMap.toCID(0xb1, 2));
+
+        // 1:1 cid char mapping
+        assertEquals("UniJIS-UTF16-H CID 0x00b1 -> 694",
+                694,
+                cMap.toCID(new byte[] { 0x00, (byte) 0xb1 }));
+        assertEquals(
+                "UniJIS-UTF16-H CID 0xd850dc4b -> 20168",
+                20168,
+                cMap.toCID(new byte[] { (byte) 0xd8, 0x50, (byte) 0xdc, 0x4b }));
+
+        // cid range mapping
+        assertEquals(
+                "UniJIS-UTF16-H CID 0x5434 -> 19223",
+                19223,
+                cMap.toCID(new byte[] { 0x54, 0x34 }));
+        assertEquals("UniJIS-UTF16-H CID 0xd83cdd12 -> 10006",
+                10006,
+                cMap.toCID(new byte[] { (byte) 0xd8, 0x3c, (byte) 0xdd, 0x12 }));
+
     }
 
     public void testUniJIS_UCS2_H() throws IOException
@@ -109,7 +141,19 @@ public class TestCMapParser extends TestCase
         CMapParser parser = new CMapParser();
         CMap cMap = parser.parse(new File(inDir, "UniJIS-UCS2-H"));
 
-        assertEquals("UniJIS-UCS2-H CID 65 -> 34", 34, cMap.toCID(65));
+        assertEquals("UniJIS-UCS2-H CID 65 -> 34", 34, cMap.toCID(new byte[] { 0, 65 }));
+    }
+
+    public void testAdobe_GB1_UCS2() throws IOException
+    {
+        final String resourceDir = "src/main/resources/org/apache/fontbox/cmap";
+        File inDir = new File(resourceDir);
+
+        CMapParser parser = new CMapParser();
+        CMap cMap = parser.parse(new File(inDir, "Adobe-GB1-UCS2"));
+
+        assertEquals("Adobe-GB1-UCS2 CID 0x11 -> \"0\"", "0",
+                cMap.toUnicode(new byte[] { 0, 0x11 }));
     }
 
     /**
@@ -132,10 +176,10 @@ public class TestCMapParser extends TestCase
 
         byte[] bytes1 = { 0, 1 };
         assertEquals("bytes 00 01 from bfrange <0001> <0009> <0041>", "A",
-                cMap.toUnicode(toInt(bytes1, bytes1.length)));
+                cMap.toUnicode(bytes1));
 
         byte[] bytes2 = { 1, 00 };
-        assertNull(cMap.toUnicode(toInt(bytes2, bytes2.length)));
+        assertNull(cMap.toUnicode(bytes2));
 
     }
 
@@ -146,13 +190,15 @@ public class TestCMapParser extends TestCase
 
         assertNotNull("Failed to parse malformed CMap file", cMap);
 
-        assertEquals("bytes 00 01 from bfrange <0001> <0009> <0030>", "0", cMap.toUnicode(0x001));
+        assertEquals("bytes 00 01 from bfrange <0001> <0009> <0030>", "0",
+                cMap.toUnicode(new byte[] { 0, 1 }));
 
-        assertEquals("bytes 02 32 from bfrange <0232> <0432> <0041>", "A", cMap.toUnicode(0x232));
+        assertEquals("bytes 02 32 from bfrange <0232> <0432> <0041>", "A",
+                cMap.toUnicode(new byte[] { 2, 0x32 }));
 
         // check border values
-        assertNotNull(cMap.toUnicode(0x2F0));
-        assertNull(cMap.toUnicode(0x2F1));
+        assertNotNull(cMap.toUnicode(new byte[] { 2, (byte) 0xF0 }));
+        assertNull(cMap.toUnicode(new byte[] { 2, (byte) 0xF1 }));
 
     }
 
