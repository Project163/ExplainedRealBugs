diff --git a/fontbox/src/main/java/org/apache/fontbox/ttf/GlyfSimpleDescript.java b/fontbox/src/main/java/org/apache/fontbox/ttf/GlyfSimpleDescript.java
index bff8b2737d..5d09cf8eeb 100644
--- a/fontbox/src/main/java/org/apache/fontbox/ttf/GlyfSimpleDescript.java
+++ b/fontbox/src/main/java/org/apache/fontbox/ttf/GlyfSimpleDescript.java
@@ -51,7 +51,7 @@ public class GlyfSimpleDescript extends GlyfDescript
         super(numberOfContours);
 
         /*
-         * https://developer.apple.com/fonts/TTRefMan/RM06/Chap6glyf.html
+         * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html
          * "If a glyph has zero contours, it need not have any glyph data." set the pointCount to zero to initialize
          * attributes and avoid nullpointer but maybe there shouldn't have GlyphDescript in the GlyphData?
          */
diff --git a/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubsetter.java b/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubsetter.java
index 535e71ca5b..bf2bc82f38 100755
--- a/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubsetter.java
+++ b/fontbox/src/main/java/org/apache/fontbox/ttf/TTFSubsetter.java
@@ -26,6 +26,7 @@ import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.Calendar;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -52,7 +53,7 @@ public final class TTFSubsetter
 {
     private static final Logger LOG = LogManager.getLogger(TTFSubsetter.class);
     
-    private static final byte[] PAD_BUF = { 0, 0, 0 };
+    private static final byte[] PAD_BUF = { 0, 0, 0, 0 };
 
     private static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone("UTC"); // clone before using
 
@@ -62,6 +63,7 @@ public final class TTFSubsetter
 
     private final List<String> keepTables;
     private final SortedSet<Integer> glyphIds; // new glyph ids
+    private final Set<Integer> invisibleGlyphIds;
     private String prefix;
     private boolean hasAddedCompoundReferences;
 
@@ -92,6 +94,7 @@ public final class TTFSubsetter
 
         uniToGID = new TreeMap<>();
         glyphIds = new TreeSet<>();
+        invisibleGlyphIds = new HashSet<>();
 
         // find the best Unicode cmap
         this.unicodeCmap = ttf.getUnicodeCmapLookup();
@@ -135,6 +138,23 @@ public final class TTFSubsetter
         unicodeSet.forEach(this::add);
     }
 
+    /**
+     * Forces the glyph for the specified character code to be zero-width and contour-free,
+     * regardless of what the glyph looks like in the original font. Note that the specified
+     * character code is not added to the subset unless it is also {@link #add(int) added}
+     * separately.
+     *
+     * @param unicode the character code whose glyph should be invisible
+     */
+    public void forceInvisible(int unicode)
+    {
+        int gid = unicodeCmap.getGlyphId(unicode);
+        if (gid != 0)
+        {
+            invisibleGlyphIds.add(gid);
+        }
+    }
+
     /**
      * Returns the map of new -&gt; old GIDs.
      * 
@@ -611,6 +631,13 @@ public final class TTFSubsetter
                             isResult);
                 }
 
+                // glyphs with no outlines have an empty entry in the 'glyf' table, with a
+                // corresponding 'loca' table entry with length = 0
+                if (invisibleGlyphIds.contains(gid))
+                {
+                    continue;
+                }
+
                 byte[] buf = new byte[(int)length];
                 isResult = is.read(buf);
 
@@ -921,9 +948,18 @@ public final class TTFSubsetter
                 long offset;
                 if (glyphId <= lastgid)
                 {
-                    // copy width and lsb
-                    offset = glyphId * 4l;
-                    lastOffset = copyBytes(is, bos, offset, lastOffset, 4);
+                    if (invisibleGlyphIds.contains(glyphId))
+                    {
+                        // force zero width (no change to last offset)
+                        // 4 bytes total, 2 bytes each for: advance width = 0, left side bearing = 0
+                        bos.write(PAD_BUF, 0, 4);
+                    }
+                    else
+                    {
+                        // copy width and lsb
+                        offset = glyphId * 4l;
+                        lastOffset = copyBytes(is, bos, offset, lastOffset, 4);
+                    }
                 }
                 else 
                 {
diff --git a/fontbox/src/test/java/org/apache/fontbox/ttf/TTFSubsetterTest.java b/fontbox/src/test/java/org/apache/fontbox/ttf/TTFSubsetterTest.java
index 6d91772421..e777e11887 100644
--- a/fontbox/src/test/java/org/apache/fontbox/ttf/TTFSubsetterTest.java
+++ b/fontbox/src/test/java/org/apache/fontbox/ttf/TTFSubsetterTest.java
@@ -29,6 +29,7 @@ import org.apache.pdfbox.io.RandomAccessReadBufferedFile;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
@@ -294,4 +295,76 @@ class TTFSubsetterTest
             subsetter.writeToStream(output);
         }
     }
+
+    /**
+     * Test of PDFBOX-5230: check that subsetting can be forced to use invisible glyphs.
+     *
+     * @throws java.io.IOException
+     */
+    @Test
+    void testPDFBox5230() throws IOException
+    {
+        final File testFile = new File("src/test/resources/ttf/LiberationSans-Regular.ttf");
+        TrueTypeFont ttf = new TTFParser().parse(new RandomAccessReadBufferedFile(testFile));
+        TTFSubsetter ttfSubsetter = new TTFSubsetter(ttf);
+        ttfSubsetter.add('A');
+        ttfSubsetter.add('B');
+        ttfSubsetter.add('\u200C');
+
+        // verify results without forcing
+
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        ttfSubsetter.writeToStream(baos);
+        try (TrueTypeFont subset = new TTFParser(true)
+                .parse(new RandomAccessReadBuffer(baos.toByteArray())))
+        {
+            assertEquals(4, subset.getNumberOfGlyphs());
+            assertEquals(0, subset.nameToGID(".notdef"));
+            assertEquals(1, subset.nameToGID("A"));
+            assertEquals(2, subset.nameToGID("B"));
+            assertEquals(3, subset.nameToGID("uni200C"));
+
+            PostScriptTable pst = subset.getPostScript();
+            assertEquals(".notdef", pst.getName(0));
+            assertEquals("A", pst.getName(1));
+            assertEquals("B", pst.getName(2));
+            assertEquals("uni200C", pst.getName(3));
+
+            assertFalse(subset.getPath("A").getBounds2D().isEmpty(), "A path should not be empty");
+            assertFalse(subset.getPath("B").getBounds2D().isEmpty(), "B path should not be empty");
+            assertFalse(subset.getPath("uni200C").getBounds2D().isEmpty(), "ZWNJ path should not be empty");
+            assertNotEquals(0, subset.getWidth("A"), "A width should not be zero.");
+            assertNotEquals(0, subset.getWidth("B"), "B width should not be zero.");
+            assertEquals(0, subset.getWidth("uni200C"), "ZWNJ width should be zero");
+        }
+
+        // verify results while forcing B and ZWNJ to use invisible glyphs
+
+        ttfSubsetter.forceInvisible('B');
+        ttfSubsetter.forceInvisible('\u200C');
+        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
+        ttfSubsetter.writeToStream(baos2);
+        try (TrueTypeFont subset = new TTFParser(true)
+                .parse(new RandomAccessReadBuffer(baos2.toByteArray())))
+        {
+            assertEquals(4, subset.getNumberOfGlyphs());
+            assertEquals(0, subset.nameToGID(".notdef"));
+            assertEquals(1, subset.nameToGID("A"));
+            assertEquals(2, subset.nameToGID("B"));
+            assertEquals(3, subset.nameToGID("uni200C"));
+
+            PostScriptTable pst = subset.getPostScript();
+            assertEquals(".notdef", pst.getName(0));
+            assertEquals("A", pst.getName(1));
+            assertEquals("B", pst.getName(2));
+            assertEquals("uni200C", pst.getName(3));
+
+            assertFalse(subset.getPath("A").getBounds2D().isEmpty(), "A path should not be empty");
+            assertTrue(subset.getPath("B").getBounds2D().isEmpty(), "B path should be empty");
+            assertTrue(subset.getPath("uni200C").getBounds2D().isEmpty(), "ZWNJ path should be empty");
+            assertNotEquals(0, subset.getWidth("A"), "A width should not be zero.");
+            assertEquals(0, subset.getWidth("B"), "B width should be zero.");
+            assertEquals(0, subset.getWidth("uni200C"), "ZWNJ width should be zero");
+        }
+    }
 }
