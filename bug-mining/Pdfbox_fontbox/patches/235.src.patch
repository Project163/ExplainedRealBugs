diff --git a/fontbox/src/main/java/org/apache/fontbox/type1/Token.java b/fontbox/src/main/java/org/apache/fontbox/type1/Token.java
index 08844e0663..1f3cba2bbc 100644
--- a/fontbox/src/main/java/org/apache/fontbox/type1/Token.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Token.java
@@ -33,8 +33,10 @@ class Token
     enum Kind
     {
         NONE, STRING, NAME, LITERAL, REAL, INTEGER,
-        START_ARRAY,  END_ARRAY, START_PROC,
-        END_PROC, CHARSTRING
+        START_ARRAY, END_ARRAY, 
+        START_PROC, END_PROC, 
+        START_DICT, END_DICT, 
+        CHARSTRING
     }
 
     // exposed statically for convenience
@@ -48,6 +50,8 @@ class Token
     static final Kind START_PROC = Kind.START_PROC;
     static final Kind END_PROC = Kind.END_PROC;
     static final Kind CHARSTRING = Kind.CHARSTRING;
+    static final Kind START_DICT = Kind.START_DICT;
+    static final Kind END_DICT = Kind.END_DICT;
 
     private String text;
     private byte[] data;
diff --git a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
index ae58461ad3..ba0eebaa33 100644
--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Lexer.java
@@ -142,6 +142,34 @@ class Type1Lexer
                 {
                     return new Token(readRegular(), Token.LITERAL);
                 }
+                else if (c == '<')
+                {
+                    char c2 = getChar();
+                    if (c2 == c)
+                    {
+                        return new Token("<<", Token.START_DICT);
+                    }
+                    else
+                    {
+                        // code may have to be changed in something better, maybe new token type
+                        buffer.position(buffer.position() - 1);
+                        return new Token(c, Token.NAME);
+                    }
+                }
+                else if (c == '>')
+                {
+                    char c2 = getChar();
+                    if (c2 == c)
+                    {
+                        return new Token(">>", Token.END_DICT);
+                    }
+                    else
+                    {
+                        // code may have to be changed in something better, maybe new token type
+                        buffer.position(buffer.position() - 1);
+                        return new Token(c, Token.NAME);
+                    }
+                }
                 else if (Character.isWhitespace(c))
                 {
                     skip = true;
@@ -191,7 +219,8 @@ class Type1Lexer
                     }
                 }
             }
-        } while (skip);
+        }
+        while (skip);
         return null;
     }
 
diff --git a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
index cd2f4e5165..7f3a3ad94c 100644
--- a/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/type1/Type1Parser.java
@@ -349,7 +349,7 @@ final class Type1Parser
     /**
      * Reads a simple value. This is either a number, a string,
      * a name, a literal name, an array, a procedure, or a charstring.
-     * This method does not support reading nested dictionaries.
+     * This method does not support reading nested dictionaries unless they're empty.
      */
     private List<Token> readValue() throws IOException
     {
@@ -384,6 +384,12 @@ final class Type1Parser
         {
             value.addAll(readProc());
         }
+        else if (token.getKind() == Token.START_DICT)
+        {
+            // skip "/GlyphNames2HostCode << >> def"
+            read(Token.END_DICT);
+            return value;
+        }
 
         // postscript wrapper (not in the Type 1 spec)
         if (lexer.peekToken().getText().equals("systemdict"))
