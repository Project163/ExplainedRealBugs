diff --git a/fontbox/src/main/java/org/apache/fontbox/cff/CFFFont.java b/fontbox/src/main/java/org/apache/fontbox/cff/CFFFont.java
index e024fe1c24..0434328fd3 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cff/CFFFont.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cff/CFFFont.java
@@ -25,6 +25,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.fontbox.cff.IndexData;
 import org.apache.fontbox.cff.charset.CFFCharset;
 import org.apache.fontbox.cff.encoding.CFFEncoding;
 
@@ -43,6 +44,8 @@ public class CFFFont
     private CFFEncoding fontEncoding = null;
     private CFFCharset fontCharset = null;
     private Map<String, byte[]> charStringsDict = new LinkedHashMap<String, byte[]>();
+    private IndexData globalSubrIndex = null;
+    private IndexData localSubrIndex = null;
 
     /**
      * The name of the font.
@@ -293,7 +296,7 @@ public class CFFFont
         Number defaultWidthX = (Number) getProperty("defaultWidthX");
         Number nominalWidthX = (Number) getProperty("nominalWidthX");
         return new CharStringConverter(defaultWidthX.intValue(), nominalWidthX
-                .intValue());
+                .intValue(), getGlobalSubrIndex(), getLocalSubrIndex());
     }
 
     /**
@@ -316,7 +319,40 @@ public class CFFFont
                 + charStringsDict + "]";
     }
 
+    
     /**
+     * Sets the global subroutine index data.
+     * @param globalSubrIndex the IndexData object containing the global subroutines 
+     */
+    public void setGlobalSubrIndex(IndexData globalSubrIndex) {
+		this.globalSubrIndex = globalSubrIndex;
+	}
+
+    /** 
+     * Returns the global subroutine index data.
+     * @return the dictionary
+     */
+	public IndexData getGlobalSubrIndex() {
+		return globalSubrIndex;
+	}
+	
+    /** 
+     * Returns the local subroutine index data.
+     * @return the dictionary
+     */
+	public IndexData getLocalSubrIndex() {
+		return localSubrIndex;
+	}
+	
+    /**
+     * Sets the local subroutine index data.
+     * @param localSubrIndex the IndexData object containing the local subroutines 
+     */
+	public void setLocalSubrIndex(IndexData localSubrIndex) {
+		this.localSubrIndex = localSubrIndex;	
+	}
+
+	/**
      * This class is used for the font mapping.
      *
      */
diff --git a/fontbox/src/main/java/org/apache/fontbox/cff/CFFParser.java b/fontbox/src/main/java/org/apache/fontbox/cff/CFFParser.java
index a6fbd0b665..9dee2be1a5 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cff/CFFParser.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cff/CFFParser.java
@@ -49,7 +49,6 @@ public class CFFParser
     private IndexData nameIndex = null;
     private IndexData topDictIndex = null;
     private IndexData stringIndex = null;
-    private IndexData globalSubrIndex = null;
 
     /**
      * Parsing CFF Font using a byte array as input.
@@ -64,12 +63,13 @@ public class CFFParser
         nameIndex = readIndexData(input);
         topDictIndex = readIndexData(input);
         stringIndex = readIndexData(input);
-        globalSubrIndex = readIndexData(input);
+        IndexData globalSubrIndex = readIndexData(input);
 
         List<CFFFont> fonts = new ArrayList<CFFFont>();
-        for (int i = 0; i < nameIndex.count; i++)
+        for (int i = 0; i < nameIndex.getCount(); i++)
         {
             CFFFont font = parseFont(i);
+            font.setGlobalSubrIndex(globalSubrIndex);
             fonts.add(font);
         }
         return fonts;
@@ -88,23 +88,22 @@ public class CFFParser
     private static IndexData readIndexData(CFFDataInput input)
             throws IOException
     {
-        IndexData index = new IndexData();
-        index.count = input.readCard16();
-        if (index.count == 0)
+        int count = input.readCard16();
+        IndexData index = new IndexData(count);
+        if (count == 0)
         {
             return index;
         }
-        index.offSize = input.readOffSize();
-        index.offset = new int[index.count + 1];
-        for (int i = 0; i < index.offset.length; i++)
+        int offSize = input.readOffSize();
+        for (int i = 0; i <= count; i++)
         {
-            index.offset[i] = input.readOffset(index.offSize);
+            index.setOffset(i, input.readOffset(offSize));
         }
-        index.data = new int[index.offset[index.offset.length - 1]
-                - index.offset[0]];
-        for (int i = 0; i < index.data.length; i++)
+        int dataSize = index.getOffset(count) - index.getOffset(0);
+        index.initData(dataSize);
+        for (int i = 0; i < dataSize; i++)
         {
-            index.data[i] = input.readCard8();
+            index.setData(i, input.readCard8());
         }
         return index;
     }
@@ -334,13 +333,13 @@ public class CFFParser
         else
         {
             input.setPosition(charsetId);
-            charset = readCharset(input, charStringsIndex.count);
+            charset = readCharset(input, charStringsIndex.getCount());
         }
         font.setCharset(charset);
         font.getCharStringsDict().put(".notdef", charStringsIndex.getBytes(0));
-        int[] gids = new int[charStringsIndex.count];
+        int[] gids = new int[charStringsIndex.getCount()];
         List<CFFCharset.Entry> glyphEntries = charset.getEntries();
-        for (int i = 1; i < charStringsIndex.count; i++)
+        for (int i = 1; i < charStringsIndex.getCount(); i++)
         {
             CFFCharset.Entry glyphEntry = glyphEntries.get(i - 1);
             gids[i - 1] = glyphEntry.getSID();
@@ -382,7 +381,7 @@ public class CFFParser
             List<Map<String, Object>> fontDictionaries = new LinkedList<Map<String, Object>>();
     		CFFFontROS fontRos = (CFFFontROS)font;
 
-        	for (int i = 0; i < fdIndex.count; ++i) {
+        	for (int i = 0; i < fdIndex.getCount(); ++i) {
         		byte[] b = fdIndex.getBytes(i);
         		CFFDataInput fontDictInput = new CFFDataInput(b);
         		DictData fontDictData = readDictData(fontDictInput);
@@ -426,6 +425,17 @@ public class CFFParser
     	        privDict.put("defaultWidthX", getNumber(privateDict, "defaultWidthX", Integer.valueOf(0)));
     	        privDict.put("nominalWidthX", getNumber(privateDict, "nominalWidthX", Integer.valueOf(0)));
 
+    	        int localSubrOffset = (Integer)getNumber(privateDict, "Subrs", Integer.valueOf(0));
+    	        if (localSubrOffset == 0)
+    	        {
+    	            font.setLocalSubrIndex(new IndexData(0));
+    	        }
+    	        else
+    	        {
+    	            input.setPosition(privateOffset + localSubrOffset);
+    	            font.setLocalSubrIndex(readIndexData(input));
+    	        }
+    	        
     	        privateDictionaries.add(privDict);
         	}
 
@@ -435,7 +445,7 @@ public class CFFParser
         	DictData.Entry fdSelectEntry = topDict.getEntry("FDSelect");
         	int fdSelectPos = fdSelectEntry.getNumber(0).intValue();
         	input.setPosition(fdSelectPos);
-        	CIDKeyedFDSelect fdSelect = readFDSelect(input, charStringsIndex.count, fontRos);
+        	CIDKeyedFDSelect fdSelect = readFDSelect(input, charStringsIndex.getCount(), fontRos);
 
 	        font.addValueToPrivateDict("defaultWidthX", Integer.valueOf(1000));
 	        font.addValueToPrivateDict("nominalWidthX", Integer.valueOf(0));
@@ -466,6 +476,17 @@ public class CFFParser
 	        font.addValueToPrivateDict("initialRandomSeed", getNumber(privateDict, "initialRandomSeed", Integer.valueOf(0)));
 	        font.addValueToPrivateDict("defaultWidthX", getNumber(privateDict, "defaultWidthX", Integer.valueOf(0)));
 	        font.addValueToPrivateDict("nominalWidthX", getNumber(privateDict, "nominalWidthX", Integer.valueOf(0)));
+	        
+	        int localSubrOffset = (Integer)getNumber(privateDict, "Subrs", Integer.valueOf(0));
+	        if (localSubrOffset == 0)
+	        {
+	            font.setLocalSubrIndex(new IndexData(0));
+	        }
+	        else
+	        {
+	            input.setPosition(privateOffset + localSubrOffset);
+	            font.setLocalSubrIndex(readIndexData(input));
+	        }
         }
 
         return font;
@@ -477,8 +498,13 @@ public class CFFParser
         {
             return CFFStandardString.getName(index);
         }
-        DataInput dataInput = new DataInput(stringIndex.getBytes(index - 391));
-        return dataInput.getString();
+        if (index - 391 <= stringIndex.getCount()) {
+            DataInput dataInput = new DataInput(stringIndex.getBytes(index - 391));
+            return dataInput.getString();
+        }
+        else {
+            return CFFStandardString.getName(0);
+        }
     }
 
     private String getString(DictData dict, String name) throws IOException
@@ -814,23 +840,20 @@ public class CFFParser
     {
         Format1Charset charset = new Format1Charset();
         charset.format = format;
-        charset.range = new Format1Charset.Range1[0];
+        List<Format1Charset.Range1> ranges = new ArrayList<Format1Charset.Range1>();
         for (int i = 0; i < nGlyphs - 1;)
         {
-            Format1Charset.Range1[] newRange = new Format1Charset.Range1[charset.range.length + 1];
-            System.arraycopy(charset.range, 0, newRange, 0,
-                    charset.range.length);
-            charset.range = newRange;
             Format1Charset.Range1 range = new Format1Charset.Range1();
             range.first = dataInput.readSID();
             range.nLeft = dataInput.readCard8();
-            charset.range[charset.range.length - 1] = range;
+            ranges.add(range);
             for (int j = 0; j < 1 + range.nLeft; j++)
             {
                 charset.register(range.first + j, readString(range.first + j));
             }
             i += 1 + range.nLeft;
         }
+        charset.range = ranges.toArray(new Format1Charset.Range1[0]);
         return charset;
     }
     
@@ -878,36 +901,6 @@ public class CFFParser
         }
     }
 
-    /**
-     * Inner class holding the IndexData of a CFF font. 
-     */
-    private static class IndexData
-    {
-        private int count;
-        private int offSize;
-        private int[] offset;
-        private int[] data;
-
-        public byte[] getBytes(int index)
-        {
-            int length = offset[index + 1] - offset[index];
-            byte[] bytes = new byte[length];
-            for (int i = 0; i < length; i++)
-            {
-                bytes[i] = (byte) data[offset[index] - 1 + i];
-            }
-            return bytes;
-        }
-
-        @Override
-        public String toString()
-        {
-            return getClass().getName() + "[count=" + count + ", offSize="
-                    + offSize + ", offset=" + Arrays.toString(offset)
-                    + ", data=" + Arrays.toString(data) + "]";
-        }
-    }
-
     /**
      * Inner class holding the DictData of a CFF font. 
      */
diff --git a/fontbox/src/main/java/org/apache/fontbox/cff/CharStringConverter.java b/fontbox/src/main/java/org/apache/fontbox/cff/CharStringConverter.java
index 49ec4dd816..b30f5d1b10 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cff/CharStringConverter.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cff/CharStringConverter.java
@@ -16,6 +16,7 @@
  */
 package org.apache.fontbox.cff;
 
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -34,6 +35,8 @@ public class CharStringConverter extends CharStringHandler
     private int nominalWidthX = 0;
     private List<Object> sequence = null;
     private int pathCount = 0;
+    private IndexData globalSubrIndex = null;
+    private IndexData localSubrIndex = null;
 
     /**
      * Constructor.
@@ -41,10 +44,12 @@ public class CharStringConverter extends CharStringHandler
      * @param defaultWidth default width
      * @param nominalWidth nominal width
      */
-    public CharStringConverter(int defaultWidth, int nominalWidth)
+    public CharStringConverter(int defaultWidth, int nominalWidth, IndexData fontGlobalSubrIndex, IndexData fontLocalSubrIndex)
     {
         defaultWidthX = defaultWidth;
         nominalWidthX = nominalWidth;
+        globalSubrIndex = fontGlobalSubrIndex;
+        localSubrIndex = fontLocalSubrIndex;
     }
 
     /**
@@ -64,20 +69,20 @@ public class CharStringConverter extends CharStringHandler
      * {@inheritDoc}
      */
     @Override
-    public void handleCommand(List<Integer> numbers, CharStringCommand command)
+    public List<Integer> handleCommand(List<Integer> numbers, CharStringCommand command)
     {
 
         if (CharStringCommand.TYPE1_VOCABULARY.containsKey(command.getKey()))
         {
-            handleType1Command(numbers, command);
+            return handleType1Command(numbers, command);
         } 
         else
         {
-            handleType2Command(numbers, command);
+            return handleType2Command(numbers, command);
         }
     }
 
-    private void handleType1Command(List<Integer> numbers,
+    private List<Integer> handleType1Command(List<Integer> numbers,
             CharStringCommand command)
     {
         String name = CharStringCommand.TYPE1_VOCABULARY.get(command.getKey());
@@ -140,14 +145,57 @@ public class CharStringConverter extends CharStringHandler
         {
             drawAlternatingCurve(numbers, true);
         } 
+        else if ("callsubr".equals(name))
+        {
+            //get subrbias
+            int bias = 0;
+            int nSubrs = localSubrIndex.getCount();
+            
+            if (nSubrs < 1240)
+            {
+                bias = 107;
+            }
+            else if (nSubrs < 33900) 
+            {
+                bias = 1131;
+            }
+            else 
+            {
+                bias = 32768;
+            }
+           
+            List<Integer> result = null;
+            int subrNumber = bias+numbers.get(numbers.size()-1);
+            if (subrNumber < localSubrIndex.getCount())
+            {
+                Type2CharStringParser parser = new Type2CharStringParser();
+                byte[] bytes = localSubrIndex.getBytes(subrNumber);
+                List<Object> parsed = null;
+                try {
+                    parsed = parser.parse(bytes);
+                    parsed.addAll(0,numbers.subList(0, numbers.size()-1));
+                    result = handleSequence(parsed);
+                } 
+                catch (IOException e) 
+                {
+                    e.printStackTrace();
+                }
+            }
+            return result;
+        }
+        else if ("return".equals(name))
+        {
+            return numbers;
+        }
         else
         {
             addCommand(numbers, command);
         }
+        return null;
     }
 
     @SuppressWarnings(value = { "unchecked" })
-    private void handleType2Command(List<Integer> numbers,
+    private List<Integer> handleType2Command(List<Integer> numbers,
             CharStringCommand command)
     {
         String name = CharStringCommand.TYPE2_VOCABULARY.get(command.getKey());
@@ -228,11 +276,47 @@ public class CharStringConverter extends CharStringHandler
         {
             drawCurve(numbers, true);
         } 
+        else if ("callgsubr".equals(name))
+        {
+            //get subrbias
+            int bias = 0;
+            int nSubrs = globalSubrIndex.getCount();
+            
+            if (nSubrs < 1240)
+            {
+                bias = 107;
+            }
+            else if (nSubrs < 33900)
+            {
+                bias = 1131;
+            }
+            else 
+            {
+                bias = 32768;
+            }
+            List<Integer> result = null;
+            int subrNumber = bias+numbers.get(numbers.size()-1);
+            if (subrNumber < nSubrs)
+            {
+                Type2CharStringParser parser = new Type2CharStringParser();
+                byte[] bytes = globalSubrIndex.getBytes(subrNumber);
+                List<Object> parsed = null;
+                try {
+                    parsed = parser.parse(bytes);
+                    parsed.addAll(0,numbers.subList(0, numbers.size()-1));
+                    result = handleSequence(parsed);
+                } catch (IOException e) 
+                {
+                    e.printStackTrace();
+                }
+            }
+            return result;
+        }
         else
         {
-            // System.out.println("Not implemented: numbers=" + numbers +
-            // " command=" +command+ " (" +name+ ")");
+            addCommand(numbers, command);
         }
+        return null;
     }
 
     private List<Integer> clearStack(List<Integer> numbers, boolean flag)
diff --git a/fontbox/src/main/java/org/apache/fontbox/cff/CharStringHandler.java b/fontbox/src/main/java/org/apache/fontbox/cff/CharStringHandler.java
index 7e9e11faee..708ca44c22 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cff/CharStringHandler.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cff/CharStringHandler.java
@@ -16,6 +16,7 @@
  */
 package org.apache.fontbox.cff;
 
+
 import java.util.List;
 
 /**
@@ -31,28 +32,44 @@ public abstract class CharStringHandler
      * Handler for a sequence of CharStringCommands.
      * 
      * @param sequence of CharStringCommands
+     * 
+     * @return may return a command sequence of a subroutine
      */
     @SuppressWarnings(value = { "unchecked" })
-    public void handleSequence(List<Object> sequence)
+    public List<Integer> handleSequence(List<Object> sequence)
     {
+        List<Integer> numbers = null;
         int offset = 0;
-        for (int i = 0; i < sequence.size(); i++)
+        int size = sequence.size();
+        for (int i = 0; i < size; i++)
         {
             Object object = sequence.get(i);
             if (object instanceof CharStringCommand)
             {
-                List<Integer> numbers = (List) sequence.subList(offset, i);
-                CharStringCommand command = (CharStringCommand) object;
-                handleCommand(numbers, command);
+                if (numbers == null)
+                    numbers = (List) sequence.subList(offset, i);
+                else 
+                    numbers.addAll((List) sequence.subList(offset, i));
+                List<Integer> stack = handleCommand(numbers, (CharStringCommand) object);
+                if (stack != null && !stack.isEmpty())
+                    numbers = stack;
+                else
+                    numbers = null;
                 offset = i + 1;
             }
         }
+        if (numbers != null && !numbers.isEmpty())
+            return numbers;
+        else
+            return null;
     }
     /**
      * Handler for CharStringCommands.
      *  
      * @param numbers a list of numbers
      * @param command the CharStringCommand
+     * 
+     * @return may return a command sequence of a subroutine
      */
-    public abstract void handleCommand(List<Integer> numbers, CharStringCommand command);
+    public abstract List<Integer> handleCommand(List<Integer> numbers, CharStringCommand command);
 }
\ No newline at end of file
diff --git a/fontbox/src/main/java/org/apache/fontbox/cff/CharStringRenderer.java b/fontbox/src/main/java/org/apache/fontbox/cff/CharStringRenderer.java
index 47e7396aa0..dca58f5006 100644
--- a/fontbox/src/main/java/org/apache/fontbox/cff/CharStringRenderer.java
+++ b/fontbox/src/main/java/org/apache/fontbox/cff/CharStringRenderer.java
@@ -19,6 +19,8 @@ package org.apache.fontbox.cff;
 import java.awt.geom.GeneralPath;
 import java.awt.geom.Point2D;
 import java.awt.geom.Rectangle2D;
+import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -50,7 +52,7 @@ public class CharStringRenderer extends CharStringHandler
      * @param sequence the given charstring sequence
      * @return the rendered GeneralPath 
      */
-    public GeneralPath render(List<Object> sequence)
+    public GeneralPath render(List<Object> sequence) throws IOException
     {
         path = new GeneralPath();
         sidebearingPoint = new Point2D.Float(0, 0);
@@ -63,13 +65,14 @@ public class CharStringRenderer extends CharStringHandler
     /**
      * {@inheritDoc}
      */
-    public void handleCommand(List<Integer> numbers, CharStringCommand command)
+    public List<Integer> handleCommand(List<Integer> numbers, CharStringCommand command)
     {
         if (isCharstringType1) {
             handleCommandType1(numbers, command);
         } else {
             handleCommandType2(numbers, command);
         }
+        return null;
     }
  
     /**
diff --git a/fontbox/src/main/java/org/apache/fontbox/cff/IndexData.java b/fontbox/src/main/java/org/apache/fontbox/cff/IndexData.java
new file mode 100644
index 0000000000..7ef324bdef
--- /dev/null
+++ b/fontbox/src/main/java/org/apache/fontbox/cff/IndexData.java
@@ -0,0 +1,107 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.fontbox.cff;
+
+import java.util.Arrays;
+
+/**
+ * Class holding the IndexData of a CFF font. 
+ */
+public class IndexData
+{
+    private int count;
+    private int[] offset;
+    private int[] data;
+
+    /**
+     * Constructor.
+     * 
+     * @param count number of index values
+     */
+    public IndexData(int count)
+    {
+        this.count = count;
+        this.offset = new int[count+1];
+    }
+
+    public byte[] getBytes(int index)
+    {
+        int length = offset[index + 1] - offset[index];
+        byte[] bytes = new byte[length];
+        for (int i = 0; i < length; i++)
+        {
+            bytes[i] = (byte) data[offset[index] - 1 + i];
+        }
+        return bytes;
+    }
+
+    @Override
+    public String toString()
+    {
+        return getClass().getName() + "[count=" + count  
+                + ", offset=" + Arrays.toString(offset)
+                + ", data=" + Arrays.toString(data) + "]";
+    }
+    
+    /**
+     * Returns the count value.
+     * @return the count value
+     */
+    public int getCount() 
+    {
+        return count;
+    }
+    
+    /**
+     * Sets the offset value to the given value.
+     * @param index the index of the offset value
+     * @param value the given offset value
+     */
+    public void setOffset(int index, int value) 
+    {
+        offset[index] = value;
+    }
+
+    /**
+     * Returns the offset at the given index.
+     * @param index the index
+     * @return the offset value at the given index
+     */
+    public int getOffset(int index) 
+    {
+        return offset[index];
+    }
+
+    /**
+     * Initializes the data array with the given size.
+     * @param dataSize the size of the data array
+     */
+    public void initData(int dataSize) 
+    {
+        data = new int[dataSize];
+    }
+    
+    /**
+     * Sets the data value to the given value.
+     * @param index the index of the data value
+     * @param value the given data value
+     */
+    public void setData(int index, int value) 
+    {
+        data[index] = value;
+    }
+}
\ No newline at end of file
