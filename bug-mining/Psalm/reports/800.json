{"url":"https://api.github.com/repos/vimeo/psalm/issues/3755","repository_url":"https://api.github.com/repos/vimeo/psalm","labels_url":"https://api.github.com/repos/vimeo/psalm/issues/3755/labels{/name}","comments_url":"https://api.github.com/repos/vimeo/psalm/issues/3755/comments","events_url":"https://api.github.com/repos/vimeo/psalm/issues/3755/events","html_url":"https://github.com/vimeo/psalm/issues/3755","id":651128715,"node_id":"MDU6SXNzdWU2NTExMjg3MTU=","number":3755,"title":"Could not get class storage for guzzlehttp/guzzleexception","user":{"login":"patrickkusebauch","id":1620948,"node_id":"MDQ6VXNlcjE2MjA5NDg=","avatar_url":"https://avatars.githubusercontent.com/u/1620948?v=4","gravatar_id":"","url":"https://api.github.com/users/patrickkusebauch","html_url":"https://github.com/patrickkusebauch","followers_url":"https://api.github.com/users/patrickkusebauch/followers","following_url":"https://api.github.com/users/patrickkusebauch/following{/other_user}","gists_url":"https://api.github.com/users/patrickkusebauch/gists{/gist_id}","starred_url":"https://api.github.com/users/patrickkusebauch/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/patrickkusebauch/subscriptions","organizations_url":"https://api.github.com/users/patrickkusebauch/orgs","repos_url":"https://api.github.com/users/patrickkusebauch/repos","events_url":"https://api.github.com/users/patrickkusebauch/events{/privacy}","received_events_url":"https://api.github.com/users/patrickkusebauch/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":486061586,"node_id":"MDU6TGFiZWw0ODYwNjE1ODY=","url":"https://api.github.com/repos/vimeo/psalm/labels/bug","name":"bug","color":"ee0701","default":true,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":2,"created_at":"2020-07-05T19:16:51Z","updated_at":"2020-07-07T04:29:52Z","closed_at":"2020-07-07T04:29:52Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Command: `bin/psalm --debug-by-line`\r\n0utput:\r\n```\r\n.\r\n.\r\n.\r\n/var/www/app/Saas/Plugins/GoogleFit/GoogleFitController.php:258\r\nUncaught InvalidArgumentException: Could not get class storage for guzzlehttp\\guzzleexception in /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Provider/ClassLikeStorageProvider.php:45\r\nStack trace:\r\n#0 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Codebase/ClassLikes.php(525): Psalm\\Internal\\Provider\\ClassLikeStorageProvider->get('guzzlehttp\\\\guzz...')\r\n#1 /var/www/vendor/vimeo/psalm/src/Psalm/Codebase.php(744): Psalm\\Internal\\Codebase\\ClassLikes->classExtends('GuzzleHttp\\\\Guzz...', 'logicexception', true)\r\n#2 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php(2414): Psalm\\Codebase->classExtends('GuzzleHttp\\\\Guzz...', 'logicexception')\r\n#3 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php(692): Psalm\\Internal\\Analyzer\\StatementsAnalyzer->getUncaughtThrows(Object(Psalm\\Context))\r\n#4 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Analyzer/ClassAnalyzer.php(1740): Psalm\\Internal\\Analyzer\\FunctionLikeAnalyzer->analyze(Object(Psalm\\Context), Object(Psalm\\Internal\\Provider\\NodeDataProvider), Object(Psalm\\Context))\r\n#5 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Analyzer/ClassAnalyzer.php(721): Psalm\\Internal\\Analyzer\\ClassAnalyzer->analyzeClassMethod(Object(PhpParser\\Node\\Stmt\\ClassMethod), Object(Psalm\\Storage\\ClassLikeStorage), Object(Psalm\\Internal\\Analyzer\\ClassAnalyzer), Object(Psalm\\Context), Object(Psalm\\Context))\r\n#6 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Analyzer/FileAnalyzer.php(198): Psalm\\Internal\\Analyzer\\ClassAnalyzer->analyze(Object(Psalm\\Context), Object(Psalm\\Context))\r\n#7 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Codebase/Analyzer.php(318): Psalm\\Internal\\Analyzer\\FileAnalyzer->analyze(NULL)\r\n#8 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Codebase/Analyzer.php(552): Psalm\\Internal\\Codebase\\Analyzer->Psalm\\Internal\\Codebase\\{closure}(61, '/var/www/app/Sa...')\r\n#9 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Codebase/Analyzer.php(241): Psalm\\Internal\\Codebase\\Analyzer->doAnalysis(Object(Psalm\\Internal\\Analyzer\\ProjectAnalyzer), 1)\r\n#10 /var/www/vendor/vimeo/psalm/src/Psalm/Internal/Analyzer/ProjectAnalyzer.php(527): Psalm\\Internal\\Codebase\\Analyzer->analyzeFiles(Object(Psalm\\Internal\\Analyzer\\ProjectAnalyzer), 1, false)\r\n#11 /var/www/vendor/vimeo/psalm/src/psalm.php(594): Psalm\\Internal\\Analyzer\\ProjectAnalyzer->check('/var/www/', false)\r\n#12 /var/www/vendor/vimeo/psalm/psalm(2): require_once('/var/www/vendor...')\r\n#13 {main}\r\n(Psalm 3.10.1@eeed5ecccc10131397f0eb7ee6da810c0be3a7fc crashed due to an uncaught Throwable)\r\n```\r\n\r\nRelevant class code(lined 199-259) - `$this-googleFit` is `GuzzleHttp\\Client`:\r\n```php\r\n    public function activitySummary(string $userId, DateTimeInterface $date = null): ActivitySummaryInterface\r\n    {\r\n        if ($date === null) {\r\n            $date = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $date = new DateTimeImmutable($date->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        $start       = $date->setTime(0, 0, 0, 0);\r\n        $end         = $date->setTime(23, 59, 59, 999999);\r\n        $accessToken = $this->accessToken($userId);\r\n\r\n        $stepsAggregate       = json_decode($this->googleFit->request('POST',\r\n            'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                'headers' => [\r\n                    'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                ], 'body' => json_encode([\r\n                    'aggregateBy'     => [\r\n                        [\r\n                            'dataTypeName' => 'com.google.step_count.delta',\r\n                            'dataSourceId' => 'derived:com.google.step_count.delta:com.google.android.gms:estimated_steps',\r\n                        ],\r\n                    ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                    'startTimeMillis' => (int) $start->format('U') * 1000, 'endTimeMillis' => (int) $end->format('U') * 1000,\r\n                ], JSON_THROW_ON_ERROR),\r\n            ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        $steps                = $stepsAggregate['bucket'][0]['dataset'][0]['point'] === [] ? 0\r\n            : (int) $stepsAggregate['bucket'][0]['dataset'][0]['point'][0]['value'][0]['intVal'];\r\n        $caloriesAggregate    = json_decode($this->googleFit->request('POST',\r\n            'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                'headers' => [\r\n                    'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                ], 'body' => json_encode([\r\n                    'aggregateBy'     => [\r\n                        [\r\n                            'dataTypeName' => 'com.google.calories.expended',\r\n                        ],\r\n                    ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                    'startTimeMillis' => (int) $start->format('U') * 1000, 'endTimeMillis' => (int) $end->format('U') * 1000,\r\n                ], JSON_THROW_ON_ERROR),\r\n            ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        $calories             = $caloriesAggregate['bucket'][0]['dataset'][0]['point'] === [] ? 0\r\n            : (int) $caloriesAggregate['bucket'][0]['dataset'][0]['point'][0]['value'][0]['fpVal'];\r\n        $moveMinutesAggregate = json_decode($this->googleFit->request('POST',\r\n            'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                'headers' => [\r\n                    'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                ], 'body' => json_encode([\r\n                    'aggregateBy'     => [\r\n                        [\r\n                            'dataTypeName' => 'com.google.active_minutes',\r\n                        ],\r\n                    ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                    'startTimeMillis' => (int) $start->format('U') * 1000, 'endTimeMillis' => (int) $end->format('U') * 1000,\r\n                ], JSON_THROW_ON_ERROR),\r\n            ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        $moveMinutes          = $moveMinutesAggregate['bucket'][0]['dataset'][0]['point'] === [] ? 0\r\n            : (int) $moveMinutesAggregate['bucket'][0]['dataset'][0]['point'][0]['value'][0]['intVal'];\r\n\r\n        return new ActivitySummary($steps, $calories, $moveMinutes);\r\n    }\r\n```\r\n\r\n# Additional info\r\npsalm.xml:\r\n```xml\r\n<?xml version=\"1.0\"?>\r\n<psalm\r\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n        errorLevel=\"2\"\r\n        strictBinaryOperands=\"true\"\r\n        resolveFromConfigFile=\"true\"\r\n        checkForThrowsDocblock=\"true\"\r\n        ignoreInternalFunctionNullReturn=\"false\"\r\n        findUnusedVariablesAndParams=\"true\"\r\n        skipChecksOnUnresolvableIncludes=\"false\"\r\n        xmlns=\"https://getpsalm.org/schema/config\"\r\n        xsi:schemaLocation=\"https://getpsalm.org/schema/config vendor/vimeo/psalm/config.xsd\"\r\n        checkForThrowsInGlobalScope=\"true\"\r\n        autoloader=\"app/Booting.php\"\r\n>\r\n    <projectFiles>\r\n        <directory name=\"app\"/>\r\n        <ignoreFiles>\r\n            <directory name=\"vendor\"/>\r\n        </ignoreFiles>\r\n    </projectFiles>\r\n    <plugins>\r\n        <pluginClass class=\"Weirdan\\DoctrinePsalmPlugin\\Plugin\"/>\r\n        <pluginClass class=\"DanceEngineer\\PsalmKnapsackCollections\\Plugin\"/>\r\n        <pluginClass class=\"PatrickKusebauch\\NettePsalmPlugin\\Plugin\"/>\r\n    </plugins>\r\n    <stubs>\r\n        <file name=\"stubs/BootstrapContainerTrait.phpstub\"/>\r\n    </stubs>\r\n    <ignoreExceptions>\r\n        <!-- Logic exception can appear anywhere and should be expected nowhere -->\r\n        <classAndDescendants name=\"LogicException\" onlyGlobalScope=\"false\"/>\r\n    </ignoreExceptions>\r\n    <issueHandlers>\r\n        <!-- todo Templates, Presenters and Controls - would be really useful to ignore only for those -->\r\n        <PropertyNotSetInConstructor errorLevel=\"suppress\"/>\r\n        <!-- todo Errors on form components-->\r\n        <UndefinedInterfaceMethod errorLevel=\"suppress\"/>\r\n        <!-- todo Fix PHPStan....-->\r\n        <UnnecessaryVarAnnotation errorLevel=\"suppress\" />\r\n    </issueHandlers>\r\n</psalm>\r\n```\r\n\r\nFull class code:\r\n```php\r\n<?php\r\n\r\ndeclare(strict_types = 1);\r\n\r\nnamespace SfEngineer\\Website\\Saas\\Plugins\\GoogleFit;\r\n\r\nuse Contributte\\OAuth2Client\\Flow\\Google\\GoogleProvider;\r\nuse DateInterval;\r\nuse DatePeriod;\r\nuse DateTimeImmutable;\r\nuse DateTimeInterface;\r\nuse DusanKasan\\Knapsack\\Collection;\r\nuse GuzzleHttp\\Client;\r\nuse League\\OAuth2\\Client\\Token\\AccessTokenInterface;\r\nuse SfEngineer\\Website\\Saas\\Model\\Activity\\ActivityInterface;\r\nuse SfEngineer\\Website\\Saas\\Model\\Activity\\ActivitySummaryInterface;\r\nuse SfEngineer\\Website\\Saas\\Model\\Sleep\\SleepInterface;\r\nuse SfEngineer\\Website\\Saas\\Plugins\\AccessTokens\\AccessTokenController;\r\nuse SfEngineer\\Website\\Saas\\Plugins\\ExternalDataSource\\DataSourceInterface;\r\nuse Tracy\\Debugger;\r\n\r\nfinal class GoogleFitController implements DataSourceInterface\r\n{\r\n    private const MAX_AGGREGATE_RANGE = 'P90D';\r\n\r\n    private const GOOGLE_FIT_SLEEP       = 72;\r\n    private const GOOGLE_FIT_LIGHT_SLEEP = 109;\r\n    private const GOOGLE_FIT_DEEP_SLEEP  = 110;\r\n    private const GOOGLE_FIT_REM_SLEEP   = 111;\r\n    private const GOOGLE_FIT_AWAKE_SLEEP  = 112;\r\n    private const ONE_DAY_IN_MILLISECONDS = 86400000;\r\n\r\n    private Client $googleFit;\r\n\r\n    private AccessTokenController $accessTokenController;\r\n\r\n    private GoogleProvider $googleProvider;\r\n\r\n    public function __construct(\r\n        Client $googleFit,\r\n        GoogleProvider $googleProvider,\r\n        AccessTokenController $accessTokenController\r\n    ) {\r\n        $this->accessTokenController = $accessTokenController;\r\n        $this->googleFit             = $googleFit;\r\n        $this->googleProvider        = $googleProvider;\r\n    }\r\n\r\n    public function lastSync(string $userId): ?DateTimeImmutable\r\n    {\r\n        return new DateTimeImmutable();\r\n    }\r\n\r\n    public function calories(string $userId, DateTimeInterface $start = null, DateTimeInterface $end = null): Collection\r\n    {\r\n        if ($start === null) {\r\n            $start = new DateTimeImmutable('- 30 days', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $start = new DateTimeImmutable($start->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        if ($end === null) {\r\n            $end = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $end = new DateTimeImmutable($end->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        $maxAggregateRange = new DateInterval(self::MAX_AGGREGATE_RANGE);\r\n        $period            = new DatePeriod($start, $maxAggregateRange, $end->add(new DateInterval('P1D')));\r\n        $accessToken       = $this->accessToken($userId);\r\n\r\n        return Collection::from(iterator_to_array($period))->map(function (DateTimeImmutable $periodStart) use (\r\n            $end,\r\n            $accessToken,\r\n            $maxAggregateRange\r\n        ) {\r\n            $periodEnd =\r\n                $periodStart->add($maxAggregateRange)->sub(new DateInterval('P1D'))->setTime(23, 59, 59, 999999);\r\n            if ($periodEnd > $end) {\r\n                $periodEnd = $end->setTime(23, 59, 59, 999999);\r\n            }\r\n\r\n            $caloriesAggregate = json_decode($this->googleFit->request('POST',\r\n                'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                    'headers' => [\r\n                        'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                    ], 'body' => json_encode([\r\n                        'aggregateBy'     => [\r\n                            [\r\n                                'dataTypeName' => 'com.google.calories.expended',\r\n                            ],\r\n                        ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                        'startTimeMillis' => (int) $periodStart->format('U') * 1000,\r\n                        'endTimeMillis'   => (int) $periodEnd->format('U') * 1000,\r\n                    ], JSON_THROW_ON_ERROR),\r\n                ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n\r\n            return Collection::from($caloriesAggregate['bucket'])\r\n                ->indexBy(static function (array $session): string {\r\n                    $date =\r\n                        DateTimeImmutable::createFromFormat('U', (string) ((int) ($session['endTimeMillis'] / 1000)),\r\n                            new\r\n                            \\DateTimeZone('UTC'));\r\n                    assert($date !== false);\r\n                    return $date->format('Y-m-d');\r\n                })\r\n                ->groupBy(static fn($_, string $key): string => $key)\r\n                ->map(static function (Collection $buckets): ?int {\r\n                    return $buckets->reduce(static function (?int $carry, array $bucket): ?int {\r\n                        $dataPoint = $bucket['dataset'][0]['point'];\r\n                        if ($dataPoint === []) {\r\n                            return $carry;\r\n                        }\r\n                        $dataPoint = $bucket['dataset'][0]['point'][0]['value'] ;\r\n                        if ($dataPoint === []) {\r\n                            return $carry;\r\n                        }\r\n                        if ($carry === null) {\r\n                            return (int) $dataPoint[0]['fpVal'];\r\n                        }\r\n                        return (int) min($carry, $dataPoint[0]['fpVal']);\r\n                    }, null);\r\n                });\r\n        })->flatten(1)->realize();\r\n    }\r\n\r\n    public function bodyFat(\r\n        string $userId,\r\n        ?DateTimeImmutable $start = null,\r\n        ?DateTimeImmutable $end = null\r\n    ): Collection {\r\n        if ($start === null) {\r\n            $start = new DateTimeImmutable('- 30 days', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $start = new DateTimeImmutable($start->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        if ($end === null) {\r\n            $end = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $end = new DateTimeImmutable($end->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        $maxAggregateRange = new DateInterval(self::MAX_AGGREGATE_RANGE);\r\n        $period            = new DatePeriod($start, $maxAggregateRange, $end->add(new DateInterval('P1D')));\r\n        $accessToken       = $this->accessToken($userId);\r\n\r\n        return Collection::from(iterator_to_array($period))->map(function (DateTimeImmutable $periodStart) use (\r\n            $end,\r\n            $accessToken,\r\n            $maxAggregateRange\r\n        ) {\r\n            $periodEnd =\r\n                $periodStart->add($maxAggregateRange)->sub(new DateInterval('P1D'))->setTime(23, 59, 59, 999999);\r\n            if ($periodEnd > $end) {\r\n                $periodEnd = $end->setTime(23, 59, 59, 999999);\r\n            }\r\n\r\n            $bodyFatAggregate = json_decode($this->googleFit->request('POST',\r\n                'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                    'headers' => [\r\n                        'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                    ], 'body' => json_encode([\r\n                        'aggregateBy'     => [\r\n                            [\r\n                                'dataTypeName' => 'com.google.body.fat.percentage',\r\n                            ],\r\n                        ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                        'startTimeMillis' => (int) $periodStart->format('U') * 1000,\r\n                        'endTimeMillis'   => (int) $periodEnd->format('U') * 1000,\r\n                    ], JSON_THROW_ON_ERROR),\r\n                ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n\r\n            return Collection::from($bodyFatAggregate['bucket'])\r\n                ->indexBy(static function (array $session): string {\r\n                    $date =\r\n                        DateTimeImmutable::createFromFormat('U', (string) ((int) ($session['endTimeMillis'] / 1000)),\r\n                            new\r\n                            \\DateTimeZone('UTC'));\r\n                    assert($date !== false);\r\n                    return $date->format('Y-m-d');\r\n                })\r\n                ->groupBy(static fn($_, string $key): string => $key)\r\n                ->map(static function (Collection $buckets): ?float {\r\n                    return $buckets->reduce(static function (?float $carry, array $bucket): ?float {\r\n                        $dataPoint = $bucket['dataset'][0]['point'];\r\n                        if ($dataPoint === []) {\r\n                            return $carry;\r\n                        }\r\n                        if ($carry === null) {\r\n                            return $dataPoint[0]['ftVal'];\r\n                        }\r\n                        return min($carry, $dataPoint[0]['ftVal']);\r\n                    }, null);\r\n                });\r\n        })->flatten(1)->realize();\r\n    }\r\n\r\n    public function activitySummary(string $userId, DateTimeInterface $date = null): ActivitySummaryInterface\r\n    {\r\n        if ($date === null) {\r\n            $date = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $date = new DateTimeImmutable($date->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        $start       = $date->setTime(0, 0, 0, 0);\r\n        $end         = $date->setTime(23, 59, 59, 999999);\r\n        $accessToken = $this->accessToken($userId);\r\n\r\n        $stepsAggregate       = json_decode($this->googleFit->request('POST',\r\n            'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                'headers' => [\r\n                    'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                ], 'body' => json_encode([\r\n                    'aggregateBy'     => [\r\n                        [\r\n                            'dataTypeName' => 'com.google.step_count.delta',\r\n                            'dataSourceId' => 'derived:com.google.step_count.delta:com.google.android.gms:estimated_steps',\r\n                        ],\r\n                    ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                    'startTimeMillis' => (int) $start->format('U') * 1000, 'endTimeMillis' => (int) $end->format('U') * 1000,\r\n                ], JSON_THROW_ON_ERROR),\r\n            ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        $steps                = $stepsAggregate['bucket'][0]['dataset'][0]['point'] === [] ? 0\r\n            : (int) $stepsAggregate['bucket'][0]['dataset'][0]['point'][0]['value'][0]['intVal'];\r\n        $caloriesAggregate    = json_decode($this->googleFit->request('POST',\r\n            'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                'headers' => [\r\n                    'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                ], 'body' => json_encode([\r\n                    'aggregateBy'     => [\r\n                        [\r\n                            'dataTypeName' => 'com.google.calories.expended',\r\n                        ],\r\n                    ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                    'startTimeMillis' => (int) $start->format('U') * 1000, 'endTimeMillis' => (int) $end->format('U') * 1000,\r\n                ], JSON_THROW_ON_ERROR),\r\n            ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        $calories             = $caloriesAggregate['bucket'][0]['dataset'][0]['point'] === [] ? 0\r\n            : (int) $caloriesAggregate['bucket'][0]['dataset'][0]['point'][0]['value'][0]['fpVal'];\r\n        $moveMinutesAggregate = json_decode($this->googleFit->request('POST',\r\n            'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                'headers' => [\r\n                    'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                ], 'body' => json_encode([\r\n                    'aggregateBy'     => [\r\n                        [\r\n                            'dataTypeName' => 'com.google.active_minutes',\r\n                        ],\r\n                    ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                    'startTimeMillis' => (int) $start->format('U') * 1000, 'endTimeMillis' => (int) $end->format('U') * 1000,\r\n                ], JSON_THROW_ON_ERROR),\r\n            ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        $moveMinutes          = $moveMinutesAggregate['bucket'][0]['dataset'][0]['point'] === [] ? 0\r\n            : (int) $moveMinutesAggregate['bucket'][0]['dataset'][0]['point'][0]['value'][0]['intVal'];\r\n\r\n        return new ActivitySummary($steps, $calories, $moveMinutes);\r\n    }\r\n\r\n    public function restingHeartRate(\r\n        string $userId,\r\n        DateTimeImmutable $start = null,\r\n        DateTimeImmutable $end = null\r\n    ): Collection {\r\n        return Collection::from([]);\r\n    }\r\n\r\n    public function sleepData(string $userId, DateTimeImmutable $start = null, ?DateTimeImmutable $end = null): array\r\n    {\r\n        if ($start === null) {\r\n            $start = new DateTimeImmutable('- 30 days', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $start = new DateTimeImmutable($start->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n        $start = $start->setTime(0, 0, 0, 0);\r\n\r\n        if ($end === null) {\r\n            $end = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $end = new DateTimeImmutable($end->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n        $end = $end->setTime(23, 59, 59, 999999);\r\n\r\n        $uri      = 'https://www.googleapis.com/fitness/v1/users/me/sessions?activityType=72&startTime='\r\n                    .$start->format('Y-m-d\\TH:i:s.v\\Z').'&endTime='.$end->format('Y-m-d\\TH:i:s.v\\Z');\r\n        $response = $this->googleFit->request('GET', $uri, [\r\n            'headers' => [\r\n                'Accept' => 'application/json', 'Authorization' => 'Bearer '.$this->accessToken($userId)->getToken(),\r\n            ],\r\n        ]);\r\n\r\n        $parsedResponse = json_decode($response->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n        if (array_key_exists('session', $parsedResponse) === false || $parsedResponse['session'] === []) {\r\n            return ['history' => Collection::from([])];\r\n        }\r\n\r\n        $data = Collection::from($parsedResponse['session'])->groupBy(static function (array $session\r\n        ): string {\r\n            $date =\r\n                DateTimeImmutable::createFromFormat('U', (string) ((int) ($session['endTimeMillis'] / 1000)), new\r\n                \\DateTimeZone('UTC'));\r\n            assert($date !== false);\r\n            return $date->format('Y-m-d');\r\n        })->map(static function (Collection $sessionsInADay): Collection {\r\n            return Collection::from($sessionsInADay->reduce(static function (array $carry, array $session): array {\r\n                $time = ($session['endTimeMillis'] - $session['startTimeMillis']) / 1000 / 60;\r\n                return [\r\n                    'duration'      => (int) ($carry['duration'] + $time),\r\n                    'minutesAsleep' => (int) ($carry['minutesAsleep'] + $time),\r\n                ];\r\n            }, ['duration' => 0, 'minutesAsleep' => 0]));\r\n        });\r\n\r\n        return [\r\n            'history' => $this->defaultCollection($start, $end)->map(static fn($_): Collection => Collection::from([\r\n                'duration' => null, 'minutesAsleep' => null,\r\n            ]))->replaceByKeys($data),\r\n        ];\r\n    }\r\n\r\n    public function sleep(string $userId, DateTimeInterface $date = null): SleepInterface\r\n    {\r\n        if ($date === null) {\r\n            $date = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $date = new DateTimeImmutable($date->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        $start = $date->setTime(0, 0, 0, 0);\r\n        $end   = $date->setTime(23, 59, 59, 999999);\r\n\r\n        $accessToken = $this->accessToken($userId);\r\n\r\n        $uri      = 'https://www.googleapis.com/fitness/v1/users/me/sessions?activityType=72&startTime='\r\n                    .$start->format('Y-m-d\\TH:i:s.v\\Z').'&endTime='.$end->format('Y-m-d\\TH:i:s.v\\Z');\r\n        $response = $this->googleFit->request('GET', $uri, [\r\n            'headers' => [\r\n                'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n            ],\r\n        ]);\r\n\r\n        $parsedResponse = json_decode($response->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n\r\n        if (array_key_exists('session', $parsedResponse) === false || $parsedResponse['session'] === []) {\r\n            return new class implements SleepInterface {\r\n\r\n                private const GOAL = 8.0;\r\n\r\n                public function hoursSlept(): float\r\n                {\r\n                    return 0.0;\r\n                }\r\n\r\n                public function hoursGoal(): float\r\n                {\r\n                    return self::GOAL;\r\n                }\r\n\r\n                public function hoursRemainingToGoal(): float\r\n                {\r\n                    return $this->hoursGoal() - $this->hoursSlept();\r\n                }\r\n\r\n                public function sleptRatioOfGoal(): float\r\n                {\r\n                    return $this->hoursSlept() / $this->hoursGoal();\r\n                }\r\n\r\n                public function score(): ?int\r\n                {\r\n                    return null;\r\n                }\r\n            };\r\n        }\r\n\r\n        $sleptNanoseconds = Collection::from($parsedResponse['session'])->map(function (array $session) use (\r\n            $end,\r\n            $start,\r\n            $accessToken\r\n        ): Collection {\r\n            $response       =\r\n                $this->googleFit->request('POST', 'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                    'headers' => [\r\n                        'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                    ], 'body' => json_encode([\r\n                        'aggregateBy'        => [\r\n                            [\r\n                                'dataTypeName' => 'com.google.activity.segment',\r\n                            ],\r\n                        ], 'startTimeMillis' => $session['startTimeMillis'],\r\n                        'endTimeMillis'      => $session['endTimeMillis'],\r\n                    ], JSON_THROW_ON_ERROR),\r\n                ]);\r\n            $parsedResponse = json_decode($response->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n            return Collection::from($parsedResponse['bucket'][0]['dataset'][0]['point'])->reject(static fn(\r\n                array $dataPoint\r\n            ): bool => $dataPoint['value'][0]['intVal'] !== self::GOOGLE_FIT_SLEEP)->filter(static function (\r\n                array $dataPoint\r\n            ) use ($start, $end): bool {\r\n                $dataEnd =\r\n                    DateTimeImmutable::createFromFormat('U', (string) ($dataPoint['endTimeNanos'] / 1000000000), new\r\n                    \\DateTimeZone('UTC'));\r\n                return $dataEnd > $start && $dataEnd < $end;\r\n            });\r\n        })->flatten(1)->reduce(static function (int $carry, array $current): int {\r\n            return $carry + $current['endTimeNanos'] - $current['startTimeNanos'];\r\n        }, 0);\r\n\r\n        return new class($sleptNanoseconds) implements SleepInterface {\r\n\r\n            private const GOAL = 8.0;\r\n\r\n            private float $slept;\r\n\r\n            public function __construct(int $sleptNanoseconds)\r\n            {\r\n                $this->slept = (float) $sleptNanoseconds / 1000000000.0 / 3600.0;\r\n            }\r\n\r\n            public function hoursSlept(): float\r\n            {\r\n                return $this->slept;\r\n            }\r\n\r\n            public function hoursGoal(): float\r\n            {\r\n                return self::GOAL;\r\n            }\r\n\r\n            public function hoursRemainingToGoal(): float\r\n            {\r\n                return $this->hoursGoal() - $this->hoursSlept();\r\n            }\r\n\r\n            public function sleptRatioOfGoal(): float\r\n            {\r\n                return $this->hoursSlept() / $this->hoursGoal();\r\n            }\r\n\r\n            public function score(): ?int\r\n            {\r\n                return null;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @param  string  $userId\r\n     * @return \\League\\OAuth2\\Client\\Token\\AccessTokenInterface\r\n     * @throws \\RuntimeException if there is no access token for the user\r\n     * @throws \\League\\OAuth2\\Client\\Provider\\Exception\\IdentityProviderException\r\n     */\r\n    private function accessToken(string $userId): AccessTokenInterface\r\n    {\r\n        $accessToken = $this->accessTokenController->getTokenFor($userId, AccessTokenController::GOOGLE_FIT);\r\n        if ($accessToken->hasExpired()) {\r\n            $newToken = $this->googleProvider->getAccessToken('refreshToken', [\r\n                'refresh_token' => $accessToken->getRefreshToken(),\r\n            ]);\r\n            $this->accessTokenController->storeTokenFor($newToken, $userId, AccessTokenController::GOOGLE_FIT);\r\n            return $newToken;\r\n        }\r\n        return $accessToken;\r\n    }\r\n\r\n    /**\r\n     * @return \\DusanKasan\\Knapsack\\Collection<string, null>\r\n     * @throws \\Exception\r\n     */\r\n    private function defaultCollection(DateTimeImmutable $start, DateTimeImmutable $end): Collection\r\n    {\r\n        $period = new DatePeriod($start, new DateInterval('P1D'), $end->add(new DateInterval('P1D')));\r\n        return Collection::from(iterator_to_array($period))->map(static fn(DateTimeInterface $dateTime\r\n        ): string => $dateTime->format('Y-m-d'))->flip()->map(static fn(string $_): ?bool => null);\r\n    }\r\n\r\n    public function weight(string $userId, ?DateTimeImmutable $start, ?DateTimeImmutable $end): Collection\r\n    {\r\n        if ($start === null) {\r\n            $start = new DateTimeImmutable('- 30 days', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $start = new DateTimeImmutable($start->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        if ($end === null) {\r\n            $end = new DateTimeImmutable('now', new \\DateTimeZone('UTC'));\r\n        } else {\r\n            $end = new DateTimeImmutable($end->format('Y-m-d'), new \\DateTimeZone('UTC'));\r\n        }\r\n\r\n        $maxAggregateRange = new DateInterval(self::MAX_AGGREGATE_RANGE);\r\n        $period            = new DatePeriod($start, $maxAggregateRange, $end->add(new DateInterval('P1D')));\r\n        $accessToken       = $this->accessToken($userId);\r\n\r\n        $bodyFat = $this->bodyFat($userId, $start, $end);\r\n\r\n        return Collection::from(iterator_to_array($period))->map(function (DateTimeImmutable $periodStart) use (\r\n            $bodyFat,\r\n            $accessToken,\r\n            $maxAggregateRange,\r\n            $end\r\n        ) {\r\n            $periodEnd =\r\n                $periodStart->add($maxAggregateRange)->sub(new DateInterval('P1D'))->setTime(23, 59, 59, 999999);\r\n            if ($periodEnd > $end) {\r\n                $periodEnd = $end->setTime(23, 59, 59, 999999);\r\n            }\r\n\r\n            $weightAggregate = json_decode($this->googleFit->request('POST',\r\n                'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate', [\r\n                    'headers' => [\r\n                        'Accept' => 'application/json', 'Authorization' => 'Bearer '.$accessToken->getToken(),\r\n                    ], 'body' => json_encode([\r\n                        'aggregateBy'     => [\r\n                            [\r\n                                'dataTypeName' => 'com.google.weight',\r\n                            ],\r\n                        ], \"bucketByTime\" => ['durationMillis' => self::ONE_DAY_IN_MILLISECONDS],\r\n                        'startTimeMillis' => (int) $periodStart->format('U') * 1000,\r\n                        'endTimeMillis'   => (int) $periodEnd->format('U') * 1000,\r\n                    ], JSON_THROW_ON_ERROR),\r\n                ])->getBody()->getContents(), true, 512, JSON_THROW_ON_ERROR);\r\n            return Collection::from($weightAggregate['bucket'])\r\n                ->indexBy(static function (array $session): string {\r\n                    $date = DateTimeImmutable::createFromFormat('U',\r\n                        (string) ((int) ((int) $session['endTimeMillis'] / 1000)), new\r\n                        \\DateTimeZone('UTC'));\r\n                    assert($date !== false);\r\n                    return $date->format('Y-m-d');\r\n                })\r\n                ->groupBy(static fn($_, string $key): string => $key)\r\n                ->map(static function (Collection $buckets): ?float {\r\n                    return $buckets->reduce(static function (?float $carry, array $bucket): ?float {\r\n                        $dataPoint = $bucket['dataset'][0]['point'];\r\n                        if ($dataPoint === []) {\r\n                            return $carry;\r\n                        }\r\n                        $weight = Collection::from($dataPoint[0]['value'])->reduce(static function (\r\n                            ?float $carry,\r\n                            array $data\r\n                        ): ?float {\r\n                            $value = $data['fpVal'];\r\n                            if ($carry === null) {\r\n                                return $value;\r\n                            }\r\n                            return min($carry, $value);\r\n                        }, null);\r\n                        if ($carry === null) {\r\n                            return $weight;\r\n                        }\r\n                        if ($weight === null) {\r\n                            return $carry;\r\n                        }\r\n                        return min($carry, $weight);\r\n                    }, null);\r\n                })\r\n                ->map(static function (?float $weight, string $date) use ($bodyFat): array {\r\n                    $fat = $bodyFat->get($date);\r\n                    return [\r\n                        'fatPercentage' => $fat, 'weight' => $weight,\r\n                        'fatMass'       => $fat === null || $weight === null ? null : round($fat * $weight / 100, 2),\r\n                        'BMI'           => null,\r\n                    ];\r\n                });\r\n        })->flatten(1)->realize();\r\n    }\r\n\r\n}\r\n```","closed_by":{"login":"muglug","id":2292638,"node_id":"MDQ6VXNlcjIyOTI2Mzg=","avatar_url":"https://avatars.githubusercontent.com/u/2292638?v=4","gravatar_id":"","url":"https://api.github.com/users/muglug","html_url":"https://github.com/muglug","followers_url":"https://api.github.com/users/muglug/followers","following_url":"https://api.github.com/users/muglug/following{/other_user}","gists_url":"https://api.github.com/users/muglug/gists{/gist_id}","starred_url":"https://api.github.com/users/muglug/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/muglug/subscriptions","organizations_url":"https://api.github.com/users/muglug/orgs","repos_url":"https://api.github.com/users/muglug/repos","events_url":"https://api.github.com/users/muglug/events{/privacy}","received_events_url":"https://api.github.com/users/muglug/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/vimeo/psalm/issues/3755/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/vimeo/psalm/issues/3755/timeline","performed_via_github_app":null,"state_reason":"completed"}