diff --git a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
index 00a3a8f25..7537b2225 100644
--- a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
@@ -972,7 +972,9 @@ class ClassAnalyzer extends ClassLikeAnalyzer
             }
         }
 
-        foreach ($storage->pseudo_methods as $pseudo_method_name => $pseudo_method_storage) {
+        $pseudo_methods = $storage->pseudo_methods + $storage->pseudo_static_methods;
+
+        foreach ($pseudo_methods as $pseudo_method_name => $pseudo_method_storage) {
             $pseudo_method_id = $this->fq_class_name . '::' . $pseudo_method_name;
 
             $overridden_method_ids = $codebase->methods->getOverriddenMethodIds($pseudo_method_id);
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticCallAnalyzer.php
index 088a43485..89c98cde5 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticCallAnalyzer.php
@@ -398,6 +398,8 @@ class StaticCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                     }
                 }
 
+                $class_storage = $codebase->classlike_storage_provider->get($fq_class_name);
+
                 if (!$codebase->methods->methodExists(
                     $method_id,
                     $context->calling_function_id,
@@ -410,6 +412,8 @@ class StaticCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                         $context,
                         $statements_analyzer->getSource()
                     )
+                    || (isset($class_storage->pseudo_static_methods[$method_name_lc])
+                        && ($config->use_phpdoc_method_without_magic_or_parent || $class_storage->parent_class))
                 ) {
                     if ($codebase->methods->methodExists(
                         $fq_class_name . '::__callStatic',
@@ -418,60 +422,24 @@ class StaticCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                         null,
                         $statements_analyzer->getFilePath()
                     )) {
-                        $class_storage = $codebase->classlike_storage_provider->get($fq_class_name);
-
                         if (isset($class_storage->pseudo_static_methods[$method_name_lc])) {
                             $pseudo_method_storage = $class_storage->pseudo_static_methods[$method_name_lc];
 
-                            if (self::checkFunctionArguments(
+                            if (self::checkPseudoMethod(
                                 $statements_analyzer,
-                                $args,
-                                $pseudo_method_storage->params,
+                                $stmt,
                                 $method_id,
-                                $context
-                            ) === false) {
-                                return false;
-                            }
-
-                            if (self::checkFunctionLikeArgumentsMatch(
-                                $statements_analyzer,
+                                $fq_class_name,
                                 $args,
-                                null,
-                                $pseudo_method_storage->params,
+                                $class_storage,
                                 $pseudo_method_storage,
-                                null,
-                                null,
-                                new CodeLocation($source, $stmt),
                                 $context
-                            ) === false) {
+                            ) === false
+                            ) {
                                 return false;
                             }
 
                             if ($pseudo_method_storage->return_type) {
-                                $return_type_candidate = clone $pseudo_method_storage->return_type;
-
-                                $return_type_candidate = ExpressionAnalyzer::fleshOutType(
-                                    $codebase,
-                                    $return_type_candidate,
-                                    $fq_class_name,
-                                    $fq_class_name,
-                                    $class_storage->parent_class
-                                );
-
-                                $stmt_type = $statements_analyzer->node_data->getType($stmt);
-
-                                if (!$stmt_type) {
-                                    $statements_analyzer->node_data->setType($stmt, $return_type_candidate);
-                                } else {
-                                    $statements_analyzer->node_data->setType(
-                                        $stmt,
-                                        Type::combineUnionTypes(
-                                            $return_type_candidate,
-                                            $stmt_type
-                                        )
-                                    );
-                                }
-
                                 return;
                             }
                         } else {
@@ -502,6 +470,28 @@ class StaticCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                         ];
 
                         $method_id = $fq_class_name . '::__callstatic';
+                    } elseif (isset($class_storage->pseudo_static_methods[$method_name_lc])
+                        && ($config->use_phpdoc_method_without_magic_or_parent || $class_storage->parent_class)
+                    ) {
+                        $pseudo_method_storage = $class_storage->pseudo_static_methods[$method_name_lc];
+
+                        if (self::checkPseudoMethod(
+                            $statements_analyzer,
+                            $stmt,
+                            $method_id,
+                            $fq_class_name,
+                            $args,
+                            $class_storage,
+                            $pseudo_method_storage,
+                            $context
+                        ) === false
+                        ) {
+                            return false;
+                        }
+
+                        if ($pseudo_method_storage->return_type) {
+                            return;
+                        }
                     }
 
                     if (!$context->check_methods) {
@@ -1179,4 +1169,68 @@ class StaticCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
             $statements_analyzer->node_data->setType($stmt, Type::getMixed());
         }
     }
+
+    /**
+     * @return false|null
+     */
+    private static function checkPseudoMethod(
+        StatementsAnalyzer $statements_analyzer,
+        PhpParser\Node\Expr\StaticCall $stmt,
+        string $method_id,
+        string $fq_class_name,
+        array $args,
+        \Psalm\Storage\ClassLikeStorage $class_storage,
+        \Psalm\Storage\MethodStorage $pseudo_method_storage,
+        Context $context
+    ) {
+        if (self::checkFunctionArguments(
+            $statements_analyzer,
+            $args,
+            $pseudo_method_storage->params,
+            $method_id,
+            $context
+        ) === false) {
+            return false;
+        }
+
+        if (self::checkFunctionLikeArgumentsMatch(
+            $statements_analyzer,
+            $args,
+            null,
+            $pseudo_method_storage->params,
+            $pseudo_method_storage,
+            null,
+            null,
+            new CodeLocation($statements_analyzer, $stmt),
+            $context
+        ) === false) {
+            return false;
+        }
+
+        if ($pseudo_method_storage->return_type) {
+            $return_type_candidate = clone $pseudo_method_storage->return_type;
+
+            $return_type_candidate = ExpressionAnalyzer::fleshOutType(
+                $statements_analyzer->getCodebase(),
+                $return_type_candidate,
+                $fq_class_name,
+                $fq_class_name,
+                $class_storage->parent_class
+            );
+
+            $stmt_type = $statements_analyzer->node_data->getType($stmt);
+
+            if (!$stmt_type) {
+                $statements_analyzer->node_data->setType($stmt, $return_type_candidate);
+            } else {
+                $statements_analyzer->node_data->setType(
+                    $stmt,
+                    Type::combineUnionTypes(
+                        $return_type_candidate,
+                        $stmt_type
+                    )
+                );
+            }
+        }
+    }
 }
diff --git a/src/Psalm/Internal/Visitor/ReflectorVisitor.php b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
index b7e376b8c..6f8dea417 100644
--- a/src/Psalm/Internal/Visitor/ReflectorVisitor.php
+++ b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
@@ -1629,6 +1629,7 @@ class ReflectorVisitor extends PhpParser\NodeVisitorAbstract implements PhpParse
             $storage = new MethodStorage();
             $storage->defining_fqcln = '';
             $storage->is_static = $stmt->isStatic();
+            $class_storage = $this->classlike_storages[count($this->classlike_storages) - 1];
         } elseif ($stmt instanceof PhpParser\Node\Stmt\Function_) {
             $cased_function_id =
                 ($this->aliases->namespace ? $this->aliases->namespace . '\\' : '') . $stmt->name->name;
diff --git a/tests/MagicMethodAnnotationTest.php b/tests/MagicMethodAnnotationTest.php
index 1fd41640a..8b6bf031c 100644
--- a/tests/MagicMethodAnnotationTest.php
+++ b/tests/MagicMethodAnnotationTest.php
@@ -559,6 +559,23 @@ class MagicMethodAnnotationTest extends TestCase
                     $child->boolean(5);
                     $child->integer(5);'
             ],
+            'overrideWithSelfBeforeMethodName' => [
+                '<?php
+                    class A {
+                        public static function make(): self {
+                            return new self();
+                        }
+                    }
+
+                    /**
+                     * @method static self make()
+                     */
+                    class B extends A {}
+
+                    function makeB(): B {
+                        return B::make();
+                    }'
+            ],
         ];
     }
 
