diff --git a/config.xsd b/config.xsd
index 634b3de26..e03e0b623 100644
--- a/config.xsd
+++ b/config.xsd
@@ -413,6 +413,7 @@
             <xs:element name="RedundantIdentityWithTrue" type="IssueHandlerType" minOccurs="0" />
             <xs:element name="RedundantPropertyInitializationCheck" type="IssueHandlerType" minOccurs="0" />
             <xs:element name="ReferenceConstraintViolation" type="IssueHandlerType" minOccurs="0" />
+            <xs:element name="ReferenceReusedFromConfusingScope" type="IssueHandlerType" minOccurs="0" />
             <xs:element name="ReservedWord" type="IssueHandlerType" minOccurs="0" />
             <xs:element name="StringIncrement" type="IssueHandlerType" minOccurs="0" />
             <xs:element name="TaintedCallable" type="IssueHandlerType" minOccurs="0" />
diff --git a/docs/running_psalm/issues/ReferenceReusedFromConfusingScope.md b/docs/running_psalm/issues/ReferenceReusedFromConfusingScope.md
new file mode 100644
index 000000000..b280e4948
--- /dev/null
+++ b/docs/running_psalm/issues/ReferenceReusedFromConfusingScope.md
@@ -0,0 +1,39 @@
+# ReferenceReusedFromConfusingScope
+
+Emitted when a reference assigned in a potentially confusing scope is reused later.
+Since PHP doesn't scope loops and ifs the same way most other languages do, a common issue is the reuse of a variable
+declared in such a scope. Usually it doesn't matter, because a reassignment to an already-defined variable will just
+reassign it, but if the already-defined variable is a reference it will change the value of the referred to variable.
+
+```php
+<?php
+
+$arr = [1, 2, 3];
+foreach ($arr as &$i) {
+    ++$i;
+}
+
+// ...more code, after which the usage of $i as a reference has been forgotten by the programmer
+
+for ($i = 0; $i < 10; ++$i) {
+    echo $i;
+}
+// $arr is now [2, 3, 10] instead of the expected [2, 3, 4]
+```
+
+To fix the issue, unset the reference after using it in such a scope:
+
+```php
+<?php
+
+$arr = [1, 2, 3];
+foreach ($arr as &$i) {
+    ++$i;
+}
+unset($i);
+
+for ($i = 0; $i < 10; ++$i) {
+    echo $i;
+}
+// $arr is correctly [2, 3, 4]
+```
diff --git a/src/Psalm/Codebase.php b/src/Psalm/Codebase.php
index 0a30f27ea..ef309d7fe 100644
--- a/src/Psalm/Codebase.php
+++ b/src/Psalm/Codebase.php
@@ -1966,9 +1966,7 @@ class Codebase
 
         $this->taint_flow_graph->addSource($source);
 
-        $expr_type->parent_nodes = [
-            $source->id => $source,
-        ];
+        $expr_type->parent_nodes[$source->id] = $source;
     }
 
     /**
diff --git a/src/Psalm/Context.php b/src/Psalm/Context.php
index eba6e9a44..5d624e17b 100644
--- a/src/Psalm/Context.php
+++ b/src/Psalm/Context.php
@@ -13,6 +13,7 @@ use Psalm\Storage\FunctionLikeStorage;
 use Psalm\Type\Atomic\DependentType;
 use Psalm\Type\Atomic\TArray;
 use Psalm\Type\Union;
+use RuntimeException;
 
 use function array_keys;
 use function array_search;
@@ -40,6 +41,54 @@ class Context
      */
     public $vars_possibly_in_scope = [];
 
+    /**
+     * Keeps track of how many times a var_in_scope has been referenced. May not be set for all $vars_in_scope.
+     *
+     * @var array<string, int<0, max>>
+     */
+    public $referenced_counts = [];
+
+    /**
+     * Maps references to referenced variables for the current scope.
+     * With `$b = &$a`, this will contain `['$b' => '$a']`.
+     *
+     * All keys and values in this array are guaranteed to be set in $vars_in_scope.
+     *
+     * To check if a variable was passed or returned by reference, or
+     * references an object property or array item, see Union::$by_ref.
+     *
+     * @var array<string, string>
+     */
+    public $references_in_scope = [];
+
+    /**
+     * Set of references to variables in another scope. These references will be marked as used if they are assigned to.
+     *
+     * @var array<string, true>
+     */
+    public $references_to_external_scope = [];
+
+    /**
+     * A set of globals that are referenced somewhere.
+     * Ideally this shouldn't be needed and GlobalAnalyzer should add an edge to the
+     * DataFlowGraph pointing from the global to its use in another scope, but since that's
+     * difficult this is used as a workaround to always mark referenced globals as used.
+     *
+     * @internal May be removed if GlobalAnalyzer is improved.
+     *
+     * @var array<string, true>
+     */
+    public $referenced_globals = [];
+
+    /**
+     * A set of references that might still be in scope from a scope likely to cause confusion. This applies
+     * to references set inside a loop or if statement, since it's easy to forget about PHP's weird scope
+     * rules, and assinging to a reference will change the referenced variable rather than shadowing it.
+     *
+     * @var array<string, CodeLocation>
+     */
+    public $references_possibly_from_confusing_scope = [];
+
     /**
      * Whether or not we're inside the conditional of an if/where etc.
      *
@@ -362,11 +411,6 @@ class Context
      */
     public $has_returned = false;
 
-    /**
-     * @var array<string, bool>
-     */
-    public $vars_from_global = [];
-
     /**
      * @var array<string, true>
      */
@@ -449,6 +493,28 @@ class Context
         }
     }
 
+    /**
+     * Updates the list of possible references from a confusing scope,
+     * such as a reference created in an if and then later reused.
+     */
+    public function updateReferencesPossiblyFromConfusingScope(
+        Context $confusing_scope_context,
+        StatementsAnalyzer $statements_analyzer
+    ): void {
+        foreach ($confusing_scope_context->references_in_scope + $confusing_scope_context->references_to_external_scope
+            as $reference_id => $_
+        ) {
+            if (!isset($this->references_in_scope[$reference_id])
+                && !isset($this->references_to_external_scope[$reference_id])
+                && $reference_location = $statements_analyzer->getFirstAppearance($reference_id)
+            ) {
+                $this->references_possibly_from_confusing_scope[$reference_id] = $reference_location;
+            }
+        }
+        $this->references_possibly_from_confusing_scope +=
+            $confusing_scope_context->references_possibly_from_confusing_scope;
+    }
+
     /**
      * @param  array<string, Union> $new_vars_in_scope
      *
@@ -496,19 +562,39 @@ class Context
         return $redefined_var_ids;
     }
 
-    public function remove(string $remove_var_id): void
+    public function remove(string $remove_var_id, bool $removeDescendents = true): void
     {
-        unset(
-            $this->referenced_var_ids[$remove_var_id],
-            $this->vars_possibly_in_scope[$remove_var_id]
-        );
-
         if (isset($this->vars_in_scope[$remove_var_id])) {
             $existing_type = $this->vars_in_scope[$remove_var_id];
             unset($this->vars_in_scope[$remove_var_id]);
 
-            $this->removeDescendents($remove_var_id, $existing_type);
+            if ($removeDescendents) {
+                $this->removeDescendents($remove_var_id, $existing_type);
+            }
         }
+        $this->removePossibleReference($remove_var_id);
+        unset($this->vars_possibly_in_scope[$remove_var_id]);
+    }
+
+    /**
+     * Remove a variable from the context which might be a reference to another variable.
+     * Leaves the variable as possibly-in-scope, unlike remove().
+     */
+    public function removePossibleReference(string $remove_var_id): void
+    {
+        if (isset($this->references_in_scope[$remove_var_id])) {
+            $reference_count = &$this->referenced_counts[$this->references_in_scope[$remove_var_id]];
+            if ($reference_count < 1) {
+                throw new RuntimeException("Incorrect referenced count found");
+            }
+            --$reference_count;
+        }
+        unset(
+            $this->vars_in_scope[$remove_var_id],
+            $this->referenced_var_ids[$remove_var_id],
+            $this->references_in_scope[$remove_var_id],
+            $this->references_to_external_scope[$remove_var_id],
+        );
     }
 
     /**
@@ -645,7 +731,7 @@ class Context
 
         foreach ($this->vars_in_scope as $var_id => $type) {
             if (preg_match('/' . preg_quote($remove_var_id, '/') . '[\]\[\-]/', $var_id)) {
-                unset($this->vars_in_scope[$var_id]);
+                $this->remove($var_id, false);
             }
 
             foreach ($type->getAtomicTypes() as $atomic_type) {
@@ -676,7 +762,7 @@ class Context
         }
 
         foreach ($vars_to_remove as $var_id) {
-            unset($this->vars_in_scope[$var_id], $this->vars_possibly_in_scope[$var_id]);
+            $this->remove($var_id, false);
         }
 
         $clauses_to_keep = [];
diff --git a/src/Psalm/Internal/Analyzer/ClosureAnalyzer.php b/src/Psalm/Internal/Analyzer/ClosureAnalyzer.php
index aabb0f43f..cbed8f768 100644
--- a/src/Psalm/Internal/Analyzer/ClosureAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/ClosureAnalyzer.php
@@ -159,6 +159,7 @@ class ClosureAnalyzer extends FunctionLikeAnalyzer
 
                 if ($use->byRef) {
                     $use_context->vars_in_scope[$use_var_id]->by_ref = true;
+                    $use_context->references_to_external_scope[$use_var_id] = true;
                 }
 
                 $use_context->vars_possibly_in_scope[$use_var_id] = true;
diff --git a/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php b/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php
index d329e7f8c..8e767dd32 100644
--- a/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php
@@ -771,7 +771,7 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
 
             foreach ($context->vars_in_scope as $var => $_) {
                 if (strpos($var, '$this->') !== 0 && $var !== '$this') {
-                    unset($context->vars_in_scope[$var]);
+                    $context->removePossibleReference($var);
                 }
             }
 
@@ -854,10 +854,6 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
                 throw new UnexpectedValueException('$position should not be false here');
             }
 
-            if ($storage->params[$position]->by_ref) {
-                continue;
-            }
-
             if ($storage->params[$position]->promoted_property) {
                 continue;
             }
@@ -984,6 +980,7 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
         $project_analyzer = $statements_analyzer->getProjectAnalyzer();
 
         foreach ($params as $offset => $function_param) {
+            $function_param_id = '$' . $function_param->name;
             $signature_type = $function_param->signature_type;
             $signature_type_location = $function_param->signature_type_location;
 
@@ -1087,7 +1084,7 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
                         && !$function_param->type->isBool())
                 ) {
                     $param_assignment = DataFlowNode::getForAssignment(
-                        '$' . $function_param->name,
+                        $function_param_id,
                         $function_param->location
                     );
 
@@ -1105,16 +1102,6 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
                         $statements_analyzer->data_flow_graph->addPath($type_source, $param_assignment, 'param');
                     }
 
-                    if ($function_param->by_ref
-                        && $codebase->find_unused_variables
-                    ) {
-                        $statements_analyzer->data_flow_graph->addPath(
-                            $param_assignment,
-                            new DataFlowNode('variable-use', 'variable use', null),
-                            'variable-use'
-                        );
-                    }
-
                     if ($storage->variadic) {
                         $this->param_nodes += [$param_assignment->id => $param_assignment];
                     }
@@ -1123,18 +1110,19 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
                 }
             }
 
-            $context->vars_in_scope['$' . $function_param->name] = $var_type;
-            $context->vars_possibly_in_scope['$' . $function_param->name] = true;
+            $context->vars_in_scope[$function_param_id] = $var_type;
+            $context->vars_possibly_in_scope[$function_param_id] = true;
 
             if ($function_param->by_ref) {
-                $context->vars_in_scope['$' . $function_param->name]->by_ref = true;
+                $context->vars_in_scope[$function_param_id]->by_ref = true;
+                $context->references_to_external_scope[$function_param_id] = true;
             }
 
             $parser_param = $this->function->getParams()[$offset] ?? null;
 
             if ($function_param->location) {
                 $statements_analyzer->registerVariable(
-                    '$' . $function_param->name,
+                    $function_param_id,
                     $function_param->location,
                     null
                 );
@@ -1170,7 +1158,7 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
 
                     IssueBuffer::maybeAdd(
                         new MismatchingDocblockParamType(
-                            'Parameter $' . $function_param->name . ' has wrong type \'' . $param_type .
+                            'Parameter ' . $function_param_id . ' has wrong type \'' . $param_type .
                                 '\', should be \'' . $signature_type . '\'',
                             $function_param->type_location
                         ),
@@ -1271,13 +1259,6 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer
                 }
             }
 
-            if ($function_param->by_ref) {
-                // register by ref params as having been used, to avoid false positives
-                // @todo change the assignment analysis *just* for byref params
-                // so that we don't have to do this
-                $context->hasVariable('$' . $function_param->name);
-            }
-
             foreach ($function_param->attributes as $attribute) {
                 AttributeAnalyzer::analyze(
                     $this,
diff --git a/src/Psalm/Internal/Analyzer/Statements/Block/ForeachAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Block/ForeachAnalyzer.php
index f03f3d0a0..31b465a10 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Block/ForeachAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Block/ForeachAnalyzer.php
@@ -298,6 +298,15 @@ class ForeachAnalyzer
             $value_type->by_ref = true;
         }
 
+        if ($stmt->byRef
+            && $stmt->valueVar instanceof PhpParser\Node\Expr\Variable
+            && is_string($stmt->valueVar->name)
+        ) {
+            // When assigning as reference, it removes any previous
+            // reference, so it's no longer from a previous confusing scope
+            unset($foreach_context->references_possibly_from_confusing_scope['$' . $stmt->valueVar->name]);
+        }
+
         AssignmentAnalyzer::analyze(
             $statements_analyzer,
             $stmt->valueVar,
@@ -311,6 +320,14 @@ class ForeachAnalyzer
                 : []
         );
 
+        if ($stmt->byRef
+            && $stmt->valueVar instanceof PhpParser\Node\Expr\Variable
+            && is_string($stmt->valueVar->name)
+        ) {
+            // TODO support references with destructuring
+            $foreach_context->references_to_external_scope['$' . $stmt->valueVar->name] = true;
+        }
+
         foreach ($var_comments as $var_comment) {
             if (!$var_comment->var_id || !$var_comment->type) {
                 continue;
diff --git a/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseAnalyzer.php
index ad7ba5c7d..2b0be2e17 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseAnalyzer.php
@@ -97,7 +97,7 @@ class ElseAnalyzer
                     if (preg_match('/' . preg_quote($changed_var_id, '/') . '[\]\[\-]/', $var_id)
                         && !array_key_exists($var_id, $changed_var_ids)
                     ) {
-                        unset($else_context->vars_in_scope[$var_id]);
+                        $else_context->removePossibleReference($var_id);
                     }
                 }
             }
@@ -243,6 +243,12 @@ class ElseAnalyzer
             $outer_context->mergeExceptions($else_context);
         }
 
+        // Track references set in the else to make sure they aren't reused later
+        $outer_context->updateReferencesPossiblyFromConfusingScope(
+            $else_context,
+            $statements_analyzer
+        );
+
         return null;
     }
 }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseIfAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseIfAnalyzer.php
index 0a5ec037a..ff10838d3 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseIfAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/ElseIfAnalyzer.php
@@ -255,7 +255,7 @@ class ElseIfAnalyzer
                             && !array_key_exists($var_id, $newly_reconciled_var_ids)
                             && !array_key_exists($var_id, $cond_referenced_var_ids)
                         ) {
-                            unset($elseif_context->vars_in_scope[$var_id]);
+                            $elseif_context->removePossibleReference($var_id);
                         }
                     }
                 }
@@ -434,6 +434,12 @@ class ElseIfAnalyzer
             $if_scope->negated_clauses = [];
         }
 
+        // Track references set in the elseif to make sure they aren't reused later
+        $outer_context->updateReferencesPossiblyFromConfusingScope(
+            $elseif_context,
+            $statements_analyzer
+        );
+
         return null;
     }
 }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/IfAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/IfAnalyzer.php
index 51b8e80dd..c33eb147f 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/IfAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Block/IfElse/IfAnalyzer.php
@@ -254,6 +254,12 @@ class IfAnalyzer
             $outer_context->mergeExceptions($if_context);
         }
 
+        // Track references set in the if to make sure they aren't reused later
+        $outer_context->updateReferencesPossiblyFromConfusingScope(
+            $if_context,
+            $statements_analyzer
+        );
+
         return null;
     }
 
diff --git a/src/Psalm/Internal/Analyzer/Statements/Block/IfElseAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Block/IfElseAnalyzer.php
index a3bf7c900..837873c3a 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Block/IfElseAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Block/IfElseAnalyzer.php
@@ -297,7 +297,7 @@ class IfElseAnalyzer
                             && !array_key_exists($var_id, $changed_var_ids)
                             && !array_key_exists($var_id, $cond_referenced_var_ids)
                         ) {
-                            unset($if_context->vars_in_scope[$var_id]);
+                            $if_context->removePossibleReference($var_id);
                         }
                     }
                 }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Block/LoopAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Block/LoopAnalyzer.php
index 13683b2ac..c49155bad 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Block/LoopAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Block/LoopAnalyzer.php
@@ -317,7 +317,7 @@ class LoopAnalyzer
 
                 // remove vars that were defined in the foreach
                 foreach ($vars_to_remove as $var_id) {
-                    unset($inner_context->vars_in_scope[$var_id]);
+                    $inner_context->removePossibleReference($var_id);
                 }
 
                 $inner_context->clauses = $pre_loop_context->clauses;
@@ -360,7 +360,7 @@ class LoopAnalyzer
                         if (isset($pre_loop_context->vars_in_scope[$var_id])) {
                             $inner_context->vars_in_scope[$var_id] = clone $pre_loop_context->vars_in_scope[$var_id];
                         } else {
-                            unset($inner_context->vars_in_scope[$var_id]);
+                            $inner_context->removePossibleReference($var_id);
                         }
                     }
                 }
@@ -453,7 +453,7 @@ class LoopAnalyzer
         if (!$does_always_break) {
             foreach ($loop_scope->loop_parent_context->vars_in_scope as $var_id => $type) {
                 if (!isset($inner_context->vars_in_scope[$var_id])) {
-                    unset($loop_scope->loop_parent_context->vars_in_scope[$var_id]);
+                    $loop_scope->loop_parent_context->removePossibleReference($var_id);
                     continue;
                 }
 
@@ -555,6 +555,12 @@ class LoopAnalyzer
             $inner_context = $inner_do_context;
         }
 
+        // Track references set in the loop to make sure they aren't reused later
+        $loop_scope->loop_parent_context->updateReferencesPossiblyFromConfusingScope(
+            $inner_context,
+            $statements_analyzer
+        );
+
         return null;
     }
 
@@ -630,7 +636,7 @@ class LoopAnalyzer
 
         if (ExpressionAnalyzer::analyze($statements_analyzer, $pre_condition, $loop_context) === false) {
             $loop_context->inside_conditional = $was_inside_conditional;
-            
+
             return [];
         }
 
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php
index 765258969..b4d7c3dac 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php
@@ -4,6 +4,7 @@ namespace Psalm\Internal\Analyzer\Statements\Expression\Assignment;
 
 use InvalidArgumentException;
 use PhpParser;
+use PhpParser\Node\Expr\Variable;
 use Psalm\CodeLocation;
 use Psalm\Codebase;
 use Psalm\Context;
@@ -46,6 +47,7 @@ use function implode;
 use function in_array;
 use function is_string;
 use function preg_match;
+use function reset;
 use function strlen;
 
 /**
@@ -690,6 +692,10 @@ class ArrayAssignmentAnalyzer
 
         $child_stmt = null;
 
+        if (!empty($child_stmts)) {
+            $root_var = reset($child_stmts)->var;
+        }
+
         // First go from the root element up, and go as far as we can to figure out what
         // array types there are
         while ($child_stmts) {
@@ -816,6 +822,23 @@ class ArrayAssignmentAnalyzer
             $parent_var_id = $array_var_id;
         }
 
+        if ($statements_analyzer->data_flow_graph instanceof VariableUseGraph
+            && $root_var_id !== null
+            && isset($context->references_to_external_scope[$root_var_id])
+            && isset($root_var) && $root_var instanceof Variable && is_string($root_var->name)
+            && $root_var_id === '$' . $root_var->name
+        ) {
+            // Array is a reference to an external scope, mark it as used
+            $statements_analyzer->data_flow_graph->addPath(
+                DataFlowNode::getForAssignment(
+                    $root_var_id,
+                    new CodeLocation($statements_analyzer->getSource(), $root_var)
+                ),
+                new DataFlowNode('variable-use', 'variable use', null),
+                'variable-use'
+            );
+        }
+
         if ($root_var_id
             && $full_var_id
             && $child_stmt
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/InstancePropertyAssignmentAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/InstancePropertyAssignmentAnalyzer.php
index 12a09c8d7..464490857 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/InstancePropertyAssignmentAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/InstancePropertyAssignmentAnalyzer.php
@@ -1494,7 +1494,7 @@ class InstancePropertyAssignmentAnalyzer
                 $statements_analyzer
             );
 
-            unset($context->vars_in_scope[$var_id]);
+            $context->removePossibleReference($var_id);
         }
 
         $old_data_provider = $statements_analyzer->node_data;
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php
index 976fafa45..f6d948d55 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php
@@ -49,6 +49,7 @@ use Psalm\Issue\PossiblyInvalidArrayAccess;
 use Psalm\Issue\PossiblyNullArrayAccess;
 use Psalm\Issue\PossiblyUndefinedArrayOffset;
 use Psalm\Issue\ReferenceConstraintViolation;
+use Psalm\Issue\ReferenceReusedFromConfusingScope;
 use Psalm\Issue\UnnecessaryVarAnnotation;
 use Psalm\IssueBuffer;
 use Psalm\Node\Expr\BinaryOp\VirtualBitwiseAnd;
@@ -78,6 +79,7 @@ use Psalm\Type\Atomic\TNonEmptyArray;
 use Psalm\Type\Atomic\TNonEmptyList;
 use Psalm\Type\Atomic\TNull;
 use Psalm\Type\Union;
+use RuntimeException;
 use UnexpectedValueException;
 
 use function array_filter;
@@ -852,20 +854,7 @@ class AssignmentAnalyzer
         PhpParser\Node\Expr\AssignRef $stmt,
         Context $context
     ): bool {
-        $assignment_type = self::analyze(
-            $statements_analyzer,
-            $stmt->var,
-            $stmt->expr,
-            null,
-            $context,
-            $stmt->getDocComment()
-        );
-
-        if ($assignment_type === false) {
-            return false;
-        }
-
-        $assignment_type->by_ref = true;
+        ExpressionAnalyzer::analyze($statements_analyzer, $stmt->expr, $context, false, null, false, null, true);
 
         $lhs_var_id = ExpressionIdentifier::getArrayVarId(
             $stmt->var,
@@ -879,47 +868,86 @@ class AssignmentAnalyzer
             $statements_analyzer
         );
 
-        if ($lhs_var_id) {
-            $context->vars_in_scope[$lhs_var_id] = $assignment_type;
-            $context->hasVariable($lhs_var_id);
-            $context->byref_constraints[$lhs_var_id] = new ReferenceConstraint();
-
-            if ($statements_analyzer->data_flow_graph instanceof VariableUseGraph) {
-                foreach ($context->vars_in_scope[$lhs_var_id]->parent_nodes as $parent_node) {
-                    $statements_analyzer->data_flow_graph->addPath(
-                        $parent_node,
-                        new DataFlowNode('variable-use', 'variable use', null),
-                        'variable-use'
-                    );
-                }
+        $doc_comment = $stmt->getDocComment();
+        if ($doc_comment) {
+            try {
+                $var_comments = CommentAnalyzer::getTypeFromComment(
+                    $doc_comment,
+                    $statements_analyzer->getSource(),
+                    $statements_analyzer->getAliases(),
+                );
+            } catch (IncorrectDocblockException $e) {
+                IssueBuffer::maybeAdd(
+                    new MissingDocblockType(
+                        $e->getMessage(),
+                        new CodeLocation($statements_analyzer->getSource(), $stmt)
+                    )
+                );
+            } catch (DocblockParseException $e) {
+                IssueBuffer::maybeAdd(
+                    new InvalidDocblock(
+                        $e->getMessage(),
+                        new CodeLocation($statements_analyzer->getSource(), $stmt)
+                    )
+                );
             }
-        }
-
-        if ($rhs_var_id) {
-            if (!isset($context->vars_in_scope[$rhs_var_id])) {
-                $context->vars_in_scope[$rhs_var_id] = Type::getMixed();
+            if (!empty($var_comments)) {
+                IssueBuffer::maybeAdd(
+                    new InvalidDocblock(
+                        "Docblock type cannot be used for reference assignment",
+                        new CodeLocation($statements_analyzer->getSource(), $stmt)
+                    )
+                );
             }
-
-            $context->byref_constraints[$rhs_var_id] = new ReferenceConstraint();
         }
 
-        if ($statements_analyzer->data_flow_graph
-            && $lhs_var_id
-            && $rhs_var_id
-            && isset($context->vars_in_scope[$rhs_var_id])
-        ) {
-            $rhs_type = $context->vars_in_scope[$rhs_var_id];
-
-            $data_flow_graph = $statements_analyzer->data_flow_graph;
-
-            $lhs_location = new CodeLocation($statements_analyzer->getSource(), $stmt->var);
+        if ($lhs_var_id === null || $rhs_var_id === null) {
+            return false;
+        }
 
-            $lhs_node = DataFlowNode::getForAssignment($lhs_var_id, $lhs_location);
+        if (isset($context->references_in_scope[$lhs_var_id])) {
+            // Decrement old referenced variable's reference count
+            $reference_count = &$context->referenced_counts[$context->references_in_scope[$lhs_var_id]];
+            if ($reference_count < 1) {
+                throw new RuntimeException("Incorrect referenced count found");
+            }
+            --$reference_count;
 
-            foreach ($rhs_type->parent_nodes as $byref_destination_node) {
-                $data_flow_graph->addPath($lhs_node, $byref_destination_node, '=');
+            // Remove old reference parent node so previously referenced variable usage doesn't count as reference usage
+            $old_type = $context->vars_in_scope[$lhs_var_id];
+            foreach ($old_type->parent_nodes as $old_parent_node_id => $_) {
+                if (strpos($old_parent_node_id, "$lhs_var_id-") === 0) {
+                    unset($old_type->parent_nodes[$old_parent_node_id]);
+                }
             }
         }
+        // When assigning an existing reference as a reference it removes the
+        // old reference, so it's no longer potentially from a confusing scope.
+        unset($context->references_possibly_from_confusing_scope[$lhs_var_id]);
+
+        $context->vars_in_scope[$lhs_var_id] = &$context->vars_in_scope[$rhs_var_id];
+        $context->hasVariable($lhs_var_id);
+        $context->references_in_scope[$lhs_var_id] = $rhs_var_id;
+        $context->referenced_counts[$rhs_var_id] = ($context->referenced_counts[$rhs_var_id] ?? 0) + 1;
+        if (strpos($rhs_var_id, '[') !== false) {
+            // Reference to array item, we always consider array items to be an external scope for references
+            // TODO handle differently so it's detected as unused if the array is unused?
+            $context->references_to_external_scope[$lhs_var_id] = true;
+        }
+        if (strpos($rhs_var_id, '->') !== false) {
+            // Reference to object property, we always consider object properties to be an external scope for references
+            // TODO handle differently so it's detected as unused if the object is unused?
+            $context->references_to_external_scope[$lhs_var_id] = true;
+        }
+
+        $lhs_location = new CodeLocation($statements_analyzer->getSource(), $stmt->var);
+        $statements_analyzer->registerVariableAssignment(
+            $lhs_var_id,
+            $lhs_location
+        );
+
+        $lhs_node = DataFlowNode::getForAssignment($lhs_var_id, $lhs_location);
+        $context->vars_in_scope[$lhs_var_id]->parent_nodes[$lhs_node->id] = $lhs_node;
 
         return true;
     }
@@ -1600,6 +1628,7 @@ class AssignmentAnalyzer
     ): void {
         if (is_string($assign_var->name)) {
             if ($var_id) {
+                $original_type = $context->vars_in_scope[$var_id] ?? null;
                 $context->vars_in_scope[$var_id] = $assign_value_type;
                 $context->vars_possibly_in_scope[$var_id] = true;
 
@@ -1636,30 +1665,50 @@ class AssignmentAnalyzer
                     $assign_value_type->by_ref = true;
                 }
 
-                if ($assign_value_type->by_ref) {
-                    if ($statements_analyzer->data_flow_graph instanceof VariableUseGraph
-                        && $assign_value_type->parent_nodes
+                if ($statements_analyzer->data_flow_graph instanceof VariableUseGraph
+                    && $assign_value_type->parent_nodes
+                ) {
+                    if (isset($context->references_to_external_scope[$var_id])
+                        || isset($context->references_in_scope[$var_id])
+                        || isset($context->referenced_counts[$var_id]) && $context->referenced_counts[$var_id] > 0
                     ) {
                         $location = new CodeLocation($statements_analyzer, $assign_var);
-
-                        $byref_node = DataFlowNode::getForAssignment($var_id, $location);
-
-                        foreach ($assign_value_type->parent_nodes as $parent_node) {
+                        $assignment_node = DataFlowNode::getForAssignment($var_id, $location);
+                        $parent_nodes = $assign_value_type->parent_nodes;
+                        if ($original_type !== null) {
+                            $parent_nodes += $original_type->parent_nodes;
+                        }
+                        foreach ($parent_nodes as $parent_node) {
                             $statements_analyzer->data_flow_graph->addPath(
                                 $parent_node,
-                                new DataFlowNode('variable-use', 'variable use', null),
-                                'variable-use'
+                                $assignment_node,
+                                '&=' // Normal assignment to reference/referenced variable
                             );
+                        }
 
+                        if (isset($context->references_to_external_scope[$var_id])) {
+                            // Mark reference to an external scope as used when a value is assigned to it
                             $statements_analyzer->data_flow_graph->addPath(
-                                $byref_node,
-                                $parent_node,
-                                'byref-assignment'
+                                $assignment_node,
+                                new DataFlowNode('variable-use', 'variable use', null),
+                                'variable-use'
                             );
                         }
                     }
                 }
 
+                if (isset($context->references_possibly_from_confusing_scope[$var_id])) {
+                    IssueBuffer::maybeAdd(
+                        new ReferenceReusedFromConfusingScope(
+                            "$var_id is possibly a reference defined at"
+                                . " {$context->references_possibly_from_confusing_scope[$var_id]->getShortSummary()}."
+                                . " Reusing this variable may cause the referenced value to change.",
+                            new CodeLocation($statements_analyzer, $assign_var)
+                        ),
+                        $statements_analyzer->getSuppressedIssues()
+                    );
+                }
+
                 if ($assign_value_type->getId() === 'bool'
                     && ($assign_value instanceof PhpParser\Node\Expr\BinaryOp
                         || ($assign_value instanceof PhpParser\Node\Expr\BooleanNot
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index df54b95d6..4142828c7 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -227,8 +227,7 @@ class CallAnalyzer
                         if ($type->initialized) {
                             $local_vars_in_scope[$var_id] = $context->vars_in_scope[$var_id];
 
-                            unset($context->vars_in_scope[$var_id]);
-                            unset($context->vars_possibly_in_scope[$var_id]);
+                            $context->remove($var_id, false);
                         }
                     } elseif ($var_id !== '$this') {
                         $local_vars_in_scope[$var_id] = $context->vars_in_scope[$var_id];
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/AtomicPropertyFetchAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/AtomicPropertyFetchAnalyzer.php
index b0ffb87d2..39bfe8d2f 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/AtomicPropertyFetchAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/AtomicPropertyFetchAnalyzer.php
@@ -74,6 +74,7 @@ class AtomicPropertyFetchAnalyzer
 {
     /**
      * @param array<string> $invalid_fetch_types $invalid_fetch_types
+     * @psalm-suppress ComplexMethod
      */
     public static function analyze(
         StatementsAnalyzer $statements_analyzer,
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/VariableFetchAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/VariableFetchAnalyzer.php
index 3ecde22a7..331c818c7 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/VariableFetchAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/VariableFetchAnalyzer.php
@@ -49,6 +49,8 @@ class VariableFetchAnalyzer
 
     /**
      * @param bool $from_global - when used in a global keyword
+     * @param bool $assigned_to_reference This is set to true when the expression being analyzed
+     *                                    here is being assigned to another variable by reference.
      */
     public static function analyze(
         StatementsAnalyzer $statements_analyzer,
@@ -57,7 +59,8 @@ class VariableFetchAnalyzer
         bool $passed_by_reference = false,
         ?Union $by_ref_type = null,
         bool $array_assignment = false,
-        bool $from_global = false
+        bool $from_global = false,
+        bool $assigned_to_reference = false
     ): bool {
         $project_analyzer = $statements_analyzer->getFileAnalyzer()->project_analyzer;
         $codebase = $statements_analyzer->getCodebase();
@@ -220,11 +223,16 @@ class VariableFetchAnalyzer
             if (!isset($context->vars_possibly_in_scope[$var_name])
                 || !$statements_analyzer->getFirstAppearance($var_name)
             ) {
-                if ($array_assignment) {
-                    // if we're in an array assignment, let's assign the variable
-                    // because PHP allows it
-
-                    $context->vars_in_scope[$var_name] = Type::getArray();
+                if ($array_assignment || $assigned_to_reference) {
+                    if ($array_assignment) {
+                        // if we're in an array assignment, let's assign the variable because PHP allows it
+                        $stmt_type = Type::getArray();
+                    } else {
+                        // If a variable is assigned by reference to a variable that
+                        // does not exist, they are automatically initialized as `null`
+                        $stmt_type = Type::getNull();
+                    }
+                    $context->vars_in_scope[$var_name] = $stmt_type;
                     $context->vars_possibly_in_scope[$var_name] = true;
 
                     // it might have been defined first in another if/else branch
@@ -235,6 +243,16 @@ class VariableFetchAnalyzer
                             $context->branch_point
                         );
                     }
+                    $statements_analyzer->node_data->setType($stmt, $stmt_type);
+
+                    if ($assigned_to_reference) {
+                        // Since this variable was created by being assigned to as a reference (ie for
+                        // `$a = &$b` this variable is $b), we need to analyze it as an assignment to null.
+                        AssignmentAnalyzer::analyze($statements_analyzer, $stmt, null, $stmt_type, $context, null);
+
+                        // Stop here, we don't want it to be considered possibly undefined like the array case.
+                        return true;
+                    }
                 } elseif (!$context->inside_isset
                     || $statements_analyzer->getSource() instanceof FunctionLikeAnalyzer
                 ) {
diff --git a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
index a1a4483b7..a33d2e3c9 100644
--- a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
@@ -65,6 +65,10 @@ use function strtolower;
  */
 class ExpressionAnalyzer
 {
+    /**
+     * @param bool $assigned_to_reference This is set to true when the expression being analyzed
+     *                                    here is being assigned to another variable by reference.
+     */
     public static function analyze(
         StatementsAnalyzer $statements_analyzer,
         PhpParser\Node\Expr $stmt,
@@ -72,7 +76,8 @@ class ExpressionAnalyzer
         bool $array_assignment = false,
         ?Context $global_context = null,
         bool $from_stmt = false,
-        ?TemplateResult $template_result = null
+        ?TemplateResult $template_result = null,
+        bool $assigned_to_reference = false
     ): bool {
         $codebase = $statements_analyzer->getCodebase();
 
@@ -83,7 +88,8 @@ class ExpressionAnalyzer
             $array_assignment,
             $global_context,
             $from_stmt,
-            $template_result
+            $template_result,
+            $assigned_to_reference,
         ) === false) {
             return false;
         }
@@ -140,6 +146,10 @@ class ExpressionAnalyzer
         return true;
     }
 
+    /**
+     * @param bool $assigned_to_reference This is set to true when the expression being analyzed
+     *                                    here is being assigned to another variable by reference.
+     */
     private static function handleExpression(
         StatementsAnalyzer $statements_analyzer,
         PhpParser\Node\Expr $stmt,
@@ -147,7 +157,8 @@ class ExpressionAnalyzer
         bool $array_assignment,
         ?Context $global_context,
         bool $from_stmt,
-        ?TemplateResult $template_result = null
+        ?TemplateResult $template_result = null,
+        bool $assigned_to_reference = false
     ): bool {
         if ($stmt instanceof PhpParser\Node\Expr\Variable) {
             return VariableFetchAnalyzer::analyze(
@@ -156,7 +167,9 @@ class ExpressionAnalyzer
                 $context,
                 false,
                 null,
-                $array_assignment
+                $array_assignment,
+                false,
+                $assigned_to_reference
             );
         }
 
diff --git a/src/Psalm/Internal/Analyzer/Statements/GlobalAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/GlobalAnalyzer.php
index 1781f242d..3ef2635c8 100644
--- a/src/Psalm/Internal/Analyzer/Statements/GlobalAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/GlobalAnalyzer.php
@@ -8,10 +8,12 @@ use Psalm\Context;
 use Psalm\Internal\Analyzer\FunctionLikeAnalyzer;
 use Psalm\Internal\Analyzer\Statements\Expression\Fetch\VariableFetchAnalyzer;
 use Psalm\Internal\Analyzer\StatementsAnalyzer;
+use Psalm\Internal\Codebase\VariableUseGraph;
 use Psalm\Internal\DataFlow\DataFlowNode;
 use Psalm\Internal\ReferenceConstraint;
 use Psalm\Issue\InvalidGlobal;
 use Psalm\IssueBuffer;
+use RuntimeException;
 
 use function is_string;
 
@@ -61,6 +63,7 @@ class GlobalAnalyzer
 
                         $context->byref_constraints[$var_id] = new ReferenceConstraint();
                     }
+
                     $assignment_node = DataFlowNode::getForAssignment(
                         $var_id,
                         new CodeLocation($statements_analyzer, $var)
@@ -68,7 +71,17 @@ class GlobalAnalyzer
                     $context->vars_in_scope[$var_id]->parent_nodes = [
                         $assignment_node->id => $assignment_node,
                     ];
-                    $context->vars_from_global[$var_id] = true;
+                    $context->references_to_external_scope[$var_id] = true;
+
+                    if (isset($context->references_in_scope[$var_id])) {
+                        // Global shadows existing reference
+                        $reference_count = &$context->referenced_counts[$context->references_in_scope[$var_id]];
+                        if ($reference_count < 1) {
+                            throw new RuntimeException("Incorrect referenced count found");
+                        }
+                        --$reference_count;
+                        unset($context->references_in_scope[$var_id]);
+                    }
                     $statements_analyzer->registerVariable(
                         $var_id,
                         new CodeLocation($statements_analyzer, $var),
@@ -79,6 +92,20 @@ class GlobalAnalyzer
                         $var,
                         $var_id
                     );
+
+                    if ($statements_analyzer->data_flow_graph instanceof VariableUseGraph) {
+                        if ($global_context !== null && $global_context->hasVariable($var_id)) {
+                            // TODO get global CodeLocation so that global variable can be marked as unused if it is
+                            // unused inside the function. Marking it as a referenced global causes it to be marked
+                            // used if it's used as a global in any function, even if it's unused in that function.
+                            $global_context->referenced_globals[$var_id] = true;
+                            // $statements_analyzer->data_flow_graph->addPath(
+                            //     $assignment_node,
+                            //     $global_node,
+                            //     'byref-assignment'
+                            // );
+                        }
+                    }
                 }
             }
         }
diff --git a/src/Psalm/Internal/Analyzer/Statements/UnsetAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/UnsetAnalyzer.php
index b11ce758a..d580f6c99 100644
--- a/src/Psalm/Internal/Analyzer/Statements/UnsetAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/UnsetAnalyzer.php
@@ -47,6 +47,7 @@ class UnsetAnalyzer
 
             if ($var_id) {
                 $context->remove($var_id);
+                unset($context->references_possibly_from_confusing_scope[$var_id]);
             }
 
             if ($var instanceof PhpParser\Node\Expr\ArrayDimFetch && $var->dim) {
diff --git a/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php b/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php
index 952d8c5ac..2881e5273 100644
--- a/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php
@@ -131,9 +131,9 @@ class StatementsAnalyzer extends SourceAnalyzer
     private $unused_var_locations = [];
 
     /**
-     * @var ?array<string, bool>
+     * @var array<string, true>
      */
-    public $byref_uses;
+    public $byref_uses = [];
 
     /**
      * @var ParsedDocblock|null
@@ -214,7 +214,6 @@ class StatementsAnalyzer extends SourceAnalyzer
             && $codebase->find_unused_variables
             && $context->check_variables
         ) {
-            //var_dump($this->data_flow_graph);
             $this->checkUnreferencedVars($stmts, $context);
         }
 
@@ -790,7 +789,7 @@ class StatementsAnalyzer extends SourceAnalyzer
             $assignment_node = DataFlowNode::getForAssignment($var_id, $original_location);
 
             if (!isset($this->byref_uses[$var_id])
-                && !isset($context->vars_from_global[$var_id])
+                && !isset($context->referenced_globals[$var_id])
                 && !VariableFetchAnalyzer::isSuperGlobal($var_id)
                 && $this->data_flow_graph instanceof VariableUseGraph
                 && !$this->data_flow_graph->isVariableUsed($assignment_node)
@@ -955,7 +954,7 @@ class StatementsAnalyzer extends SourceAnalyzer
     }
 
     /**
-     * @param array<string, bool> $byref_uses
+     * @param array<string, true> $byref_uses
      */
     public function setByRefUses(array $byref_uses): void
     {
diff --git a/src/Psalm/Internal/Diff/FileStatementsDiffer.php b/src/Psalm/Internal/Diff/FileStatementsDiffer.php
index 9580d7f63..d5decb928 100644
--- a/src/Psalm/Internal/Diff/FileStatementsDiffer.php
+++ b/src/Psalm/Internal/Diff/FileStatementsDiffer.php
@@ -34,8 +34,7 @@ class FileStatementsDiffer extends AstDiffer
                 PhpParser\Node\Stmt $a,
                 PhpParser\Node\Stmt $b,
                 string $a_code,
-                string $b_code,
-                bool &$body_change = false
+                string $b_code
             ): bool {
                 if (get_class($a) !== get_class($b)) {
                     return false;
diff --git a/src/Psalm/Internal/Diff/NamespaceStatementsDiffer.php b/src/Psalm/Internal/Diff/NamespaceStatementsDiffer.php
index 5ac1e8a9d..77eec3875 100644
--- a/src/Psalm/Internal/Diff/NamespaceStatementsDiffer.php
+++ b/src/Psalm/Internal/Diff/NamespaceStatementsDiffer.php
@@ -34,8 +34,7 @@ class NamespaceStatementsDiffer extends AstDiffer
                 PhpParser\Node\Stmt $a,
                 PhpParser\Node\Stmt $b,
                 string $a_code,
-                string $b_code,
-                bool &$body_change = false
+                string $b_code
             ): bool {
                 if (get_class($a) !== get_class($b)) {
                     return false;
diff --git a/src/Psalm/Internal/Type/SimpleAssertionReconciler.php b/src/Psalm/Internal/Type/SimpleAssertionReconciler.php
index b2e175350..7ce33e72e 100644
--- a/src/Psalm/Internal/Type/SimpleAssertionReconciler.php
+++ b/src/Psalm/Internal/Type/SimpleAssertionReconciler.php
@@ -241,8 +241,7 @@ class SimpleAssertionReconciler extends Reconciler
                 $negated,
                 $code_location,
                 $suppressed_issues,
-                $failed_reconciliation,
-                $is_equality
+                $is_equality,
             );
         }
 
@@ -254,8 +253,7 @@ class SimpleAssertionReconciler extends Reconciler
                 $negated,
                 $code_location,
                 $suppressed_issues,
-                $failed_reconciliation,
-                $is_equality
+                $is_equality,
             );
         }
 
@@ -434,7 +432,7 @@ class SimpleAssertionReconciler extends Reconciler
                 $code_location,
                 $suppressed_issues,
                 $failed_reconciliation,
-                $is_equality
+                $is_equality,
             );
         }
 
@@ -560,7 +558,6 @@ class SimpleAssertionReconciler extends Reconciler
 
     /**
      * @param   string[]  $suppressed_issues
-     * @param Reconciler::RECONCILIATION_* $failed_reconciliation
      */
     private static function reconcileNonEmptyCountable(
         Assertion $assertion,
@@ -569,7 +566,6 @@ class SimpleAssertionReconciler extends Reconciler
         bool $negated,
         ?CodeLocation $code_location,
         array $suppressed_issues,
-        int &$failed_reconciliation,
         bool $is_equality
     ): Union {
         $old_var_type_string = $existing_var_type->getId();
diff --git a/src/Psalm/Internal/Type/SimpleNegatedAssertionReconciler.php b/src/Psalm/Internal/Type/SimpleNegatedAssertionReconciler.php
index 548ec187b..fc8d6b62c 100644
--- a/src/Psalm/Internal/Type/SimpleNegatedAssertionReconciler.php
+++ b/src/Psalm/Internal/Type/SimpleNegatedAssertionReconciler.php
@@ -204,7 +204,6 @@ class SimpleNegatedAssertionReconciler extends Reconciler
                 $negated,
                 $code_location,
                 $suppressed_issues,
-                $failed_reconciliation,
                 $is_equality,
                 null
             );
@@ -218,7 +217,6 @@ class SimpleNegatedAssertionReconciler extends Reconciler
                 $negated,
                 $code_location,
                 $suppressed_issues,
-                $failed_reconciliation,
                 $is_equality,
                 $assertion->count
             );
@@ -510,7 +508,6 @@ class SimpleNegatedAssertionReconciler extends Reconciler
         bool $negated,
         ?CodeLocation $code_location,
         array $suppressed_issues,
-        int &$failed_reconciliation,
         bool $is_equality,
         ?int $min_count
     ): Union {
diff --git a/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php b/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php
index c3e336edc..67bc81302 100644
--- a/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php
+++ b/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php
@@ -214,7 +214,6 @@ class TemplateStandinTypeReplacer
                     $bound_equality_classlike,
                     $depth,
                     $was_single,
-                    $had_template
                 );
             }
         }
@@ -896,7 +895,6 @@ class TemplateStandinTypeReplacer
         ?string $bound_equality_classlike,
         int $depth,
         bool $was_single,
-        bool &$had_template
     ): array {
         if ($atomic_type->defining_class === $calling_class) {
             return [$atomic_type];
diff --git a/src/Psalm/Issue/ReferenceReusedFromConfusingScope.php b/src/Psalm/Issue/ReferenceReusedFromConfusingScope.php
new file mode 100644
index 000000000..31332b98b
--- /dev/null
+++ b/src/Psalm/Issue/ReferenceReusedFromConfusingScope.php
@@ -0,0 +1,9 @@
+<?php
+
+namespace Psalm\Issue;
+
+class ReferenceReusedFromConfusingScope extends CodeIssue
+{
+    public const ERROR_LEVEL = 4;
+    public const SHORTCODE = 303;
+}
diff --git a/src/Psalm/Type/Union.php b/src/Psalm/Type/Union.php
index dd949d61f..a5c550bbf 100644
--- a/src/Psalm/Type/Union.php
+++ b/src/Psalm/Type/Union.php
@@ -190,7 +190,9 @@ class Union implements TypeNode
     private $literal_float_types = [];
 
     /**
-     * Whether or not the type was passed by reference
+     * True if the type was passed or returned by reference, or if the type refers to an object's
+     * property or an item in an array. Note that this is not true for locally created references
+     * that don't refer to properties or array items (see Context::$references_in_scope).
      *
      * @var bool
      */
diff --git a/tests/AnnotationTest.php b/tests/AnnotationTest.php
index 8d287fd77..c485f07b4 100644
--- a/tests/AnnotationTest.php
+++ b/tests/AnnotationTest.php
@@ -537,11 +537,20 @@ class AnnotationTest extends TestCase
             ],
             'spreadOperatorByRefAnnotation' => [
                 'code' => '<?php
-                    /** @param string &...$s */
+                    /**
+                     * @param string &...$s
+                     * @psalm-suppress UnusedParam
+                     */
                     function foo(&...$s) : void {}
-                    /** @param string ...&$s */
+                    /**
+                     * @param string ...&$s
+                     * @psalm-suppress UnusedParam
+                     */
                     function bar(&...$s) : void {}
-                    /** @param string[] &$s */
+                    /**
+                     * @param string[] &$s
+                     * @psalm-suppress UnusedParam
+                     */
                     function bat(&...$s) : void {}
 
                     $a = "hello";
@@ -1684,7 +1693,10 @@ class AnnotationTest extends TestCase
             ],
             'spreadOperatorByRefAnnotationBadCall1' => [
                 'code' => '<?php
-                    /** @param string &...$s */
+                    /**
+                     * @param string &...$s
+                     * @psalm-suppress UnusedParam
+                     */
                     function foo(&...$s) : void {}
 
                     $a = 1;
@@ -1693,7 +1705,10 @@ class AnnotationTest extends TestCase
             ],
             'spreadOperatorByRefAnnotationBadCall2' => [
                 'code' => '<?php
-                    /** @param string ...&$s */
+                    /**
+                     * @param string ...&$s
+                     * @psalm-suppress UnusedParam
+                     */
                     function foo(&...$s) : void {}
 
                     $b = 2;
@@ -1702,7 +1717,10 @@ class AnnotationTest extends TestCase
             ],
             'spreadOperatorByRefAnnotationBadCall3' => [
                 'code' => '<?php
-                    /** @param string[] &$s */
+                    /**
+                     * @param string[] &$s
+                     * @psalm-suppress UnusedParam
+                     */
                     function foo(&...$s) : void {}
 
                     $c = 3;
diff --git a/tests/FileManipulation/UnusedVariableManipulationTest.php b/tests/FileManipulation/UnusedVariableManipulationTest.php
index 8eb39c109..1e73f75fe 100644
--- a/tests/FileManipulation/UnusedVariableManipulationTest.php
+++ b/tests/FileManipulation/UnusedVariableManipulationTest.php
@@ -338,7 +338,7 @@ class UnusedVariableManipulationTest extends FileManipulationTestCase
                 'safe_types' => true,
             ],
 
-            'removeUnusedVarAssignByRef' => [
+            'SKIPPED-removeUnusedVarAssignByRefToSubsequentlyUsedVariable' => [
                 'input' => '<?php
                     function foo() : void {
                         $a = 5;
@@ -348,7 +348,6 @@ class UnusedVariableManipulationTest extends FileManipulationTestCase
                 'output' => '<?php
                     function foo() : void {
                         $a = 5;
-                        $b = &$a;
                         echo $a;
                     }',
                 'php_version' => '7.1',
@@ -356,6 +355,20 @@ class UnusedVariableManipulationTest extends FileManipulationTestCase
                 'safe_types' => true,
             ],
 
+            'removeUnusedVarAssignByRef' => [
+                'input' => '<?php
+                    function foo() : void {
+                        $a = 5;
+                        $b = &$a;
+                    }',
+                'output' => '<?php
+                    function foo() : void {
+                    }',
+                'php_version' => '7.1',
+                'issues_to_fix' => ['UnusedVariable'],
+                'safe_types' => true,
+            ],
+
             'removeUnusedVarAssignByRefPartial' => [
                 'input' => '<?php
                     function foo() : void {
@@ -366,7 +379,7 @@ class UnusedVariableManipulationTest extends FileManipulationTestCase
                 'output' => '<?php
                     function foo() : void {
                         $a = [1, 2, 3];
-                        $b = &$a[1];
+                        $a[1];
                         print_r($a);
                     }',
                 'php_version' => '7.1',
@@ -384,7 +397,7 @@ class UnusedVariableManipulationTest extends FileManipulationTestCase
                 'output' => '<?php
                     function foo() : void {
                         $a = [1, 2, 3];
-                        $b = & $a[1];
+                        $a[1];
                         print_r($a);
                     }',
                 'php_version' => '7.1',
diff --git a/tests/ReferenceTest.php b/tests/ReferenceTest.php
new file mode 100644
index 000000000..09a0f6d2a
--- /dev/null
+++ b/tests/ReferenceTest.php
@@ -0,0 +1,337 @@
+<?php
+
+namespace Psalm\Tests;
+
+use Psalm\Tests\Traits\InvalidCodeAnalysisTestTrait;
+use Psalm\Tests\Traits\ValidCodeAnalysisTestTrait;
+
+use const DIRECTORY_SEPARATOR;
+
+class ReferenceTest extends TestCase
+{
+    use InvalidCodeAnalysisTestTrait;
+    use ValidCodeAnalysisTestTrait;
+
+    /**
+     * @return iterable<string,array{code:string,assertions?:array<string,string>,ignored_issues?:list<string>,php_version?:string}>
+     */
+    public function providerValidCodeParse(): iterable
+    {
+        return [
+            'updateReferencedTypes' => [
+                'code' => '<?php
+                    $a = 1;
+                    $b = &$a;
+                    $b = 2;
+                    $c = 3;
+                    $b = &$c;
+                    $b = 4;
+                ',
+                'assertions' => [
+                    '$a===' => '2',
+                    '$b===' => '4',
+                    '$c===' => '4',
+                ],
+            ],
+            'SKIPPED-referenceToArrayItemChangesArrayType' => [
+                'code' => '<?php
+                    /** @var list<int> */
+                    $arr = [];
+
+                    assert(isset($arr[0]));
+                    $int = &$arr[0];
+                    $int = (string) $int;
+                ',
+                'assertions' => [
+                    '$arr' => 'list<int|string>',
+                ],
+            ],
+            'referenceToReference' => [
+                'code' => '<?php
+                    $a = 1;
+                    $b = &$a;
+                    $c = &$b;
+                    $c = 2;
+                    $d = 3;
+                    $b = &$d;
+                ',
+                'assertions' => [
+                    '$a===' => '2',
+                    '$b===' => '3',
+                    '$c===' => '2',
+                    '$d===' => '3',
+                ],
+            ],
+            'referenceToSubsequentCatch' => [
+                'code' => '<?php
+                    $a = null;
+                    $b = &$a;
+
+                    try {
+                        throw new \Exception();
+                    } catch (\Exception $a) {
+                        takesException($b);
+                    }
+                    function takesException(\Exception $e): void {}
+                ',
+            ],
+            'referenceAsSubsequentCatch' => [
+                'code' => '<?php
+                    $a = null;
+                    $b = &$a;
+
+                    try {
+                        throw new \Exception();
+                    } catch (\Exception $b) {
+                        takesException($a);
+                    }
+                    function takesException(\Exception $e): void {}
+                ',
+            ],
+            'referenceToNewVariableInitializesNull' => [
+                'code' => '<?php
+                    $b = &$a;
+                ',
+                'assertions' => [
+                    '$a===' => 'null',
+                    '$b===' => 'null',
+                ],
+            ],
+            'referenceShadowedByGlobal' => [
+                'code' => '<?php
+                    /** @var string */
+                    $a = 0;
+                    function foo(): void
+                    {
+                        $b = 1;
+                        $a = &$b;
+                        global $a;
+                    }
+                ',
+                'assertions' => [
+                    '$a' => 'string',
+                ],
+            ],
+            'unsetPreventsReferenceConfusion' => [
+                'code' => '<?php
+                    $arr = [1, 2, 3];
+                    foreach ($arr as &$i) {
+                        ++$i;
+                    }
+                    unset($i);
+
+                    for ($i = 0; $i < 10; ++$i) {
+                        echo $i;
+                    }
+                ',
+            ],
+            'assignmentAsReferencePreventsReferenceConfusion' => [
+                'code' => '<?php
+                    $arr = [1, 2, 3];
+                    foreach ($arr as &$i) {
+                        ++$i;
+                    }
+
+                    $i = &$foo;
+
+                    for ($i = 0; $i < 10; ++$i) {
+                        echo $i;
+                    }
+                ',
+            ],
+            'assignmentAsReferenceInForeachPreventsReferenceConfusion' => [
+                'code' => '<?php
+                    $arr = [1, 2, 3];
+                    foreach ($arr as &$i) {
+                        ++$i;
+                    }
+                    foreach ($arr as &$i) {
+                        ++$i;
+                    }
+                ',
+            ],
+        ];
+    }
+
+    /**
+     * @return iterable<string,array{code:string,error_message:string,ignored_issues?:list<string>,php_version?:string}>
+     */
+    public function providerInvalidCodeParse(): iterable
+    {
+        return [
+            'referenceReuseForeachValue' => [
+                'code' => '<?php
+                    /** @var array<int> */
+                    $arr = [];
+
+                    foreach ($arr as &$var) {
+                        $var += 1;
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referenceReuseDeclaredInForeach' => [
+                'code' => '<?php
+                    /** @var array<int> */
+                    $arr = [];
+
+                    foreach ($arr as $val) {
+                        $var = &$val;
+                        $var += 1;
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referenceReuseDeclaredInFor' => [
+                'code' => '<?php
+                    /** @var list<int> */
+                    $arr = [];
+
+                    for ($i = 0; $i < count($arr); ++$i) {
+                        $var = &$arr[$i];
+                        $var += 1;
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referenceReuseDeclaredInIf' => [
+                'code' => '<?php
+                    /** @var array<int> */
+                    $arr = [];
+
+                    if (isset($arr[0])) {
+                        $var = &$arr[0];
+                        $var += 1;
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referenceReuseDeclaredInElseif' => [
+                'code' => '<?php
+                    /** @var array<int> */
+                    $arr = [];
+
+                    if (random_int(0, 1)) {
+                    } elseif (isset($arr[0])) {
+                        $var = &$arr[0];
+                        $var += 1;
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referenceReuseDeclaredInElse' => [
+                'code' => '<?php
+                    /** @var array<int> */
+                    $arr = [];
+
+                    if (!isset($arr[0])) {
+                    } else {
+                        $var = &$arr[0];
+                        $var += 1;
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referenceReuseDeeplyNested' => [
+                'code' => '<?php
+                    /** @var list<list<list<int>>> */
+                    $arr = [];
+
+                    for ($i = 0; $i < count($arr); ++$i) {
+                        foreach ($arr[$i] as $inner_arr) {
+                            if (isset($inner_arr[0])) {
+                                $var = &$inner_arr[0];
+                                $var += 1;
+                            }
+                        }
+                    }
+
+                    $var = "foo";
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'referencesIgnoreVarAnnotation' => [
+                'code' => '<?php
+                    $a = 1;
+                    /** @var int */
+                    $b = &$a;
+                ',
+                'error_message' => 'InvalidDocblock - src' . DIRECTORY_SEPARATOR . 'somefile.php:4:21 - Docblock type cannot be used for reference assignment',
+            ],
+            'SKIPPED-referenceToTypedArrayConstrainsAssignment' => [
+                'code' => '<?php
+                    class Foo
+                    {
+                        /** @var list<int> */
+                        public array $arr = [];
+
+                        public function __construct()
+                        {
+                            assert(isset($this->arr[0]));
+                            $int = &$this->arr[0];
+                            $int = (string) $int;
+                        }
+                    }
+                ',
+                'error_message' => 'ReferenceConstraintViolation',
+            ],
+            'SKIPPED-referenceToTypedArrayConstrainsAssignmentWithNullReferenceInitialization' => [
+                'code' => '<?php
+                    class Foo
+                    {
+                        /** @var list<int> */
+                        public array $arr = [];
+
+                        public function __construct()
+                        {
+                            $int = &$this->arr[0]; // If $this->arr[0] isn\'t set, this will set it to null.
+                        }
+                    }
+                ',
+                'error_message' => 'PossiblyInvalidPropertyAssignmentValue',
+            ],
+            'unsetOnlyPreventsReferenceConfusionAfterCall' => [
+                'code' => '<?php
+                    $arr = [1, 2, 3];
+                    foreach ($arr as &$i) {
+                        ++$i;
+                    }
+
+                    for ($i = 0; $i < 10; ++$i) {
+                        echo $i;
+                    }
+
+                    unset($i);
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+            'assignmentAsReferenceOnlyPreventsReferenceConfusionAfterAssignment' => [
+                'code' => '<?php
+                    $arr = [1, 2, 3];
+                    foreach ($arr as &$i) {
+                        ++$i;
+                    }
+
+                    for ($i = 0; $i < 10; ++$i) {
+                        echo $i;
+                    }
+
+                    $i = &$foo;
+                ',
+                'error_message' => 'ReferenceReusedFromConfusingScope',
+            ],
+        ];
+    }
+}
diff --git a/tests/UnusedVariableTest.php b/tests/UnusedVariableTest.php
index dc7fb38ca..fac062429 100644
--- a/tests/UnusedVariableTest.php
+++ b/tests/UnusedVariableTest.php
@@ -1525,7 +1525,10 @@ class UnusedVariableTest extends TestCase
                         }
                     }
 
-                    /** @param mixed $p */
+                    /**
+                     * @param mixed $p
+                     * @psalm-suppress UnusedParam
+                     */
                     function takes_ref(&$p): void {}'
             ],
             'passedByRefArrayOffset' => [
@@ -1955,6 +1958,23 @@ class UnusedVariableTest extends TestCase
                         $arr[0] = $b;
                     }'
             ],
+            'byRefDeeplyNestedArrayParam' => [
+                'code' => '<?php
+                    /** @param non-empty-list<non-empty-list<int>> $arr */
+                    function foo(array &$arr): void {
+                        $b = 5;
+                        $arr[0][0] = $b;
+                    }'
+            ],
+            'nestedReferencesToByRefParam' => [
+                'code' => '<?php
+                    /** @param non-empty-list<non-empty-list<int>> $arr */
+                    function foo(array &$arr): void {
+                        $a = &$arr[0];
+                        $b = &$a[0];
+                        $b = 5;
+                    }'
+            ],
             'byRefNestedArrayInForeach' => [
                 'code' => '<?php
                     function foo(array $arr): array {
@@ -2453,6 +2473,47 @@ class UnusedVariableTest extends TestCase
                         }  
                     }',
             ],
+            'referenceUseUsesReferencedVariable' => [
+                'code' => '<?php
+                    $a = 1;
+                    $b = &$a;
+                    echo $b;
+                ',
+            ],
+            'referenceAssignmentToNonReferenceCountsAsUse' => [
+                'code' => '<?php
+                    $b = &$a;
+                    $b = 2;
+                    echo $a;
+                ',
+                'assertions' => [
+                    '$b===' => '2',
+                    '$a===' => '2',
+                ],
+            ],
+            'referenceUsedAfterVariableReassignment' => [
+                'code' => '<?php
+                    $b = &$a;
+                    $a = 2;
+                    echo $a;
+                    $b = 3;
+                    echo $a;
+                ',
+            ],
+            'referenceUsedInForeach' => [
+                'code' => '<?php
+                    foreach ([1, 2, 3] as &$var) {
+                        $var += 1;
+                    }
+                ',
+            ],
+            'SKIPPED-referenceUsedInDestructuredForeach' => [
+                'code' => '<?php
+                    foreach ([[1, 2], [3, 4]] as [&$a, $_]) {
+                        $a += 1;
+                    }
+                ',
+            ],
         ];
     }
 
@@ -3433,6 +3494,98 @@ class UnusedVariableTest extends TestCase
                     }',
                 'error_message' => 'MixedArgumentTypeCoercion - src' . DIRECTORY_SEPARATOR . 'somefile.php:12:44 - Argument 1 of takesArrayOfString expects array<array-key, string>, parent type array{mixed} provided. Consider improving the type at src' . DIRECTORY_SEPARATOR . 'somefile.php:10:41'
             ],
+            'referenceReassignmentUnusedVariable' => [
+                'code' => '<?php
+                    $a = $b = 1;
+                    $c = &$a;
+                    $c = &$b;
+                    $c = 2;
+
+                    echo $a + $b + $c;
+                ',
+                'error_message' => 'UnusedVariable - src' . DIRECTORY_SEPARATOR . 'somefile.php:3:21 - $c',
+            ],
+            'referenceAssignmentIsNotUsed' => [
+                'code' => '<?php
+                    $a = 1;
+                    $b = &$a;
+                ',
+                'error_message' => 'UnusedVariable - src' . DIRECTORY_SEPARATOR . 'somefile.php:2:21 - $a',
+            ],
+            'unusedReferenceToPreviouslyUsedVariable' => [
+                'code' => '<?php
+                    $a = 1;
+                    echo $a;
+                    $b = &$a;
+                ',
+                'error_message' => 'UnusedVariable - src' . DIRECTORY_SEPARATOR . 'somefile.php:4:21 - $b',
+            ],
+            'SKIPPED-unusedReferenceToSubsequentlyUsedVariable' => [ // Not easy to do the way it's currently set up
+                'code' => '<?php
+                    $a = 1;
+                    $b = &$a;
+                    echo $a;
+                ',
+                'error_message' => 'UnusedVariable - src' . DIRECTORY_SEPARATOR . 'somefile.php:3:21 - $b',
+            ],
+            'unusedReferenceInForeach' => [
+                'code' => '<?php
+                    foreach ([1, 2, 3] as &$var) {
+                    }
+                ',
+                'error_message' => 'UnusedForeachValue',
+            ],
+            'SKIPPED-unusedReferenceInDestructuredForeach' => [
+                'code' => '<?php
+                    foreach ([[1, 2], [3, 4]] as [&$var, $_]) {
+                    }
+                ',
+                'error_message' => 'UnusedForeachValue',
+            ],
+            'unusedReturnByReference' => [
+                'code' => '<?php
+                    function &foo(): int
+                    {
+                        /** @var ?int */
+                        static $i;
+                        if ($i === null) {
+                            $i = 0;
+                        }
+                        return $i;
+                    }
+
+                    $bar = foo();
+                ',
+                'error_message' => 'UnusedVariable',
+            ],
+            'unusedPassByReference' => [
+                'code' => '<?php
+                    function foo(int &$arg): int
+                    {
+                        return 0;
+                    }
+                ',
+                'error_message' => 'UnusedParam',
+            ],
+            'SKIPPED-unusedGlobalVariable' => [
+                'code' => '<?php
+                    $a = 0;
+                    function foo(): void
+                    {
+                        global $a;
+                    }
+                ',
+                'error_message' => 'UnusedVariable - src' . DIRECTORY_SEPARATOR . 'somefile.php:2:21 - $a',
+            ],
+            'unusedUndeclaredGlobalVariable' => [
+                'code' => '<?php
+                    function foo(): void
+                    {
+                        global $a;
+                    }
+                ',
+                'error_message' => 'UnusedVariable',
+            ],
         ];
     }
 }
