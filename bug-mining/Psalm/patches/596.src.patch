diff --git a/docs/annotating_code/type_syntax/atomic_types.md b/docs/annotating_code/type_syntax/atomic_types.md
index c569afee8..0849a62a5 100644
--- a/docs/annotating_code/type_syntax/atomic_types.md
+++ b/docs/annotating_code/type_syntax/atomic_types.md
@@ -44,6 +44,7 @@ Atomic types are the basic building block of all type information used in Psalm.
 
 ## Magical types
 
+- [(T is true ? string : bool)](conditional_types.md)
 - `key-of<Foo\Bar::ARRAY_CONST>`
 - `value-of<Foo\Bar::ARRAY_CONST>`
 - `T[K]`
diff --git a/docs/annotating_code/type_syntax/conditional_types.md b/docs/annotating_code/type_syntax/conditional_types.md
new file mode 100644
index 000000000..d9614c00e
--- /dev/null
+++ b/docs/annotating_code/type_syntax/conditional_types.md
@@ -0,0 +1,42 @@
+# Conditional types
+
+Psalm supports the equivalent of TypeScriptâ€™s [conditional types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types).
+
+Conditional types have the form:
+
+`(<template param> is <union type> ? <union type> : <union type>)`
+
+All conditional types must be wrapped inside brackets e.g. `(...)`
+
+Conditional types are dependent on [template parameters](../templated_annotations.md), so you can only use them in a function where template parameters are defined:
+
+```php
+<?php
+
+/**
+ * @template T as int|float
+ * @param T $a
+ * @param T $b
+ * @return int|float
+ * @psalm-return (T is int ? int : float)
+ */
+function add($a, $b) {
+    return $a + $b;
+}
+```
+
+When figuring out the result of `add($x, $y)` Psalm tries to infer the value `T` for that particular call. When calling `add(1, 2)`, `T` can be trivially inferred as an `int`. Then Psalm takes the provided conditional return type
+
+`(T is int ? int : float)`
+
+and substitutes in the known value of `T`, `int`, so that expression becomes
+
+`(int is int ? int : float)`
+
+which simplifies to `(true ? int : float)`, which simplifies to `int`.
+
+Calling `add(1, 2.1)` means `T` would instead be inferred as `int|float`, which means the expression `(T is int ? int : float)` would instead have the substitution
+
+`(int|float is int ? int : float)`
+
+The union `int|float` is clearly not an `int`, so the expression is simplified to `(false ? int : float)`, which simplifies to `float`.
