diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php
index aac7cdb26..193c86ebc 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Assignment/ArrayAssignmentAnalyzer.php
@@ -301,7 +301,7 @@ class ArrayAssignmentAnalyzer
                     $array_type,
                     $assignment_type,
                     $array_var_id,
-                    $dim_value
+                    $dim_value !== null ? [$dim_value] : []
                 );
             }
 
@@ -338,69 +338,38 @@ class ArrayAssignmentAnalyzer
                 throw new \InvalidArgumentException('Should never get here');
             }
 
-            $key_value = null;
+            $key_values = [];
 
             if ($current_dim instanceof PhpParser\Node\Scalar\String_
                 || $current_dim instanceof PhpParser\Node\Scalar\LNumber
             ) {
-                $key_value = $current_dim->value;
-            } elseif ($current_dim instanceof PhpParser\Node\Expr\ConstFetch
+                $key_values[] = $current_dim->value;
+            } elseif ($current_dim
                 && ($current_dim_type = $statements_analyzer->node_data->getType($current_dim))
             ) {
-                $is_single_string_literal = $current_dim_type->isSingleStringLiteral();
+                $string_literals = $current_dim_type->getLiteralStrings();
+                $int_literals = $current_dim_type->getLiteralInts();
 
-                if ($is_single_string_literal || $current_dim_type->isSingleIntLiteral()) {
-                    if ($is_single_string_literal) {
-                        $key_value = $current_dim_type->getSingleStringLiteral()->value;
-                    } else {
-                        $key_value = $current_dim_type->getSingleIntLiteral()->value;
-                    }
-                }
-            }
+                $all_atomic_types = $current_dim_type->getAtomicTypes();
 
-            if ($key_value !== null) {
-                $has_matching_objectlike_property = false;
-                $has_matching_string = false;
-
-                foreach ($child_stmt_type->getAtomicTypes() as $type) {
-                    if ($type instanceof ObjectLike) {
-                        if (isset($type->properties[$key_value])) {
-                            $has_matching_objectlike_property = true;
-
-                            $type->properties[$key_value] = clone $current_type;
-                        }
+                if (count($string_literals) + count($int_literals) === count($all_atomic_types)) {
+                    foreach ($string_literals as $string_literal) {
+                        $key_values[] = $string_literal->value;
                     }
 
-                    if ($type instanceof Type\Atomic\TString && \is_int($key_value)) {
-                        $has_matching_string = true;
-
-                        if ($type instanceof Type\Atomic\TLiteralString
-                            && $current_type->isSingleStringLiteral()
-                        ) {
-                            $new_char = $current_type->getSingleStringLiteral()->value;
-
-                            if (\strlen($new_char) === 1) {
-                                $type->value[0] = $new_char;
-                            }
-                        }
+                    foreach ($int_literals as $int_literal) {
+                        $key_values[] = $int_literal->value;
                     }
                 }
+            }
 
-                if (!$has_matching_objectlike_property && !$has_matching_string) {
-                    $array_assignment_type = new Type\Union([
-                        new ObjectLike([$key_value => $current_type]),
-                    ]);
-
-                    $new_child_type = Type::combineUnionTypes(
-                        $child_stmt_type,
-                        $array_assignment_type,
-                        $codebase,
-                        true,
-                        true
-                    );
-                } else {
-                    $new_child_type = $child_stmt_type; // noop
-                }
+            if ($key_values) {
+                $new_child_type = self::updateTypeWithKeyValues(
+                    $codebase,
+                    $child_stmt_type,
+                    $current_type,
+                    $key_values
+                );
             } else {
                 if (!$current_dim) {
                     $array_assignment_type = new Type\Union([
@@ -456,74 +425,45 @@ class ArrayAssignmentAnalyzer
                     $statements_analyzer->node_data->getType($child_stmt->var) ?: Type::getMixed(),
                     $new_child_type,
                     $array_var_id,
-                    $key_value
+                    $key_values
                 );
             }
         }
 
         $root_is_string = $root_type->isString();
-        $key_value = null;
+        $key_values = [];
 
         if ($current_dim instanceof PhpParser\Node\Scalar\String_
             || ($current_dim instanceof PhpParser\Node\Scalar\LNumber && !$root_is_string)
         ) {
-            $key_value = $current_dim->value;
-        } elseif ($current_dim instanceof PhpParser\Node\Expr\ConstFetch
+            $key_values[] = $current_dim->value;
+        } elseif ($current_dim
             && ($current_dim_type = $statements_analyzer->node_data->getType($current_dim))
             && !$root_is_string
         ) {
-            $is_single_string_literal = $current_dim_type->isSingleStringLiteral();
+            $string_literals = $current_dim_type->getLiteralStrings();
+            $int_literals = $current_dim_type->getLiteralInts();
 
-            if ($is_single_string_literal || $current_dim_type->isSingleIntLiteral()) {
-                if ($is_single_string_literal) {
-                    $key_value = $current_dim_type->getSingleStringLiteral()->value;
-                } else {
-                    $key_value = $current_dim_type->getSingleIntLiteral()->value;
-                }
-            }
-        }
-
-        if ($key_value !== null) {
-            $has_matching_objectlike_property = false;
-
-            foreach ($root_type->getAtomicTypes() as $type) {
-                if ($type instanceof ObjectLike) {
-                    if (isset($type->properties[$key_value])) {
-                        $has_matching_objectlike_property = true;
+            $all_atomic_types = $current_dim_type->getAtomicTypes();
 
-                        $type->properties[$key_value] = clone $current_type;
-                    }
-                } elseif ($type instanceof TNonEmptyList && $key_value === 0) {
-                    $has_matching_objectlike_property = true;
+            if (count($string_literals) + count($int_literals) === count($all_atomic_types)) {
+                foreach ($string_literals as $string_literal) {
+                    $key_values[] = $string_literal->value;
+                }
 
-                    $type->type_param = Type::combineUnionTypes(
-                        clone $current_type,
-                        $type->type_param,
-                        $codebase,
-                        true,
-                        false
-                    );
+                foreach ($int_literals as $int_literal) {
+                    $key_values[] = $int_literal->value;
                 }
             }
+        }
 
-            if (!$has_matching_objectlike_property) {
-                $object_like = new ObjectLike([$key_value => $current_type]);
-                $object_like->sealed = true;
-
-                $array_assignment_type = new Type\Union([
-                    $object_like,
-                ]);
-
-                $new_child_type = Type::combineUnionTypes(
-                    $root_type,
-                    $array_assignment_type,
-                    $codebase,
-                    true,
-                    false
-                );
-            } else {
-                $new_child_type = $root_type; // noop
-            }
+        if ($key_values) {
+            $new_child_type = self::updateTypeWithKeyValues(
+                $codebase,
+                $root_type,
+                $current_type,
+                $key_values
+            );
         } elseif (!$root_is_string) {
             if ($current_dim) {
                 if ($current_dim_type = $statements_analyzer->node_data->getType($current_dim)) {
@@ -742,7 +682,101 @@ class ArrayAssignmentAnalyzer
     }
 
     /**
-     * @param int|string|null $item_key_value
+     * @param non-empty-list<int|string> $key_values
+     */
+    private static function updateTypeWithKeyValues(
+        \Psalm\Codebase $codebase,
+        Type\Union $child_stmt_type,
+        Type\Union $current_type,
+        array $key_values
+    ) : Type\Union {
+        $has_matching_objectlike_property = false;
+        $has_matching_string = false;
+
+        foreach ($child_stmt_type->getAtomicTypes() as $type) {
+            foreach ($key_values as $key_value) {
+                if ($type instanceof ObjectLike) {
+                    if (isset($type->properties[$key_value])) {
+                        $has_matching_objectlike_property = true;
+
+                        $type->properties[$key_value] = clone $current_type;
+                    }
+                } elseif ($type instanceof Type\Atomic\TString
+                    && \is_int($key_value)
+                ) {
+                    $has_matching_string = true;
+
+                    if ($type instanceof Type\Atomic\TLiteralString
+                        && $current_type->isSingleStringLiteral()
+                    ) {
+                        $new_char = $current_type->getSingleStringLiteral()->value;
+
+                        if (\strlen($new_char) === 1) {
+                            $type->value[0] = $new_char;
+                        }
+                    }
+                } elseif ($type instanceof TNonEmptyList
+                    && $key_value === 0
+                    && count($key_values) === 1
+                ) {
+                    $has_matching_objectlike_property = true;
+
+                    $type->type_param = Type::combineUnionTypes(
+                        clone $current_type,
+                        $type->type_param,
+                        $codebase,
+                        true,
+                        false
+                    );
+                }
+            }
+        }
+
+        $child_stmt_type->bustCache();
+
+        if (!$has_matching_objectlike_property && !$has_matching_string) {
+            if (count($key_values) === 1) {
+                $key_value = $key_values[0];
+
+                $object_like = new ObjectLike([$key_value => clone $current_type]);
+                $object_like->sealed = true;
+
+                $array_assignment_type = new Type\Union([
+                    $object_like,
+                ]);
+            } else {
+                $array_assignment_literals = [];
+
+                foreach ($key_values as $key_value) {
+                    if (\is_int($key_value)) {
+                        $array_assignment_literals[] = new Type\Atomic\TLiteralInt($key_value);
+                    } else {
+                        $array_assignment_literals[] = new Type\Atomic\TLiteralString($key_value);
+                    }
+                }
+
+                $array_assignment_type = new Type\Union([
+                    new Type\Atomic\TNonEmptyArray([
+                        new Type\Union($array_assignment_literals),
+                        clone $current_type
+                    ])
+                ]);
+            }
+
+            return Type::combineUnionTypes(
+                $child_stmt_type,
+                $array_assignment_type,
+                $codebase,
+                true,
+                false
+            );
+        }
+
+        return $child_stmt_type;
+    }
+
+    /**
+     * @param list<int|string> $key_values
      */
     private static function taintArrayAssignment(
         StatementsAnalyzer $statements_analyzer,
@@ -750,7 +784,7 @@ class ArrayAssignmentAnalyzer
         Type\Union $stmt_type,
         Type\Union $child_stmt_type,
         ?string $array_var_id,
-        $item_key_value
+        array $key_values
     ) : void {
         $codebase = $statements_analyzer->getCodebase();
 
@@ -767,12 +801,21 @@ class ArrayAssignmentAnalyzer
             $codebase->taint->addTaintNode($new_parent_node);
 
             foreach ($child_stmt_type->parent_nodes as $parent_node) {
-                $codebase->taint->addPath(
-                    $parent_node,
-                    $new_parent_node,
-                    'array-assignment'
-                        . ($item_key_value !== null ? '-\'' . $item_key_value . '\'' : '')
-                );
+                if ($key_values) {
+                    foreach ($key_values as $key_value) {
+                        $codebase->taint->addPath(
+                            $parent_node,
+                            $new_parent_node,
+                            'array-assignment-\'' . $key_value . '\''
+                        );
+                    }
+                } else {
+                    $codebase->taint->addPath(
+                        $parent_node,
+                        $new_parent_node,
+                        'array-assignment'
+                    );
+                }
             }
 
             $stmt_type->parent_nodes[] = $new_parent_node;
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php
index d53789837..14d36ea75 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php
@@ -372,28 +372,25 @@ class ArrayFetchAnalyzer
         $has_valid_offset = false;
         $expected_offset_types = [];
 
-        $key_value = null;
+        $key_values = [];
 
         if ($stmt->dim instanceof PhpParser\Node\Scalar\String_
             || $stmt->dim instanceof PhpParser\Node\Scalar\LNumber
         ) {
-            $key_value = $stmt->dim->value;
+            $key_values[] = $stmt->dim->value;
         } elseif ($stmt->dim && ($stmt_dim_type = $statements_analyzer->node_data->getType($stmt->dim))) {
-            foreach ($stmt_dim_type->getAtomicTypes() as $possible_value_type) {
-                if ($possible_value_type instanceof TLiteralString
-                    || $possible_value_type instanceof TLiteralInt
-                ) {
-                    if ($key_value !== null) {
-                        $key_value = null;
-                        break;
-                    }
+            $string_literals = $stmt_dim_type->getLiteralStrings();
+            $int_literals = $stmt_dim_type->getLiteralInts();
 
-                    $key_value = $possible_value_type->value;
-                } elseif ($possible_value_type instanceof TString
-                    || $possible_value_type instanceof TInt
-                ) {
-                    $key_value = null;
-                    break;
+            $all_atomic_types = $stmt_dim_type->getAtomicTypes();
+
+            if (count($string_literals) + count($int_literals) === count($all_atomic_types)) {
+                foreach ($string_literals as $string_literal) {
+                    $key_values[] = $string_literal->value;
+                }
+
+                foreach ($int_literals as $int_literal) {
+                    $key_values[] = $int_literal->value;
                 }
             }
         }
@@ -557,11 +554,13 @@ class ArrayFetchAnalyzer
                 if ($in_assignment
                     && $type instanceof TArray
                     && (($type->type_params[0]->isEmpty() && $type->type_params[1]->isEmpty())
-                        || ($type->type_params[1]->hasMixed() && \is_string($key_value)))
+                        || ($type->type_params[1]->hasMixed()
+                            && count($key_values) === 1
+                            &&  \is_string($key_values[0])))
                 ) {
                     $from_empty_array = $type->type_params[0]->isEmpty() && $type->type_params[1]->isEmpty();
 
-                    if ($key_value !== null) {
+                    if (count($key_values) === 1) {
                         $from_mixed_array = $type->type_params[1]->isMixed();
 
                         $previous_key_type = $type->type_params[0];
@@ -569,7 +568,9 @@ class ArrayFetchAnalyzer
 
                         // ok, type becomes an ObjectLike
                         $array_type->removeType($type_string);
-                        $type = new ObjectLike([$key_value => $from_mixed_array ? Type::getMixed() : Type::getEmpty()]);
+                        $type = new ObjectLike([
+                            $key_values[0] => $from_mixed_array ? Type::getMixed() : Type::getEmpty()
+                        ]);
 
                         $type->sealed = $from_empty_array;
 
@@ -588,9 +589,9 @@ class ArrayFetchAnalyzer
                     && $type instanceof ObjectLike
                     && $type->previous_value_type
                     && $type->previous_value_type->isMixed()
-                    && $key_value !== null
+                    && count($key_values) === 1
                 ) {
-                    $type->properties[$key_value] = Type::getMixed();
+                    $type->properties[$key_values[0]] = Type::getMixed();
                 }
 
                 $offset_type = self::replaceOffsetTypeWithInts($offset_type);
@@ -759,7 +760,10 @@ class ArrayFetchAnalyzer
                     // if we're assigning to an empty array with a key offset, refashion that array
                     if (!$in_assignment) {
                         if (!$type instanceof TNonEmptyList
-                            || ($key_value > 0 && $key_value > ($type->count - 1))
+                            || (count($key_values) === 1
+                                && is_int($key_values[0])
+                                && $key_values[0] > 0
+                                && $key_values[0] > ($type->count - 1))
                         ) {
                             $expected_offset_type = Type::getInt();
 
@@ -898,89 +902,91 @@ class ArrayFetchAnalyzer
                     $generic_key_type = $type->getGenericKeyType();
 
                     if (!$stmt->dim && $type->sealed && $type->is_list) {
-                        $key_value = count($type->properties);
+                        $key_values[] = count($type->properties);
                     }
 
-                    if ($key_value !== null) {
-                        if (isset($type->properties[$key_value]) || $replacement_type) {
-                            $has_valid_offset = true;
+                    if ($key_values) {
+                        foreach ($key_values as $key_value) {
+                            if (isset($type->properties[$key_value]) || $replacement_type) {
+                                $has_valid_offset = true;
 
-                            if ($replacement_type) {
-                                if (isset($type->properties[$key_value])) {
-                                    $type->properties[$key_value] = Type::combineUnionTypes(
-                                        $type->properties[$key_value],
-                                        $replacement_type
-                                    );
-                                } else {
-                                    $type->properties[$key_value] = $replacement_type;
+                                if ($replacement_type) {
+                                    if (isset($type->properties[$key_value])) {
+                                        $type->properties[$key_value] = Type::combineUnionTypes(
+                                            $type->properties[$key_value],
+                                            $replacement_type
+                                        );
+                                    } else {
+                                        $type->properties[$key_value] = $replacement_type;
+                                    }
                                 }
-                            }
 
-                            if (!$array_access_type) {
-                                $array_access_type = clone $type->properties[$key_value];
-                            } else {
-                                $array_access_type = Type::combineUnionTypes(
-                                    $array_access_type,
-                                    $type->properties[$key_value]
-                                );
-                            }
-                        } elseif ($in_assignment) {
-                            $type->properties[$key_value] = new Type\Union([new TEmpty]);
+                                if (!$array_access_type) {
+                                    $array_access_type = clone $type->properties[$key_value];
+                                } else {
+                                    $array_access_type = Type::combineUnionTypes(
+                                        $array_access_type,
+                                        $type->properties[$key_value]
+                                    );
+                                }
+                            } elseif ($in_assignment) {
+                                $type->properties[$key_value] = new Type\Union([new TEmpty]);
 
-                            if (!$array_access_type) {
-                                $array_access_type = clone $type->properties[$key_value];
-                            } else {
-                                $array_access_type = Type::combineUnionTypes(
-                                    $array_access_type,
-                                    $type->properties[$key_value]
-                                );
-                            }
-                        } elseif ($type->previous_value_type) {
-                            if ($codebase->config->ensure_array_string_offsets_exist) {
-                                self::checkLiteralStringArrayOffset(
-                                    $offset_type,
-                                    $type->getGenericKeyType(),
-                                    $array_var_id,
-                                    $stmt,
-                                    $context,
-                                    $statements_analyzer
-                                );
-                            }
+                                if (!$array_access_type) {
+                                    $array_access_type = clone $type->properties[$key_value];
+                                } else {
+                                    $array_access_type = Type::combineUnionTypes(
+                                        $array_access_type,
+                                        $type->properties[$key_value]
+                                    );
+                                }
+                            } elseif ($type->previous_value_type) {
+                                if ($codebase->config->ensure_array_string_offsets_exist) {
+                                    self::checkLiteralStringArrayOffset(
+                                        $offset_type,
+                                        $type->getGenericKeyType(),
+                                        $array_var_id,
+                                        $stmt,
+                                        $context,
+                                        $statements_analyzer
+                                    );
+                                }
 
-                            if ($codebase->config->ensure_array_int_offsets_exist) {
-                                self::checkLiteralIntArrayOffset(
-                                    $offset_type,
-                                    $type->getGenericKeyType(),
-                                    $array_var_id,
-                                    $stmt,
-                                    $context,
-                                    $statements_analyzer
-                                );
-                            }
+                                if ($codebase->config->ensure_array_int_offsets_exist) {
+                                    self::checkLiteralIntArrayOffset(
+                                        $offset_type,
+                                        $type->getGenericKeyType(),
+                                        $array_var_id,
+                                        $stmt,
+                                        $context,
+                                        $statements_analyzer
+                                    );
+                                }
 
-                            $type->properties[$key_value] = clone $type->previous_value_type;
+                                $type->properties[$key_value] = clone $type->previous_value_type;
 
-                            $array_access_type = clone $type->previous_value_type;
-                        } elseif ($array_type->hasMixed()) {
-                            $has_valid_offset = true;
+                                $array_access_type = clone $type->previous_value_type;
+                            } elseif ($array_type->hasMixed()) {
+                                $has_valid_offset = true;
 
-                            $array_access_type = Type::getMixed();
-                        } else {
-                            if ($type->sealed || !$context->inside_isset) {
-                                $object_like_keys = array_keys($type->properties);
+                                $array_access_type = Type::getMixed();
+                            } else {
+                                if ($type->sealed || !$context->inside_isset) {
+                                    $object_like_keys = array_keys($type->properties);
+
+                                    if (count($object_like_keys) === 1) {
+                                        $expected_keys_string = '\'' . $object_like_keys[0] . '\'';
+                                    } else {
+                                        $last_key = array_pop($object_like_keys);
+                                        $expected_keys_string = '\'' . implode('\', \'', $object_like_keys) .
+                                            '\' or \'' . $last_key . '\'';
+                                    }
 
-                                if (count($object_like_keys) === 1) {
-                                    $expected_keys_string = '\'' . $object_like_keys[0] . '\'';
-                                } else {
-                                    $last_key = array_pop($object_like_keys);
-                                    $expected_keys_string = '\'' . implode('\', \'', $object_like_keys) .
-                                        '\' or \'' . $last_key . '\'';
+                                    $expected_offset_types[] = $expected_keys_string;
                                 }
 
-                                $expected_offset_types[] = $expected_keys_string;
+                                $array_access_type = Type::getMixed();
                             }
-
-                            $array_access_type = Type::getMixed();
                         }
                     } else {
                         $key_type = $generic_key_type->hasMixed()
@@ -1421,9 +1427,9 @@ class ArrayFetchAnalyzer
 
                 $used_offset = 'using a ' . $offset_type->getId() . ' offset';
 
-                if ($key_value !== null) {
+                if ($key_values) {
                     $used_offset = 'using offset value of '
-                        . (is_int($key_value) ? $key_value : '\'' . $key_value . '\'');
+                        . (is_int($key_values[0]) ? $key_values[0] : '\'' . $key_values[0] . '\'');
                 }
 
                 if ($has_valid_offset && $context->inside_isset) {
diff --git a/tests/ArrayAssignmentTest.php b/tests/ArrayAssignmentTest.php
index b92850c02..30825c1a9 100644
--- a/tests/ArrayAssignmentTest.php
+++ b/tests/ArrayAssignmentTest.php
@@ -361,7 +361,7 @@ class ArrayAssignmentTest extends TestCase
                     $c[$b][$b][] = "bam";',
                 'assertions' => [
                     '$a' => 'array{boop: non-empty-list<string>}',
-                    '$c' => 'array{boop: non-empty-array<string, non-empty-list<string>>}',
+                    '$c' => 'array{boop: array{boop: non-empty-list<string>}}',
                 ],
             ],
             'assignExplicitValueToGeneric' => [
@@ -491,7 +491,7 @@ class ArrayAssignmentTest extends TestCase
                     $d[$int] = 3;
                     $d["a"] = 5;',
                 'assertions' => [
-                    '$d' => 'non-empty-array<int|string, int>',
+                    '$d' => 'array{5: int, a: int}',
                 ],
             ],
             'updateStringIntKey5' => [
@@ -504,7 +504,7 @@ class ArrayAssignmentTest extends TestCase
                     $e[$int] = 3;
                     $e[$string] = 5;',
                 'assertions' => [
-                    '$e' => 'non-empty-array<int|string, int>',
+                    '$e' => 'array{5: int, c: int}',
                 ],
             ],
             'updateStringIntKeyWithIntRootAndNumberOffset' => [
@@ -545,10 +545,10 @@ class ArrayAssignmentTest extends TestCase
                     $e[0][$int] = 3;
                     $e[0][$string] = 5;',
                 'assertions' => [
-                    '$b' => 'array{0: non-empty-array<int|string, int>}',
-                    '$c' => 'array{0: non-empty-array<int|string, int>}',
-                    '$d' => 'array{0: non-empty-array<int|string, int>}',
-                    '$e' => 'array{0: non-empty-array<int|string, int>}',
+                    '$b' => 'array{0: array{0: int, c: int}}',
+                    '$c' => 'array{0: array{0: int, c: int}}',
+                    '$d' => 'array{0: array{5: int, a: int}}',
+                    '$e' => 'array{0: array{5: int, c: int}}',
                 ],
             ],
             'updateStringIntKeyWithObjectLikeRootAndNumberOffset' => [
@@ -589,10 +589,10 @@ class ArrayAssignmentTest extends TestCase
                     $e["root"][$int] = 3;
                     $e["root"][$string] = 5;',
                 'assertions' => [
-                    '$b' => 'array{root: non-empty-array<int|string, int>}',
-                    '$c' => 'array{root: non-empty-array<int|string, int>}',
-                    '$d' => 'array{root: non-empty-array<int|string, int>}',
-                    '$e' => 'array{root: non-empty-array<int|string, int>}',
+                    '$b' => 'array{root: array{0: int, c: int}}',
+                    '$c' => 'array{root: array{0: int, c: int}}',
+                    '$d' => 'array{root: array{5: int, a: int}}',
+                    '$e' => 'array{root: array{5: int, c: int}}',
                 ],
             ],
             'mixedArrayAssignmentWithStringKeys' => [
@@ -707,6 +707,17 @@ class ArrayAssignmentTest extends TestCase
                 ],
                 'error_levels' => ['MixedMethodCall'],
             ],
+            'mixedSwallowsArrayAssignment' => [
+                '<?php
+                    /** @psalm-suppress MixedAssignment */
+                    $a = $_GET["foo"];
+
+                    /** @psalm-suppress MixedArrayAssignment */
+                    $a["bar"] = "cool";
+
+                    /** @psalm-suppress MixedMethodCall */
+                    $a->offsetExists("baz");',
+            ],
             'implementsArrayAccessInheritingDocblock' => [
                 '<?php
                     class A implements \ArrayAccess
@@ -1430,9 +1441,20 @@ class ArrayAssignmentTest extends TestCase
                     /** @psalm-suppress MixedArrayAssignment */
                     $options[\'b\'][\'c\'] = 2;',
                 [
-                    '$options[\'b\']' => 'array{c: int}|mixed'
+                    '$options[\'b\']' => 'mixed'
                 ]
             ],
+            'assignWithLiteralStringKey' => [
+                '<?php
+                    /**
+                     * @param array<int, array{internal: bool, ported: bool}> $i
+                     * @return array<int, array{internal: bool, ported: bool}>
+                     */
+                    function addOneEntry(array $i, int $id): array {
+                        $i[$id][rand(0, 1) ? "internal" : "ported"] = true;
+                        return $i;
+                    }'
+            ],
         ];
     }
 
