diff --git a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
index 7cb5cffc2..24b54c99f 100644
--- a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
@@ -1265,8 +1265,6 @@ class ClassAnalyzer extends ClassLikeAnalyzer
 
         $analyzed_method_id = $actual_method_id;
 
-        $classlike_storage_provider = $codebase->classlike_storage_provider;
-
         $included_file_path = $source->getFilePath();
 
         if ($class_context->include_location) {
@@ -1288,13 +1286,15 @@ class ClassAnalyzer extends ClassLikeAnalyzer
                 }
 
                 if ($declaring_method_id && $declaring_method_storage->abstract) {
-                    $appearing_storage = $classlike_storage_provider->get($class_context->self);
                     $implementer_method_storage = $codebase->methods->getStorage($declaring_method_id);
+                    $declaring_storage = $codebase->classlike_storage_provider->get(
+                        explode('::', $actual_method_id)[0]
+                    );
 
                     MethodAnalyzer::compareMethods(
                         $codebase,
                         $class_storage,
-                        $appearing_storage,
+                        $declaring_storage,
                         $implementer_method_storage,
                         $declaring_method_storage,
                         $this->fq_class_name,
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
index 705a9b48e..d62995e36 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
@@ -866,17 +866,40 @@ class MethodCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
 
         $fq_class_name = $codebase->classlikes->getUnAliasedName($fq_class_name);
 
-        $class_storage = $codebase->methods->getClassLikeStorageForMethod($method_id);
+        $parent_source = $statements_analyzer->getSource();
 
         $class_template_params = self::getClassTemplateParams(
             $codebase,
-            $class_storage,
+            $codebase->methods->getClassLikeStorageForMethod($method_id),
             $fq_class_name,
             $method_name_lc,
             $lhs_type_part,
             $lhs_var_id
         );
 
+        if ($lhs_var_id === '$this' && $parent_source instanceof \Psalm\Internal\Analyzer\FunctionLikeAnalyzer) {
+            $grandparent_source = $parent_source->getSource();
+
+            if ($grandparent_source instanceof \Psalm\Internal\Analyzer\TraitAnalyzer) {
+                $fq_trait_name = $grandparent_source->getFQCLN();
+
+                $trait_storage = $codebase->classlike_storage_provider->get($fq_trait_name);
+
+                if (isset($trait_storage->methods[$method_name_lc])) {
+                    $trait_method_id = $fq_trait_name . '::' . $method_name_lc;
+
+                    $class_template_params = self::getClassTemplateParams(
+                        $codebase,
+                        $codebase->methods->getClassLikeStorageForMethod($trait_method_id),
+                        $fq_class_name,
+                        $method_name_lc,
+                        $lhs_type_part,
+                        $lhs_var_id
+                    );
+                }
+            }
+        }
+
         if (self::checkMethodArgs(
             $method_id,
             $args,
@@ -935,6 +958,8 @@ class MethodCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                 }
             }
 
+            $class_storage = $codebase->methods->getClassLikeStorageForMethod($method_id);
+
             if (!$return_type_candidate) {
                 if ($call_map_id && CallMap::inCallMap($call_map_id)) {
                     if (($class_template_params || $class_storage->stubbed)
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index 22cb4f9ca..daeb61e8b 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -1441,6 +1441,13 @@ class CallAnalyzer
                     $codebase,
                     $arg->value->inferredType
                 );
+
+                $arg_type->replaceTemplateTypesWithStandins(
+                    $existing_generic_params,
+                    $empty_generic_params,
+                    $codebase,
+                    $arg->value->inferredType
+                );
             }
 
             if ($template_types) {
diff --git a/src/Psalm/Internal/Codebase/Populator.php b/src/Psalm/Internal/Codebase/Populator.php
index 55c5cb151..ec812bed7 100644
--- a/src/Psalm/Internal/Codebase/Populator.php
+++ b/src/Psalm/Internal/Codebase/Populator.php
@@ -998,8 +998,19 @@ class Populator
 
         // register where they're declared
         foreach ($parent_storage->inheritable_method_ids as $method_name => $declaring_method_id) {
-            if (!$parent_storage->is_trait && $method_name !== '__construct') {
-                $storage->overridden_method_ids[$method_name][] = $declaring_method_id;
+            if ($method_name !== '__construct') {
+                if ($parent_storage->is_trait) {
+                    $declaring_class = explode('::', $declaring_method_id)[0];
+                    $declaring_class_storage = $this->classlike_storage_provider->get($declaring_class);
+
+                    if (isset($declaring_class_storage->methods[$method_name])
+                        && $declaring_class_storage->methods[$method_name]->abstract
+                    ) {
+                        $storage->overridden_method_ids[$method_name][] = $declaring_method_id;
+                    }
+                } else {
+                    $storage->overridden_method_ids[$method_name][] = $declaring_method_id;
+                }
             }
 
             $aliased_method_names = [$method_name];
diff --git a/tests/MethodSignatureTest.php b/tests/MethodSignatureTest.php
index 3e10cffed..2dcf191bd 100644
--- a/tests/MethodSignatureTest.php
+++ b/tests/MethodSignatureTest.php
@@ -627,7 +627,7 @@ class MethodSignatureTest extends TestCase
                     class B extends A {
                         use T;
                     }',
-                'error_message' => 'ImplementedReturnTypeMismatch',
+                'error_message' => 'MethodSignatureMismatch',
             ],
             'abstractTraitMethodWithDifferentReturnType' => [
                 '<?php
@@ -645,7 +645,7 @@ class MethodSignatureTest extends TestCase
                             return new B();
                         }
                     }',
-                'error_message' => 'ImplementedReturnTypeMismatch',
+                'error_message' => 'MethodSignatureMismatch',
             ],
             'mustOmitReturnType' => [
                 '<?php
diff --git a/tests/Template/TemplateExtendsTest.php b/tests/Template/TemplateExtendsTest.php
index dcb4f0f52..fa85d71f2 100644
--- a/tests/Template/TemplateExtendsTest.php
+++ b/tests/Template/TemplateExtendsTest.php
@@ -1674,6 +1674,99 @@ class TemplateExtendsTest extends TestCase
                         }
                     }'
             ],
+            'allowTraitExtendAndImplementWithExplicitParamType' => [
+                '<?php
+                    /**
+                     * @template T
+                     */
+                    trait ValueObjectTrait
+                    {
+                        /**
+                         * @psalm-var ?T
+                         */
+                        protected $value;
+
+                        /**
+                         * @psalm-param T $value
+                         *
+                         * @param $value
+                         */
+                        private function setValue($value): void {
+                            $this->validate($value);
+
+                            $this->value = $value;
+                        }
+
+                        /**
+                         * @psalm-param T $value
+                         *
+                         * @param $value
+                         */
+                        abstract protected function validate($value): void;
+                    }
+
+                    final class StringValidator {
+                        /**
+                         * @template-use ValueObjectTrait<string>
+                         */
+                        use ValueObjectTrait;
+
+                        /**
+                         * @param string $value
+                         */
+                        protected function validate($value): void
+                        {
+                            if (strlen($value) > 30) {
+                                throw new \Exception("bad");
+                            }
+                        }
+                    }',
+            ],
+            'allowTraitExtendAndImplementWithoutExplicitParamType' => [
+                '<?php
+                    /**
+                     * @template T
+                     */
+                    trait ValueObjectTrait
+                    {
+                        /**
+                         * @psalm-var ?T
+                         */
+                        protected $value;
+
+                        /**
+                         * @psalm-param T $value
+                         *
+                         * @param $value
+                         */
+                        private function setValue($value): void {
+                            $this->validate($value);
+
+                            $this->value = $value;
+                        }
+
+                        /**
+                         * @psalm-param T $value
+                         *
+                         * @param $value
+                         */
+                        abstract protected function validate($value): void;
+                    }
+
+                    final class StringValidator {
+                        /**
+                         * @template-use ValueObjectTrait<string>
+                         */
+                        use ValueObjectTrait;
+
+                        protected function validate($value): void
+                        {
+                            if (strlen($value) > 30) {
+                                throw new \Exception("bad");
+                            }
+                        }
+                    }',
+            ],
         ];
     }
 
