diff --git a/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php b/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php
index a13080ee2..d83833018 100644
--- a/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/FunctionLikeAnalyzer.php
@@ -1372,124 +1372,6 @@ abstract class FunctionLikeAnalyzer extends SourceAnalyzer implements Statements
         return $this->codebase;
     }
 
-    /**
-     * @param  string                           $method_id
-     * @param  array<int, PhpParser\Node\Arg>   $args
-     *
-     * @return array<int, FunctionLikeParameter>
-     */
-    public static function getFunctionParamsFromCallMapById(Codebase $codebase, $method_id, array $args)
-    {
-        $function_param_options = CallMap::getParamsFromCallMap($method_id);
-
-        if ($function_param_options === null) {
-            throw new \UnexpectedValueException(
-                'Not expecting $function_param_options to be null for ' . $method_id
-            );
-        }
-
-        return self::getMatchingParamsFromCallMapOptions($codebase, $function_param_options, $args);
-    }
-
-    /**
-     * @param  array<int, array<int, FunctionLikeParameter>>  $function_param_options
-     * @param  array<int, PhpParser\Node\Arg>                 $args
-     *
-     * @return array<int, FunctionLikeParameter>
-     */
-    public static function getMatchingParamsFromCallMapOptions(
-        Codebase $codebase,
-        array $function_param_options,
-        array $args
-    ) {
-        if (count($function_param_options) === 1) {
-            return $function_param_options[0];
-        }
-
-        foreach ($function_param_options as $possible_function_params) {
-            $all_args_match = true;
-
-            $last_param = count($possible_function_params)
-                ? $possible_function_params[count($possible_function_params) - 1]
-                : null;
-
-            $mandatory_param_count = count($possible_function_params);
-
-            foreach ($possible_function_params as $i => $possible_function_param) {
-                if ($possible_function_param->is_optional) {
-                    $mandatory_param_count = $i;
-                    break;
-                }
-            }
-
-            if ($mandatory_param_count > count($args) && !($last_param && $last_param->is_variadic)) {
-                continue;
-            }
-
-            foreach ($args as $argument_offset => $arg) {
-                if ($argument_offset >= count($possible_function_params)) {
-                    if (!$last_param || !$last_param->is_variadic) {
-                        $all_args_match = false;
-                        break;
-                    }
-
-                    $function_param = $last_param;
-                } else {
-                    $function_param = $possible_function_params[$argument_offset];
-                }
-
-                $param_type = $function_param->type;
-
-                if (!$param_type) {
-                    continue;
-                }
-
-                if (!isset($arg->value->inferredType)) {
-                    continue;
-                }
-
-                $arg_type = $arg->value->inferredType;
-
-                if ($arg_type->hasMixed()) {
-                    continue;
-                }
-
-                if ($arg->unpack && !$function_param->is_variadic) {
-                    if ($arg_type->hasArray()) {
-                        /** @var Type\Atomic\TArray|Type\Atomic\ObjectLike */
-                        $array_atomic_type = $arg_type->getTypes()['array'];
-
-                        if ($array_atomic_type instanceof Type\Atomic\ObjectLike) {
-                            $array_atomic_type = $array_atomic_type->getGenericArrayType();
-                        }
-
-                        $arg_type = $array_atomic_type->type_params[1];
-                    }
-                }
-
-                if (TypeAnalyzer::isContainedBy(
-                    $codebase,
-                    $arg_type,
-                    $param_type,
-                    true,
-                    true
-                )) {
-                    continue;
-                }
-
-                $all_args_match = false;
-                break;
-            }
-
-            if ($all_args_match) {
-                return $possible_function_params;
-            }
-        }
-
-        // if we don't succeed in finding a match, set to the first possible and wait for issues below
-        return $function_param_options[0];
-    }
-
     /**
      * Get a list of suppressed issues
      *
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
index dfeb08b82..5ff544bfc 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
@@ -297,11 +297,13 @@ class FunctionCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expressio
                     }
 
                     if ($in_call_map && !$is_stubbed) {
-                        $function_params = FunctionLikeAnalyzer::getFunctionParamsFromCallMapById(
+                        $function_callable = \Psalm\Internal\Codebase\CallMap::getCallableFromCallMapById(
                             $codebase,
                             $function_id,
                             $stmt->args
                         );
+
+                        $function_params = $function_callable->params;
                     }
                 }
 
@@ -344,11 +346,13 @@ class FunctionCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expressio
         if ($function_exists) {
             if ($stmt->name instanceof PhpParser\Node\Name && $function_id) {
                 if (!$is_stubbed && $in_call_map) {
-                    $function_params = FunctionLikeAnalyzer::getFunctionParamsFromCallMapById(
+                    $function_callable = \Psalm\Internal\Codebase\CallMap::getCallableFromCallMapById(
                         $codebase,
                         $function_id,
                         $stmt->args
                     );
+
+                    $function_params = $function_callable->params;
                 }
             }
 
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
index 10851c46f..251e6f48a 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
@@ -1017,7 +1017,13 @@ class MethodCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                             );
                         }
                     } else {
-                        $return_type_candidate = CallMap::getReturnTypeFromCallMap($call_map_id);
+                        $callmap_callables = CallMap::getCallablesFromCallMap($call_map_id);
+
+                        if (!$callmap_callables || $callmap_callables[0]->return_type === null) {
+                            throw new \UnexpectedValueException('Shouldn’t get here');
+                        }
+
+                        $return_type_candidate = $callmap_callables[0]->return_type;
                     }
 
                     if ($return_type_candidate->isFalsable()) {
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index 8115d7277..a22c675a8 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -1936,42 +1936,36 @@ class CallAnalyzer
                     );
 
                     if (CallMap::inCallMap($function_id)) {
-                        $callmap_params_options = CallMap::getParamsFromCallMap($function_id);
+                        $callmap_callables = CallMap::getCallablesFromCallMap($function_id);
 
-                        if ($callmap_params_options === null) {
+                        if ($callmap_callables === null) {
                             throw new \UnexpectedValueException('This should not happen');
                         }
 
-                        $passing_callmap_params_options = [];
+                        $passing_callmap_callables = [];
 
-                        foreach ($callmap_params_options as $callmap_params_option) {
+                        foreach ($callmap_callables as $callmap_callable) {
                             $required_param_count = 0;
 
-                            foreach ($callmap_params_option as $i => $param) {
+                            assert($callmap_callable->params !== null);
+
+                            foreach ($callmap_callable->params as $i => $param) {
                                 if (!$param->is_optional && !$param->is_variadic) {
                                     $required_param_count = $i + 1;
                                 }
                             }
 
                             if ($required_param_count <= $max_closure_param_count) {
-                                $passing_callmap_params_options[] = $callmap_params_option;
+                                $passing_callmap_callables[] = $callmap_callable;
                             }
                         }
 
-                        if ($passing_callmap_params_options) {
-                            foreach ($passing_callmap_params_options as $passing_callmap_params_option) {
-                                $closure_types[] = new Type\Atomic\TFn(
-                                    'Closure',
-                                    $passing_callmap_params_option,
-                                    $function_storage->return_type ?: Type::getMixed()
-                                );
+                        if ($passing_callmap_callables) {
+                            foreach ($passing_callmap_callables as $passing_callmap_callable) {
+                                $closure_types[] = $passing_callmap_callable;
                             }
                         } else {
-                            $closure_types[] = new Type\Atomic\TFn(
-                                'Closure',
-                                $callmap_params_options[0],
-                                $function_storage->return_type ?: Type::getMixed()
-                            );
+                            $closure_types[] = $callmap_callables[0];
                         }
                     } else {
                         $closure_types[] = new Type\Atomic\TFn(
@@ -2006,9 +2000,10 @@ class CallAnalyzer
     }
 
     /**
+     * @param  Type\Atomic\TFn|Type\Atomic\TCallable $closure_type
      * @param  string   $method_id
      * @param  int      $min_closure_param_count
-     * @param  int      $max_closure_param_count [description]
+     * @param  int      $max_closure_param_count
      * @param  (TArray|null)[] $array_arg_types
      *
      * @return false|null
@@ -2016,7 +2011,7 @@ class CallAnalyzer
     private static function checkArrayFunctionClosureTypeArgs(
         StatementsAnalyzer $statements_analyzer,
         $method_id,
-        Type\Atomic\TFn $closure_type,
+        Type\Atomic $closure_type,
         PhpParser\Node\Arg $closure_arg,
         $min_closure_param_count,
         $max_closure_param_count,
diff --git a/src/Psalm/Internal/Analyzer/TypeAnalyzer.php b/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
index 681f8077a..1e47de7ad 100644
--- a/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
@@ -1270,7 +1270,7 @@ class TypeAnalyzer
                 }
             }
 
-            $input_callable = self::getCallableFromAtomic($codebase, $input_type_part);
+            $input_callable = self::getCallableFromAtomic($codebase, $input_type_part, $container_type_part);
 
             if ($input_callable) {
                 $all_types_contain = true;
@@ -1421,8 +1421,11 @@ class TypeAnalyzer
     /**
      * @return ?TCallable
      */
-    public static function getCallableFromAtomic(Codebase $codebase, Type\Atomic $input_type_part)
-    {
+    public static function getCallableFromAtomic(
+        Codebase $codebase,
+        Type\Atomic $input_type_part,
+        ?TCallable $container_type_part = null
+    ) : ?TCallable {
         if ($input_type_part instanceof TLiteralString) {
             try {
                 $function_storage = $codebase->functions->getStorage(null, $input_type_part->value);
@@ -1434,16 +1437,24 @@ class TypeAnalyzer
                 );
             } catch (\Exception $e) {
                 if (CallMap::inCallMap($input_type_part->value)) {
-                    $function_params = FunctionLikeAnalyzer::getFunctionParamsFromCallMapById(
+                    $args = [];
+
+                    if ($container_type_part && $container_type_part->params) {
+                        foreach ($container_type_part->params as $i => $param) {
+                            $arg = new \PhpParser\Node\Arg(
+                                new \PhpParser\Node\Expr\Variable('_' . $i)
+                            );
+
+                            $arg->value->inferredType = $param->type;
+
+                            $args[] = $arg;
+                        }
+                    }
+
+                    return \Psalm\Internal\Codebase\CallMap::getCallableFromCallMapById(
                         $codebase,
                         $input_type_part->value,
-                        []
-                    );
-
-                    return new TCallable(
-                        'callable',
-                        $function_params,
-                        CallMap::getReturnTypeFromCallMap($input_type_part->value)
+                        $args
                     );
                 }
             }
diff --git a/src/Psalm/Internal/Codebase/CallMap.php b/src/Psalm/Internal/Codebase/CallMap.php
index ebf6904d6..77afcb927 100644
--- a/src/Psalm/Internal/Codebase/CallMap.php
+++ b/src/Psalm/Internal/Codebase/CallMap.php
@@ -1,8 +1,12 @@
 <?php
 namespace Psalm\Internal\Codebase;
 
+use PhpParser;
+use Psalm\Codebase;
 use Psalm\Internal\Analyzer\ProjectAnalyzer;
+use Psalm\Internal\Analyzer\TypeAnalyzer;
 use Psalm\Type;
+use Psalm\Type\Atomic\TCallable;
 use Psalm\Storage\FunctionLikeParameter;
 
 /**
@@ -29,14 +33,145 @@ class CallMap
      */
     private static $call_map = null;
 
+    /**
+     * @var array<array<int, TCallable>>|null
+     */
+    private static $call_map_callables = [];
+
+    /**
+     * @param  string                           $method_id
+     * @param  array<int, PhpParser\Node\Arg>   $args
+     *
+     * @return TCallable
+     */
+    public static function getCallableFromCallMapById(Codebase $codebase, $method_id, array $args)
+    {
+        $possible_callables = self::getCallablesFromCallMap($method_id);
+
+        if ($possible_callables === null) {
+            throw new \UnexpectedValueException(
+                'Not expecting $function_param_options to be null for ' . $method_id
+            );
+        }
+
+        return self::getMatchingCallableFromCallMapOptions($codebase, $possible_callables, $args);
+    }
+
+    /**
+     * @param  array<int, TCallable>  $callables
+     * @param  array<int, PhpParser\Node\Arg>                 $args
+     *
+     * @return TCallable
+     */
+    public static function getMatchingCallableFromCallMapOptions(
+        Codebase $codebase,
+        array $callables,
+        array $args
+    ) {
+        if (count($callables) === 1) {
+            return $callables[0];
+        }
+
+        foreach ($callables as $possible_callable) {
+            $possible_function_params = $possible_callable->params;
+
+            assert($possible_function_params !== null);
+
+            $all_args_match = true;
+
+            $last_param = count($possible_function_params)
+                ? $possible_function_params[count($possible_function_params) - 1]
+                : null;
+
+            $mandatory_param_count = count($possible_function_params);
+
+            foreach ($possible_function_params as $i => $possible_function_param) {
+                if ($possible_function_param->is_optional) {
+                    $mandatory_param_count = $i;
+                    break;
+                }
+            }
+
+            if ($mandatory_param_count > count($args) && !($last_param && $last_param->is_variadic)) {
+                continue;
+            }
+
+            foreach ($args as $argument_offset => $arg) {
+                if ($argument_offset >= count($possible_function_params)) {
+                    if (!$last_param || !$last_param->is_variadic) {
+                        $all_args_match = false;
+                        break;
+                    }
+
+                    $function_param = $last_param;
+                } else {
+                    $function_param = $possible_function_params[$argument_offset];
+                }
+
+                $param_type = $function_param->type;
+
+                if (!$param_type) {
+                    continue;
+                }
+
+                if (!isset($arg->value->inferredType)) {
+                    continue;
+                }
+
+                $arg_type = $arg->value->inferredType;
+
+                if ($arg_type->hasMixed()) {
+                    continue;
+                }
+
+                if ($arg->unpack && !$function_param->is_variadic) {
+                    if ($arg_type->hasArray()) {
+                        /** @var Type\Atomic\TArray|Type\Atomic\ObjectLike */
+                        $array_atomic_type = $arg_type->getTypes()['array'];
+
+                        if ($array_atomic_type instanceof Type\Atomic\ObjectLike) {
+                            $array_atomic_type = $array_atomic_type->getGenericArrayType();
+                        }
+
+                        $arg_type = $array_atomic_type->type_params[1];
+                    }
+                }
+
+                if (TypeAnalyzer::isContainedBy(
+                    $codebase,
+                    $arg_type,
+                    $param_type,
+                    true,
+                    true
+                )) {
+                    continue;
+                }
+
+                $all_args_match = false;
+                break;
+            }
+
+            if ($all_args_match) {
+                return $possible_callable;
+            }
+        }
+
+        // if we don't succeed in finding a match, set to the first possible and wait for issues below
+        return $callables[0];
+    }
+
     /**
      * @param  string $function_id
      *
      * @return array|null
-     * @psalm-return array<int, array<int, FunctionLikeParameter>>|null
+     * @psalm-return array<int, TCallable>|null
      */
-    public static function getParamsFromCallMap($function_id)
+    public static function getCallablesFromCallMap($function_id)
     {
+        if (isset(self::$call_map_callables[$function_id])) {
+            return self::$call_map_callables[$function_id];
+        }
+
         $call_map = self::getCallMap();
 
         $call_map_key = strtolower($function_id);
@@ -56,10 +191,16 @@ class CallMap
             $call_map_functions[] = $call_map[$call_map_key . '\'' . $i];
         }
 
-        $function_param_options = [];
+        $possible_callables = [];
 
         foreach ($call_map_functions as $call_map_function_args) {
-            array_shift($call_map_function_args);
+            $return_type_string = array_shift($call_map_function_args);
+
+            if (!$return_type_string) {
+                $return_type = Type::getMixed();
+            } else {
+                $return_type = Type::parseString($return_type_string);
+            }
 
             $function_params = [];
 
@@ -104,38 +245,12 @@ class CallMap
                 $function_params[] = $function_param;
             }
 
-            $function_param_options[] = $function_params;
-        }
-
-        return $function_param_options;
-    }
-
-    /**
-     * @param  string  $function_id
-     *
-     * @return Type\Union
-     */
-    public static function getReturnTypeFromCallMap($function_id)
-    {
-        $call_map_key = strtolower($function_id);
-
-        $call_map = self::getCallMap();
-
-        if (!isset($call_map[$call_map_key])) {
-            throw new \InvalidArgumentException('Function ' . $function_id . ' was not found in callmap');
+            $possible_callables[] = new TCallable('callable', $function_params, $return_type);
         }
 
-        if (!$call_map[$call_map_key][0]) {
-            return Type::getMixed();
-        }
-
-        $call_map_type = Type::parseString($call_map[$call_map_key][0]);
-
-        if ($call_map_type->isNullable()) {
-            $call_map_type->from_docblock = true;
-        }
+        self::$call_map_callables[$function_id] = $possible_callables;
 
-        return $call_map_type;
+        return $possible_callables;
     }
 
     /**
diff --git a/src/Psalm/Internal/Codebase/Methods.php b/src/Psalm/Internal/Codebase/Methods.php
index 654b98d7d..02071369a 100644
--- a/src/Psalm/Internal/Codebase/Methods.php
+++ b/src/Psalm/Internal/Codebase/Methods.php
@@ -324,16 +324,18 @@ class Methods
             $class_storage = $this->classlike_storage_provider->get($declaring_fq_class_name);
 
             if (!$class_storage->stubbed) {
-                $function_param_options = CallMap::getParamsFromCallMap($declaring_method_id ?: $method_id);
+                $function_callables = CallMap::getCallablesFromCallMap($declaring_method_id ?: $method_id);
 
-                if ($function_param_options === null) {
+                if ($function_callables === null) {
                     throw new \UnexpectedValueException(
-                        'Not expecting $function_param_options to be null for ' . $declaring_method_id
+                        'Not expecting $function_callables to be null for ' . $declaring_method_id
                     );
                 }
 
-                if (!$source || $args === null || count($function_param_options) === 1) {
-                    return $function_param_options[0];
+                if (!$source || $args === null || count($function_callables) === 1) {
+                    assert($function_callables[0]->params !== null);
+
+                    return $function_callables[0]->params;
                 }
 
                 if ($context && $source instanceof \Psalm\Internal\Analyzer\StatementsAnalyzer) {
@@ -346,11 +348,15 @@ class Methods
                     }
                 }
 
-                return FunctionLikeAnalyzer::getMatchingParamsFromCallMapOptions(
+                $matching_callable = CallMap::getMatchingCallableFromCallMapOptions(
                     $source->getCodebase(),
-                    $function_param_options,
+                    $function_callables,
                     $args
                 );
+
+                assert($matching_callable->params !== null);
+
+                return $matching_callable->params;
             }
         }
 
@@ -596,7 +602,13 @@ class Methods
                 }
             }
 
-            $return_type_candidate = CallMap::getReturnTypeFromCallMap($appearing_method_id);
+            $callmap_callables = CallMap::getCallablesFromCallMap($appearing_method_id);
+
+            if (!$callmap_callables || $callmap_callables[0]->return_type === null) {
+                throw new \UnexpectedValueException('Shouldn’t get here');
+            }
+
+            $return_type_candidate = $callmap_callables[0]->return_type;
 
             if ($return_type_candidate->isFalsable()) {
                 $return_type_candidate->ignore_falsable_issues = true;
diff --git a/src/Psalm/Internal/Codebase/Reflection.php b/src/Psalm/Internal/Codebase/Reflection.php
index 10e728165..d8ed830dd 100644
--- a/src/Psalm/Internal/Codebase/Reflection.php
+++ b/src/Psalm/Internal/Codebase/Reflection.php
@@ -251,20 +251,26 @@ class Reflection
         $class_storage->appearing_method_ids[$method_name] = $class_storage->declaring_method_ids[$method_name];
         $class_storage->overridden_method_ids[$method_name] = [];
 
-        try {
-            $storage->return_type = CallMap::getReturnTypeFromCallMap($method_id);
-            $storage->return_type->queueClassLikesForScanning($this->codebase);
-        } catch (\InvalidArgumentException $e) {
-            // do nothing
-        }
-
         $storage->visibility = $method->isPrivate()
             ? ClassLikeAnalyzer::VISIBILITY_PRIVATE
             : ($method->isProtected() ? ClassLikeAnalyzer::VISIBILITY_PROTECTED : ClassLikeAnalyzer::VISIBILITY_PUBLIC);
 
-        $possible_params = CallMap::getParamsFromCallMap($method_id);
+        $callables = CallMap::getCallablesFromCallMap($method_id);
+
+        if ($callables && $callables[0]->params !== null && $callables[0]->return_type !== null) {
+            $storage->params = [];
+
+            foreach ($callables[0]->params as $param) {
+                if ($param->type) {
+                    $param->type->queueClassLikesForScanning($this->codebase);
+                }
+            }
 
-        if ($possible_params === null) {
+            $storage->params = $callables[0]->params;
+
+            $storage->return_type = $callables[0]->return_type;
+            $storage->return_type->queueClassLikesForScanning($this->codebase);
+        } else {
             $params = $method->getParameters();
 
             $storage->params = [];
@@ -275,14 +281,6 @@ class Reflection
                 $storage->params[] = $param_array;
                 $storage->param_types[$param->name] = $param_array->type;
             }
-        } else {
-            foreach ($possible_params[0] as $param) {
-                if ($param->type) {
-                    $param->type->queueClassLikesForScanning($this->codebase);
-                }
-            }
-
-            $storage->params = $possible_params[0];
         }
 
         $storage->required_param_count = 0;
@@ -332,24 +330,24 @@ class Reflection
         try {
             $reflection_function = new \ReflectionFunction($function_id);
 
-            $callmap_function_params = null;
-
-            $callmap_return_type = null;
+            $callmap_callable = null;
 
             $storage = self::$builtin_functions[$function_id] = new FunctionLikeStorage();
 
             if (CallMap::inCallMap($function_id)) {
-                $callmap_function_params = FunctionLikeAnalyzer::getFunctionParamsFromCallMapById(
+                $callmap_callable = \Psalm\Internal\Codebase\CallMap::getCallableFromCallMapById(
                     $this->codebase,
                     $function_id,
                     []
                 );
-
-                $callmap_return_type = CallMap::getReturnTypeFromCallMap($function_id);
             }
 
-            if ($callmap_function_params !== null) {
-                $storage->params = $callmap_function_params;
+            if ($callmap_callable !== null
+                && $callmap_callable->params !== null
+                && $callmap_callable->return_type !== null
+            ) {
+                $storage->params = $callmap_callable->params;
+                $storage->return_type = $callmap_callable->return_type;
             } else {
                 $reflection_params = $reflection_function->getParameters();
 
@@ -358,6 +356,10 @@ class Reflection
                     $param_obj = $this->getReflectionParamData($param);
                     $storage->params[] = $param_obj;
                 }
+
+                if ($reflection_return_type = $reflection_function->getReturnType()) {
+                    $storage->return_type = self::getPsalmTypeFromReflectionType($reflection_return_type);
+                }
             }
 
             $storage->required_param_count = 0;
@@ -369,12 +371,6 @@ class Reflection
             }
 
             $storage->cased_name = $reflection_function->getName();
-
-            if ($callmap_return_type) {
-                $storage->return_type = $callmap_return_type;
-            } elseif ($reflection_return_type = $reflection_function->getReturnType()) {
-                $storage->return_type = self::getPsalmTypeFromReflectionType($reflection_return_type);
-            }
         } catch (\ReflectionException $e) {
             return false;
         }
diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayColumnReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayColumnReturnTypeProvider.php
index daeedf7da..eedaa771a 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayColumnReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayColumnReturnTypeProvider.php
@@ -93,6 +93,10 @@ class ArrayColumnReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturn
             ]);
         }
 
-        return CallMap::getReturnTypeFromCallMap($function_id);
+        $callmap_callables = CallMap::getCallablesFromCallMap($function_id);
+
+        assert($callmap_callables && $callmap_callables[0]->return_type);
+
+        return $callmap_callables[0]->return_type;
     }
 }
diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php
index 50c39801c..cb1994122 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php
@@ -77,6 +77,10 @@ class IteratorToArrayReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionRe
             }
         }
 
-        return CallMap::getReturnTypeFromCallMap($function_id);
+        $callmap_callables = CallMap::getCallablesFromCallMap($function_id);
+
+        assert($callmap_callables && $callmap_callables[0]->return_type);
+
+        return $callmap_callables[0]->return_type;
     }
 }
diff --git a/src/Psalm/Internal/Visitor/ReflectorVisitor.php b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
index 7987e8f76..59739ea12 100644
--- a/src/Psalm/Internal/Visitor/ReflectorVisitor.php
+++ b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
@@ -698,11 +698,13 @@ class ReflectorVisitor extends PhpParser\NodeVisitorAbstract implements PhpParse
         string $function_id,
         PhpParser\Node\Expr\FuncCall $node
     ) {
-        $function_params = CallMap::getParamsFromCallMap($function_id);
+        $callables = CallMap::getCallablesFromCallMap($function_id);
 
-        if ($function_params) {
-            foreach ($function_params as $function_param_group) {
-                foreach ($function_param_group as $function_param) {
+        if ($callables) {
+            foreach ($callables as $callable) {
+                assert($callable->params !== null);
+
+                foreach ($callable->params as $function_param) {
                     if ($function_param->type) {
                         $function_param->type->queueClassLikesForScanning(
                             $this->codebase,
@@ -710,13 +712,13 @@ class ReflectorVisitor extends PhpParser\NodeVisitorAbstract implements PhpParse
                         );
                     }
                 }
+
+                if ($callable->return_type && !$callable->return_type->hasMixed()) {
+                    $callable->return_type->queueClassLikesForScanning($this->codebase, $this->file_storage);
+                }
             }
         }
 
-        $return_type = CallMap::getReturnTypeFromCallMap($function_id);
-
-        $return_type->queueClassLikesForScanning($this->codebase, $this->file_storage);
-
         if ($function_id === 'define') {
             $first_arg_value = isset($node->args[0]) ? $node->args[0]->value : null;
             $second_arg_value = isset($node->args[1]) ? $node->args[1]->value : null;
diff --git a/tests/FunctionCallTest.php b/tests/FunctionCallTest.php
index 8ed1397bb..7038ffc10 100644
--- a/tests/FunctionCallTest.php
+++ b/tests/FunctionCallTest.php
@@ -1725,6 +1725,11 @@ class FunctionCallTest extends TestCase
                        if (count($iterableObject) === 0) {}
                     }',
             ],
+            'versionCompareAsCallable' => [
+                '<?php
+                    $a = ["1.0", "2.0"];
+                    uksort($a, "version_compare");'
+            ],
         ];
     }
 
