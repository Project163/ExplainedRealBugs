diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayFilterReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayFilterReturnTypeProvider.php
index b13b910fc..c57eb4289 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayFilterReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayFilterReturnTypeProvider.php
@@ -10,11 +10,13 @@ use Psalm\Context;
 use Psalm\Internal\Analyzer\StatementsAnalyzer;
 use Psalm\Internal\Analyzer\Statements\Expression\AssertionFinder;
 use Psalm\Internal\Codebase\InternalCallMapHandler;
+use Psalm\Internal\Analyzer\Statements\Expression\ExpressionIdentifier;
 use Psalm\Issue\InvalidReturnType;
 use Psalm\IssueBuffer;
 use Psalm\StatementsSource;
 use Psalm\Type;
 use Psalm\Type\Reconciler;
+use Psalm\Internal\Analyzer\Statements\Expression\CallAnalyzer;
 
 class ArrayFilterReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTypeProviderInterface
 {
@@ -98,62 +100,58 @@ class ArrayFilterReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturn
         } elseif (!isset($call_args[2])) {
             $function_call_arg = $call_args[1];
 
-            $second_arg_value = $function_call_arg->value;
-
-            if ($second_arg_value instanceof PhpParser\Node\Scalar\String_
-                && InternalCallMapHandler::inCallMap($second_arg_value->value)
+            if ($function_call_arg->value instanceof PhpParser\Node\Scalar\String_
+                || $function_call_arg->value instanceof PhpParser\Node\Expr\Array_
+                || $function_call_arg->value instanceof PhpParser\Node\Expr\BinaryOp\Concat
             ) {
-                $callables = InternalCallMapHandler::getCallablesFromCallMap($second_arg_value->value);
-
-                if ($callables) {
-                    $callable = clone $callables[0];
-
-                    if ($callable->params !== null && $callable->return_type) {
-                        $second_arg_value = new PhpParser\Node\Expr\Closure([
-                            'params' => array_map(
-                                function (\Psalm\Storage\FunctionLikeParameter $param) {
-                                    return new PhpParser\Node\Param(
-                                        new PhpParser\Node\Expr\Variable($param->name)
-                                    );
-                                },
-                                $callable->params
-                            ),
-                            'stmts' => [
-                                new PhpParser\Node\Stmt\Return_(
-                                    new PhpParser\Node\Expr\FuncCall(
-                                        new PhpParser\Node\Name\FullyQualified(
-                                            $second_arg_value->value
-                                        ),
-                                        array_map(
-                                            function (\Psalm\Storage\FunctionLikeParameter $param) {
-                                                return new PhpParser\Node\Arg(
-                                                    new PhpParser\Node\Expr\Variable($param->name)
-                                                );
-                                            },
-                                            $callable->params
-                                        )
-                                    )
-                                ),
-                            ],
-                        ]);
-
-                        $closure_atomic_type = new Type\Atomic\TFn(
-                            'Closure',
-                            $callable->params,
-                            $callable->return_type
-                        );
+                $mapping_function_ids = CallAnalyzer::getFunctionIdsFromCallableArg(
+                    $statements_source,
+                    $function_call_arg->value
+                );
+
+                if ($array_arg && $mapping_function_ids) {
+                    $assertions = [];
+
+                    ArrayMapReturnTypeProvider::getReturnTypeFromMappingIds(
+                        $statements_source,
+                        $mapping_function_ids,
+                        $context,
+                        $function_call_arg,
+                        \array_slice($call_args, 0, 1),
+                        $assertions
+                    );
+
+                    $array_var_id = ExpressionIdentifier::getArrayVarId(
+                        $array_arg,
+                        null,
+                        $statements_source
+                    );
+
+                    if (isset($assertions[$array_var_id . '[$__fake_offset_var__]'])) {
+                        $changed_var_ids = [];
 
-                        $statements_source->node_data->setType(
-                            $second_arg_value,
-                            new Type\Union([$closure_atomic_type])
+                        $assertions = ['$inner_type' => $assertions[$array_var_id . '[$__fake_offset_var__]']];
+
+                        $reconciled_types = Reconciler::reconcileKeyedTypes(
+                            $assertions,
+                            $assertions,
+                            ['$inner_type' => $inner_type],
+                            $changed_var_ids,
+                            ['$inner_type' => true],
+                            $statements_source,
+                            $statements_source->getTemplateTypeMap() ?: [],
+                            false,
+                            new CodeLocation($statements_source, $function_call_arg->value)
                         );
+
+                        if (isset($reconciled_types['$inner_type'])) {
+                            $inner_type = $reconciled_types['$inner_type'];
+                        }
                     }
                 }
-            }
-
-            if (($second_arg_value instanceof PhpParser\Node\Expr\Closure
-                    || $second_arg_value instanceof PhpParser\Node\Expr\ArrowFunction)
-                && ($second_arg_type = $statements_source->node_data->getType($second_arg_value))
+            } elseif (($function_call_arg->value instanceof PhpParser\Node\Expr\Closure
+                    || $function_call_arg->value instanceof PhpParser\Node\Expr\ArrowFunction)
+                && ($second_arg_type = $statements_source->node_data->getType($function_call_arg->value))
                 && ($closure_types = $second_arg_type->getClosureTypes())
             ) {
                 $closure_atomic_type = \reset($closure_types);
@@ -171,9 +169,9 @@ class ArrayFilterReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturn
                     return Type::getArray();
                 }
 
-                if (count($second_arg_value->getStmts()) === 1 && count($second_arg_value->params)) {
-                    $first_param = $second_arg_value->params[0];
-                    $stmt = $second_arg_value->getStmts()[0];
+                if (count($function_call_arg->value->getStmts()) === 1 && count($function_call_arg->value->params)) {
+                    $first_param = $function_call_arg->value->params[0];
+                    $stmt = $function_call_arg->value->getStmts()[0];
 
                     if ($first_param->variadic === false
                         && $first_param->var instanceof PhpParser\Node\Expr\Variable
diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayMapReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayMapReturnTypeProvider.php
index 76001282e..32ab00ed3 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayMapReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayMapReturnTypeProvider.php
@@ -13,6 +13,7 @@ use Psalm\Internal\Type\ArrayType;
 use Psalm\StatementsSource;
 use Psalm\Type;
 use function strpos;
+use Psalm\Internal\Analyzer\Statements\Expression\AssertionFinder;
 
 class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTypeProviderInterface
 {
@@ -229,10 +230,14 @@ class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
             : Type::getList();
     }
 
+    /**
+     * @param-out array<string, array<array<string>>>|null $assertions
+     */
     private static function executeFakeCall(
         \Psalm\Internal\Analyzer\StatementsAnalyzer $statements_analyzer,
         PhpParser\Node\Expr $fake_call,
-        Context $context
+        Context $context,
+        ?array &$assertions = null
     ) : ?Type\Union {
         $old_data_provider = $statements_analyzer->node_data;
 
@@ -274,6 +279,17 @@ class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
             throw new \UnexpectedValueException('UnrecognizedCall');
         }
 
+        $codebase = $statements_analyzer->getCodebase();
+
+        if ($assertions !== null) {
+            $assertions = AssertionFinder::scrapeAssertions(
+                $fake_call,
+                null,
+                $statements_analyzer,
+                $codebase
+            );
+        }
+
         $context->inside_call = $was_inside_call;
 
         if (!in_array('PossiblyInvalidMethodCall', $suppressed_issues, true)) {
@@ -294,13 +310,15 @@ class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
     /**
      * @param non-empty-array<string> $mapping_function_ids
      * @param array<PhpParser\Node\Arg> $array_args
+     * @param-out array<string, array<array<string>>>|null $assertions
      */
-    private static function getReturnTypeFromMappingIds(
+    public static function getReturnTypeFromMappingIds(
         \Psalm\Internal\Analyzer\StatementsAnalyzer $statements_source,
         array $mapping_function_ids,
         Context $context,
         PhpParser\Node\Arg $function_call_arg,
-        array $array_args
+        array $array_args,
+        ?array &$assertions = null
     ) : Type\Union {
         $mapping_return_type = null;
 
@@ -363,7 +381,8 @@ class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
                         $fake_method_return_type = self::executeFakeCall(
                             $statements_source,
                             $fake_method_call,
-                            $context
+                            $context,
+                            $assertions
                         );
 
                         unset($context->vars_in_scope['$__fake_offset_var__']);
@@ -387,7 +406,8 @@ class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
                         $fake_method_return_type = self::executeFakeCall(
                             $statements_source,
                             $fake_method_call,
-                            $context
+                            $context,
+                            $assertions
                         );
 
                         unset($context->vars_in_scope['$__fake_offset_var__']);
@@ -409,7 +429,8 @@ class ArrayMapReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
                     $fake_function_return_type = self::executeFakeCall(
                         $statements_source,
                         $fake_function_call,
-                        $context
+                        $context,
+                        $assertions
                     );
 
                     unset($context->vars_in_scope['$__fake_offset_var__']);
