diff --git a/src/Psalm/Internal/Type/AssertionReconciler.php b/src/Psalm/Internal/Type/AssertionReconciler.php
index 2ad021ec7..cdb48c64b 100644
--- a/src/Psalm/Internal/Type/AssertionReconciler.php
+++ b/src/Psalm/Internal/Type/AssertionReconciler.php
@@ -267,6 +267,28 @@ class AssertionReconciler extends \Psalm\Type\Reconciler
             );
         }
 
+        if ($assertion === 'string-array-access') {
+            return self::reconcileStringArrayAccess(
+                $codebase,
+                $existing_var_type,
+                $key,
+                $code_location,
+                $suppressed_issues,
+                $failed_reconciliation
+            );
+        }
+
+        if ($assertion === 'int-or-string-array-access') {
+            return self::reconcileIntArrayAccess(
+                $codebase,
+                $existing_var_type,
+                $key,
+                $code_location,
+                $suppressed_issues,
+                $failed_reconciliation
+            );
+        }
+
         if ($assertion === 'numeric' && !$existing_var_type->hasMixed()) {
             return self::reconcileNumeric(
                 $existing_var_type,
@@ -1332,6 +1354,126 @@ class AssertionReconciler extends \Psalm\Type\Reconciler
         return Type::getMixed();
     }
 
+    /**
+     * @param   string[]  $suppressed_issues
+     * @param   0|1|2    $failed_reconciliation
+     */
+    private static function reconcileStringArrayAccess(
+        Codebase $codebase,
+        Union $existing_var_type,
+        ?string $key,
+        ?CodeLocation $code_location,
+        array $suppressed_issues,
+        int &$failed_reconciliation
+    ) : Union {
+        $old_var_type_string = $existing_var_type->getId();
+
+        $existing_var_atomic_types = $existing_var_type->getTypes();
+
+        if ($existing_var_type->hasMixed() || $existing_var_type->hasTemplate()) {
+            return new Union([
+                new Atomic\TNonEmptyArray([Type::getArrayKey(), Type::getMixed()]),
+                new TNamedObject('ArrayAccess'),
+            ]);
+        }
+
+        $array_types = [];
+
+        foreach ($existing_var_atomic_types as $type) {
+            if ($type->isArrayAccessibleWithStringKey($codebase)) {
+                if (get_class($type) === TArray::class) {
+                    $array_types[] = new Atomic\TNonEmptyArray($type->type_params);
+                } else {
+                    $array_types[] = $type;
+                }
+            } elseif ($type instanceof TTemplateParam) {
+                $array_types[] = $type;
+            }
+        }
+
+        if (!$array_types) {
+            if ($key && $code_location) {
+                self::triggerIssueForImpossible(
+                    $existing_var_type,
+                    $old_var_type_string,
+                    $key,
+                    'string-array-access',
+                    true,
+                    $code_location,
+                    $suppressed_issues
+                );
+            }
+        }
+
+        if ($array_types) {
+            return new Type\Union($array_types);
+        }
+
+        $failed_reconciliation = 2;
+
+        return Type::getMixed();
+    }
+
+    /**
+     * @param   string[]  $suppressed_issues
+     * @param   0|1|2    $failed_reconciliation
+     */
+    private static function reconcileIntArrayAccess(
+        Codebase $codebase,
+        Union $existing_var_type,
+        ?string $key,
+        ?CodeLocation $code_location,
+        array $suppressed_issues,
+        int &$failed_reconciliation
+    ) : Union {
+        $old_var_type_string = $existing_var_type->getId();
+
+        $existing_var_atomic_types = $existing_var_type->getTypes();
+
+        if ($existing_var_type->hasMixed()) {
+            return new Union([
+                new Atomic\TNonEmptyArray([Type::getArrayKey(), Type::getMixed()]),
+                new TNamedObject('ArrayAccess'),
+            ]);
+        }
+
+        $array_types = [];
+
+        foreach ($existing_var_atomic_types as $type) {
+            if ($type->isArrayAccessibleWithIntOrStringKey($codebase)) {
+                if (get_class($type) === TArray::class) {
+                    $array_types[] = new Atomic\TNonEmptyArray($type->type_params);
+                } else {
+                    $array_types[] = $type;
+                }
+            } elseif ($type instanceof TTemplateParam) {
+                $array_types[] = $type;
+            }
+        }
+
+        if (!$array_types) {
+            if ($key && $code_location) {
+                self::triggerIssueForImpossible(
+                    $existing_var_type,
+                    $old_var_type_string,
+                    $key,
+                    'int-or-string-array-access',
+                    true,
+                    $code_location,
+                    $suppressed_issues
+                );
+            }
+        }
+
+        if ($array_types) {
+            return new Type\Union($array_types);
+        }
+
+        $failed_reconciliation = 2;
+
+        return Type::getMixed();
+    }
+
     /**
      * @param   string[]  $suppressed_issues
      * @param   0|1|2    $failed_reconciliation
diff --git a/src/Psalm/Internal/Visitor/ReflectorVisitor.php b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
index 897083b23..7f5727efc 100644
--- a/src/Psalm/Internal/Visitor/ReflectorVisitor.php
+++ b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
@@ -1941,7 +1941,7 @@ class ReflectorVisitor extends PhpParser\NodeVisitorAbstract implements PhpParse
 
                     $param_index = \array_search($param_name, \array_keys($storage->param_types), true);
 
-                    if (!isset($storage->params[$param_index]->type)) {
+                    if ($param_index === false || !isset($storage->params[$param_index]->type)) {
                         continue;
                     }
 
diff --git a/src/Psalm/Type/Atomic.php b/src/Psalm/Type/Atomic.php
index 951d22df8..3b5a18ece 100644
--- a/src/Psalm/Type/Atomic.php
+++ b/src/Psalm/Type/Atomic.php
@@ -341,6 +341,54 @@ abstract class Atomic
             );
     }
 
+    /**
+     * @return bool
+     */
+    public function isArrayAccessibleWithStringKey(Codebase $codebase)
+    {
+        return $this instanceof TArray
+            || $this instanceof ObjectLike
+            || $this->hasArrayAccessInterface($codebase)
+            || ($this instanceof TNamedObject && $this->value === 'SimpleXMLElement');
+    }
+
+    /**
+     * @return bool
+     */
+    public function isArrayAccessibleWithIntOrStringKey(Codebase $codebase)
+    {
+        return $this instanceof TString
+            || $this->isArrayAccessibleWithStringKey($codebase);
+    }
+
+    /**
+     * @return bool
+     */
+    private function hasArrayAccessInterface(Codebase $codebase)
+    {
+        return $this instanceof TNamedObject
+            && (
+                strtolower($this->value) === 'arrayaccess'
+                || ($codebase->classOrInterfaceExists($this->value)
+                    && ($codebase->classExtendsOrImplements(
+                        $this->value,
+                        'ArrayAccess'
+                    ) || $codebase->interfaceExtends(
+                        $this->value,
+                        'ArrayAccess'
+                    )))
+                || (
+                    $this->extra_types
+                    && array_filter(
+                        $this->extra_types,
+                        function (Atomic $a) use ($codebase) : bool {
+                            return $a->hasArrayAccessInterface($codebase);
+                        }
+                    )
+                )
+            );
+    }
+
     /**
      * @param  StatementsSource $source
      * @param  CodeLocation     $code_location
diff --git a/src/Psalm/Type/Reconciler.php b/src/Psalm/Type/Reconciler.php
index 254c02338..87dfed604 100644
--- a/src/Psalm/Type/Reconciler.php
+++ b/src/Psalm/Type/Reconciler.php
@@ -102,12 +102,12 @@ class Reconciler
 
                 $base_key = array_shift($key_parts);
 
-                if (!isset($new_types[$base_key])) {
-                    $new_types[$base_key] = [['!~bool'], ['!~int'], ['=isset']];
-                } else {
-                    $new_types[$base_key][] = ['!~bool'];
-                    $new_types[$base_key][] = ['!~int'];
-                    $new_types[$base_key][] = ['=isset'];
+                if (!isset($existing_types[$base_key]) || $existing_types[$base_key]->isNullable()) {
+                    if (!isset($new_types[$base_key])) {
+                        $new_types[$base_key] = [['=isset']];
+                    } else {
+                        $new_types[$base_key][] = ['=isset'];
+                    }
                 }
 
                 while ($key_parts) {
@@ -120,12 +120,17 @@ class Reconciler
                         $new_base_key = $base_key . '[' . $array_key . ']';
 
                         if (strpos($array_key, '\'') !== false) {
-                            $new_types[$base_key][] = ['!string'];
-                            $new_types[$base_key][] = ['!=falsy'];
+                            $new_types[$base_key][] = ['=string-array-access'];
+                        } else {
+                            $new_types[$base_key][] = ['=int-or-string-array-access'];
                         }
 
                         $base_key = $new_base_key;
-                    } elseif ($divider === '->') {
+
+                        continue;
+                    }
+
+                    if ($divider === '->') {
                         $property_name = array_shift($key_parts);
                         $new_base_key = $base_key . '->' . $property_name;
 
diff --git a/tests/IssetTest.php b/tests/IssetTest.php
index 87c74398e..ee524a442 100644
--- a/tests/IssetTest.php
+++ b/tests/IssetTest.php
@@ -164,8 +164,8 @@ class IssetTest extends TestCase
             'issetVariableKeysWithoutChange' => [
                 '<?php
                     $arr = [[1, 2, 3], null, [1, 2, 3], null];
-                    $b = 2;
-                    $c = 0;
+                    $b = rand(0, 2);
+                    $c = rand(0, 2);
                     if (isset($arr[$b][$c])) {
                         echo $arr[$b][$c];
                     }',
diff --git a/tests/TypeReconciliationTest.php b/tests/TypeReconciliationTest.php
index f7261eb0a..dda168811 100644
--- a/tests/TypeReconciliationTest.php
+++ b/tests/TypeReconciliationTest.php
@@ -1418,6 +1418,47 @@ class TypeReconciliationTest extends TestCase
                         if ($a[0] === 5) {}
                     }'
             ],
+            'assertHasArrayAccess' => [
+                '<?php
+                    /**
+                     * @return array|ArrayAccess
+                     */
+                    function getBar(array $array) {
+                        if (isset($array[\'foo\'][\'bar\'])) {
+                            return $array[\'foo\'];
+                        }
+
+                        return [];
+                    }',
+            ],
+            'assertHasArrayAccessWithType' => [
+                '<?php
+                    /**
+                     * @param array<string, array<string, string>> $array
+                     * @return array<string, string>
+                     */
+                    function getBar(array $array) : array {
+                        if (isset($array[\'foo\'][\'bar\'])) {
+                            return $array[\'foo\'];
+                        }
+
+                        return [];
+                    }',
+            ],
+            'assertHasArrayAccessOnSimpleXMLElement' => [
+                '<?php
+                    function getBar(SimpleXMLElement $e, string $s) : void {
+                        if (isset($e[$s])) {
+                            echo (string) $e[$s];
+                        }
+
+                        if (isset($e[\'foo\'])) {
+                            echo (string) $e[\'foo\'];
+                        }
+
+                        if (isset($e->bar)) {}
+                    }',
+            ],
         ];
     }
 
