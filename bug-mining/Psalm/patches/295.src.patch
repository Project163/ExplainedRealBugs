diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php
index 0c3c8d737..50f07bd53 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php
@@ -59,10 +59,15 @@ class ArrayPopReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
                 $nullable = true;
             }
         } else {
-            $value_type = $first_arg_array->getGenericValueType();
+            // special case where we know the type of the first element
+            if ($function_id === 'array_shift' && $first_arg_array->is_list && isset($first_arg_array->properties[0])) {
+                $value_type = clone $first_arg_array->properties[0];
+            } else {
+                $value_type = $first_arg_array->getGenericValueType();
 
-            if (!$first_arg_array->sealed && !$first_arg_array->previous_value_type) {
-                $nullable = true;
+                if (!$first_arg_array->sealed && !$first_arg_array->previous_value_type) {
+                    $nullable = true;
+                }
             }
         }
 
diff --git a/src/Psalm/Type/Reconciler.php b/src/Psalm/Type/Reconciler.php
index 74fd6a2d2..a28692b7d 100644
--- a/src/Psalm/Type/Reconciler.php
+++ b/src/Psalm/Type/Reconciler.php
@@ -723,6 +723,7 @@ class Reconciler
                 if ($base_atomic_type instanceof Type\Atomic\ObjectLike
                     || ($base_atomic_type instanceof Type\Atomic\TArray
                         && !$base_atomic_type->type_params[1]->isEmpty())
+                    || $base_atomic_type instanceof Type\Atomic\TList
                 ) {
                     $new_base_type = clone $existing_types[$base_key];
 
@@ -741,6 +742,21 @@ class Reconciler
                             $base_atomic_type->previous_key_type = $previous_key_type;
                         }
                         $base_atomic_type->previous_value_type = $previous_value_type;
+                    } elseif ($base_atomic_type instanceof Type\Atomic\TList) {
+                        $previous_key_type = Type::getInt();
+                        $previous_value_type = clone $base_atomic_type->type_param;
+
+                        $base_atomic_type = new Type\Atomic\ObjectLike(
+                            [
+                                $array_key_offset => clone $result_type,
+                            ],
+                            null
+                        );
+
+                        $base_atomic_type->is_list = true;
+
+                        $base_atomic_type->previous_key_type = $previous_key_type;
+                        $base_atomic_type->previous_value_type = $previous_value_type;
                     } else {
                         $base_atomic_type = clone $base_atomic_type;
                         $base_atomic_type->properties[$array_key_offset] = clone $result_type;
diff --git a/tests/FunctionCallTest.php b/tests/FunctionCallTest.php
index bd06e4fb1..831bf8149 100644
--- a/tests/FunctionCallTest.php
+++ b/tests/FunctionCallTest.php
@@ -345,6 +345,17 @@ class FunctionCallTest extends TestCase
                     '$b' => 'int',
                 ],
             ],
+            'arrayShiftNonEmptyList' => [
+                '<?php
+                    /** @param non-empty-list $arr */
+                    function type_of_array_shift(array $arr) : int {
+                        if (\is_int($arr[0])) {
+                            return \array_shift($arr);
+                        }
+
+                        return 0;
+                    }',
+            ],
             'noRedundantConditionAfterArrayObjectCountCheck' => [
                 '<?php
                     /** @var ArrayObject<int, int> */
