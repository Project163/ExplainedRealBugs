diff --git a/src/Psalm/Type.php b/src/Psalm/Type.php
index 6d47a2b3c..2ce5dddfc 100644
--- a/src/Psalm/Type.php
+++ b/src/Psalm/Type.php
@@ -817,9 +817,25 @@ abstract class Type
                 );
             }
 
+            if ($t instanceof Atomic\TTemplateParam) {
+                $t_atomic_types = $t->as->getAtomicTypes();
+                $t_atomic_type = count($t_atomic_types) === 1 ? reset($t_atomic_types) : null;
+
+                if (!$t_atomic_type instanceof TNamedObject) {
+                    $t_atomic_type = null;
+                }
+
+                return new Atomic\TTemplateParamClass(
+                    $t->param_name,
+                    $t_atomic_type ? $t_atomic_type->value : 'object',
+                    $t_atomic_type,
+                    $t->defining_class
+                );
+            }
+
             if (!$t instanceof TNamedObject) {
                 throw new TypeParseTreeException(
-                    'Invalid templated classname \'' . $t . '\''
+                    'Invalid templated classname \'' . $t->getId() . '\''
                 );
             }
 
diff --git a/tests/Template/FunctionTemplateAssertTest.php b/tests/Template/FunctionTemplateAssertTest.php
index 90c1049bc..9dd3c72d2 100644
--- a/tests/Template/FunctionTemplateAssertTest.php
+++ b/tests/Template/FunctionTemplateAssertTest.php
@@ -589,6 +589,36 @@ class FunctionTemplateAssertTest extends TestCase
                         }
                     }'
             ],
+            'noCrashWhenAsserting' => [
+                '<?php
+                    /**
+                     * @psalm-template ExpectedClassType of object
+                     * @psalm-param class-string<ExpectedClassType> $expectedType
+                     * @psalm-assert class-string<ExpectedClassType> $actualType
+                     */
+                    function assertIsA(string $expectedType, string $actualType): void {
+                        \assert(\is_a($actualType, $expectedType, true));
+                    }
+
+                    class Foo {
+                        /**
+                         * @psalm-template OriginalClass of object
+                         * @psalm-param class-string<OriginalClass> $originalClass
+                         * @psalm-return class-string<OriginalClass>|null
+                         */
+                        private function generateProxy(string $originalClass) : ?string {
+                            $generatedClassName = self::class . \'\\\\\' . $originalClass;
+
+                            if (class_exists($generatedClassName)) {
+                                assertIsA($originalClass, $generatedClassName);
+
+                                return $generatedClassName;
+                            }
+
+                            return null;
+                        }
+                    }',
+            ],
         ];
     }
 
