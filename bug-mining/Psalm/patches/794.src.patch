diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
index cb91c1ce3..7bb01535b 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
@@ -1176,6 +1176,7 @@ class FunctionCallAnalyzer extends CallAnalyzer
                     || $current === '|'
                     || $current === ':'
                     || $current === '#'
+                    || $current === '.'
                     || $current === ' '
                 ) {
                     continue;
diff --git a/src/Psalm/Internal/Type/UnionTemplateHandler.php b/src/Psalm/Internal/Type/UnionTemplateHandler.php
index b5db7338f..c5b0e715e 100644
--- a/src/Psalm/Internal/Type/UnionTemplateHandler.php
+++ b/src/Psalm/Internal/Type/UnionTemplateHandler.php
@@ -342,6 +342,43 @@ class UnionTemplateHandler
                 continue;
             }
 
+            if ($atomic_input_type instanceof Atomic\TLiteralClassString
+                && $base_type instanceof Atomic\TClassString
+                && $base_type->as_type
+            ) {
+                try {
+                    $classlike_storage =
+                        $codebase->classlike_storage_provider->get($atomic_input_type->value);
+
+                    if (isset($classlike_storage->template_type_extends[$base_type->as_type->value])) {
+                        $extends_list = $classlike_storage->template_type_extends[$base_type->as_type->value];
+
+                        $new_generic_params = [];
+
+                        foreach ($extends_list as $extends_key => $value) {
+                            if (is_string($extends_key)) {
+                                $new_generic_params[] = $value;
+                            }
+                        }
+
+                        if ($new_generic_params) {
+                            $atomic_input_type = new Atomic\TClassString(
+                                $base_type->as_type->value,
+                                new Atomic\TGenericObject(
+                                    $base_type->as_type->value,
+                                    $new_generic_params
+                                )
+                            );
+                        }
+
+                        $matching_atomic_types[$atomic_input_type->getId()] = $atomic_input_type;
+                        continue;
+                    }
+                } catch (\InvalidArgumentException $e) {
+                    // do nothing
+                }
+            }
+
             if ($base_type instanceof Atomic\TCallable) {
                 $matching_atomic_type = TypeAnalyzer::getCallableFromAtomic(
                     $codebase,
diff --git a/src/Psalm/Type/Atomic/TClassString.php b/src/Psalm/Type/Atomic/TClassString.php
index b3c97319a..13d031cb6 100644
--- a/src/Psalm/Type/Atomic/TClassString.php
+++ b/src/Psalm/Type/Atomic/TClassString.php
@@ -1,8 +1,13 @@
 <?php
 namespace Psalm\Type\Atomic;
 
+use Psalm\Codebase;
 use Psalm\CodeLocation;
+use Psalm\Internal\Analyzer\StatementsAnalyzer;
+use Psalm\Internal\Type\TemplateResult;
+use Psalm\Internal\Type\UnionTemplateHandler;
 use Psalm\StatementsSource;
+use Psalm\Type\Atomic;
 use function preg_quote;
 use function preg_replace;
 use function stripos;
@@ -120,4 +125,58 @@ class TClassString extends TString
     {
         return $this->as_type ? [$this->as_type] : [];
     }
+
+    public function replaceTemplateTypesWithStandins(
+        TemplateResult $template_result,
+        ?Codebase $codebase = null,
+        ?StatementsAnalyzer $statements_analyzer = null,
+        Atomic $input_type = null,
+        ?int $input_arg_offset = null,
+        ?string $calling_class = null,
+        ?string $calling_function = null,
+        bool $replace = true,
+        bool $add_upper_bound = false,
+        int $depth = 0
+    ) : Atomic {
+        $class_string = clone $this;
+
+        if (!$class_string->as_type) {
+            return $class_string;
+        }
+
+        if ($input_type instanceof TLiteralClassString) {
+            $input_object_type = new TNamedObject($input_type->value);
+        } elseif ($input_type instanceof TClassString && $input_type->as_type) {
+            $input_object_type = $input_type->as_type;
+        } else {
+            $input_object_type = new TObject();
+        }
+
+        $as_type = UnionTemplateHandler::replaceTemplateTypesWithStandins(
+            new \Psalm\Type\Union([$class_string->as_type]),
+            $template_result,
+            $codebase,
+            $statements_analyzer,
+            new \Psalm\Type\Union([$input_object_type]),
+            $input_arg_offset,
+            $calling_class,
+            $calling_function,
+            $replace,
+            $add_upper_bound,
+            $depth
+        );
+
+        $as_type_types = \array_values($as_type->getAtomicTypes());
+
+        $class_string->as_type = count($as_type_types) === 1
+            && $as_type_types[0] instanceof TNamedObject
+            ? $as_type_types[0]
+            : null;
+
+        if (!$class_string->as_type) {
+            $class_string->as = 'object';
+        }
+
+        return $class_string;
+    }
 }
diff --git a/tests/Template/ClassTemplateExtendsTest.php b/tests/Template/ClassTemplateExtendsTest.php
index d50cf39a6..0fb3aed55 100644
--- a/tests/Template/ClassTemplateExtendsTest.php
+++ b/tests/Template/ClassTemplateExtendsTest.php
@@ -4160,7 +4160,7 @@ class ClassTemplateExtendsTest extends TestCase
                         }
                     }'
             ],
-            'SKIPPED-classStringTemplatedExtends' => [
+            'classStringTemplatedExtends' => [
                 '<?php
                     /** @template T */
                     interface CrudRequest {}
