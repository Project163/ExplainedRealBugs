diff --git a/src/Psalm/Internal/PhpVisitor/ReflectorVisitor.php b/src/Psalm/Internal/PhpVisitor/ReflectorVisitor.php
index 94970ba2c..e1fe988a2 100644
--- a/src/Psalm/Internal/PhpVisitor/ReflectorVisitor.php
+++ b/src/Psalm/Internal/PhpVisitor/ReflectorVisitor.php
@@ -2955,7 +2955,6 @@ class ReflectorVisitor extends PhpParser\NodeVisitorAbstract implements PhpParse
         foreach ($namespaced_type->getAtomicTypes() as $namespaced_type_part) {
             if ($namespaced_type_part instanceof Type\Atomic\TAssertionFalsy
                 || ($namespaced_type_part instanceof Type\Atomic\TList
-                    && !$namespaced_type_part instanceof Type\Atomic\TNonEmptyList
                     && $namespaced_type_part->type_param->isMixed())
                 || ($namespaced_type_part instanceof Type\Atomic\TArray
                     && $namespaced_type_part->type_params[0]->isArrayKey()
diff --git a/src/Psalm/Internal/Type/SimpleAssertionReconciler.php b/src/Psalm/Internal/Type/SimpleAssertionReconciler.php
index 351c1e153..329b639ee 100644
--- a/src/Psalm/Internal/Type/SimpleAssertionReconciler.php
+++ b/src/Psalm/Internal/Type/SimpleAssertionReconciler.php
@@ -193,7 +193,20 @@ class SimpleAssertionReconciler extends \Psalm\Type\Reconciler
                 $code_location,
                 $suppressed_issues,
                 $failed_reconciliation,
-                $is_equality
+                $is_equality,
+                false
+            );
+        }
+
+        if ($assertion === 'non-empty-list') {
+            return self::reconcileList(
+                $existing_var_type,
+                $key,
+                $code_location,
+                $suppressed_issues,
+                $failed_reconciliation,
+                $is_equality,
+                true
             );
         }
 
@@ -1534,22 +1547,30 @@ class SimpleAssertionReconciler extends \Psalm\Type\Reconciler
         ?CodeLocation $code_location,
         array $suppressed_issues,
         int &$failed_reconciliation,
-        bool $is_equality
+        bool $is_equality,
+        bool $is_non_empty
     ) : Union {
         $old_var_type_string = $existing_var_type->getId();
 
         $existing_var_atomic_types = $existing_var_type->getAtomicTypes();
 
         if ($existing_var_type->hasMixed() || $existing_var_type->hasTemplate()) {
-            return Type::getList();
+            return $is_non_empty ? Type::getNonEmptyList() : Type::getList();
         }
 
         $array_types = [];
         $did_remove_type = false;
 
         foreach ($existing_var_atomic_types as $type) {
-            if ($type instanceof TList || ($type instanceof ObjectLike && $type->is_list)) {
-                $array_types[] = $type;
+            if ($type instanceof TList
+                || ($type instanceof ObjectLike && $type->is_list)
+            ) {
+                if ($is_non_empty && $type instanceof TList && !$type instanceof TNonEmptyList) {
+                    $array_types[] = new TNonEmptyList($type->type_param);
+                    $did_remove_type = true;
+                } else {
+                    $array_types[] = $type;
+                }
             } elseif ($type instanceof TArray || $type instanceof ObjectLike) {
                 if ($type instanceof ObjectLike) {
                     $type = $type->getGenericArrayType();
diff --git a/src/Psalm/Type.php b/src/Psalm/Type.php
index 58df4e4cc..cddf80c97 100644
--- a/src/Psalm/Type.php
+++ b/src/Psalm/Type.php
@@ -413,6 +413,16 @@ abstract class Type
         return new Union([$type]);
     }
 
+    /**
+     * @return Type\Union
+     */
+    public static function getNonEmptyList()
+    {
+        $type = new Type\Atomic\TNonEmptyList(new Type\Union([new TMixed]));
+
+        return new Union([$type]);
+    }
+
     /**
      * @return Type\Union
      */
diff --git a/src/Psalm/Type/Atomic/TNonEmptyList.php b/src/Psalm/Type/Atomic/TNonEmptyList.php
index 80b150a71..fc81dc90e 100644
--- a/src/Psalm/Type/Atomic/TNonEmptyList.php
+++ b/src/Psalm/Type/Atomic/TNonEmptyList.php
@@ -12,4 +12,12 @@ class TNonEmptyList extends TList
     public $count;
 
     public const KEY = 'non-empty-list';
+
+    /**
+     * @return string
+     */
+    public function getAssertionString()
+    {
+        return 'non-empty-list';
+    }
 }
diff --git a/tests/AssertAnnotationTest.php b/tests/AssertAnnotationTest.php
index d31846bbb..85a61a2b1 100644
--- a/tests/AssertAnnotationTest.php
+++ b/tests/AssertAnnotationTest.php
@@ -1085,9 +1085,36 @@ class AssertAnnotationTest extends TestCase
                      *
                      * @psalm-return non-empty-list<mixed>
                      */
-                    function consume($value): array {
+                    function consume1($value): array {
                         isNonEmptyList($value);
                         return $value;
+                    }
+
+                    /**
+                     * @psalm-param list<string> $values
+                     */
+                    function consume2(array $values): void {
+                        isNonEmptyList($values);
+                        foreach ($values as $str) {}
+                        echo $str;
+                    }'
+            ],
+            'nonEmptyListOfStrings' => [
+                '<?php
+                    /**
+                     * @psalm-assert non-empty-list<string> $array
+                     *
+                     * @param mixed  $array
+                     */
+                    function isNonEmptyListOfStrings($array): void {}
+
+                    /**
+                     * @psalm-param list<string> $values
+                     */
+                    function consume2(array $values): void {
+                        isNonEmptyListOfStrings($values);
+                        foreach ($values as $str) {}
+                        echo $str;
                     }'
             ],
             'assertResource' => [
