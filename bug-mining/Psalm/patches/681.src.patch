diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php
index 806a13a4e..c2df9a485 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/AssignmentAnalyzer.php
@@ -514,37 +514,51 @@ class AssignmentAnalyzer
                 foreach ($assign_value_type->getAtomicTypes() as $assign_value_atomic_type) {
                     if ($assign_value_atomic_type instanceof Type\Atomic\ObjectLike
                         && !$assign_var_item->key
-                        && isset($assign_value_atomic_type->properties[$offset]) // if object-like has int offsets
                     ) {
-                        $offset_type = $assign_value_atomic_type->properties[(string)$offset];
+                        // if object-like has int offsets
+                        if (isset($assign_value_atomic_type->properties[$offset])) {
+                            $offset_type = $assign_value_atomic_type->properties[(string)$offset];
+
+                            if ($offset_type->possibly_undefined) {
+                                if (IssueBuffer::accepts(
+                                    new PossiblyUndefinedArrayOffset(
+                                        'Possibly undefined array key',
+                                        new CodeLocation($statements_analyzer->getSource(), $var)
+                                    ),
+                                    $statements_analyzer->getSuppressedIssues()
+                                )) {
+                                    // fall through
+                                }
+
+                                $offset_type = clone $offset_type;
+                                $offset_type->possibly_undefined = false;
+                            }
+
+                            self::analyze(
+                                $statements_analyzer,
+                                $var,
+                                null,
+                                $offset_type,
+                                $context,
+                                $doc_comment
+                            );
 
-                        if ($offset_type->possibly_undefined) {
+                            $assigned = true;
+
+                            continue;
+                        }
+
+                        if ($assign_value_atomic_type->sealed) {
                             if (IssueBuffer::accepts(
-                                new PossiblyUndefinedArrayOffset(
-                                    'Possibly undefined array key',
+                                new InvalidArrayOffset(
+                                    'Cannot access value with offset ' . $offset,
                                     new CodeLocation($statements_analyzer->getSource(), $var)
                                 ),
                                 $statements_analyzer->getSuppressedIssues()
                             )) {
                                 // fall through
                             }
-
-                            $offset_type = clone $offset_type;
-                            $offset_type->possibly_undefined = false;
                         }
-
-                        self::analyze(
-                            $statements_analyzer,
-                            $var,
-                            null,
-                            $offset_type,
-                            $context,
-                            $doc_comment
-                        );
-
-                        $assigned = true;
-
-                        continue;
                     }
 
                     if ($assign_value_atomic_type instanceof Type\Atomic\TMixed) {
diff --git a/src/Psalm/Type.php b/src/Psalm/Type.php
index 867f2c195..ea4a602e0 100644
--- a/src/Psalm/Type.php
+++ b/src/Psalm/Type.php
@@ -623,6 +623,8 @@ abstract class Type
 
             $type = $parse_tree->value;
 
+            $is_tuple = true;
+
             foreach ($parse_tree->children as $i => $property_branch) {
                 if (!$property_branch instanceof ParseTree\ObjectLikePropertyTree) {
                     $property_type = self::getTypeFromTree(
@@ -642,6 +644,7 @@ abstract class Type
                     );
                     $property_maybe_undefined = $property_branch->possibly_undefined;
                     $property_key = $property_branch->value;
+                    $is_tuple = false;
                 } else {
                     throw new TypeParseTreeException(
                         'Missing property type'
@@ -679,7 +682,13 @@ abstract class Type
                 return new Atomic\TCallableObjectLikeArray($properties);
             }
 
-            return new ObjectLike($properties);
+            $object_like = new ObjectLike($properties);
+
+            if ($is_tuple) {
+                $object_like->sealed = true;
+            }
+
+            return $object_like;
         }
 
         if ($parse_tree instanceof ParseTree\CallableWithReturnTypeTree) {
diff --git a/tests/ArrayAccessTest.php b/tests/ArrayAccessTest.php
index 943ce4ed3..642414568 100644
--- a/tests/ArrayAccessTest.php
+++ b/tests/ArrayAccessTest.php
@@ -1237,6 +1237,18 @@ class ArrayAccessTest extends TestCase
                     ["key" => $a] = maybeReturnArray();',
                 'error_message' => 'PossiblyNullArrayAccess',
             ],
+            'destructureTuple' => [
+                '<?php
+                    /**
+                     * @return array{int, int}
+                     */
+                    function size(): array {
+                        return [10, 20];
+                    }
+
+                    [$width, $height, $depth] = size();',
+                'error_message' => 'InvalidArrayOffset',
+            ],
         ];
     }
 }
