diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php b/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php
index 9d21caba1..6e3104905 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php
@@ -970,8 +970,8 @@ class AssertionFinder
             if ($var_name && $var_type) {
                 $identical = $conditional instanceof PhpParser\Node\Expr\BinaryOp\Identical
                     || ($other_type
-                        && (($var_type->isString() && $other_type->isString())
-                            || ($var_type->isInt() && $other_type->isInt())
+                        && (($var_type->isString(true) && $other_type->isString(true))
+                            || ($var_type->isInt(true) && $other_type->isInt(true))
                             || ($var_type->isFloat() && $other_type->isFloat())
                         )
                     );
diff --git a/src/Psalm/Type/Union.php b/src/Psalm/Type/Union.php
index 27b189387..dc3371830 100644
--- a/src/Psalm/Type/Union.php
+++ b/src/Psalm/Type/Union.php
@@ -1535,13 +1535,20 @@ class Union implements TypeNode
     /**
      * @return bool true if this is an int
      */
-    public function isInt()
-    {
-        if (!$this->isSingle()) {
-            return false;
-        }
-
-        return isset($this->types['int']) || $this->literal_int_types;
+    public function isInt(bool $check_templates = false)
+    {
+        return count(
+            array_filter(
+                $this->types,
+                function ($type) use ($check_templates) {
+                    return $type instanceof TInt
+                        || ($check_templates
+                            && $type instanceof TTemplateParam
+                            && $type->as->isInt()
+                        );
+                }
+            )
+        ) === count($this->types);
     }
 
     /**
@@ -1559,17 +1566,20 @@ class Union implements TypeNode
     /**
      * @return bool true if this is a string
      */
-    public function isString()
+    public function isString(bool $check_templates = false)
     {
-        if (!$this->isSingle()) {
-            return false;
-        }
-
-        return isset($this->types['string'])
-            || isset($this->types['class-string'])
-            || isset($this->types['trait-string'])
-            || isset($this->types['numeric-string'])
-            || $this->literal_string_types;
+        return count(
+            array_filter(
+                $this->types,
+                function ($type) use ($check_templates) {
+                    return $type instanceof TString
+                        || ($check_templates
+                            && $type instanceof TTemplateParam
+                            && $type->as->isString()
+                        );
+                }
+            )
+        ) === count($this->types);
     }
 
     /**
diff --git a/tests/Template/ClassTemplateTest.php b/tests/Template/ClassTemplateTest.php
index 768bdad14..299dab88a 100644
--- a/tests/Template/ClassTemplateTest.php
+++ b/tests/Template/ClassTemplateTest.php
@@ -2781,6 +2781,63 @@ class ClassTemplateTest extends TestCase
                         abstract protected function createMap(): Map;
                     }'
             ],
+            'looseEquality' => [
+                '<?php
+
+                    /**
+                     * @psalm-immutable
+                     * @template T of self::READ_UNCOMMITTED|self::READ_COMMITTED|self::REPEATABLE_READ|self::SERIALIZABLE
+                     */
+                    final class TransactionIsolationLevel
+                    {
+                        private const READ_UNCOMMITTED = "read uncommitted";
+                        private const READ_COMMITTED = "read committed";
+                        private const REPEATABLE_READ = "repeatable read";
+                        private const SERIALIZABLE = "serializable";
+
+                        /**
+                         * @psalm-var T $level
+                         */
+                        private string $level;
+
+                        /**
+                         * @psalm-param T $level
+                         */
+                        private function __construct(string $level)
+                        {
+                            $this->level = $level;
+                        }
+
+                        /**
+                         * @psalm-return self<self::READ_UNCOMMITTED>
+                         */
+                        public static function readUncommitted(): self
+                        {
+                            return new self(self::READ_UNCOMMITTED);
+                        }
+
+                        /**
+                         * @psalm-return T
+                         */
+                        public function toString(): string
+                        {
+                            return $this->level;
+                        }
+
+                        /**
+                         * @psalm-template TResult
+                         * @psalm-param callable(self::READ_UNCOMMITTED): TResult $readUncommitted
+                         * @psalm-return TResult
+                         */
+                        public function resolve(callable $readUncommitted) {
+                            if ($this->level == self::READ_UNCOMMITTED) {
+                                return $readUncommitted($this->level);
+                            }
+
+                            throw new \LogicException("bad");
+                        }
+                    }'
+            ],
         ];
     }
 
