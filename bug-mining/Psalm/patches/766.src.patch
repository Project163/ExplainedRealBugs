diff --git a/src/Psalm/Internal/Analyzer/FunctionAnalyzer.php b/src/Psalm/Internal/Analyzer/FunctionAnalyzer.php
index d34d32860..930d9d948 100644
--- a/src/Psalm/Internal/Analyzer/FunctionAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/FunctionAnalyzer.php
@@ -193,8 +193,7 @@ class FunctionAnalyzer extends FunctionLikeAnalyzer
                                     return clone $array_type->type_param;
                                 }
                             } elseif ($first_arg_type->hasScalarType()
-                                && isset($call_args[1])
-                                && ($second_arg = $call_args[1]->value)
+                                && ($second_arg = ($call_args[1]->value ?? null))
                                 && ($second_arg_type = $statements_analyzer->node_data->getType($second_arg))
                                 && $second_arg_type->hasScalarType()
                             ) {
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php b/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php
index 6e3104905..d03678a2d 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/AssertionFinder.php
@@ -123,6 +123,29 @@ class AssertionFinder
             return $if_types;
         }
 
+        if ($conditional instanceof PhpParser\Node\Expr\Assign) {
+            $var_name = ExpressionIdentifier::getArrayVarId(
+                $conditional->var,
+                $this_class_name,
+                $source
+            );
+
+            $if_types = self::scrapeAssertions(
+                $conditional->expr,
+                $this_class_name,
+                $source,
+                $codebase,
+                $inside_negation,
+                $cache
+            );
+
+            if ($var_name) {
+                $if_types[$var_name] = [['!falsy']];
+            }
+
+            return $if_types;
+        }
+
         $var_name = ExpressionIdentifier::getArrayVarId(
             $conditional,
             $this_class_name,
@@ -139,20 +162,6 @@ class AssertionFinder
             }
         }
 
-        if ($conditional instanceof PhpParser\Node\Expr\Assign) {
-            $var_name = ExpressionIdentifier::getArrayVarId(
-                $conditional->var,
-                $this_class_name,
-                $source
-            );
-
-            if ($var_name) {
-                $if_types[$var_name] = [['!falsy']];
-            }
-
-            return $if_types;
-        }
-
         if ($conditional instanceof PhpParser\Node\Expr\BooleanNot) {
             $expr_assertions = null;
 
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
index 15dfffde4..8211e127f 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
@@ -85,8 +85,7 @@ class MethodCallReturnTypeFetcher
 
         if (InternalCallMapHandler::inCallMap((string) $call_map_id)) {
             if (($template_result->upper_bounds || $class_storage->stubbed)
-                && isset($class_storage->methods[$method_id->method_name])
-                && ($method_storage = $class_storage->methods[$method_id->method_name])
+                && ($method_storage = ($class_storage->methods[$method_id->method_name] ?? null))
                 && $method_storage->return_type
             ) {
                 $return_type_candidate = clone $method_storage->return_type;
diff --git a/tests/TypeReconciliation/ConditionalTest.php b/tests/TypeReconciliation/ConditionalTest.php
index 9067d7f92..b05e89a2c 100644
--- a/tests/TypeReconciliation/ConditionalTest.php
+++ b/tests/TypeReconciliation/ConditionalTest.php
@@ -2781,6 +2781,20 @@ class ConditionalTest extends \Psalm\Tests\TestCase
                         $a->format("d-m-Y");
                     }',
             ],
+            'applyTruthyAssertionsToRightHandSideOfAssignment' => [
+                '<?php
+                    function takesAString(string $name): void {}
+
+                    function randomReturn(): ?string {
+                        return rand(1,2) === 1 ? "foo" : null;
+                    }
+
+                    $name = randomReturn();
+
+                    if ($foo = ($name !== null)) {
+                        takesAString($name);
+                    }'
+            ],
         ];
     }
 
