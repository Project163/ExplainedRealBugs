diff --git a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
index 9ee6df50b..5006a209a 100644
--- a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
@@ -1595,98 +1595,118 @@ class ClassAnalyzer extends ClassLikeAnalyzer
             && $config->reportIssueInFile('InvalidReturnType', $source->getFilePath())
             && $class_context->self
         ) {
-            $return_type_location = null;
-            $secondary_return_type_location = null;
-
-            $actual_method_storage = $codebase->methods->getStorage($actual_method_id);
-
-            if ($actual_method_id) {
-                $return_type_location = $codebase->methods->getMethodReturnTypeLocation(
-                    $actual_method_id,
-                    $secondary_return_type_location
-                );
-            }
+            self::analyzeClassMethodReturnType(
+                $stmt,
+                $method_analyzer,
+                $source,
+                $codebase,
+                $class_storage,
+                $class_context->self,
+                $analyzed_method_id,
+                $actual_method_id
+            );
+        }
 
-            $self_class = $class_context->self;
+        if (!$method_already_analyzed
+            && !$class_context->collect_initializations
+            && !$class_context->collect_mutations
+            && !$is_fake
+        ) {
+            $codebase->analyzer->setAnalyzedMethod($included_file_path, $trait_safe_method_id);
+        }
 
-            $return_type = $codebase->methods->getMethodReturnType($analyzed_method_id, $self_class);
+        return $method_analyzer;
+    }
 
-            if ($return_type && $class_storage->template_type_extends) {
-                $generic_params = [];
+    public static function analyzeClassMethodReturnType(
+        PhpParser\Node\Stmt\ClassMethod $stmt,
+        MethodAnalyzer $method_analyzer,
+        SourceAnalyzer $source,
+        Codebase $codebase,
+        ClassLikeStorage $class_storage,
+        string $fq_classlike_name,
+        string $analyzed_method_id,
+        string $actual_method_id
+    ) : void {
+        $return_type_location = null;
+        $secondary_return_type_location = null;
+
+        $actual_method_storage = $codebase->methods->getStorage($actual_method_id);
+
+        if ($actual_method_id) {
+            $return_type_location = $codebase->methods->getMethodReturnTypeLocation(
+                $actual_method_id,
+                $secondary_return_type_location
+            );
+        }
 
-                $declaring_method_id = $codebase->methods->getDeclaringMethodId($analyzed_method_id);
+        $return_type = $codebase->methods->getMethodReturnType($analyzed_method_id, $fq_classlike_name);
 
-                if ($declaring_method_id) {
-                    $declaring_class_name = explode('::', $declaring_method_id)[0];
+        if ($return_type && $class_storage->template_type_extends) {
+            $generic_params = [];
 
-                    $class_storage = $codebase->classlike_storage_provider->get($declaring_class_name);
-                }
+            $declaring_method_id = $codebase->methods->getDeclaringMethodId($analyzed_method_id);
 
-                $class_template_params = MethodCallAnalyzer::getClassTemplateParams(
-                    $codebase,
-                    $class_storage,
-                    $class_context->self,
-                    strtolower($stmt->name->name)
-                ) ?: [];
+            if ($declaring_method_id) {
+                $declaring_class_name = explode('::', $declaring_method_id)[0];
 
-                $return_type->replaceTemplateTypesWithStandins($class_template_params, $generic_params);
+                $class_storage = $codebase->classlike_storage_provider->get($declaring_class_name);
             }
 
-            $overridden_method_ids = isset($class_storage->overridden_method_ids[strtolower($stmt->name->name)])
-                ? $class_storage->overridden_method_ids[strtolower($stmt->name->name)]
-                : [];
+            $class_template_params = Statements\Expression\Call\MethodCallAnalyzer::getClassTemplateParams(
+                $codebase,
+                $class_storage,
+                $fq_classlike_name,
+                strtolower($stmt->name->name)
+            ) ?: [];
 
-            if ($actual_method_storage->overridden_downstream) {
-                $overridden_method_ids['overridden::downstream'] = 'overridden::downstream';
-            }
+            $return_type->replaceTemplateTypesWithStandins($class_template_params, $generic_params);
+        }
 
-            if (!$return_type && isset($class_storage->interface_method_ids[strtolower($stmt->name->name)])) {
-                $interface_method_ids = $class_storage->interface_method_ids[strtolower($stmt->name->name)];
+        $overridden_method_ids = isset($class_storage->overridden_method_ids[strtolower($stmt->name->name)])
+            ? $class_storage->overridden_method_ids[strtolower($stmt->name->name)]
+            : [];
 
-                foreach ($interface_method_ids as $interface_method_id) {
-                    list($interface_class) = explode('::', $interface_method_id);
+        if ($actual_method_storage->overridden_downstream) {
+            $overridden_method_ids['overridden::downstream'] = 'overridden::downstream';
+        }
 
-                    $interface_return_type = $codebase->methods->getMethodReturnType(
-                        $interface_method_id,
-                        $interface_class
-                    );
+        if (!$return_type && isset($class_storage->interface_method_ids[strtolower($stmt->name->name)])) {
+            $interface_method_ids = $class_storage->interface_method_ids[strtolower($stmt->name->name)];
 
-                    $interface_return_type_location = $codebase->methods->getMethodReturnTypeLocation(
-                        $interface_method_id
-                    );
+            foreach ($interface_method_ids as $interface_method_id) {
+                list($interface_class) = explode('::', $interface_method_id);
 
-                    ReturnTypeAnalyzer::verifyReturnType(
-                        $stmt,
-                        $source,
-                        $method_analyzer,
-                        $interface_return_type,
-                        $interface_class,
-                        $interface_return_type_location,
-                        [$analyzed_method_id]
-                    );
-                }
-            }
+                $interface_return_type = $codebase->methods->getMethodReturnType(
+                    $interface_method_id,
+                    $interface_class
+                );
 
-            ReturnTypeAnalyzer::verifyReturnType(
-                $stmt,
-                $source,
-                $method_analyzer,
-                $return_type,
-                $self_class,
-                $return_type_location,
-                $overridden_method_ids
-            );
-        }
+                $interface_return_type_location = $codebase->methods->getMethodReturnTypeLocation(
+                    $interface_method_id
+                );
 
-        if (!$method_already_analyzed
-            && !$class_context->collect_initializations
-            && !$class_context->collect_mutations
-            && !$is_fake
-        ) {
-            $codebase->analyzer->setAnalyzedMethod($included_file_path, $trait_safe_method_id);
+                FunctionLike\ReturnTypeAnalyzer::verifyReturnType(
+                    $stmt,
+                    $source,
+                    $method_analyzer,
+                    $interface_return_type,
+                    $interface_class,
+                    $interface_return_type_location,
+                    [$analyzed_method_id]
+                );
+            }
         }
 
-        return $method_analyzer;
+        FunctionLike\ReturnTypeAnalyzer::verifyReturnType(
+            $stmt,
+            $source,
+            $method_analyzer,
+            $return_type,
+            $fq_classlike_name,
+            $return_type_location,
+            $overridden_method_ids
+        );
     }
 
     /**
diff --git a/src/Psalm/Internal/Analyzer/FunctionLike/ReturnTypeAnalyzer.php b/src/Psalm/Internal/Analyzer/FunctionLike/ReturnTypeAnalyzer.php
index bdf83eae4..cb4d98038 100644
--- a/src/Psalm/Internal/Analyzer/FunctionLike/ReturnTypeAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/FunctionLike/ReturnTypeAnalyzer.php
@@ -76,12 +76,26 @@ class ReturnTypeAnalyzer
             $function_like_storage = $function_like_analyzer->getFunctionLikeStorage();
         }
 
+        $cased_method_id = $function_like_analyzer->getCorrectlyCasedMethodId();
+
         if (!$function->getStmts() &&
             (
                 $function instanceof ClassMethod &&
                 ($source instanceof InterfaceAnalyzer || $function->isAbstract())
             )
         ) {
+            if (!$return_type) {
+                if (IssueBuffer::accepts(
+                    new MissingReturnType(
+                        'Method ' . $cased_method_id . ' does not have a return type',
+                        new CodeLocation($function_like_analyzer, $function->name, null, true)
+                    ),
+                    $suppressed_issues
+                )) {
+                    // fall through
+                }
+            }
+
             return null;
         }
 
@@ -96,8 +110,6 @@ class ReturnTypeAnalyzer
             return null;
         }
 
-        $cased_method_id = $function_like_analyzer->getCorrectlyCasedMethodId();
-
         if (!$return_type_location) {
             $return_type_location = new CodeLocation(
                 $function_like_analyzer,
diff --git a/src/Psalm/Internal/Analyzer/InterfaceAnalyzer.php b/src/Psalm/Internal/Analyzer/InterfaceAnalyzer.php
index 93d13ca79..738af9812 100644
--- a/src/Psalm/Internal/Analyzer/InterfaceAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/InterfaceAnalyzer.php
@@ -4,6 +4,7 @@ namespace Psalm\Internal\Analyzer;
 use PhpParser;
 use Psalm\CodeLocation;
 use Psalm\Issue\UndefinedInterface;
+use UnexpectedValueException;
 
 /**
  * @internal
@@ -28,10 +29,11 @@ class InterfaceAnalyzer extends ClassLikeAnalyzer
             throw new \LogicException('Something went badly wrong');
         }
 
-        if ($this->class->extends) {
-            $project_analyzer = $this->file_analyzer->project_analyzer;
-            $codebase = $project_analyzer->getCodebase();
+        $project_analyzer = $this->file_analyzer->project_analyzer;
+        $codebase = $project_analyzer->getCodebase();
+        $config = $project_analyzer->getConfig();
 
+        if ($this->class->extends) {
             foreach ($this->class->extends as $extended_interface) {
                 $extended_interface_name = self::getFQCLNFromNameObject(
                     $extended_interface,
@@ -85,11 +87,36 @@ class InterfaceAnalyzer extends ClassLikeAnalyzer
             }
         }
 
+        $fq_interface_name = $this->getFQCLN();
+
+        if (!$fq_interface_name) {
+            throw new \UnexpectedValueException('bad');
+        }
+
+        $class_storage = $codebase->classlike_storage_provider->get($fq_interface_name);
+
         foreach ($this->class->stmts as $stmt) {
             if ($stmt instanceof PhpParser\Node\Stmt\ClassMethod) {
                 $method_analyzer = new MethodAnalyzer($stmt, $this);
 
                 $method_analyzer->analyze(new \Psalm\Context($this->getFQCLN()));
+
+                $actual_method_id = (string)$method_analyzer->getMethodId();
+
+                if ($stmt->name->name !== '__construct'
+                    && $config->reportIssueInFile('InvalidReturnType', $this->getFilePath())
+                ) {
+                    ClassAnalyzer::analyzeClassMethodReturnType(
+                        $stmt,
+                        $method_analyzer,
+                        $this,
+                        $codebase,
+                        $class_storage,
+                        $fq_interface_name,
+                        $actual_method_id,
+                        $actual_method_id
+                    );
+        }
             } elseif ($stmt instanceof PhpParser\Node\Stmt\Property) {
                 \Psalm\IssueBuffer::add(
                     new \Psalm\Issue\ParseError(
diff --git a/tests/InterfaceTest.php b/tests/InterfaceTest.php
index 6573c200a..4a7cb1a53 100644
--- a/tests/InterfaceTest.php
+++ b/tests/InterfaceTest.php
@@ -112,7 +112,7 @@ class InterfaceTest extends TestCase
 
                     interface B extends A
                     {
-                        public function barBar();
+                        public function barBar() : void;
                     }
 
                     /** @return void */
@@ -176,7 +176,7 @@ class InterfaceTest extends TestCase
                 '<?php
                     interface A { }
                     interface B {
-                        function foo();
+                        function foo() : void;
                     }
                     function bar(A $a): void {
                         if ($a instanceof B) {
@@ -187,7 +187,7 @@ class InterfaceTest extends TestCase
             'abstractInterfaceImplements' => [
                 '<?php
                     interface I {
-                        public function fnc();
+                        public function fnc() : void;
                     }
 
                     abstract class A implements I {}',
@@ -195,7 +195,7 @@ class InterfaceTest extends TestCase
             'abstractInterfaceImplementsButCallMethod' => [
                 '<?php
                     interface I {
-                        public function foo();
+                        public function foo() : void;
                     }
 
                     abstract class A implements I {
@@ -546,7 +546,7 @@ class InterfaceTest extends TestCase
             'allowStaticCallOnInterfaceMethod' => [
                 '<?php
                     interface IFoo {
-                        public static function doFoo();
+                        public static function doFoo() : void;
                     }
 
                     function bar(IFoo $i) : void {
@@ -564,7 +564,7 @@ class InterfaceTest extends TestCase
             'intersectMixedTypes' => [
                 '<?php
                     interface IFoo {
-                        function foo();
+                        function foo() : string;
                     }
 
                     interface IBar {
@@ -676,7 +676,7 @@ class InterfaceTest extends TestCase
             'unimplementedInterfaceMethod' => [
                 '<?php
                     interface A {
-                        public function fooFoo();
+                        public function fooFoo() : void;
                     }
 
                     class B implements A { }',
@@ -766,7 +766,7 @@ class InterfaceTest extends TestCase
             'abstractInterfaceImplementsButCallUndefinedMethod' => [
                 '<?php
                     interface I {
-                        public function foo();
+                        public function foo() : void;
                     }
 
                     abstract class A implements I {
@@ -779,7 +779,7 @@ class InterfaceTest extends TestCase
             'abstractInterfaceImplementsWithSubclass' => [
                 '<?php
                     interface I {
-                        public function fnc();
+                        public function fnc() : void;
                     }
 
                     abstract class A implements I {}
@@ -865,6 +865,20 @@ class InterfaceTest extends TestCase
                     Foo::doFoo();',
                 'error_message' => 'UndefinedClass',
             ],
+            'missingReturnType' => [
+                '<?php
+                    interface foo {
+                        public function withoutAnyReturnType();
+                    }',
+                'error_message' => 'MissingReturnType'
+            ],
+            'missingParamType' => [
+                '<?php
+                    interface foo {
+                        public function withoutAnyReturnType($s) : void;
+                    }',
+                'error_message' => 'MissingParamType'
+            ],
         ];
     }
 }
