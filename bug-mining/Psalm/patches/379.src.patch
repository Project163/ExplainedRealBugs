diff --git a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
index dd7ef7ebe..a2d04f642 100644
--- a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
@@ -1330,7 +1330,10 @@ class ExpressionAnalyzer
             return $return_type;
         }
 
-        if ($return_type instanceof Type\Atomic\TArray || $return_type instanceof Type\Atomic\TGenericObject) {
+        if ($return_type instanceof Type\Atomic\TArray
+            || $return_type instanceof Type\Atomic\TGenericObject
+            || $return_type instanceof Type\Atomic\TIterable
+        ) {
             foreach ($return_type->type_params as &$type_param) {
                 $type_param = self::fleshOutType(
                     $codebase,
diff --git a/tests/ReturnTypeTest.php b/tests/ReturnTypeTest.php
index f8005d387..c1f73f8d9 100644
--- a/tests/ReturnTypeTest.php
+++ b/tests/ReturnTypeTest.php
@@ -661,6 +661,28 @@ class ReturnTypeTest extends TestCase
                         }
                     }',
             ],
+            'allowIterableReturnTypeCrossover' => [
+                '<?php
+                    class Foo {
+                        public const TYPE1 = "a";
+                        public const TYPE2 = "b";
+
+                        public const AVAILABLE_TYPES = [
+                            self::TYPE1,
+                            self::TYPE2,
+                        ];
+
+                        /**
+                         * @return iterable<array-key, array{foo: value-of<self::AVAILABLE_TYPES>}>
+                         */
+                        public function foo() {
+                            return [
+                                ["foo" => self::TYPE1],
+                                ["foo" => self::TYPE2]
+                            ];
+                        }
+                    }',
+            ],
         ];
     }
 
