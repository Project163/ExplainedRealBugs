diff --git a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
index f5b7cc0cb..fab90c826 100644
--- a/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/ClassAnalyzer.php
@@ -754,7 +754,10 @@ class ClassAnalyzer extends ClassLikeAnalyzer
                                 $pt_name = array_keys($parent_storage->template_types)[$pt_offset];
                                 if (isset($template_standins->lower_bounds[$pt_name][$parent_class])) {
                                     $lower_bounds[$pt_name][$parent_class] =
-                                        $template_standins->lower_bounds[$pt_name][$parent_class]->type;
+                                        TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                                            $template_standins->lower_bounds[$pt_name][$parent_class],
+                                            $codebase
+                                        );
                                 }
                             }
                         }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentAnalyzer.php
index 35bc8d48a..3e13920cf 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentAnalyzer.php
@@ -367,17 +367,19 @@ class ArgumentAnalyzer
                             [$template_type->param_name]
                             [$template_type->defining_class]
                     )) {
-                        $template_result->lower_bounds[$template_type->param_name][$template_type->defining_class]
-                            = new TemplateBound(
+                        $template_result->lower_bounds[$template_type->param_name][$template_type->defining_class] = [
+                            new TemplateBound(
                                 clone $template_result->upper_bounds
                                     [$template_type->param_name]
                                     [$template_type->defining_class]->type
-                            );
+                            )
+                        ];
                     } else {
-                        $template_result->lower_bounds[$template_type->param_name][$template_type->defining_class]
-                            = new TemplateBound(
+                        $template_result->lower_bounds[$template_type->param_name][$template_type->defining_class] = [
+                            new TemplateBound(
                                 clone $template_type->as
-                            );
+                            )
+                        ];
                     }
                 }
             }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentsAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentsAnalyzer.php
index 4173c4963..3c0deea79 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentsAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/ArgumentsAnalyzer.php
@@ -40,6 +40,7 @@ use function array_reverse;
 use function count;
 use function in_array;
 use function is_string;
+use function reset;
 use function strpos;
 use function strtolower;
 
@@ -327,10 +328,13 @@ class ArgumentsAnalyzer
 
         $replace_template_result = new \Psalm\Internal\Type\TemplateResult(
             array_map(
-                function ($template_map) {
+                function ($template_map) use ($codebase) {
                     return array_map(
-                        function ($bound) {
-                            return $bound->type;
+                        function ($lower_bounds) use ($codebase) {
+                            return \Psalm\Internal\Type\TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                                $lower_bounds,
+                                $codebase
+                            );
                         },
                         $template_map
                     );
@@ -563,8 +567,10 @@ class ArgumentsAnalyzer
 
         if ($class_template_result) {
             foreach ($class_template_result->lower_bounds as $template_name => $type_map) {
-                foreach ($type_map as $class => $bound) {
-                    $class_generic_params[$template_name][$class] = clone $bound->type;
+                foreach ($type_map as $class => $lower_bounds) {
+                    if (count($lower_bounds) === 1) {
+                        $class_generic_params[$template_name][$class] = clone reset($lower_bounds)->type;
+                    }
                 }
             }
         }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
index 45db337a2..84e80d0ba 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
@@ -283,8 +283,8 @@ class FunctionCallAnalyzer extends CallAnalyzer
                 $statements_analyzer->node_data->setIfTrueAssertions(
                     $stmt,
                     array_map(
-                        function (Assertion $assertion) use ($inferred_lower_bounds) : Assertion {
-                            return $assertion->getUntemplatedCopy($inferred_lower_bounds ?: [], null);
+                        function (Assertion $assertion) use ($inferred_lower_bounds, $codebase) : Assertion {
+                            return $assertion->getUntemplatedCopy($inferred_lower_bounds ?: [], null, $codebase);
                         },
                         $function_call_info->function_storage->if_true_assertions
                     )
@@ -295,8 +295,8 @@ class FunctionCallAnalyzer extends CallAnalyzer
                 $statements_analyzer->node_data->setIfFalseAssertions(
                     $stmt,
                     array_map(
-                        function (Assertion $assertion) use ($inferred_lower_bounds) : Assertion {
-                            return $assertion->getUntemplatedCopy($inferred_lower_bounds ?: [], null);
+                        function (Assertion $assertion) use ($inferred_lower_bounds, $codebase) : Assertion {
+                            return $assertion->getUntemplatedCopy($inferred_lower_bounds ?: [], null, $codebase);
                         },
                         $function_call_info->function_storage->if_false_assertions
                     )
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallReturnTypeFetcher.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallReturnTypeFetcher.php
index 60d147f09..0bc9bf479 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallReturnTypeFetcher.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallReturnTypeFetcher.php
@@ -67,21 +67,27 @@ class FunctionCallReturnTypeFetcher
                         if (!isset($template_result->lower_bounds[$template_name])) {
                             if ($template_name === 'TFunctionArgCount') {
                                 $template_result->lower_bounds[$template_name] = [
-                                    'fn-' . $function_id => new TemplateBound(
-                                        Type::getInt(false, count($stmt->args))
-                                    )
+                                    'fn-' . $function_id => [
+                                        new TemplateBound(
+                                            Type::getInt(false, count($stmt->args))
+                                        )
+                                    ]
                                 ];
                             } elseif ($template_name === 'TPhpMajorVersion') {
                                 $template_result->lower_bounds[$template_name] = [
-                                    'fn-' . $function_id => new TemplateBound(
-                                        Type::getInt(false, $codebase->php_major_version)
-                                    )
+                                    'fn-' . $function_id => [
+                                            new TemplateBound(
+                                                Type::getInt(false, $codebase->php_major_version)
+                                            )
+                                    ]
                                 ];
                             } else {
                                 $template_result->lower_bounds[$template_name] = [
-                                    'fn-' . $function_id => new TemplateBound(
-                                        Type::getEmpty()
-                                    )
+                                    'fn-' . $function_id => [
+                                        new TemplateBound(
+                                            Type::getEmpty()
+                                        )
+                                    ]
                                 ];
                             }
                         }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/ExistingAtomicMethodCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/ExistingAtomicMethodCallAnalyzer.php
index 1e761f57d..e92174acb 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/ExistingAtomicMethodCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/ExistingAtomicMethodCallAnalyzer.php
@@ -322,11 +322,13 @@ class ExistingAtomicMethodCallAnalyzer extends CallAnalyzer
                     array_map(
                         function (Assertion $assertion) use (
                             $class_template_params,
-                            $lhs_var_id
+                            $lhs_var_id,
+                            $codebase
                         ) : Assertion {
                             return $assertion->getUntemplatedCopy(
                                 $class_template_params ?: [],
-                                $lhs_var_id
+                                $lhs_var_id,
+                                $codebase
                             );
                         },
                         $method_storage->if_true_assertions
@@ -340,11 +342,13 @@ class ExistingAtomicMethodCallAnalyzer extends CallAnalyzer
                     array_map(
                         function (Assertion $assertion) use (
                             $class_template_params,
-                            $lhs_var_id
+                            $lhs_var_id,
+                            $codebase
                         ) : Assertion {
                             return $assertion->getUntemplatedCopy(
                                 $class_template_params ?: [],
-                                $lhs_var_id
+                                $lhs_var_id,
+                                $codebase
                             );
                         },
                         $method_storage->if_false_assertions
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
index e36526fc8..9f1ea16eb 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
@@ -534,19 +534,25 @@ class MethodCallReturnTypeFetcher
                 ) {
                     if ($template_type->param_name === 'TFunctionArgCount') {
                         $template_result->lower_bounds[$template_type->param_name] = [
-                            'fn-' . strtolower((string) $method_id) => new TemplateBound(
-                                Type::getInt(false, $arg_count)
-                            )
+                            'fn-' . strtolower((string) $method_id) => [
+                                new TemplateBound(
+                                    Type::getInt(false, $arg_count)
+                                )
+                            ]
                         ];
                     } elseif ($template_type->param_name === 'TPhpMajorVersion') {
                         $template_result->lower_bounds[$template_type->param_name] = [
-                            'fn-' . strtolower((string) $method_id) => new TemplateBound(
-                                Type::getInt(false, $codebase->php_major_version)
-                            )
+                            'fn-' . strtolower((string) $method_id) => [
+                                new TemplateBound(
+                                    Type::getInt(false, $codebase->php_major_version)
+                                )
+                            ]
                         ];
                     } else {
                         $template_result->lower_bounds[$template_type->param_name] = [
-                            ($template_type->defining_class) => new TemplateBound(Type::getEmpty())
+                            ($template_type->defining_class) => [
+                                new TemplateBound(Type::getEmpty())
+                            ]
                         ];
                     }
                 }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/NewAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/NewAnalyzer.php
index a81199152..747cf0edc 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/NewAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/NewAnalyzer.php
@@ -11,6 +11,7 @@ use Psalm\Internal\Analyzer\Statements\ExpressionAnalyzer;
 use Psalm\Internal\Analyzer\StatementsAnalyzer;
 use Psalm\Internal\Codebase\TaintFlowGraph;
 use Psalm\Internal\DataFlow\DataFlowNode;
+use Psalm\Internal\Type\TemplateStandinTypeReplacer;
 use Psalm\Issue\AbstractInstantiation;
 use Psalm\Issue\DeprecatedClass;
 use Psalm\Issue\ImpureMethodCall;
@@ -439,8 +440,8 @@ class NewAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\CallAna
                     $statements_analyzer->node_data->setIfTrueAssertions(
                         $stmt,
                         \array_map(
-                            function ($assertion) use ($generic_params) {
-                                return $assertion->getUntemplatedCopy($generic_params, null);
+                            function ($assertion) use ($generic_params, $codebase) {
+                                return $assertion->getUntemplatedCopy($generic_params, null, $codebase);
                             },
                             $method_storage->if_true_assertions
                         )
@@ -451,8 +452,8 @@ class NewAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\CallAna
                     $statements_analyzer->node_data->setIfFalseAssertions(
                         $stmt,
                         \array_map(
-                            function ($assertion) use ($generic_params) {
-                                return $assertion->getUntemplatedCopy($generic_params, null);
+                            function ($assertion) use ($generic_params, $codebase) {
+                                return $assertion->getUntemplatedCopy($generic_params, null, $codebase);
                             },
                             $method_storage->if_false_assertions
                         )
@@ -465,18 +466,23 @@ class NewAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\CallAna
             if ($storage->template_types) {
                 foreach ($storage->template_types as $template_name => $base_type) {
                     if (isset($template_result->lower_bounds[$template_name][$fq_class_name])) {
-                        $generic_param_type
-                            = $template_result->lower_bounds[$template_name][$fq_class_name]->type;
+                        $generic_param_type = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                            $template_result->lower_bounds[$template_name][$fq_class_name],
+                            $codebase
+                        );
                     } elseif ($storage->template_extended_params && $template_result->lower_bounds) {
                         $generic_param_type = self::getGenericParamForOffset(
                             $fq_class_name,
                             $template_name,
                             $storage->template_extended_params,
                             array_map(
-                                function ($type_map) {
+                                function ($type_map) use ($codebase) {
                                     return array_map(
-                                        function ($bound) {
-                                            return $bound->type;
+                                        function ($bounds) use ($codebase) {
+                                            return TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                                                $bounds,
+                                                $codebase
+                                            );
                                         },
                                         $type_map
                                     );
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/ExistingAtomicStaticCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/ExistingAtomicStaticCallAnalyzer.php
index 1f50817d3..a23e6467b 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/ExistingAtomicStaticCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/ExistingAtomicStaticCallAnalyzer.php
@@ -318,8 +318,8 @@ class ExistingAtomicStaticCallAnalyzer
                 $statements_analyzer->node_data->setIfTrueAssertions(
                     $stmt,
                     array_map(
-                        function (Assertion $assertion) use ($generic_params) : Assertion {
-                            return $assertion->getUntemplatedCopy($generic_params, null);
+                        function (Assertion $assertion) use ($generic_params, $codebase) : Assertion {
+                            return $assertion->getUntemplatedCopy($generic_params, null, $codebase);
                         },
                         $method_storage->if_true_assertions
                     )
@@ -330,8 +330,8 @@ class ExistingAtomicStaticCallAnalyzer
                 $statements_analyzer->node_data->setIfFalseAssertions(
                     $stmt,
                     array_map(
-                        function (Assertion $assertion) use ($generic_params) : Assertion {
-                            return $assertion->getUntemplatedCopy($generic_params, null);
+                        function (Assertion $assertion) use ($generic_params, $codebase) : Assertion {
+                            return $assertion->getUntemplatedCopy($generic_params, null, $codebase);
                         },
                         $method_storage->if_false_assertions
                     )
@@ -488,19 +488,25 @@ class ExistingAtomicStaticCallAnalyzer
                     )) {
                         if ($template_type->param_name === 'TFunctionArgCount') {
                             $template_result->lower_bounds[$template_type->param_name] = [
-                                'fn-' . strtolower((string)$method_id) => new TemplateBound(
-                                    Type::getInt(false, count($stmt->args))
-                                )
+                                'fn-' . strtolower((string)$method_id) => [
+                                    new TemplateBound(
+                                        Type::getInt(false, count($stmt->args))
+                                    )
+                                ]
                             ];
                         } elseif ($template_type->param_name === 'TPhpMajorVersion') {
                             $template_result->lower_bounds[$template_type->param_name] = [
-                                'fn-' . strtolower((string)$method_id) => new TemplateBound(
-                                    Type::getInt(false, $codebase->php_major_version)
-                                )
+                                'fn-' . strtolower((string)$method_id) => [
+                                    new TemplateBound(
+                                        Type::getInt(false, $codebase->php_major_version)
+                                    )
+                                ]
                             ];
                         } else {
                             $template_result->lower_bounds[$template_type->param_name] = [
-                                ($template_type->defining_class) => new TemplateBound(Type::getEmpty())
+                                ($template_type->defining_class) => [
+                                    new TemplateBound(Type::getEmpty())
+                                ]
                             ];
                         }
                     }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index 174d8d148..e29913f98 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -11,6 +11,7 @@ use Psalm\Internal\Analyzer\StatementsAnalyzer;
 use Psalm\Internal\Type\Comparator\UnionTypeComparator;
 use Psalm\Internal\Type\TemplateBound;
 use Psalm\Internal\Type\TemplateResult;
+use Psalm\Internal\Type\TemplateStandinTypeReplacer;
 use Psalm\Issue\ArgumentTypeCoercion;
 use Psalm\Issue\InvalidArgument;
 use Psalm\Issue\InvalidScalarArgument;
@@ -24,8 +25,10 @@ use Psalm\Storage\ClassLikeStorage;
 use Psalm\Type;
 use Psalm\Type\Atomic\TNamedObject;
 
+use function array_filter;
 use function array_map;
 use function array_merge;
+use function array_unique;
 use function count;
 use function in_array;
 use function is_int;
@@ -624,7 +627,7 @@ class CallAnalyzer
      * @param  \Psalm\Storage\Assertion[] $assertions
      * @param  string $thisName
      * @param  list<PhpParser\Node\Arg> $args
-     * @param  array<string, array<string, TemplateBound>> $inferred_lower_bounds,
+     * @param  array<string, array<string, non-empty-list<TemplateBound>>> $inferred_lower_bounds,
      *
      */
     public static function applyAssertionsToContext(
@@ -670,6 +673,8 @@ class CallAnalyzer
                 $assertion_var_id = $assertion->var_id;
             }
 
+            $codebase = $statements_analyzer->getCodebase();
+
             if ($assertion_var_id) {
                 $rule = $assertion->rule[0][0];
 
@@ -688,12 +693,17 @@ class CallAnalyzer
                 }
 
                 if (isset($inferred_lower_bounds[$rule])) {
-                    foreach ($inferred_lower_bounds[$rule] as $template_map) {
-                        if ($template_map->type->hasMixed()) {
+                    foreach ($inferred_lower_bounds[$rule] as $lower_bounds) {
+                        $lower_bound_type = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                            $lower_bounds,
+                            $codebase
+                        );
+
+                        if ($lower_bound_type->hasMixed()) {
                             continue 2;
                         }
 
-                        $replacement_atomic_types = $template_map->type->getAtomicTypes();
+                        $replacement_atomic_types = $lower_bound_type->getAtomicTypes();
 
                         if (count($replacement_atomic_types) > 1) {
                             continue 2;
@@ -748,7 +758,7 @@ class CallAnalyzer
                         $conditional,
                         $context->self,
                         $statements_analyzer,
-                        $statements_analyzer->getCodebase()
+                        $codebase
                     );
                 } else {
                     $assert_clauses = FormulaGenerator::getFormula(
@@ -778,7 +788,7 @@ class CallAnalyzer
                         $arg_value,
                         $context->self,
                         $statements_analyzer,
-                        $statements_analyzer->getCodebase()
+                        $codebase
                     )
                 );
 
@@ -800,12 +810,17 @@ class CallAnalyzer
             $asserted_keys[$var_id] = true;
         }
 
+        $codebase = $statements_analyzer->getCodebase();
+
         if ($type_assertions) {
             $template_type_map = array_map(
-                function ($type_map) {
+                function ($type_map) use ($codebase) {
                     return array_map(
-                        function ($bound) {
-                            return $bound->type;
+                        function ($bounds) use ($codebase) {
+                            return TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                                $bounds,
+                                $codebase
+                            );
                         },
                         $type_map
                     );
@@ -843,8 +858,6 @@ class CallAnalyzer
                 if (isset($op_vars_in_scope[$var_id])) {
                     $first_appearance = $statements_analyzer->getFirstAppearance($var_id);
 
-                    $codebase = $statements_analyzer->getCodebase();
-
                     if ($first_appearance
                         && isset($context->vars_in_scope[$var_id])
                         && $context->vars_in_scope[$var_id]->hasMixed()
@@ -896,6 +909,32 @@ class CallAnalyzer
         }
     }
 
+    /**
+     * This method looks for problems with a generated TemplateResult.
+     *
+     * The TemplateResult object contains upper bounds and lower bounds for each template param.
+     *
+     * Those upper bounds represent a series of constraints like
+     *
+     * Lower bound:
+     * T >: X (the type param T matches X, or is a supertype of X)
+     * Upper bound:
+     * T <: Y (the type param T matches Y, or is a subtype of Y)
+     * Equality (currently represented as an upper bound with a special flag)
+     * T = Z  (the template T must match Z)
+     *
+     * This method attempts to reconcile those constraints.
+     *
+     * Valid constraints:
+     *
+     * T <: int|float, T >: int --- implies T is an int
+     * T = int --- implies T is an int
+     *
+     * Invalid constraints:
+     *
+     * T <: int|string, T >: string|float --- implies T <: int and T >: float, which is impossible
+     * T = int, T = string --- implies T is a string _and_ and int, which is impossible
+     */
     public static function checkTemplateResult(
         StatementsAnalyzer $statements_analyzer,
         TemplateResult $template_result,
@@ -906,7 +945,11 @@ class CallAnalyzer
             foreach ($template_result->upper_bounds as $template_name => $defining_map) {
                 foreach ($defining_map as $defining_id => $upper_bound) {
                     if (isset($template_result->lower_bounds[$template_name][$defining_id])) {
-                        $lower_bound_type = $template_result->lower_bounds[$template_name][$defining_id]->type;
+                        $lower_bound_type = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                            $template_result->lower_bounds[$template_name][$defining_id],
+                            $statements_analyzer->getCodebase()
+                        );
+
                         $upper_bound_type = $upper_bound->type;
 
                         $union_comparison_result = new \Psalm\Internal\Type\Comparator\TypeComparisonResult();
@@ -977,9 +1020,72 @@ class CallAnalyzer
                             }
                         }
                     } else {
-                        $template_result->lower_bounds[$template_name][$defining_id] = new TemplateBound(
-                            clone $upper_bound->type
-                        );
+                        $template_result->lower_bounds[$template_name][$defining_id] = [
+                            new TemplateBound(
+                                clone $upper_bound->type
+                            )
+                        ];
+                    }
+                }
+            }
+        }
+
+        // Attempt to identify invalid lower bounds
+        foreach ($template_result->lower_bounds as $template_name => $lower_bounds) {
+            foreach ($lower_bounds as $lower_bounds) {
+                if (count($lower_bounds) > 1) {
+                    $bounds_with_equality = array_filter(
+                        $lower_bounds,
+                        function ($lower_bound) {
+                            return !!$lower_bound->equality_bound_classlike;
+                        }
+                    );
+
+                    if (!$bounds_with_equality) {
+                        continue;
+                    }
+
+                    $equality_classlikes = [];
+                    $equality_types = [];
+
+                    foreach ($bounds_with_equality as $bound_with_equality) {
+                        $equality_classlikes[] = $bound_with_equality->equality_bound_classlike;
+                        $equality_types[] = $bound_with_equality->type->getId();
+                    }
+
+                    $equality_classlikes = array_unique($equality_classlikes);
+                    $equality_types = array_unique($equality_types);
+
+                    if (count($equality_classlikes) > 1
+                        || count($equality_types) > 1
+                    ) {
+                        if (IssueBuffer::accepts(
+                            new InvalidArgument(
+                                'Incompatible types found for ' . $template_name,
+                                $code_location,
+                                $function_id
+                            ),
+                            $statements_analyzer->getSuppressedIssues()
+                        )) {
+                            // continue
+                        }
+                    } else {
+                        foreach ($lower_bounds as $lower_bound) {
+                            if ($lower_bound->equality_bound_classlike === null) {
+                                if (!in_array($lower_bound->type->getId(), $equality_types, true)) {
+                                    if (IssueBuffer::accepts(
+                                        new InvalidArgument(
+                                            'Incompatible types found for ' . $template_name,
+                                            $code_location,
+                                            $function_id
+                                        ),
+                                        $statements_analyzer->getSuppressedIssues()
+                                    )) {
+                                        // continue
+                                    }
+                                }
+                            }
+                        }
                     }
                 }
             }
diff --git a/src/Psalm/Internal/Type/TemplateBound.php b/src/Psalm/Internal/Type/TemplateBound.php
index 4c9b6202f..da8da461a 100644
--- a/src/Psalm/Internal/Type/TemplateBound.php
+++ b/src/Psalm/Internal/Type/TemplateBound.php
@@ -18,7 +18,7 @@ class TemplateBound
      *
      * The shallowest-appearance of the template takes prominence when inferring the type of T.
      *
-     * @var ?int
+     * @var int
      */
     public $appearance_depth;
 
@@ -31,10 +31,22 @@ class TemplateBound
      */
     public $arg_offset;
 
-    public function __construct(Union $type, ?int $appearance_depth = null, ?int $arg_offset = null)
-    {
+    /**
+     * When non-null, indicates an equality template bound (vs a lower or upper bound)
+     *
+     * @var ?string
+     */
+    public $equality_bound_classlike;
+
+    public function __construct(
+        Union $type,
+        int $appearance_depth = 0,
+        ?int $arg_offset = null,
+        ?string $equality_bound_classlike = null
+    ) {
         $this->type = $type;
         $this->appearance_depth = $appearance_depth;
         $this->arg_offset = $arg_offset;
+        $this->equality_bound_classlike = $equality_bound_classlike;
     }
 }
diff --git a/src/Psalm/Internal/Type/TemplateInferredTypeReplacer.php b/src/Psalm/Internal/Type/TemplateInferredTypeReplacer.php
index 69f258eba..b39608064 100644
--- a/src/Psalm/Internal/Type/TemplateInferredTypeReplacer.php
+++ b/src/Psalm/Internal/Type/TemplateInferredTypeReplacer.php
@@ -43,7 +43,9 @@ class TemplateInferredTypeReplacer
                 $traversed_type = \Psalm\Internal\Type\TemplateStandinTypeReplacer::getRootTemplateType(
                     $inferred_lower_bounds,
                     $atomic_type->param_name,
-                    $atomic_type->defining_class
+                    $atomic_type->defining_class,
+                    [],
+                    $codebase
                 );
 
                 if ($traversed_type) {
@@ -100,7 +102,10 @@ class TemplateInferredTypeReplacer
                                             $template_name = (string) $param_map[$key];
 
                                             $template_type
-                                                = clone $inferred_lower_bounds[$template_name][$template_class]->type;
+                                                = clone TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                                                    $inferred_lower_bounds[$template_name][$template_class],
+                                                    $codebase
+                                                );
                                         }
                                     }
                                 }
@@ -123,7 +128,10 @@ class TemplateInferredTypeReplacer
                 }
             } elseif ($atomic_type instanceof Atomic\TTemplateParamClass) {
                 $template_type = isset($inferred_lower_bounds[$atomic_type->param_name][$atomic_type->defining_class])
-                    ? clone $inferred_lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]->type
+                    ? clone TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                        $inferred_lower_bounds[$atomic_type->param_name][$atomic_type->defining_class],
+                        $codebase
+                    )
                     : null;
 
                 $class_template_type = null;
@@ -165,11 +173,16 @@ class TemplateInferredTypeReplacer
                     && !empty($inferred_lower_bounds[$atomic_type->offset_param_name])
                 ) {
                     $array_template_type
-                        = $inferred_lower_bounds[$atomic_type->array_param_name][$atomic_type->defining_class]->type;
+                        = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                            $inferred_lower_bounds[$atomic_type->array_param_name][$atomic_type->defining_class],
+                            $codebase
+                        );
+
                     $offset_template_type
-                        = array_values(
-                            $inferred_lower_bounds[$atomic_type->offset_param_name]
-                        )[0]->type;
+                        = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                            array_values($inferred_lower_bounds[$atomic_type->offset_param_name])[0],
+                            $codebase
+                        );
 
                     if ($array_template_type->isSingle()
                         && $offset_template_type->isSingle()
@@ -204,7 +217,10 @@ class TemplateInferredTypeReplacer
                 && $codebase
             ) {
                 $template_type = isset($inferred_lower_bounds[$atomic_type->param_name][$atomic_type->defining_class])
-                    ? clone $inferred_lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]->type
+                    ? clone TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                        $inferred_lower_bounds[$atomic_type->param_name][$atomic_type->defining_class],
+                        $codebase
+                    )
                     : null;
 
                 $if_template_type = null;
@@ -275,9 +291,11 @@ class TemplateInferredTypeReplacer
                         $refined_template_result = clone $template_result;
 
                         $refined_template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]
-                            = new \Psalm\Internal\Type\TemplateBound(
+                            = [
+                            new \Psalm\Internal\Type\TemplateBound(
                                 $if_candidate_type
-                            );
+                            )
+                        ];
 
                         self::replace(
                             $if_template_type,
@@ -303,9 +321,11 @@ class TemplateInferredTypeReplacer
                         $refined_template_result = clone $template_result;
 
                         $refined_template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]
-                            = new \Psalm\Internal\Type\TemplateBound(
+                            = [
+                            new \Psalm\Internal\Type\TemplateBound(
                                 $else_candidate_type
-                            );
+                            )
+                        ];
 
                         self::replace(
                             $else_template_type,
diff --git a/src/Psalm/Internal/Type/TemplateResult.php b/src/Psalm/Internal/Type/TemplateResult.php
index 1134e9d6a..c213eb59c 100644
--- a/src/Psalm/Internal/Type/TemplateResult.php
+++ b/src/Psalm/Internal/Type/TemplateResult.php
@@ -6,6 +6,21 @@ use Psalm\Type\Union;
 
 use function array_map;
 
+/**
+ * This class captures the result of running Psalm's argument analysis with
+ * regard to generic parameters.
+ *
+ * It captures upper and lower bounds for parameters. Mostly we just care about
+ * lower bounds — those are captured when calling a function that expects a
+ * non-callable templated argument.
+ *
+ * Upper bounds are found in callable parameter types. Given a parameter type
+ * `callable(T1): void` and an argument typed as `callable(int): void`, `int` will
+ * be added as an _upper_ bound for the template param `T1`. This only applies to
+ * parameters — given a parameter type `callable(): T2` and an argument typed as
+ * `callable(): string`, `string` will be added as a _lower_ bound for the template
+ * param `T2`.
+ */
 class TemplateResult
 {
     /**
@@ -14,7 +29,7 @@ class TemplateResult
     public $template_types;
 
     /**
-     * @var array<string, array<string, TemplateBound>>
+     * @var array<string, array<string, non-empty-list<TemplateBound>>>
      */
     public $lower_bounds;
 
@@ -47,7 +62,7 @@ class TemplateResult
             function ($type_map) {
                 return array_map(
                     function ($type) {
-                        return new TemplateBound($type);
+                        return [new TemplateBound($type)];
                     },
                     $type_map
                 );
diff --git a/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php b/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php
index 65f7e4f66..477685d39 100644
--- a/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php
+++ b/src/Psalm/Internal/Type/TemplateStandinTypeReplacer.php
@@ -12,8 +12,10 @@ use Psalm\Type\Union;
 use function array_merge;
 use function array_values;
 use function count;
+use function reset;
 use function strpos;
 use function substr;
+use function usort;
 
 class TemplateStandinTypeReplacer
 {
@@ -36,7 +38,8 @@ class TemplateStandinTypeReplacer
         ?string $calling_function = null,
         bool $replace = true,
         bool $add_lower_bound = false,
-        int $depth = 0
+        ?string $bound_equality_classlike = null,
+        int $depth = 1
     ) : Union {
         $atomic_types = [];
 
@@ -76,6 +79,7 @@ class TemplateStandinTypeReplacer
                     $calling_function,
                     $replace,
                     $add_lower_bound,
+                    $bound_equality_classlike,
                     $depth,
                     count($original_atomic_types) === 1,
                     $had_template
@@ -130,6 +134,7 @@ class TemplateStandinTypeReplacer
         ?string $calling_function,
         bool $replace,
         bool $add_lower_bound,
+        ?string $bound_equality_classlike,
         int $depth,
         bool $was_single,
         bool &$had_template
@@ -153,6 +158,7 @@ class TemplateStandinTypeReplacer
                 $statements_analyzer,
                 $replace,
                 $add_lower_bound,
+                $bound_equality_classlike,
                 $depth,
                 $had_template
             );
@@ -173,6 +179,7 @@ class TemplateStandinTypeReplacer
                     $statements_analyzer,
                     $replace,
                     $add_lower_bound,
+                    $bound_equality_classlike,
                     $depth,
                     $was_single,
                     $had_template
@@ -192,9 +199,10 @@ class TemplateStandinTypeReplacer
                     $array_template_type
                         = $template_result->template_types[$atomic_type->array_param_name][$atomic_type->defining_class];
                     $offset_template_type
-                        = array_values(
-                            $template_result->lower_bounds[$atomic_type->offset_param_name]
-                        )[0]->type;
+                        = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                            array_values($template_result->lower_bounds[$atomic_type->offset_param_name])[0],
+                            $codebase
+                        );
 
                     if ($array_template_type->isSingle()
                         && $offset_template_type->isSingle()
@@ -496,6 +504,7 @@ class TemplateStandinTypeReplacer
         ?StatementsAnalyzer $statements_analyzer,
         bool $replace,
         bool $add_lower_bound,
+        ?string $bound_equality_classlike,
         int $depth,
         bool &$had_template
     ) : array {
@@ -534,6 +543,7 @@ class TemplateStandinTypeReplacer
                     $calling_function,
                     $replace,
                     $add_lower_bound,
+                    $bound_equality_classlike,
                     $depth + 1
                 );
 
@@ -583,6 +593,7 @@ class TemplateStandinTypeReplacer
                         $calling_function,
                         $replace,
                         $add_lower_bound,
+                        $bound_equality_classlike,
                         $depth + 1
                     );
                 }
@@ -593,6 +604,8 @@ class TemplateStandinTypeReplacer
                     // @codingStandardsIgnoreStart
                     if ($replacement_atomic_type instanceof Atomic\TTemplateKeyOf
                         && isset($template_result->template_types[$replacement_atomic_type->param_name][$replacement_atomic_type->defining_class])
+                        && count($template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class])
+                            === 1
                     ) {
                         $keyed_template = $template_result->template_types[$replacement_atomic_type->param_name][$replacement_atomic_type->defining_class];
 
@@ -618,8 +631,9 @@ class TemplateStandinTypeReplacer
                                 $atomic_types[] = clone $key_type_atomic;
                             }
 
-                            $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]->type
-                                = clone $key_type;
+                            $existing_lower_bound = reset($template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]);
+
+                            $existing_lower_bound->type = clone $key_type;
                         }
                     }
 
@@ -665,6 +679,7 @@ class TemplateStandinTypeReplacer
                 $calling_function,
                 $replace,
                 $add_lower_bound,
+                $bound_equality_classlike,
                 $depth + 1
             );
 
@@ -704,33 +719,47 @@ class TemplateStandinTypeReplacer
                 if (isset(
                     $template_result->lower_bounds[$param_name_key][$atomic_type->defining_class]
                 )) {
-                    $existing_generic_param = $template_result->lower_bounds
+                    $existing_lower_bounds = $template_result->lower_bounds
                         [$param_name_key]
                         [$atomic_type->defining_class];
 
-                    $existing_depth = $existing_generic_param->appearance_depth ?? -1;
-                    $existing_arg_offset = $existing_generic_param->arg_offset ?? $input_arg_offset;
+                    $has_matching_lower_bound = false;
 
-                    if ($existing_depth > $depth && $input_arg_offset === $existing_arg_offset) {
-                        return $atomic_types ?: [$atomic_type];
+                    foreach ($existing_lower_bounds as $existing_lower_bound) {
+                        $existing_depth = $existing_lower_bound->appearance_depth;
+                        $existing_arg_offset = $existing_lower_bound->arg_offset ?? $input_arg_offset;
+
+                        if ($existing_depth === $depth
+                            && $input_arg_offset === $existing_arg_offset
+                            && $existing_lower_bound->type->getId() === $generic_param->getId()
+                            && $existing_lower_bound->equality_bound_classlike === $bound_equality_classlike
+                        ) {
+                            $has_matching_lower_bound = true;
+                            break;
+                        }
                     }
 
-                    if ($existing_depth === $depth || $input_arg_offset !== $existing_arg_offset) {
-                        $generic_param = \Psalm\Type::combineUnionTypes(
-                            $template_result->lower_bounds
-                                [$param_name_key]
-                                [$atomic_type->defining_class]->type,
-                            $generic_param,
-                            $codebase
-                        );
+                    if (!$has_matching_lower_bound) {
+                        $template_result->lower_bounds
+                            [$param_name_key]
+                            [$atomic_type->defining_class]
+                            [] = new TemplateBound(
+                                $generic_param,
+                                $depth,
+                                $input_arg_offset,
+                                $bound_equality_classlike
+                            );
                     }
+                } else {
+                    $template_result->lower_bounds[$param_name_key][$atomic_type->defining_class] = [
+                        new TemplateBound(
+                            $generic_param,
+                            $depth,
+                            $input_arg_offset,
+                            $bound_equality_classlike
+                        )
+                    ];
                 }
-
-                $template_result->lower_bounds[$param_name_key][$atomic_type->defining_class] = new TemplateBound(
-                    $generic_param,
-                    $depth,
-                    $input_arg_offset
-                );
             }
 
             foreach ($atomic_types as &$atomic_type) {
@@ -829,6 +858,7 @@ class TemplateStandinTypeReplacer
         ?StatementsAnalyzer $statements_analyzer,
         bool $replace,
         bool $add_lower_bound,
+        ?string $bound_equality_classlike,
         int $depth,
         bool $was_single,
         bool &$had_template
@@ -895,6 +925,7 @@ class TemplateStandinTypeReplacer
                     $calling_function,
                     $replace,
                     $add_lower_bound,
+                    $bound_equality_classlike,
                     $depth + 1
                 );
 
@@ -911,19 +942,26 @@ class TemplateStandinTypeReplacer
 
             if ($generic_param) {
                 if (isset($template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class])) {
-                    $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class] = new TemplateBound(
-                        \Psalm\Type::combineUnionTypes(
-                            $generic_param,
-                            $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class]->type
-                        ),
-                        $depth
-                    );
+                    $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class] = [
+                        new TemplateBound(
+                            \Psalm\Type::combineUnionTypes(
+                                $generic_param,
+                                self::getMostSpecificTypeFromBounds(
+                                    $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class],
+                                    $codebase
+                                )
+                            ),
+                            $depth
+                        )
+                    ];
                 } else {
-                    $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class] = new TemplateBound(
-                        $generic_param,
-                        $depth,
-                        $input_arg_offset
-                    );
+                    $template_result->lower_bounds[$atomic_type->param_name][$atomic_type->defining_class] = [
+                        new TemplateBound(
+                            $generic_param,
+                            $depth,
+                            $input_arg_offset
+                        )
+                    ];
                 }
             }
         } else {
@@ -953,27 +991,31 @@ class TemplateStandinTypeReplacer
     }
 
     /**
-     * @param  array<string, array<string, TemplateBound>>  $template_types
+     * @param  array<string, array<string, non-empty-list<TemplateBound>>>  $template_types
      */
     public static function getRootTemplateType(
         array $template_types,
         string $param_name,
         string $defining_class,
-        array $visited_classes = []
+        array $visited_classes,
+        ?Codebase $codebase
     ) : ?Union {
         if (isset($visited_classes[$defining_class])) {
             return null;
         }
 
         if (isset($template_types[$param_name][$defining_class])) {
-            $mapped_type = $template_types[$param_name][$defining_class]->type;
+            $mapped_type = self::getMostSpecificTypeFromBounds(
+                $template_types[$param_name][$defining_class],
+                $codebase
+            );
 
             $mapped_type_atomic_types = array_values($mapped_type->getAtomicTypes());
 
             if (count($mapped_type_atomic_types) > 1
                 || !$mapped_type_atomic_types[0] instanceof Atomic\TTemplateParam
             ) {
-                return $template_types[$param_name][$defining_class]->type;
+                return $mapped_type;
             }
 
             $first_template = $mapped_type_atomic_types[0];
@@ -982,13 +1024,75 @@ class TemplateStandinTypeReplacer
                 $template_types,
                 $first_template->param_name,
                 $first_template->defining_class,
-                $visited_classes + [$defining_class => true]
-            ) ?? $template_types[$param_name][$defining_class]->type;
+                $visited_classes + [$defining_class => true],
+                $codebase
+            ) ?? $mapped_type;
         }
 
         return null;
     }
 
+    /**
+     * This takes a list of lower bounds and returns the most general type.
+     *
+     * If given a single bound that's just the type of that bound.
+     *
+     * If instead given a collection of lower bounds it normally returns a union of those
+     * bound types.
+     *
+     * @param  non-empty-list<TemplateBound>  $lower_bounds
+     */
+    public static function getMostSpecificTypeFromBounds(array $lower_bounds, ?Codebase $codebase): Union
+    {
+        if (count($lower_bounds) === 1) {
+            return reset($lower_bounds)->type;
+        }
+
+        usort(
+            $lower_bounds,
+            function (TemplateBound $bound_a, TemplateBound $bound_b) {
+                return $bound_b->appearance_depth <=> $bound_a->appearance_depth;
+            }
+        );
+
+        $current_depth = null;
+        $current_type = null;
+        $had_invariant = false;
+        $last_arg_offset = -1;
+
+        foreach ($lower_bounds as $template_bound) {
+            if ($current_depth === null) {
+                $current_depth = $template_bound->appearance_depth;
+            } elseif ($current_depth !== $template_bound->appearance_depth && $current_type) {
+                if (!$current_type->isEmpty()
+                    && ($had_invariant || $last_arg_offset === $template_bound->arg_offset)
+                ) {
+                    // escape switches when matching on invariant generic params
+                    // and when matching
+                    break;
+                }
+
+                $current_depth = $template_bound->appearance_depth;
+            }
+
+            $had_invariant = $had_invariant ?: $template_bound->equality_bound_classlike !== null;
+
+            if ($current_type === null) {
+                $current_type = $template_bound->type;
+            } else {
+                $current_type = \Psalm\Type::combineUnionTypes(
+                    $current_type,
+                    $template_bound->type,
+                    $codebase
+                );
+            }
+
+            $last_arg_offset = $template_bound->arg_offset;
+        }
+
+        return $current_type ?: \Psalm\Type::getMixed();
+    }
+
     /**
      * @param Atomic\TGenericObject|Atomic\TIterable $input_type_part
      * @param Atomic\TGenericObject|Atomic\TIterable $container_type_part
diff --git a/src/Psalm/Storage/Assertion.php b/src/Psalm/Storage/Assertion.php
index 6540fe104..a6b3f5cbf 100644
--- a/src/Psalm/Storage/Assertion.php
+++ b/src/Psalm/Storage/Assertion.php
@@ -1,6 +1,9 @@
 <?php
 namespace Psalm\Storage;
 
+use Psalm\Internal\Type\TemplateBound;
+use Psalm\Internal\Type\TemplateStandinTypeReplacer;
+
 use function array_map;
 use function implode;
 
@@ -28,10 +31,13 @@ class Assertion
     }
 
     /**
-     * @param array<string, array<string, \Psalm\Internal\Type\TemplateBound>> $inferred_lower_bounds
+     * @param array<string, array<string, non-empty-list<TemplateBound>>> $inferred_lower_bounds
      */
-    public function getUntemplatedCopy(array $inferred_lower_bounds, ?string $this_var_id) : self
-    {
+    public function getUntemplatedCopy(
+        array $inferred_lower_bounds,
+        ?string $this_var_id,
+        ?\Psalm\Codebase $codebase
+    ) : self {
         return new Assertion(
             \is_string($this->var_id) && $this_var_id
                 ? \str_replace('$this->', $this_var_id . '->', $this->var_id)
@@ -42,7 +48,7 @@ class Assertion
                  *
                  * @return array{0: string}
                  */
-                function (array $rules) use ($inferred_lower_bounds) : array {
+                function (array $rules) use ($inferred_lower_bounds, $codebase) : array {
                     $first_rule = $rules[0];
 
                     if ($inferred_lower_bounds) {
@@ -52,10 +58,15 @@ class Assertion
 
                         foreach ($rule_tokens as &$rule_token) {
                             if (isset($inferred_lower_bounds[$rule_token[0]])) {
-                                foreach ($inferred_lower_bounds[$rule_token[0]] as $bound) {
+                                foreach ($inferred_lower_bounds[$rule_token[0]] as $lower_bounds) {
                                     $substitute = true;
 
-                                    $first_type = \array_values($bound->type->getAtomicTypes())[0];
+                                    $bound_type = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                                        $lower_bounds,
+                                        $codebase
+                                    );
+
+                                    $first_type = \array_values($bound_type->getAtomicTypes())[0];
 
                                     if ($first_type instanceof \Psalm\Type\Atomic\TTemplateParam) {
                                         $rule_token[0] = $first_type->param_name;
diff --git a/src/Psalm/Type/Atomic/CallableTrait.php b/src/Psalm/Type/Atomic/CallableTrait.php
index 63c23159a..cfb406351 100644
--- a/src/Psalm/Type/Atomic/CallableTrait.php
+++ b/src/Psalm/Type/Atomic/CallableTrait.php
@@ -218,6 +218,7 @@ trait CallableTrait
                     $calling_function,
                     $replace,
                     !$add_lower_bound,
+                    null,
                     $depth
                 );
             }
diff --git a/src/Psalm/Type/Atomic/GenericTrait.php b/src/Psalm/Type/Atomic/GenericTrait.php
index e5f8902b7..26334a072 100644
--- a/src/Psalm/Type/Atomic/GenericTrait.php
+++ b/src/Psalm/Type/Atomic/GenericTrait.php
@@ -191,6 +191,8 @@ trait GenericTrait
 
         $input_object_type_params = [];
 
+        $container_type_params_covariant = [];
+
         if ($input_type instanceof Atomic\TGenericObject
             && ($this instanceof Atomic\TGenericObject || $this instanceof Atomic\TIterable)
             && $codebase
@@ -198,7 +200,8 @@ trait GenericTrait
             $input_object_type_params = TemplateStandinTypeReplacer::getMappedGenericTypeParams(
                 $codebase,
                 $input_type,
-                $this
+                $this,
+                $container_type_params_covariant
             );
         }
 
@@ -239,6 +242,10 @@ trait GenericTrait
                 $calling_function,
                 $replace,
                 $add_lower_bound,
+                !($container_type_params_covariant[$offset] ?? true)
+                    && $this instanceof Atomic\TGenericObject
+                    ? $this->value
+                    : null,
                 $depth + 1
             );
         }
diff --git a/src/Psalm/Type/Atomic/HasIntersectionTrait.php b/src/Psalm/Type/Atomic/HasIntersectionTrait.php
index 6f8963e03..a74137c17 100644
--- a/src/Psalm/Type/Atomic/HasIntersectionTrait.php
+++ b/src/Psalm/Type/Atomic/HasIntersectionTrait.php
@@ -3,6 +3,7 @@ namespace Psalm\Type\Atomic;
 
 use Psalm\Codebase;
 use Psalm\Internal\Type\TemplateResult;
+use Psalm\Internal\Type\TemplateStandinTypeReplacer;
 use Psalm\Type;
 use Psalm\Type\Atomic;
 
@@ -85,14 +86,16 @@ trait HasIntersectionTrait
             if ($extra_type instanceof TTemplateParam
                 && isset($template_result->lower_bounds[$extra_type->param_name][$extra_type->defining_class])
             ) {
-                $template_type = clone $template_result->lower_bounds
-                    [$extra_type->param_name][$extra_type->defining_class]->type;
+                $template_type = TemplateStandinTypeReplacer::getMostSpecificTypeFromBounds(
+                    $template_result->lower_bounds[$extra_type->param_name][$extra_type->defining_class],
+                    $codebase
+                );
 
                 foreach ($template_type->getAtomicTypes() as $template_type_part) {
                     if ($template_type_part instanceof TNamedObject) {
-                        $new_types[$template_type_part->getKey()] = $template_type_part;
+                        $new_types[$template_type_part->getKey()] = clone $template_type_part;
                     } elseif ($template_type_part instanceof TTemplateParam) {
-                        $new_types[$template_type_part->getKey()] = $template_type_part;
+                        $new_types[$template_type_part->getKey()] = clone $template_type_part;
                     }
                 }
             } else {
diff --git a/src/Psalm/Type/Atomic/TClassString.php b/src/Psalm/Type/Atomic/TClassString.php
index 6779eaeba..06365f115 100644
--- a/src/Psalm/Type/Atomic/TClassString.php
+++ b/src/Psalm/Type/Atomic/TClassString.php
@@ -147,6 +147,7 @@ class TClassString extends TString
             $calling_function,
             $replace,
             $add_lower_bound,
+            null,
             $depth
         );
 
diff --git a/src/Psalm/Type/Atomic/TClassStringMap.php b/src/Psalm/Type/Atomic/TClassStringMap.php
index 820290276..acef988c7 100644
--- a/src/Psalm/Type/Atomic/TClassStringMap.php
+++ b/src/Psalm/Type/Atomic/TClassStringMap.php
@@ -183,6 +183,7 @@ class TClassStringMap extends \Psalm\Type\Atomic
                 $calling_function,
                 $replace,
                 $add_lower_bound,
+                null,
                 $depth + 1
             );
 
diff --git a/src/Psalm/Type/Atomic/TKeyedArray.php b/src/Psalm/Type/Atomic/TKeyedArray.php
index 1b64ef692..a63add012 100644
--- a/src/Psalm/Type/Atomic/TKeyedArray.php
+++ b/src/Psalm/Type/Atomic/TKeyedArray.php
@@ -353,6 +353,7 @@ class TKeyedArray extends \Psalm\Type\Atomic
                 $calling_function,
                 $replace,
                 $add_lower_bound,
+                null,
                 $depth
             );
         }
diff --git a/src/Psalm/Type/Atomic/TList.php b/src/Psalm/Type/Atomic/TList.php
index c40e80f34..50a319aa8 100644
--- a/src/Psalm/Type/Atomic/TList.php
+++ b/src/Psalm/Type/Atomic/TList.php
@@ -156,6 +156,7 @@ class TList extends \Psalm\Type\Atomic
                 $calling_function,
                 $replace,
                 $add_lower_bound,
+                null,
                 $depth + 1
             );
 
diff --git a/src/Psalm/Type/Atomic/TObjectWithProperties.php b/src/Psalm/Type/Atomic/TObjectWithProperties.php
index 0f73fbc1e..90d555059 100644
--- a/src/Psalm/Type/Atomic/TObjectWithProperties.php
+++ b/src/Psalm/Type/Atomic/TObjectWithProperties.php
@@ -251,6 +251,7 @@ class TObjectWithProperties extends TObject
                 $calling_function,
                 $replace,
                 $add_lower_bound,
+                null,
                 $depth
             );
         }
diff --git a/tests/Template/ClassTemplateTest.php b/tests/Template/ClassTemplateTest.php
index b6595e72e..3860ea04c 100644
--- a/tests/Template/ClassTemplateTest.php
+++ b/tests/Template/ClassTemplateTest.php
@@ -2872,7 +2872,7 @@ class ClassTemplateTest extends TestCase
             ],
             'multipleMatchingObjectsInUnion' => [
                 '<?php
-                    /** @template T */
+                    /** @template-covariant T */
                     interface Container {
                         /** @return T */
                         public function get();
@@ -3459,6 +3459,101 @@ class ClassTemplateTest extends TestCase
 
                     if ($me->data["name"] === "David") {}'
             ],
+            'allowCovariantBoundsMismatchSameContainers' => [
+                '<?php
+                    /**
+                     * @param Collection<Dog> $c
+                     * @param Collection<Cat> $d
+                     */
+                    function bar(Collection $c, Collection $d): Dog|Cat {
+                        return foo($c, $d);
+                    }
+
+                    /** @template-covariant T of object */
+                    interface Collection {
+                        /** @return T */
+                        public function get(): object;
+                    }
+
+                    class Cat {}
+                    class Dog {}
+
+                    /**
+                     * @template T of object
+                     * @param Collection<T> $c
+                     * @param Collection<T> $d
+                     * @return T
+                     */
+                    function foo(Collection $c, Collection $d): object {
+                        return rand(0, 1) ? $c->get() : $d->get();
+                    }',
+            ],
+            'allowCovariantBoundsMismatchDifferentContainers' => [
+                '<?php
+                    /**
+                     * @param Collection1<Dog> $c
+                     * @param Collection2<Cat> $d
+                     */
+                    function bar(Collection1 $c, Collection2 $d): Dog|Cat {
+                        return foo($c, $d);
+                    }
+
+                    /** @template-covariant T of object */
+                    interface Collection1 {
+                        /** @return T */
+                        public function get(): object;
+                    }
+
+                    /** @template-covariant T of object */
+                    interface Collection2 {
+                        /** @return T */
+                        public function get(): object;
+                    }
+
+                    class Cat {}
+                    class Dog {}
+
+                    /**
+                     * @template T of object
+                     * @param Collection1<T> $c
+                     * @param Collection2<T> $d
+                     * @return T
+                     */
+                    function foo(Collection1 $c, Collection2 $d): object {
+                        return rand(0, 1) ? $c->get() : $d->get();
+                    }',
+            ],
+            'allowCovariantBoundsMismatchContainerAndObject' => [
+                '<?php
+                    /**
+                     * @param Collection<Cat> $d
+                     */
+                    function bar(Dog $c, Collection $d): Dog|Cat {
+                        $animal = foo($c, $d);
+                        if ($animal instanceof Dog) {}
+                        if ($animal instanceof Cat) {}
+                        return $animal;
+                    }
+
+                    /** @template-covariant T of object */
+                    interface Collection {
+                        /** @return T */
+                        public function get(): object;
+                    }
+
+                    class Cat {}
+                    class Dog {}
+
+                    /**
+                     * @template T of object
+                     * @param T $c
+                     * @param Collection<T> $d
+                     * @return T
+                     */
+                    function foo(object $c, Collection $d): object {
+                        return rand(0, 1) ? $c : $d->get();
+                    }',
+            ],
         ];
     }
 
@@ -4121,6 +4216,104 @@ class ClassTemplateTest extends TestCase
                     $a->setCallback(function() { return "b";});',
                 'error_message' => 'InvalidScalarArgument',
             ],
+            'preventBoundsMismatchDifferentContainers' => [
+                '<?php
+                    /**
+                     * @param Collection1<Dog> $c
+                     * @param Collection2<Cat> $d
+                     */
+                    function bar(Collection1 $c, Collection2 $d): void {
+                        foo($c, $d);
+                    }
+
+                    /** @template T of object */
+                    interface Collection1 {
+                        /** @param T $item */
+                        public function add(object $item): void;
+                    }
+
+                    /** @template T of object */
+                    interface Collection2 {
+                        /** @param T $item */
+                        public function add(object $item): void;
+
+                        /** @return T */
+                        public function get(): object;
+                    }
+
+                    class Cat {}
+                    class Dog {}
+
+                    /**
+                     * @template T of object
+                     * @param Collection1<T> $c
+                     * @param Collection2<T> $d
+                     */
+                    function foo(Collection1 $c, Collection2 $d): void {
+                        $c->add($d->get());
+                    }',
+                'error_message' => 'InvalidArgument',
+            ],
+            'preventBoundsMismatchSameContainers' => [
+                '<?php
+                    /**
+                     * @param Collection<Dog> $c
+                     * @param Collection<Cat> $d
+                     */
+                    function bar(Collection $c, Collection $d): void {
+                        foo($c, $d);
+                    }
+
+                    /** @template T of object */
+                    interface Collection {
+                        /** @param T $item */
+                        public function add(object $item): void;
+
+                        /** @return T */
+                        public function get(): object;
+                    }
+
+                    class Cat {}
+                    class Dog {}
+
+                    /**
+                     * @template T of object
+                     * @param Collection<T> $c
+                     * @param Collection<T> $d
+                     */
+                    function foo(Collection $c, Collection $d): void {
+                        $c->add($d->get());
+                    }',
+                'error_message' => 'InvalidArgument',
+            ],
+            'preventBoundsMismatchDifferentBoundLevels' => [
+                '<?php
+                    /**
+                     * @param Collection<Dog> $c
+                     */
+                    function bar(Collection $c): void {
+                        foo($c, new Cat());
+                    }
+
+                    /** @template T of object */
+                    interface Collection {
+                        /** @param T $item */
+                        public function add(object $item): void;
+                    }
+
+                    class Cat {}
+                    class Dog {}
+
+                    /**
+                     * @template T of object
+                     * @param Collection<T> $c
+                     * @param T $d
+                     */
+                    function foo(Collection $c, object $d): void {
+                        $c->add($d);
+                    }',
+                'error_message' => 'InvalidArgument',
+            ],
         ];
     }
 }
