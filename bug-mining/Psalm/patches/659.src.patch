diff --git a/src/Psalm/Internal/Analyzer/TypeAnalyzer.php b/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
index 7d4b4b919..b151ba6d3 100644
--- a/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
@@ -92,7 +92,11 @@ class TypeAnalyzer
             return true;
         }
 
-        foreach ($input_type->getAtomicTypes() as $input_type_part) {
+        $container_has_template = $container_type->hasTemplateOrStatic();
+
+        $input_atomic_types = array_reverse($input_type->getAtomicTypes());
+
+        while ($input_type_part = array_pop($input_atomic_types)) {
             if ($input_type_part instanceof TNull && $ignore_null) {
                 continue;
             }
@@ -101,6 +105,14 @@ class TypeAnalyzer
                 continue;
             }
 
+            if ($input_type_part instanceof TTemplateParam
+                && !$container_has_template
+                && !$input_type_part->extra_types
+            ) {
+                $input_atomic_types = array_merge($input_type_part->as->getAtomicTypes(), $input_atomic_types);
+                continue;
+            }
+
             $type_match_found = false;
             $scalar_type_match_found = false;
             $all_to_string_cast = true;
diff --git a/src/Psalm/Type/Atomic.php b/src/Psalm/Type/Atomic.php
index b1c3dd390..e8f8d82f8 100644
--- a/src/Psalm/Type/Atomic.php
+++ b/src/Psalm/Type/Atomic.php
@@ -552,6 +552,10 @@ abstract class Atomic implements TypeNode
                 }
             }
         }
+
+        if ($this instanceof TTemplateParam) {
+            $this->as = clone $this->as;
+        }
     }
 
     /**
diff --git a/src/Psalm/Type/Atomic/TConditional.php b/src/Psalm/Type/Atomic/TConditional.php
index b73defe67..ee6be172e 100644
--- a/src/Psalm/Type/Atomic/TConditional.php
+++ b/src/Psalm/Type/Atomic/TConditional.php
@@ -78,6 +78,7 @@ class TConditional extends \Psalm\Type\Atomic
         $this->conditional_type = clone $this->conditional_type;
         $this->if_type = clone $this->if_type;
         $this->else_type = clone $this->else_type;
+        $this->as_type = clone $this->as_type;
     }
 
     /**
diff --git a/src/Psalm/Type/Union.php b/src/Psalm/Type/Union.php
index 74a286a82..250808a32 100644
--- a/src/Psalm/Type/Union.php
+++ b/src/Psalm/Type/Union.php
@@ -954,7 +954,41 @@ class Union implements TypeNode
         return (bool) array_filter(
             $this->types,
             function (Atomic $type) : bool {
-                return $type instanceof Type\Atomic\TTemplateParam;
+                return $type instanceof Type\Atomic\TTemplateParam
+                    || ($type instanceof Type\Atomic\TNamedObject
+                        && $type->extra_types
+                        && array_filter(
+                            $type->extra_types,
+                            function ($t) {
+                                return $t instanceof Type\Atomic\TTemplateParam;
+                            }
+                        )
+                    );
+            }
+        );
+    }
+
+    /**
+     * @return bool
+     */
+    public function hasTemplateOrStatic()
+    {
+        return (bool) array_filter(
+            $this->types,
+            function (Atomic $type) : bool {
+                return $type instanceof Type\Atomic\TTemplateParam
+                    || ($type instanceof Type\Atomic\TNamedObject
+                        && ($type->was_static
+                            || ($type->extra_types
+                                && array_filter(
+                                    $type->extra_types,
+                                    function ($t) {
+                                        return $t instanceof Type\Atomic\TTemplateParam;
+                                    }
+                                )
+                            )
+                        )
+                    );
             }
         );
     }
@@ -1334,7 +1368,14 @@ class Union implements TypeNode
 
                 $class_template_type = null;
 
+                $atomic_type = clone $atomic_type;
+
                 if ($template_type) {
+                    $atomic_type->as_type->replaceTemplateTypesWithArgTypes(
+                        $template_result,
+                        $codebase
+                    );
+
                     if (TypeAnalyzer::isContainedBy(
                         $codebase,
                         $template_type,
diff --git a/tests/Template/ConditionalReturnTypeTest.php b/tests/Template/ConditionalReturnTypeTest.php
index 55af022f1..7ec594c7f 100644
--- a/tests/Template/ConditionalReturnTypeTest.php
+++ b/tests/Template/ConditionalReturnTypeTest.php
@@ -365,6 +365,63 @@ class ConditionalReturnTypeTest extends TestCase
                         return [new stdClass(), new stdClass()];
                     }'
             ],
+            'promiseConditional' => [
+                '<?php
+                    /**
+                     * @template T
+                     */
+                    class Promise {
+                        /** @var T */
+                        private $t;
+
+                        /** @param T $t */
+                        public function __construct($t) {
+                            $this->t = $t;
+                        }
+                    }
+
+                    /**
+                     * @template T
+                     * @extends Promise<T>
+                     */
+                    class Success extends Promise {}
+
+                    /**
+                     * @template TReturn
+                     * @template TPromise
+                     *
+                     * @template T as Promise<TPromise>|TReturn
+                     *
+                     * @param callable(): T $callback
+                     *
+                     * @return Promise
+                     * @psalm-return (T is Promise ? Promise<TPromise> : Promise<TReturn>)
+                     */
+                    function call(callable $callback): Promise {
+                        $result = $callback();
+
+                        if ($result instanceof Promise) {
+                            return $result;
+                        }
+
+                        /** @psalm-suppress InvalidReturnStatement */
+                        return new Promise($result);
+                    }
+
+                    $ret_int_promise = function (): Promise {
+                        return new Success(9);
+                    };
+
+                    $c1 = call($ret_int_promise);
+
+                    $c2 = call(function (): int {
+                        return 42;
+                    });',
+                [
+                    '$c1' => 'Promise<int>',
+                    '$c2' => 'Promise<int>',
+                ]
+            ],
         ];
     }
 }
