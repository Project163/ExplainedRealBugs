diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
index 32c18d830..7da1da261 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
@@ -1064,6 +1064,8 @@ class MethodCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
             $declaring_method_id ?: $method_id
         );
 
+        $can_memoize = false;
+
         if ($method_name_lc === '__tostring') {
             $return_type_candidate = Type::getString();
         } else {
@@ -1326,24 +1328,33 @@ class MethodCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
                             } elseif (($method_storage->mutation_free
                                     || ($method_storage->external_mutation_free
                                         && (isset($stmt->var->external_mutation_free) || isset($stmt->var->pure))))
-                                && $codebase->find_unused_variables
-                                && !$context->inside_conditional
                                 && !$context->inside_unset
                             ) {
-                                if (!$context->inside_assignment && !$context->inside_call) {
-                                    if (IssueBuffer::accepts(
-                                        new \Psalm\Issue\UnusedMethodCall(
-                                            'The call to ' . $cased_method_id . ' is not used',
-                                            new CodeLocation($statements_analyzer, $stmt->name),
-                                            $method_id
-                                        ),
-                                        $statements_analyzer->getSuppressedIssues()
-                                    )) {
-                                        // fall through
+                                if ($method_storage->mutation_free && !$method_storage->mutation_free_inferred) {
+                                    if ($context->inside_conditional) {
+                                        /** @psalm-suppress UndefinedPropertyAssignment */
+                                        $stmt->pure = true;
+                                    }
+
+                                    $can_memoize = true;
+                                }
+
+                                if ($codebase->find_unused_variables && !$context->inside_conditional) {
+                                    if (!$context->inside_assignment && !$context->inside_call) {
+                                        if (IssueBuffer::accepts(
+                                            new \Psalm\Issue\UnusedMethodCall(
+                                                'The call to ' . $cased_method_id . ' is not used',
+                                                new CodeLocation($statements_analyzer, $stmt->name),
+                                                $method_id
+                                            ),
+                                            $statements_analyzer->getSuppressedIssues()
+                                        )) {
+                                            // fall through
+                                        }
+                                    } else {
+                                        /** @psalm-suppress UndefinedPropertyAssignment */
+                                        $stmt->pure = true;
                                     }
-                                } else {
-                                    /** @psalm-suppress UndefinedPropertyAssignment */
-                                    $stmt->pure = true;
                                 }
                             }
 
@@ -1416,7 +1427,7 @@ class MethodCallAnalyzer extends \Psalm\Internal\Analyzer\Statements\Expression\
         }
 
         if (!$args && $lhs_var_id) {
-            if ($config->memoize_method_calls) {
+            if ($config->memoize_method_calls || $can_memoize) {
                 $method_var_id = $lhs_var_id . '->' . $method_name_lc . '()';
 
                 if (isset($context->vars_in_scope[$method_var_id])) {
diff --git a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
index fde598291..c988be635 100644
--- a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
@@ -1099,7 +1099,7 @@ class ExpressionAnalyzer
         ) {
             $config = \Psalm\Config::getInstance();
 
-            if ($config->memoize_method_calls) {
+            if ($config->memoize_method_calls || isset($stmt->pure)) {
                 $lhs_var_name = self::getArrayVarId(
                     $stmt->var,
                     $this_class_name,
diff --git a/src/Psalm/Internal/Visitor/ReflectorVisitor.php b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
index e74dd3af2..861df0fc0 100644
--- a/src/Psalm/Internal/Visitor/ReflectorVisitor.php
+++ b/src/Psalm/Internal/Visitor/ReflectorVisitor.php
@@ -1851,6 +1851,8 @@ class ReflectorVisitor extends PhpParser\NodeVisitorAbstract implements PhpParse
         ) {
             if ($stmt instanceof PhpParser\Node\Stmt\ClassMethod
                 && $storage instanceof MethodStorage
+                && $class_storage
+                && !$class_storage->mutation_free
                 && count($stmt->stmts) === 1
                 && !count($stmt->params)
                 && $stmt->stmts[0] instanceof PhpParser\Node\Stmt\Return_
diff --git a/tests/ImmutableAnnotationTest.php b/tests/ImmutableAnnotationTest.php
index 00c7e7621..85cbed5a0 100644
--- a/tests/ImmutableAnnotationTest.php
+++ b/tests/ImmutableAnnotationTest.php
@@ -252,6 +252,32 @@ class ImmutableAnnotationTest extends TestCase
                         }
                     }',
             ],
+            'memoizeImmutableCalls' => [
+                '<?php
+                    function takesString(string $s) : void {}
+
+                    /**
+                     * @psalm-immutable
+                     */
+                    class DTO {
+                        /** @var string|null */
+                        private $error;
+
+                        public function __construct(?string $error) {
+                            $this->error = $error;
+                        }
+
+                        public function getError(): ?string {
+                            return $this->error;
+                        }
+                    }
+
+                    $dto = new DTO("BOOM!");
+
+                    if ($dto->getError()) {
+                        takesString($dto->getError());
+                    }'
+            ],
         ];
     }
 
