diff --git a/src/Psalm/Internal/Type/AssertionReconciler.php b/src/Psalm/Internal/Type/AssertionReconciler.php
index 6a25a4644..03631e0d2 100644
--- a/src/Psalm/Internal/Type/AssertionReconciler.php
+++ b/src/Psalm/Internal/Type/AssertionReconciler.php
@@ -173,9 +173,17 @@ class AssertionReconciler extends \Psalm\Type\Reconciler
             if (empty($existing_var_type->getAtomicTypes())) {
                 $failed_reconciliation = 2;
 
-                // @todo - I think there's a better way to handle this, but for the moment
-                // mixed will have to do.
-                return Type::getMixed();
+                if (IssueBuffer::accepts(
+                    new TypeDoesNotContainType(
+                        'Cannot resolve types for ' . $key . ' on null var',
+                        $code_location
+                    ),
+                    $suppressed_issues
+                )) {
+                    // fall through
+                }
+
+                return Type::getEmpty();
             }
 
             if ($existing_var_type->hasType('empty')) {
diff --git a/tests/TypeReconciliation/IssetTest.php b/tests/TypeReconciliation/IssetTest.php
index 85413b2d5..bb703deb7 100644
--- a/tests/TypeReconciliation/IssetTest.php
+++ b/tests/TypeReconciliation/IssetTest.php
@@ -778,6 +778,15 @@ class IssetTest extends \Psalm\Tests\TestCase
                     }',
                 'error_message' => 'UndefinedVariable'
             ],
+            'issetNullVar' => [
+                '<?php
+                    function four(?string $s) : void {
+                        if ($s === null) {
+                            if (isset($s)) {}
+                        }
+                    }',
+                'error_message' => 'TypeDoesNotContainType',
+            ],
         ];
     }
 }
