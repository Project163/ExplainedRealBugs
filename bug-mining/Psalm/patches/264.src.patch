diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index 6e82dde37..f3d471467 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -1906,7 +1906,10 @@ class CallAnalyzer
 
             $array_arg = isset($arg->value) ? $arg->value : null;
 
-            /** @var ObjectLike|TArray|null */
+            /**
+             * @psalm-suppress PossiblyUndefinedArrayOffset
+             * @var ObjectLike|TArray|null
+             */
             $array_arg_type = $array_arg
                     && isset($array_arg->inferredType)
                     && ($types = $array_arg->inferredType->getTypes())
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php
index 670f5b08b..902d65af6 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Fetch/ArrayFetchAnalyzer.php
@@ -464,10 +464,10 @@ class ArrayFetchAnalyzer
                         || ($type->type_params[1]->isMixed() && \is_string($key_value)))
                     && $key_value !== null
                 ) {
-                    $from_string_key = $type->type_params[0]->isString();
                     $from_mixed_array = $type->type_params[1]->isMixed();
                     $from_empty_array = $type->type_params[0]->isEmpty() && $type->type_params[1]->isEmpty();
 
+                    $previous_key_type = $type->type_params[0];
                     $previous_value_type = $type->type_params[1];
 
                     // ok, type becomes an ObjectLike
@@ -476,12 +476,9 @@ class ArrayFetchAnalyzer
 
                     $type->sealed = $from_empty_array;
 
-                    if ($from_mixed_array) {
+                    if (!$from_empty_array) {
                         $type->previous_value_type = clone $previous_value_type;
-
-                        if ($from_string_key) {
-                            $type->had_string_key = true;
-                        }
+                        $type->previous_key_type = clone $previous_key_type;
                     }
 
                     $array_type->addType($type);
diff --git a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
index 3f07da15b..1100566f4 100644
--- a/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/ExpressionAnalyzer.php
@@ -965,6 +965,12 @@ class ExpressionAnalyzer
                     $offset = '$' . $stmt->dim->name;
                 } elseif ($stmt->dim instanceof PhpParser\Node\Expr\ConstFetch) {
                     $offset = implode('\\', $stmt->dim->name->parts);
+                } elseif ($stmt->dim instanceof PhpParser\Node\Expr\PropertyFetch) {
+                    $object_id = self::getArrayVarId($stmt->dim->var, $this_class_name, $source);
+
+                    if ($object_id && $stmt->dim->name instanceof PhpParser\Node\Identifier) {
+                        $offset = $object_id . '->' . $stmt->dim->name;
+                    }
                 } elseif (isset($stmt->dim->inferredType)) {
                     if ($stmt->dim->inferredType->isSingleStringLiteral()) {
                         $offset = '\'' . $stmt->dim->inferredType->getSingleStringLiteral()->value . '\'';
diff --git a/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php b/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php
index 83b7461ae..4522b5bec 100644
--- a/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/StatementsAnalyzer.php
@@ -1240,7 +1240,9 @@ class StatementsAnalyzer extends SourceAnalyzer implements StatementsSource
                                     if ($atomic_root_type->previous_value_type) {
                                         $root_type->addType(
                                             new Type\Atomic\TArray([
-                                                new Type\Union([new Type\Atomic\TArrayKey]),
+                                                $atomic_root_type->previous_key_type
+                                                    ? clone $atomic_root_type->previous_key_type
+                                                    : new Type\Union([new Type\Atomic\TArrayKey]),
                                                 clone $atomic_root_type->previous_value_type,
                                             ])
                                         );
diff --git a/src/Psalm/Internal/Analyzer/TypeAnalyzer.php b/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
index 707f70c94..2f8ca3e06 100644
--- a/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/TypeAnalyzer.php
@@ -1971,7 +1971,9 @@ class TypeAnalyzer
 
         if ($container_type_part instanceof Type\Atomic\TNonEmptyArray
             && !$input_type_part instanceof Type\Atomic\TNonEmptyArray
-            && !($input_type_part instanceof ObjectLike && $input_type_part->sealed)
+            && !($input_type_part instanceof ObjectLike
+                && ($input_type_part->sealed || $input_type_part->previous_value_type)
+            )
         ) {
             if ($all_types_contain) {
                 $atomic_comparison_result->type_coerced = true;
diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php
index fcfa36647..853ec2431 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayPopReturnTypeProvider.php
@@ -54,7 +54,7 @@ class ArrayPopReturnTypeProvider implements \Psalm\Plugin\Hook\FunctionReturnTyp
         } else {
             $value_type = $first_arg_array->getGenericValueType();
 
-            if (!$first_arg_array->sealed) {
+            if (!$first_arg_array->sealed && !$first_arg_array->previous_value_type) {
                 $nullable = true;
             }
         }
diff --git a/src/Psalm/Internal/Type/TypeCombination.php b/src/Psalm/Internal/Type/TypeCombination.php
index aa6388a43..fb822e34e 100644
--- a/src/Psalm/Internal/Type/TypeCombination.php
+++ b/src/Psalm/Internal/Type/TypeCombination.php
@@ -83,7 +83,10 @@ class TypeCombination
     private $objectlike_sealed = true;
 
     /** @var ?Union */
-    private $objectlike_value_type = false;
+    private $objectlike_key_type = null;
+
+    /** @var ?Union */
+    private $objectlike_value_type = null;
 
     /** @var bool */
     private $has_mixed = false;
@@ -310,6 +313,10 @@ class TypeCombination
                             $objectlike->sealed = true;
                         }
 
+                        if ($combination->objectlike_key_type) {
+                            $objectlike->previous_key_type = $combination->objectlike_key_type;
+                        }
+
                         if ($combination->objectlike_value_type) {
                             $objectlike->previous_value_type = $combination->objectlike_value_type;
                         }
@@ -356,10 +363,28 @@ class TypeCombination
                     }
                 }
 
+                if ($combination->objectlike_value_type) {
+                    $objectlike_generic_type = Type::combineUnionTypes(
+                        $combination->objectlike_value_type,
+                        $objectlike_generic_type,
+                        $codebase,
+                        $overwrite_empty_array
+                    );
+                }
+
                 $objectlike_generic_type->possibly_undefined = false;
 
                 $objectlike_key_type = new Type\Union(array_values($objectlike_keys));
 
+                if ($combination->objectlike_key_type) {
+                    $objectlike_key_type = Type::combineUnionTypes(
+                        $combination->objectlike_key_type,
+                        $objectlike_key_type,
+                        $codebase,
+                        $overwrite_empty_array
+                    );
+                }
+
                 $generic_type_params[0] = Type::combineUnionTypes(
                     $generic_type_params[0],
                     $objectlike_key_type,
@@ -693,6 +718,19 @@ class TypeCombination
                 }
             }
 
+            if ($type->previous_key_type) {
+                if (!$combination->objectlike_key_type) {
+                    $combination->objectlike_key_type = $type->previous_key_type;
+                } else {
+                    $combination->objectlike_key_type = Type::combineUnionTypes(
+                        $type->previous_key_type,
+                        $combination->objectlike_key_type,
+                        $codebase,
+                        $overwrite_empty_array
+                    );
+                }
+            }
+
             foreach ($type->properties as $candidate_property_name => $candidate_property_type) {
                 $value_type = isset($combination->objectlike_entries[$candidate_property_name])
                     ? $combination->objectlike_entries[$candidate_property_name]
diff --git a/src/Psalm/Type/Atomic/ObjectLike.php b/src/Psalm/Type/Atomic/ObjectLike.php
index 2e9763b35..296d939dc 100644
--- a/src/Psalm/Type/Atomic/ObjectLike.php
+++ b/src/Psalm/Type/Atomic/ObjectLike.php
@@ -38,9 +38,9 @@ class ObjectLike extends \Psalm\Type\Atomic
     /**
      * Whether or not the previous array had an unknown key type
      *
-     * @var bool
+     * @var ?Union
      */
-    public $had_string_key = false;
+    public $previous_key_type = null;
 
     /**
      * Whether or not to allow new properties to be asserted on the given array
@@ -106,7 +106,11 @@ class ObjectLike extends \Psalm\Type\Atomic
                         $this->properties
                     )
                 ) .
-                '}';
+                '}'
+                . ($this->previous_value_type
+                    ? '<' . ($this->previous_key_type ? $this->previous_key_type->getId() . ', ' : '')
+                        . $this->previous_value_type->getId() . '>'
+                    : '');
     }
 
     /**
@@ -199,11 +203,13 @@ class ObjectLike extends \Psalm\Type\Atomic
             }
         }
 
-        if ($this->previous_value_type) {
-            $key_types[] = $this->had_string_key ? new TString : new TArrayKey;
+        $key_type = TypeCombination::combineTypes($key_types);
+
+        if ($this->previous_key_type) {
+            $key_type = Type::combineUnionTypes($this->previous_key_type, $key_type);
         }
 
-        return TypeCombination::combineTypes($key_types);
+        return $key_type;
     }
 
     /**
@@ -262,19 +268,23 @@ class ObjectLike extends \Psalm\Type\Atomic
             throw new \UnexpectedValueException('$value_type should not be null here');
         }
 
-        if ($this->previous_value_type) {
-            $key_types[] = $this->had_string_key ? new TString : new TArrayKey;
+        $key_type = TypeCombination::combineTypes($key_types);
 
+        if ($this->previous_value_type) {
             $value_type = Type::combineUnionTypes($this->previous_value_type, $value_type);
         }
 
+        if ($this->previous_key_type) {
+            $key_type = Type::combineUnionTypes($this->previous_key_type, $key_type);
+        }
+
         $value_type->possibly_undefined = false;
 
-        if ($this->sealed) {
-            $array_type = new TNonEmptyArray([TypeCombination::combineTypes($key_types), $value_type]);
+        if ($this->sealed || $this->previous_value_type) {
+            $array_type = new TNonEmptyArray([$key_type, $value_type]);
             $array_type->count = count($this->properties);
         } else {
-            $array_type = new TArray([TypeCombination::combineTypes($key_types), $value_type]);
+            $array_type = new TArray([$key_type, $value_type]);
         }
 
         return $array_type;
diff --git a/src/Psalm/Type/Reconciler.php b/src/Psalm/Type/Reconciler.php
index ad11ff92d..dd0b4a32b 100644
--- a/src/Psalm/Type/Reconciler.php
+++ b/src/Psalm/Type/Reconciler.php
@@ -169,7 +169,6 @@ class Reconciler
                     $codebase,
                     $key,
                     $existing_types,
-                    $new_type_parts,
                     $code_location
                 );
 
@@ -323,6 +322,7 @@ class Reconciler
 
         $string_char = null;
         $escape_char = false;
+        $brackets = 0;
 
         $parts = [''];
         $parts_offset = 0;
@@ -349,6 +349,13 @@ class Reconciler
                     $parts_offset++;
                     $parts[$parts_offset] = $char;
                     ++$parts_offset;
+
+                    if ($char === '[') {
+                        $brackets++;
+                    } else {
+                        $brackets--;
+                    }
+
                     continue 2;
 
                 case '\'':
@@ -362,7 +369,10 @@ class Reconciler
                     continue 2;
 
                 case '-':
-                    if ($i < $char_count - 1 && $chars[$i + 1] === '>') {
+                    if (!$brackets
+                        && $i < $char_count - 1
+                        && $chars[$i + 1] === '>'
+                    ) {
                         ++$i;
 
                         ++$parts_offset;
@@ -381,6 +391,8 @@ class Reconciler
             }
         }
 
+        $parts = \array_values($parts);
+
         self::$broken_paths[$path] = $parts;
 
         return $parts;
@@ -399,7 +411,6 @@ class Reconciler
         Codebase $codebase,
         string $key,
         array &$existing_keys,
-        array $new_type_parts,
         CodeLocation $code_location = null
     ) {
         $key_parts = self::breakUpPathIntoParts($key);
@@ -447,9 +458,7 @@ class Reconciler
                         if ($existing_key_type_part instanceof Type\Atomic\TArray) {
                             $new_base_type_candidate = clone $existing_key_type_part->type_params[1];
 
-                            if ($new_type_parts[0][0] === 'empty' || $new_type_parts[0][0] === '=empty') {
-                                $new_base_type_candidate->possibly_undefined = true;
-                            }
+                            $new_base_type_candidate->possibly_undefined = true;
                         } elseif (!$existing_key_type_part instanceof Type\Atomic\ObjectLike) {
                             return Type::getMixed();
                         } elseif ($array_key[0] === '$') {
@@ -460,6 +469,13 @@ class Reconciler
                             $key_parts_key = str_replace('\'', '', $array_key);
 
                             if (!isset($array_properties[$key_parts_key])) {
+                                if ($existing_key_type_part->previous_value_type) {
+                                    $new_base_type_candidate = clone $existing_key_type_part->previous_value_type;
+                                    $new_base_type_candidate->possibly_undefined = true;
+
+                                    return $new_base_type_candidate;
+                                }
+
                                 return null;
                             }
 
@@ -681,12 +697,12 @@ class Reconciler
             foreach ($existing_types[$base_key]->getTypes() as $base_atomic_type) {
                 if ($base_atomic_type instanceof Type\Atomic\ObjectLike
                     || ($base_atomic_type instanceof Type\Atomic\TArray
-                        && $base_atomic_type->type_params[0]->isArrayKey()
-                        && $base_atomic_type->type_params[1]->isMixed())
+                        && !$base_atomic_type->type_params[1]->isEmpty())
                 ) {
                     $new_base_type = clone $existing_types[$base_key];
 
                     if ($base_atomic_type instanceof Type\Atomic\TArray) {
+                        $previous_key_type = clone $base_atomic_type->type_params[0];
                         $previous_value_type = clone $base_atomic_type->type_params[1];
 
                         $base_atomic_type = new Type\Atomic\ObjectLike(
@@ -696,6 +712,9 @@ class Reconciler
                             null
                         );
 
+                        if (!$previous_key_type->isArrayKey()) {
+                            $base_atomic_type->previous_key_type = $previous_key_type;
+                        }
                         $base_atomic_type->previous_value_type = $previous_value_type;
                     } else {
                         $base_atomic_type = clone $base_atomic_type;
diff --git a/src/psalm.php b/src/psalm.php
index 8c2fd1a10..3db82990c 100644
--- a/src/psalm.php
+++ b/src/psalm.php
@@ -328,11 +328,6 @@ if (isset($options['set-baseline'])) {
     }
 }
 
-
-$output_format = isset($options['output-format']) && is_string($options['output-format'])
-    ? $options['output-format']
-    : \Psalm\Report::TYPE_CONSOLE;
-
 $paths_to_check = getPathsToCheck(isset($options['f']) ? $options['f'] : null);
 
 $plugins = [];
diff --git a/tests/AssertTest.php b/tests/AssertTest.php
index 4f610f433..26a7a92d5 100644
--- a/tests/AssertTest.php
+++ b/tests/AssertTest.php
@@ -163,6 +163,98 @@ class AssertTest extends TestCase
                         return count() > 0;
                     }',
             ],
+            'assertHasArrayAccess' => [
+                '<?php
+                    /**
+                     * @return array|ArrayAccess
+                     */
+                    function getBar(array $array) {
+                        if (isset($array[\'foo\'][\'bar\'])) {
+                            return $array[\'foo\'];
+                        }
+
+                        return [];
+                    }',
+            ],
+            'assertHasArrayAccessWithType' => [
+                '<?php
+                    /**
+                     * @param array<string, array<string, string>> $array
+                     * @return array<string, string>
+                     */
+                    function getBar(array $array) : array {
+                        if (isset($array[\'foo\'][\'bar\'])) {
+                            return $array[\'foo\'];
+                        }
+
+                        return [];
+                    }',
+            ],
+            'assertHasArrayAccessOnSimpleXMLElement' => [
+                '<?php
+                    function getBar(SimpleXMLElement $e, string $s) : void {
+                        if (isset($e[$s])) {
+                            echo (string) $e[$s];
+                        }
+
+                        if (isset($e[\'foo\'])) {
+                            echo (string) $e[\'foo\'];
+                        }
+
+                        if (isset($e->bar)) {}
+                    }',
+            ],
+            'assertArrayOffsetToTraversable' => [
+                '<?php
+                    function render(array $data): ?Traversable {
+                        if ($data["o"] instanceof Traversable) {
+                            return $data["o"];
+                        }
+
+                        return null;
+                    }'
+            ],
+            'assertOnArrayShouldNotChangeType' => [
+                '<?php
+                    /** @return array|string|false */
+                    function foo(string $a, string $b) {
+                        $options = getopt($a, [$b]);
+
+                        if (isset($options["config"])) {
+                            $options["c"] = $options["config"];
+                        }
+
+                        if (isset($options["root"])) {
+                            return $options["root"];
+                        }
+
+                        return false;
+                    }'
+            ],
+            'assertOnArrayInTernary' => [
+                '<?php
+                    function foo(string $a, string $b) : void {
+                        $o = getopt($a, [$b]);
+
+                        $a = isset($o["a"]) && is_string($o["a"]) ? $o["a"] : "foo";
+                        $a = isset($o["a"]) && is_string($o["a"]) ? $o["a"] : "foo";
+                        echo $a;
+                    }'
+            ],
+            'nonEmptyArrayAfterIsset' => [
+                '<?php
+                    /**
+                     * @param array<string, int> $arr
+                     * @return non-empty-array<string, int>
+                     */
+                    function foo(array $arr) : array {
+                        if (isset($arr["a"])) {
+                            return $arr;
+                        }
+
+                        return ["b" => 1];
+                    }'
+            ],
         ];
     }
 }
diff --git a/tests/IssetTest.php b/tests/IssetTest.php
index 38bb6b9b9..0ee3df804 100644
--- a/tests/IssetTest.php
+++ b/tests/IssetTest.php
@@ -353,7 +353,17 @@ class IssetTest extends TestCase
                         echo $_GET["b"];
                     }',
             ],
-            'nestedArrayAccessInLoopAfterIsset' => [
+            'regularArrayAccessInLoopAfterIsset' => [
+                '<?php
+                    $arr = [];
+                    while (rand(0, 1)) {
+                        if (!isset($arr["a"]["b"])) {
+                            $arr["a"]["b"] = "foo";
+                        }
+                        echo $arr["a"]["b"];
+                    }',
+            ],
+            'conditionalArrayAccessInLoopAfterIssetWithAltAssignment' => [
                 '<?php
                     $arr = [];
                     while (rand(0, 1)) {
@@ -571,7 +581,7 @@ class IssetTest extends TestCase
                         }
                     }',
             ],
-            'SKIPPED-issetOnNestedObjectlikeOneLevel' => [
+            'issetOnNestedObjectlikeOneLevel' => [
                 '<?php
                     /**
                      * @param array{a:array} $array
@@ -585,6 +595,34 @@ class IssetTest extends TestCase
                         return $array;
                     }'
             ],
+            'issetOnStringArrayShouldInformArrayness' => [
+                '<?php
+                    /**
+                     * @param string[] $a
+                     * @return array{b: string}
+                     */
+                    function foo(array $a) {
+                        if (isset($a["b"])) {
+                            return $a;
+                        }
+
+                        throw new \Exception("bad");
+                    }'
+            ],
+            'arrayKeyExistsOnStringArrayShouldInformArrayness' => [
+                '<?php
+                    /**
+                     * @param string[] $a
+                     * @return array{b: string}
+                     */
+                    function foo(array $a) {
+                        if (array_key_exists("b", $a)) {
+                            return $a;
+                        }
+
+                        throw new \Exception("bad");
+                    }'
+            ],
         ];
     }
 
diff --git a/tests/TypeReconciliationTest.php b/tests/TypeReconciliationTest.php
index e69e58826..8288e88fd 100644
--- a/tests/TypeReconciliationTest.php
+++ b/tests/TypeReconciliationTest.php
@@ -1417,57 +1417,6 @@ class TypeReconciliationTest extends TestCase
                         if ($a[0] === 5) {}
                     }'
             ],
-            'assertHasArrayAccess' => [
-                '<?php
-                    /**
-                     * @return array|ArrayAccess
-                     */
-                    function getBar(array $array) {
-                        if (isset($array[\'foo\'][\'bar\'])) {
-                            return $array[\'foo\'];
-                        }
-
-                        return [];
-                    }',
-            ],
-            'assertHasArrayAccessWithType' => [
-                '<?php
-                    /**
-                     * @param array<string, array<string, string>> $array
-                     * @return array<string, string>
-                     */
-                    function getBar(array $array) : array {
-                        if (isset($array[\'foo\'][\'bar\'])) {
-                            return $array[\'foo\'];
-                        }
-
-                        return [];
-                    }',
-            ],
-            'assertHasArrayAccessOnSimpleXMLElement' => [
-                '<?php
-                    function getBar(SimpleXMLElement $e, string $s) : void {
-                        if (isset($e[$s])) {
-                            echo (string) $e[$s];
-                        }
-
-                        if (isset($e[\'foo\'])) {
-                            echo (string) $e[\'foo\'];
-                        }
-
-                        if (isset($e->bar)) {}
-                    }',
-            ],
-            'assertArrayOffsetToTraversable' => [
-                '<?php
-                    function render(array $data): ?Traversable {
-                        if ($data["o"] instanceof Traversable) {
-                            return $data["o"];
-                        }
-
-                        return null;
-                    }'
-            ],
             'nullCoalesceTypedArrayValue' => [
                 '<?php
                     /** @param string[] $arr */
