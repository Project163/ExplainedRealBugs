diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/AtomicMethodCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/AtomicMethodCallAnalyzer.php
index 799bbd4bd..6ca0f5fb7 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/AtomicMethodCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/AtomicMethodCallAnalyzer.php
@@ -191,6 +191,7 @@ class AtomicMethodCallAnalyzer extends CallAnalyzer
                 $result->has_mixed_method_call = $intersection_result->has_mixed_method_call;
                 $result->invalid_method_call_types = $intersection_result->invalid_method_call_types;
                 $result->check_visibility = $intersection_result->check_visibility;
+                $result->too_many_arguments = $intersection_result->too_many_arguments;
 
                 $all_intersection_existent_method_ids = array_merge(
                     $all_intersection_existent_method_ids,
diff --git a/tests/MethodCallTest.php b/tests/MethodCallTest.php
index a184d6783..4afb1070a 100644
--- a/tests/MethodCallTest.php
+++ b/tests/MethodCallTest.php
@@ -553,6 +553,28 @@ class MethodCallTest extends TestCase
 
                     (rand(0, 1) ? new A : new B)->fooFoo(5, "dfd");',
             ],
+            'interfaceMethodCallCheck' => [
+                '<?php
+                    interface A {
+                        function foo() : void;
+                    }
+
+                    interface B extends A {
+                        function foo(string $a = "") : void;
+                    }
+
+                    class C implements B {
+                        public function foo(string $a = "") : void {}
+                    }
+
+                    function takesWithoutArguments(A $a) : void {
+                        if ($a instanceof B) {
+                           $a->foo("");
+                        }
+                    }
+
+                    takesWithoutArguments(new C);'
+            ],
         ];
     }
 
