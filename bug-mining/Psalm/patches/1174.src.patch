diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
index 225aa21b2..2ecd6f9e2 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/FunctionCallAnalyzer.php
@@ -90,10 +90,12 @@ class FunctionCallAnalyzer extends CallAnalyzer
         $code_location = new CodeLocation($statements_analyzer->getSource(), $stmt);
         $config = $codebase->config;
 
+        $is_first_class_callable = $stmt->isFirstClassCallable();
+
         $real_stmt = $stmt;
 
         if ($function_name instanceof PhpParser\Node\Name
-            && !$stmt->isFirstClassCallable()
+            && !$is_first_class_callable
             && isset($stmt->getArgs()[0])
             && !$stmt->getArgs()[0]->unpack
         ) {
@@ -152,7 +154,6 @@ class FunctionCallAnalyzer extends CallAnalyzer
             }
         }
 
-        $is_first_class_callable = $stmt->isFirstClassCallable();
         $set_inside_conditional = false;
 
         if ($function_name instanceof PhpParser\Node\Name
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
index 8f09b222b..17ed678ab 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MethodCallReturnTypeFetcher.php
@@ -60,6 +60,22 @@ class MethodCallReturnTypeFetcher
         $fq_class_name = $method_id->fq_class_name;
         $method_name = $method_id->method_name;
 
+        $class_storage = $codebase->methods->getClassLikeStorageForMethod($method_id);
+        $method_storage = ($class_storage->methods[$method_id->method_name] ?? null);
+
+        if ($stmt->isFirstClassCallable()) {
+            if ($method_storage) {
+                return new Union([new TClosure(
+                    'Closure',
+                    $method_storage->params,
+                    $method_storage->return_type,
+                    $method_storage->pure
+                )]);
+            }
+
+            return Type::getClosure();
+        }
+
         if ($codebase->methods->return_type_provider->has($premixin_method_id->fq_class_name)) {
             $return_type_candidate = $codebase->methods->return_type_provider->getReturnType(
                 $statements_analyzer,
@@ -99,8 +115,6 @@ class MethodCallReturnTypeFetcher
             }
         }
 
-        $class_storage = $codebase->methods->getClassLikeStorageForMethod($method_id);
-
         if (InternalCallMapHandler::inCallMap((string) $call_map_id)) {
             if (($template_result->lower_bounds || $class_storage->stubbed)
                 && ($method_storage = ($class_storage->methods[$method_id->method_name] ?? null))
@@ -143,58 +157,22 @@ class MethodCallReturnTypeFetcher
         } else {
             $self_fq_class_name = $fq_class_name;
 
-            if ($stmt->isFirstClassCallable()) {
-                $method_storage = ($class_storage->methods[$method_id->method_name] ?? null);
-
-                if ($method_storage) {
-                    $return_type_candidate = new Union([new TClosure(
-                        'Closure',
-                        $method_storage->params,
-                        $method_storage->return_type,
-                        $method_storage->pure
-                    )]);
-                } else {
-                    $return_type_candidate = Type::getClosure();
-                }
-            } else {
-                $return_type_candidate = $codebase->methods->getMethodReturnType(
-                    $method_id,
-                    $self_fq_class_name,
-                    $statements_analyzer,
-                    $args
-                );
-
-                if ($return_type_candidate) {
-                    $return_type_candidate = clone $return_type_candidate;
-
-                    if ($template_result->lower_bounds) {
-                        $return_type_candidate = TypeExpander::expandUnion(
-                            $codebase,
-                            $return_type_candidate,
-                            $fq_class_name,
-                            null,
-                            $class_storage->parent_class,
-                            true,
-                            false,
-                            $static_type instanceof TNamedObject
-                            && $codebase->classlike_storage_provider->get($static_type->value)->final,
-                            true
-                        );
-                    }
+            $return_type_candidate = $codebase->methods->getMethodReturnType(
+                $method_id,
+                $self_fq_class_name,
+                $statements_analyzer,
+                $args
+            );
 
-                    $return_type_candidate = self::replaceTemplateTypes(
-                        $return_type_candidate,
-                        $template_result,
-                        $method_id,
-                        count($stmt->getArgs()),
-                        $codebase
-                    );
+            if ($return_type_candidate) {
+                $return_type_candidate = clone $return_type_candidate;
 
+                if ($template_result->lower_bounds) {
                     $return_type_candidate = TypeExpander::expandUnion(
                         $codebase,
                         $return_type_candidate,
-                        $self_fq_class_name,
-                        $static_type,
+                        $fq_class_name,
+                        null,
                         $class_storage->parent_class,
                         true,
                         false,
@@ -202,36 +180,57 @@ class MethodCallReturnTypeFetcher
                         && $codebase->classlike_storage_provider->get($static_type->value)->final,
                         true
                     );
+                }
 
-                    $return_type_location = $codebase->methods->getMethodReturnTypeLocation(
-                        $method_id,
-                        $secondary_return_type_location
-                    );
+                $return_type_candidate = self::replaceTemplateTypes(
+                    $return_type_candidate,
+                    $template_result,
+                    $method_id,
+                    count($stmt->getArgs()),
+                    $codebase
+                );
 
-                    if ($secondary_return_type_location) {
-                        $return_type_location = $secondary_return_type_location;
-                    }
+                $return_type_candidate = TypeExpander::expandUnion(
+                    $codebase,
+                    $return_type_candidate,
+                    $self_fq_class_name,
+                    $static_type,
+                    $class_storage->parent_class,
+                    true,
+                    false,
+                    $static_type instanceof TNamedObject
+                    && $codebase->classlike_storage_provider->get($static_type->value)->final,
+                    true
+                );
 
-                    $config = Config::getInstance();
-
-                    // only check the type locally if it's defined externally
-                    if ($return_type_location && !$config->isInProjectDirs($return_type_location->file_path)) {
-                        $return_type_candidate->check(
-                            $statements_analyzer,
-                            new CodeLocation($statements_analyzer, $stmt),
-                            $statements_analyzer->getSuppressedIssues(),
-                            $context->phantom_classes,
-                            true,
-                            false,
-                            false,
-                            $context->calling_method_id
-                        );
-                    }
-                } else {
-                    $result->returns_by_ref =
-                        $result->returns_by_ref
-                        || $codebase->methods->getMethodReturnsByRef($method_id);
+                $return_type_location = $codebase->methods->getMethodReturnTypeLocation(
+                    $method_id,
+                    $secondary_return_type_location
+                );
+
+                if ($secondary_return_type_location) {
+                    $return_type_location = $secondary_return_type_location;
                 }
+
+                $config = Config::getInstance();
+
+                // only check the type locally if it's defined externally
+                if ($return_type_location && !$config->isInProjectDirs($return_type_location->file_path)) {
+                    $return_type_candidate->check(
+                        $statements_analyzer,
+                        new CodeLocation($statements_analyzer, $stmt),
+                        $statements_analyzer->getSuppressedIssues(),
+                        $context->phantom_classes,
+                        true,
+                        false,
+                        false,
+                        $context->calling_method_id
+                    );
+                }
+            } else {
+                $result->returns_by_ref =
+                    $result->returns_by_ref
+                    || $codebase->methods->getMethodReturnsByRef($method_id);
             }
         }
 
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MissingMethodCallHandler.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MissingMethodCallHandler.php
index 1c1c649f5..3b050ce76 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MissingMethodCallHandler.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/Method/MissingMethodCallHandler.php
@@ -17,7 +17,9 @@ use Psalm\Node\Expr\VirtualArrayItem;
 use Psalm\Node\Scalar\VirtualString;
 use Psalm\Node\VirtualArg;
 use Psalm\Storage\ClassLikeStorage;
+use Psalm\Storage\MethodStorage;
 use Psalm\Type;
+use Psalm\Type\Atomic\TClosure;
 use Psalm\Type\Union;
 
 use function array_map;
@@ -39,6 +41,21 @@ class MissingMethodCallHandler
         $fq_class_name = $method_id->fq_class_name;
         $method_name_lc = $method_id->method_name;
 
+        if ($stmt->isFirstClassCallable()) {
+            if (isset($class_storage->pseudo_methods[$method_name_lc])) {
+                $result->has_valid_method_call_type = true;
+                $result->existent_method_ids[] = $method_id->__toString();
+                $result->return_type = self::createFirstClassCallableReturnType(
+                    $class_storage->pseudo_methods[$method_name_lc]
+                );
+            } else {
+                $result->non_existent_magic_method_ids[] = $method_id->__toString();
+                $result->return_type = self::createFirstClassCallableReturnType();
+            }
+
+            return null;
+        }
+
         if ($codebase->methods->return_type_provider->has($fq_class_name)) {
             $return_type_candidate = $codebase->methods->return_type_provider->getReturnType(
                 $statements_analyzer,
@@ -220,6 +237,11 @@ class MissingMethodCallHandler
 
             $pseudo_method_storage = $class_storage->pseudo_methods[$method_name_lc];
 
+            if ($stmt->isFirstClassCallable()) {
+                $result->return_type = self::createFirstClassCallableReturnType($pseudo_method_storage);
+                return;
+            }
+
             if (ArgumentsAnalyzer::analyze(
                 $statements_analyzer,
                 $stmt->getArgs(),
@@ -277,6 +299,12 @@ class MissingMethodCallHandler
             return;
         }
 
+        if ($stmt->isFirstClassCallable()) {
+            $result->non_existent_class_method_ids[] = $method_id->__toString();
+            $result->return_type = self::createFirstClassCallableReturnType();
+            return;
+        }
+
         if (ArgumentsAnalyzer::analyze(
             $statements_analyzer,
             $stmt->getArgs(),
@@ -309,4 +337,18 @@ class MissingMethodCallHandler
             }
         }
     }
+
+    private static function createFirstClassCallableReturnType(?MethodStorage $method_storage = null): Union
+    {
+        if ($method_storage) {
+            return new Union([new TClosure(
+                'Closure',
+                $method_storage->params,
+                $method_storage->return_type,
+                $method_storage->pure
+            )]);
+        }
+
+        return Type::getClosure();
+    }
 }
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
index eef4a321e..957d53077 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/MethodCallAnalyzer.php
@@ -382,7 +382,7 @@ class MethodCallAnalyzer extends CallAnalyzer
         }
 
         if (!$result->existent_method_ids) {
-            return self::checkMethodArgs(
+            return $stmt->isFirstClassCallable() || self::checkMethodArgs(
                 null,
                 $stmt->getArgs(),
                 null,
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/AtomicStaticCallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/AtomicStaticCallAnalyzer.php
index 6adf64c59..04b863381 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/AtomicStaticCallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/Call/StaticMethod/AtomicStaticCallAnalyzer.php
@@ -288,8 +288,6 @@ class AtomicStaticCallAnalyzer
             );
         }
 
-        $args = $stmt->isFirstClassCallable() ? [] : $stmt->getArgs();
-
         if ($intersection_types
             && !$codebase->methods->methodExists($method_id)
         ) {
@@ -346,6 +344,28 @@ class AtomicStaticCallAnalyzer
             }
         }
 
+        if ($stmt->isFirstClassCallable()) {
+            $method_storage = ($class_storage->methods[$method_name_lc] ??
+                ($class_storage->pseudo_static_methods[$method_name_lc] ?? null));
+
+            if ($method_storage) {
+                $return_type_candidate = new Union([new TClosure(
+                    'Closure',
+                    $method_storage->params,
+                    $method_storage->return_type,
+                    $method_storage->pure
+                )]);
+            } else {
+                $return_type_candidate = Type::getClosure();
+            }
+
+            $statements_analyzer->node_data->setType($stmt, $return_type_candidate);
+
+            return true;
+        }
+
+        $args = $stmt->getArgs();
+
         if (!$naive_method_exists
             && $class_storage->mixin_declaring_fqcln
             && $class_storage->namedMixins
@@ -790,25 +810,6 @@ class AtomicStaticCallAnalyzer
 
         $has_existing_method = true;
 
-        if ($stmt->isFirstClassCallable()) {
-            $method_storage = ($class_storage->methods[$method_id->method_name] ?? null);
-
-            if ($method_storage) {
-                $return_type_candidate = new Union([new TClosure(
-                    'Closure',
-                    $method_storage->params,
-                    $method_storage->return_type,
-                    $method_storage->pure
-                )]);
-            } else {
-                $return_type_candidate = Type::getClosure();
-            }
-
-            $statements_analyzer->node_data->setType($stmt, $return_type_candidate);
-
-            return true;
-        }
-
         ExistingAtomicStaticCallAnalyzer::analyze(
             $statements_analyzer,
             $stmt,
diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/ExpressionIdentifier.php b/src/Psalm/Internal/Analyzer/Statements/Expression/ExpressionIdentifier.php
index 19cbe3044..c5f64d472 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/ExpressionIdentifier.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/ExpressionIdentifier.php
@@ -199,6 +199,7 @@ class ExpressionIdentifier
 
         if ($stmt instanceof PhpParser\Node\Expr\MethodCall
             && $stmt->name instanceof PhpParser\Node\Identifier
+            && !$stmt->isFirstClassCallable()
             && !$stmt->getArgs()
         ) {
             $config = Config::getInstance();
diff --git a/tests/ClosureTest.php b/tests/ClosureTest.php
index 4fd04e84d..64a17a53d 100644
--- a/tests/ClosureTest.php
+++ b/tests/ClosureTest.php
@@ -589,7 +589,7 @@ class ClosureTest extends TestCase
                 [],
                 '8.1'
             ],
-            'FirstClassCallable:InstanceMethod' => [
+            'FirstClassCallable:InstanceMethod:UserDefined' => [
                 '<?php
                     class Test {
                         public function __construct(private readonly string $string) {
@@ -609,6 +609,18 @@ class ClosureTest extends TestCase
                 [],
                 '8.1'
             ],
+            'FirstClassCallable:InstanceMethod:BuiltIn' => [
+                '<?php
+                    $queue = new \SplQueue;
+                    $closure = $queue->count(...);
+                    $count = $closure();
+                ',
+                'assertions' => [
+                    '$count' => 'int',
+                ],
+                [],
+                '8.1'
+            ],
             'FirstClassCallable:StaticMethod' => [
                 '<?php
                     class Test {
@@ -653,6 +665,70 @@ class ClosureTest extends TestCase
                 [],
                 '8.1'
             ],
+            'FirstClassCallable:MagicInstanceMethod' => [
+                '<?php
+                    /**
+                     * @method int length()
+                     */
+                    class Test {
+                        public function __construct(private readonly string $string) {
+                        }
+
+                        public function __call(string $name, array $args): mixed {
+                            return match ($name) {
+                                "length" => strlen($this->string),
+                                default => throw new \Error("Undefined method"),
+                            };
+                        }
+                    }
+                    $test = new Test("test");
+                    $closure = $test->length(...);
+                    $length = $closure();
+                ',
+                'assertions' => [
+                    '$length' => 'int',
+                ],
+                [],
+                '8.1'
+            ],
+            'FirstClassCallable:MagicStaticMethod' => [
+                '<?php
+                    /**
+                     * @method static int length(string $length)
+                     */
+                    class Test {
+                        public static function __callStatic(string $name, array $args): mixed {
+                            return match ($name) {
+                                "length" => strlen((string) $args[0]),
+                                default => throw new \Error("Undefined method"),
+                            };
+                        }
+                    }
+                    $closure = Test::length(...);
+                    $length = $closure("test");
+                ',
+                'assertions' => [
+                    '$length' => 'int',
+                ],
+                [],
+                '8.1'
+            ],
+            'FirstClassCallable:WithArrayMap' => [
+                '<?php
+                    $array = [1, 2, 3];
+                    $closure = fn (int $value): int => $value * $value;
+                    $result1 = array_map((new \SplQueue())->enqueue(...), $array);
+                    $result2 = array_map(strval(...), $array);
+                    $result3 = array_map($closure(...), $array);
+                ',
+                'assertions' => [
+                    '$result1' => 'array{null, null, null}',
+                    '$result2' => 'array{string, string, string}',
+                    '$result3' => 'array{int, int, int}',
+                ],
+                [],
+                '8.1'
+            ],
         ];
     }
 
@@ -1051,6 +1127,53 @@ class ClosureTest extends TestCase
                     takesClosure(5);',
                 'error_message' => 'InvalidArgument',
             ],
+            'FirstClassCallable:UndefinedMethod' => [
+                '<?php
+                    $queue = new \SplQueue;
+                    $closure = $queue->undefined(...);
+                    $count = $closure();
+                ',
+                'error_message' => 'UndefinedMethod',
+                [],
+                false,
+                '8.1'
+            ],
+            'FirstClassCallable:UndefinedMagicInstanceMethod' => [
+                '<?php
+                    class Test {
+                        public function __call(string $name, array $args): mixed {
+                            return match ($name) {
+                                default => throw new \Error("Undefined method"),
+                            };
+                        }
+                    }
+                    $test = new Test();
+                    $closure = $test->length(...);
+                    $length = $closure();
+                ',
+                'error_message' => 'UndefinedMagicMethod',
+                [],
+                false,
+                '8.1'
+            ],
+            'FirstClassCallable:UndefinedMagicStaticMethod' => [
+                '<?php
+                    class Test {
+                        public static function __callStatic(string $name, array $args): mixed {
+                            return match ($name) {
+                                default => throw new \Error("Undefined method"),
+                            };
+                        }
+                    }
+                    $closure = Test::length(...);
+                    $length = $closure();
+                ',
+                'error_message' => 'MixedAssignment',
+                [],
+                false,
+                '8.1'
+            ],
+
         ];
     }
 }
