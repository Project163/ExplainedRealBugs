diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayValuesReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayValuesReturnTypeProvider.php
index 3a85bc470..1d0294943 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayValuesReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/ArrayValuesReturnTypeProvider.php
@@ -23,42 +23,53 @@ class ArrayValuesReturnTypeProvider implements \Psalm\Plugin\EventHandler\Functi
             return Type::getMixed();
         }
 
-        $first_arg = $call_args[0]->value ?? null;
+        $first_arg = isset($call_args[0]->value) ? $call_args[0]->value : null;
 
-        $first_arg_array = $first_arg
-            && ($first_arg_type = $statements_source->node_data->getType($first_arg))
-            && $first_arg_type->hasType('array')
-            && ($array_atomic_type = $first_arg_type->getAtomicTypes()['array'])
-            && ($array_atomic_type instanceof Type\Atomic\TArray
-                || $array_atomic_type instanceof Type\Atomic\TKeyedArray
-                || $array_atomic_type instanceof Type\Atomic\TList)
-        ? $array_atomic_type
-        : null;
-
-        if (!$first_arg_array) {
+        if (!$first_arg) {
             return Type::getArray();
         }
 
-        if ($first_arg_array instanceof Type\Atomic\TKeyedArray) {
-            $first_arg_array = $first_arg_array->getGenericArrayType();
+        $first_arg_type = $statements_source->node_data->getType($first_arg);
+
+        if (!$first_arg_type) {
+            return Type::getArray();
         }
 
-        if ($first_arg_array instanceof Type\Atomic\TArray) {
-            if ($first_arg_array instanceof Type\Atomic\TNonEmptyArray) {
-                return new Type\Union([
-                    new Type\Atomic\TNonEmptyList(
-                        clone $first_arg_array->type_params[1]
-                    )
-                ]);
+        $atomic_types = $first_arg_type->getAtomicTypes();
+
+        $return_atomic_type = null;
+
+        while ($atomic_type = \array_shift($atomic_types)) {
+            if ($atomic_type instanceof Type\Atomic\TTemplateParam) {
+                $atomic_types = \array_merge($atomic_types, $atomic_type->as->getAtomicTypes());
+                continue;
             }
 
-            return new Type\Union([
-                new Type\Atomic\TList(
-                    clone $first_arg_array->type_params[1]
-                )
-            ]);
+            if ($atomic_type instanceof Type\Atomic\TKeyedArray) {
+                $atomic_type = $atomic_type->getGenericArrayType();
+            }
+
+            if ($atomic_type instanceof Type\Atomic\TArray) {
+                if ($atomic_type instanceof Type\Atomic\TNonEmptyArray) {
+                    $return_atomic_type = new Type\Atomic\TNonEmptyList(
+                        clone $atomic_type->type_params[1]
+                    );
+                } else {
+                    $return_atomic_type = new Type\Atomic\TList(
+                        clone $atomic_type->type_params[1]
+                    );
+                }
+            } elseif ($atomic_type instanceof Type\Atomic\TList) {
+                $return_atomic_type = $atomic_type;
+            } else {
+                return Type::getArray();
+            }
+        }
+
+        if (!$return_atomic_type) {
+            throw new \UnexpectedValueException('This should never happen');
         }
 
-        return new Type\Union([clone $first_arg_array]);
+        return new Type\Union([$return_atomic_type]);
     }
 }
diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php
index 23983e277..17c224c19 100644
--- a/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/IteratorToArrayReturnTypeProvider.php
@@ -34,15 +34,20 @@ class IteratorToArrayReturnTypeProvider implements \Psalm\Plugin\EventHandler\Fu
             return Type::getMixed();
         }
 
-        if (($first_arg_type = $statements_source->node_data->getType($call_args[0]->value))
-            && $first_arg_type->hasObjectType()
-        ) {
+        if (($first_arg_type = $statements_source->node_data->getType($call_args[0]->value))) {
             $key_type = null;
             $value_type = null;
 
             $codebase = $statements_source->getCodebase();
 
-            foreach ($first_arg_type->getAtomicTypes() as $call_arg_atomic_type) {
+            $atomic_types = $first_arg_type->getAtomicTypes();
+
+            while ($call_arg_atomic_type = array_shift($atomic_types)) {
+                if ($call_arg_atomic_type instanceof Type\Atomic\TTemplateParam) {
+                    $atomic_types = \array_merge($atomic_types, $call_arg_atomic_type->as->getAtomicTypes());
+                    continue;
+                }
+
                 if ($call_arg_atomic_type instanceof Type\Atomic\TNamedObject
                     && AtomicTypeComparator::isContainedBy(
                         $codebase,
diff --git a/tests/Template/ConditionalReturnTypeTest.php b/tests/Template/ConditionalReturnTypeTest.php
index 3b3a75f09..2885426a7 100644
--- a/tests/Template/ConditionalReturnTypeTest.php
+++ b/tests/Template/ConditionalReturnTypeTest.php
@@ -790,6 +790,27 @@ class ConditionalReturnTypeTest extends TestCase
                     /** @psalm-suppress MixedArgument */
                     echo (new Request)->getParams(Request::SOURCE_GET)["a"];'
             ],
+            'conditionalArrayValues' => [
+                '<?php
+                    /**
+                     * @psalm-pure
+                     * @template TValue
+                     * @template TIterable of ?iterable<TValue>
+                     * @param TIterable $iterable
+                     * @return (TIterable is null ? null : list<TValue>)
+                     */
+                    function toList(?iterable $iterable): ?array {
+                        if (null === $iterable) {
+                            return null;
+                        }
+
+                        if (is_array($iterable)) {
+                            return array_values($iterable);
+                        }
+
+                        return iterator_to_array($iterable, false);
+                    }'
+            ],
         ];
     }
 }
