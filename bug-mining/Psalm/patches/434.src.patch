diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index 2b8d52721..56f6c97ca 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -2032,14 +2032,11 @@ class CallAnalyzer
                 break;
             }
 
-            $array_arg = isset($arg->value) ? $arg->value : null;
-
             /**
              * @psalm-suppress PossiblyUndefinedStringArrayOffset
              * @var ObjectLike|TArray|TList|null
              */
-            $array_arg_type = $array_arg
-                    && ($arg_value_type = $statements_analyzer->node_data->getType($array_arg))
+            $array_arg_type = ($arg_value_type = $statements_analyzer->node_data->getType($arg->value))
                     && ($types = $arg_value_type->getAtomicTypes())
                     && isset($types['array'])
                 ? $types['array']
diff --git a/src/Psalm/Internal/Type/NegatedAssertionReconciler.php b/src/Psalm/Internal/Type/NegatedAssertionReconciler.php
index 1aefbcad9..eb4b4ee55 100644
--- a/src/Psalm/Internal/Type/NegatedAssertionReconciler.php
+++ b/src/Psalm/Internal/Type/NegatedAssertionReconciler.php
@@ -11,6 +11,7 @@ use Psalm\Internal\Analyzer\TraitAnalyzer;
 use Psalm\Internal\Analyzer\TypeAnalyzer;
 use Psalm\Issue\ParadoxicalCondition;
 use Psalm\Issue\RedundantCondition;
+use Psalm\Issue\TypeDoesNotContainType;
 use Psalm\IssueBuffer;
 use Psalm\Type;
 use Psalm\Type\Atomic;
@@ -92,6 +93,34 @@ class NegatedAssertionReconciler extends Reconciler
                     return Type::getEmpty();
                 }
 
+                if (!$existing_var_type->isNullable()
+                    && $key
+                    && strpos($key, '[') === false
+                    && strpos($key, '->') === false
+                ) {
+                    foreach ($existing_var_type->getAtomicTypes() as $atomic) {
+                        if (!$atomic instanceof TMixed
+                            || $atomic instanceof Type\Atomic\TNonEmptyMixed
+                        ) {
+                            $failed_reconciliation = 2;
+
+                            if ($code_location) {
+                                if (IssueBuffer::accepts(
+                                    new TypeDoesNotContainType(
+                                        'Cannot resolve types for ' . $key . ' and !isset assertion',
+                                        $code_location
+                                    ),
+                                    $suppressed_issues
+                                )) {
+                                    // fall through
+                                }
+                            }
+
+                            return Type::getEmpty();
+                        }
+                    }
+                }
+
                 return Type::getNull();
             } elseif ($assertion === 'array-key-exists') {
                 return Type::getEmpty();
diff --git a/tests/TypeReconciliation/IssetTest.php b/tests/TypeReconciliation/IssetTest.php
index bb703deb7..e9ab82d6d 100644
--- a/tests/TypeReconciliation/IssetTest.php
+++ b/tests/TypeReconciliation/IssetTest.php
@@ -787,6 +787,16 @@ class IssetTest extends \Psalm\Tests\TestCase
                     }',
                 'error_message' => 'TypeDoesNotContainType',
             ],
+            'stringIsAlwaysSet' => [
+                '<?php
+                    function foo(string $s) : string {
+                        if (!isset($s)) {
+                            return "foo";
+                        }
+                        return "bar";
+                    }',
+                'error_message' => 'TypeDoesNotContainType'
+            ],
         ];
     }
 }
