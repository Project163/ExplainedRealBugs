diff --git a/src/Psalm/Internal/Codebase/ClassLikes.php b/src/Psalm/Internal/Codebase/ClassLikes.php
index 7ffde7269..e0e0d3f58 100644
--- a/src/Psalm/Internal/Codebase/ClassLikes.php
+++ b/src/Psalm/Internal/Codebase/ClassLikes.php
@@ -1495,14 +1495,12 @@ class ClassLikes
         }
 
         if ($constant_storage->unresolved_node) {
-            return new Type\Union([
-                ConstantTypeResolver::resolve(
-                    $this,
-                    $constant_storage->unresolved_node,
-                    $statements_analyzer,
-                    $visited_constant_ids
-                )
-            ]);
+            $constant_storage->type = new Type\Union([ConstantTypeResolver::resolve(
+                $this,
+                $constant_storage->unresolved_node,
+                $statements_analyzer,
+                $visited_constant_ids
+            )]);
         }
 
         return $constant_storage->type;
diff --git a/src/Psalm/Internal/Codebase/ConstantTypeResolver.php b/src/Psalm/Internal/Codebase/ConstantTypeResolver.php
index 814bcbca8..4c7607e51 100644
--- a/src/Psalm/Internal/Codebase/ConstantTypeResolver.php
+++ b/src/Psalm/Internal/Codebase/ConstantTypeResolver.php
@@ -5,6 +5,7 @@ use Psalm\Internal\Scanner\UnresolvedConstant;
 use Psalm\Internal\Analyzer\Statements\Expression\Fetch\ConstFetchAnalyzer;
 use Psalm\Type;
 use ReflectionProperty;
+use function ctype_digit;
 
 /**
  * @internal
@@ -46,11 +47,17 @@ class ConstantTypeResolver
             }
 
             if ($c instanceof UnresolvedConstant\UnresolvedConcatOp) {
-                if ($left instanceof Type\Atomic\TLiteralString && $right instanceof Type\Atomic\TLiteralString) {
+                if (($left instanceof Type\Atomic\TLiteralString
+                        || $left instanceof Type\Atomic\TLiteralFloat
+                        || $left instanceof Type\Atomic\TLiteralInt)
+                    && ($right instanceof Type\Atomic\TLiteralString
+                        || $right instanceof Type\Atomic\TLiteralFloat
+                        || $right instanceof Type\Atomic\TLiteralInt)
+                ) {
                     return new Type\Atomic\TLiteralString($left->value . $right->value);
                 }
 
-                return new Type\Atomic\TMixed;
+                return new Type\Atomic\TString();
             }
 
             if ($c instanceof UnresolvedConstant\UnresolvedAdditionOp
@@ -91,6 +98,10 @@ class ConstantTypeResolver
                     return self::getLiteralTypeFromScalarValue($left->value * $right->value);
                 }
 
+                if ($left instanceof Type\Atomic\TKeyedArray && $right instanceof Type\Atomic\TKeyedArray) {
+                    return new Type\Atomic\TKeyedArray($left->properties + $right->properties);
+                }
+
                 return new Type\Atomic\TMixed;
             }
 
@@ -133,6 +144,7 @@ class ConstantTypeResolver
 
         if ($c instanceof UnresolvedConstant\ArrayValue) {
             $properties = [];
+            $auto_key = 0;
 
             if (!$c->entries) {
                 return new Type\Atomic\TArray([Type::getEmpty(), Type::getEmpty()]);
@@ -140,7 +152,29 @@ class ConstantTypeResolver
 
             $is_list = true;
 
-            foreach ($c->entries as $i => $entry) {
+            foreach ($c->entries as $entry) {
+                if ($entry instanceof UnresolvedConstant\ArraySpread) {
+                    $spread_array = self::resolve(
+                        $classlikes,
+                        $entry->array,
+                        $statements_analyzer,
+                        $visited_constant_ids + [$c_id => true]
+                    );
+
+                    if ($spread_array instanceof Type\Atomic\TArray && $spread_array->type_params[1]->isEmpty()) {
+                        continue;
+                    }
+
+                    if (!$spread_array instanceof Type\Atomic\TKeyedArray) {
+                        return new Type\Atomic\TArray([Type::getArrayKey(), Type::getMixed()]);
+                    }
+
+                    foreach ($spread_array->properties as $spread_array_type) {
+                        $properties[$auto_key++] = $spread_array_type;
+                    }
+                    continue;
+                }
+
                 if ($entry->key) {
                     $key_type = self::resolve(
                         $classlikes,
@@ -150,18 +184,23 @@ class ConstantTypeResolver
                     );
 
                     if (!$key_type instanceof Type\Atomic\TLiteralInt
-                        || $key_type->value !== $i
+                        || $key_type->value !== $auto_key
                     ) {
                         $is_list = false;
                     }
                 } else {
-                    $key_type = new Type\Atomic\TLiteralInt($i);
+                    $key_type = new Type\Atomic\TLiteralInt($auto_key);
                 }
 
                 if ($key_type instanceof Type\Atomic\TLiteralInt
                     || $key_type instanceof Type\Atomic\TLiteralString
                 ) {
                     $key_value = $key_type->value;
+                    if ($key_type instanceof Type\Atomic\TLiteralInt) {
+                        $auto_key = $key_type->value + 1;
+                    } elseif (ctype_digit($key_type->value)) {
+                        $auto_key = ((int) $key_type->value) + 1;
+                    }
                 } else {
                     return new Type\Atomic\TArray([Type::getArrayKey(), Type::getMixed()]);
                 }
@@ -176,12 +215,19 @@ class ConstantTypeResolver
                 $properties[$key_value] = $value_type;
             }
 
-            $objectlike = new Type\Atomic\TKeyedArray($properties);
+            if (empty($properties)) {
+                $resolved_type = new Type\Atomic\TArray([
+                    new Type\Union([new Type\Atomic\TEmpty()]),
+                    new Type\Union([new Type\Atomic\TEmpty()]),
+                ]);
+            } else {
+                $resolved_type = new Type\Atomic\TKeyedArray($properties);
 
-            $objectlike->is_list = $is_list;
-            $objectlike->sealed = true;
+                $resolved_type->is_list = $is_list;
+                $resolved_type->sealed = true;
+            }
 
-            return $objectlike;
+            return $resolved_type;
         }
 
         if ($c instanceof UnresolvedConstant\ClassConstant) {
diff --git a/src/Psalm/Internal/PhpVisitor/Reflector/ClassLikeNodeScanner.php b/src/Psalm/Internal/PhpVisitor/Reflector/ClassLikeNodeScanner.php
index 776518491..318a16331 100644
--- a/src/Psalm/Internal/PhpVisitor/Reflector/ClassLikeNodeScanner.php
+++ b/src/Psalm/Internal/PhpVisitor/Reflector/ClassLikeNodeScanner.php
@@ -46,6 +46,8 @@ use function preg_split;
 use const PREG_SPLIT_DELIM_CAPTURE;
 use const PREG_SPLIT_NO_EMPTY;
 use function array_shift;
+use function array_values;
+use function get_class;
 
 class ClassLikeNodeScanner
 {
@@ -1161,17 +1163,31 @@ class ClassLikeNodeScanner
                 $const
             );
 
+            if ($const_type
+                && $const->value instanceof \PhpParser\Node\Expr\BinaryOp\Concat
+                && $const_type->isSingle()
+                && get_class(array_values($const_type->getAtomicTypes())[0]) === Type\Atomic\TString::class
+            ) {
+                // Prefer unresolved type over inferred string from concat, so that it can later be resolved to literal.
+                $const_type = null;
+            }
+
             if ($const_type) {
                 $existing_constants[$const->name->name] = new \Psalm\Storage\ClassConstantStorage(
                     $const_type,
-                    ClassLikeAnalyzer::VISIBILITY_PUBLIC,
+                    $stmt->isProtected()
+                        ? ClassLikeAnalyzer::VISIBILITY_PROTECTED
+                        : ($stmt->isPrivate()
+                            ? ClassLikeAnalyzer::VISIBILITY_PRIVATE
+                            : ClassLikeAnalyzer::VISIBILITY_PUBLIC),
                     null
                 );
             } else {
                 $unresolved_const_expr = ExpressionResolver::getUnresolvedClassConstExpr(
                     $const->value,
                     $this->aliases,
-                    $fq_classlike_name
+                    $fq_classlike_name,
+                    $storage->parent_class
                 );
 
                 if ($unresolved_const_expr) {
diff --git a/src/Psalm/Internal/PhpVisitor/Reflector/ExpressionResolver.php b/src/Psalm/Internal/PhpVisitor/Reflector/ExpressionResolver.php
index 6277da441..91ab4464c 100644
--- a/src/Psalm/Internal/PhpVisitor/Reflector/ExpressionResolver.php
+++ b/src/Psalm/Internal/PhpVisitor/Reflector/ExpressionResolver.php
@@ -15,6 +15,7 @@ use Psalm\Codebase;
 use Psalm\Internal\Analyzer\ClassLikeAnalyzer;
 use Psalm\Internal\Scanner\UnresolvedConstant;
 use Psalm\Internal\Scanner\UnresolvedConstantComponent;
+use function assert;
 use function strtolower;
 
 class ExpressionResolver
@@ -22,19 +23,22 @@ class ExpressionResolver
     public static function getUnresolvedClassConstExpr(
         PhpParser\Node\Expr $stmt,
         Aliases $aliases,
-        ?string $fq_classlike_name
+        ?string $fq_classlike_name,
+        ?string $parent_fq_class_name = null
     ) : ?UnresolvedConstantComponent {
         if ($stmt instanceof PhpParser\Node\Expr\BinaryOp) {
             $left = self::getUnresolvedClassConstExpr(
                 $stmt->left,
                 $aliases,
-                $fq_classlike_name
+                $fq_classlike_name,
+                $parent_fq_class_name
             );
 
             $right = self::getUnresolvedClassConstExpr(
                 $stmt->right,
                 $aliases,
-                $fq_classlike_name
+                $fq_classlike_name,
+                $parent_fq_class_name
             );
 
             if (!$left || !$right) {
@@ -78,7 +82,8 @@ class ExpressionResolver
             $cond = self::getUnresolvedClassConstExpr(
                 $stmt->cond,
                 $aliases,
-                $fq_classlike_name
+                $fq_classlike_name,
+                $parent_fq_class_name
             );
 
             $if = null;
@@ -87,7 +92,8 @@ class ExpressionResolver
                 $if = self::getUnresolvedClassConstExpr(
                     $stmt->if,
                     $aliases,
-                    $fq_classlike_name
+                    $fq_classlike_name,
+                    $parent_fq_class_name
                 );
 
                 if ($if === null) {
@@ -98,7 +104,8 @@ class ExpressionResolver
             $else = self::getUnresolvedClassConstExpr(
                 $stmt->else,
                 $aliases,
-                $fq_classlike_name
+                $fq_classlike_name,
+                $parent_fq_class_name
             );
 
             if ($cond && $else && $if !== false) {
@@ -131,13 +138,15 @@ class ExpressionResolver
             $left = self::getUnresolvedClassConstExpr(
                 $stmt->var,
                 $aliases,
-                $fq_classlike_name
+                $fq_classlike_name,
+                $parent_fq_class_name
             );
 
             $right = self::getUnresolvedClassConstExpr(
                 $stmt->dim,
                 $aliases,
-                $fq_classlike_name
+                $fq_classlike_name,
+                $parent_fq_class_name
             );
 
             if ($left && $right) {
@@ -150,15 +159,20 @@ class ExpressionResolver
                 && $stmt->name instanceof PhpParser\Node\Identifier
                 && $fq_classlike_name
                 && $stmt->class->parts !== ['static']
-                && $stmt->class->parts !== ['parent']
+                && ($stmt->class->parts !== ['parent'] || $parent_fq_class_name !== null)
             ) {
                 if ($stmt->class->parts === ['self']) {
                     $const_fq_class_name = $fq_classlike_name;
                 } else {
-                    $const_fq_class_name = ClassLikeAnalyzer::getFQCLNFromNameObject(
-                        $stmt->class,
-                        $aliases
-                    );
+                    if ($stmt->class->parts === ['parent']) {
+                        assert($parent_fq_class_name !== null);
+                        $const_fq_class_name = $parent_fq_class_name;
+                    } else {
+                        $const_fq_class_name = ClassLikeAnalyzer::getFQCLNFromNameObject(
+                            $stmt->class,
+                            $aliases
+                        );
+                    }
                 }
 
                 return new UnresolvedConstant\ClassConstant($const_fq_class_name, $stmt->name->name);
@@ -186,7 +200,8 @@ class ExpressionResolver
                     $item_key_type = self::getUnresolvedClassConstExpr(
                         $item->key,
                         $aliases,
-                        $fq_classlike_name
+                        $fq_classlike_name,
+                        $parent_fq_class_name
                     );
 
                     if (!$item_key_type) {
@@ -199,14 +214,19 @@ class ExpressionResolver
                 $item_value_type = self::getUnresolvedClassConstExpr(
                     $item->value,
                     $aliases,
-                    $fq_classlike_name
+                    $fq_classlike_name,
+                    $parent_fq_class_name
                 );
 
                 if (!$item_value_type) {
                     return null;
                 }
 
-                $items[] = new UnresolvedConstant\KeyValuePair($item_key_type, $item_value_type);
+                if ($item->unpack) {
+                    $items[] = new UnresolvedConstant\ArraySpread($item_value_type);
+                } else {
+                    $items[] = new UnresolvedConstant\KeyValuePair($item_key_type, $item_value_type);
+                }
             }
 
             return new UnresolvedConstant\ArrayValue($items);
diff --git a/src/Psalm/Internal/Scanner/UnresolvedConstant/ArraySpread.php b/src/Psalm/Internal/Scanner/UnresolvedConstant/ArraySpread.php
new file mode 100644
index 000000000..1a1ec7bdf
--- /dev/null
+++ b/src/Psalm/Internal/Scanner/UnresolvedConstant/ArraySpread.php
@@ -0,0 +1,19 @@
+<?php
+
+namespace Psalm\Internal\Scanner\UnresolvedConstant;
+
+use Psalm\Internal\Scanner\UnresolvedConstantComponent;
+
+/**
+ * @psalm-immutable
+ */
+class ArraySpread extends UnresolvedConstantComponent
+{
+    /** @var UnresolvedConstantComponent */
+    public $array;
+
+    public function __construct(UnresolvedConstantComponent $array)
+    {
+        $this->array = $array;
+    }
+}
diff --git a/src/Psalm/Internal/Scanner/UnresolvedConstant/ArrayValue.php b/src/Psalm/Internal/Scanner/UnresolvedConstant/ArrayValue.php
index fe5e1b96f..e42888f29 100644
--- a/src/Psalm/Internal/Scanner/UnresolvedConstant/ArrayValue.php
+++ b/src/Psalm/Internal/Scanner/UnresolvedConstant/ArrayValue.php
@@ -9,10 +9,10 @@ use Psalm\Internal\Scanner\UnresolvedConstantComponent;
  */
 class ArrayValue extends UnresolvedConstantComponent
 {
-    /** @var array<int, KeyValuePair> */
+    /** @var array<int, KeyValuePair|ArraySpread> */
     public $entries;
 
-    /** @param list<KeyValuePair> $entries */
+    /** @param list<KeyValuePair|ArraySpread> $entries */
     public function __construct(array $entries)
     {
         $this->entries = $entries;
diff --git a/tests/ConstantTest.php b/tests/ConstantTest.php
index 79fde564d..db9c75896 100644
--- a/tests/ConstantTest.php
+++ b/tests/ConstantTest.php
@@ -228,6 +228,92 @@ class ConstantTest extends TestCase
                     '$b' => 'string',
                 ],
             ],
+            'lateConstantResolutionParentArrayPlus' => [
+                '<?php
+                    class A {
+                        public const ARR = ["a" => true];
+                    }
+
+                    class B extends A {
+                        public const ARR = parent::ARR + ["b" => true];
+                    }
+
+                    class C extends B {
+                        public const ARR = parent::ARR + ["c" => true];
+                    }
+
+                    /** @param array{a: true, b: true, c: true} $arg */
+                    function foo(array $arg): void {}
+                    foo(C::ARR);
+                ',
+            ],
+            'lateConstantResolutionParentArraySpread' => [
+                '<?php
+                    class A {
+                        public const ARR = ["a"];
+                    }
+
+                    class B extends A {
+                        public const ARR = [...parent::ARR, "b"];
+                    }
+
+                    class C extends B {
+                        public const ARR = [...parent::ARR, "c"];
+                    }
+
+                    /** @param array{"a", "b", "c"} $arg */
+                    function foo(array $arg): void {}
+                    foo(C::ARR);
+                ',
+            ],
+            'lateConstantResolutionParentStringConcat' => [
+                '<?php
+                    class A {
+                        public const STR = "a";
+                    }
+
+                    class B extends A {
+                        public const STR = parent::STR . "b";
+                    }
+
+                    class C extends B {
+                        public const STR = parent::STR . "c";
+                    }
+
+                    /** @param "abc" $foo */
+                    function foo(string $foo): void {}
+                    foo(C::STR);
+                ',
+            ],
+            'lateConstantResolutionSpreadEmptyArray' => [
+                '<?php
+                    class A {
+                        public const ARR = [];
+                    }
+
+                    class B extends A {
+                        public const ARR = [...parent::ARR];
+                    }
+
+                    class C extends B {
+                        public const ARR = [...parent::ARR];
+                    }
+
+                    /** @param array<empty, empty> $arg */
+                    function foo(array $arg): void {}
+                    foo(C::ARR);
+                ',
+            ],
+            'classConstConcatEol' => [
+                '<?php
+                    class Foo {
+                        public const BAR = "bar" . PHP_EOL;
+                    }
+
+                    $foo = Foo::BAR;
+                ',
+                'assertions' => ['$foo' => 'string'],
+            ],
             'allowConstCheckForDifferentPlatforms' => [
                 '<?php
                     if ("phpdbg" === \PHP_SAPI) {}',
