diff --git a/src/Psalm/Internal/Type/AssertionReconciler.php b/src/Psalm/Internal/Type/AssertionReconciler.php
index ae14e0014..b20c3cdbf 100644
--- a/src/Psalm/Internal/Type/AssertionReconciler.php
+++ b/src/Psalm/Internal/Type/AssertionReconciler.php
@@ -684,6 +684,30 @@ class AssertionReconciler extends \Psalm\Type\Reconciler
             }
         }
 
+        if ($new_type_part instanceof Type\Atomic\TTemplateParam
+            && $new_type_part->as->isSingle()
+        ) {
+            $new_as_atomic = array_values($new_type_part->as->getAtomicTypes())[0];
+            $acceptable_atomic_types = [];
+
+            foreach ($existing_var_type->getAtomicTypes() as $existing_var_type_part) {
+                if (TypeAnalyzer::isAtomicContainedBy(
+                    $codebase,
+                    $existing_var_type_part,
+                    $new_as_atomic
+                )) {
+                    $acceptable_atomic_types[] = clone $existing_var_type_part;
+                    continue;
+                }
+            }
+
+            if ($acceptable_atomic_types) {
+                $new_type_part->as = new Type\Union($acceptable_atomic_types);
+
+                return new Type\Union([$new_type_part]);
+            }
+        }
+
         if ($new_type_part instanceof TNamedObject
             && ((
                 $new_type_has_interface
diff --git a/tests/Template/FunctionTemplateAssertTest.php b/tests/Template/FunctionTemplateAssertTest.php
index a26ef5045..911e8f619 100644
--- a/tests/Template/FunctionTemplateAssertTest.php
+++ b/tests/Template/FunctionTemplateAssertTest.php
@@ -631,6 +631,52 @@ class FunctionTemplateAssertTest extends TestCase
                         return $anyString;
                     }'
             ],
+            'classTemplateAssert' => [
+                '<?php
+                    /**
+                     * @template ActualFieldType
+                     */
+                    final class FieldValue
+                    {
+                        /** @var ActualFieldType */
+                        public $value;
+
+                        /** @param ActualFieldType $value */
+                        public function __construct($value) {
+                            $this->value = $value;
+                        }
+                    }
+
+                    /**
+                     * @template FieldDefinitionType
+                     *
+                     * @param string|bool|int|null $value
+                     * @param FieldDefinition<FieldDefinitionType> $definition
+                     *
+                     * @return FieldValue<FieldDefinitionType>
+                     */
+                    function fromScalarAndDefinition($value, FieldDefinition $definition) : FieldValue
+                    {
+                        $definition->assertAppliesToValue($value);
+
+                        return new FieldValue($value);
+                    }
+
+                    /**
+                     * @template ExpectedFieldType
+                     */
+                    final class FieldDefinition
+                    {
+                        /**
+                         * @param mixed $value
+                         * @psalm-assert ExpectedFieldType $value
+                         */
+                        public function assertAppliesToValue($value): void
+                        {
+                          throw new \Exception("bad");
+                        }
+                    }'
+            ],
         ];
     }
 
