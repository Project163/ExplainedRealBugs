diff --git a/dictionaries/CallMap.php b/dictionaries/CallMap.php
index df6b3456d..df1739c66 100644
--- a/dictionaries/CallMap.php
+++ b/dictionaries/CallMap.php
@@ -11714,7 +11714,7 @@ return [
 'rewind' => ['bool', 'stream'=>'resource'],
 'rewinddir' => ['null|false', 'dir_handle='=>'resource'],
 'rmdir' => ['bool', 'directory'=>'string', 'context='=>'resource'],
-'round' => ['float', 'num'=>'float', 'precision='=>'int', 'mode='=>'int'],
+'round' => ['float', 'num'=>'float', 'precision='=>'int', 'mode='=>'0|positive-int'],
 'rpm_close' => ['bool', 'rpmr'=>'resource'],
 'rpm_get_tag' => ['mixed', 'rpmr'=>'resource', 'tagnum'=>'int'],
 'rpm_is_valid' => ['bool', 'filename'=>'string'],
diff --git a/dictionaries/CallMap_historical.php b/dictionaries/CallMap_historical.php
index 036c5c710..a8ad6acd4 100644
--- a/dictionaries/CallMap_historical.php
+++ b/dictionaries/CallMap_historical.php
@@ -14751,7 +14751,7 @@ return [
     'rewind' => ['bool', 'stream'=>'resource'],
     'rewinddir' => ['null|false', 'dir_handle='=>'resource'],
     'rmdir' => ['bool', 'directory'=>'string', 'context='=>'resource'],
-    'round' => ['float', 'num'=>'float', 'precision='=>'int', 'mode='=>'int'],
+    'round' => ['float', 'num'=>'float', 'precision='=>'int', 'mode='=>'0|positive-int'],
     'rpm_close' => ['bool', 'rpmr'=>'resource'],
     'rpm_get_tag' => ['mixed', 'rpmr'=>'resource', 'tagnum'=>'int'],
     'rpm_is_valid' => ['bool', 'filename'=>'string'],
diff --git a/src/Psalm/Internal/Provider/FunctionReturnTypeProvider.php b/src/Psalm/Internal/Provider/FunctionReturnTypeProvider.php
index 8b124ea55..e4636d5c3 100644
--- a/src/Psalm/Internal/Provider/FunctionReturnTypeProvider.php
+++ b/src/Psalm/Internal/Provider/FunctionReturnTypeProvider.php
@@ -35,6 +35,7 @@ use Psalm\Internal\Provider\ReturnTypeProvider\MinMaxReturnTypeProvider;
 use Psalm\Internal\Provider\ReturnTypeProvider\MktimeReturnTypeProvider;
 use Psalm\Internal\Provider\ReturnTypeProvider\ParseUrlReturnTypeProvider;
 use Psalm\Internal\Provider\ReturnTypeProvider\RandReturnTypeProvider;
+use Psalm\Internal\Provider\ReturnTypeProvider\RoundReturnTypeProvider;
 use Psalm\Internal\Provider\ReturnTypeProvider\StrReplaceReturnTypeProvider;
 use Psalm\Internal\Provider\ReturnTypeProvider\StrTrReturnTypeProvider;
 use Psalm\Internal\Provider\ReturnTypeProvider\TriggerErrorReturnTypeProvider;
@@ -109,6 +110,7 @@ class FunctionReturnTypeProvider
         $this->registerClass(TriggerErrorReturnTypeProvider::class);
         $this->registerClass(RandReturnTypeProvider::class);
         $this->registerClass(InArrayReturnTypeProvider::class);
+        $this->registerClass(RoundReturnTypeProvider::class);
     }
 
     /**
diff --git a/src/Psalm/Internal/Provider/ReturnTypeProvider/RoundReturnTypeProvider.php b/src/Psalm/Internal/Provider/ReturnTypeProvider/RoundReturnTypeProvider.php
new file mode 100644
index 000000000..eb8ee561f
--- /dev/null
+++ b/src/Psalm/Internal/Provider/ReturnTypeProvider/RoundReturnTypeProvider.php
@@ -0,0 +1,78 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Psalm\Internal\Provider\ReturnTypeProvider;
+
+use Psalm\Internal\Analyzer\StatementsAnalyzer;
+use Psalm\Plugin\EventHandler\Event\FunctionReturnTypeProviderEvent;
+use Psalm\Plugin\EventHandler\FunctionReturnTypeProviderInterface;
+use Psalm\Type;
+
+use function array_values;
+use function count;
+use function round;
+
+use const PHP_ROUND_HALF_UP;
+
+/**
+ * @internal
+ */
+class RoundReturnTypeProvider implements FunctionReturnTypeProviderInterface
+{
+    /**
+     * @return array<lowercase-string>
+     */
+    public static function getFunctionIds(): array
+    {
+        return ['round'];
+    }
+
+    public static function getFunctionReturnType(FunctionReturnTypeProviderEvent $event): ?Type\Union
+    {
+        $call_args = $event->getCallArgs();
+        if (count($call_args) === 0) {
+            return null;
+        }
+
+        $statements_source = $event->getStatementsSource();
+        $nodeTypeProvider = $statements_source->getNodeTypeProvider();
+
+        $num_arg = $nodeTypeProvider->getType($call_args[0]->value);
+
+        $precision_val = 0;
+        if ($statements_source instanceof StatementsAnalyzer && count($call_args) > 1) {
+            $type = $statements_source->node_data->getType($call_args[1]->value);
+
+            if ($type !== null && $type->isSingle()) {
+                $atomic_type = array_values($type->getAtomicTypes())[0];
+                if ($atomic_type instanceof Type\Atomic\TLiteralInt) {
+                    $precision_val = $atomic_type->value;
+                }
+            }
+        }
+
+        $mode_val = PHP_ROUND_HALF_UP;
+        if ($statements_source instanceof StatementsAnalyzer && count($call_args) > 2) {
+            $type = $statements_source->node_data->getType($call_args[2]->value);
+
+            if ($type !== null && $type->isSingle()) {
+                $atomic_type = array_values($type->getAtomicTypes())[0];
+                if ($atomic_type instanceof Type\Atomic\TLiteralInt) {
+                    /** @var positive-int|0 $mode_val */
+                    $mode_val = $atomic_type->value;
+                }
+            }
+        }
+
+        if ($num_arg !== null && $num_arg->isSingle()) {
+            $num_type = array_values($num_arg->getAtomicTypes())[0];
+            if ($num_type instanceof Type\Atomic\TLiteralFloat || $num_type instanceof Type\Atomic\TLiteralInt) {
+                $rounded_val = round($num_type->value, $precision_val, $mode_val);
+                return new Type\Union([new Type\Atomic\TLiteralFloat($rounded_val)]);
+            }
+        }
+
+        return new Type\Union([new Type\Atomic\TFloat()]);
+    }
+}
diff --git a/tests/FunctionCallTest.php b/tests/FunctionCallTest.php
index e57a1d432..9b457ce60 100644
--- a/tests/FunctionCallTest.php
+++ b/tests/FunctionCallTest.php
@@ -31,7 +31,6 @@ class FunctionCallTest extends TestCase
                   }
                 '
             ],
-
             'typedArrayWithDefault' => [
                 '<?php
                     class A {}
@@ -1812,6 +1811,14 @@ class FunctionCallTest extends TestCase
                     '$b===' => 'lowercase-string',
                 ],
             ],
+            'round_literalValue' => [
+                '<?php
+                    $a = round(10.363, 2);
+                ',
+                'assertions' => [
+                    '$a===' => 'float(10.36)',
+                ],
+            ],
         ];
     }
 
diff --git a/tests/TypeReconciliation/ValueTest.php b/tests/TypeReconciliation/ValueTest.php
index b5963ac41..cda147673 100644
--- a/tests/TypeReconciliation/ValueTest.php
+++ b/tests/TypeReconciliation/ValueTest.php
@@ -909,6 +909,14 @@ class ValueTest extends TestCase
                     $interval = \DateInterval::createFromDateString("30 дней");
                     if ($interval === false) {}',
             ],
+            'literalInt' => [
+                '<?php
+                    $a = (int)"5";
+                ',
+                'assertions' => [
+                    '$a===' => '5',
+                ],
+            ],
         ];
     }
 
