diff --git a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
index 175fc6423..3985ec6f8 100644
--- a/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
+++ b/src/Psalm/Internal/Analyzer/Statements/Expression/CallAnalyzer.php
@@ -3,7 +3,6 @@
 namespace Psalm\Internal\Analyzer\Statements\Expression;
 
 use PhpParser;
-use PhpParser\Node\Expr\BinaryOp\NotIdentical;
 use PhpParser\Node\Identifier;
 use PhpParser\Node\Name;
 use Psalm\CodeLocation;
@@ -38,7 +37,6 @@ use Psalm\Node\Expr\VirtualConstFetch;
 use Psalm\Node\VirtualName;
 use Psalm\Storage\Assertion\Falsy;
 use Psalm\Storage\Assertion\IsIdentical;
-use Psalm\Storage\Assertion\IsLooselyEqual;
 use Psalm\Storage\Assertion\IsType;
 use Psalm\Storage\Assertion\Truthy;
 use Psalm\Storage\ClassLikeStorage;
@@ -58,7 +56,6 @@ use function array_merge;
 use function array_unique;
 use function count;
 use function explode;
-use function get_class;
 use function implode;
 use function in_array;
 use function is_int;
@@ -779,8 +776,8 @@ class CallAnalyzer
                                 $orred_rules[] = $assertion_rule;
                             }
                         } elseif (isset($context->vars_in_scope[$assertion_var_id])) {
+                            $asserted_type = $context->vars_in_scope[$assertion_var_id];
                             if ($assertion_rule instanceof IsIdentical) {
-                                $asserted_type = $context->vars_in_scope[$assertion_var_id];
                                 $intersection = Type::intersectUnionTypes($assertion_type, $asserted_type, $codebase);
 
                                 if ($intersection === null) {
@@ -793,6 +790,8 @@ class CallAnalyzer
                                         $statements_analyzer->getSuppressedIssues()
                                     );
                                     $intersection = Type::getNever();
+                                } elseif ($intersection->getId(true) === $asserted_type->getId(true)) {
+                                    continue;
                                 }
                                 foreach ($intersection->getAtomicTypes() as $atomic_type) {
                                     if ($assertion_type_atomic instanceof TTemplateParam
@@ -805,14 +804,23 @@ class CallAnalyzer
                                     $assertion_rule->setAtomicType($atomic_type);
                                     $orred_rules[] = $assertion_rule;
                                 }
+                            } elseif ($assertion_rule instanceof IsType) {
+                                if (!UnionTypeComparator::canExpressionTypesBeIdentical(
+                                    $codebase,
+                                    $assertion_type,
+                                    $asserted_type
+                                )) {
+                                    IssueBuffer::maybeAdd(
+                                        new TypeDoesNotContainType(
+                                            $asserted_type->getId() . ' is not contained by ' . $assertion_type->getId(),
+                                            new CodeLocation($statements_analyzer->getSource(), $expr),
+                                            $asserted_type->getId() . ' ' . $assertion_type->getId()
+                                        ),
+                                        $statements_analyzer->getSuppressedIssues()
+                                    );
+                                }
                             } else {
-                                IssueBuffer::maybeAdd(
-                                    new InvalidArgument(
-                                        "Cannot use ".get_class($assertion_rule)." assertion with assertion union type ".$assertion_type->getId(true).", try inverting the assertion and asserted types",
-                                        new CodeLocation($statements_analyzer->getSource(), $expr),
-                                    ),
-                                    $statements_analyzer->getSuppressedIssues()
-                                );
+                                // Ignore negations and loose assertions with union types
                             }
                         }
                     } else {
@@ -1136,82 +1144,4 @@ class CallAnalyzer
             }
         }
     }
-
-    /**
-     * This method should detect if the new type narrows down the old type.
-     */
-    private static function isNewTypeNarrowingDownOldType(Union $old_type, Union $new_type): bool
-    {
-        if ($new_type->isSingle()) {
-            return true;
-        }
-
-        // non-mixed is always better than mixed
-        if ($old_type->isMixed() && !$new_type->hasMixed()) {
-            return true;
-        }
-
-        // non-nullable is always better than nullable
-        if ($old_type->isNullable() && !$new_type->isNullable()) {
-            return true;
-        }
-
-        // Do not hassle around with non-single old types if they are not nullable
-        if (!$old_type->isSingle()) {
-            return false;
-        }
-
-        // Do not hassle around with single literals as they supposed to be more accurate than any new type assertion
-        if ($old_type->isSingleFloatLiteral()
-            || $old_type->isSingleIntLiteral()
-            || $old_type->isSingleStringLiteral()
-        ) {
-            return false;
-        }
-
-        // Literals should always replace non-literals
-        if (($old_type->isString() && $new_type->allStringLiterals())
-            || ($old_type->isInt() && $new_type->allIntLiterals())
-            || ($old_type->isFloat() && $new_type->allFloatLiterals())
-        ) {
-            return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * This method should kick all literals within `new_type` which are not part of the already known `old_type`.
-     * So lets say we already know that the old type is one of "a", "b" or "c".
-     * If another assertion takes place to determine if the value is either "a", "c" or "d", we can kick "d" as that
-     * won't be possible.
-     */
-    private static function createUnionIntersectionFromOldType(Union $new_type, Union $old_type): ?Union
-    {
-        if (!self::isNewTypeNarrowingDownOldType($old_type, $new_type)) {
-            return null;
-        }
-
-        if (!$new_type->allLiterals() || !$old_type->allLiterals()) {
-            return $new_type;
-        }
-
-        $equal_atomic_types = [];
-
-        foreach ($new_type->getAtomicTypes() as $new_atomic_type) {
-            foreach ($old_type->getAtomicTypes() as $old_atomic_type) {
-                if (!$new_atomic_type->equals($old_atomic_type, false)) {
-                    continue;
-                }
-
-                $equal_atomic_types[] = $new_atomic_type;
-            }
-        }
-
-        if ($equal_atomic_types === []) {
-            return null;
-        }
-
-        return new Union($equal_atomic_types);
-    }
 }
diff --git a/src/Psalm/Type/Atomic/TLiteralFloat.php b/src/Psalm/Type/Atomic/TLiteralFloat.php
index 2608a4efe..4e1146830 100644
--- a/src/Psalm/Type/Atomic/TLiteralFloat.php
+++ b/src/Psalm/Type/Atomic/TLiteralFloat.php
@@ -2,10 +2,6 @@
 
 namespace Psalm\Type\Atomic;
 
-use Psalm\Type\Atomic;
-
-use function get_class;
-
 /**
  * Denotes a floating point value where the exact numeric value is known.
  */
diff --git a/src/Psalm/Type/Atomic/TLiteralInt.php b/src/Psalm/Type/Atomic/TLiteralInt.php
index 50aa92989..390606ebb 100644
--- a/src/Psalm/Type/Atomic/TLiteralInt.php
+++ b/src/Psalm/Type/Atomic/TLiteralInt.php
@@ -2,10 +2,6 @@
 
 namespace Psalm\Type\Atomic;
 
-use Psalm\Type\Atomic;
-
-use function get_class;
-
 /**
  * Denotes an integer value where the exact numeric value is known.
  */
diff --git a/src/Psalm/Type/Atomic/TLiteralString.php b/src/Psalm/Type/Atomic/TLiteralString.php
index 1a3925cfc..71ae7f735 100644
--- a/src/Psalm/Type/Atomic/TLiteralString.php
+++ b/src/Psalm/Type/Atomic/TLiteralString.php
@@ -2,10 +2,7 @@
 
 namespace Psalm\Type\Atomic;
 
-use Psalm\Type\Atomic;
-
 use function addcslashes;
-use function get_class;
 use function mb_strlen;
 use function mb_substr;
 
diff --git a/tests/ArrayAssignmentTest.php b/tests/ArrayAssignmentTest.php
index 377886620..9bd257564 100644
--- a/tests/ArrayAssignmentTest.php
+++ b/tests/ArrayAssignmentTest.php
@@ -1758,6 +1758,40 @@ class ArrayAssignmentTest extends TestCase
                     $c = new C();
                     $c[] = "hello";'
             ],
+            'conditionalRestrictedDocblockKeyAssignment' => [
+                'code' => '<?php
+
+
+                /**
+                 * @return array{booking: array{active: false, icon: "settings"}, phones: array{active: false, icon: "phone-tube"}, stat: array{active: false, icon: "review"}, support: array{active: false, icon: "help"}}
+                 */
+                function getSections(): array {
+                    return [
+                            "phones" => [
+                                "active" => false,
+                                "icon" => "phone-tube",
+                            ],
+                            "stat" => [
+                                "active" => false,
+                                "icon" => "review",
+                            ],
+                            "booking" => [
+                                "active" => false,
+                                "icon" => "settings",
+                            ],
+                            "support" => [
+                                "active" => false,
+                                "icon" => "help",
+                            ],
+                    ];
+                }
+                $items = getSections();
+                /** @var string */
+                $currentAction = "";
+                if (\array_key_exists($currentAction, $items)) {
+                    $items[$currentAction]["active"] = true;
+                }'
+            ]
         ];
     }
 
diff --git a/tests/Template/FunctionTemplateAssertTest.php b/tests/Template/FunctionTemplateAssertTest.php
index 9d2d20988..e3c8f5e28 100644
--- a/tests/Template/FunctionTemplateAssertTest.php
+++ b/tests/Template/FunctionTemplateAssertTest.php
@@ -167,7 +167,7 @@ class FunctionTemplateAssertTest extends TestCase
                      *
                      * @param mixed $value
                      * @param class-string<T> $type
-                     * 
+                     *
                      * @psalm-assert T $value
                      */
                     function assertInstanceOf($value, string $type): void {
@@ -1089,6 +1089,23 @@ class FunctionTemplateAssertTest extends TestCase
                     assertEqual($c, $d);',
                 'error_message' => 'TypeDoesNotContainType',
             ],
+            'assertTemplateUnionParadox' => [
+                'code' => '<?php
+                    /**
+                     * Asserts that two variables are not the same.
+                     *
+                     * @template T
+                     * @param T      $expected
+                     * @param mixed  $actual
+                     * @psalm-assert T $actual
+                     */
+                    function assertSame($expected, $actual) : void {}
+
+                    $expected = rand(0, 1) ? 4 : 5;
+                    $actual = 6;
+                    assertSame($expected, $actual);',
+                'error_message' => 'TypeDoesNotContainType',
+            ],
             'assertNotSameDifferentTypes' => [
                 'code' => '<?php
                     /**
