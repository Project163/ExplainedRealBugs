diff --git a/yaml/src/main/java/com/fasterxml/jackson/dataformat/yaml/YAMLParser.java b/yaml/src/main/java/com/fasterxml/jackson/dataformat/yaml/YAMLParser.java
index 978b2d82..3b446c81 100644
--- a/yaml/src/main/java/com/fasterxml/jackson/dataformat/yaml/YAMLParser.java
+++ b/yaml/src/main/java/com/fasterxml/jackson/dataformat/yaml/YAMLParser.java
@@ -117,6 +117,12 @@ public class YAMLParser extends ParserBase
      */
     protected String _textValue;
 
+    /**
+     * For some tokens (specifically, numbers), we'll have cleaned up version,
+     * mostly free of underscores
+     */
+    protected String _cleanedTextValue;
+    
     /**
      * Let's also have a local copy of the current field name
      */
@@ -426,6 +432,7 @@ public class YAMLParser extends ParserBase
                 AliasEvent alias = (AliasEvent) evt;
                 _currentIsAlias = true;
                 _textValue = alias.getAnchor();
+                _cleanedTextValue = null;
                 // for now, nothing to do: in future, maybe try to expose as ObjectIds?
                 return (_currToken = JsonToken.VALUE_STRING);
             }
@@ -443,6 +450,7 @@ public class YAMLParser extends ParserBase
     {
         String value = scalar.getValue();
         _textValue = value;
+        _cleanedTextValue = null;
         // we may get an explicit tag, if so, use for corroborating...
         String typeTag = scalar.getTag();
         final int len = value.length();
@@ -457,7 +465,7 @@ public class YAMLParser extends ParserBase
             }
             if (nodeTag == Tag.FLOAT) {
                 _numTypesValid = 0;
-                return JsonToken.VALUE_NUMBER_FLOAT;
+                return _cleanYamlFloat(value);
             }
             if (nodeTag == Tag.BOOL) {
                 Boolean B = _matchYAMLBoolean(value, len);
@@ -497,13 +505,17 @@ public class YAMLParser extends ParserBase
                 if (B != null) {
                     return B ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;
                 }
-            } else if ("int".equals(typeTag)) {
-                return _decodeNumberScalar(value, len);
-            } else if ("float".equals(typeTag)) {
-                _numTypesValid = 0;
-                return JsonToken.VALUE_NUMBER_FLOAT;
-            } else if ("null".equals(typeTag)) {
-                return JsonToken.VALUE_NULL;
+            } else {
+                if ("int".equals(typeTag)) {
+                    return _decodeNumberScalar(value, len);
+                }
+                if ("float".equals(typeTag)) {
+                    _numTypesValid = 0;
+                    return _cleanYamlFloat(value);
+                }
+                if ("null".equals(typeTag)) {
+                    return JsonToken.VALUE_NULL;
+                }
             }
         }
         
@@ -551,29 +563,47 @@ public class YAMLParser extends ParserBase
          */
         //if (PATTERN_INT.matcher(value).matches()) {
         int i;
-        if (value.charAt(0) == '-') {
+        char sign = value.charAt(0);
+        if (sign == '-') {
             _numberNegative = true;
+            if (len == 1) {
+                return null;
+            }
             i = 1;
+        } else if (sign == '+') {
+            _numberNegative = false;
             if (len == 1) {
                 return null;
             }
+            i = 1;
         } else {
             _numberNegative = false;
             i = 0;
         }
+        // !!! 11-Jan-2018, tatu: Should check for binary/octal/hex/sexagesimal
+        //    as per http://yaml.org/type/int.html
+
+        int underscores = 0;
         while (true) {
             int c = value.charAt(i);
             if (c > '9' || c < '0') {
-                break;
+                if (c != '_') {
+                    break;
+                }
+                ++underscores;
             }
             if (++i == len) {
                 _numTypesValid = 0;
+                if (underscores > 0) {
+                    return _cleanYamlInt(_textValue);
+                }
+                _cleanedTextValue = _textValue;
                 return JsonToken.VALUE_NUMBER_INT;
             }
         }
         if (PATTERN_FLOAT.matcher(value).matches()) {
             _numTypesValid = 0;
-            return JsonToken.VALUE_NUMBER_FLOAT;
+            return _cleanYamlFloat(_textValue);
         }
         
         // 25-Aug-2016, tatu: If we can't actually match it to valid number,
@@ -581,6 +611,11 @@ public class YAMLParser extends ParserBase
         return JsonToken.VALUE_STRING;
     }   
 
+    protected JsonToken _decodeIntWithUnderscores(String value, final int len)
+    {
+        return JsonToken.VALUE_NUMBER_INT;
+    }
+    
     /*
     /**********************************************************
     /* String value handling
@@ -694,7 +729,7 @@ public class YAMLParser extends ParserBase
                 return;
             }
             if (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls
-                long l = Long.parseLong(_textValue);
+                long l = Long.parseLong(_cleanedTextValue);
                 // [JACKSON-230] Could still fit in int, need to check
                 if (len == 10) {
                     if (_numberNegative) {
@@ -717,7 +752,7 @@ public class YAMLParser extends ParserBase
             }
             // !!! TODO: implement proper bounds checks; now we'll just use BigInteger for convenience
             try {
-                BigInteger n = new BigInteger(_textValue);
+                BigInteger n = new BigInteger(_cleanedTextValue);
                 // Could still fit in a long, need to check
                 if (len == 19 && n.bitLength() <= 63) {
                     _numberLong = n.longValue();
@@ -728,13 +763,14 @@ public class YAMLParser extends ParserBase
                 _numTypesValid = NR_BIGINT;
                 return;
             } catch (NumberFormatException nex) {
+                // NOTE: pass non-cleaned variant for error message
                 // Can this ever occur? Due to overflow, maybe?
                 _wrapError("Malformed numeric value '"+_textValue+"'", nex);
             }
         }
         if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {
-            // related to [Issue-4]: strip out optional underscores, if any:
-            String str = _cleanYamlDouble(_textValue);
+            // strip out optional underscores, if any:
+            final String str = _cleanedTextValue;
             try {
                 if (expType == NR_BIGDECIMAL) {
                     _numberBigDecimal = new BigDecimal(str);
@@ -746,7 +782,8 @@ public class YAMLParser extends ParserBase
                 }
             } catch (NumberFormatException nex) {
                 // Can this ever occur? Due to overflow, maybe?
-                _wrapError("Malformed numeric value '"+str+"'", nex);
+                // NOTE: pass non-cleaned variant for error message
+                _wrapError("Malformed numeric value '"+_textValue+"'", nex);
             }
             return;
         }
@@ -757,13 +794,13 @@ public class YAMLParser extends ParserBase
     protected int _parseIntValue() throws IOException
     {
         if (_currToken == JsonToken.VALUE_NUMBER_INT) {
-            int len = _textValue.length();
+            int len = _cleanedTextValue.length();
             if (_numberNegative) {
                 len--;
             }
             if (len <= 9) { // definitely fits in int
                 _numTypesValid = NR_INT;
-                return (_numberInt = Integer.parseInt(_textValue));
+                return (_numberInt = Integer.parseInt(_cleanedTextValue));
             }
         }
         _parseNumericValue(NR_INT);
@@ -830,12 +867,31 @@ public class YAMLParser extends ParserBase
      * using standard JDK classes.
      * Currently this just means stripping out optional underscores.
      */
-    private String _cleanYamlDouble(String str)
+    private JsonToken _cleanYamlInt(String str)
     {
+        // Here we already know there is either plus sign, or underscore (or both) so
+        final int len = str.length();
+        StringBuilder sb = new StringBuilder(len);
+        // first: do we have a leading plus sign to skip?
+        int i = (str.charAt(0) == '+') ? 1 : 0;
+        for (; i < len; ++i) {
+            char c = str.charAt(i);
+            if (c != '_') {
+                sb.append(c);
+            }
+        }
+        _cleanedTextValue = sb.toString();
+        return JsonToken.VALUE_NUMBER_INT;
+    }
+
+    private JsonToken _cleanYamlFloat(String str)
+    {
+        // Here we do NOT yet know whether we might have underscores so check
         final int len = str.length();
         int ix = str.indexOf('_');
         if (ix < 0 || len == 0) {
-            return str;
+            _cleanedTextValue = str;
+            return JsonToken.VALUE_NUMBER_FLOAT;
         }
         StringBuilder sb = new StringBuilder(len);
         // first: do we have a leading plus sign to skip?
@@ -846,6 +902,7 @@ public class YAMLParser extends ParserBase
                 sb.append(c);
             }
         }
-        return sb.toString();
+        _cleanedTextValue = sb.toString();
+        return JsonToken.VALUE_NUMBER_FLOAT;
     }
 }
diff --git a/yaml/src/test/java/com/fasterxml/jackson/dataformat/yaml/deser/SimpleParseTest.java b/yaml/src/test/java/com/fasterxml/jackson/dataformat/yaml/deser/StreamingParseTest.java
similarity index 72%
rename from yaml/src/test/java/com/fasterxml/jackson/dataformat/yaml/deser/SimpleParseTest.java
rename to yaml/src/test/java/com/fasterxml/jackson/dataformat/yaml/deser/StreamingParseTest.java
index 1b4ce3df..17c2c20b 100644
--- a/yaml/src/test/java/com/fasterxml/jackson/dataformat/yaml/deser/SimpleParseTest.java
+++ b/yaml/src/test/java/com/fasterxml/jackson/dataformat/yaml/deser/StreamingParseTest.java
@@ -13,7 +13,7 @@ import java.math.BigInteger;
  * Unit tests for checking functioning of the underlying
  * parser implementation.
  */
-public class SimpleParseTest extends ModuleTestBase
+public class StreamingParseTest extends ModuleTestBase
 {
     final YAMLFactory YAML_F = new YAMLFactory();
 
@@ -57,9 +57,10 @@ public class SimpleParseTest extends ModuleTestBase
         assertNull(p.nextToken());
         assertNull(p.nextToken());
         p.close();
-    }    
+    }
+
     // Parsing large numbers around the transition from int->long and long->BigInteger
-    public void testIntParsing() throws Exception
+    public void testIntParsingWithLimits() throws Exception
     {
         String YAML;
         JsonParser p;
@@ -161,6 +162,143 @@ public class SimpleParseTest extends ModuleTestBase
         p.close();
     }
 
+    // Testing addition of underscores
+    public void testIntParsingUnderscoresSm() throws Exception
+    {
+        // First, couple of simple small values
+        try (JsonParser p = YAML_F.createParser("num: 10_345")) {
+            assertToken(JsonToken.START_OBJECT, p.nextToken());
+            assertToken(JsonToken.FIELD_NAME, p.nextToken());
+            assertEquals("num", p.getCurrentName());
+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+            assertEquals(10345, p.getIntValue());
+            assertEquals(JsonParser.NumberType.INT, p.getNumberType());
+            assertEquals("10_345", p.getText());
+            assertToken(JsonToken.END_OBJECT, p.nextToken());
+        }
+
+        try (JsonParser p = YAML_F.createParser("num: -11_222")) {
+            assertToken(JsonToken.START_OBJECT, p.nextToken());
+            assertToken(JsonToken.FIELD_NAME, p.nextToken());
+            assertEquals("num", p.getCurrentName());
+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+            assertEquals(-11222, p.getIntValue());
+            assertEquals(JsonParser.NumberType.INT, p.getNumberType());
+            assertEquals("-11_222", p.getText());
+            assertToken(JsonToken.END_OBJECT, p.nextToken());
+        }
+
+        try (JsonParser p = YAML_F.createParser("num: +8_192")) {
+            assertToken(JsonToken.START_OBJECT, p.nextToken());
+            assertToken(JsonToken.FIELD_NAME, p.nextToken());
+            assertEquals("num", p.getCurrentName());
+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+            assertEquals(8192, p.getIntValue());
+            assertEquals(JsonParser.NumberType.INT, p.getNumberType());
+            assertEquals("+8_192", p.getText());
+            assertToken(JsonToken.END_OBJECT, p.nextToken());
+        }
+
+        String YAML;
+        JsonParser p;
+
+        // Test positive max-int
+        YAML = "num: 2_147_483_647";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(Integer.MAX_VALUE, p.getIntValue());
+        assertEquals(JsonParser.NumberType.INT, p.getNumberType());
+        assertEquals("2_147_483_647", p.getText());
+        p.close();
+
+        // Test negative max-int
+        YAML = "num: -2_147_483_648";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(Integer.MIN_VALUE, p.getIntValue());
+        assertEquals(JsonParser.NumberType.INT, p.getNumberType());
+        assertEquals("-2_147_483_648", p.getText());
+        p.close();
+
+        // Test positive max-int + 1
+        YAML = "num: 2_147_483_648";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(Integer.MAX_VALUE + 1L, p.getLongValue());
+        assertEquals(JsonParser.NumberType.LONG, p.getNumberType());
+        assertEquals("2_147_483_648", p.getText());
+        p.close();
+
+        // Test negative max-int - 1
+        YAML = "num: -2_147_483_649";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(Integer.MIN_VALUE - 1L, p.getLongValue());
+        assertEquals(JsonParser.NumberType.LONG, p.getNumberType());
+        assertEquals("-2_147_483_649", p.getText());
+        p.close();
+
+        // Test positive max-long
+        YAML = "num: 9_223_372_036_854_775_807";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(Long.MAX_VALUE, p.getLongValue());
+        assertEquals(JsonParser.NumberType.LONG, p.getNumberType());
+        assertEquals("9_223_372_036_854_775_807", p.getText());
+        p.close();
+
+        // Test negative max-long
+        YAML = "num: -9_223_372_036_854_775_808";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(Long.MIN_VALUE, p.getLongValue());
+        assertEquals(JsonParser.NumberType.LONG, p.getNumberType());
+        assertEquals("-9_223_372_036_854_775_808", p.getText());
+        p.close();
+
+        // Test positive max-long + 1
+        YAML = "num: 9_223372036854775_808";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE), p.getBigIntegerValue());
+        assertEquals(JsonParser.NumberType.BIG_INTEGER, p.getNumberType());
+        assertEquals("9_223372036854775_808", p.getText());
+        p.close();
+
+        // Test negative max-long - 1
+        YAML = "num: -92233_72036_85477_5809";
+        p = YAML_F.createParser(YAML);
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken());
+        assertEquals("num", p.getCurrentName());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals(BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE), p.getBigIntegerValue());
+        assertEquals(JsonParser.NumberType.BIG_INTEGER, p.getNumberType());
+        assertEquals("-92233_72036_85477_5809", p.getText());
+        p.close();
+    }
+
     // [cbor#4]: accidental recognition as double, with multiple dots
     public void testDoubleParsing() throws Exception
     {
