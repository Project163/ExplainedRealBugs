diff --git a/guava-tests/test/com/google/common/hash/BloomFilterTest.java b/guava-tests/test/com/google/common/hash/BloomFilterTest.java
index 571bb27a41..f28c239029 100644
--- a/guava-tests/test/com/google/common/hash/BloomFilterTest.java
+++ b/guava-tests/test/com/google/common/hash/BloomFilterTest.java
@@ -53,6 +53,14 @@ public class BloomFilterTest extends TestCase {
     // BloomFilter.create(Funnels.unencodedCharsFunnel(), 244412641, 1e-11);
   }
 
+  /**
+   * Asserts that {@link BloomFilter#approximateCount} is within 1 percent of the expected value.
+   */
+  private static void assertApproximateCountGuess(BloomFilter<?> bf, int sizeGuess) {
+    assertThat(bf.approximateCount()).isAtLeast((long) (sizeGuess * 0.99));
+    assertThat(bf.approximateCount()).isAtMost((long) (sizeGuess * 1.01));
+  }
+
   public void testCreateAndCheckMitz32BloomFilterWithKnownFalsePositives() {
     int numInsertions = 1000000;
     BloomFilter<String> bf = BloomFilter.create(
@@ -63,6 +71,7 @@ public class BloomFilterTest extends TestCase {
     for (int i = 0; i < numInsertions * 2; i += 2) {
       bf.put(Integer.toString(i));
     }
+    assertApproximateCountGuess(bf, numInsertions);
 
     // Assert that the BF "might" have all of the even numbers.
     for (int i = 0; i < numInsertions * 2; i += 2) {
@@ -104,6 +113,7 @@ public class BloomFilterTest extends TestCase {
     for (int i = 0; i < numInsertions * 2; i += 2) {
       bf.put(Integer.toString(i));
     }
+    assertApproximateCountGuess(bf, numInsertions);
 
     // Assert that the BF "might" have all of the even numbers.
     for (int i = 0; i < numInsertions * 2; i += 2) {
@@ -145,6 +155,7 @@ public class BloomFilterTest extends TestCase {
     for (int i = 0; i < numInsertions * 2; i += 2) {
       bf.put(Integer.toString(i));
     }
+    assertApproximateCountGuess(bf, numInsertions);
 
     // Assert that the BF "might" have all of the even numbers.
     for (int i = 0; i < numInsertions * 2; i += 2) {
@@ -273,7 +284,7 @@ public class BloomFilterTest extends TestCase {
     unused = BloomFilter.create(Funnels.unencodedCharsFunnel(), 45L * Integer.MAX_VALUE, 0.99);
   }
 
-  private void checkSanity(BloomFilter<Object> bf) {
+  private static void checkSanity(BloomFilter<Object> bf) {
     assertFalse(bf.mightContain(new Object()));
     assertFalse(bf.apply(new Object()));
     for (int i = 0; i < 100; i++) {
@@ -317,6 +328,16 @@ public class BloomFilterTest extends TestCase {
     }
   }
 
+  public void testApproximateCount() {
+    int numInsertions = 1000;
+    BloomFilter<Integer> bf = BloomFilter.create(Funnels.integerFunnel(), numInsertions);
+    bf.put(-1);
+    for (int i = 0; i < numInsertions; i++) {
+      bf.put(i);
+    }
+    assertApproximateCountGuess(bf, numInsertions);
+  }
+
   public void testEquals_empty() {
     new EqualsTester()
         .addEqualityGroup(BloomFilter.create(Funnels.byteArrayFunnel(), 100, 0.01))
diff --git a/guava/src/com/google/common/hash/BloomFilter.java b/guava/src/com/google/common/hash/BloomFilter.java
index 2f4342595e..601a2db62a 100644
--- a/guava/src/com/google/common/hash/BloomFilter.java
+++ b/guava/src/com/google/common/hash/BloomFilter.java
@@ -22,6 +22,7 @@ import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Objects;
 import com.google.common.base.Predicate;
 import com.google.common.hash.BloomFilterStrategies.BitArray;
+import com.google.common.math.DoubleMath;
 import com.google.common.primitives.SignedBytes;
 import com.google.common.primitives.UnsignedBytes;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -31,6 +32,7 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.Serializable;
+import java.math.RoundingMode;
 import javax.annotation.Nullable;
 
 /**
@@ -38,18 +40,18 @@ import javax.annotation.Nullable;
  * with one-sided error: if it claims that an element is contained in it, this might be in error,
  * but if it claims that an element is <i>not</i> contained in it, then this is definitely true.
  *
- * <p>If you are unfamiliar with Bloom filters, this nice
- * <a href="http://llimllib.github.com/bloomfilter-tutorial/">tutorial</a> may help you understand
- * how they work.
+ * <p>If you are unfamiliar with Bloom filters, this nice <a
+ * href="http://llimllib.github.com/bloomfilter-tutorial/">tutorial</a> may help you understand how
+ * they work.
  *
- * <p>The false positive probability ({@code FPP}) of a bloom filter is defined as the probability
+ * <p>The false positive probability ({@code FPP}) of a Bloom filter is defined as the probability
  * that {@linkplain #mightContain(Object)} will erroneously return {@code true} for an object that
  * has not actually been put in the {@code BloomFilter}.
  *
  * <p>Bloom filters are serializable. They also support a more compact serial representation via the
  * {@link #writeTo} and {@link #readFrom} methods. Both serialized forms will continue to be
  * supported by future versions of this library. However, serial forms generated by newer versions
- * of the code may not be readable by older versions of the code (e.g., a serialized bloom filter
+ * of the code may not be readable by older versions of the code (e.g., a serialized Bloom filter
  * generated today may <i>not</i> be readable by a binary that was compiled 6 months ago).
  *
  * @param <T> the type of instances that the {@code BloomFilter} accepts
@@ -150,7 +152,7 @@ public final class BloomFilter<T> implements Predicate<T>, Serializable {
    * Puts an element into this {@code BloomFilter}. Ensures that subsequent invocations of {@link
    * #mightContain(Object)} with the same element will always return {@code true}.
    *
-   * @return true if the bloom filter's bits changed as a result of this operation. If the bits
+   * @return true if the Bloom filter's bits changed as a result of this operation. If the bits
    *     changed, this is <i>definitely</i> the first time {@code object} has been added to the
    *     filter. If the bits haven't changed, this <i>might</i> be the first time {@code object} has
    *     been added to the filter. Note that {@code put(t)} always returns the <i>opposite</i>
@@ -178,6 +180,28 @@ public final class BloomFilter<T> implements Predicate<T>, Serializable {
     return Math.pow((double) bits.bitCount() / bitSize(), numHashFunctions);
   }
 
+  /**
+   * Returns an estimate for the total number of distinct elements that have been added to this
+   * Bloom filter. This approximation is reasonably accurate if it does not exceed the value of
+   * {@code expectedInsertions} that was used when constructing the filter.
+   *
+   * @since 22.0
+   */
+  public long approximateCount() {
+    long bitSize = bits.bitSize();
+    long bitCount = bits.bitCount();
+
+    /**
+     * Each insertion is expected to reduce the # of clear bits by a factor of
+     * `numHashFunctions/bitSize`. So, after n insertions, expected bitCount is `bitSize * (1 - (1 -
+     * numHashFunctions/bitSize)^n)`. Solving that for n, and approximating `ln x` as `x - 1` when x
+     * is close to 1 (why?), gives the following formula.
+     */
+    double fractionOfBitsSet = (double) bitCount / bitSize;
+    return DoubleMath.roundToLong(
+        -Math.log1p(-fractionOfBitsSet) * bitSize / numHashFunctions, RoundingMode.HALF_UP);
+  }
+
   /**
    * Returns the number of bits in the underlying bit array.
    */
@@ -187,18 +211,18 @@ public final class BloomFilter<T> implements Predicate<T>, Serializable {
   }
 
   /**
-   * Determines whether a given bloom filter is compatible with this bloom filter. For two bloom
+   * Determines whether a given Bloom filter is compatible with this Bloom filter. For two Bloom
    * filters to be compatible, they must:
    *
    * <ul>
-   * <li>not be the same instance
-   * <li>have the same number of hash functions
-   * <li>have the same bit size
-   * <li>have the same strategy
-   * <li>have equal funnels
-   * <ul>
-   *
-   * @param that The bloom filter to check for compatibility.
+   *   <li>not be the same instance
+   *   <li>have the same number of hash functions
+   *   <li>have the same bit size
+   *   <li>have the same strategy
+   *   <li>have equal funnels
+   *       <ul>
+   *
+   * @param that The Bloom filter to check for compatibility.
    * @since 15.0
    */
   public boolean isCompatible(BloomFilter<T> that) {
@@ -211,13 +235,12 @@ public final class BloomFilter<T> implements Predicate<T>, Serializable {
   }
 
   /**
-   * Combines this bloom filter with another bloom filter by performing a bitwise OR of the
-   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the bloom
+   * Combines this Bloom filter with another Bloom filter by performing a bitwise OR of the
+   * underlying data. The mutations happen to <b>this</b> instance. Callers must ensure the Bloom
    * filters are appropriately sized to avoid saturating them.
    *
-   * @param that The bloom filter to combine this bloom filter with. It is not mutated.
+   * @param that The Bloom filter to combine this Bloom filter with. It is not mutated.
    * @throws IllegalArgumentException if {@code isCompatible(that) == false}
-   *
    * @since 15.0
    */
   public void putAll(BloomFilter<T> that) {
