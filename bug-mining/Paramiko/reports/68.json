{"url":"https://api.github.com/repos/paramiko/paramiko/issues/1175","repository_url":"https://api.github.com/repos/paramiko/paramiko","labels_url":"https://api.github.com/repos/paramiko/paramiko/issues/1175/labels{/name}","comments_url":"https://api.github.com/repos/paramiko/paramiko/issues/1175/comments","events_url":"https://api.github.com/repos/paramiko/paramiko/issues/1175/events","html_url":"https://github.com/paramiko/paramiko/issues/1175","id":304582845,"node_id":"MDU6SXNzdWUzMDQ1ODI4NDU=","number":1175,"title":"Server implementation does not check for auth before serving later requests","user":{"login":"bitprophet","id":6088,"node_id":"MDQ6VXNlcjYwODg=","avatar_url":"https://avatars.githubusercontent.com/u/6088?v=4","gravatar_id":"","url":"https://api.github.com/users/bitprophet","html_url":"https://github.com/bitprophet","followers_url":"https://api.github.com/users/bitprophet/followers","following_url":"https://api.github.com/users/bitprophet/following{/other_user}","gists_url":"https://api.github.com/users/bitprophet/gists{/gist_id}","starred_url":"https://api.github.com/users/bitprophet/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bitprophet/subscriptions","organizations_url":"https://api.github.com/users/bitprophet/orgs","repos_url":"https://api.github.com/users/bitprophet/repos","events_url":"https://api.github.com/users/bitprophet/events{/privacy}","received_events_url":"https://api.github.com/users/bitprophet/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":61259482,"node_id":"MDU6TGFiZWw2MTI1OTQ4Mg==","url":"https://api.github.com/repos/paramiko/paramiko/labels/High%20priority","name":"High priority","color":"f7c6c7","default":false,"description":null},{"id":120561399,"node_id":"MDU6TGFiZWwxMjA1NjEzOTk=","url":"https://api.github.com/repos/paramiko/paramiko/labels/Bug","name":"Bug","color":"a04040","default":false,"description":null},{"id":363568597,"node_id":"MDU6TGFiZWwzNjM1Njg1OTc=","url":"https://api.github.com/repos/paramiko/paramiko/labels/Security","name":"Security","color":"b60205","default":false,"description":null},{"id":544727935,"node_id":"MDU6TGFiZWw1NDQ3Mjc5MzU=","url":"https://api.github.com/repos/paramiko/paramiko/labels/Server","name":"Server","color":"bfd4f2","default":false,"description":null}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":10,"created_at":"2018-03-13T00:02:03Z","updated_at":"2018-08-30T15:07:00Z","closed_at":"2018-03-13T00:47:59Z","author_association":"MEMBER","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"What follows is a direct paste from a private gist used to workshop the issue a bit late last week; have completed tests/impl (from 1.17+) and will be pushing those shortly. (wanted the issue number set in stone first...:D)\r\n\r\nWe have a CVE for this issue: CVE-2018-7750.\r\n\r\n## Intro\r\n\r\nEmail from one Matthijs Kooijman ([@matthijskooijman](https://github.com/matthijskooijman/)) dated 2018.03.02 notes that Paramiko's server implementation may be connected to by clients that do not implement the auth step, and happily serves up commands/etc to such un-authed clients. He found that AsyncSSH (another Python lib that does not use Paramiko) has the same issue. Finally, he states the RFC is unclear as to whether this is purposeful.\r\n\r\nLet's double check both the RFCs and then our favorite reference implementation, OpenSSH.\r\n\r\nShould neither provide a useful clue, my gut says the server implementation should track whether we've sent `SSH_MSG_USERAUTH_SUCCESS` (99% sure we already do track this) and default to rejecting any connection-level messages (like `SSH_MSG_CHANNEL_OPEN` or `SSH_MSG_GLOBAL_REQUEST`) unless that flag is True.\r\n\r\n\r\n## RFC scan\r\n\r\ntl;dr it is indeed kinda vague, there are two kinda-disagreeing undercurrents, neither of which are ironclad:\r\n\r\n- It is _assumed_ that the connection protocol (which is where command exec occurs) runs on top of / after setting up, the transport (initial kex/handshake/etc) and auth (user auth) protocols.\r\n- The specific server implementation, and/or operator of an instantiation of such an implementation, has _significant leeway_ in how they implement and/or configure the server, re: when and how user-auth occurs.\r\n\r\nSpecifics:\r\n\r\n- RFC 4251 (protocol arch)\r\n    - [1](https://tools.ietf.org/html/rfc4251#section-1): pretty clear that the intent is that a user auth step always occurs, followed by a service request:\r\n    \r\n      > The client sends a service request once a secure transport layer\r\n      > connection has been established.  A second service request is sent after\r\n      > user authentication is complete.\r\n\r\n    - [4.3](https://tools.ietf.org/html/rfc4251#section-4.3): third bullet point re: policy issues that 'SHOULD' be addressed, highlights that auth specifics are up to the site/operator:\r\n    \r\n      > The authentication methods that are to be required by the server for\r\n      > each user.  The server's policy MAY require multiple authentication for\r\n      > some or all users.  The required algorithms MAY depend on the location\r\n      > from where the user is trying to gain access.\r\n\r\n    - [9.4.3](https://tools.ietf.org/html/rfc4251.html#section-9.4.3): this whole section arguably applies, but it's very vague. However it _seems_ to back up my hunch that at core, this is up to the server implementer and/or operator, e.g:\r\n    \r\n      > At the discretion of the implementers, this default policy may be along\r\n      > the lines of anything-goes where there are no restrictions placed upon\r\n      > users [...]\r\n\r\n- RFC 4252 (auth protocol)\r\n    - [4](https://tools.ietf.org/html/rfc4252.html#section-4): more vague implications that the server can do whatever it wants, e.g. the below quote about `none` auth implies the authors at least partly considered servers that intentionally don't care about auth at all (though the specific discussion is about the actual, explicit use of the `none` auth type message, which is distinct from \"did not submit auth at all\"):\r\n    \r\n      > The \"none\" method is reserved, and MUST NOT be listed as supported.\r\n      > However, it MAY be sent by the client.  The server MUST always reject\r\n      > this request, unless the client is to be granted access without any\r\n      > authentication, in which case, the server MUST accept this request.\r\n\r\n    - [5.3](https://tools.ietf.org/html/rfc4252.html#section-5.3): this (like 4251.1) states that the server should start up the requested service after sending auth-success. One could read this to imply that services SHOULD NOT start UNLESS auth has occurred, but it's not explicit...    \r\n    - [7](https://tools.ietf.org/html/rfc4252.html#section-7): notes that implementations MUST implement public-key auth, though I note this is distinct from requiring that it is _enabled_ (clearly, many real servers only offer password auth, for example.)\r\n- RFC 4253 (transport protocol)\r\n    - [10](https://tools.ietf.org/html/rfc4253.html#section-10): implies client may request \"a service\" after initial (high level) kex, where that service is one of userauth or connection. The transport level of the protocol thus doesn't appear to actually care or enforce that one performs auth before connection.\r\n- RFC 4254 (connection protocol)\r\n    - [1](https://tools.ietf.org/html/rfc4254.html#section-1): once again implies that connection is \"designed to\" occur after/on top of auth.\r\n    - [11](https://tools.ietf.org/html/rfc4254.html#section-11): again, it's 'assumed':\r\n    \r\n      > This protocol is assumed to run on top of a secure, authenticated\r\n      > transport.  User authentication and protection against network-level\r\n      > attacks are assumed to be provided by the underlying protocols.\r\n      \r\n## OpenSSH's implementation\r\n\r\nMy old friend and the only C codebase I have any familiarity with whatsoever, [openssh-portable](https://github.com/openssh/openssh-portable)...\r\n\r\n### Synopsis\r\n\r\nAfter all the below, the tl;dr seems to be:\r\n\r\n- OpenSSH sets up a dispatch table to determine how it responds to protocol messages/packets\r\n- This table gets reinitialized depending on 'phase' of execution: while awaiting auth, it is only set to respond to auth-related messages, then after successful auth, it retools the table to only respond to post-auth-related messages like channel opens.\r\n- Thus, the case under test ends up being a simple \"What even are you talking about? What's a channel open?\" `NotImplementedError` style situation - no auth step, no idea how to handle anything beyond auth.\r\n\r\n### Deep dive\r\n\r\n- Main SSH2 server loop is `serverloop.c` -> `server_loop2()`\r\n- Which uses a dispatch table to handle inbound messages: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L393\r\n- Which dispatches to other functions, so when it sees eg `MSG_CHANNEL_OPEN` it calls `server_input_channel_open()`: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L897\r\n- Which is defined here: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L613\r\n- If the user is asking for command exec, that's channel type `session`: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L630\r\n- Which calls `server_request_session`: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L582\r\n- Which calls `session_open` with a handle on `the_authctxt`: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L603\r\n    - This is our first apparent reference to anything auth-related so far...\r\n    - The only other apparent external context is the `ssh` object used to get the actual channel in play on the call prior: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L600\r\n    - That auth context object is `extern`'d at top of file: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/serverloop.c#L84\r\n    - We'll dig into that later if necessary but for now, let's assume it has handy ways of telling whether the user is authed or not, and the question is whether/how those are consulted.\r\n- `session_open` is, bizarrely, defined in `session.c`: https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/session.c#L1757\r\n- It checks for `authctxt->valid` (or a null password entry) and gets mad if not true: https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/session.c#L1767\r\n    - So yea, we gotta doublecheck what that `->valid` member actually maps to. \r\n- `Authctxt` struct is defined in `auth.h` here: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth.h#L55-L98\r\n    - It has a bunch of flags, of which `success`, `authenticated`, and `valid` all seem relevant.\r\n    - `success` is not documented; `authenticated` sounds like it maps to, well, authentication (user is who they claim to be) with `valid` mapping to (a generic level of) authorization (the user is actually allowed to login.)\r\n- Those flags (esp `valid`) aren't set in too many places; the most useful and in retrospect most obvious place is in handling of userauth requests: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth2.c#L215\r\n    - The core of this is actually use of `Authmethod` structs ([format defined here](https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth.h#L107-L111)) created by the various `auth2-*` modules (one for each implemented auth backend - kerberos, password, publickey, hostbased, etc)\r\n        - These are simple `name`, `userauth`, `enabled` structures, with `userauth` being a pointer to an implementation function (so e.g. the one for password auth is referencing `userauth_passwd` in `auth2-passwd.c` ([here](https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth2-passwd.c#L51-L71).)\r\n    - The per-method `userauth` func is called and the result stored as `authenticated` var: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth2.c#L287\r\n    - Which bubbles down (after much state machine checking) to finalizing userauth - sending the success network message, updating `authctxt->success = 1`, etc: https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth2.c#L352-L360\r\n- The `->valid` flag seems to actually just be \"is the requested username a valid local system user\": https://github.com/openssh/openssh-portable/blob/71e48bc7945f867029e50e06c665c66aed6d3c64/auth2.c#L236-L239\r\n    - Note use of `getpwnamallow`, which (basically) wraps the syscall `getpwnam` aka \"get password entry for user\" (so `authctxt->pw` is specifically that structure and not just a password)\r\n    - Which explains why it's distinct from `success` and `authenticated`.\r\n\r\n### Initial distillation\r\n\r\n- Seems at first that \"huh, the user can get a session as long as they exist locally, without necessarily passing auth\" which would be bad but would also act like Paramiko.\r\n- However, realized: that `->valid` flag is set by `input_userauth_request`, meaning the client has to actually submit auth in order to set it. (Ditto `->pw`.)\r\n- So if a user attempts to send a channel open request without authing, both `authctxt->pw` and `authctxt->valid` will be null, and thus `session_open` should call [line 1767](https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/session.c#L1767) and thus result in `fatal(\"no user for session\")`.\r\n\r\n### Testing with live OpenSSH server\r\n\r\nProving this with a live install is interesting:\r\n\r\n- Ran local docker container executing Ubuntu + OpenSSH 7.2 on port 2222 with nothing but root password auth by default\r\n- Executed Matthijs's `client-test.py` with nothing but the port number changed\r\n- Did not get expected `no user for session` but instead seem to have just confused the poor thing:\r\n\r\n  ```\r\n  debug1: SSH2_MSG_NEWKEYS received [preauth]\r\n  debug1: KEX done [preauth]\r\n  dispatch_protocol_error: type 90 seq 3 [preauth]\r\n  debug1: Received SSH2_MSG_UNIMPLEMENTED for 3 [preauth]\r\n  ```\r\n\r\n### Second dive\r\n\r\n- The above protocol error log message comes out of here: https://github.com/openssh/openssh-portable/blob/151c6e433a5f5af761c78de87d7b5d30a453cf5e/dispatch.c#L45-L46 in `dispatch_protocol_error()`\r\n- Which is stuffed into newly initialized dispatch tables by [ssh_dispatch_init](https://github.com/openssh/openssh-portable/blob/151c6e433a5f5af761c78de87d7b5d30a453cf5e/dispatch.c#L61-L67)\r\n    - Which is done via `do_authentication2` here: https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/auth2.c#L172\r\n- So the tl;dr is that the dispatch table gets all 255 slots filled initially by `SSH2_MSG_UNIMPLEMENTED`, then the table is filled in with what is intended to be responded to (e.g. in `do_authentication2`, the very next line is to say [\"ok and now respond to service requests\"](https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/auth2.c#L173))\r\n    - E.g. slot 90 corresponds to `SSH_MSG_CHANNEL_OPEN`, aka what our test client was requesting: https://tools.ietf.org/html/rfc4250#section-4.1.2\r\n- Looks like in the normal flow of things, the post-auth process ends up reinitializing the dispatch table with acceptable messages (including channel opens):\r\n    - Server loop emits \"Entering interactive session\" log message one can see in a successful regular auth+shell: https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/serverloop.c#L375\r\n    - Then calls `server_init_dispatch`: https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/serverloop.c#L393\r\n    - Which does aforementioned dispatch reset & fill-in: https://github.com/openssh/openssh-portable/blob/de1920d743d295f50e6905e5957c4172c038e8eb/serverloop.c#L889-L910\r\n\r\n\r\n## End result\r\n\r\n- The RFC isn't terrifically clear beyond \"well, we kind of assume you're not gonna open channels and such unless you've already authed\", but it's not a `SHOULD` or a `MUST`.\r\n- OpenSSH has chosen to implement this as a strict \"only respond to the messages you can handle at the current stage\" setup, where auth comes before connection (as in the RFC.) Trying to do things out-of-order results in a simple `SSH_MSG_UNIMPLEMENTED`.\r\n- Paramiko does not do things quite that way: instead, as one might guess from the bug description, it simply sets up all possible dispatch targets (anything implemented by the Transport  across its two handler tables, and the AuthHandler handler table) and then dispatches depending on message type: https://github.com/paramiko/paramiko/blob/27a8ed14c2f3e7a1fd8e75d259f06504d5c8e11b/paramiko/transport.py#L1891-L1917\r\n\r\nDoing nothing certainly seems like a bad idea: this is clearly a massive security flaw, and the only reason I did all the above investigation is because software has an irritating history of \"but I was _relying_ on that bug / looseness in the spec / whatever!\". Given the main reference implementation disallows it, I'm inclined to assume nobody could possibly rely on this.\r\n\r\nSo there's two obvious fixes for Paramiko:\r\n\r\n- The \"OpenSSH is the Bible\" approach: update Transport's dispatching to be more like OpenSSH's and only enable certain message types depending on the state of `self.is_authenticated` (which, impressively, appears to only ever be used in `__repr__`...!!!)\r\n    - This could be problematic given that Transport is frustratingly bimodal and is used both for server _and_ client operations - we'd have to make sure that we're not preventing a not-yet-authed client from dispatching on necessary responses because it's not authed yet, for example.\r\n    - Of note, AsyncSSH is taking this approach in their fix, and are simply leveraging the fact that RFC 4250 compatible protocol numbers mean one can just go \"is the message identifier greater than the highest possible auth related number? Are you authed yet? No? Screw off!\" - seems possible on our end, though doesn't really change the previous point about ensuring client-side cases are protected.\r\n- The \"that's too much work right now\" approach: simply rub some more references to `.auth_handler` and/or `.is_authenticated` in specific spots such as `Server.check_channel_request` ([here](https://github.com/paramiko/paramiko/blob/master/paramiko/server.py#L42))\r\n    - Except this, too, is problematic because of how Transport, Server and AuthHandler split up responsibilities & exposures to one another. By default a Server has no direct access to the Transport running it, or that Transport's AuthHandler (which, in server mode, is set up during rekeying [including initial kex].)\r\n        - Changing this would be backwards incompatible (e.g. enforcing an actual `__init__` on `Server` subclasses for the passing-in of a reference to one of the other objects, since right now `Server` doesn't even define one!) though I would like to examine it sometime. Now probably not the best time though.\r\n    - Could still put specific, small-scoped changes in `Transport` though, such as around the `check_channel_request` calls here: https://github.com/paramiko/paramiko/blob/27a8ed14c2f3e7a1fd8e75d259f06504d5c8e11b/paramiko/transport.py#L2531-L2537\r\n\r\nMy gut says to take a quick stab at the 1st approach but to fall back to the\r\n2nd if the 1st cannot be done relatively painlessly.\r\n\r\nEither way, re: the actual action to take seems poorly defined, but esp given OpenSSH simply spits out a bunch of question marks and not a \"useful\" error; the RFCs (4250, 4254) list only 4 default 'error' types, of which `OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED` seems the closest fit. And indeed Paramiko uses it for eg bogus channel types, in some legacy tests.","closed_by":{"login":"bitprophet","id":6088,"node_id":"MDQ6VXNlcjYwODg=","avatar_url":"https://avatars.githubusercontent.com/u/6088?v=4","gravatar_id":"","url":"https://api.github.com/users/bitprophet","html_url":"https://github.com/bitprophet","followers_url":"https://api.github.com/users/bitprophet/followers","following_url":"https://api.github.com/users/bitprophet/following{/other_user}","gists_url":"https://api.github.com/users/bitprophet/gists{/gist_id}","starred_url":"https://api.github.com/users/bitprophet/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/bitprophet/subscriptions","organizations_url":"https://api.github.com/users/bitprophet/orgs","repos_url":"https://api.github.com/users/bitprophet/repos","events_url":"https://api.github.com/users/bitprophet/events{/privacy}","received_events_url":"https://api.github.com/users/bitprophet/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/paramiko/paramiko/issues/1175/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/paramiko/paramiko/issues/1175/timeline","performed_via_github_app":null,"state_reason":"completed"}