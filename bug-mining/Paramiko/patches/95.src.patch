diff --git a/demos/demo.py b/demos/demo.py
index 5252db7c..96d43277 100755
--- a/demos/demo.py
+++ b/demos/demo.py
@@ -61,9 +61,7 @@ def agent_auth(transport, username):
 
 def manual_auth(username, hostname):
     default_auth = "p"
-    auth = input(
-        "Auth by (p)assword, (r)sa key, or (d)ss key? [%s] " % default_auth
-    )
+    auth = input("Auth by (p)assword or (r)sa key? [%s] " % default_auth)
     if len(auth) == 0:
         auth = default_auth
 
@@ -78,17 +76,6 @@ def manual_auth(username, hostname):
             password = getpass.getpass("RSA key password: ")
             key = paramiko.RSAKey.from_private_key_file(path, password)
         t.auth_publickey(username, key)
-    elif auth == "d":
-        default_path = os.path.join(os.environ["HOME"], ".ssh", "id_dsa")
-        path = input("DSS key [%s]: " % default_path)
-        if len(path) == 0:
-            path = default_path
-        try:
-            key = paramiko.DSSKey.from_private_key_file(path)
-        except paramiko.PasswordRequiredException:
-            password = getpass.getpass("DSS key password: ")
-            key = paramiko.DSSKey.from_private_key_file(path, password)
-        t.auth_publickey(username, key)
     else:
         pw = getpass.getpass("Password for %s@%s: " % (username, hostname))
         t.auth_password(username, pw)
diff --git a/demos/demo_keygen.py b/demos/demo_keygen.py
index 12637ed0..c7db9e59 100755
--- a/demos/demo_keygen.py
+++ b/demos/demo_keygen.py
@@ -23,7 +23,6 @@ import sys
 from binascii import hexlify
 from optparse import OptionParser
 
-from paramiko import DSSKey
 from paramiko import RSAKey
 from paramiko.ssh_exception import SSHException
 from paramiko.py3compat import u
@@ -32,13 +31,13 @@ usage = """
 %prog [-v] [-b bits] -t type [-N new_passphrase] [-f output_keyfile]"""
 
 default_values = {
-    "ktype": "dsa",
+    "ktype": "rsa",
     "bits": 1024,
     "filename": "output",
     "comment": "",
 }
 
-key_dispatch_table = {"dsa": DSSKey, "rsa": RSAKey}
+key_dispatch_table = {"rsa": RSAKey}
 
 
 def progress(arg=None):
@@ -68,7 +67,7 @@ if __name__ == "__main__":
         "--type",
         type="string",
         dest="ktype",
-        help="Specify type of key to create (dsa or rsa)",
+        help="Specify type of key to create",
         metavar="ktype",
         default=default_values["ktype"],
     )
@@ -140,9 +139,6 @@ if __name__ == "__main__":
         )
         sys.stdout.flush()
 
-    if ktype == "dsa" and bits > 1024:
-        raise SSHException("DSA Keys must be 1024 bits")
-
     if ktype not in key_dispatch_table:
         raise SSHException(
             "Unknown %s algorithm to generate keys pair" % ktype
diff --git a/demos/demo_server.py b/demos/demo_server.py
index 6cb2dc51..88d8bc71 100644
--- a/demos/demo_server.py
+++ b/demos/demo_server.py
@@ -34,7 +34,6 @@ from paramiko.py3compat import b, u, decodebytes
 paramiko.util.log_to_file("demo_server.log")
 
 host_key = paramiko.RSAKey(filename="test_rsa.key")
-# host_key = paramiko.DSSKey(filename='test_dss.key')
 
 print("Read key: " + u(hexlify(host_key.get_fingerprint())))
 
diff --git a/lol b/lol
new file mode 100644
index 00000000..08d84995
--- /dev/null
+++ b/lol
@@ -0,0 +1,7 @@
+-----BEGIN OPENSSH PRIVATE KEY-----
+b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
+QyNTUxOQAAACDPznQKX59nZTY2WJ3zUurD2n6JcCK/T7w2Cvx+PDs/TAAAAJjoZMDv6GTA
+7wAAAAtzc2gtZWQyNTUxOQAAACDPznQKX59nZTY2WJ3zUurD2n6JcCK/T7w2Cvx+PDs/TA
+AAAEBRpxEHx9PJaZFkRuym+EMCO4JDRYHk/WLcLm/3Tv36g8/OdApfn2dlNjZYnfNS6sPa
+folwIr9PvDYK/H48Oz9MAAAAEWpmb3JjaWVyQGVwaXBocm9uAQIDBA==
+-----END OPENSSH PRIVATE KEY-----
diff --git a/lol.pub b/lol.pub
new file mode 100644
index 00000000..bcc33f8f
--- /dev/null
+++ b/lol.pub
@@ -0,0 +1 @@
+ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIM/OdApfn2dlNjZYnfNS6sPafolwIr9PvDYK/H48Oz9M jforcier@epiphron
diff --git a/paramiko/__init__.py b/paramiko/__init__.py
index 65148d2a..77a53126 100644
--- a/paramiko/__init__.py
+++ b/paramiko/__init__.py
@@ -66,7 +66,6 @@ from paramiko.ssh_exception import (
 )
 from paramiko.server import ServerInterface, SubsystemHandler, InteractiveQuery
 from paramiko.rsakey import RSAKey
-from paramiko.dsskey import DSSKey
 from paramiko.ecdsakey import ECDSAKey
 from paramiko.ed25519key import Ed25519Key
 from paramiko.sftp import SFTPError, BaseSFTP
@@ -112,7 +111,7 @@ from paramiko.common import io_sleep
 
 
 # TODO: I guess a real plugin system might be nice for future expansion...
-key_classes = [DSSKey, RSAKey, Ed25519Key, ECDSAKey]
+key_classes = [RSAKey, Ed25519Key, ECDSAKey]
 
 
 __author__ = "Jeff Forcier <jeff@bitprophet.org>"
@@ -131,7 +130,6 @@ __all__ = [
     "ChannelException",
     "ConfigParseError",
     "CouldNotCanonicalize",
-    "DSSKey",
     "ECDSAKey",
     "Ed25519Key",
     "HostKeys",
diff --git a/paramiko/_version.py b/paramiko/_version.py
index 3e947080..4f4b3533 100644
--- a/paramiko/_version.py
+++ b/paramiko/_version.py
@@ -1,2 +1,2 @@
-__version_info__ = (3, 5, 1)
+__version_info__ = (4, 0, 0)
 __version__ = ".".join(map(str, __version_info__))
diff --git a/paramiko/client.py b/paramiko/client.py
index d8be9108..1f674a92 100644
--- a/paramiko/client.py
+++ b/paramiko/client.py
@@ -31,7 +31,6 @@ from errno import ECONNREFUSED, EHOSTUNREACH
 from paramiko.agent import Agent
 from paramiko.common import DEBUG
 from paramiko.config import SSH_PORT
-from paramiko.dsskey import DSSKey
 from paramiko.ecdsakey import ECDSAKey
 from paramiko.ed25519key import Ed25519Key
 from paramiko.hostkeys import HostKeys
@@ -260,8 +259,7 @@ class SSHClient(ClosingContextManager):
                 this to occur - *just* the certificate.)
 
             - Any key we can find through an SSH agent
-            - Any "id_rsa", "id_dsa" or "id_ecdsa" key discoverable in
-              ``~/.ssh/``
+            - Any ``id_*`` keys discoverable in ``~/.ssh/``
 
               - When OpenSSH-style public certificates exist that match an
                 existing such private key (so e.g. one has ``id_rsa`` and
@@ -668,8 +666,7 @@ class SSHClient(ClosingContextManager):
 
             - The key(s) passed in, if one was passed in.
             - Any key we can find through an SSH agent (if allowed).
-            - Any "id_rsa", "id_dsa" or "id_ecdsa" key discoverable in ~/.ssh/
-              (if allowed).
+            - Any id_* key discoverable in ~/.ssh/ (if allowed).
             - Plain username/password auth, if a password was given.
 
         (The password might be needed to unlock a private key [if 'passphrase'
@@ -725,7 +722,7 @@ class SSHClient(ClosingContextManager):
             for key_filename in key_filenames:
                 # TODO 4.0: leverage PKey.from_path() if we don't end up just
                 # killing SSHClient entirely
-                for pkey_class in (RSAKey, DSSKey, ECDSAKey, Ed25519Key):
+                for pkey_class in (RSAKey, ECDSAKey, Ed25519Key):
                     try:
                         key = self._key_from_filepath(
                             key_filename, pkey_class, passphrase
@@ -765,7 +762,6 @@ class SSHClient(ClosingContextManager):
 
             for keytype, name in [
                 (RSAKey, "rsa"),
-                (DSSKey, "dsa"),
                 (ECDSAKey, "ecdsa"),
                 (Ed25519Key, "ed25519"),
             ]:
diff --git a/paramiko/dsskey.py b/paramiko/dsskey.py
deleted file mode 100644
index 5215d282..00000000
--- a/paramiko/dsskey.py
+++ /dev/null
@@ -1,258 +0,0 @@
-# Copyright (C) 2003-2007  Robey Pointer <robeypointer@gmail.com>
-#
-# This file is part of paramiko.
-#
-# Paramiko is free software; you can redistribute it and/or modify it under the
-# terms of the GNU Lesser General Public License as published by the Free
-# Software Foundation; either version 2.1 of the License, or (at your option)
-# any later version.
-#
-# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY
-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
-# details.
-#
-# You should have received a copy of the GNU Lesser General Public License
-# along with Paramiko; if not, write to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.
-
-"""
-DSS keys.
-"""
-
-from cryptography.exceptions import InvalidSignature
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives import hashes, serialization
-from cryptography.hazmat.primitives.asymmetric import dsa
-from cryptography.hazmat.primitives.asymmetric.utils import (
-    decode_dss_signature,
-    encode_dss_signature,
-)
-
-from paramiko import util
-from paramiko.common import zero_byte
-from paramiko.ssh_exception import SSHException
-from paramiko.message import Message
-from paramiko.ber import BER, BERException
-from paramiko.pkey import PKey
-
-
-class DSSKey(PKey):
-    """
-    Representation of a DSS key which can be used to sign an verify SSH2
-    data.
-    """
-
-    name = "ssh-dss"
-
-    def __init__(
-        self,
-        msg=None,
-        data=None,
-        filename=None,
-        password=None,
-        vals=None,
-        file_obj=None,
-    ):
-        self.p = None
-        self.q = None
-        self.g = None
-        self.y = None
-        self.x = None
-        self.public_blob = None
-        if file_obj is not None:
-            self._from_private_key(file_obj, password)
-            return
-        if filename is not None:
-            self._from_private_key_file(filename, password)
-            return
-        if (msg is None) and (data is not None):
-            msg = Message(data)
-        if vals is not None:
-            self.p, self.q, self.g, self.y = vals
-        else:
-            self._check_type_and_load_cert(
-                msg=msg,
-                key_type=self.name,
-                cert_type=f"{self.name}-cert-v01@openssh.com",
-            )
-            self.p = msg.get_mpint()
-            self.q = msg.get_mpint()
-            self.g = msg.get_mpint()
-            self.y = msg.get_mpint()
-        self.size = util.bit_length(self.p)
-
-    def asbytes(self):
-        m = Message()
-        m.add_string(self.name)
-        m.add_mpint(self.p)
-        m.add_mpint(self.q)
-        m.add_mpint(self.g)
-        m.add_mpint(self.y)
-        return m.asbytes()
-
-    def __str__(self):
-        return self.asbytes()
-
-    @property
-    def _fields(self):
-        return (self.get_name(), self.p, self.q, self.g, self.y)
-
-    # TODO 4.0: remove
-    def get_name(self):
-        return self.name
-
-    def get_bits(self):
-        return self.size
-
-    def can_sign(self):
-        return self.x is not None
-
-    def sign_ssh_data(self, data, algorithm=None):
-        key = dsa.DSAPrivateNumbers(
-            x=self.x,
-            public_numbers=dsa.DSAPublicNumbers(
-                y=self.y,
-                parameter_numbers=dsa.DSAParameterNumbers(
-                    p=self.p, q=self.q, g=self.g
-                ),
-            ),
-        ).private_key(backend=default_backend())
-        sig = key.sign(data, hashes.SHA1())
-        r, s = decode_dss_signature(sig)
-
-        m = Message()
-        m.add_string(self.name)
-        # apparently, in rare cases, r or s may be shorter than 20 bytes!
-        rstr = util.deflate_long(r, 0)
-        sstr = util.deflate_long(s, 0)
-        if len(rstr) < 20:
-            rstr = zero_byte * (20 - len(rstr)) + rstr
-        if len(sstr) < 20:
-            sstr = zero_byte * (20 - len(sstr)) + sstr
-        m.add_string(rstr + sstr)
-        return m
-
-    def verify_ssh_sig(self, data, msg):
-        if len(msg.asbytes()) == 40:
-            # spies.com bug: signature has no header
-            sig = msg.asbytes()
-        else:
-            kind = msg.get_text()
-            if kind != self.name:
-                return 0
-            sig = msg.get_binary()
-
-        # pull out (r, s) which are NOT encoded as mpints
-        sigR = util.inflate_long(sig[:20], 1)
-        sigS = util.inflate_long(sig[20:], 1)
-
-        signature = encode_dss_signature(sigR, sigS)
-
-        key = dsa.DSAPublicNumbers(
-            y=self.y,
-            parameter_numbers=dsa.DSAParameterNumbers(
-                p=self.p, q=self.q, g=self.g
-            ),
-        ).public_key(backend=default_backend())
-        try:
-            key.verify(signature, data, hashes.SHA1())
-        except InvalidSignature:
-            return False
-        else:
-            return True
-
-    def write_private_key_file(self, filename, password=None):
-        key = dsa.DSAPrivateNumbers(
-            x=self.x,
-            public_numbers=dsa.DSAPublicNumbers(
-                y=self.y,
-                parameter_numbers=dsa.DSAParameterNumbers(
-                    p=self.p, q=self.q, g=self.g
-                ),
-            ),
-        ).private_key(backend=default_backend())
-
-        self._write_private_key_file(
-            filename,
-            key,
-            serialization.PrivateFormat.TraditionalOpenSSL,
-            password=password,
-        )
-
-    def write_private_key(self, file_obj, password=None):
-        key = dsa.DSAPrivateNumbers(
-            x=self.x,
-            public_numbers=dsa.DSAPublicNumbers(
-                y=self.y,
-                parameter_numbers=dsa.DSAParameterNumbers(
-                    p=self.p, q=self.q, g=self.g
-                ),
-            ),
-        ).private_key(backend=default_backend())
-
-        self._write_private_key(
-            file_obj,
-            key,
-            serialization.PrivateFormat.TraditionalOpenSSL,
-            password=password,
-        )
-
-    @staticmethod
-    def generate(bits=1024, progress_func=None):
-        """
-        Generate a new private DSS key.  This factory function can be used to
-        generate a new host key or authentication key.
-
-        :param int bits: number of bits the generated key should be.
-        :param progress_func: Unused
-        :return: new `.DSSKey` private key
-        """
-        numbers = dsa.generate_private_key(
-            bits, backend=default_backend()
-        ).private_numbers()
-        key = DSSKey(
-            vals=(
-                numbers.public_numbers.parameter_numbers.p,
-                numbers.public_numbers.parameter_numbers.q,
-                numbers.public_numbers.parameter_numbers.g,
-                numbers.public_numbers.y,
-            )
-        )
-        key.x = numbers.x
-        return key
-
-    # ...internals...
-
-    def _from_private_key_file(self, filename, password):
-        data = self._read_private_key_file("DSA", filename, password)
-        self._decode_key(data)
-
-    def _from_private_key(self, file_obj, password):
-        data = self._read_private_key("DSA", file_obj, password)
-        self._decode_key(data)
-
-    def _decode_key(self, data):
-        pkformat, data = data
-        # private key file contains:
-        # DSAPrivateKey = { version = 0, p, q, g, y, x }
-        if pkformat == self._PRIVATE_KEY_FORMAT_ORIGINAL:
-            try:
-                keylist = BER(data).decode()
-            except BERException as e:
-                raise SSHException("Unable to parse key file: {}".format(e))
-        elif pkformat == self._PRIVATE_KEY_FORMAT_OPENSSH:
-            keylist = self._uint32_cstruct_unpack(data, "iiiii")
-            keylist = [0] + list(keylist)
-        else:
-            self._got_bad_key_format_id(pkformat)
-        if type(keylist) is not list or len(keylist) < 6 or keylist[0] != 0:
-            raise SSHException(
-                "not a valid DSA private key file (bad ber encoding)"
-            )
-        self.p = keylist[1]
-        self.q = keylist[2]
-        self.g = keylist[3]
-        self.y = keylist[4]
-        self.x = keylist[5]
-        self.size = util.bit_length(self.p)
diff --git a/paramiko/hostkeys.py b/paramiko/hostkeys.py
index 4d47e950..0bcf6c39 100644
--- a/paramiko/hostkeys.py
+++ b/paramiko/hostkeys.py
@@ -62,7 +62,7 @@ class HostKeys(MutableMapping):
         ``(hostname, keytype)`` pair will be replaced.
 
         :param str hostname: the hostname (or IP) to add
-        :param str keytype: key type (``"ssh-rsa"`` or ``"ssh-dss"``)
+        :param str keytype: key type (in ``"ssh-<type>"`` format)
         :param .PKey key: the key to add
         """
         for e in self._entries:
@@ -126,7 +126,7 @@ class HostKeys(MutableMapping):
         """
         Find a hostkey entry for a given hostname or IP.  If no entry is found,
         ``None`` is returned.  Otherwise a dictionary of keytype to key is
-        returned.  The keytype will be either ``"ssh-rsa"`` or ``"ssh-dss"``.
+        returned.
 
         :param str hostname: the hostname (or IP) to lookup
         :return: dict of `str` -> `.PKey` keys associated with this host
diff --git a/paramiko/pkey.py b/paramiko/pkey.py
index 9a4cf900..50558cbd 100644
--- a/paramiko/pkey.py
+++ b/paramiko/pkey.py
@@ -119,10 +119,8 @@ class PKey:
     }
     _PRIVATE_KEY_FORMAT_ORIGINAL = 1
     _PRIVATE_KEY_FORMAT_OPENSSH = 2
-    BEGIN_TAG = re.compile(
-        r"^-{5}BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-{5}\s*$"
-    )
-    END_TAG = re.compile(r"^-{5}END (RSA|DSA|EC|OPENSSH) PRIVATE KEY-{5}\s*$")
+    BEGIN_TAG = re.compile(r"^-{5}BEGIN (RSA|EC|OPENSSH) PRIVATE KEY-{5}\s*$")
+    END_TAG = re.compile(r"^-{5}END (RSA|EC|OPENSSH) PRIVATE KEY-{5}\s*$")
 
     @staticmethod
     def from_path(path, passphrase=None):
@@ -142,7 +140,7 @@ class PKey:
         # TODO: make sure sphinx is reading Path right in param list...
 
         # Lazy import to avoid circular import issues
-        from paramiko import DSSKey, RSAKey, Ed25519Key, ECDSAKey
+        from paramiko import RSAKey, Ed25519Key, ECDSAKey
 
         # Normalize to string, as cert suffix isn't quite an extension, so
         # pathlib isn't useful for this.
@@ -181,9 +179,7 @@ class PKey:
         # to be cryptography-object-forward. this is still likely faster than
         # the old SSHClient code that just tried instantiating every class!
         key_class = None
-        if isinstance(loaded, asymmetric.dsa.DSAPrivateKey):
-            key_class = DSSKey
-        elif isinstance(loaded, asymmetric.rsa.RSAPrivateKey):
+        if isinstance(loaded, asymmetric.rsa.RSAPrivateKey):
             key_class = RSAKey
         elif isinstance(loaded, asymmetric.ed25519.Ed25519PrivateKey):
             key_class = Ed25519Key
@@ -418,7 +414,7 @@ class PKey:
         key is encrypted and ``password`` is not ``None``, the given password
         will be used to decrypt the key (otherwise `.PasswordRequiredException`
         is thrown).  Through the magic of Python, this factory method will
-        exist in all subclasses of PKey (such as `.RSAKey` or `.DSSKey`), but
+        exist in all subclasses of PKey (such as `.RSAKey`), but
         is useless on the abstract PKey class.
 
         :param str filename: name of the file to read
@@ -492,13 +488,15 @@ class PKey:
         ``password`` is not ``None``, the given password will be used to
         decrypt the key (otherwise `.PasswordRequiredException` is thrown).
 
-        :param str tag: ``"RSA"`` or ``"DSA"``, the tag used to mark the
-            data block.
-        :param str filename: name of the file to read.
+        :param str tag:
+            ``"RSA"`` (or etc), the tag used to mark the data block.
+        :param str filename:
+            name of the file to read.
         :param str password:
             an optional password to use to decrypt the key file, if it's
             encrypted.
-        :return: the `bytes` that make up the private key.
+        :return:
+            the `bytes` that make up the private key.
 
         :raises: ``IOError`` -- if there was an error reading the file.
         :raises: `.PasswordRequiredException` -- if the private key file is
@@ -745,7 +743,7 @@ class PKey:
         a password is given, DES-EDE3-CBC is used.
 
         :param str tag:
-            ``"RSA"`` or ``"DSA"``, the tag used to mark the data block.
+            ``"RSA"`` or etc, the tag used to mark the data block.
         :param filename: name of the file to write.
         :param bytes data: data blob that makes up the private key.
         :param str password: an optional password to use to encrypt the file.
@@ -868,7 +866,7 @@ class PKey:
 # readable from a one-line file of the format:
 #     <key-name> <base64-blob> [<comment>]
 # Of little value in the case of standard public keys
-# {ssh-rsa, ssh-dss, ssh-ecdsa, ssh-ed25519}, but should
+# {ssh-rsa, ssh-ecdsa, ssh-ed25519}, but should
 # provide rudimentary support for {*-cert.v01}
 class PublicBlob:
     """
diff --git a/paramiko/transport.py b/paramiko/transport.py
index f0fcb979..4e3c4f42 100644
--- a/paramiko/transport.py
+++ b/paramiko/transport.py
@@ -95,7 +95,6 @@ from paramiko.common import (
     byte_ord,
 )
 from paramiko.compress import ZlibCompressor, ZlibDecompressor
-from paramiko.dsskey import DSSKey
 from paramiko.ed25519key import Ed25519Key
 from paramiko.kex_curve25519 import KexCurve25519
 from paramiko.kex_gex import KexGex, KexGexSHA256
@@ -206,7 +205,6 @@ class Transport(threading.Thread, ClosingContextManager):
         "rsa-sha2-512",
         "rsa-sha2-256",
         "ssh-rsa",
-        "ssh-dss",
     )
     # ~= PubKeyAcceptedAlgorithms
     _preferred_pubkeys = (
@@ -217,7 +215,6 @@ class Transport(threading.Thread, ClosingContextManager):
         "rsa-sha2-512",
         "rsa-sha2-256",
         "ssh-rsa",
-        "ssh-dss",
     )
     _preferred_kex = (
         "ecdh-sha2-nistp256",
@@ -320,8 +317,6 @@ class Transport(threading.Thread, ClosingContextManager):
         "rsa-sha2-256-cert-v01@openssh.com": RSAKey,
         "rsa-sha2-512": RSAKey,
         "rsa-sha2-512-cert-v01@openssh.com": RSAKey,
-        "ssh-dss": DSSKey,
-        "ssh-dss-cert-v01@openssh.com": DSSKey,
         "ecdsa-sha2-nistp256": ECDSAKey,
         "ecdsa-sha2-nistp256-cert-v01@openssh.com": ECDSAKey,
         "ecdsa-sha2-nistp384": ECDSAKey,
@@ -849,11 +844,10 @@ class Transport(threading.Thread, ClosingContextManager):
         as a server, the host key is used to sign certain packets during the
         SSH2 negotiation, so that the client can trust that we are who we say
         we are.  Because this is used for signing, the key must contain private
-        key info, not just the public half.  Only one key of each type (RSA or
-        DSS) is kept.
+        key info, not just the public half.  Only one key of each type is kept.
 
         :param .PKey key:
-            the host key to add, usually an `.RSAKey` or `.DSSKey`.
+            the host key (instance of some subclass) to add
         """
         self.server_key_dict[key.get_name()] = key
         # Handle SHA-2 extensions for RSA by ensuring that lookups into
@@ -869,10 +863,10 @@ class Transport(threading.Thread, ClosingContextManager):
         client, this method will return the negotiated host key.  If only one
         type of host key was set with `add_server_key`, that's the only key
         that will ever be returned.  But in cases where you have set more than
-        one type of host key (for example, an RSA key and a DSS key), the key
-        type will be negotiated by the client, and this method will return the
-        key of the type agreed on.  If the host key has not been negotiated
-        yet, ``None`` is returned.  In client mode, the behavior is undefined.
+        one type of host key, the key type will be negotiated by the client,
+        and this method will return the key of the type agreed on.  If the host
+        key has not been negotiated yet, ``None`` is returned.  In client mode,
+        the behavior is undefined.
 
         :return:
             host key (`.PKey`) of the type negotiated by the client, or
diff --git a/paramiko/util.py b/paramiko/util.py
index f1e33a50..0f5a7859 100644
--- a/paramiko/util.py
+++ b/paramiko/util.py
@@ -174,8 +174,7 @@ def load_host_keys(filename):
     """
     Read a file of known SSH host keys, in the format used by openssh, and
     return a compound dict of ``hostname -> keytype ->`` `PKey
-    <paramiko.pkey.PKey>`. The hostname may be an IP address or DNS name.  The
-    keytype will be either ``"ssh-rsa"`` or ``"ssh-dss"``.
+    <paramiko.pkey.PKey>`. The hostname may be an IP address or DNS name.
 
     This type of file unfortunately doesn't exist on Windows, but on posix,
     it will usually be stored in ``os.path.expanduser("~/.ssh/known_hosts")``.
diff --git a/sites/docs/api/keys.rst b/sites/docs/api/keys.rst
index a456f502..4025f699 100644
--- a/sites/docs/api/keys.rst
+++ b/sites/docs/api/keys.rst
@@ -7,10 +7,6 @@ Parent key class
 
 .. automodule:: paramiko.pkey
 
-DSA (DSS)
-=========
-
-.. automodule:: paramiko.dsskey
 
 RSA
 ===
diff --git a/sites/www/changelog.rst b/sites/www/changelog.rst
index 63b86198..f8c4afcb 100644
--- a/sites/www/changelog.rst
+++ b/sites/www/changelog.rst
@@ -2,6 +2,15 @@
 Changelog
 =========
 
+- :support:`973` Removed support for the DSA (aka DSS) key algorithm, as it has
+  been badly outdated and insecure for a decade or more at this point, and was
+  recently completely removed from OpenSSH as well.
+
+  If you were still using DSA out of sheer inertia: we strongly recommend
+  upgrading to Ed25519 (or maybe ECDSA).
+
+  If you were still using DSA because of target hosts you do not control:
+  please continue using Paramiko 3.x.
 - :release:`3.5.1 <2025-02-03>`
 - :bug:`2490` Private key material is now explicitly 'unpadded' during
   decryption, removing a reliance on some lax OpenSSL behavior & making us
diff --git a/tests/_support/dss.key b/tests/_support/dss.key
deleted file mode 100644
index e10807f1..00000000
--- a/tests/_support/dss.key
+++ /dev/null
@@ -1,12 +0,0 @@
------BEGIN DSA PRIVATE KEY-----
-MIIBuwIBAAKBgQDngaYDZ30c6/7cJgEEbtl8FgKdwhba1Z7oOrOn4MI/6C42G1bY
-wMuqZf4dBCglsdq39SHrcjbE8Vq54gPSOh3g4+uV9Rcg5IOoPLbwp2jQfF6f1FIb
-sx7hrDCIqUcQccPSxetPBKmXI9RN8rZLaFuQeTnI65BKM98Ruwvq6SI2LwIVAPDP
-hSeawaJI27mKqOfe5PPBSmyHAoGBAJMXxXmPD9sGaQ419DIpmZecJKBUAy9uXD8x
-gbgeDpwfDaFJP8owByCKREocPFfi86LjCuQkyUKOfjYMN6iHIf1oEZjB8uJAatUr
-FzI0ArXtUqOhwTLwTyFuUojE5own2WYsOAGByvgfyWjsGhvckYNhI4ODpNdPlxQ8
-ZamaPGPsAoGARmR7CCPjodxASvRbIyzaVpZoJ/Z6x7dAumV+ysrV1BVYd0lYukmn
-jO1kKBWApqpH1ve9XDQYN8zgxM4b16L21kpoWQnZtXrY3GZ4/it9kUgyB7+NwacI
-BlXa8cMDL7Q/69o0d54U0X/NeX5QxuYR6OMJlrkQB7oiW/P/1mwjQgECFGI9QPSc
-h9pT9XHqn+1rZ4bK+QGA
------END DSA PRIVATE KEY-----
diff --git a/tests/_support/dss.key-cert.pub b/tests/_support/dss.key-cert.pub
deleted file mode 100644
index 07fd5578..00000000
--- a/tests/_support/dss.key-cert.pub
+++ /dev/null
@@ -1 +0,0 @@
-ssh-dss-cert-v01@openssh.com AAAAHHNzaC1kc3MtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgJA3GjLmg6JbIWxokW/c827lmPOSvSfPDIY586yICFqIAAACBAOeBpgNnfRzr/twmAQRu2XwWAp3CFtrVnug6s6fgwj/oLjYbVtjAy6pl/h0EKCWx2rf1IetyNsTxWrniA9I6HeDj65X1FyDkg6g8tvCnaNB8Xp/UUhuzHuGsMIipRxBxw9LF608EqZcj1E3ytktoW5B5OcjrkEoz3xG7C+rpIjYvAAAAFQDwz4UnmsGiSNu5iqjn3uTzwUpshwAAAIEAkxfFeY8P2wZpDjX0MimZl5wkoFQDL25cPzGBuB4OnB8NoUk/yjAHIIpEShw8V+LzouMK5CTJQo5+Ngw3qIch/WgRmMHy4kBq1SsXMjQCte1So6HBMvBPIW5SiMTmjCfZZiw4AYHK+B/JaOwaG9yRg2Ejg4Ok10+XFDxlqZo8Y+wAAACARmR7CCPjodxASvRbIyzaVpZoJ/Z6x7dAumV+ysrV1BVYd0lYukmnjO1kKBWApqpH1ve9XDQYN8zgxM4b16L21kpoWQnZtXrY3GZ4/it9kUgyB7+NwacIBlXa8cMDL7Q/69o0d54U0X/NeX5QxuYR6OMJlrkQB7oiW/P/1mwjQgEAAAAAAAAAAAAAAAEAAAAJdXNlcl90ZXN0AAAACAAAAAR0ZXN0AAAAAAAAAAD//////////wAAAAAAAACCAAAAFXBlcm1pdC1YMTEtZm9yd2FyZGluZwAAAAAAAAAXcGVybWl0LWFnZW50LWZvcndhcmRpbmcAAAAAAAAAFnBlcm1pdC1wb3J0LWZvcndhcmRpbmcAAAAAAAAACnBlcm1pdC1wdHkAAAAAAAAADnBlcm1pdC11c2VyLXJjAAAAAAAAAAAAAAEXAAAAB3NzaC1yc2EAAAADAQABAAABAQDskr46Umjxh3wo7PoPQsSVS3xt6+5PhwmXrnVtBBnkOo+zHRwQo8G8sY+Lc6oOOzA5GCSawKOwqE305GIDfB8/L9EKOkAjdN18imDjw/YuJFA4bl9yFhsXrCb1GZPJw0pJ0H0Eid9EldyMQAhGE49MWvnFMQl1TgO6YWq/g71xAFimge0LvVWijlbMy7O+nsGxSpinIprV5S9Viv8XC/ku89tadZfca1uxq751aGfAWGeYrVytpUl8UO0ggqH6BaUvkDU7rWh2n5RHUTvgzceKWnz5wqd8BngK37WmJjAgCtHCJS5ZRf6oJGj2QVcqc6cjvEFWsCuOKB4KAjktauWxAAABDwAAAAdzc2gtcnNhAAABAK6jweL231fRhFoybEGTOXJfj0lx55KpDsw9Q1rBvZhrSgwUr2dFr9HVcKe44mTC7CMtdW5VcyB67l1fnMil/D/e4zYxI0PvbW6RxLFNqvvtxBu5sGt5B7uzV4aAV31TpWR0l5RwwpZqc0NUlTx7oMutN1BDrPqW70QZ/iTEwalkn5fo1JWej0cf4BdC9VgYDLnprx0KN3IToukbszRQySnuR6MQUfj0m7lUloJfF3rq8G0kNxWqDGoJilMhO5Lqu9wAhlZWdouypI6bViO6+ToCVixLNUYs3EfS1zCxvXpiyMvh6rZofJ6WqzUuSd4Mzb2Ka4ocTKi7kynF+OG0Ivo= tests/test_dss.key.pub
diff --git a/tests/_util.py b/tests/_util.py
index a3f82e09..db5a1e99 100644
--- a/tests/_util.py
+++ b/tests/_util.py
@@ -10,12 +10,12 @@ import unittest
 import time
 import threading
 
+from paramiko import Ed25519Key
 import pytest
 
 from paramiko import (
     ServerInterface,
     RSAKey,
-    DSSKey,
     AUTH_FAILED,
     AUTH_PARTIALLY_SUCCESSFUL,
     AUTH_SUCCESSFUL,
@@ -211,8 +211,7 @@ unicodey = "\u2022"
 class TestServer(ServerInterface):
     paranoid_did_password = False
     paranoid_did_public_key = False
-    # TODO: make this ed25519 or something else modern? (_is_ this used??)
-    paranoid_key = DSSKey.from_private_key_file(_support("dss.key"))
+    paranoid_key = Ed25519Key.from_private_key_file(_support("ed25519.key"))
 
     def __init__(self, allowed_keys=None):
         self.allowed_keys = allowed_keys if allowed_keys is not None else []
diff --git a/tests/auth.py b/tests/auth.py
index c0afe889..7341de38 100644
--- a/tests/auth.py
+++ b/tests/auth.py
@@ -7,6 +7,7 @@ Thus, they concern AuthHandler and AuthStrategy, with a side of Transport.
 from logging import Logger
 from unittest.mock import Mock
 
+from paramiko import Ed25519Key
 from pytest import raises
 
 from paramiko import (
@@ -17,7 +18,6 @@ from paramiko import (
     AuthSource,
     AuthStrategy,
     BadAuthenticationType,
-    DSSKey,
     InMemoryPrivateKey,
     NoneAuth,
     OnDiskPrivateKey,
@@ -85,7 +85,7 @@ class AuthHandler_:
             assert tc.auth_password(
                 username="paranoid", password="paranoid"
             ) == ["publickey"]
-            key = DSSKey.from_private_key_file(_support("dss.key"))
+            key = Ed25519Key.from_private_key_file(_support("ed25519.key"))
             assert tc.auth_publickey(username="paranoid", key=key) == []
 
     def interactive_auth(self):
diff --git a/tests/conftest.py b/tests/conftest.py
index 12b97283..9073a380 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -11,7 +11,6 @@ from paramiko import (
     SFTPServer,
     SFTP,
     Transport,
-    DSSKey,
     RSAKey,
     Ed25519Key,
     ECDSAKey,
@@ -121,7 +120,6 @@ def sftp(sftp_server):
 
 key_data = [
     ["ssh-rsa", RSAKey, "SHA256:OhNL391d/beeFnxxg18AwWVYTAHww+D4djEE7Co0Yng"],
-    ["ssh-dss", DSSKey, "SHA256:uHwwykG099f4M4kfzvFpKCTino0/P03DRbAidpAmPm0"],
     [
         "ssh-ed25519",
         Ed25519Key,
diff --git a/tests/pkey.py b/tests/pkey.py
index 691fda0f..fdd657ae 100644
--- a/tests/pkey.py
+++ b/tests/pkey.py
@@ -5,7 +5,6 @@ from pytest import raises
 
 from cryptography.hazmat.primitives.asymmetric.ed448 import Ed448PrivateKey
 from paramiko import (
-    DSSKey,
     ECDSAKey,
     Ed25519Key,
     Message,
@@ -170,8 +169,6 @@ class PKey_:
         key = keys.pkey
         if isinstance(key, RSAKey):
             assert key.algorithm_name == "RSA"
-        elif isinstance(key, DSSKey):
-            assert key.algorithm_name == "DSS"
         elif isinstance(key, ECDSAKey):
             assert key.algorithm_name == "ECDSA"
         elif isinstance(key, Ed25519Key):
@@ -215,9 +212,6 @@ class PKey_:
                 "rsa-sha2-512-cert-v01@openssh.com",
             ]
 
-        def dss_is_protocol_name(self):
-            assert DSSKey.identifiers() == ["ssh-dss"]
-
         def ed25519_is_protocol_name(self):
             assert Ed25519Key.identifiers() == ["ssh-ed25519"]
 
diff --git a/tests/test_client.py b/tests/test_client.py
index 1c0c6c84..accb16aa 100644
--- a/tests/test_client.py
+++ b/tests/test_client.py
@@ -49,7 +49,6 @@ requires_gss_auth = unittest.skipUnless(
 )
 
 FINGERPRINTS = {
-    "ssh-dss": b"\x44\x78\xf0\xb9\xa2\x3c\xc5\x18\x20\x09\xff\x75\x5b\xc1\xd2\x6c",  # noqa
     "ssh-rsa": b"\x60\x73\x38\x44\xcb\x51\x86\x65\x7f\xde\xda\xa2\x2b\x5a\x57\xd5",  # noqa
     "ecdsa-sha2-nistp256": b"\x25\x19\xeb\x55\xe6\xa1\x47\xff\x4f\x38\xd2\x75\x6f\xa5\xd5\x60",  # noqa
     "ssh-ed25519": b'\xb3\xd5"\xaa\xf9u^\xe8\xcd\x0e\xea\x02\xb9)\xa2\x80',
@@ -249,13 +248,6 @@ class SSHClientTest(ClientTest):
         """
         self._test_connection(password="pygmalion")
 
-    @requires_sha1_signing
-    def test_client_dsa(self):
-        """
-        verify that SSHClient works with a DSA key.
-        """
-        self._test_connection(key_filename=_support("dss.key"))
-
     @requires_sha1_signing
     def test_client_rsa(self):
         """
@@ -282,16 +274,25 @@ class SSHClientTest(ClientTest):
         # This is dumb :(
         types_ = {
             "rsa": "ssh-rsa",
-            "dss": "ssh-dss",
+            "ed25519": "ssh-ed25519",
             "ecdsa": "ecdsa-sha2-nistp256",
         }
         # Various combos of attempted & valid keys
         # TODO: try every possible combo using itertools functions
         # TODO: use new key(s) fixture(s)
         for attempt, accept in (
-            (["rsa", "dss"], ["dss"]),  # Original test #3
-            (["dss", "rsa"], ["dss"]),  # Ordering matters sometimes, sadly
-            (["dss", "rsa", "ecdsa-256"], ["dss"]),  # Try ECDSA but fail
+            (
+                ["rsa", "ed25519"],
+                ["ed25519"],
+            ),  # Original test #3 (but s/DSA/Ed25519/)
+            (
+                ["ed25519", "rsa"],
+                ["ed25519"],
+            ),  # Ordering matters sometimes, sadly
+            (
+                ["ed25519", "rsa", "ecdsa-256"],
+                ["ed25519"],
+            ),  # Try ECDSA but fail
             (["rsa", "ecdsa-256"], ["ecdsa"]),  # ECDSA success
         ):
             try:
@@ -327,7 +328,7 @@ class SSHClientTest(ClientTest):
         # They're similar except for which path is given; the expected auth and
         # server-side behavior is 100% identical.)
         # NOTE: only bothered whipping up one cert per overall class/family.
-        for type_ in ("rsa", "dss", "ecdsa-256", "ed25519"):
+        for type_ in ("rsa", "ecdsa-256", "ed25519"):
             key_path = _support(f"{type_}.key")
             self._test_connection(
                 key_filename=key_path,
@@ -342,7 +343,7 @@ class SSHClientTest(ClientTest):
         # about the server-side key object's public blob. Thus, we can prove
         # that a specific cert was found, along with regular authorization
         # succeeding proving that the overall flow works.
-        for type_ in ("rsa", "dss", "ecdsa-256", "ed25519"):
+        for type_ in ("rsa", "ecdsa-256", "ed25519"):
             key_path = _support(f"{type_}.key")
             self._test_connection(
                 key_filename=key_path,
@@ -746,10 +747,10 @@ class SSHClientTest(ClientTest):
             "host",
             sock=Mock(),
             password="no",
-            disabled_algorithms={"keys": ["ssh-dss"]},
+            disabled_algorithms={"keys": ["ssh-rsa"]},
         )
         call_arg = Transport.call_args[1]["disabled_algorithms"]
-        assert call_arg == {"keys": ["ssh-dss"]}
+        assert call_arg == {"keys": ["ssh-rsa"]}
 
     @patch("paramiko.client.Transport")
     def test_transport_factory_defaults_to_Transport(self, Transport):
diff --git a/tests/test_config.py b/tests/test_config.py
index 1e623e0a..c3003803 100644
--- a/tests/test_config.py
+++ b/tests/test_config.py
@@ -309,36 +309,36 @@ ProxyCommand foo=bar:%h-%p
         getpass.getuser.return_value = "gandalf"
         config = SSHConfig.from_text(
             """
-IdentityFile id_dsa0
+IdentityFile id_rsa0
 
 Host *
-IdentityFile id_dsa1
+IdentityFile id_rsa1
 
-Host dsa2
-IdentityFile id_dsa2
+Host rsa2
+IdentityFile id_rsa2
 
-Host dsa2*
-IdentityFile id_dsa22
+Host rsa2*
+IdentityFile id_rsa22
 
 Host hashbrowns
 IdentityFile %C
 """
         )
         for host, values in {
-            "foo": {"hostname": "foo", "identityfile": ["id_dsa0", "id_dsa1"]},
-            "dsa2": {
-                "hostname": "dsa2",
-                "identityfile": ["id_dsa0", "id_dsa1", "id_dsa2", "id_dsa22"],
+            "foo": {"hostname": "foo", "identityfile": ["id_rsa0", "id_rsa1"]},
+            "rsa2": {
+                "hostname": "rsa2",
+                "identityfile": ["id_rsa0", "id_rsa1", "id_rsa2", "id_rsa22"],
             },
-            "dsa22": {
-                "hostname": "dsa22",
-                "identityfile": ["id_dsa0", "id_dsa1", "id_dsa22"],
+            "rsa22": {
+                "hostname": "rsa22",
+                "identityfile": ["id_rsa0", "id_rsa1", "id_rsa22"],
             },
             "hashbrowns": {
                 "hostname": "hashbrowns",
                 "identityfile": [
-                    "id_dsa0",
-                    "id_dsa1",
+                    "id_rsa0",
+                    "id_rsa1",
                     "a438e7dbf5308b923aba9db8fe2ca63447ac8688",
                 ],
             },
diff --git a/tests/test_dss_openssh.key b/tests/test_dss_openssh.key
deleted file mode 100644
index 2a9f8922..00000000
--- a/tests/test_dss_openssh.key
+++ /dev/null
@@ -1,22 +0,0 @@
------BEGIN OPENSSH PRIVATE KEY-----
-b3BlbnNzaC1rZXktdjEAAAAACmFlczI1Ni1jdHIAAAAGYmNyeXB0AAAAGAAAABAsyq4pxL
-R5sOprPDHGpvzxAAAAEAAAAAEAAAGxAAAAB3NzaC1kc3MAAACBAL8XEx7F9xuwBNles+vW
-pNF+YcofrBhjX1r5QhpBe0eoYWLHRcroN6lxwCdGYRfgOoRjTncBiixQX/uUxAY96zDh3i
-r492s2BcJt4ihvNn/AY0I0OTuX/2IwGk9CGzafjaeZNVYxMa8lcVt0hSOTjkPQ7gVuk6bJ
-zMInvie+VWKLAAAAFQDUgYdY+rhR0SkKbC09BS/SIHcB+wAAAIB44+4zpCNcd0CGvZlowH
-99zyPX8uxQtmTLQFuR2O8O0FgVVuCdDgD0D9W8CLOp32oatpM0jyyN89EdvSWzjHzZJ+L6
-H1FtZps7uhpDFWHdva1R25vyGecLMUuXjo5t/D7oCDih+HwHoSAxoi0QvsPd8/qqHQVznN
-JKtR6thUpXEwAAAIAG4DCBjbgTTgpBw0egRkJwBSz0oTt+1IcapNU2jA6N8urMSk9YXHEQ
-HKN68BAF3YJ59q2Ujv3LOXmBqGd1T+kzwUszfMlgzq8MMu19Yfzse6AIK1Agn1Vj6F7YXL
-sXDN+T4KszX5+FJa7t/Zsp3nALWy6l0f4WKivEF5Y2QpEFcQAAAgCH6XUl1hYWB6kgCSHV
-a4C+vQHrgFNgNwEQnE074LXHXlAhxC+Dm8XTGqVPX1KRPWzadq9/+v6pqLFqiRueB86uRb
-J5WtAbUs3WwxAaC5Mi+mn42MBfL9PIwWPWCvstrAq9Nyj3EBMeX3XFLxN3RuGXIQnY/5rF
-f5hriUVxhWDQGIVbBKhkpn7Geqg6nLpn7iqQhzFmFGjPmAdrllgdVGJRLyIN6BRsaltDdy
-vxufkvGzKudvQ85QvsaoFJQ6K1d0S7907pexvxmWpcO7zchXb6i09BITWOAKIcHpVkbNQw
-+8pzSdpggsAwCRbfk/Jkezz8sXVUCfmmJ23NFUw04/0ZbilCADRsUaPfafgVPeDznBnuCm
-tfXa4JSrVUvPdwoex3SKZmYsFXwsuOEQnFkhUGHfWwTbmOmxzy6dtC24KYhnWG5OGFVJXh
-3B8jQJGGs2ANfusI/Z0o15tAnQy5fqsLf9TT3RX7RG2ujIiDBsU+A1g//IXmSxxkUOQMZs
-v+cMI8KfODAXmQtB30+yAgoV03Zb/bdptv+HqPT4eeecstJUxzEGYADt1mDq3uV7fQbNmo
-80bppU52JjztrJb7hBmXsXHPRRK6spQ1FCatqvu1ggZeXZpEifNsHeqCljt87ueXsQsORY
-pvhLzjTbTKZmjLDPuB+GxUNLEKh1ZNyAqKng==
------END OPENSSH PRIVATE KEY-----
diff --git a/tests/test_dss_password.key b/tests/test_dss_password.key
deleted file mode 100644
index e2a9bc50..00000000
--- a/tests/test_dss_password.key
+++ /dev/null
@@ -1,15 +0,0 @@
------BEGIN DSA PRIVATE KEY-----
-Proc-Type: 4,ENCRYPTED
-DEK-Info: DES-EDE3-CBC,78DAEB836ED0A646
-
-ldWkq9OMlXqWmjIqppNnmNPIUj5uVT12LkBosTApTbibTme3kIJb1uDeG2BShVfY
-+vDOTUE9koGPDLsxW1t5At+EVyIDK8aIO0uHteXM5AbBX20LLUWRbRVqZhsMxqQh
-3H3XlHiN+QhaWcb4fFuu18a8SkimTFpDnZuffoCDl/zh/B7XieARTLA805K/ZgVB
-BBwflkR2BE053XHrJAIx9BEUlLP76Fo18rvjLZOSeu3s+VnnhqUb5FCt5h50a46u
-YXQBbo2r9Zo1ilGMNEXJO0gk5hwGVmTySz53NkPA5HmWt8NIzv5jQHMDy7N+ZykF
-uwpP1R5M/ZIFY4Y5h/lvn6IJjQ7VySRPIbpN8o2YJv2OD1Ja80n3tU8Mg77o3o4d
-NwKm7cCjlq+FuIBdOsSgsB8FPQRUhW+jpFDxmWN64DM2cEg6RUdptby7WmMp0HwK
-1qyEfxHjLMuDVlD7lASIDBrRlUjPtXEH1DzIYQuYaRZaixFoZ7EY+X73TwmrKFEU
-US9ZnQZtRtroRqGwR4fz4wQQsjTl/AmOijlBmi29taJccJsT/THrLQ5plOEd8OMv
-9FsaPJXBU85gaRKo3JZtrw==
------END DSA PRIVATE KEY-----
diff --git a/tests/test_hostkeys.py b/tests/test_hostkeys.py
index a028411d..4e5dab04 100644
--- a/tests/test_hostkeys.py
+++ b/tests/test_hostkeys.py
@@ -27,6 +27,8 @@ import unittest
 
 import paramiko
 
+from ._util import _support
+
 
 test_hosts_file = """\
 secure.example.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA1PD6U2/TVxET6lkpKhOk5r\
@@ -62,16 +64,6 @@ AAAAB3NzaC1yc2EAAAABIwAAAIEA8bP1ZA7DCZDB9J0s50l31MBGQ3GQ/Fc7SX6gkpXkwcZryoi4k\
 NFhHu5LvHcZPdxXV1D+uTMfGS1eyd2Yz/DoNWXNAl8TI0cAsW5ymME3bQ4J/k1IKxCtz/bAlAqFgK\
 oc+EolMziDYqWIATtW0rYTJvzGAzTmMj80/QpsFH+Pc2M="""
 
-keyblob_dss = b"""\
-AAAAB3NzaC1kc3MAAACBAOeBpgNnfRzr/twmAQRu2XwWAp3CFtrVnug6s6fgwj/oLjYbVtjAy6pl/\
-h0EKCWx2rf1IetyNsTxWrniA9I6HeDj65X1FyDkg6g8tvCnaNB8Xp/UUhuzHuGsMIipRxBxw9LF60\
-8EqZcj1E3ytktoW5B5OcjrkEoz3xG7C+rpIjYvAAAAFQDwz4UnmsGiSNu5iqjn3uTzwUpshwAAAIE\
-AkxfFeY8P2wZpDjX0MimZl5wkoFQDL25cPzGBuB4OnB8NoUk/yjAHIIpEShw8V+LzouMK5CTJQo5+\
-Ngw3qIch/WgRmMHy4kBq1SsXMjQCte1So6HBMvBPIW5SiMTmjCfZZiw4AYHK+B/JaOwaG9yRg2Ejg\
-4Ok10+XFDxlqZo8Y+wAAACARmR7CCPjodxASvRbIyzaVpZoJ/Z6x7dAumV+ysrV1BVYd0lYukmnjO\
-1kKBWApqpH1ve9XDQYN8zgxM4b16L21kpoWQnZtXrY3GZ4/it9kUgyB7+NwacIBlXa8cMDL7Q/69o\
-0d54U0X/NeX5QxuYR6OMJlrkQB7oiW/P/1mwjQgE="""
-
 
 class HostKeysTest(unittest.TestCase):
     def setUp(self):
@@ -118,8 +110,13 @@ class HostKeysTest(unittest.TestCase):
     def test_dict_set(self):
         hostdict = paramiko.HostKeys("hostfile.temp")
         key = paramiko.RSAKey(data=decodebytes(keyblob))
-        key_dss = paramiko.DSSKey(data=decodebytes(keyblob_dss))
-        hostdict["secure.example.com"] = {"ssh-rsa": key, "ssh-dss": key_dss}
+        key_ed25519 = paramiko.Ed25519Key.from_private_key_file(
+            _support("ed25519.key")
+        )
+        hostdict["secure.example.com"] = {
+            "ssh-rsa": key,
+            "ssh-ed25519": key_ed25519,
+        }
         hostdict["fake.example.com"] = {}
         hostdict["fake.example.com"]["ssh-rsa"] = key
 
@@ -132,9 +129,9 @@ class HostKeysTest(unittest.TestCase):
         ).upper()
         self.assertEqual(b"7EC91BB336CB6D810B124B1353C32396", fp)
         fp = hexlify(
-            hostdict["secure.example.com"]["ssh-dss"].get_fingerprint()
+            hostdict["secure.example.com"]["ssh-ed25519"].get_fingerprint()
         ).upper()
-        self.assertEqual(b"4478F0B9A23CC5182009FF755BC1D26C", fp)
+        self.assertEqual(b"B3D522AAF9755EE8CD0EEA02B929A280", fp)
 
     def test_delitem(self):
         hostdict = paramiko.HostKeys("hostfile.temp")
diff --git a/tests/test_pkey.py b/tests/test_pkey.py
index d4d193b8..92b4b270 100644
--- a/tests/test_pkey.py
+++ b/tests/test_pkey.py
@@ -30,7 +30,6 @@ from io import StringIO
 
 from paramiko import (
     RSAKey,
-    DSSKey,
     ECDSAKey,
     Ed25519Key,
     Message,
@@ -50,18 +49,15 @@ from ._util import _support, is_low_entropy, requires_sha1_signing
 
 # from openssh's ssh-keygen
 PUB_RSA = "ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAIEA049W6geFpmsljTwfvI1UmKWWJPNFI74+vNKTk4dmzkQY2yAMs6FhlvhlI8ysU4oj71ZsRYMecHbBbxdN79+JRFVYTKaLqjwGENeTd+yv4q+V2PvZv3fLnzApI3l7EJCqhWwJUHJ1jAkZzqDx0tyOL4uoZpww3nmE0kb3y21tH4c="  # noqa
-PUB_DSS = "ssh-dss AAAAB3NzaC1kc3MAAACBAOeBpgNnfRzr/twmAQRu2XwWAp3CFtrVnug6s6fgwj/oLjYbVtjAy6pl/h0EKCWx2rf1IetyNsTxWrniA9I6HeDj65X1FyDkg6g8tvCnaNB8Xp/UUhuzHuGsMIipRxBxw9LF608EqZcj1E3ytktoW5B5OcjrkEoz3xG7C+rpIjYvAAAAFQDwz4UnmsGiSNu5iqjn3uTzwUpshwAAAIEAkxfFeY8P2wZpDjX0MimZl5wkoFQDL25cPzGBuB4OnB8NoUk/yjAHIIpEShw8V+LzouMK5CTJQo5+Ngw3qIch/WgRmMHy4kBq1SsXMjQCte1So6HBMvBPIW5SiMTmjCfZZiw4AYHK+B/JaOwaG9yRg2Ejg4Ok10+XFDxlqZo8Y+wAAACARmR7CCPjodxASvRbIyzaVpZoJ/Z6x7dAumV+ysrV1BVYd0lYukmnjO1kKBWApqpH1ve9XDQYN8zgxM4b16L21kpoWQnZtXrY3GZ4/it9kUgyB7+NwacIBlXa8cMDL7Q/69o0d54U0X/NeX5QxuYR6OMJlrkQB7oiW/P/1mwjQgE="  # noqa
 PUB_ECDSA_256 = "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBJSPZm3ZWkvk/Zx8WP+fZRZ5/NBBHnGQwR6uIC6XHGPDIHuWUzIjAwA0bzqkOUffEsbLe+uQgKl5kbc/L8KA/eo="  # noqa
 PUB_ECDSA_384 = "ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAzODQAAABhBBbGibQLW9AAZiGN2hEQxWYYoFaWKwN3PKSaDJSMqmIn1Z9sgRUuw8Y/w502OGvXL/wFk0i2z50l3pWZjD7gfMH7gX5TUiCzwrQkS+Hn1U2S9aF5WJp0NcIzYxXw2r4M2A=="  # noqa
 PUB_ECDSA_521 = "ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1MjEAAACFBACaOaFLZGuxa5AW16qj6VLypFbLrEWrt9AZUloCMefxO8bNLjK/O5g0rAVasar1TnyHE9qj4NwzANZASWjQNbc4MAG8vzqezFwLIn/kNyNTsXNfqEko9OgHZknlj2Z79dwTJcRAL4QLcT5aND0EHZLB2fAUDXiWIb2j4rg1mwPlBMiBXA=="  # noqa
 PUB_RSA_2K_OPENSSH = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDF+Dpr54DX0WdeTDpNAMdkCWEkl3OXtNgf58qlN1gX572OLBqLf0zT4bHstUEpU3piazph/rSWcUMuBoD46tZ6jiH7H9b9Pem2eYQWaELDDkM+v9BMbEy5rMbFRLol5OtEvPFqneyEAanPOgvd8t3yyhSev9QVusakzJ8j8LGgrA8huYZ+Srnw0shEWLG70KUKCh3rG0QIvA8nfhtUOisr2Gp+F0YxMGb5gwBlQYAYE5l6u1SjZ7hNjyNosjK+wRBFgFFBYVpkZKJgWoK9w4ijFyzMZTucnZMqKOKAjIJvHfKBf2/cEfYxSq1EndqTqjYsd9T7/s2vcn1OH5a0wkER"  # noqa
 RSA_2K_OPENSSH_P = 161773687847617758886803946572654778625119997081005961935077336594287351354258259920334554906235187683459069634729972458348855793639393524799865799559575414247668746919721196359908321800753913350455861871582087986355637886875933045224711827701526739934602161222599672381604211130651397331775901258858869418853  # noqa
 RSA_2K_OPENSSH_Q = 154483416325630619558401349033571772244816915504195060221073502923720741119664820208064202825686848103224453777955988437823797692957091438442833606009978046057345917301441832647551208158342812551003395417862260727795454409459089912659057393394458150862012620127030757893820711157099494238156383382454310199869  # noqa
-PUB_DSS_1K_OPENSSH = "ssh-dss AAAAB3NzaC1kc3MAAACBAL8XEx7F9xuwBNles+vWpNF+YcofrBhjX1r5QhpBe0eoYWLHRcroN6lxwCdGYRfgOoRjTncBiixQX/uUxAY96zDh3ir492s2BcJt4ihvNn/AY0I0OTuX/2IwGk9CGzafjaeZNVYxMa8lcVt0hSOTjkPQ7gVuk6bJzMInvie+VWKLAAAAFQDUgYdY+rhR0SkKbC09BS/SIHcB+wAAAIB44+4zpCNcd0CGvZlowH99zyPX8uxQtmTLQFuR2O8O0FgVVuCdDgD0D9W8CLOp32oatpM0jyyN89EdvSWzjHzZJ+L6H1FtZps7uhpDFWHdva1R25vyGecLMUuXjo5t/D7oCDih+HwHoSAxoi0QvsPd8/qqHQVznNJKtR6thUpXEwAAAIAG4DCBjbgTTgpBw0egRkJwBSz0oTt+1IcapNU2jA6N8urMSk9YXHEQHKN68BAF3YJ59q2Ujv3LOXmBqGd1T+kzwUszfMlgzq8MMu19Yfzse6AIK1Agn1Vj6F7YXLsXDN+T4KszX5+FJa7t/Zsp3nALWy6l0f4WKivEF5Y2QpEFcQ=="  # noqa
 PUB_EC_384_OPENSSH = "ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAzODQAAABhBIch5LXTq/L/TWsTGG6dIktxD8DIMh7EfvoRmWsks6CuNDTvFvbQNtY4QO1mn5OXegHbS0M5DPIS++wpKGFP3suDEH08O35vZQasLNrL0tO2jyyEnzB2ZEx3PPYci811yg=="  # noqa
 
 FINGER_RSA = "1024 60:73:38:44:cb:51:86:65:7f:de:da:a2:2b:5a:57:d5"
-FINGER_DSS = "1024 44:78:f0:b9:a2:3c:c5:18:20:09:ff:75:5b:c1:d2:6c"
 FINGER_ECDSA_256 = "256 25:19:eb:55:e6:a1:47:ff:4f:38:d2:75:6f:a5:d5:60"
 FINGER_ECDSA_384 = "384 c1:8d:a0:59:09:47:41:8e:a8:a6:07:01:29:23:b4:65"
 FINGER_ECDSA_521 = "521 44:58:22:52:12:33:16:0e:ce:0e:be:2c:7c:7e:cc:1e"
@@ -69,7 +65,6 @@ SIGNED_RSA = "20:d7:8a:31:21:cb:f7:92:12:f2:a4:89:37:f5:78:af:e6:16:b6:25:b9:97:
 SIGNED_RSA_256 = "cc:6:60:e0:0:2c:ac:9e:26:bc:d5:68:64:3f:9f:a7:e5:aa:41:eb:88:4a:25:5:9c:93:84:66:ef:ef:60:f4:34:fb:f4:c8:3d:55:33:6a:77:bd:b2:ee:83:f:71:27:41:7e:f5:7:5:0:a9:4c:7:80:6f:be:76:67:cb:58:35:b9:2b:f3:c2:d3:3c:ee:e1:3f:59:e0:fa:e4:5c:92:ed:ae:74:de:d:d6:27:16:8f:84:a3:86:68:c:94:90:7d:6e:cc:81:12:d8:b6:ad:aa:31:a8:13:3d:63:81:3e:bb:5:b6:38:4d:2:d:1b:5b:70:de:83:cc:3a:cb:31"  # noqa
 SIGNED_RSA_512 = "87:46:8b:75:92:33:78:a0:22:35:32:39:23:c6:ab:e1:6:92:ad:bc:7f:6e:ab:19:32:e4:78:b2:2c:8f:1d:c:65:da:fc:a5:7:ca:b6:55:55:31:83:b1:a0:af:d1:95:c5:2e:af:56:ba:f5:41:64:f:39:9d:af:82:43:22:8f:90:52:9d:89:e7:45:97:df:f3:f2:bc:7b:3a:db:89:e:34:fd:18:62:25:1b:ef:77:aa:c6:6c:99:36:3a:84:d6:9c:2a:34:8c:7f:f4:bb:c9:a5:9a:6c:11:f2:cf:da:51:5e:1e:7f:90:27:34:de:b2:f3:15:4f:db:47:32:6b:a7"  # noqa
 FINGER_RSA_2K_OPENSSH = "2048 68:d1:72:01:bf:c0:0c:66:97:78:df:ce:75:74:46:d6"
-FINGER_DSS_1K_OPENSSH = "1024 cf:1d:eb:d7:61:d3:12:94:c6:c0:c6:54:35:35:b0:82"
 FINGER_EC_384_OPENSSH = "384 72:14:df:c1:9a:c3:e6:0e:11:29:d6:32:18:7b:ea:9b"
 
 RSA_PRIVATE_OUT = """\
@@ -90,21 +85,6 @@ nvuQES5C9BMHjF39LZiGH1iLQy7FgdHyoP+eodI7
 -----END RSA PRIVATE KEY-----
 """
 
-DSS_PRIVATE_OUT = """\
------BEGIN DSA PRIVATE KEY-----
-MIIBuwIBAAKBgQDngaYDZ30c6/7cJgEEbtl8FgKdwhba1Z7oOrOn4MI/6C42G1bY
-wMuqZf4dBCglsdq39SHrcjbE8Vq54gPSOh3g4+uV9Rcg5IOoPLbwp2jQfF6f1FIb
-sx7hrDCIqUcQccPSxetPBKmXI9RN8rZLaFuQeTnI65BKM98Ruwvq6SI2LwIVAPDP
-hSeawaJI27mKqOfe5PPBSmyHAoGBAJMXxXmPD9sGaQ419DIpmZecJKBUAy9uXD8x
-gbgeDpwfDaFJP8owByCKREocPFfi86LjCuQkyUKOfjYMN6iHIf1oEZjB8uJAatUr
-FzI0ArXtUqOhwTLwTyFuUojE5own2WYsOAGByvgfyWjsGhvckYNhI4ODpNdPlxQ8
-ZamaPGPsAoGARmR7CCPjodxASvRbIyzaVpZoJ/Z6x7dAumV+ysrV1BVYd0lYukmn
-jO1kKBWApqpH1ve9XDQYN8zgxM4b16L21kpoWQnZtXrY3GZ4/it9kUgyB7+NwacI
-BlXa8cMDL7Q/69o0d54U0X/NeX5QxuYR6OMJlrkQB7oiW/P/1mwjQgECFGI9QPSc
-h9pT9XHqn+1rZ4bK+QGA
------END DSA PRIVATE KEY-----
-"""
-
 ECDSA_PRIVATE_OUT_256 = """\
 -----BEGIN EC PRIVATE KEY-----
 MHcCAQEEIKB6ty3yVyKEnfF/zprx0qwC76MsMlHY4HXCnqho2eKioAoGCCqGSM49
@@ -196,33 +176,6 @@ class KeyTest(unittest.TestCase):
         self.assertEqual(PUB_RSA.split()[1], key.get_base64())
         self.assertEqual(1024, key.get_bits())
 
-    def test_load_dss(self):
-        key = DSSKey.from_private_key_file(_support("dss.key"))
-        self.assertEqual("ssh-dss", key.get_name())
-        exp_dss = b(FINGER_DSS.split()[1].replace(":", ""))
-        my_dss = hexlify(key.get_fingerprint())
-        self.assertEqual(exp_dss, my_dss)
-        self.assertEqual(PUB_DSS.split()[1], key.get_base64())
-        self.assertEqual(1024, key.get_bits())
-
-        s = StringIO()
-        key.write_private_key(s)
-        self.assertEqual(DSS_PRIVATE_OUT, s.getvalue())
-        s.seek(0)
-        key2 = DSSKey.from_private_key(s)
-        self.assertEqual(key, key2)
-
-    def test_load_dss_password(self):
-        key = DSSKey.from_private_key_file(
-            _support("test_dss_password.key"), "television"
-        )
-        self.assertEqual("ssh-dss", key.get_name())
-        exp_dss = b(FINGER_DSS.split()[1].replace(":", ""))
-        my_dss = hexlify(key.get_fingerprint())
-        self.assertEqual(exp_dss, my_dss)
-        self.assertEqual(PUB_DSS.split()[1], key.get_base64())
-        self.assertEqual(1024, key.get_bits())
-
     def test_compare_rsa(self):
         # verify that the private & public keys compare equal
         key = RSAKey.from_private_key_file(_support("rsa.key"))
@@ -232,15 +185,6 @@ class KeyTest(unittest.TestCase):
         self.assertTrue(not pub.can_sign())
         self.assertEqual(key, pub)
 
-    def test_compare_dss(self):
-        # verify that the private & public keys compare equal
-        key = DSSKey.from_private_key_file(_support("dss.key"))
-        self.assertEqual(key, key)
-        pub = DSSKey(data=key.asbytes())
-        self.assertTrue(key.can_sign())
-        self.assertTrue(not pub.can_sign())
-        self.assertEqual(key, pub)
-
     def _sign_and_verify_rsa(self, algorithm, saved_sig):
         key = RSAKey.from_private_key_file(_support("rsa.key"))
         msg = key.sign_ssh_data(b"ice weasels", algorithm)
@@ -265,21 +209,6 @@ class KeyTest(unittest.TestCase):
     def test_sign_and_verify_rsa_sha2_256(self):
         self._sign_and_verify_rsa("rsa-sha2-256", SIGNED_RSA_256)
 
-    def test_sign_dss(self):
-        # verify that the dss private key can sign and verify
-        key = DSSKey.from_private_key_file(_support("dss.key"))
-        msg = key.sign_ssh_data(b"ice weasels")
-        self.assertTrue(type(msg) is Message)
-        msg.rewind()
-        self.assertEqual("ssh-dss", msg.get_text())
-        # can't do the same test as we do for RSA, because DSS signatures
-        # are usually different each time.  but we can test verification
-        # anyway so it's ok.
-        self.assertEqual(40, len(msg.get_binary()))
-        msg.rewind()
-        pub = DSSKey(data=key.asbytes())
-        self.assertTrue(pub.verify_ssh_sig(b"ice weasels", msg))
-
     @requires_sha1_signing
     def test_generate_rsa(self):
         key = RSAKey.generate(1024)
@@ -287,12 +216,6 @@ class KeyTest(unittest.TestCase):
         msg.rewind()
         self.assertTrue(key.verify_ssh_sig(b"jerri blank", msg))
 
-    def test_generate_dss(self):
-        key = DSSKey.generate(1024)
-        msg = key.sign_ssh_data(b"jerri blank")
-        msg.rewind()
-        self.assertTrue(key.verify_ssh_sig(b"jerri blank", msg))
-
     def test_generate_ecdsa(self):
         key = ECDSAKey.generate()
         msg = key.sign_ssh_data(b"jerri blank")
@@ -365,9 +288,8 @@ class KeyTest(unittest.TestCase):
         self.assertTrue(type(msg) is Message)
         msg.rewind()
         self.assertEqual("ecdsa-sha2-nistp256", msg.get_text())
-        # ECDSA signatures, like DSS signatures, tend to be different
-        # each time, so we can't compare against a "known correct"
-        # signature.
+        # ECDSA signatures tend to be different each time, so we can't compare
+        # against a "known correct" signature.
         # Even the length of the signature can change.
 
         msg.rewind()
@@ -428,9 +350,8 @@ class KeyTest(unittest.TestCase):
         self.assertTrue(type(msg) is Message)
         msg.rewind()
         self.assertEqual("ecdsa-sha2-nistp384", msg.get_text())
-        # ECDSA signatures, like DSS signatures, tend to be different
-        # each time, so we can't compare against a "known correct"
-        # signature.
+        # ECDSA signatures tend to be different each time, so we can't compare
+        # against a "known correct" signature.
         # Even the length of the signature can change.
 
         msg.rewind()
@@ -483,9 +404,8 @@ class KeyTest(unittest.TestCase):
         self.assertTrue(type(msg) is Message)
         msg.rewind()
         self.assertEqual("ecdsa-sha2-nistp521", msg.get_text())
-        # ECDSA signatures, like DSS signatures, tend to be different
-        # each time, so we can't compare against a "known correct"
-        # signature.
+        # ECDSA signatures tend to be different each time, so we can't compare
+        # against a "known correct" signature.
         # Even the length of the signature can change.
 
         msg.rewind()
@@ -518,17 +438,6 @@ class KeyTest(unittest.TestCase):
             assert kwargs["p"] == RSA_2K_OPENSSH_P
             assert kwargs["q"] == RSA_2K_OPENSSH_Q
 
-    def test_load_openssh_format_DSS_key(self):
-        key = DSSKey.from_private_key_file(
-            _support("test_dss_openssh.key"), b"television"
-        )
-        self.assertEqual("ssh-dss", key.get_name())
-        self.assertEqual(PUB_DSS_1K_OPENSSH.split()[1], key.get_base64())
-        self.assertEqual(1024, key.get_bits())
-        exp_rsa = b(FINGER_DSS_1K_OPENSSH.split()[1].replace(":", ""))
-        my_rsa = hexlify(key.get_fingerprint())
-        self.assertEqual(exp_rsa, my_rsa)
-
     def test_load_openssh_format_EC_key(self):
         key = ECDSAKey.from_private_key_file(
             _support("test_ecdsa_384_openssh.key"), b"television"
diff --git a/tests/test_transport.py b/tests/test_transport.py
index 54e1f206..623dff00 100644
--- a/tests/test_transport.py
+++ b/tests/test_transport.py
@@ -1108,7 +1108,7 @@ class AlgorithmDisablingTests(unittest.TestCase):
             disabled_algorithms={
                 "ciphers": ["aes128-cbc"],
                 "macs": ["hmac-md5"],
-                "keys": ["ssh-dss"],
+                "keys": ["ssh-rsa"],
                 "kex": ["diffie-hellman-group14-sha256"],
             },
         )
@@ -1116,9 +1116,9 @@ class AlgorithmDisablingTests(unittest.TestCase):
         assert "aes128-cbc" not in t.preferred_ciphers
         assert "hmac-md5" in t._preferred_macs
         assert "hmac-md5" not in t.preferred_macs
-        assert "ssh-dss" in t._preferred_keys
-        assert "ssh-dss" not in t.preferred_keys
-        assert "ssh-dss-cert-v01@openssh.com" not in t.preferred_keys
+        assert "ssh-rsa" in t._preferred_keys
+        assert "ssh-rsa" not in t.preferred_keys
+        assert "ssh-rsa-cert-v01@openssh.com" not in t.preferred_keys
         assert "diffie-hellman-group14-sha256" in t._preferred_kex
         assert "diffie-hellman-group14-sha256" not in t.preferred_kex
 
@@ -1128,7 +1128,7 @@ class AlgorithmDisablingTests(unittest.TestCase):
             disabled_algorithms={
                 "ciphers": ["aes128-cbc"],
                 "macs": ["hmac-md5"],
-                "keys": ["ssh-dss"],
+                "keys": ["ssh-rsa"],
                 "kex": ["diffie-hellman-group14-sha256"],
                 "compression": ["zlib"],
             },
@@ -1157,7 +1157,7 @@ class AlgorithmDisablingTests(unittest.TestCase):
         # included (as this message includes the full lists)
         assert "aes128-cbc" not in ciphers
         assert "hmac-md5" not in macs
-        assert "ssh-dss" not in server_keys
+        assert "ssh-rsa" not in server_keys
         assert "diffie-hellman-group14-sha256" not in kexen
         assert "zlib" not in compressions
 
@@ -1243,7 +1243,7 @@ class TestExtInfo(unittest.TestCase):
             # data stored on Transport after hearing back from a compatible
             # server (such as ourselves in server mode)
             assert tc.server_extensions == {
-                "server-sig-algs": b"ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss"  # noqa
+                "server-sig-algs": b"ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,rsa-sha2-512,rsa-sha2-256,ssh-rsa"  # noqa
             }
 
     def test_client_uses_server_sig_algs_for_pubkey_auth(self):
diff --git a/tests/test_util.py b/tests/test_util.py
index a2a8224e..050483ef 100644
--- a/tests/test_util.py
+++ b/tests/test_util.py
@@ -61,7 +61,8 @@ class UtilTest(unittest.TestCase):
             "ChannelException",
             "ConfigParseError",
             "CouldNotCanonicalize",
-            "DSSKey",
+            "ECDSAKey",
+            "Ed25519Key",
             "HostKeys",
             "InMemoryPrivateKey",
             "Message",
